/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

/*
License obsidian-tasks:
MIT License

Copyright (c) 2021 Martin Schenck and Clare Macrae

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
License rrule (included library):
rrule.js: Library for working with recurrence rules for calendar dates.
=======================================================================

Copyright 2010, Jakub Roztocil <jakub@roztocil.name> and Lars Schöning

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of The author nor the names of its contributors may
       be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



./rrule.js and ./test/tests.js is based on python-dateutil. LICENCE:

python-dateutil - Extensions to the standard Python datetime module.
====================================================================

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
License chrono-node (included library):
The MIT License

Copyright (c) 2014, Wanasit Tanakitrungruang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, g = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function(t2, e2, n2) {
        var r2;
        if (!t2)
          return D;
        if ("string" == typeof t2)
          v[t2] && (r2 = t2), e2 && (v[t2] = e2, r2 = t2);
        else {
          var i2 = t2.name;
          v[i2] = t2, r2 = i2;
        }
        return !n2 && r2 && (D = r2), r2 || !n2 && D;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match(l);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), $2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, l2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $2(1, 0) : $2(31, 11);
            case f:
              return r2 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
              return $2(r2 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $2 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y2 = function(t2) {
            var e2 = w($2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || $;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || l2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b = _.prototype;
      return w.prototype = b, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        b[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault(require_quarterOfYear());
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference, knownComponents) {
        this.reference = reference;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        return new Date(date.getTime() + this.getSystemTimezoneAdjustmentMinute(date) * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      getSystemTimezoneAdjustmentMinute(date) {
        var _a, _b;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_b = (_a = this.get("timezoneOffset")) !== null && _a !== void 0 ? _a : this.reference.timezoneOffset) !== null && _b !== void 0 ? _b : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
      static createRelativeFromReference(reference, fragments) {
        let date = dayjs_1.default(reference.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference, index, text2, start, end) {
        this.reference = reference;
        this.refDate = reference.instant;
        this.index = index;
        this.text = text2;
        this.start = start || new ParsingComponents(reference);
        this.end = end;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context) {
        const innerPattern = this.innerPattern(context);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i = 2; i < match.length; i++) {
          match[i - 1] = match[i];
        }
        return this.innerExtract(context, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context, match) {
        const startComponents = this.extractPrimaryTimeComponents(context, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text2 = match[0].substring(match[1].length);
        const result = context.createParsingResult(index, text2, startComponents);
        match.index += match[0].length;
        const remainingText = context.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text2.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context, match, strict = false) {
        const components = context.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context, match, result) {
        const components = context.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter2 = class {
      refine(context, results) {
        return results.filter((r) => this.isValid(context, r));
      }
    };
    exports.Filter = Filter2;
    var MergingRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i = 1; i < results.length; i++) {
          nextResult = results[i];
          const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left = curResult;
            const right = nextResult;
            const mergedResult = this.mergeResults(textBetween, left, right, context);
            context.debug(() => {
              console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context, results) {
        var _a;
        const timezoneOverrides = (_a = context.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i = 1; i < results.length; i++) {
          const result = results[i];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context, results) {
        if (!context.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
              result.start.imply("year", result.start.get("year") + 1);
              context.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context, result);
        }
        return true;
      }
      isStrictModeValid(context, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset2 = hourOffset * 60;
            if (offset2 < 0) {
              offset2 -= minuteOffset;
            } else {
              offset2 += minuteOffset;
            }
            components["timezoneOffset"] = offset2;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference) {
      return theDayBefore(reference, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference, numDay) {
      return theDayAfter(reference, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference) {
      return theDayAfter(reference, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference, nDays) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference, implyHour = 22) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference, implyHour = 0) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference, implyHour = 20) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context.reference);
          case "today":
            return references.today(context.reference);
          case "yesterday":
            return references.yesterday(context.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context.reference);
          case "tonight":
            return references.tonight(context.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/calculation/weeks.js
var require_weeks = __commonJS({
  "node_modules/chrono-node/dist/calculation/weeks.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDayJSClosestWeekday = exports.toDayJSWeekday = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function toDayJSWeekday(refDate, offset2, modifier) {
      if (!modifier) {
        return toDayJSClosestWeekday(refDate, offset2);
      }
      let date = dayjs_1.default(refDate);
      switch (modifier) {
        case "this":
          date = date.day(offset2);
          break;
        case "next":
          date = date.day(offset2 + 7);
          break;
        case "last":
          date = date.day(offset2 - 7);
          break;
      }
      return date;
    }
    exports.toDayJSWeekday = toDayJSWeekday;
    function toDayJSClosestWeekday(refDate, offset2) {
      let date = dayjs_1.default(refDate);
      const refOffset = date.day();
      if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        date = date.day(offset2 - 7);
      } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        date = date.day(offset2 + 7);
      } else {
        date = date.day(offset2);
      }
      return date;
    }
    exports.toDayJSClosestWeekday = toDayJSClosestWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text2, referenceDate, option) {
        const results = this.parse(text2, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text2, referenceDate, option) {
        const context = new ParsingContext(text2, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a, b) => {
          return a.index - b.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context, results);
        });
        return results;
      }
      static executeParser(context, parser) {
        const results = [];
        const pattern = parser.pattern(context);
        const originalText = context.text;
        let remainingText = context.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context.createParsingResult(match.index, match[0], result);
          }
          context.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text2, refDate, option) {
        this.text = text2;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text2 = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start = startComponents ? this.createParsingComponents(startComponents) : null;
        const end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text2, start, end);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text2 = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text2.match(/^\d\.\d$/) || text2.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context.createParsingResult(index, text2);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var references = __importStar(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context.reference);
            break;
          case "heute":
            component = references.today(context.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context.reference);
          case "aujourd'hui":
            return references.today(context.reference);
          case "hier":
            return references.yesterday(context.reference);
          case "demain":
            return references.tomorrow(context.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset2 === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text2) {
      return String(text2).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment = dayjs_1.default(context.refDate);
          components.assign("year", moment.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const text2 = match[0];
        const date = dayjs_1.default(context.refDate);
        const components = context.createParsingComponents();
        switch (text2) {
          case "\u6628\u65E5":
            return references.yesterday(context.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context.reference);
        }
        if (text2 == "\u4ECA\u591C" || text2 == "\u4ECA\u5915" || text2 == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text2.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset2 === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context.reference);
          case "hoje":
            return references.today(context.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context.reference);
          case "ontem":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_2.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context.reference);
          case "vandaag":
            return references.today(context.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context.reference);
          case "gisteren":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context.refDate.getDate());
          component.assign("month", context.refDate.getMonth() + 1);
          component.assign("year", context.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = context.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context.createParsingComponents();
        const targetDate = dayjs_2.default(context.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u5E7E") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset2 - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset2 + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset2);
        } else {
          if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 - 7);
          } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 + 7);
          } else {
            startMoment = startMoment.day(offset2);
          }
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 - 7);
        } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 + 7);
        } else {
          startMoment = startMoment.day(offset2);
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u51E0") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset2 - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset2 + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset2);
        } else {
          if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 - 7);
          } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
            startMoment = startMoment.day(offset2 + 7);
          } else {
            startMoment = startMoment.day(offset2);
          }
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset2 = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset2 === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 - 7);
        } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
          startMoment = startMoment.day(offset2 + 7);
        } else {
          startMoment = startMoment.day(offset2);
        }
        result.start.assign("weekday", offset2);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar(require_hant(), exports);
    exports.hans = __importStar(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u0435\u043C\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var xf = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = xf;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        const lowerText = match[1].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_2.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset2 = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset2, modifier);
        return context.createParsingComponents().assign("weekday", offset2).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var de = __importStar(require_de());
    exports.de = de;
    var fr = __importStar(require_fr());
    exports.fr = fr;
    var ja = __importStar(require_ja());
    exports.ja = ja;
    var pt = __importStar(require_pt());
    exports.pt = pt;
    var nl = __importStar(require_nl());
    exports.nl = nl;
    var zh = __importStar(require_zh());
    exports.zh = zh;
    var ru = __importStar(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray3 = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init2() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a, b, c) {
        var n = arguments.length;
        switch (n) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b];
          case 3:
            return [a, b, c];
          default:
            var arr = new Array(n);
            while (n--) {
              arr[n] = arguments[n];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = i < valuesCount ? values[i] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
          on = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on = target.on;
          off = target.off;
        }
        if (!on && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i = events.length;
            while (i-- > 0) {
              event = events[i];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i = 0; i < length; i++) {
          option = keys[i];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value = options[option];
          if (value !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value, reject) : value;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v, reject) {
            if (typeof v === firstType) {
              return v;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType)
              return v;
            reject(message);
          };
        }
        return function(v, reject) {
          var kind = typeof v;
          var i = len;
          while (i-- > 0) {
            if (kind === types[i])
              return v;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value, reject2) {
              value *= 1;
              if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                reject2("timeout must be a positive number");
              }
              return value;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value) {
            cleanup();
            resolve(value);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i = 1; i < length; i++) {
              callbacks[i](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i = 0; i < len; i++) {
          if (observers[i]._target === observer)
            return i;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) {
          return null;
        }
        if (i === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l++] = type.slice(j, n);
                j = n + dl;
              } while ((n = type.indexOf(delimiter, j)) !== -1);
              ns[l++] = type.slice(j);
              type = ns;
              typeLength = l;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j, i);
              j = i + dl;
            } while ((i = type.indexOf(delimiter, j)) !== -1);
            ns[len++] = type.slice(j);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i = 0; i + 1 < len; i++) {
            if (ns[i] === "**" && ns[i + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i = 0; i < len; i++) {
          name = ns[i];
          tree = tree[name] || (tree[name] = {});
          if (i === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i-- > 0) {
          branchName = branches[i];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while (i-- > 0) {
          key = keys[i];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen2(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i = 0; i < len; i++) {
            event = keys[i];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray3(events) ? listen2(toObject(events)) : typeof events === "string" ? listen2(toObject(events.split(/\s+/))) : listen2(events);
        return this;
      };
      EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i-- > 0) {
          observer = observers[i];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn, options) {
        return this._once(event, fn, false, options);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
        return this._once(event, fn, true, options);
      };
      EventEmitter.prototype._once = function(event, fn, prepend, options) {
        return this._many(event, 1, fn, prepend, options);
      };
      EventEmitter.prototype.many = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, false, options);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, true, options);
      };
      EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
        var self2 = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init2.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray3(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init2.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
          if (!leafs)
            return this;
          for (i = 0; i < leafs.length; i++) {
            leaf = leafs[i];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i = keys.length;
          allListeners = [];
          while (i-- > 0) {
            listeners = _events[keys[i]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter.prototype;
      Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n) {
            if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module2.exports = EventEmitter;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// node_modules/mustache-validator/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/mustache-validator/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PathSymbol = Symbol("MustacheDataPath");
    function createPropertyPathArray({ target, propertyName }) {
      return [...target[PathSymbol] || [], propertyName];
    }
    function proxyMustacheData(data, options) {
      if (typeof data !== "object") {
        return data;
      }
      return new Proxy(data, {
        get(target, propertyName) {
          let value = target[propertyName];
          if (value === void 0 && !(propertyName in target)) {
            const pathSegments = createPropertyPathArray({ target, propertyName });
            if (options === null || options === void 0 ? void 0 : options.handleError) {
              options.handleError(pathSegments);
              return value;
            }
            throw Error(`Missing Mustache data property: ${pathSegments.join(" > ")}`);
          }
          if (value && typeof value === "object") {
            value[PathSymbol] = createPropertyPathArray({ target, propertyName });
            return proxyMustacheData(value, options);
          }
          return value;
        }
      });
    }
    exports.default = proxyMustacheData;
  }
});

// node_modules/boon-js/lib/types.js
var require_types = __commonJS({
  "node_modules/boon-js/lib/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Tokens = exports.StructuralCharacters = exports.Operators = void 0;
    var Operators;
    (function(Operators2) {
      Operators2["AND"] = "AND";
      Operators2["OR"] = "OR";
      Operators2["XOR"] = "XOR";
      Operators2["NOT"] = "NOT";
    })(Operators = exports.Operators || (exports.Operators = {}));
    var StructuralCharacters;
    (function(StructuralCharacters2) {
      StructuralCharacters2["OPEN_PARENTHESIS"] = "(";
      StructuralCharacters2["CLOSE_PARENTHESIS"] = ")";
    })(StructuralCharacters = exports.StructuralCharacters || (exports.StructuralCharacters = {}));
    var Tokens;
    (function(Tokens2) {
      Tokens2["IDENTIFIER"] = "IDENTIFIER";
      Tokens2["OPERATOR"] = "OPERATOR";
      Tokens2["STRUCTURAL_CHARACTER"] = "STRUCTURAL_CHARACTER";
      Tokens2["EOF"] = "EOF";
      Tokens2["COMMENT"] = "COMMENT";
    })(Tokens = exports.Tokens || (exports.Tokens = {}));
  }
});

// node_modules/boon-js/lib/parse/const.js
var require_const = __commonJS({
  "node_modules/boon-js/lib/parse/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.VALID_TOKENS = exports.OPERATOR_PRECEDENCE = void 0;
    var types_1 = require_types();
    exports.OPERATOR_PRECEDENCE = {
      NOT: 0,
      XOR: 1,
      AND: 2,
      OR: 3
    };
    exports.VALID_TOKENS = {
      identifierOnly: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        }
      ],
      identifierOrNot: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }
      ],
      binaryOperator: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR }
      ],
      binaryOperatorOrClose: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.CLOSE_PARENTHESIS
        }
      ]
    };
  }
});

// node_modules/boon-js/lib/lex/const.js
var require_const2 = __commonJS({
  "node_modules/boon-js/lib/lex/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.ESCAPE_CHARACTER = exports.EOL = exports.COMMENT_DELIMITER = exports.QUOTED_IDENTIFIER_DELIMITER = exports.SEPARATORS = exports.OPERATORS = exports.STRUCTURAL_CHARACTERS = void 0;
    var types_1 = require_types();
    exports.STRUCTURAL_CHARACTERS = {
      "(": types_1.StructuralCharacters.OPEN_PARENTHESIS,
      ")": types_1.StructuralCharacters.CLOSE_PARENTHESIS
    };
    exports.OPERATORS = {
      AND: types_1.Operators.AND,
      OR: types_1.Operators.OR,
      XOR: types_1.Operators.XOR,
      NOT: types_1.Operators.NOT
    };
    exports.SEPARATORS = new Set([
      32,
      9,
      10,
      13
    ].map(function(separator) {
      return String.fromCodePoint(separator);
    }));
    exports.QUOTED_IDENTIFIER_DELIMITER = String.fromCodePoint(34);
    exports.COMMENT_DELIMITER = String.fromCodePoint(35);
    exports.EOL = String.fromCodePoint(10);
    exports.ESCAPE_CHARACTER = String.fromCodePoint(92);
  }
});

// node_modules/boon-js/lib/lex/utils.js
var require_utils = __commonJS({
  "node_modules/boon-js/lib/lex/utils.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.getQuotedIdentifier = exports.getComment = exports.createResult = void 0;
    var types_1 = require_types();
    var const_1 = require_const2();
    var createResult = function(name, value, remainingString) {
      return {
        token: __assign2({ name }, value !== null ? { value } : {}),
        remainingString
      };
    };
    exports.createResult = createResult;
    var getComment = function(expression) {
      var tokenEnd = expression.length;
      for (var i = 0; i < expression.length; i += 1) {
        var letter = expression[i];
        if (letter === const_1.EOL) {
          tokenEnd = i;
          break;
        }
      }
      return (0, exports.createResult)(types_1.Tokens.COMMENT, expression.slice(0, tokenEnd), expression.slice(tokenEnd + 1));
    };
    exports.getComment = getComment;
    var getQuotedIdentifier = function(expression) {
      var escapeQuotation = false;
      var value = "";
      var tokenEnd = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenEnd === null) {
          if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
            if (escapeQuotation) {
              value = value.slice(-1) + const_1.QUOTED_IDENTIFIER_DELIMITER;
            } else {
              tokenEnd = i;
            }
          } else {
            if (char === const_1.ESCAPE_CHARACTER) {
              escapeQuotation = true;
            } else {
              escapeQuotation = false;
            }
            value = value += char;
          }
        } else {
          if (!const_1.SEPARATORS.has(char) && !const_1.STRUCTURAL_CHARACTERS[char]) {
            throw new Error("Unexpected character: ".concat(char, " Expected ) character or separator"));
          }
          break;
        }
      }
      if (tokenEnd === null) {
        throw new Error("Unexpected end of expression: expected ".concat(const_1.QUOTED_IDENTIFIER_DELIMITER, " character"));
      }
      return (0, exports.createResult)(types_1.Tokens.IDENTIFIER, value, expression.slice(tokenEnd + 1));
    };
    exports.getQuotedIdentifier = getQuotedIdentifier;
  }
});

// node_modules/boon-js/lib/lex/lex.js
var require_lex = __commonJS({
  "node_modules/boon-js/lib/lex/lex.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.lex = void 0;
    var types_1 = require_types();
    var const_1 = require_const2();
    var utils_1 = require_utils();
    var lex = function(expression) {
      var tokenStart = null;
      var tokenEnd = null;
      var delimitingCharacter = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenStart === null) {
          if (!const_1.SEPARATORS.has(char)) {
            var structuralChar = const_1.STRUCTURAL_CHARACTERS[char];
            if (structuralChar) {
              var nextChar = expression[i + 1];
              if (structuralChar === types_1.StructuralCharacters.CLOSE_PARENTHESIS && nextChar && !const_1.SEPARATORS.has(nextChar) && nextChar !== types_1.StructuralCharacters.CLOSE_PARENTHESIS) {
                throw new Error("Unexpected character: ".concat(nextChar, ". A closing parenthesis should be followed by another closing parenthesis or whitespace"));
              }
              return (0, utils_1.createResult)(types_1.Tokens.STRUCTURAL_CHARACTER, const_1.STRUCTURAL_CHARACTERS[char], expression.slice(i + 1));
            }
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
              return (0, utils_1.getQuotedIdentifier)(expression.slice(i + 1));
            }
            if (char === const_1.COMMENT_DELIMITER) {
              return (0, utils_1.getComment)(expression.slice(i + 1));
            }
            tokenStart = i;
          }
        } else {
          if (const_1.SEPARATORS.has(char) || const_1.STRUCTURAL_CHARACTERS[char]) {
            tokenEnd = i;
            delimitingCharacter = char;
            break;
          } else {
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER || char === const_1.COMMENT_DELIMITER) {
              throw new Error("Unexpected character: ".concat(char));
            }
          }
        }
      }
      if (tokenStart !== null) {
        tokenEnd = tokenEnd !== null && tokenEnd !== void 0 ? tokenEnd : expression.length;
        var value = expression.slice(tokenStart, tokenEnd);
        var remainingString = expression.slice(tokenEnd);
        if (const_1.OPERATORS[value]) {
          if (delimitingCharacter && !const_1.SEPARATORS.has(delimitingCharacter)) {
            throw new Error("Unexpected character: ".concat(delimitingCharacter, ". Operators should be separated using whitespace"));
          }
          return (0, utils_1.createResult)(types_1.Tokens.OPERATOR, const_1.OPERATORS[value], remainingString);
        } else {
          return (0, utils_1.createResult)(types_1.Tokens.IDENTIFIER, value, remainingString);
        }
      }
      return (0, utils_1.createResult)(types_1.Tokens.EOF, null, "");
    };
    exports.lex = lex;
  }
});

// node_modules/boon-js/lib/parse/utils.js
var require_utils2 = __commonJS({
  "node_modules/boon-js/lib/parse/utils.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.validateToken = exports.previousOperatorTakesPrecedent = exports.getValue = exports.newTokenGenerator = void 0;
    var lex_1 = require_lex();
    var types_1 = require_types();
    var const_1 = require_const();
    var newTokenGenerator = function(expression) {
      var remainingExpression = expression;
      return function(validTokens, endIsValid) {
        if (endIsValid === void 0) {
          endIsValid = false;
        }
        while (true) {
          var _a = (0, lex_1.lex)(remainingExpression), token = _a.token, remainingString = _a.remainingString;
          remainingExpression = remainingString;
          if (token.name !== types_1.Tokens.COMMENT) {
            (0, exports.validateToken)(token, validTokens, endIsValid);
            return token;
          }
        }
      };
    };
    exports.newTokenGenerator = newTokenGenerator;
    var getValue = function(getNextToken, parser) {
      var nextToken = getNextToken(const_1.VALID_TOKENS.identifierOrNot);
      var negatedValue = nextToken.value === types_1.Operators.NOT;
      if (negatedValue) {
        nextToken = getNextToken(const_1.VALID_TOKENS.identifierOnly);
      }
      var value = nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER ? parser(getNextToken, true) : [nextToken];
      return negatedValue ? __spreadArray2(__spreadArray2([], value, true), [{ name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }], false) : value;
    };
    exports.getValue = getValue;
    var previousOperatorTakesPrecedent = function(previousOperator, nextOperator) {
      return const_1.OPERATOR_PRECEDENCE[previousOperator] <= const_1.OPERATOR_PRECEDENCE[nextOperator];
    };
    exports.previousOperatorTakesPrecedent = previousOperatorTakesPrecedent;
    var validateToken = function(token, validTokens, endIsValid) {
      if (endIsValid === void 0) {
        endIsValid = false;
      }
      if (token.name === types_1.Tokens.EOF) {
        if (endIsValid) {
          return;
        }
        throw new Error("Unexpected end of expression");
      }
      for (var _i = 0, validTokens_1 = validTokens; _i < validTokens_1.length; _i++) {
        var validToken = validTokens_1[_i];
        if (validToken.name === token.name) {
          if (!validToken.value || validToken.value === token.value) {
            return;
          }
        }
      }
      throw new TypeError("Invalid token");
    };
    exports.validateToken = validateToken;
  }
});

// node_modules/boon-js/lib/parse/parse.js
var require_parse = __commonJS({
  "node_modules/boon-js/lib/parse/parse.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.parse = void 0;
    var types_1 = require_types();
    var const_1 = require_const();
    var utils_1 = require_utils2();
    var parse4 = function(expression) {
      if (typeof expression !== "string") {
        throw new Error("Expected string but received ".concat(typeof expression));
      }
      var getNextToken = (0, utils_1.newTokenGenerator)(expression);
      return parseInternal(getNextToken);
    };
    exports.parse = parse4;
    var parseInternal = function(getNextToken, nested) {
      if (nested === void 0) {
        nested = false;
      }
      var output = __spreadArray2([], (0, utils_1.getValue)(getNextToken, parseInternal), true);
      var operators = [];
      while (true) {
        var validTokens = nested ? const_1.VALID_TOKENS.binaryOperatorOrClose : const_1.VALID_TOKENS.binaryOperator;
        var nextToken = getNextToken(validTokens, !nested);
        if (nextToken.name === types_1.Tokens.EOF || nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER) {
          return __spreadArray2(__spreadArray2([], output, true), __spreadArray2([], operators, true).reverse(), true);
        }
        while (operators.length) {
          var previousOperator = operators[operators.length - 1] || null;
          if (previousOperator && (0, utils_1.previousOperatorTakesPrecedent)(previousOperator.value, nextToken.value)) {
            output = __spreadArray2(__spreadArray2([], output, true), [previousOperator], false);
            operators = operators.slice(0, -1);
          } else {
            break;
          }
        }
        operators = __spreadArray2(__spreadArray2([], operators, true), [nextToken], false);
        output = __spreadArray2(__spreadArray2([], output, true), (0, utils_1.getValue)(getNextToken, parseInternal), true);
      }
    };
  }
});

// node_modules/boon-js/lib/evaluate/utils.js
var require_utils3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.throwInvalidExpression = exports.isOperator = exports.isIdentifier = exports.notUtil = exports.xorUtil = exports.orUtil = exports.andUtil = void 0;
    var types_1 = require_types();
    var andUtil = function(left, right) {
      return left && right;
    };
    exports.andUtil = andUtil;
    var orUtil = function(left, right) {
      return left || right;
    };
    exports.orUtil = orUtil;
    var xorUtil = function(left, right) {
      return !(left === right);
    };
    exports.xorUtil = xorUtil;
    var notUtil = function(identifier) {
      return !identifier;
    };
    exports.notUtil = notUtil;
    var isIdentifier = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.IDENTIFIER && typeof value === "string";
    };
    exports.isIdentifier = isIdentifier;
    var isOperator = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.OPERATOR && typeof value === "string";
    };
    exports.isOperator = isOperator;
    var throwInvalidExpression = function(message) {
      throw new TypeError("Invalid postfix expression: ".concat(message));
    };
    exports.throwInvalidExpression = throwInvalidExpression;
  }
});

// node_modules/boon-js/lib/evaluate/const.js
var require_const3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/const.js"(exports) {
    "use strict";
    var _a;
    exports.__esModule = true;
    exports.OPERATOR_MAP = void 0;
    var types_1 = require_types();
    var utils_1 = require_utils3();
    exports.OPERATOR_MAP = (_a = {}, _a[types_1.Operators.AND] = utils_1.andUtil, _a[types_1.Operators.OR] = utils_1.orUtil, _a[types_1.Operators.XOR] = utils_1.xorUtil, _a);
  }
});

// node_modules/boon-js/lib/evaluate/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/boon-js/lib/evaluate/evaluate.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.evaluate = exports.getEvaluator = void 0;
    var parse_1 = require_parse();
    var types_1 = require_types();
    var const_1 = require_const3();
    var utils_1 = require_utils3();
    var getEvaluator = function(expression) {
      var parsedExpression = (0, parse_1.parse)(expression);
      return function(booleanMap) {
        return (0, exports.evaluate)(parsedExpression, booleanMap);
      };
    };
    exports.getEvaluator = getEvaluator;
    var evaluate2 = function(expression, booleanMap) {
      if (!Array.isArray(expression)) {
        throw new Error("".concat(expression, " should be an array. evaluate takes in a parsed expression. Use in combination with parse or use getEvaluator"));
      }
      var evaluatedExpression = expression.reduce(function(stack, token, i) {
        if (!(token && ((0, utils_1.isIdentifier)(token) || (0, utils_1.isOperator)(token)))) {
          throw new Error("Invalid token: ".concat(token, ". Found in parsed expression at index ").concat(i));
        }
        if (token.name === types_1.Tokens.IDENTIFIER) {
          return __spreadArray2(__spreadArray2([], stack, true), [Boolean(booleanMap[token.value])], false);
        }
        var secondLastItem = stack[stack.length - 2];
        var lastItem = stack[stack.length - 1];
        if (token.value === types_1.Operators.NOT) {
          if (lastItem === void 0) {
            (0, utils_1.throwInvalidExpression)("missing identifier");
          }
          return __spreadArray2(__spreadArray2([], stack.slice(0, -1), true), [(0, utils_1.notUtil)(lastItem)], false);
        }
        if (lastItem === void 0 || secondLastItem === void 0) {
          (0, utils_1.throwInvalidExpression)("missing identifier");
        }
        var operatorUtil = const_1.OPERATOR_MAP[token.value];
        if (!operatorUtil) {
          (0, utils_1.throwInvalidExpression)("unknown operator");
        }
        return __spreadArray2(__spreadArray2([], stack.slice(0, -2), true), [operatorUtil(secondLastItem, lastItem)], false);
      }, []);
      if (evaluatedExpression.length !== 1) {
        (0, utils_1.throwInvalidExpression)("too many identifiers after evaluation");
      }
      return evaluatedExpression[0];
    };
    exports.evaluate = evaluate2;
  }
});

// node_modules/boon-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/boon-js/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    exports.__esModule = true;
    exports.parse = exports.evaluate = exports.getEvaluator = void 0;
    var evaluate_1 = require_evaluate();
    __createBinding(exports, evaluate_1, "getEvaluator");
    __createBinding(exports, evaluate_1, "evaluate");
    var parse_1 = require_parse();
    __createBinding(exports, parse_1, "parse");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TasksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian18 = require("obsidian");

// src/Obsidian/Cache.ts
var import_obsidian4 = require("obsidian");

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._weightedQueues = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      if (!this._weightedQueues[weight - 1])
        this._weightedQueues[weight - 1] = [];
      this._weightedQueues[weight - 1].push({ resolve, reject });
      this._dispatch();
    });
  }
  runExclusive(callback, weight = 1) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire(weight);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve) => {
      if (!this._weightedWaiters[weight - 1])
        this._weightedWaiters[weight - 1] = [];
      this._weightedWaiters[weight - 1].push(resolve);
      this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatch();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));
    this._weightedQueues = [];
  }
  _dispatch() {
    var _a;
    for (let weight = this._value; weight > 0; weight--) {
      const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
      if (!queueEntry)
        continue;
      const previousValue = this._value;
      const previousWeight = weight;
      this._value -= weight;
      weight = this._value + 1;
      queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    for (let weight = this._value; weight > 0; weight--) {
      if (!this._weightedWaiters[weight - 1])
        continue;
      this._weightedWaiters[weight - 1].forEach((waiter) => waiter());
      this._weightedWaiters[weight - 1] = [];
    }
  }
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/Scripting/TasksFile.ts
var TasksFile = class {
  constructor(path) {
    this._path = path;
  }
  get path() {
    return this._path;
  }
  get pathWithoutExtension() {
    return this.withoutExtension(this.path);
  }
  withoutExtension(value) {
    return value.replace(/\.md$/, "");
  }
  get root() {
    let path = this.path.replace(/\\/g, "/");
    if (path.charAt(0) === "/") {
      path = path.substring(1);
    }
    const separatorIndex = path.indexOf("/");
    if (separatorIndex == -1) {
      return "/";
    }
    return path.substring(0, separatorIndex + 1);
  }
  get folder() {
    const path = this.path;
    const fileNameWithExtension = this.filename;
    const folder = path.substring(0, path.lastIndexOf(fileNameWithExtension));
    if (folder === "") {
      return "/";
    }
    return folder;
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return "";
    }
  }
  get filenameWithoutExtension() {
    return this.withoutExtension(this.filename);
  }
};

// src/Query/DateParser.ts
var chrono = __toESM(require_dist());

// src/Query/DateRange.ts
var DateRange = class {
  constructor(start, end) {
    this.start = start;
    this.end = end;
    if (end.isBefore(start)) {
      this.start = end;
      this.end = start;
    }
    this.start = this.start.startOf("day");
    this.end = this.end.startOf("day");
  }
  static buildRelative(range2) {
    const unitOfTime = range2 === "week" ? "isoWeek" : range2;
    return new DateRange(
      window.moment().startOf(unitOfTime).startOf("day"),
      window.moment().endOf(unitOfTime).startOf("day")
    );
  }
  static buildInvalid() {
    return new DateRange(window.moment.invalid(), window.moment.invalid());
  }
  isValid() {
    return this.start.isValid() && this.end.isValid();
  }
  moveToPrevious(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.subtract(delta);
    this.end.subtract(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
  moveToNext(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.add(delta);
    this.end.add(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
};

// src/Query/DateParser.ts
var DateParser = class {
  static parseDate(input, forwardDate = false) {
    return window.moment(
      chrono.parseDate(input, void 0, {
        forwardDate
      })
    ).startOf("day");
  }
  static parseDateRange(input, forwardDate = false) {
    const dateRangeParsers = [
      DateParser.parseRelativeDateRange,
      DateParser.parseNumberedDateRange,
      DateParser.parseAbsoluteDateRange
    ];
    for (const parser of dateRangeParsers) {
      const parsedDateRange = parser(input, forwardDate);
      if (parsedDateRange.isValid()) {
        return parsedDateRange;
      }
    }
    return DateRange.buildInvalid();
  }
  static parseAbsoluteDateRange(input, forwardDate) {
    const result = chrono.parse(input, void 0, {
      forwardDate
    });
    if (result.length === 0) {
      return DateRange.buildInvalid();
    }
    const startDate = result[0].start;
    const endDate = result[1] && result[1].start ? result[1].start : startDate;
    const start = window.moment(startDate.date());
    const end = window.moment(endDate.date());
    return new DateRange(start, end);
  }
  static parseRelativeDateRange(input, _forwardDate) {
    const relativeDateRangeRegexp = /(last|this|next) (week|month|quarter|year)/;
    const relativeDateRangeMatch = input.match(relativeDateRangeRegexp);
    if (relativeDateRangeMatch && relativeDateRangeMatch.length === 3) {
      const lastThisNext = relativeDateRangeMatch[1];
      const range2 = relativeDateRangeMatch[2];
      const dateRange = DateRange.buildRelative(range2);
      switch (lastThisNext) {
        case "last":
          dateRange.moveToPrevious(range2);
          break;
        case "next":
          dateRange.moveToNext(range2);
          break;
      }
      return dateRange;
    }
    return DateRange.buildInvalid();
  }
  static parseNumberedDateRange(input, _forwardDate) {
    const parsingVectors = [
      [/^\s*[0-9]{4}\s*$/, "YYYY", "year"],
      [/^\s*[0-9]{4}-Q[1-4]\s*$/, "YYYY-Q", "quarter"],
      [/^\s*[0-9]{4}-[0-9]{2}\s*$/, "YYYY-MM", "month"],
      [/^\s*[0-9]{4}-W[0-9]{2}\s*$/, "YYYY-WW", "isoWeek"]
    ];
    for (const [regexp, dateFormat, range2] of parsingVectors) {
      const matched = input.match(regexp);
      if (matched) {
        const date = matched[0].trim();
        return new DateRange(
          window.moment(date, dateFormat).startOf(range2),
          window.moment(date, dateFormat).endOf(range2)
        );
      }
    }
    return DateRange.buildInvalid();
  }
};

// src/lib/DateAbbreviations.ts
var abbreviations = {
  td: "today",
  tm: "tomorrow",
  yd: "yesterday",
  tw: "this week",
  nw: "next week",
  weekend: "sat",
  we: "sat"
};
function doAutocomplete(date) {
  for (const [key, val] of Object.entries(abbreviations)) {
    date = date.replace(RegExp(`\\b${key}\\s`, "i"), val);
  }
  return date;
}

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = function() {
  function Weekday2(weekday, n) {
    if (n === 0)
      throw new Error("Can't create weekday with n == 0");
    this.weekday = weekday;
    this.n = n;
  }
  Weekday2.fromStr = function(str) {
    return new Weekday2(ALL_WEEKDAYS.indexOf(str));
  };
  Weekday2.prototype.nth = function(n) {
    return this.n === n ? this : new Weekday2(this.weekday, n);
  };
  Weekday2.prototype.equals = function(other) {
    return this.weekday === other.weekday && this.n === other.n;
  };
  Weekday2.prototype.toString = function() {
    var s = ALL_WEEKDAYS[this.weekday];
    if (this.n)
      s = (this.n > 0 ? "+" : "") + String(this.n) + s;
    return s;
  };
  Weekday2.prototype.getJsWeekday = function() {
    return this.weekday === 6 ? 0 : this.weekday + 1;
  };
  return Weekday2;
}();

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y, m, d, h, i, s) {
  if (h === void 0) {
    h = 0;
  }
  if (i === void 0) {
    i = 0;
  }
  if (s === void 0) {
    s = 0;
  }
  return new Date(Date.UTC(y, m - 1, d, h, i, s));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var tzOffset = function(date) {
  return date.getTimezoneOffset() * 60 * 1e3;
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime() - tzOffset(date1);
  var date2ms = date2.getTime() - tzOffset(date2);
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i = 0; i < dates.length; i++) {
    clones.push(clone(dates[i]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart(date.getUTCFullYear().toString(), 4, "0"),
    padStart(date.getUTCMonth() + 1, 2, "0"),
    padStart(date.getUTCDate(), 2, "0"),
    "T",
    padStart(date.getUTCHours(), 2, "0"),
    padStart(date.getUTCMinutes(), 2, "0"),
    padStart(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset2 = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset2);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = function() {
  function IterResult2(method, args) {
    this.minDate = null;
    this.maxDate = null;
    this._result = [];
    this.total = 0;
    this.method = method;
    this.args = args;
    if (method === "between") {
      this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
      this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
    } else if (method === "before") {
      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
    } else if (method === "after") {
      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
    }
  }
  IterResult2.prototype.accept = function(date) {
    ++this.total;
    var tooEarly = this.minDate && date < this.minDate;
    var tooLate = this.maxDate && date > this.maxDate;
    if (this.method === "between") {
      if (tooEarly)
        return true;
      if (tooLate)
        return false;
    } else if (this.method === "before") {
      if (tooLate)
        return false;
    } else if (this.method === "after") {
      if (tooEarly)
        return true;
      this.add(date);
      return false;
    }
    return this.add(date);
  };
  IterResult2.prototype.add = function(date) {
    this._result.push(date);
    return true;
  };
  IterResult2.prototype.getValue = function() {
    var res = this._result;
    switch (this.method) {
      case "all":
      case "between":
        return res;
      case "before":
      case "after":
      default:
        return res.length ? res[res.length - 1] : null;
    }
  };
  IterResult2.prototype.clone = function() {
    return new IterResult2(this.method, this.args);
  };
  return IterResult2;
}();
var iterresult_default = IterResult;

// node_modules/rrule/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = function(_super) {
  __extends(CallbackIterResult2, _super);
  function CallbackIterResult2(method, args, iterator) {
    var _this = _super.call(this, method, args) || this;
    _this.iterator = iterator;
    return _this;
  }
  CallbackIterResult2.prototype.add = function(date) {
    if (this.iterator(date, this._result.length)) {
      this._result.push(date);
      return true;
    }
    return false;
  };
  return CallbackIterResult2;
}(iterresult_default);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = function() {
  function ToText2(rrule, gettext, language, dateFormatter) {
    if (gettext === void 0) {
      gettext = defaultGetText;
    }
    if (language === void 0) {
      language = i18n_default;
    }
    if (dateFormatter === void 0) {
      dateFormatter = defaultDateFormatter;
    }
    this.text = [];
    this.language = language || i18n_default;
    this.gettext = gettext;
    this.dateFormatter = dateFormatter;
    this.rrule = rrule;
    this.options = rrule.options;
    this.origOptions = rrule.origOptions;
    if (this.origOptions.bymonthday) {
      var bymonthday = [].concat(this.options.bymonthday);
      var bynmonthday = [].concat(this.options.bynmonthday);
      bymonthday.sort(function(a, b) {
        return a - b;
      });
      bynmonthday.sort(function(a, b) {
        return b - a;
      });
      this.bymonthday = bymonthday.concat(bynmonthday);
      if (!this.bymonthday.length)
        this.bymonthday = null;
    }
    if (isPresent(this.origOptions.byweekday)) {
      var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
      var days = String(byweekday);
      this.byweekday = {
        allWeeks: byweekday.filter(function(weekday) {
          return !weekday.n;
        }),
        someWeeks: byweekday.filter(function(weekday) {
          return Boolean(weekday.n);
        }),
        isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
        isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
      };
      var sortWeekDays = function(a, b) {
        return a.weekday - b.weekday;
      };
      this.byweekday.allWeeks.sort(sortWeekDays);
      this.byweekday.someWeeks.sort(sortWeekDays);
      if (!this.byweekday.allWeeks.length)
        this.byweekday.allWeeks = null;
      if (!this.byweekday.someWeeks.length)
        this.byweekday.someWeeks = null;
    } else {
      this.byweekday = null;
    }
  }
  ToText2.isFullyConvertible = function(rrule) {
    var canConvert = true;
    if (!(rrule.options.freq in ToText2.IMPLEMENTED))
      return false;
    if (rrule.origOptions.until && rrule.origOptions.count)
      return false;
    for (var key in rrule.origOptions) {
      if (contains(["dtstart", "wkst", "freq"], key))
        return true;
      if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
        return false;
    }
    return canConvert;
  };
  ToText2.prototype.isFullyConvertible = function() {
    return ToText2.isFullyConvertible(this.rrule);
  };
  ToText2.prototype.toString = function() {
    var gettext = this.gettext;
    if (!(this.options.freq in ToText2.IMPLEMENTED)) {
      return gettext("RRule error: Unable to fully convert this rrule to text");
    }
    this.text = [gettext("every")];
    this[RRule.FREQUENCIES[this.options.freq]]();
    if (this.options.until) {
      this.add(gettext("until"));
      var until = this.options.until;
      this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
    } else if (this.options.count) {
      this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
    }
    if (!this.isFullyConvertible())
      this.add(gettext("(~ approximate)"));
    return this.text.join("");
  };
  ToText2.prototype.HOURLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
  };
  ToText2.prototype.MINUTELY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
  };
  ToText2.prototype.DAILY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
    } else {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    }
    if (this.origOptions.bymonth) {
      this.add(gettext("in"));
      this._bymonth();
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };
  ToText2.prototype.WEEKLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
    }
    if (this.byweekday && this.byweekday.isWeekdays) {
      if (this.options.interval === 1) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(gettext("on")).add(gettext("weekdays"));
      }
    } else if (this.byweekday && this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    } else {
      if (this.options.interval === 1)
        this.add(gettext("week"));
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
    }
  };
  ToText2.prototype.MONTHLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(gettext("months"));
        if (this.plural(this.options.interval))
          this.add(gettext("in"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(gettext("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };
  ToText2.prototype.YEARLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
        this.add(gettext("years"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }
    if (this.options.byyearday) {
      this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
    }
    if (this.options.byweekno) {
      this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
    }
  };
  ToText2.prototype._bymonthday = function() {
    var gettext = this.gettext;
    if (this.byweekday && this.byweekday.allWeeks) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
    } else {
      this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
    }
  };
  ToText2.prototype._byweekday = function() {
    var gettext = this.gettext;
    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
    }
    if (this.byweekday.someWeeks) {
      if (this.byweekday.allWeeks)
        this.add(gettext("and"));
      this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
    }
  };
  ToText2.prototype._byhour = function() {
    var gettext = this.gettext;
    this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
  };
  ToText2.prototype._bymonth = function() {
    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
  };
  ToText2.prototype.nth = function(n) {
    n = parseInt(n.toString(), 10);
    var nth;
    var gettext = this.gettext;
    if (n === -1)
      return gettext("last");
    var npos = Math.abs(n);
    switch (npos) {
      case 1:
      case 21:
      case 31:
        nth = npos + gettext("st");
        break;
      case 2:
      case 22:
        nth = npos + gettext("nd");
        break;
      case 3:
      case 23:
        nth = npos + gettext("rd");
        break;
      default:
        nth = npos + gettext("th");
    }
    return n < 0 ? nth + " " + gettext("last") : nth;
  };
  ToText2.prototype.monthtext = function(m) {
    return this.language.monthNames[m - 1];
  };
  ToText2.prototype.weekdaytext = function(wday) {
    var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
    return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
  };
  ToText2.prototype.plural = function(n) {
    return n % 100 !== 1;
  };
  ToText2.prototype.add = function(s) {
    this.text.push(" ");
    this.text.push(s);
    return this;
  };
  ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
    var _this = this;
    if (delim === void 0) {
      delim = ",";
    }
    if (!isArray(arr)) {
      arr = [arr];
    }
    var delimJoin = function(array, delimiter, finalDelimiter) {
      var list = "";
      for (var i = 0; i < array.length; i++) {
        if (i !== 0) {
          if (i === array.length - 1) {
            list += " " + finalDelimiter + " ";
          } else {
            list += delimiter + " ";
          }
        }
        list += array[i];
      }
      return list;
    };
    callback = callback || function(o) {
      return o.toString();
    };
    var realCallback = function(arg) {
      return callback && callback.call(_this, arg);
    };
    if (finalDelim) {
      return delimJoin(arr.map(realCallback), delim, finalDelim);
    } else {
      return arr.map(realCallback).join(delim + " ");
    }
  };
  return ToText2;
}();
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = function() {
  function Parser2(rules) {
    this.done = true;
    this.rules = rules;
  }
  Parser2.prototype.start = function(text2) {
    this.text = text2;
    this.done = false;
    return this.nextSymbol();
  };
  Parser2.prototype.isDone = function() {
    return this.done && this.symbol === null;
  };
  Parser2.prototype.nextSymbol = function() {
    var best;
    var bestSymbol;
    this.symbol = null;
    this.value = null;
    do {
      if (this.done)
        return false;
      var rule = void 0;
      best = null;
      for (var name_1 in this.rules) {
        rule = this.rules[name_1];
        var match = rule.exec(this.text);
        if (match) {
          if (best === null || match[0].length > best[0].length) {
            best = match;
            bestSymbol = name_1;
          }
        }
      }
      if (best != null) {
        this.text = this.text.substr(best[0].length);
        if (this.text === "")
          this.done = true;
      }
      if (best == null) {
        this.done = true;
        this.symbol = null;
        this.value = null;
        return;
      }
    } while (bestSymbol === "SKIP");
    this.symbol = bestSymbol;
    this.value = best;
    return true;
  };
  Parser2.prototype.accept = function(name) {
    if (this.symbol === name) {
      if (this.value) {
        var v = this.value;
        this.nextSymbol();
        return v;
      }
      this.nextSymbol();
      return true;
    }
    return false;
  };
  Parser2.prototype.acceptNumber = function() {
    return this.accept("number");
  };
  Parser2.prototype.expect = function(name) {
    if (this.accept(name))
      return true;
    throw new Error("expected " + name + " but found " + this.symbol);
  };
  return Parser2;
}();
function parseText(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text2))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text2, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = function() {
  function Time2(hour, minute, second, millisecond) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond || 0;
  }
  Time2.prototype.getHours = function() {
    return this.hour;
  };
  Time2.prototype.getMinutes = function() {
    return this.minute;
  };
  Time2.prototype.getSeconds = function() {
    return this.second;
  };
  Time2.prototype.getMilliseconds = function() {
    return this.millisecond;
  };
  Time2.prototype.getTime = function() {
    return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
  };
  return Time2;
}();
var DateTime = function(_super) {
  __extends(DateTime2, _super);
  function DateTime2(year, month, day, hour, minute, second, millisecond) {
    var _this = _super.call(this, hour, minute, second, millisecond) || this;
    _this.year = year;
    _this.month = month;
    _this.day = day;
    return _this;
  }
  DateTime2.fromDate = function(date) {
    return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
  };
  DateTime2.prototype.getWeekday = function() {
    return getWeekday(new Date(this.getTime()));
  };
  DateTime2.prototype.getTime = function() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
  };
  DateTime2.prototype.getDay = function() {
    return this.day;
  };
  DateTime2.prototype.getMonth = function() {
    return this.month;
  };
  DateTime2.prototype.getYear = function() {
    return this.year;
  };
  DateTime2.prototype.addYears = function(years) {
    this.year += years;
  };
  DateTime2.prototype.addMonths = function(months) {
    this.month += months;
    if (this.month > 12) {
      var yearDiv = Math.floor(this.month / 12);
      var monthMod = pymod(this.month, 12);
      this.month = monthMod;
      this.year += yearDiv;
      if (this.month === 0) {
        this.month = 12;
        --this.year;
      }
    }
  };
  DateTime2.prototype.addWeekly = function(days, wkst) {
    if (wkst > this.getWeekday()) {
      this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
    } else {
      this.day += -(this.getWeekday() - wkst) + days * 7;
    }
    this.fixDay();
  };
  DateTime2.prototype.addDaily = function(days) {
    this.day += days;
    this.fixDay();
  };
  DateTime2.prototype.addHours = function(hours, filtered, byhour) {
    if (filtered) {
      this.hour += Math.floor((23 - this.hour) / hours) * hours;
    }
    for (; ; ) {
      this.hour += hours;
      var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
      if (dayDiv) {
        this.hour = hourMod;
        this.addDaily(dayDiv);
      }
      if (empty(byhour) || includes(byhour, this.hour))
        break;
    }
  };
  DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
    if (filtered) {
      this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
    }
    for (; ; ) {
      this.minute += minutes;
      var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
      if (hourDiv) {
        this.minute = minuteMod;
        this.addHours(hourDiv, false, byhour);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
        break;
      }
    }
  };
  DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
    if (filtered) {
      this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
    }
    for (; ; ) {
      this.second += seconds;
      var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
      if (minuteDiv) {
        this.second = secondMod;
        this.addMinutes(minuteDiv, false, byhour, byminute);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
        break;
      }
    }
  };
  DateTime2.prototype.fixDay = function() {
    if (this.day <= 28) {
      return;
    }
    var daysinmonth = monthRange(this.year, this.month - 1)[1];
    if (this.day <= daysinmonth) {
      return;
    }
    while (this.day > daysinmonth) {
      this.day -= daysinmonth;
      ++this.month;
      if (this.month === 13) {
        this.month = 1;
        ++this.year;
        if (this.year > MAXYEAR) {
          return;
        }
      }
      daysinmonth = monthRange(this.year, this.month - 1)[1];
    }
  };
  DateTime2.prototype.add = function(options, filtered) {
    var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
    switch (freq) {
      case Frequency.YEARLY:
        return this.addYears(interval);
      case Frequency.MONTHLY:
        return this.addMonths(interval);
      case Frequency.WEEKLY:
        return this.addWeekly(interval, wkst);
      case Frequency.DAILY:
        return this.addDaily(interval);
      case Frequency.HOURLY:
        return this.addHours(interval, filtered, byhour);
      case Frequency.MINUTELY:
        return this.addMinutes(interval, filtered, byhour, byminute);
      case Frequency.SECONDLY:
        return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
    }
  };
  return DateTime2;
}(Time);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr2) {
    var _a = attr2.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = function() {
  function DateWithZone2(date, tzid) {
    if (isNaN(date.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date = date;
    this.tzid = tzid;
  }
  Object.defineProperty(DateWithZone2.prototype, "isUTC", {
    get: function() {
      return !this.tzid || this.tzid.toUpperCase() === "UTC";
    },
    enumerable: false,
    configurable: true
  });
  DateWithZone2.prototype.toString = function() {
    var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
    if (!this.isUTC) {
      return ";TZID=".concat(this.tzid, ":").concat(datestr);
    }
    return ":".concat(datestr);
  };
  DateWithZone2.prototype.getTime = function() {
    return this.date.getTime();
  };
  DateWithZone2.prototype.rezonedDate = function() {
    if (this.isUTC) {
      return this.date;
    }
    return dateInTimeZone(this.date, this.tzid);
  };
  return DateWithZone2;
}();

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value = options[keys[i]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = function() {
  function Cache3() {
    this.all = false;
    this.before = [];
    this.after = [];
    this.between = [];
  }
  Cache3.prototype._cacheAdd = function(what, value, args) {
    if (value) {
      value = value instanceof Date ? clone(value) : cloneDates(value);
    }
    if (what === "all") {
      this.all = value;
    } else {
      args._value = value;
      this[what].push(args);
    }
  };
  Cache3.prototype._cacheGet = function(what, args) {
    var cached = false;
    var argsKeys = args ? Object.keys(args) : [];
    var findCacheDiff = function(item2) {
      for (var i2 = 0; i2 < argsKeys.length; i2++) {
        var key = argsKeys[i2];
        if (!argsMatch(args[key], item2[key])) {
          return true;
        }
      }
      return false;
    };
    var cachedObject = this[what];
    if (what === "all") {
      cached = this.all;
    } else if (isArray(cachedObject)) {
      for (var i = 0; i < cachedObject.length; i++) {
        var item = cachedObject[i];
        if (argsKeys.length && findCacheDiff(item))
          continue;
        cached = item._value;
        break;
      }
    }
    if (!cached && this.all) {
      var iterResult = new iterresult_default(what, args);
      for (var i = 0; i < this.all.length; i++) {
        if (!iterResult.accept(this.all[i]))
          break;
      }
      cached = iterResult.getValue();
      this._cacheAdd(what, cached, args);
    }
    return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
  };
  return Cache3;
}();

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset2);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = function() {
  function Iterinfo2(options) {
    this.options = options;
  }
  Iterinfo2.prototype.rebuild = function(year, month) {
    var options = this.options;
    if (year !== this.lastyear) {
      this.yearinfo = rebuildYear(year, options);
    }
    if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
      this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
    }
    if (isPresent(options.byeaster)) {
      this.eastermask = easter(year, options.byeaster);
    }
  };
  Object.defineProperty(Iterinfo2.prototype, "lastyear", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastyear : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastmonth : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearlen", {
    get: function() {
      return this.yearinfo.yearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
    get: function() {
      return this.yearinfo.yearordinal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mrange", {
    get: function() {
      return this.yearinfo.mrange;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
    get: function() {
      return this.yearinfo.wdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mmask", {
    get: function() {
      return this.yearinfo.mmask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wnomask", {
    get: function() {
      return this.yearinfo.wnomask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
    get: function() {
      return this.monthinfo ? this.monthinfo.nwdaymask : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
    get: function() {
      return this.yearinfo.nextyearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
    get: function() {
      return this.yearinfo.mdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
    get: function() {
      return this.yearinfo.nmdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Iterinfo2.prototype.ydayset = function() {
    return [range(this.yearlen), 0, this.yearlen];
  };
  Iterinfo2.prototype.mdayset = function(_, month) {
    var start = this.mrange[month - 1];
    var end = this.mrange[month];
    var set = repeat(null, this.yearlen);
    for (var i = start; i < end; i++)
      set[i] = i;
    return [set, start, end];
  };
  Iterinfo2.prototype.wdayset = function(year, month, day) {
    var set = repeat(null, this.yearlen + 7);
    var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
    var start = i;
    for (var j = 0; j < 7; j++) {
      set[i] = i;
      ++i;
      if (this.wdaymask[i] === this.options.wkst)
        break;
    }
    return [set, start, i];
  };
  Iterinfo2.prototype.ddayset = function(year, month, day) {
    var set = repeat(null, this.yearlen);
    var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
    set[i] = i;
    return [set, i, i + 1];
  };
  Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
    var _this = this;
    var set = [];
    this.options.byminute.forEach(function(minute) {
      set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
    });
    sort(set);
    return set;
  };
  Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
    var set = this.options.bysecond.map(function(second) {
      return new Time(hour, minute, second, millisecond);
    });
    sort(set);
    return set;
  };
  Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
    return [new Time(hour, minute, second, millisecond)];
  };
  Iterinfo2.prototype.getdayset = function(freq) {
    switch (freq) {
      case Frequency.YEARLY:
        return this.ydayset.bind(this);
      case Frequency.MONTHLY:
        return this.mdayset.bind(this);
      case Frequency.WEEKLY:
        return this.wdayset.bind(this);
      case Frequency.DAILY:
        return this.ddayset.bind(this);
      default:
        return this.ddayset.bind(this);
    }
  };
  Iterinfo2.prototype.gettimeset = function(freq) {
    switch (freq) {
      case Frequency.HOURLY:
        return this.htimeset.bind(this);
      case Frequency.MINUTELY:
        return this.mtimeset.bind(this);
      case Frequency.SECONDLY:
        return this.stimeset.bind(this);
    }
  };
  return Iterinfo2;
}();
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = function() {
  function RRule2(options, noCache) {
    if (options === void 0) {
      options = {};
    }
    if (noCache === void 0) {
      noCache = false;
    }
    this._cache = noCache ? null : new Cache();
    this.origOptions = initializeOptions(options);
    var parsedOptions = parseOptions(options).parsedOptions;
    this.options = parsedOptions;
  }
  RRule2.parseText = function(text2, language) {
    return parseText(text2, language);
  };
  RRule2.fromText = function(text2, language) {
    return fromText(text2, language);
  };
  RRule2.fromString = function(str) {
    return new RRule2(RRule2.parseString(str) || void 0);
  };
  RRule2.prototype._iter = function(iterResult) {
    return iter(iterResult, this.options);
  };
  RRule2.prototype._cacheGet = function(what, args) {
    if (!this._cache)
      return false;
    return this._cache._cacheGet(what, args);
  };
  RRule2.prototype._cacheAdd = function(what, value, args) {
    if (!this._cache)
      return;
    return this._cache._cacheAdd(what, value, args);
  };
  RRule2.prototype.all = function(iterator) {
    if (iterator) {
      return this._iter(new callbackiterresult_default("all", {}, iterator));
    }
    var result = this._cacheGet("all");
    if (result === false) {
      result = this._iter(new iterresult_default("all", {}));
      this._cacheAdd("all", result);
    }
    return result;
  };
  RRule2.prototype.between = function(after, before, inc, iterator) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(after) || !isValidDate(before)) {
      throw new Error("Invalid date passed in to RRule.between");
    }
    var args = {
      before,
      after,
      inc
    };
    if (iterator) {
      return this._iter(new callbackiterresult_default("between", args, iterator));
    }
    var result = this._cacheGet("between", args);
    if (result === false) {
      result = this._iter(new iterresult_default("between", args));
      this._cacheAdd("between", result, args);
    }
    return result;
  };
  RRule2.prototype.before = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.before");
    }
    var args = { dt, inc };
    var result = this._cacheGet("before", args);
    if (result === false) {
      result = this._iter(new iterresult_default("before", args));
      this._cacheAdd("before", result, args);
    }
    return result;
  };
  RRule2.prototype.after = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.after");
    }
    var args = { dt, inc };
    var result = this._cacheGet("after", args);
    if (result === false) {
      result = this._iter(new iterresult_default("after", args));
      this._cacheAdd("after", result, args);
    }
    return result;
  };
  RRule2.prototype.count = function() {
    return this.all().length;
  };
  RRule2.prototype.toString = function() {
    return optionsToString(this.origOptions);
  };
  RRule2.prototype.toText = function(gettext, language, dateFormatter) {
    return toText(this, gettext, language, dateFormatter);
  };
  RRule2.prototype.isFullyConvertibleToText = function() {
    return isFullyConvertible(this);
  };
  RRule2.prototype.clone = function() {
    return new RRule2(this.origOptions);
  };
  RRule2.FREQUENCIES = [
    "YEARLY",
    "MONTHLY",
    "WEEKLY",
    "DAILY",
    "HOURLY",
    "MINUTELY",
    "SECONDLY"
  ];
  RRule2.YEARLY = Frequency.YEARLY;
  RRule2.MONTHLY = Frequency.MONTHLY;
  RRule2.WEEKLY = Frequency.WEEKLY;
  RRule2.DAILY = Frequency.DAILY;
  RRule2.HOURLY = Frequency.HOURLY;
  RRule2.MINUTELY = Frequency.MINUTELY;
  RRule2.SECONDLY = Frequency.SECONDLY;
  RRule2.MO = Days.MO;
  RRule2.TU = Days.TU;
  RRule2.WE = Days.WE;
  RRule2.TH = Days.TH;
  RRule2.FR = Days.FR;
  RRule2.SA = Days.SA;
  RRule2.SU = Days.SU;
  RRule2.parseString = parseString;
  RRule2.optionsToString = optionsToString;
  return RRule2;
}();

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = function(_super) {
  __extends(RRuleSet2, _super);
  function RRuleSet2(noCache) {
    if (noCache === void 0) {
      noCache = false;
    }
    var _this = _super.call(this, {}, noCache) || this;
    _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
    _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
    _this._rrule = [];
    _this._rdate = [];
    _this._exrule = [];
    _this._exdate = [];
    return _this;
  }
  RRuleSet2.prototype._iter = function(iterResult) {
    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
  };
  RRuleSet2.prototype.rrule = function(rrule) {
    _addRule(rrule, this._rrule);
  };
  RRuleSet2.prototype.exrule = function(rrule) {
    _addRule(rrule, this._exrule);
  };
  RRuleSet2.prototype.rdate = function(date) {
    _addDate(date, this._rdate);
  };
  RRuleSet2.prototype.exdate = function(date) {
    _addDate(date, this._exdate);
  };
  RRuleSet2.prototype.rrules = function() {
    return this._rrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.exrules = function() {
    return this._exrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.rdates = function() {
    return this._rdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.exdates = function() {
    return this._exdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.valueOf = function() {
    var result = [];
    if (!this._rrule.length && this._dtstart) {
      result = result.concat(optionsToString({ dtstart: this._dtstart }));
    }
    this._rrule.forEach(function(rrule) {
      result = result.concat(rrule.toString().split("\n"));
    });
    this._exrule.forEach(function(exrule) {
      result = result.concat(exrule.toString().split("\n").map(function(line) {
        return line.replace(/^RRULE:/, "EXRULE:");
      }).filter(function(line) {
        return !/^DTSTART/.test(line);
      }));
    });
    if (this._rdate.length) {
      result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
    }
    if (this._exdate.length) {
      result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
    }
    return result;
  };
  RRuleSet2.prototype.toString = function() {
    return this.valueOf().join("\n");
  };
  RRuleSet2.prototype.clone = function() {
    var rrs = new RRuleSet2(!!this._cache);
    this._rrule.forEach(function(rule) {
      return rrs.rrule(rule.clone());
    });
    this._exrule.forEach(function(rule) {
      return rrs.exrule(rule.clone());
    });
    this._rdate.forEach(function(date) {
      return rrs.rdate(new Date(date.getTime()));
    });
    this._exdate.forEach(function(date) {
      return rrs.exdate(new Date(date.getTime()));
    });
    return rrs;
  };
  return RRuleSet2;
}(RRule);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// src/lib/DateTools.ts
var chrono2 = __toESM(require_dist());
function compareByDate(a, b) {
  if (a !== null && b === null) {
    return -1;
  }
  if (a === null && b !== null) {
    return 1;
  }
  if (!(a !== null && b !== null)) {
    return 0;
  }
  if (a.isValid() && !b.isValid()) {
    return 1;
  } else if (!a.isValid() && b.isValid()) {
    return -1;
  }
  if (a.isAfter(b)) {
    return 1;
  } else if (a.isBefore(b)) {
    return -1;
  } else {
    return 0;
  }
}
function parseTypedDateForDisplay(fieldName, typedDate, forwardDate = void 0) {
  if (!typedDate) {
    return `<i>no ${fieldName} date</i>`;
  }
  const parsed = chrono2.parseDate(typedDate, forwardDate, {
    forwardDate: forwardDate != void 0
  });
  if (parsed !== null) {
    const parsedMoment = window.moment(parsed);
    if (fieldName === "reminder") {
      const typedDateFormatIsDateTime = isDateTime(window.moment(typedDate));
      return typedDateFormatIsDateTime ? parsedMoment.format("YYYY-MM-DD HH:mm") : parsedMoment.format("YYYY-MM-DD");
    }
    return parsedMoment.format("YYYY-MM-DD");
  }
  return `<i>invalid ${fieldName} date</i>`;
}
function parseTypedDateForDisplayUsingFutureDate(fieldName, typedDate, forwardOnly) {
  return parseTypedDateForDisplay(fieldName, typedDate, forwardOnly ? new Date() : void 0);
}
function parseTypedDateForSaving(typedDate, forwardDate) {
  let date = null;
  const parsedDate = chrono2.parseDate(typedDate, new Date(), { forwardDate });
  if (parsedDate !== null) {
    date = window.moment(parsedDate);
  }
  return date;
}
function parseTypedDateorDateTimeForSavingReminder(typedDate, forwardDate) {
  let date = null;
  const parsedDate = chrono2.parseDate(typedDate, new Date(), { forwardDate });
  if (parsedDate !== null) {
    date = window.moment(parsedDate);
    const dateString = isDateTime(window.moment(typedDate)) ? date.format("YYYY-MM-DD HH:mm") : date.format("YYYY-MM-DD");
    date = window.moment(dateString);
  }
  return date;
}
function isDateTime(dateObj) {
  let hasTime = false;
  if (dateObj != null) {
    hasTime = dateObj.creationData().format === "YYYY-MM-DD HH:mm";
  }
  return hasTime;
}

// src/Task/Recurrence.ts
var Recurrence = class {
  constructor({
    rrule,
    baseOnToday,
    referenceDate,
    startDate,
    scheduledDate,
    dueDate,
    reminderDate
  }) {
    this.rrule = rrule;
    this.baseOnToday = baseOnToday;
    this.referenceDate = referenceDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.reminderDate = reminderDate;
  }
  static fromText({
    recurrenceRuleText,
    startDate,
    scheduledDate,
    dueDate,
    reminderDate
  }) {
    try {
      const match = recurrenceRuleText.match(/^([a-zA-Z0-9, !]+?)( when done)?$/i);
      if (match == null) {
        return null;
      }
      const isolatedRuleText = match[1].trim();
      const baseOnToday = match[2] !== void 0;
      const options = RRule.parseText(isolatedRuleText);
      if (options !== null) {
        let referenceDate = null;
        if (dueDate) {
          referenceDate = window.moment(dueDate);
        } else if (reminderDate) {
          referenceDate = window.moment(reminderDate);
        } else if (scheduledDate) {
          referenceDate = window.moment(scheduledDate);
        } else if (startDate) {
          referenceDate = window.moment(startDate);
        }
        if (!baseOnToday && referenceDate !== null) {
          options.dtstart = window.moment(referenceDate).startOf("day").utc(true).toDate();
        } else {
          options.dtstart = window.moment().startOf("day").utc(true).toDate();
        }
        const rrule = new RRule(options);
        return new Recurrence({
          rrule,
          baseOnToday,
          referenceDate,
          startDate,
          scheduledDate,
          dueDate,
          reminderDate
        });
      }
    } catch (e) {
      if (e instanceof Error) {
        console.log(e.message);
      }
    }
    return null;
  }
  toText() {
    let text2 = this.rrule.toText();
    if (this.baseOnToday) {
      text2 += " when done";
    }
    return text2;
  }
  next(today = window.moment()) {
    const next = this.nextReferenceDate(today);
    if (next !== null) {
      let startDate = null;
      let scheduledDate = null;
      let dueDate = null;
      let reminderDate = null;
      if (this.referenceDate) {
        if (this.startDate) {
          const originalDifference = window.moment.duration(this.startDate.diff(this.referenceDate));
          startDate = window.moment(next);
          startDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.scheduledDate) {
          const originalDifference = window.moment.duration(this.scheduledDate.diff(this.referenceDate));
          scheduledDate = window.moment(next);
          scheduledDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.dueDate) {
          const originalDifference = window.moment.duration(this.dueDate.diff(this.referenceDate));
          dueDate = window.moment(next);
          dueDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.reminderDate) {
          const originalDifference = window.moment.duration(this.reminderDate.diff(this.referenceDate));
          reminderDate = window.moment(next);
          reminderDate.add(Math.round(originalDifference.asDays()), "days");
        }
      }
      return {
        startDate,
        scheduledDate,
        dueDate,
        reminderDate
      };
    }
    return null;
  }
  identicalTo(other) {
    if (this.baseOnToday !== other.baseOnToday) {
      return false;
    }
    if (compareByDate(this.startDate, other.startDate) !== 0) {
      return false;
    }
    if (compareByDate(this.scheduledDate, other.scheduledDate) !== 0) {
      return false;
    }
    if (compareByDate(this.dueDate, other.dueDate) !== 0) {
      return false;
    }
    if (compareByDate(this.reminderDate, other.reminderDate) !== 0) {
      return false;
    }
    return this.toText() === other.toText();
  }
  nextReferenceDate(today) {
    if (this.baseOnToday) {
      return this.nextReferenceDateFromToday(today).toDate();
    } else {
      return this.nextReferenceDateFromOriginalReferenceDate().toDate();
    }
  }
  nextReferenceDateFromToday(today) {
    const ruleBasedOnToday = new RRule(__spreadProps(__spreadValues({}, this.rrule.origOptions), {
      dtstart: today.startOf("day").utc(true).toDate()
    }));
    return this.nextAfter(today.endOf("day"), ruleBasedOnToday);
  }
  nextReferenceDateFromOriginalReferenceDate() {
    var _a;
    const after = window.moment((_a = this.referenceDate) != null ? _a : void 0).endOf("day");
    return this.nextAfter(after, this.rrule);
  }
  nextAfter(after, rrule) {
    after.utc(true);
    let next = window.moment(rrule.after(after.toDate()));
    const asText = this.toText();
    const monthMatch = asText.match(/every( \d+)? month(s)?(.*)?/);
    if (monthMatch !== null) {
      if (!asText.includes(" on ")) {
        next = Recurrence.nextAfterMonths(after, next, rrule, monthMatch[1]);
      }
    }
    const yearMatch = asText.match(/every( \d+)? year(s)?(.*)?/);
    if (yearMatch !== null) {
      next = Recurrence.nextAfterYears(after, next, rrule, yearMatch[1]);
    }
    return Recurrence.addTimezone(next);
  }
  static nextAfterMonths(after, next, rrule, skippingMonths) {
    let parsedSkippingMonths = 1;
    if (skippingMonths !== void 0) {
      parsedSkippingMonths = Number.parseInt(skippingMonths.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyMonths(after, next, parsedSkippingMonths)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyMonths(after, next, skippingMonths) {
    let diffMonths = next.month() - after.month();
    const diffYears = next.year() - after.year();
    diffMonths += diffYears * 12;
    return diffMonths > skippingMonths;
  }
  static nextAfterYears(after, next, rrule, skippingYears) {
    let parsedSkippingYears = 1;
    if (skippingYears !== void 0) {
      parsedSkippingYears = Number.parseInt(skippingYears.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyYears(after, next, parsedSkippingYears)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyYears(after, next, skippingYears) {
    const diff = next.year() - after.year();
    return diff > skippingYears;
  }
  static fromOneDayEarlier(after, rrule) {
    after.subtract(1, "days").endOf("day");
    const options = rrule.origOptions;
    options.dtstart = after.startOf("day").toDate();
    rrule = new RRule(options);
    return window.moment(rrule.after(after.toDate()));
  }
  static addTimezone(date) {
    const localTimeZone = window.moment.utc(date).local(true);
    return localTimeZone.startOf("day");
  }
};

// src/Layout/TaskLayoutOptions.ts
var TaskLayoutComponent = /* @__PURE__ */ ((TaskLayoutComponent2) => {
  TaskLayoutComponent2["Description"] = "description";
  TaskLayoutComponent2["Id"] = "id";
  TaskLayoutComponent2["DependsOn"] = "dependsOn";
  TaskLayoutComponent2["Priority"] = "priority";
  TaskLayoutComponent2["RecurrenceRule"] = "recurrenceRule";
  TaskLayoutComponent2["CreatedDate"] = "createdDate";
  TaskLayoutComponent2["StartDate"] = "startDate";
  TaskLayoutComponent2["ScheduledDate"] = "scheduledDate";
  TaskLayoutComponent2["DueDate"] = "dueDate";
  TaskLayoutComponent2["ReminderDate"] = "reminderDate";
  TaskLayoutComponent2["CancelledDate"] = "cancelledDate";
  TaskLayoutComponent2["DoneDate"] = "doneDate";
  TaskLayoutComponent2["BlockLink"] = "blockLink";
  return TaskLayoutComponent2;
})(TaskLayoutComponent || {});
var taskLayoutComponents = Object.values(TaskLayoutComponent);
var TaskLayoutOptions = class {
  constructor() {
    this.visible = {};
    this.tagsVisible = true;
    taskLayoutComponents.forEach((component) => {
      this.visible[component] = true;
    });
  }
  isShown(component) {
    return this.visible[component];
  }
  areTagsShown() {
    return this.tagsVisible;
  }
  hide(component) {
    this.visible[component] = false;
  }
  setVisibility(component, visible) {
    this.visible[component] = visible;
  }
  setTagsVisibility(visibility) {
    this.tagsVisible = visibility;
  }
  get shownComponents() {
    return taskLayoutComponents.filter((component) => {
      return this.visible[component];
    });
  }
  get hiddenComponents() {
    return taskLayoutComponents.filter((component) => {
      return !this.visible[component];
    });
  }
  get toggleableComponents() {
    return taskLayoutComponents.filter((component) => {
      return component !== "description" /* Description */ && component !== "blockLink" /* BlockLink */;
    });
  }
  toggleVisibilityExceptDescriptionAndBlockLink() {
    this.toggleableComponents.forEach((component) => {
      this.visible[component] = !this.visible[component];
    });
    this.setTagsVisibility(!this.areTagsShown());
  }
};

// src/Task/TaskRegularExpressions.ts
var _TaskRegularExpressions = class {
};
var TaskRegularExpressions = _TaskRegularExpressions;
TaskRegularExpressions.dateFormat = "YYYY-MM-DD";
TaskRegularExpressions.dateTimeFormat = "YYYY-MM-DD HH:mm";
TaskRegularExpressions.indentationRegex = /^([\s\t>]*)/;
TaskRegularExpressions.listMarkerRegex = /([-*+]|[0-9]+\.)/;
TaskRegularExpressions.checkboxRegex = /\[(.)\]/u;
TaskRegularExpressions.afterCheckboxRegex = / *(.*)/u;
TaskRegularExpressions.taskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + " +" + _TaskRegularExpressions.checkboxRegex.source + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.nonTaskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + "? *(" + _TaskRegularExpressions.checkboxRegex.source + ")?" + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.listItemRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source
);
TaskRegularExpressions.blockLinkRegex = / \^[a-zA-Z0-9-]+$/u;
TaskRegularExpressions.hashTags = /(^|\s)#[^ !@#$%^&*(),.?":{}|<>]+/g;
TaskRegularExpressions.hashTagsFromEnd = new RegExp(_TaskRegularExpressions.hashTags.source + "$");

// src/TaskSerializer/DefaultTaskSerializer.ts
var taskIdRegex = /[a-zA-Z0-9-_]+/;
var taskIdSequenceRegex = new RegExp(taskIdRegex.source + "( *, *" + taskIdRegex.source + " *)*");
var DEFAULT_SYMBOLS = {
  prioritySymbols: {
    Highest: "\u{1F53A}",
    High: "\u23EB",
    Medium: "\u{1F53C}",
    Low: "\u{1F53D}",
    Lowest: "\u23EC",
    None: ""
  },
  startDateSymbol: "\u{1F6EB}",
  createdDateSymbol: "\u2795",
  scheduledDateSymbol: "\u23F3",
  dueDateSymbol: "\u{1F4C5}",
  reminderDateSymbol: "\u23F0",
  doneDateSymbol: "\u2705",
  cancelledDateSymbol: "\u274C",
  recurrenceSymbol: "\u{1F501}",
  dependsOnSymbol: "\u26D4",
  idSymbol: "\u{1F194}",
  TaskFormatRegularExpressions: {
    priorityRegex: /([🔺⏫🔼🔽⏬])\uFE0F?$/u,
    startDateRegex: /🛫 *(\d{4}-\d{2}-\d{2})$/u,
    createdDateRegex: /➕ *(\d{4}-\d{2}-\d{2})$/u,
    scheduledDateRegex: /[⏳⌛] *(\d{4}-\d{2}-\d{2})$/u,
    dueDateRegex: /[📅📆🗓] *(\d{4}-\d{2}-\d{2})$/u,
    reminderDateRegex: /[⏰] *(\d{4}-\d{2}-\d{2})$/u,
    reminderDateTimeRegex: /[⏰] *(\d{4}-\d{2}-\d{2} \d{2}:\d{2})$/u,
    doneDateRegex: /✅ *(\d{4}-\d{2}-\d{2})$/u,
    cancelledDateRegex: /❌ *(\d{4}-\d{2}-\d{2})$/u,
    recurrenceRegex: /🔁 ?([a-zA-Z0-9, !]+)$/iu,
    dependsOnRegex: new RegExp("\u26D4\uFE0F? *(" + taskIdSequenceRegex.source + ")$", "iu"),
    idRegex: new RegExp("\u{1F194} *(" + taskIdRegex.source + ")$", "iu")
  }
};
function symbolAndStringValue(shortMode, symbol, value) {
  if (!value)
    return "";
  return shortMode ? " " + symbol : ` ${symbol} ${value}`;
}
function symbolAndDateValue(shortMode, symbol, date) {
  if (!date)
    return "";
  return shortMode ? " " + symbol : ` ${symbol} ${date.format(
    isDateTime(date) ? TaskRegularExpressions.dateTimeFormat : TaskRegularExpressions.dateFormat
  )}`;
}
var DefaultTaskSerializer = class {
  constructor(symbols) {
    this.symbols = symbols;
  }
  serialize(task) {
    const taskLayoutOptions = new TaskLayoutOptions();
    let taskString = "";
    const shortMode = false;
    for (const component of taskLayoutOptions.shownComponents) {
      taskString += this.componentToString(task, shortMode, component);
    }
    return taskString;
  }
  componentToString(task, shortMode, component) {
    var _a;
    const {
      prioritySymbols,
      startDateSymbol,
      createdDateSymbol,
      scheduledDateSymbol,
      doneDateSymbol,
      cancelledDateSymbol,
      recurrenceSymbol,
      dueDateSymbol,
      reminderDateSymbol,
      dependsOnSymbol,
      idSymbol
    } = this.symbols;
    switch (component) {
      case "description" /* Description */:
        return task.description;
      case "priority" /* Priority */: {
        let priority = "";
        if (task.priority === "0" /* Highest */) {
          priority = " " + prioritySymbols.Highest;
        } else if (task.priority === "1" /* High */) {
          priority = " " + prioritySymbols.High;
        } else if (task.priority === "2" /* Medium */) {
          priority = " " + prioritySymbols.Medium;
        } else if (task.priority === "4" /* Low */) {
          priority = " " + prioritySymbols.Low;
        } else if (task.priority === "5" /* Lowest */) {
          priority = " " + prioritySymbols.Lowest;
        }
        return priority;
      }
      case "startDate" /* StartDate */:
        return symbolAndDateValue(shortMode, startDateSymbol, task.startDate);
      case "createdDate" /* CreatedDate */:
        return symbolAndDateValue(shortMode, createdDateSymbol, task.createdDate);
      case "scheduledDate" /* ScheduledDate */:
        if (task.scheduledDateIsInferred)
          return "";
        return symbolAndDateValue(shortMode, scheduledDateSymbol, task.scheduledDate);
      case "doneDate" /* DoneDate */:
        return symbolAndDateValue(shortMode, doneDateSymbol, task.doneDate);
      case "cancelledDate" /* CancelledDate */:
        return symbolAndDateValue(shortMode, cancelledDateSymbol, task.cancelledDate);
      case "dueDate" /* DueDate */:
        return symbolAndDateValue(shortMode, dueDateSymbol, task.dueDate);
      case "reminderDate" /* ReminderDate */:
        return symbolAndDateValue(shortMode, reminderDateSymbol, task.reminderDate);
      case "recurrenceRule" /* RecurrenceRule */:
        if (!task.recurrence)
          return "";
        return symbolAndStringValue(shortMode, recurrenceSymbol, task.recurrence.toText());
      case "dependsOn" /* DependsOn */: {
        if (task.dependsOn.length === 0)
          return "";
        return symbolAndStringValue(shortMode, dependsOnSymbol, task.dependsOn.join(","));
      }
      case "id" /* Id */:
        return symbolAndStringValue(shortMode, idSymbol, task.id);
      case "blockLink" /* BlockLink */:
        return (_a = task.blockLink) != null ? _a : "";
      default:
        throw new Error(`Don't know how to render task component of type '${component}'`);
    }
  }
  parsePriority(p) {
    const { prioritySymbols } = this.symbols;
    switch (p) {
      case prioritySymbols.Lowest:
        return "5" /* Lowest */;
      case prioritySymbols.Low:
        return "4" /* Low */;
      case prioritySymbols.Medium:
        return "2" /* Medium */;
      case prioritySymbols.High:
        return "1" /* High */;
      case prioritySymbols.Highest:
        return "0" /* Highest */;
      default:
        return "3" /* None */;
    }
  }
  deserialize(line) {
    const { TaskFormatRegularExpressions } = this.symbols;
    let matched;
    let priority = "3" /* None */;
    let startDate = null;
    let scheduledDate = null;
    let dueDate = null;
    let reminderDate = null;
    let doneDate = null;
    let cancelledDate = null;
    let createdDate = null;
    let recurrenceRule = "";
    let recurrence = null;
    let id = "";
    let dependsOn = [];
    let trailingTags = "";
    const maxRuns = 20;
    let runs = 0;
    do {
      matched = false;
      const priorityMatch = line.match(TaskFormatRegularExpressions.priorityRegex);
      if (priorityMatch !== null) {
        priority = this.parsePriority(priorityMatch[1]);
        line = line.replace(TaskFormatRegularExpressions.priorityRegex, "").trim();
        matched = true;
      }
      const doneDateMatch = line.match(TaskFormatRegularExpressions.doneDateRegex);
      if (doneDateMatch !== null) {
        doneDate = window.moment(doneDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.doneDateRegex, "").trim();
        matched = true;
      }
      const cancelledDateMatch = line.match(TaskFormatRegularExpressions.cancelledDateRegex);
      if (cancelledDateMatch !== null) {
        cancelledDate = window.moment(cancelledDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.cancelledDateRegex, "").trim();
        matched = true;
      }
      const dueDateMatch = line.match(TaskFormatRegularExpressions.dueDateRegex);
      if (dueDateMatch !== null) {
        dueDate = window.moment(dueDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.dueDateRegex, "").trim();
        matched = true;
      }
      const reminderDateTimeMatch = line.match(TaskFormatRegularExpressions.reminderDateTimeRegex);
      const reminderDateMatch = line.match(TaskFormatRegularExpressions.reminderDateRegex);
      if (reminderDateTimeMatch !== null) {
        reminderDate = window.moment(reminderDateTimeMatch[1], TaskRegularExpressions.dateTimeFormat);
        line = line.replace(TaskFormatRegularExpressions.reminderDateTimeRegex, "").trim();
        matched = true;
      } else if (reminderDateMatch !== null) {
        reminderDate = window.moment(reminderDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.reminderDateRegex, "").trim();
        matched = true;
      }
      const scheduledDateMatch = line.match(TaskFormatRegularExpressions.scheduledDateRegex);
      if (scheduledDateMatch !== null) {
        scheduledDate = window.moment(scheduledDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.scheduledDateRegex, "").trim();
        matched = true;
      }
      const startDateMatch = line.match(TaskFormatRegularExpressions.startDateRegex);
      if (startDateMatch !== null) {
        startDate = window.moment(startDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.startDateRegex, "").trim();
        matched = true;
      }
      const createdDateMatch = line.match(TaskFormatRegularExpressions.createdDateRegex);
      if (createdDateMatch !== null) {
        createdDate = window.moment(createdDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.createdDateRegex, "").trim();
        matched = true;
      }
      const recurrenceMatch = line.match(TaskFormatRegularExpressions.recurrenceRegex);
      if (recurrenceMatch !== null) {
        recurrenceRule = recurrenceMatch[1].trim();
        line = line.replace(TaskFormatRegularExpressions.recurrenceRegex, "").trim();
        matched = true;
      }
      const tagsMatch = line.match(TaskRegularExpressions.hashTagsFromEnd);
      if (tagsMatch != null) {
        line = line.replace(TaskRegularExpressions.hashTagsFromEnd, "").trim();
        matched = true;
        const tagName = tagsMatch[0].trim();
        trailingTags = trailingTags.length > 0 ? [tagName, trailingTags].join(" ") : tagName;
      }
      const idMatch = line.match(TaskFormatRegularExpressions.idRegex);
      if (idMatch != null) {
        line = line.replace(TaskFormatRegularExpressions.idRegex, "").trim();
        id = idMatch[1].trim();
        matched = true;
      }
      const dependsOnMatch = line.match(TaskFormatRegularExpressions.dependsOnRegex);
      if (dependsOnMatch != null) {
        line = line.replace(TaskFormatRegularExpressions.dependsOnRegex, "").trim();
        dependsOn = dependsOnMatch[1].replace(/ /g, "").split(",").filter((item) => item !== "");
        matched = true;
      }
      runs++;
    } while (matched && runs <= maxRuns);
    if (recurrenceRule.length > 0) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceRule,
        startDate,
        scheduledDate,
        dueDate,
        reminderDate
      });
    }
    if (trailingTags.length > 0)
      line += " " + trailingTags;
    return {
      description: line,
      priority,
      startDate,
      createdDate,
      scheduledDate,
      dueDate,
      reminderDate,
      doneDate,
      cancelledDate,
      recurrence,
      id,
      dependsOn,
      tags: Task.extractHashtags(line)
    };
  }
};

// src/Task/TaskDependency.ts
function generateUniqueId(existingIds) {
  let id = "";
  let keepGenerating = true;
  while (keepGenerating) {
    id = Math.random().toString(36).substring(2, 6 + 2);
    if (!existingIds.includes(id)) {
      keepGenerating = false;
    }
  }
  return id;
}
function ensureTaskHasId(child, existingIds) {
  if (child.id !== "")
    return child;
  return new Task(__spreadProps(__spreadValues({}, child), { id: generateUniqueId(existingIds) }));
}
function addDependencyToParent(parent, child) {
  let newParent = parent;
  if (!parent.dependsOn.includes(child.id)) {
    const newDependsOn = [...parent.dependsOn, child.id];
    newParent = new Task(__spreadProps(__spreadValues({}, parent), { dependsOn: newDependsOn }));
  }
  return newParent;
}
function removeDependency(parent, child) {
  let newParent = parent;
  if (parent.dependsOn.includes(child.id)) {
    const newDependsOn = parent.dependsOn.filter((dependsOn) => dependsOn !== child.id);
    newParent = new Task(__spreadProps(__spreadValues({}, parent), { dependsOn: newDependsOn }));
  }
  return newParent;
}

// src/lib/RegExpTools.ts
function escapeRegExp(s) {
  return s.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
}

// src/Config/GlobalFilter.ts
var _GlobalFilter = class {
  constructor() {
    this._globalFilter = "";
    this._removeGlobalFilter = false;
  }
  static getInstance() {
    if (!_GlobalFilter.instance) {
      _GlobalFilter.instance = new _GlobalFilter();
    }
    return _GlobalFilter.instance;
  }
  get() {
    return this._globalFilter;
  }
  set(value) {
    this._globalFilter = value;
  }
  reset() {
    this.set(_GlobalFilter.empty);
  }
  isEmpty() {
    return this.get() === _GlobalFilter.empty;
  }
  equals(tag) {
    return this.get() === tag;
  }
  includedIn(description) {
    const globalFilter = this.get();
    return description.includes(globalFilter);
  }
  prependTo(description) {
    return this.get() + " " + description;
  }
  removeAsWordFromDependingOnSettings(description) {
    const removeGlobalFilter = this.getRemoveGlobalFilter();
    if (removeGlobalFilter) {
      return this.removeAsWordFrom(description);
    }
    return description;
  }
  getRemoveGlobalFilter() {
    return this._removeGlobalFilter;
  }
  setRemoveGlobalFilter(removeGlobalFilter) {
    this._removeGlobalFilter = removeGlobalFilter;
  }
  removeAsWordFrom(description) {
    if (this.isEmpty()) {
      return description;
    }
    const theRegExp = RegExp("(^|\\s)" + escapeRegExp(this.get()) + "($|\\s)", "ug");
    if (description.search(theRegExp) > -1) {
      description = description.replace(theRegExp, "$1$2").replace("  ", " ").trim();
    }
    return description;
  }
  removeAsSubstringFrom(description) {
    const globalFilter = this.get();
    return description.replace(globalFilter, "").trim();
  }
};
var GlobalFilter = _GlobalFilter;
GlobalFilter.empty = "";

// src/ui/DependencyHelpers.ts
var import_obsidian = require("obsidian");
var MAX_SEARCH_RESULTS = 20;
function descriptionAdjustedForDependencySearch(task) {
  return GlobalFilter.getInstance().removeAsWordFrom(task.description);
}
function searchDescriptionWithoutTags(query, allTasks) {
  if (query === "") {
    return allTasks;
  }
  const preparedSearch = (0, import_obsidian.prepareSimpleSearch)(query);
  const minimumScoreCutoff = -4;
  const matches = allTasks.map((task) => {
    const result = preparedSearch(descriptionAdjustedForDependencySearch(task));
    if (result && result.score > minimumScoreCutoff) {
      return {
        item: task,
        match: result
      };
    }
    return null;
  }).filter(Boolean);
  const sortedMatches = matches.sort((a, b) => b.match.score - a.match.score);
  return sortedMatches.map((item) => item.item);
}
function searchForCandidateTasksForDependency(search, allTasks, task, blockedBy, blocking) {
  let results = searchDescriptionWithoutTags(search, allTasks);
  results = results.filter((item) => {
    if (item.isDone) {
      return false;
    }
    if (item.description.includes("<%") && item.description.includes("%>")) {
      return false;
    }
    const sameTask = item.description === (task == null ? void 0 : task.description) && item.taskLocation.path === (task == null ? void 0 : task.taskLocation.path) && item.originalMarkdown === (task == null ? void 0 : task.originalMarkdown);
    if (sameTask) {
      return false;
    }
    if ((blockedBy == null ? void 0 : blockedBy.includes(item)) || (blocking == null ? void 0 : blocking.includes(item))) {
      return false;
    }
    return true;
  });
  if (task) {
    results.sort((a, b) => {
      const aInSamePath = a.taskLocation.path === task.taskLocation.path;
      const bInSamePath = b.taskLocation.path === task.taskLocation.path;
      if (aInSamePath && bInSamePath) {
        return Math.abs(a.taskLocation.lineNumber - task.taskLocation.lineNumber) - Math.abs(b.taskLocation.lineNumber - task.taskLocation.lineNumber);
      } else if (aInSamePath) {
        return -1;
      } else if (bInSamePath) {
        return 1;
      } else {
        return 0;
      }
    });
  }
  return results.slice(0, MAX_SEARCH_RESULTS);
}

// src/Suggestor/Suggestor.ts
var DEFAULT_MAX_GENERIC_SUGGESTIONS = 5;
var showDependencySuggestionsDefault = false;
globalThis.SHOW_DEPENDENCY_SUGGESTIONS = showDependencySuggestionsDefault;
function makeDefaultSuggestionBuilder(symbols, maxGenericSuggestions, dataviewMode) {
  const datePrefixRegex = [
    symbols.startDateSymbol,
    symbols.scheduledDateSymbol,
    symbols.dueDateSymbol,
    symbols.reminderDateSymbol
  ].join("|");
  return (line, cursorPos, settings2, allTasks, taskToSuggestFor) => {
    let suggestions = [];
    suggestions = suggestions.concat(
      addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions, dataviewMode)
    );
    suggestions = suggestions.concat(
      addRecurrenceSuggestions(line, cursorPos, settings2, symbols.recurrenceSymbol, dataviewMode)
    );
    if (globalThis.SHOW_DEPENDENCY_SUGGESTIONS) {
      suggestions = suggestions.concat(addIDSuggestion(line, cursorPos, symbols.idSymbol, allTasks));
      suggestions = suggestions.concat(
        addDependsOnSuggestions(line, cursorPos, settings2, symbols.dependsOnSymbol, allTasks, taskToSuggestFor)
      );
    }
    suggestions = suggestions.concat(addTaskPropertySuggestions(line, cursorPos, settings2, symbols, dataviewMode));
    if (suggestions.length > 0 && !suggestions.some((value) => value.suggestionType === "match")) {
      if (!dataviewMode) {
        suggestions.unshift({
          suggestionType: "empty",
          displayText: "\u23CE",
          appendText: "\n"
        });
      }
    }
    suggestions = suggestions.slice(0, settings2.autoSuggestMaxItems);
    return suggestions;
  };
}
function getAdjusters(dataviewMode, line, cursorPos) {
  const closingBracket = lastOpenBracket(line.substring(0, cursorPos), [
    ["(", ")"],
    ["[", "]"]
  ]) == "(" ? ")" : "]";
  const postfix = dataviewMode ? closingBracket + " " : " ";
  const insertSkip = dataviewMode && line.length > cursorPos && line.charAt(cursorPos) === closingBracket ? 1 : 0;
  return { postfix, insertSkip };
}
function addTaskPropertySuggestions(line, cursorPos, _settings, symbols, dataviewMode) {
  const hasPriority = (line2) => Object.values(symbols.prioritySymbols).some((value) => value.length > 0 && line2.includes(value));
  const genericSuggestions = [];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  if (!line.includes(symbols.dueDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.dueDateSymbol} due date`,
      appendText: `${symbols.dueDateSymbol} `
    });
  if (!line.includes(symbols.reminderDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.reminderDateSymbol} reminder date`,
      appendText: `${symbols.reminderDateSymbol} `
    });
  if (!line.includes(symbols.startDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.startDateSymbol} start date`,
      appendText: `${symbols.startDateSymbol} `
    });
  if (!line.includes(symbols.scheduledDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.scheduledDateSymbol} scheduled date`,
      appendText: `${symbols.scheduledDateSymbol} `
    });
  if (globalThis.SHOW_DEPENDENCY_SUGGESTIONS) {
    if (!line.includes(symbols.idSymbol))
      genericSuggestions.push({
        displayText: `${symbols.idSymbol} Task ID`,
        appendText: `${symbols.idSymbol}`
      });
    if (!line.includes(symbols.dependsOnSymbol))
      genericSuggestions.push({
        displayText: `${symbols.dependsOnSymbol} Task depends on ID`,
        appendText: `${symbols.dependsOnSymbol}`
      });
  }
  if (!hasPriority(line)) {
    const prioritySymbols = symbols.prioritySymbols;
    const priorityTexts = ["High", "Medium", "Low", "Highest", "Lowest"];
    for (let i = 0; i < priorityTexts.length; i++) {
      const priorityText = priorityTexts[i];
      const prioritySymbol = prioritySymbols[priorityText];
      genericSuggestions.push({
        displayText: dataviewMode ? `${prioritySymbol} priority` : `${prioritySymbol} ${priorityText.toLowerCase()} priority`,
        appendText: `${prioritySymbol}${postfix}`,
        insertSkip: dataviewMode ? insertSkip : void 0
      });
    }
  }
  if (!line.includes(symbols.recurrenceSymbol))
    genericSuggestions.push({
      displayText: `${symbols.recurrenceSymbol} recurring (repeat)`,
      appendText: `${symbols.recurrenceSymbol} `
    });
  if (!line.includes(symbols.createdDateSymbol)) {
    const parsedDate = DateParser.parseDate("today", true);
    const formattedDate = parsedDate.format(TaskRegularExpressions.dateFormat);
    genericSuggestions.push({
      textToMatch: `${symbols.createdDateSymbol} created`,
      displayText: `${symbols.createdDateSymbol} created today (${formattedDate})`,
      appendText: `${symbols.createdDateSymbol} ${formattedDate}` + postfix,
      insertSkip: dataviewMode ? insertSkip : void 0
    });
  }
  const wordMatch = matchIfCursorInRegex(line, /([a-zA-Z'_-]*)/g, cursorPos);
  const matchingSuggestions = [];
  if (wordMatch && wordMatch.length > 0) {
    const wordUnderCursor = wordMatch[0];
    if (wordUnderCursor.length >= Math.max(1, _settings.autoSuggestMinMatch)) {
      const filteredSuggestions = genericSuggestions.filter((suggestInfo) => {
        const textToMatch = suggestInfo.textToMatch || suggestInfo.displayText;
        return textToMatch.toLowerCase().includes(wordUnderCursor.toLowerCase());
      });
      for (const filtered of filteredSuggestions) {
        const insertSkipValue = dataviewMode && (filtered.displayText.includes("priority") || filtered.displayText.includes("created")) ? wordUnderCursor.length + insertSkip : wordUnderCursor.length;
        matchingSuggestions.push({
          suggestionType: "match",
          displayText: filtered.displayText,
          appendText: filtered.appendText,
          insertAt: wordMatch.index,
          insertSkip: insertSkipValue
        });
      }
    }
  }
  if (matchingSuggestions.length === 0 && _settings.autoSuggestMinMatch === 0)
    return genericSuggestions;
  return matchingSuggestions;
}
function addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions, dataviewMode) {
  const genericSuggestions = [
    "today",
    "tomorrow",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "next week",
    "next month",
    "next year"
  ];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  const results = [];
  const dateRegex = new RegExp(`(${datePrefixRegex})\\s*([0-9a-zA-Z ]*)`, "ug");
  const dateMatch = matchIfCursorInRegex(line, dateRegex, cursorPos);
  if (dateMatch && dateMatch.length >= 2) {
    const datePrefix = dateMatch[1];
    const dateString = dateMatch[2];
    if (dateString.length < settings2.autoSuggestMinMatch) {
      return [];
    }
    const possibleDate = dateString && dateString.length > 1 ? DateParser.parseDate(doAutocomplete(dateString), true) : null;
    if (possibleDate && possibleDate.isValid()) {
      results.push({
        displayText: `${possibleDate.format(TaskRegularExpressions.dateFormat)}`,
        appendText: `${datePrefix} ${possibleDate.format(TaskRegularExpressions.dateFormat)} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
    const minMatch = 1;
    let genericMatches = genericSuggestions.filter(
      (value) => dateString && dateString.length >= minMatch && value.toLowerCase().includes(dateString.toLowerCase())
    ).slice(0, maxGenericSuggestions);
    if (genericMatches.length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericSuggestions);
    }
    for (const match of genericMatches) {
      const parsedDate = DateParser.parseDate(match, true);
      const formattedDate = `${parsedDate.format(TaskRegularExpressions.dateFormat)}`;
      const insertSkipValue = dataviewMode ? dateMatch[0].length + insertSkip : dateMatch[0].length;
      results.push({
        suggestionType: "match",
        displayText: `${match} (${formattedDate})`,
        appendText: `${datePrefix} ${formattedDate}` + postfix,
        insertAt: dateMatch.index,
        insertSkip: insertSkipValue
      });
    }
  }
  return results;
}
function addRecurrenceSuggestions(line, cursorPos, settings2, recurrenceSymbol, dataviewMode) {
  var _a;
  const genericSuggestions = [
    "every",
    "every day",
    "every week",
    "every month",
    "every month on the",
    "every year",
    "every week on Sunday",
    "every week on Monday",
    "every week on Tuesday",
    "every week on Wednesday",
    "every week on Thursday",
    "every week on Friday",
    "every week on Saturday"
  ];
  const { postfix, insertSkip } = getAdjusters(dataviewMode, line, cursorPos);
  const results = [];
  const recurrenceRegex = new RegExp(`(${recurrenceSymbol})\\s*([0-9a-zA-Z ]*)`, "ug");
  const recurrenceMatch = matchIfCursorInRegex(line, recurrenceRegex, cursorPos);
  if (recurrenceMatch && recurrenceMatch.length >= 2) {
    const recurrencePrefix = recurrenceMatch[1];
    const recurrenceString = recurrenceMatch[2];
    if (recurrenceString.length < settings2.autoSuggestMinMatch)
      return [];
    if (recurrenceString.length > 0) {
      const parsedRecurrence = (_a = Recurrence.fromText({
        recurrenceRuleText: recurrenceString,
        startDate: null,
        scheduledDate: null,
        dueDate: null,
        reminderDate: null
      })) == null ? void 0 : _a.toText();
      if (parsedRecurrence) {
        const appendedText = `${recurrencePrefix} ${parsedRecurrence}` + postfix;
        const insertSkipValue = dataviewMode ? recurrenceMatch[0].length + insertSkip : recurrenceMatch[0].length;
        results.push({
          suggestionType: "match",
          displayText: `\u2705 ${parsedRecurrence}`,
          appendText: appendedText,
          insertAt: recurrenceMatch.index,
          insertSkip: insertSkipValue
        });
        if (recurrenceMatch[0] == appendedText)
          return [];
      }
    }
    const minMatch = 1;
    const maxGenericDateSuggestions = settings2.autoSuggestMaxItems / 2;
    let genericMatches = genericSuggestions.filter(
      (value) => recurrenceString && recurrenceString.length >= minMatch && value.toLowerCase().includes(recurrenceString.toLowerCase())
    ).slice(0, maxGenericDateSuggestions);
    if (genericMatches.length === 0 && recurrenceString.trim().length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericDateSuggestions);
    }
    for (const match of genericMatches) {
      results.push({
        suggestionType: "match",
        displayText: `${match}`,
        appendText: `${recurrencePrefix} ${match} `,
        insertAt: recurrenceMatch.index,
        insertSkip: recurrenceMatch[0].length
      });
    }
  }
  return results;
}
function addIDSuggestion(line, cursorPos, idSymbol, allTasks) {
  const results = [];
  const idRegex = new RegExp(`(${idSymbol})\\s*(${taskIdRegex.source})?`, "ug");
  const idMatch = matchIfCursorInRegex(line, idRegex, cursorPos);
  if (idMatch && idMatch[0].trim().length <= idSymbol.length) {
    const ID = generateUniqueId(allTasks.map((task) => task.id));
    results.push({
      suggestionType: "match",
      displayText: "Auto Generate Unique ID",
      appendText: `${idSymbol} ${ID}`,
      insertAt: idMatch.index,
      insertSkip: idSymbol.length
    });
  }
  return results;
}
function addDependsOnSuggestions(line, cursorPos, settings2, dependsOnSymbol, allTasks, taskToSuggestFor) {
  const results = [];
  const dependsOnRegex = new RegExp(`(${dependsOnSymbol})([0-9a-zA-Z-_ ^,]*,)*([0-9a-zA-Z ^,]*)`, "ug");
  const dependsOnMatch = matchIfCursorInRegex(line, dependsOnRegex, cursorPos);
  if (dependsOnMatch && dependsOnMatch.length >= 1) {
    const existingDependsOnIdStrings = dependsOnMatch[2] || "";
    const newTaskToAppend = dependsOnMatch[3];
    let blockingTasks = [];
    if (existingDependsOnIdStrings) {
      const idsArray = existingDependsOnIdStrings.split(",").map((id) => id.trim());
      blockingTasks = allTasks.filter((task) => task.id && idsArray.includes(task.id));
    }
    if (newTaskToAppend.length >= settings2.autoSuggestMinMatch) {
      const genericMatches = searchForCandidateTasksForDependency(
        newTaskToAppend.trim(),
        allTasks,
        taskToSuggestFor,
        [],
        blockingTasks
      );
      for (const task of genericMatches) {
        results.push({
          suggestionType: "match",
          displayText: `${task.descriptionWithoutTags} - From: ${task.filename}.md`,
          appendText: `${dependsOnSymbol}${existingDependsOnIdStrings}`,
          insertAt: dependsOnMatch.index,
          insertSkip: dependsOnSymbol.length + existingDependsOnIdStrings.length + newTaskToAppend.length,
          taskItDependsOn: task
        });
      }
    }
  }
  return results;
}
function matchIfCursorInRegex(s, r, position) {
  const matches = s.matchAll(r);
  for (const match of matches) {
    if ((match == null ? void 0 : match.index) && match.index < position && position <= match.index + match[0].length)
      return match;
  }
}
function isAnyBracketOpen(line, brackets) {
  if (brackets.length === 0) {
    return false;
  }
  const numOpeningBrackets = Object.fromEntries(brackets.map(([open, _]) => [open, 0]));
  const openingOf = Object.fromEntries(brackets.map(([open, close]) => [close, open]));
  for (const c of line) {
    if (c in numOpeningBrackets) {
      numOpeningBrackets[c]++;
    } else if (c in openingOf) {
      numOpeningBrackets[openingOf[c]] = Math.max(0, numOpeningBrackets[openingOf[c]] - 1);
    }
  }
  return Object.values(numOpeningBrackets).some((n) => n > 0);
}
function lastOpenBracket(line, brackets) {
  if (brackets.length === 0) {
    return null;
  }
  const numOpeningBrackets = Object.fromEntries(brackets.map(([open, _]) => [open, 0]));
  const openingOf = Object.fromEntries(brackets.map(([open, close]) => [close, open]));
  const openBracketsStack = [];
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c in numOpeningBrackets) {
      numOpeningBrackets[c]++;
      openBracketsStack.push({ bracket: c, idx: i });
    } else if (c in openingOf) {
      if (numOpeningBrackets[openingOf[c]] >= 1) {
        for (let idx = openBracketsStack.length - 1; idx >= 0; idx--) {
          if (openBracketsStack[idx].bracket == openingOf[c]) {
            openBracketsStack.splice(idx, 1);
            break;
          }
        }
      }
      numOpeningBrackets[openingOf[c]] = Math.max(0, numOpeningBrackets[openingOf[c]] - 1);
    }
  }
  return openBracketsStack.length > 0 ? openBracketsStack[openBracketsStack.length - 1].bracket : null;
}
function onlySuggestIfBracketOpen(fn, brackets) {
  return (line, cursorPos, settings2, taskToSuggestFor, allTasks) => {
    if (!isAnyBracketOpen(line.slice(0, cursorPos), brackets)) {
      return [];
    }
    return fn(line, cursorPos, settings2, taskToSuggestFor, allTasks);
  };
}
function canSuggestForLine(line, cursor, editor) {
  const lineHasGlobalFilter = GlobalFilter.getInstance().includedIn(line);
  const didEditorRequest = editorIsRequestingSuggest(editor, cursor, lineHasGlobalFilter);
  if (typeof didEditorRequest === "boolean")
    return didEditorRequest;
  return lineHasGlobalFilter && cursorIsInTaskLineDescription(line, cursor.ch);
}
function editorIsRequestingSuggest(editor, cursor, lineHasGlobalFilter) {
  var _a, _b;
  return (_b = (_a = editor == null ? void 0 : editor.editorComponent) == null ? void 0 : _a.showTasksPluginAutoSuggest) == null ? void 0 : _b.call(_a, cursor, editor, lineHasGlobalFilter);
}
function cursorIsInTaskLineDescription(line, cursorPosition) {
  if (line.length === 0) {
    return false;
  }
  const components = Task.extractTaskComponents(line);
  if (!components) {
    return false;
  }
  const beforeDescription = components.indentation + components.listMarker + " [" + components.status.symbol + "] ";
  return cursorPosition >= beforeDescription.length;
}

// src/TaskSerializer/DataviewTaskSerializer.ts
function toInlineFieldRegex(innerFieldRegex) {
  const fieldRegex = [
    "(?:",
    /(?=[^\]]+\])\[/,
    "|",
    /(?=[^)]+\))\(/,
    ")",
    / */,
    innerFieldRegex,
    / */,
    /[)\]]/,
    /(?: *,)?/,
    /$/
  ].map((val) => val instanceof RegExp ? val.source : val).join("");
  return new RegExp(fieldRegex, innerFieldRegex.flags);
}
var DATAVIEW_SYMBOLS = {
  prioritySymbols: {
    Highest: "priority:: highest",
    High: "priority:: high",
    Medium: "priority:: medium",
    Low: "priority:: low",
    Lowest: "priority:: lowest",
    None: ""
  },
  startDateSymbol: "start::",
  createdDateSymbol: "created::",
  scheduledDateSymbol: "scheduled::",
  dueDateSymbol: "due::",
  reminderDateSymbol: "reminder::",
  doneDateSymbol: "completion::",
  cancelledDateSymbol: "cancelled::",
  recurrenceSymbol: "repeat::",
  idSymbol: "id::",
  dependsOnSymbol: "dependsOn::",
  TaskFormatRegularExpressions: {
    priorityRegex: toInlineFieldRegex(/priority:: *(highest|high|medium|low|lowest)/),
    startDateRegex: toInlineFieldRegex(/start:: *(\d{4}-\d{2}-\d{2})/),
    createdDateRegex: toInlineFieldRegex(/created:: *(\d{4}-\d{2}-\d{2})/),
    scheduledDateRegex: toInlineFieldRegex(/scheduled:: *(\d{4}-\d{2}-\d{2})/),
    dueDateRegex: toInlineFieldRegex(/due:: *(\d{4}-\d{2}-\d{2})/),
    reminderDateTimeRegex: toInlineFieldRegex(/reminder:: *(\d{4}-\d{2}-\d{2} \d{2}:\d{2})/),
    reminderDateRegex: toInlineFieldRegex(/reminder:: *(\d{4}-\d{2}-\d{2})/),
    doneDateRegex: toInlineFieldRegex(/completion:: *(\d{4}-\d{2}-\d{2})/),
    cancelledDateRegex: toInlineFieldRegex(/cancelled:: *(\d{4}-\d{2}-\d{2})/),
    recurrenceRegex: toInlineFieldRegex(/repeat:: *([a-zA-Z0-9, !]+)/),
    dependsOnRegex: toInlineFieldRegex(new RegExp("dependsOn:: *(" + taskIdSequenceRegex.source + ")")),
    idRegex: toInlineFieldRegex(new RegExp("id:: *(" + taskIdRegex.source + ")"))
  }
};
var DataviewTaskSerializer = class extends DefaultTaskSerializer {
  constructor() {
    super(DATAVIEW_SYMBOLS);
  }
  parsePriority(p) {
    switch (p) {
      case "highest":
        return "0" /* Highest */;
      case "high":
        return "1" /* High */;
      case "medium":
        return "2" /* Medium */;
      case "low":
        return "4" /* Low */;
      case "lowest":
        return "5" /* Lowest */;
      default:
        return "3" /* None */;
    }
  }
  componentToString(task, shortMode, component) {
    const stringComponent = super.componentToString(task, shortMode, component);
    const notInlineFieldComponents = [
      "blockLink" /* BlockLink */,
      "description" /* Description */
    ];
    const shouldMakeInlineField = stringComponent !== "" && !notInlineFieldComponents.includes(component);
    return shouldMakeInlineField ? `  [${stringComponent.trim()}]` : stringComponent;
  }
};

// src/Statuses/StatusConfiguration.ts
var StatusType = /* @__PURE__ */ ((StatusType2) => {
  StatusType2["TODO"] = "TODO";
  StatusType2["DONE"] = "DONE";
  StatusType2["IN_PROGRESS"] = "IN_PROGRESS";
  StatusType2["CANCELLED"] = "CANCELLED";
  StatusType2["NON_TASK"] = "NON_TASK";
  StatusType2["EMPTY"] = "EMPTY";
  return StatusType2;
})(StatusType || {});
var StatusConfiguration = class {
  constructor(symbol, name, nextStatusSymbol, availableAsCommand, type = "TODO" /* TODO */) {
    this.symbol = symbol;
    this.name = name;
    this.nextStatusSymbol = nextStatusSymbol;
    this.availableAsCommand = availableAsCommand;
    this.type = type;
  }
};

// src/Statuses/Status.ts
var _Status = class {
  get symbol() {
    return this.configuration.symbol;
  }
  get name() {
    return this.configuration.name;
  }
  get nextStatusSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  get nextSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  get availableAsCommand() {
    return this.configuration.availableAsCommand;
  }
  get type() {
    return this.configuration.type;
  }
  get typeGroupText() {
    const type = this.type;
    let prefix;
    switch (type) {
      case "IN_PROGRESS" /* IN_PROGRESS */:
        prefix = "1";
        break;
      case "TODO" /* TODO */:
        prefix = "2";
        break;
      case "DONE" /* DONE */:
        prefix = "3";
        break;
      case "CANCELLED" /* CANCELLED */:
        prefix = "4";
        break;
      case "NON_TASK" /* NON_TASK */:
        prefix = "5";
        break;
      case "EMPTY" /* EMPTY */:
        prefix = "6";
        break;
    }
    return `%%${prefix}%%${type}`;
  }
  constructor(configuration) {
    this.configuration = configuration;
  }
  static makeDone() {
    return new _Status(new StatusConfiguration("x", "Done", " ", true, "DONE" /* DONE */));
  }
  static makeEmpty() {
    return new _Status(new StatusConfiguration("", "EMPTY", "", true, "EMPTY" /* EMPTY */));
  }
  static makeTodo() {
    return new _Status(new StatusConfiguration(" ", "Todo", "x", true, "TODO" /* TODO */));
  }
  static makeCancelled() {
    return new _Status(new StatusConfiguration("-", "Cancelled", " ", true, "CANCELLED" /* CANCELLED */));
  }
  static makeInProgress() {
    return new _Status(new StatusConfiguration("/", "In Progress", "x", true, "IN_PROGRESS" /* IN_PROGRESS */));
  }
  static makeNonTask() {
    return new _Status(new StatusConfiguration("Q", "Non-Task", "A", true, "NON_TASK" /* NON_TASK */));
  }
  static getTypeForUnknownSymbol(symbol) {
    switch (symbol) {
      case "x":
      case "X":
        return "DONE" /* DONE */;
      case "/":
        return "IN_PROGRESS" /* IN_PROGRESS */;
      case "-":
        return "CANCELLED" /* CANCELLED */;
      case "":
        return "EMPTY" /* EMPTY */;
      case " ":
      default:
        return "TODO" /* TODO */;
    }
  }
  static getTypeFromStatusTypeString(statusTypeAsString) {
    return StatusType[statusTypeAsString] || "TODO" /* TODO */;
  }
  static createUnknownStatus(unknownSymbol) {
    return new _Status(new StatusConfiguration(unknownSymbol, "Unknown", "x", false, "TODO" /* TODO */));
  }
  static createFromImportedValue(imported) {
    const symbol = imported[0];
    const type = _Status.getTypeFromStatusTypeString(imported[3]);
    return new _Status(new StatusConfiguration(symbol, imported[1], imported[2], false, type));
  }
  isCompleted() {
    return this.type === "DONE" /* DONE */;
  }
  isCancelled() {
    return this.type === "CANCELLED" /* CANCELLED */;
  }
  identicalTo(other) {
    const args = [
      "symbol",
      "name",
      "nextStatusSymbol",
      "availableAsCommand",
      "type"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    return true;
  }
  previewText() {
    let commandNotice = "";
    if (_Status.tasksPluginCanCreateCommandsForStatuses() && this.availableAsCommand) {
      commandNotice = " Available as a command.";
    }
    return `- [${this.symbol}] => [${this.nextStatusSymbol}], name: '${this.name}', type: '${this.configuration.type}'.${commandNotice}`;
  }
  static tasksPluginCanCreateCommandsForStatuses() {
    return false;
  }
};
var Status = _Status;
Status.DONE = _Status.makeDone();
Status.EMPTY = _Status.makeEmpty();
Status.TODO = _Status.makeTodo();

// src/Config/DebugSettings.ts
var DebugSettings = class {
  constructor(ignoreSortInstructions = false, showTaskHiddenData = false, recordTimings = false) {
    this.ignoreSortInstructions = ignoreSortInstructions;
    this.showTaskHiddenData = showTaskHiddenData;
    this.recordTimings = recordTimings;
  }
};

// src/Config/StatusSettings.ts
var StatusSettings = class {
  constructor() {
    this.coreStatuses = [
      Status.makeTodo().configuration,
      Status.makeDone().configuration
    ];
    this.customStatuses = [
      Status.makeInProgress().configuration,
      Status.makeCancelled().configuration
    ];
  }
  static addStatus(statuses, newStatus) {
    statuses.push(newStatus);
  }
  static replaceStatus(statuses, originalStatus, newStatus) {
    const index = this.findStatusIndex(originalStatus, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1, newStatus);
    return true;
  }
  static findStatusIndex(statusConfiguration, statuses) {
    const originalStatusAsStatus = new Status(statusConfiguration);
    return statuses.findIndex((s) => {
      return new Status(s).previewText() == originalStatusAsStatus.previewText();
    });
  }
  static deleteStatus(statuses, status) {
    const index = this.findStatusIndex(status, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1);
    return true;
  }
  static deleteAllCustomStatuses(statusSettings) {
    statusSettings.customStatuses.splice(0);
  }
  static resetAllCustomStatuses(statusSettings) {
    StatusSettings.deleteAllCustomStatuses(statusSettings);
    const defaultSettings2 = new StatusSettings();
    defaultSettings2.customStatuses.forEach((s) => {
      StatusSettings.addStatus(statusSettings.customStatuses, s);
    });
  }
  static bulkAddStatusCollection(statusSettings, supportedStatuses) {
    const notices = [];
    supportedStatuses.forEach((importedStatus) => {
      const hasStatus = statusSettings.customStatuses.find((element2) => {
        return element2.symbol == importedStatus[0] && element2.name == importedStatus[1] && element2.nextStatusSymbol == importedStatus[2];
      });
      if (!hasStatus) {
        StatusSettings.addStatus(statusSettings.customStatuses, Status.createFromImportedValue(importedStatus));
      } else {
        notices.push(`The status ${importedStatus[1]} (${importedStatus[0]}) is already added.`);
      }
    });
    return notices;
  }
  static allStatuses(statusSettings) {
    return statusSettings.coreStatuses.concat(statusSettings.customStatuses);
  }
  static applyToStatusRegistry(statusSettings, statusRegistry) {
    statusRegistry.clearStatuses();
    StatusSettings.allStatuses(statusSettings).forEach((statusType) => {
      statusRegistry.add(statusType);
    });
  }
};

// src/Config/featureConfiguration.json
var featureConfiguration_default = [
  {
    index: 9999,
    internalName: "INTERNAL_TESTING_ENABLED_BY_DEFAULT",
    displayName: "Test Item. Used to validate the Feature Framework.",
    description: "Description",
    enabledByDefault: true,
    stable: false
  }
];

// src/Config/Feature.ts
var Feature = class {
  constructor(internalName, index, description, displayName, enabledByDefault, stable) {
    this.internalName = internalName;
    this.index = index;
    this.description = description;
    this.displayName = displayName;
    this.enabledByDefault = enabledByDefault;
    this.stable = stable;
  }
  static get values() {
    let availableFeatures = [];
    featureConfiguration_default.forEach((feature) => {
      availableFeatures = [
        ...availableFeatures,
        new Feature(
          feature.internalName,
          feature.index,
          feature.description,
          feature.displayName,
          feature.enabledByDefault,
          feature.stable
        )
      ];
    });
    return availableFeatures;
  }
  static get settingsFlags() {
    const featureFlags = {};
    Feature.values.forEach((feature) => {
      featureFlags[feature.internalName] = feature.enabledByDefault;
    });
    return featureFlags;
  }
  static fromString(name) {
    for (const feature of Feature.values) {
      if (name === feature.internalName) {
        return feature;
      }
    }
    throw new RangeError(
      `Illegal argument passed to fromString(): ${name} does not correspond to any available Feature ${this.prototype.constructor.name}`
    );
  }
};

// src/Config/Settings.ts
var TASK_FORMATS = {
  tasksPluginEmoji: {
    displayName: "Tasks Emoji Format",
    taskSerializer: new DefaultTaskSerializer(DEFAULT_SYMBOLS),
    buildSuggestions: makeDefaultSuggestionBuilder(DEFAULT_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS, false)
  },
  dataview: {
    displayName: "Dataview",
    taskSerializer: new DataviewTaskSerializer(),
    buildSuggestions: onlySuggestIfBracketOpen(
      makeDefaultSuggestionBuilder(DATAVIEW_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS, true),
      [
        ["(", ")"],
        ["[", "]"]
      ]
    )
  }
};
var defaultSettings = {
  globalQuery: "",
  globalFilter: "",
  removeGlobalFilter: false,
  taskFormat: "tasksPluginEmoji",
  setCreatedDate: false,
  setDoneDate: true,
  setCancelledDate: true,
  autoSuggestInEditor: true,
  autoSuggestMinMatch: 0,
  autoSuggestMaxItems: 6,
  provideAccessKeys: true,
  useFilenameAsScheduledDate: false,
  filenameAsDateFolders: [],
  recurrenceOnNextLine: false,
  statusSettings: new StatusSettings(),
  features: Feature.settingsFlags,
  generalSettings: {},
  headingOpened: {},
  debugSettings: new DebugSettings(),
  loggingOptions: {
    minLevels: {
      "": "info",
      tasks: "info",
      "tasks.Cache": "info",
      "tasks.Events": "info",
      "tasks.File": "info",
      "tasks.Query": "info",
      "tasks.Task": "info"
    }
  }
};
var settings = __spreadValues({}, defaultSettings);
function addNewOptionsToUserSettings(defaultValues, userValues) {
  for (const flag in defaultValues) {
    if (userValues[flag] === void 0) {
      userValues[flag] = defaultValues[flag];
    }
  }
}
var getSettings = () => {
  addNewOptionsToUserSettings(Feature.settingsFlags, settings.features);
  addNewOptionsToUserSettings(defaultSettings.loggingOptions.minLevels, settings.loggingOptions.minLevels);
  addNewOptionsToUserSettings(defaultSettings.debugSettings, settings.debugSettings);
  settings.statusSettings.customStatuses.forEach((s, index, array) => {
    var _a, _b;
    const newType = Status.getTypeFromStatusTypeString(s.type);
    array[index] = new StatusConfiguration(
      (_a = s.symbol) != null ? _a : " ",
      s.name,
      (_b = s.nextStatusSymbol) != null ? _b : "x",
      s.availableAsCommand,
      newType
    );
  });
  return __spreadValues({}, settings);
};
var updateSettings = (newSettings) => {
  settings = __spreadValues(__spreadValues({}, settings), newSettings);
  return getSettings();
};
var updateGeneralSetting = (name, value) => {
  settings.generalSettings[name] = value;
  return getSettings();
};
var isFeatureEnabled = (internalName) => {
  var _a;
  return (_a = settings.features[internalName]) != null ? _a : false;
};
function getUserSelectedTaskFormat() {
  return TASK_FORMATS[getSettings().taskFormat];
}

// src/lib/HTMLCharacterEntities.ts
function htmlEncodeCharacter(character) {
  const charactersToEntityNames = {
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;"
  };
  const candidateEntityName = charactersToEntityNames[character];
  if (candidateEntityName !== void 0) {
    return candidateEntityName;
  }
  return character;
}
function htmlEncodeString(characters) {
  const chars = [...characters];
  let result = "";
  chars.forEach((c) => {
    result += htmlEncodeCharacter(c);
  });
  return result;
}

// src/Statuses/StatusRegistry.ts
var StatusRegistry = class {
  constructor() {
    this._registeredStatuses = [];
    this.addDefaultStatusTypes();
  }
  set(statuses) {
    this.clearStatuses();
    statuses.forEach((status) => {
      this.add(status);
    });
  }
  get registeredStatuses() {
    return this._registeredStatuses.filter(({ symbol }) => symbol !== Status.EMPTY.symbol);
  }
  static getInstance() {
    if (!StatusRegistry.instance) {
      StatusRegistry.instance = new StatusRegistry();
    }
    return StatusRegistry.instance;
  }
  add(status) {
    if (!this.hasSymbol(status.symbol)) {
      if (status instanceof Status) {
        this._registeredStatuses.push(status);
      } else {
        this._registeredStatuses.push(new Status(status));
      }
    }
  }
  bySymbol(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.EMPTY;
  }
  bySymbolOrCreate(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.createUnknownStatus(symbol);
  }
  byName(nameToFind) {
    if (this._registeredStatuses.filter(({ name }) => name === nameToFind).length > 0) {
      return this._registeredStatuses.filter(({ name }) => name === nameToFind)[0];
    }
    return Status.EMPTY;
  }
  resetToDefaultStatuses() {
    this.clearStatuses();
    this.addDefaultStatusTypes();
  }
  clearStatuses() {
    this._registeredStatuses = [];
  }
  getNextStatus(status) {
    if (status.nextStatusSymbol !== "") {
      const nextStatus = this.bySymbol(status.nextStatusSymbol);
      if (nextStatus !== null) {
        return nextStatus;
      }
    }
    return Status.EMPTY;
  }
  getNextStatusOrCreate(status) {
    const nextStatus = this.getNextStatus(status);
    if (nextStatus.type !== "EMPTY" /* EMPTY */) {
      return nextStatus;
    }
    return Status.createUnknownStatus(status.nextStatusSymbol);
  }
  getNextRecurrenceStatusOrCreate(newStatus) {
    const nextStatus = this.getNextStatusOrCreate(newStatus);
    const result1 = this.getNextRecurrenceStatusOfType(nextStatus, "TODO" /* TODO */);
    if (result1) {
      return result1;
    }
    const result2 = this.getNextRecurrenceStatusOfType(nextStatus, "IN_PROGRESS" /* IN_PROGRESS */);
    if (result2) {
      return result2;
    }
    return this.bySymbolOrCreate(" ");
  }
  getNextRecurrenceStatusOfType(nextStatus, wanted) {
    if (nextStatus.type === wanted) {
      return nextStatus;
    }
    let searchStatus = nextStatus;
    for (let i = 0; i < this.registeredStatuses.length - 1; i++) {
      searchStatus = this.getNextStatusOrCreate(searchStatus);
      if (searchStatus.type === wanted) {
        return searchStatus;
      }
    }
    return void 0;
  }
  findUnknownStatuses(allStatuses) {
    const unknownStatuses = allStatuses.filter((s) => {
      return !this.hasSymbol(s.symbol);
    });
    const newStatusRegistry = new StatusRegistry();
    const namedUniqueStatuses = [];
    unknownStatuses.forEach((s) => {
      if (newStatusRegistry.hasSymbol(s.symbol)) {
        return;
      }
      const newStatus = StatusRegistry.copyStatusWithNewName(s, `Unknown (${s.symbol})`);
      namedUniqueStatuses.push(newStatus);
      newStatusRegistry.add(newStatus);
    });
    return namedUniqueStatuses.sort((status1, status2) => {
      return status1.symbol.localeCompare(status2.symbol, void 0, { numeric: true });
    });
  }
  static copyStatusWithNewName(s, newName) {
    const statusConfiguration = new StatusConfiguration(
      s.symbol,
      newName,
      s.nextStatusSymbol,
      s.availableAsCommand,
      s.type
    );
    return new Status(statusConfiguration);
  }
  getSymbol(symbolToFind) {
    return this._registeredStatuses.filter(({ symbol }) => symbol === symbolToFind)[0];
  }
  hasSymbol(symbolToFind) {
    return this._registeredStatuses.find((element2) => {
      return element2.symbol === symbolToFind;
    }) !== void 0;
  }
  addDefaultStatusTypes() {
    const defaultStatuses = [Status.makeTodo(), Status.makeInProgress(), Status.makeDone(), Status.makeCancelled()];
    defaultStatuses.forEach((status) => {
      this.add(status);
    });
  }
  mermaidDiagram(includeDetails = false) {
    const uniqueStatuses = this.registeredStatuses;
    const language = "mermaid";
    const nodes = [];
    const edges = [];
    uniqueStatuses.forEach((status, index) => {
      const label = this.getMermaidNodeLabel(status, includeDetails);
      nodes.push(`${index + 1}${label}`);
      const nextStatus = this.getNextStatus(status);
      this.addEdgeIfNotToInternal(uniqueStatuses, nextStatus, edges, index, false);
      if (status.type === "DONE" /* DONE */) {
        const nextRecurringStatus = this.getNextRecurrenceStatusOrCreate(status);
        const nextRecurringTypeDiffers = nextRecurringStatus.symbol !== nextStatus.symbol;
        if (nextRecurringTypeDiffers) {
          this.addEdgeIfNotToInternal(uniqueStatuses, nextRecurringStatus, edges, index, true);
        }
      }
    });
    return `
\`\`\`${language}
flowchart LR

classDef TODO        stroke:#f33,stroke-width:3px;
classDef DONE        stroke:#0c0,stroke-width:3px;
classDef IN_PROGRESS stroke:#fa0,stroke-width:3px;
classDef CANCELLED   stroke:#ddd,stroke-width:3px;
classDef NON_TASK    stroke:#99e,stroke-width:3px;

${nodes.join("\n")}
${edges.join("\n")}

linkStyle default stroke:gray
\`\`\`
`;
  }
  addEdgeIfNotToInternal(uniqueStatuses, nextStatus, edges, index, isForReccurenceOverride) {
    const nextStatusIndex = uniqueStatuses.findIndex((status) => status.symbol === nextStatus.symbol);
    const nextStatusIsKnown = nextStatusIndex !== -1;
    const nextStatusIsNotInternal = nextStatus.type !== "EMPTY" /* EMPTY */;
    if (nextStatusIsKnown && nextStatusIsNotInternal) {
      let joiner;
      if (isForReccurenceOverride) {
        joiner = '-. "\u{1F501}" .-> ';
      } else {
        joiner = " --> ";
      }
      const line = `${index + 1}${joiner}${nextStatusIndex + 1}`;
      edges.push(line);
    }
  }
  getMermaidNodeLabel(status, includeDetails) {
    const statusName = htmlEncodeString(status.name);
    const statusType = status.type;
    if (includeDetails) {
      const statusSymbol = htmlEncodeCharacter(status.symbol);
      const statusNextStatusSymbol = htmlEncodeCharacter(status.nextStatusSymbol);
      const transitionText = `[${statusSymbol}] -> [${statusNextStatusSymbol}]`;
      const statusNameText = `'${statusName}'`;
      const statusTypeText = `(${statusType})`;
      return `["${statusNameText}<br>${transitionText}<br>${statusTypeText}"]:::${statusType}`;
    } else {
      return `["${statusName}"]:::${statusType}`;
    }
  }
};

// src/Scripting/TasksDate.ts
var import_obsidian2 = require("obsidian");

// src/lib/PropertyCategory.ts
var PropertyCategory = class {
  constructor(name, sortOrder) {
    this.name = name;
    this.sortOrder = sortOrder;
  }
  get groupText() {
    if (this.name !== "") {
      return `%%${this.sortOrder}%% ${this.name}`;
    } else {
      return "";
    }
  }
};

// src/Scripting/TasksDate.ts
var TasksDate = class {
  constructor(date) {
    this._date = null;
    this._date = date;
  }
  get moment() {
    return this._date;
  }
  formatAsDate(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateFormat, fallBackText);
  }
  formatAsDateAndTime(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateTimeFormat, fallBackText);
  }
  formatAsDateAndTimeOrDate(fallBackText = "") {
    return isDateTime(this.moment) ? this.formatAsDateAndTime(fallBackText) : this.formatAsDate(fallBackText);
  }
  format(format, fallBackText = "") {
    return this._date ? this._date.format(format) : fallBackText;
  }
  toISOString(keepOffset) {
    return this._date ? this._date.toISOString(keepOffset) : "";
  }
  get category() {
    const today = window.moment();
    const date = this.moment;
    if (!date) {
      return new PropertyCategory("Undated", 4);
    }
    if (date.isBefore(today, "day")) {
      return new PropertyCategory("Overdue", 1);
    }
    if (date.isSame(today, "day")) {
      return new PropertyCategory("Today", 2);
    }
    if (!date.isValid()) {
      return new PropertyCategory("Invalid date", 0);
    }
    return new PropertyCategory("Future", 3);
  }
  get fromNow() {
    const date = this.moment;
    if (!date) {
      return new PropertyCategory("", 0);
    }
    const order = this.fromNowOrder(date);
    return new PropertyCategory(date.fromNow(), order);
  }
  fromNowOrder(date) {
    if (!date.isValid()) {
      return 0;
    }
    const now = window.moment();
    const earlier = date.isSameOrBefore(now, "day");
    const startDateOfThisGroup = this.fromNowStartDateOfGroup(date, earlier, now);
    const splitPastAndFutureDates = earlier ? 1 : 3;
    return Number(splitPastAndFutureDates + startDateOfThisGroup.format("YYYYMMDD"));
  }
  fromNowStartDateOfGroup(date, earlier, now) {
    const words = date.fromNow(true).split(" ");
    let multiplier;
    const word0AsNumber = Number(words[0]);
    if (isNaN(word0AsNumber)) {
      multiplier = 1;
    } else {
      multiplier = word0AsNumber;
    }
    const unit = words[1];
    return earlier ? now.subtract(multiplier, unit) : now.add(multiplier, unit);
  }
  postpone(unitOfTime = "days", amount = 1) {
    if (!this._date)
      throw new import_obsidian2.Notice("Cannot postpone a null date");
    const today = window.moment().startOf("day");
    const isDateBeforeToday = !this._date.isSameOrAfter(today, "day");
    if (isDateBeforeToday) {
      return today.add(amount, unitOfTime);
    }
    return this._date.clone().add(amount, unitOfTime);
  }
};

// src/lib/PriorityTools.ts
var PriorityTools = class {
  static priorityNameUsingNone(priority) {
    let priorityName = "ERROR";
    switch (priority) {
      case "1" /* High */:
        priorityName = "High";
        break;
      case "0" /* Highest */:
        priorityName = "Highest";
        break;
      case "2" /* Medium */:
        priorityName = "Medium";
        break;
      case "3" /* None */:
        priorityName = "None";
        break;
      case "4" /* Low */:
        priorityName = "Low";
        break;
      case "5" /* Lowest */:
        priorityName = "Lowest";
        break;
    }
    return priorityName;
  }
  static priorityNameUsingNormal(priority) {
    return PriorityTools.priorityNameUsingNone(priority).replace("None", "Normal");
  }
};

// src/lib/logging.ts
var import_obsidian3 = require("obsidian");
var import_eventemitter2 = __toESM(require_eventemitter2());
var LogManager = class extends import_eventemitter2.EventEmitter2 {
  constructor() {
    super(...arguments);
    this.options = {
      minLevels: {
        "": "info",
        tasks: "info"
      }
    };
    this.consoleLoggerRegistered = false;
    this.arrAvg = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
  }
  configure(options) {
    this.options = Object.assign({}, this.options, options);
    return this;
  }
  getLogger(module2) {
    let minLevel = "none";
    let match = "";
    for (const key in this.options.minLevels) {
      if (module2.startsWith(key) && key.length >= match.length) {
        minLevel = this.options.minLevels[key];
        match = key;
      }
    }
    return new Logger(this, module2, minLevel);
  }
  onLogEntry(listener) {
    this.on("log", listener);
    return this;
  }
  registerConsoleLogger() {
    if (this.consoleLoggerRegistered)
      return this;
    this.onLogEntry((logEntry) => {
      let msg = `[${window.moment().format("YYYY-MM-DD-HH:mm:ss.SSS")}][${logEntry.level}][${logEntry.module}]`;
      if (logEntry.traceId) {
        msg += `[${logEntry.traceId}]`;
      }
      msg += ` ${logEntry.message}`;
      if (logEntry.objects === void 0) {
        logEntry.objects = "";
      }
      switch (logEntry.level) {
        case "trace":
          console.trace(msg, logEntry.objects);
          break;
        case "debug":
          console.debug(msg, logEntry.objects);
          break;
        case "info":
          console.info(msg, logEntry.objects);
          break;
        case "warn":
          console.warn(msg, logEntry.objects);
          break;
        case "error":
          console.error(msg, logEntry.objects);
          break;
        default:
          console.log(`{${logEntry.level}} ${msg}`, logEntry.objects);
      }
    });
    this.consoleLoggerRegistered = true;
    return this;
  }
};
var logging = new LogManager();
var Logger = class {
  constructor(logManager, module2, minLevel) {
    this.levels = {
      trace: 1,
      debug: 2,
      info: 3,
      warn: 4,
      error: 5
    };
    this.logManager = logManager;
    this.module = module2;
    this.minLevel = this.levelToInt(minLevel);
  }
  levelToInt(minLevel) {
    if (minLevel.toLowerCase() in this.levels)
      return this.levels[minLevel.toLowerCase()];
    else
      return 99;
  }
  log(logLevel, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId: void 0
    };
    this.logManager.emit("log", logEntry);
  }
  trace(message, objects) {
    this.log("trace", message, objects);
  }
  debug(message, objects) {
    this.log("debug", message, objects);
  }
  info(message, objects) {
    this.log("info", message, objects);
  }
  warn(message, objects) {
    this.log("warn", message, objects);
  }
  error(message, objects) {
    this.log("error", message, objects);
  }
  logWithId(logLevel, traceId, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId
    };
    this.logManager.emit("log", logEntry);
  }
  traceWithId(traceId, message, objects) {
    this.logWithId("trace", traceId, message, objects);
  }
  debugWithId(traceId, message, objects) {
    this.logWithId("debug", traceId, message, objects);
  }
  infoWithId(traceId, message, objects) {
    this.logWithId("info", traceId, message, objects);
  }
  warnWithId(traceId, message, objects) {
    this.logWithId("warn", traceId, message, objects);
  }
  errorWithId(traceId, message, objects) {
    this.logWithId("error", traceId, message, objects);
  }
};
function log(logLevel, message) {
  const logger = logging.getLogger("tasks");
  switch (logLevel) {
    case "trace":
      logger.trace(message);
      break;
    case "debug":
      logger.debug(message);
      break;
    case "info":
      logger.info(message);
      break;
    case "warn":
      logger.warn(message);
      break;
    case "error":
      logger.error(message);
      break;
    default:
      break;
  }
}

// src/lib/LogTasksHelper.ts
function logStartOfTaskEdit(logger, codeLocation, originalTask) {
  logger.debug(
    `${codeLocation}: task line number: ${originalTask.taskLocation.lineNumber}. file path: "${originalTask.path}"`
  );
  logger.debug(`${codeLocation} original: ${originalTask.originalMarkdown}`);
}
function logEndOfTaskEdit(logger, codeLocation, newTasks) {
  newTasks.map((task, index) => {
    logger.debug(`${codeLocation} ==> ${index + 1}   : ${task.toFileLineString()}`);
  });
}

// src/Task/DateFallback.ts
var DateFallback = class {
  static fromPath(path) {
    const { useFilenameAsScheduledDate, filenameAsDateFolders } = getSettings();
    if (!useFilenameAsScheduledDate) {
      return null;
    }
    if (!this.matchesAnyFolder(filenameAsDateFolders, path)) {
      return null;
    }
    return this.extractDateFromPath(path);
  }
  static matchesAnyFolder(folders, path) {
    if (folders.length === 0) {
      return true;
    }
    return folders.some((folder) => path.startsWith(folder + "/"));
  }
  static extractDateFromPath(path) {
    const firstPos = Math.max(0, path.lastIndexOf("/") + 1);
    const lastPos = path.lastIndexOf(".");
    const basename = path.substring(firstPos, lastPos);
    let dateMatch = /(\d{4})-(\d{2})-(\d{2})/.exec(basename);
    if (!dateMatch)
      dateMatch = /(\d{4})(\d{2})(\d{2})/.exec(basename);
    if (dateMatch) {
      const date = window.moment([parseInt(dateMatch[1]), parseInt(dateMatch[2]) - 1, parseInt(dateMatch[3])]);
      if (date.isValid()) {
        return date;
      }
    }
    return null;
  }
  static canApplyFallback({
    startDate,
    scheduledDate,
    dueDate
  }) {
    return startDate === null && dueDate === null && scheduledDate === null;
  }
  static updateTaskPath(task, newPath, fallbackDate) {
    let scheduledDate = task.scheduledDate;
    let scheduledDateIsInferred = task.scheduledDateIsInferred;
    if (fallbackDate === null) {
      if (scheduledDateIsInferred) {
        scheduledDateIsInferred = false;
        scheduledDate = null;
      } else {
      }
    } else {
      if (scheduledDateIsInferred) {
        scheduledDate = fallbackDate;
      } else if (this.canApplyFallback(task)) {
        scheduledDate = fallbackDate;
        scheduledDateIsInferred = true;
      } else {
      }
    }
    return new Task(__spreadProps(__spreadValues({}, task), {
      taskLocation: task.taskLocation.fromRenamedFile(new TasksFile(newPath)),
      scheduledDate,
      scheduledDateIsInferred
    }));
  }
  static removeInferredStatusIfNeeded(originalTask, updatedTasks) {
    const inferredScheduledDate = originalTask.scheduledDateIsInferred ? originalTask.scheduledDate : null;
    return updatedTasks.map((task) => {
      if (inferredScheduledDate !== null && !inferredScheduledDate.isSame(task.scheduledDate, "day")) {
        task = new Task(__spreadProps(__spreadValues({}, task), { scheduledDateIsInferred: false }));
      }
      return task;
    });
  }
};

// src/Task/ListItem.ts
var ListItem = class {
  constructor(parent, children2) {
    this.parent = null;
    this.parent = parent;
    this.children = children2;
  }
};

// src/Task/Urgency.ts
var _Urgency = class {
  static calculate(task) {
    var _a, _b, _c;
    let urgency = 0;
    if ((_a = task.dueDate) == null ? void 0 : _a.isValid()) {
      const startOfToday = window.moment().startOf("day");
      const daysOverdue = Math.round(startOfToday.diff(task.dueDate) / _Urgency.milliSecondsPerDay);
      let dueMultiplier;
      if (daysOverdue >= 7) {
        dueMultiplier = 1;
      } else if (daysOverdue >= -14) {
        dueMultiplier = (daysOverdue + 14) * 0.8 / 21 + 0.2;
      } else {
        dueMultiplier = 0.2;
      }
      urgency += dueMultiplier * _Urgency.dueCoefficient;
    }
    if ((_b = task.scheduledDate) == null ? void 0 : _b.isValid()) {
      if (window.moment().isSameOrAfter(task.scheduledDate)) {
        urgency += 1 * _Urgency.scheduledCoefficient;
      }
    }
    if ((_c = task.startDate) == null ? void 0 : _c.isValid()) {
      if (window.moment().isBefore(task.startDate)) {
        urgency += 1 * _Urgency.startedCoefficient;
      }
    }
    switch (task.priority) {
      case "0":
        urgency += 1.5 * _Urgency.priorityCoefficient;
        break;
      case "1":
        urgency += 1 * _Urgency.priorityCoefficient;
        break;
      case "2":
        urgency += 0.65 * _Urgency.priorityCoefficient;
        break;
      case "3":
        urgency += 0.325 * _Urgency.priorityCoefficient;
        break;
      case "5":
        urgency -= 0.3 * _Urgency.priorityCoefficient;
        break;
    }
    return urgency;
  }
};
var Urgency = _Urgency;
Urgency.dueCoefficient = 12;
Urgency.scheduledCoefficient = 5;
Urgency.startedCoefficient = -3;
Urgency.priorityCoefficient = 6;
Urgency.milliSecondsPerDay = 1e3 * 60 * 60 * 24;

// src/Task/Task.ts
var Task = class extends ListItem {
  constructor({
    status,
    description,
    taskLocation,
    indentation,
    listMarker,
    priority,
    createdDate,
    startDate,
    scheduledDate,
    dueDate,
    reminderDate,
    doneDate,
    cancelledDate,
    recurrence,
    dependsOn,
    id,
    blockLink,
    tags,
    originalMarkdown,
    scheduledDateIsInferred
  }) {
    super(null, []);
    this._urgency = null;
    this.status = status;
    this.description = description;
    this.indentation = indentation;
    this.listMarker = listMarker;
    this.taskLocation = taskLocation;
    this.tags = tags;
    this.priority = priority;
    this.createdDate = createdDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.reminderDate = reminderDate;
    this.doneDate = doneDate;
    this.cancelledDate = cancelledDate;
    this.recurrence = recurrence;
    this.dependsOn = dependsOn;
    this.id = id;
    this.blockLink = blockLink;
    this.originalMarkdown = originalMarkdown;
    this.scheduledDateIsInferred = scheduledDateIsInferred;
  }
  static fromLine({
    line,
    taskLocation,
    fallbackDate
  }) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    if (!GlobalFilter.getInstance().includedIn(taskComponents.body)) {
      return null;
    }
    return Task.parseTaskSignifiers(line, taskLocation, fallbackDate);
  }
  static parseTaskSignifiers(line, taskLocation, fallbackDate) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    const { taskSerializer } = getUserSelectedTaskFormat();
    const taskInfo = taskSerializer.deserialize(taskComponents.body);
    let scheduledDateIsInferred = false;
    if (DateFallback.canApplyFallback(taskInfo) && fallbackDate !== null) {
      taskInfo.scheduledDate = fallbackDate;
      scheduledDateIsInferred = true;
    }
    taskInfo.tags = taskInfo.tags.map((tag) => tag.trim());
    taskInfo.tags = taskInfo.tags.filter((tag) => !GlobalFilter.getInstance().equals(tag));
    return new Task(__spreadProps(__spreadValues(__spreadValues({}, taskComponents), taskInfo), {
      taskLocation,
      originalMarkdown: line,
      scheduledDateIsInferred
    }));
  }
  static extractTaskComponents(line) {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch === null) {
      return null;
    }
    const indentation = regexMatch[1];
    const listMarker = regexMatch[2];
    const statusString = regexMatch[3];
    const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
    let body = regexMatch[4].trim();
    const blockLinkMatch = body.match(TaskRegularExpressions.blockLinkRegex);
    const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
    if (blockLink !== "") {
      body = body.replace(TaskRegularExpressions.blockLinkRegex, "").trim();
    }
    return { indentation, listMarker, status, body, blockLink };
  }
  toString() {
    return getUserSelectedTaskFormat().taskSerializer.serialize(this);
  }
  toFileLineString() {
    return `${this.indentation}${this.listMarker} [${this.status.symbol}] ${this.toString()}`;
  }
  toggle() {
    const logger = logging.getLogger("tasks.Task");
    const codeLocation = "toggle()";
    logStartOfTaskEdit(logger, codeLocation, this);
    const newStatus = StatusRegistry.getInstance().getNextStatusOrCreate(this.status);
    const newTasks = this.handleNewStatus(newStatus);
    logEndOfTaskEdit(logger, codeLocation, newTasks);
    return newTasks;
  }
  handleNewStatus(newStatus, today = window.moment()) {
    if (newStatus.identicalTo(this.status)) {
      return [this];
    }
    const { setDoneDate } = getSettings();
    const newDoneDate = this.newDate(newStatus, "DONE" /* DONE */, this.doneDate, setDoneDate, today);
    const { setCancelledDate } = getSettings();
    const newCancelledDate = this.newDate(
      newStatus,
      "CANCELLED" /* CANCELLED */,
      this.cancelledDate,
      setCancelledDate,
      today
    );
    let nextOccurrence = null;
    if (newStatus.isCompleted()) {
      if (!this.status.isCompleted() && this.recurrence !== null) {
        nextOccurrence = this.recurrence.next(today);
      }
    }
    const toggledTask = new Task(__spreadProps(__spreadValues({}, this), {
      status: newStatus,
      doneDate: newDoneDate,
      cancelledDate: newCancelledDate
    }));
    const newTasks = [];
    if (nextOccurrence !== null) {
      const nextTask = this.createNextOccurrence(newStatus, nextOccurrence);
      newTasks.push(nextTask);
    }
    newTasks.push(toggledTask);
    return newTasks;
  }
  newDate(newStatus, statusType, oldDate, dateEnabledInSettings, today) {
    let newDate = null;
    if (newStatus.type === statusType) {
      if (this.status.type !== statusType) {
        if (dateEnabledInSettings) {
          newDate = today;
        }
      } else {
        newDate = oldDate;
      }
    }
    return newDate;
  }
  createNextOccurrence(newStatus, nextOccurrence) {
    const { setCreatedDate } = getSettings();
    let createdDate = null;
    if (setCreatedDate) {
      createdDate = window.moment();
    }
    const cancelledDate = null;
    const doneDate = null;
    const statusRegistry = StatusRegistry.getInstance();
    const nextStatus = statusRegistry.getNextRecurrenceStatusOrCreate(newStatus);
    return new Task(__spreadProps(__spreadValues(__spreadValues({}, this), nextOccurrence), {
      status: nextStatus,
      blockLink: "",
      id: "",
      dependsOn: [],
      createdDate,
      cancelledDate,
      doneDate
    }));
  }
  toggleWithRecurrenceInUsersOrder() {
    const newTasks = this.toggle();
    return this.putRecurrenceInUsersOrder(newTasks);
  }
  handleNewStatusWithRecurrenceInUsersOrder(newStatus, today = window.moment()) {
    const logger = logging.getLogger("tasks.Task");
    logger.debug(
      `changed task ${this.taskLocation.path} ${this.taskLocation.lineNumber} ${this.originalMarkdown} status to '${newStatus.symbol}'`
    );
    const newTasks = this.handleNewStatus(newStatus, today);
    return this.putRecurrenceInUsersOrder(newTasks);
  }
  putRecurrenceInUsersOrder(newTasks) {
    const { recurrenceOnNextLine } = getSettings();
    return recurrenceOnNextLine ? newTasks.reverse() : newTasks;
  }
  get isDone() {
    return this.status.type === "DONE" /* DONE */ || this.status.type === "CANCELLED" /* CANCELLED */ || this.status.type === "NON_TASK" /* NON_TASK */;
  }
  isBlocked(allTasks) {
    if (this.dependsOn.length === 0) {
      return false;
    }
    if (this.isDone) {
      return false;
    }
    for (const depId of this.dependsOn) {
      const depTask = allTasks.find((task) => task.id === depId && !task.isDone);
      if (!depTask) {
        continue;
      }
      return true;
    }
    return false;
  }
  isBlocking(allTasks) {
    if (this.id === "") {
      return false;
    }
    if (this.isDone) {
      return false;
    }
    return allTasks.some((task) => {
      if (task.isDone) {
        return false;
      }
      return task.dependsOn.includes(this.id);
    });
  }
  get priorityNumber() {
    return Number.parseInt(this.priority);
  }
  get priorityNameGroupText() {
    const priorityName = PriorityTools.priorityNameUsingNormal(this.priority);
    return `%%${this.priority}%%${priorityName} priority`;
  }
  get descriptionWithoutTags() {
    return this.description.replace(TaskRegularExpressions.hashTags, "").trim();
  }
  get priorityName() {
    return PriorityTools.priorityNameUsingNormal(this.priority);
  }
  get urgency() {
    if (this._urgency === null) {
      this._urgency = Urgency.calculate(this);
    }
    return this._urgency;
  }
  get path() {
    return this.taskLocation.path;
  }
  get cancelled() {
    return new TasksDate(this.cancelledDate);
  }
  get created() {
    return new TasksDate(this.createdDate);
  }
  get done() {
    return new TasksDate(this.doneDate);
  }
  get due() {
    return new TasksDate(this.dueDate);
  }
  get reminder() {
    return new TasksDate(this.reminderDate);
  }
  get scheduled() {
    return new TasksDate(this.scheduledDate);
  }
  get start() {
    return new TasksDate(this.startDate);
  }
  get happensDates() {
    return Array.of(this.startDate, this.scheduledDate, this.dueDate);
  }
  get happens() {
    const happensDates = this.happensDates;
    const sortedHappensDates = Array.from(happensDates).sort(compareByDate);
    for (const date of sortedHappensDates) {
      if (date == null ? void 0 : date.isValid()) {
        return new TasksDate(date);
      }
    }
    return new TasksDate(null);
  }
  get isRecurring() {
    return this.recurrence !== null;
  }
  get recurrenceRule() {
    return this.recurrence ? this.recurrence.toText() : "";
  }
  get heading() {
    return this.precedingHeader;
  }
  get hasHeading() {
    return this.precedingHeader !== null;
  }
  get file() {
    return this.taskLocation.tasksFile;
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)\.md$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return null;
    }
  }
  get lineNumber() {
    return this.taskLocation.lineNumber;
  }
  get sectionStart() {
    return this.taskLocation.sectionStart;
  }
  get sectionIndex() {
    return this.taskLocation.sectionIndex;
  }
  get precedingHeader() {
    return this.taskLocation.precedingHeader;
  }
  getLinkText({ isFilenameUnique }) {
    let linkText;
    if (isFilenameUnique) {
      linkText = this.filename;
    } else {
      linkText = "/" + this.path;
    }
    if (linkText === null) {
      return null;
    }
    if (this.precedingHeader !== null && this.precedingHeader !== linkText) {
      linkText = linkText + " > " + this.precedingHeader;
    }
    return linkText;
  }
  static tasksListsIdentical(oldTasks, newTasks) {
    if (oldTasks.length !== newTasks.length) {
      return false;
    }
    return oldTasks.every((oldTask, index) => oldTask.identicalTo(newTasks[index]));
  }
  identicalTo(other) {
    var _a, _b;
    let args = [
      "description",
      "path",
      "indentation",
      "listMarker",
      "lineNumber",
      "sectionStart",
      "sectionIndex",
      "precedingHeader",
      "priority",
      "blockLink",
      "scheduledDateIsInferred",
      "id",
      "dependsOn"
    ];
    for (const el of args) {
      if (((_a = this[el]) == null ? void 0 : _a.toString()) !== ((_b = other[el]) == null ? void 0 : _b.toString()))
        return false;
    }
    if (!this.status.identicalTo(other.status)) {
      return false;
    }
    if (this.tags.length !== other.tags.length) {
      return false;
    }
    if (!this.tags.every(function(element2, index) {
      return element2 === other.tags[index];
    })) {
      return false;
    }
    args = Task.allDateFields();
    for (const el of args) {
      const date1 = this[el];
      const date2 = other[el];
      if (compareByDate(date1, date2) !== 0) {
        return false;
      }
    }
    const recurrence1 = this.recurrence;
    const recurrence2 = other.recurrence;
    if (recurrence1 === null && recurrence2 !== null) {
      return false;
    } else if (recurrence1 !== null && recurrence2 === null) {
      return false;
    } else if (recurrence1 && recurrence2 && !recurrence1.identicalTo(recurrence2)) {
      return false;
    }
    return true;
  }
  static allDateFields() {
    return [
      "createdDate",
      "startDate",
      "scheduledDate",
      "dueDate",
      "reminderDate",
      "doneDate",
      "cancelledDate"
    ];
  }
  static extractHashtags(description) {
    var _a, _b;
    return (_b = (_a = description.match(TaskRegularExpressions.hashTags)) == null ? void 0 : _a.map((tag) => tag.trim())) != null ? _b : [];
  }
};

// src/lib/Lazy.ts
var Lazy = class {
  constructor(fetch) {
    this.fetch = fetch;
    this._value = void 0;
  }
  get value() {
    if (this._value === void 0) {
      this._value = this.fetch();
    }
    return this._value;
  }
};

// src/Task/TaskLocation.ts
var TaskLocation = class {
  constructor(tasksFile, lineNumber, sectionStart, sectionIndex, precedingHeader) {
    this._tasksFile = tasksFile;
    this._lineNumber = lineNumber;
    this._sectionStart = sectionStart;
    this._sectionIndex = sectionIndex;
    this._precedingHeader = precedingHeader;
  }
  static fromUnknownPosition(tasksFile) {
    return new TaskLocation(tasksFile, 0, 0, 0, null);
  }
  fromRenamedFile(newTasksFile) {
    return new TaskLocation(
      newTasksFile,
      this.lineNumber,
      this.sectionStart,
      this.sectionIndex,
      this.precedingHeader
    );
  }
  get tasksFile() {
    return this._tasksFile;
  }
  get path() {
    return this._tasksFile.path;
  }
  get lineNumber() {
    return this._lineNumber;
  }
  get sectionStart() {
    return this._sectionStart;
  }
  get sectionIndex() {
    return this._sectionIndex;
  }
  get precedingHeader() {
    return this._precedingHeader;
  }
  get hasKnownPath() {
    return this.path !== "";
  }
};

// src/Obsidian/Cache.ts
function getTasksFromFileContent2(filePath, fileContent, listItems, logger, fileCache, errorReporter) {
  const tasksFile = new TasksFile(filePath);
  const tasks = [];
  const fileLines = fileContent.split("\n");
  const linesInFile = fileLines.length;
  const dateFromFileName = new Lazy(() => DateFallback.fromPath(filePath));
  let currentSection = null;
  let sectionIndex = 0;
  for (const listItem of listItems) {
    if (listItem.task !== void 0) {
      const lineNumber = listItem.position.start.line;
      if (lineNumber >= linesInFile) {
        logger.debug(
          `${filePath} Obsidian gave us a line number ${lineNumber} past the end of the file. ${linesInFile}.`
        );
        return tasks;
      }
      if (currentSection === null || currentSection.position.end.line < lineNumber) {
        currentSection = Cache2.getSection(lineNumber, fileCache.sections);
        sectionIndex = 0;
      }
      if (currentSection === null) {
        continue;
      }
      const line = fileLines[lineNumber];
      if (line === void 0) {
        logger.debug(`${filePath}: line ${lineNumber} - ignoring 'undefined' line.`);
        continue;
      }
      let task;
      try {
        task = Task.fromLine({
          line,
          taskLocation: new TaskLocation(
            tasksFile,
            lineNumber,
            currentSection.position.start.line,
            sectionIndex,
            Cache2.getPrecedingHeader(lineNumber, fileCache.headings)
          ),
          fallbackDate: dateFromFileName.value
        });
      } catch (e) {
        errorReporter(e, filePath, listItem, line);
        continue;
      }
      if (task !== null) {
        sectionIndex++;
        tasks.push(task);
      }
    }
  }
  return tasks;
}
var Cache2 = class {
  constructor({ metadataCache: metadataCache2, vault: vault2, events }) {
    this.logger = logging.getLogger("tasks.Cache");
    this.logger.debug("Creating Cache object");
    this.metadataCache = metadataCache2;
    this.metadataCacheEventReferences = [];
    this.vault = vault2;
    this.vaultEventReferences = [];
    this.events = events;
    this.eventsEventReferences = [];
    this.tasksMutex = new Mutex();
    this.state = "Cold" /* Cold */;
    this.logger.debug("Cache.constructor(): state = Cold");
    this.tasks = [];
    this.loadedAfterFirstResolve = false;
    this.subscribeToCache();
    this.subscribeToVault();
    this.subscribeToEvents();
    this.loadVault();
  }
  unload() {
    this.logger.info("Unloading Cache");
    for (const eventReference of this.metadataCacheEventReferences) {
      this.metadataCache.offref(eventReference);
    }
    for (const eventReference of this.vaultEventReferences) {
      this.vault.offref(eventReference);
    }
    for (const eventReference of this.eventsEventReferences) {
      this.events.off(eventReference);
    }
  }
  getTasks() {
    return this.tasks;
  }
  getState() {
    return this.state;
  }
  notifySubscribers() {
    this.logger.debug("Cache.notifySubscribers()");
    this.events.triggerCacheUpdate({
      tasks: this.tasks,
      state: this.state
    });
  }
  subscribeToCache() {
    this.logger.debug("Cache.subscribeToCache()");
    const resolvedEventeReference = this.metadataCache.on("resolved", () => __async(this, null, function* () {
      if (!this.loadedAfterFirstResolve) {
        this.loadedAfterFirstResolve = true;
        this.loadVault();
      }
    }));
    this.metadataCacheEventReferences.push(resolvedEventeReference);
    const changedEventReference = this.metadataCache.on("changed", (file) => {
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.metadataCacheEventReferences.push(changedEventReference);
  }
  subscribeToVault() {
    this.logger.debug("Cache.subscribeToVault()");
    const { useFilenameAsScheduledDate } = getSettings();
    const createdEventReference = this.vault.on("create", (file) => {
      if (!(file instanceof import_obsidian4.TFile)) {
        return;
      }
      this.logger.debug(`Cache.subscribeToVault.createdEventReference() ${file.path}`);
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.vaultEventReferences.push(createdEventReference);
    const deletedEventReference = this.vault.on("delete", (file) => {
      if (!(file instanceof import_obsidian4.TFile)) {
        return;
      }
      this.logger.debug(`Cache.subscribeToVault.deletedEventReference() ${file.path}`);
      this.tasksMutex.runExclusive(() => {
        this.tasks = this.tasks.filter((task) => {
          return task.path !== file.path;
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(deletedEventReference);
    const renamedEventReference = this.vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian4.TFile)) {
        return;
      }
      this.logger.debug(`Cache.subscribeToVault.renamedEventReference() ${file.path}`);
      this.tasksMutex.runExclusive(() => {
        const tasksFile = new TasksFile(file.path);
        const fallbackDate = new Lazy(() => DateFallback.fromPath(file.path));
        this.tasks = this.tasks.map((task) => {
          if (task.path === oldPath) {
            if (!useFilenameAsScheduledDate) {
              return new Task(__spreadProps(__spreadValues({}, task), {
                taskLocation: task.taskLocation.fromRenamedFile(tasksFile)
              }));
            } else {
              return DateFallback.updateTaskPath(task, file.path, fallbackDate.value);
            }
          } else {
            return task;
          }
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(renamedEventReference);
  }
  subscribeToEvents() {
    this.logger.debug("Cache.subscribeToEvents()");
    const requestReference = this.events.onRequestCacheUpdate((handler) => {
      handler({ tasks: this.tasks, state: this.state });
    });
    this.eventsEventReferences.push(requestReference);
  }
  loadVault() {
    this.logger.debug("Cache.loadVault()");
    return this.tasksMutex.runExclusive(() => __async(this, null, function* () {
      this.state = "Initializing" /* Initializing */;
      this.logger.debug("Cache.loadVault(): state = Initializing");
      yield Promise.all(
        this.vault.getMarkdownFiles().map((file) => {
          return this.indexFile(file);
        })
      );
      this.state = "Warm" /* Warm */;
      this.logger.debug("Cache.loadVault(): state = Warm");
      this.notifySubscribers();
    }));
  }
  indexFile(file) {
    return __async(this, null, function* () {
      const fileCache = this.metadataCache.getFileCache(file);
      if (fileCache === null || fileCache === void 0) {
        return;
      }
      if (!file.path.endsWith(".md")) {
        this.logger.debug("indexFile: skipping non-markdown file: " + file.path);
        return;
      }
      this.logger.debug("Cache.indexFile: " + file.path);
      const oldTasks = this.tasks.filter((task) => {
        return task.path === file.path;
      });
      const listItems = fileCache.listItems;
      let newTasks = [];
      if (listItems !== void 0) {
        const fileContent = yield this.vault.cachedRead(file);
        newTasks = this.getTasksFromFileContent(
          fileContent,
          listItems,
          fileCache,
          file.path,
          this.reportTaskParsingErrorToUser,
          this.logger
        );
      }
      if (Task.tasksListsIdentical(oldTasks, newTasks)) {
        return;
      }
      this.tasks = this.tasks.filter((task) => {
        return task.path !== file.path;
      });
      this.tasks.push(...newTasks);
      this.logger.debug("Cache.indexFile: " + file.path + `: read ${newTasks.length} task(s)`);
      this.notifySubscribers();
    });
  }
  getTasksFromFileContent(fileContent, listItems, fileCache, filePath, errorReporter, logger) {
    return getTasksFromFileContent2(filePath, fileContent, listItems, logger, fileCache, errorReporter);
  }
  reportTaskParsingErrorToUser(e, filePath, listItem, line) {
    const msg = `There was an error reading one of the tasks in this vault.
The following task has been ignored, to prevent Tasks queries getting stuck with 'Loading Tasks ...'
Error: ${e}
File: ${filePath}
Line number: ${listItem.position.start.line}
Task line: ${line}

Please create a bug report for this message at
https://github.com/obsidian-tasks-group/obsidian-tasks/issues/new/choose
to help us find and fix the underlying issue.

Include:
- either a screenshot of the error popup, or copy the text from the console, if on a desktop machine.
- the output from running the Obsidian command 'Show debug info'

The error popup will only be shown when Tasks is starting up, but if the error persists,
it will be shown in the console every time this file is edited during the Obsidian
session.
`;
    this.logger.error(msg);
    if (e instanceof Error) {
      this.logger.error(e.stack ? e.stack : "Cannot determine stack");
    }
    if (this.state === "Initializing" /* Initializing */) {
      new import_obsidian4.Notice(msg, 1e4);
    }
  }
  static getSection(lineNumberTask, sections) {
    if (sections === void 0) {
      return null;
    }
    for (const section of sections) {
      if (section.position.start.line <= lineNumberTask && section.position.end.line >= lineNumberTask) {
        return section;
      }
    }
    return null;
  }
  static getPrecedingHeader(lineNumberTask, headings) {
    if (headings === void 0) {
      return null;
    }
    let precedingHeader = null;
    for (const heading of headings) {
      if (heading.position.start.line > lineNumberTask) {
        return precedingHeader;
      }
      precedingHeader = heading.heading;
    }
    return precedingHeader;
  }
};

// src/Commands/CreateOrEdit.ts
var import_obsidian7 = require("obsidian");

// src/Obsidian/TaskModal.ts
var import_obsidian6 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty2() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function init_binding_group(group) {
  let _inputs;
  return {
    p(...inputs) {
      _inputs = inputs;
      _inputs.forEach((input) => group.push(input));
    },
    r() {
      _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
    }
  };
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
var crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = false;
    try {
      if (typeof window !== "undefined" && window.parent) {
        void window.parent.document;
      }
    } catch (error) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_iframe_resize_listener(node, fn) {
  const computed_style = getComputedStyle(node);
  if (computed_style.position === "static") {
    node.style.position = "relative";
  }
  const iframe = element("iframe");
  iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
  iframe.setAttribute("aria-hidden", "true");
  iframe.tabIndex = -1;
  const crossorigin2 = is_crossorigin();
  let unsubscribe;
  if (crossorigin2) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
    unsubscribe = listen(window, "message", (event) => {
      if (event.source === iframe.contentWindow)
        fn();
    });
  } else {
    iframe.src = "about:blank";
    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, "resize", fn);
      fn();
    };
  }
  append(node, iframe);
  return () => {
    if (crossorigin2) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeType === 11 ? "TEMPLATE" : target.nodeName);
      this.t = target.tagName !== "TEMPLATE" ? target : target.content;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/Obsidian/File.ts
var import_obsidian5 = require("obsidian");

// src/lib/MockDataCreator.ts
function getMockDataForTesting(originalTask, fileLines, listItemsCache) {
  const allDataFromListItemCache = [];
  for (const listItemCache of listItemsCache) {
    const pos = listItemCache.position;
    const task = listItemCache.task;
    const dataFromListItemCache = {
      position: pos,
      task
    };
    allDataFromListItemCache.push(dataFromListItemCache);
  }
  const mockTaskLocation = {
    path: originalTask.taskLocation.path,
    lineNumber: originalTask.taskLocation.lineNumber,
    sectionStart: originalTask.taskLocation.sectionStart,
    sectionIndex: originalTask.taskLocation.sectionIndex,
    precedingHeader: originalTask.taskLocation.precedingHeader
  };
  return {
    taskData: {
      originalMarkdown: originalTask.originalMarkdown,
      taskLocation: mockTaskLocation
    },
    fileData: {
      fileLines
    },
    cacheData: {
      listItemsCache: allDataFromListItemCache
    }
  };
}
function saveMockDataForTesting(originalTask, fileLines, listItemsCache) {
  const everything = getMockDataForTesting(originalTask, fileLines, listItemsCache);
  console.error(`Inconsistent lines: SAVE THE OUTPUT
data:
${JSON.stringify(everything)}
`);
}

// src/Obsidian/File.ts
var metadataCache;
var vault;
var workspace;
var supportedFileExtensions = ["md"];
function getFileLogger() {
  return logging.getLogger("tasks.File");
}
var initializeFile = ({
  metadataCache: newMetadataCache,
  vault: newVault,
  workspace: newWorkspace
}) => {
  metadataCache = newMetadataCache;
  vault = newVault;
  workspace = newWorkspace;
};
var replaceTaskWithTasks = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks
}) {
  if (vault === void 0 || metadataCache === void 0 || workspace === void 0) {
    errorAndNotice("Tasks: cannot use File before initializing it.");
    return;
  }
  if (!Array.isArray(newTasks)) {
    newTasks = [newTasks];
  }
  const logger = getFileLogger();
  const codeLocation = "replaceTaskWithTasks()";
  logStartOfTaskEdit(logger, codeLocation, originalTask);
  logEndOfTaskEdit(logger, codeLocation, newTasks);
  yield tryRepetitive({
    originalTask,
    newTasks,
    vault,
    metadataCache,
    workspace,
    previousTries: 0
  });
});
function errorAndNotice(message) {
  console.error(message);
  new import_obsidian5.Notice(message, 15e3);
}
function warnAndNotice(message) {
  console.warn(message);
  new import_obsidian5.Notice(message, 1e4);
}
function debugLog(message) {
  const logger = getFileLogger();
  logger.debug(message);
}
var WarningWorthRetrying = class extends Error {
};
var RetryWithoutWarning = class extends Error {
};
var tryRepetitive = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks,
  vault: vault2,
  metadataCache: metadataCache2,
  workspace: workspace2,
  previousTries
}) {
  const logger = getFileLogger();
  logger.debug(`tryRepetitive after ${previousTries} previous tries`);
  const retry = () => __async(void 0, null, function* () {
    if (previousTries > 10) {
      const message = `Tasks: Could not find the correct task line to update.

The task line not updated is:
${originalTask.originalMarkdown}

In this markdown file:
"${originalTask.taskLocation.path}"

Note: further clicks on this checkbox will usually now be ignored until the file is opened (or certain, specific edits are made - it's complicated).

Recommendations:

1. Close all panes that have the above file open, and then re-open the file.

2. Check for exactly identical copies of the task line, in this file, and see if you can make them different.
`;
      errorAndNotice(message);
      return;
    }
    const timeout = Math.min(Math.pow(10, previousTries), 100);
    logger.debug(`timeout = ${timeout}`);
    setTimeout(() => __async(void 0, null, function* () {
      yield tryRepetitive({
        originalTask,
        newTasks,
        vault: vault2,
        metadataCache: metadataCache2,
        workspace: workspace2,
        previousTries: previousTries + 1
      });
    }), timeout);
  });
  try {
    const [taskLineNumber, file, fileLines] = yield getTaskAndFileLines(originalTask, vault2);
    const updatedFileLines = [
      ...fileLines.slice(0, taskLineNumber),
      ...newTasks.map((task) => task.toFileLineString()),
      ...fileLines.slice(taskLineNumber + 1)
    ];
    yield vault2.modify(file, updatedFileLines.join("\n"));
  } catch (e) {
    if (e instanceof WarningWorthRetrying) {
      if (e.message)
        warnAndNotice(e.message);
      yield retry();
      return;
    } else if (e instanceof RetryWithoutWarning) {
      yield retry();
      return;
    } else if (e instanceof Error) {
      errorAndNotice(e.message);
    }
  }
});
function getTaskAndFileLines(task, vault2) {
  return __async(this, null, function* () {
    if (metadataCache === void 0)
      throw new WarningWorthRetrying();
    const file = vault2.getAbstractFileByPath(task.path);
    if (!(file instanceof import_obsidian5.TFile)) {
      throw new WarningWorthRetrying(`Tasks: No file found for task ${task.description}. Retrying ...`);
    }
    if (!supportedFileExtensions.includes(file.extension)) {
      throw new Error(`Tasks: Does not support files with the ${file.extension} file extension.`);
    }
    const fileCache = metadataCache.getFileCache(file);
    if (fileCache == void 0 || fileCache === null) {
      throw new WarningWorthRetrying(`Tasks: No file cache found for file ${file.path}. Retrying ...`);
    }
    const listItemsCache = fileCache.listItems;
    if (listItemsCache === void 0 || listItemsCache.length === 0) {
      throw new WarningWorthRetrying(`Tasks: No list items found in file cache of ${file.path}. Retrying ...`);
    }
    const fileContent = yield vault2.read(file);
    const fileLines = fileContent.split("\n");
    const taskLineNumber = findLineNumberOfTaskToToggle(task, fileLines, listItemsCache, debugLog);
    if (taskLineNumber === void 0) {
      const logDataForMocking = false;
      if (logDataForMocking) {
        saveMockDataForTesting(task, fileLines, listItemsCache);
      }
      throw new RetryWithoutWarning();
    }
    return [taskLineNumber, file, fileLines];
  });
}
function getTaskLineAndFile(task, vault2) {
  return __async(this, null, function* () {
    try {
      const [taskLineNumber, file, _] = yield getTaskAndFileLines(task, vault2);
      return [taskLineNumber, file];
    } catch (e) {
      if (e instanceof WarningWorthRetrying) {
        if (e.message)
          warnAndNotice(e.message);
      } else if (e instanceof Error) {
        errorAndNotice(e.message);
      }
    }
    return void 0;
  });
}
function isValidLineNumber(listItemLineNumber, fileLines) {
  return listItemLineNumber < fileLines.length;
}
function findLineNumberOfTaskToToggle(originalTask, fileLines, listItemsCache, errorLoggingFunction) {
  let result = tryFindingExactMatchAtOriginalLineNumber(originalTask, fileLines);
  if (result !== void 0) {
    return result;
  }
  result = tryFindingIdenticalUniqueMarkdownLineInFile(originalTask, fileLines);
  if (result !== void 0) {
    return result;
  }
  return tryFindingLineNumberFromTaskSectionInfo(originalTask, fileLines, listItemsCache, errorLoggingFunction);
}
function tryFindingExactMatchAtOriginalLineNumber(originalTask, fileLines) {
  const originalTaskLineNumber = originalTask.taskLocation.lineNumber;
  if (isValidLineNumber(originalTaskLineNumber, fileLines)) {
    if (fileLines[originalTaskLineNumber] === originalTask.originalMarkdown) {
      const logger = getFileLogger();
      logger.debug(`Found original markdown at original line number ${originalTaskLineNumber}`);
      return originalTaskLineNumber;
    }
  }
  return void 0;
}
function tryFindingIdenticalUniqueMarkdownLineInFile(originalTask, fileLines) {
  const matchingLineNumbers = [];
  for (let i = 0; i < fileLines.length; i++) {
    if (fileLines[i] === originalTask.originalMarkdown) {
      matchingLineNumbers.push(i);
    }
  }
  if (matchingLineNumbers.length === 1) {
    return matchingLineNumbers[0];
  }
  return void 0;
}
function tryFindingLineNumberFromTaskSectionInfo(originalTask, fileLines, listItemsCache, errorLoggingFunction) {
  let taskLineNumber;
  let sectionIndex = 0;
  for (const listItemCache of listItemsCache) {
    const listItemLineNumber = listItemCache.position.start.line;
    if (!isValidLineNumber(listItemLineNumber, fileLines)) {
      return void 0;
    }
    if (listItemLineNumber < originalTask.taskLocation.sectionStart) {
      continue;
    }
    if (listItemCache.task === void 0) {
      continue;
    }
    const line = fileLines[listItemLineNumber];
    if (GlobalFilter.getInstance().includedIn(line)) {
      if (sectionIndex === originalTask.taskLocation.sectionIndex) {
        if (line === originalTask.originalMarkdown) {
          taskLineNumber = listItemLineNumber;
        } else {
          errorLoggingFunction(
            `Tasks: Unable to find task in file ${originalTask.taskLocation.path}.
Expected task:
${originalTask.originalMarkdown}
Found task:
${line}`
          );
          return;
        }
        break;
      }
      sectionIndex++;
    }
  }
  return taskLineNumber;
}

// src/lib/StringHelpers.ts
function capitalizeFirstLetter(text2) {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
}

// src/ui/EditTaskHelpers.ts
function labelContentWithAccessKey(labelText, accessKey) {
  if (accessKey === null) {
    return capitalizeFirstLetter(labelText);
  }
  const accessKeyIndex = labelText.toLowerCase().indexOf(accessKey.toLowerCase());
  if (accessKeyIndex === -1) {
    return `${capitalizeFirstLetter(labelText)} (<span class="accesskey">${accessKey.toLowerCase()}</span>)`;
  }
  let labelContent = labelText.substring(0, accessKeyIndex);
  labelContent += '<span class="accesskey">';
  if (accessKeyIndex === 0) {
    labelContent += labelText.substring(accessKeyIndex, accessKeyIndex + 1).toUpperCase();
  } else {
    labelContent += labelText.substring(accessKeyIndex, accessKeyIndex + 1);
  }
  labelContent += "</span>";
  labelContent += labelText.substring(accessKeyIndex + 1);
  labelContent = capitalizeFirstLetter(labelContent);
  return labelContent;
}
function parseAndValidateRecurrence(editableTask) {
  var _a;
  if (!editableTask.recurrenceRule) {
    return { parsedRecurrence: "<i>not recurring</>", isRecurrenceValid: true };
  }
  const recurrenceFromText = (_a = Recurrence.fromText({
    recurrenceRuleText: editableTask.recurrenceRule,
    startDate: null,
    scheduledDate: null,
    dueDate: null,
    reminderDate: null
  })) == null ? void 0 : _a.toText();
  if (!recurrenceFromText) {
    return { parsedRecurrence: "<i>invalid recurrence rule</i>", isRecurrenceValid: false };
  }
  if (editableTask.startDate || editableTask.scheduledDate || editableTask.dueDate || editableTask.reminderDate) {
    return { parsedRecurrence: recurrenceFromText, isRecurrenceValid: true };
  }
  return { parsedRecurrence: "<i>due, scheduled, reminder or start date required</i>", isRecurrenceValid: false };
}

// src/ui/DateEditor.svelte
function create_fragment(ctx) {
  let label;
  let raw0_value = labelContentWithAccessKey(ctx[2], ctx[4]) + "";
  let t0;
  let input;
  let t1;
  let code;
  let t2;
  let t3;
  let html_tag;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      t0 = space();
      input = element("input");
      t1 = space();
      code = element("code");
      t2 = text(ctx[3]);
      t3 = space();
      html_tag = new HtmlTag(false);
      attr(label, "for", ctx[2]);
      attr(input, "id", ctx[2]);
      attr(input, "type", "text");
      attr(input, "class", "tasks-modal-date-input");
      attr(input, "placeholder", datePlaceholder);
      attr(input, "accesskey", ctx[4]);
      toggle_class(input, "tasks-modal-error", !ctx[1]);
      html_tag.a = null;
      attr(code, "class", "tasks-modal-parsed-date");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      label.innerHTML = raw0_value;
      insert(target, t0, anchor);
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t1, anchor);
      insert(target, code, anchor);
      append(code, t2);
      append(code, t3);
      html_tag.m(ctx[5], code);
      if (!mounted) {
        dispose = listen(input, "input", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 20 && raw0_value !== (raw0_value = labelContentWithAccessKey(ctx2[2], ctx2[4]) + ""))
        label.innerHTML = raw0_value;
      ;
      if (dirty & 4) {
        attr(label, "for", ctx2[2]);
      }
      if (dirty & 4) {
        attr(input, "id", ctx2[2]);
      }
      if (dirty & 16) {
        attr(input, "accesskey", ctx2[4]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(input, "tasks-modal-error", !ctx2[1]);
      }
      if (dirty & 8)
        set_data(t2, ctx2[3]);
      if (dirty & 32)
        html_tag.p(ctx2[5]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(label);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(input);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(code);
      mounted = false;
      dispose();
    }
  };
}
var datePlaceholder = "Try 'Mon' or 'tm' then space";
function instance($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { dateSymbol } = $$props;
  let { date } = $$props;
  let { isDateValid } = $$props;
  let { forwardOnly } = $$props;
  let { accesskey } = $$props;
  let parsedDate;
  function input_input_handler() {
    date = this.value;
    $$invalidate(0, date), $$invalidate(2, id), $$invalidate(6, forwardOnly), $$invalidate(5, parsedDate);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
    if ("dateSymbol" in $$props2)
      $$invalidate(3, dateSymbol = $$props2.dateSymbol);
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("isDateValid" in $$props2)
      $$invalidate(1, isDateValid = $$props2.isDateValid);
    if ("forwardOnly" in $$props2)
      $$invalidate(6, forwardOnly = $$props2.forwardOnly);
    if ("accesskey" in $$props2)
      $$invalidate(4, accesskey = $$props2.accesskey);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 101) {
      $: {
        $$invalidate(0, date = doAutocomplete(date));
        $$invalidate(5, parsedDate = parseTypedDateForDisplayUsingFutureDate(id, date, forwardOnly));
        $$invalidate(1, isDateValid = !parsedDate.includes("invalid"));
      }
    }
  };
  return [
    date,
    isDateValid,
    id,
    dateSymbol,
    accesskey,
    parsedDate,
    forwardOnly,
    input_input_handler
  ];
}
var DateEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      id: 2,
      dateSymbol: 3,
      date: 0,
      isDateValid: 1,
      forwardOnly: 6,
      accesskey: 4
    });
  }
};
var DateEditor_default = DateEditor;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = (reference, floating, config) => __async(void 0, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = yield fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element2 = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element2)) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x,
      y
    }) : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$map$so;
                const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue2 = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue2 === "number" ? {
      mainAxis: rawValue2,
      crossAxis: 0,
      alignmentAxis: null
    } : __spreadValues({
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null
    }, rawValue2);
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x,
          y,
          placement
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x,
          y
        };
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y
          }
        });
      });
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          apply = () => {
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "apply"
        ]);
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === ((yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const overflowAvailableHeight = height - overflow[heightSide];
        const overflowAvailableWidth = width - overflow[widthSide];
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if (isYAxis) {
          const maximumClippingWidth = width - overflow.left - overflow.right;
          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
        } else {
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        yield apply(__spreadProps(__spreadValues({}, state), {
          availableWidth,
          availableHeight
        }));
        const nextDimensions = yield platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      });
    }
  };
};

// node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = __spreadProps(__spreadValues({}, clippingAncestor), {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  return getCssDimensions(element2);
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const window2 = getWindow(element2);
  if (!isHTMLElement(element2)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
var getElementRects = function(_ref) {
  return __async(this, null, function* () {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, yield getOffsetParentFn(floating), strategy),
      floating: __spreadValues({
        x: 0,
        y: 0
      }, yield getDimensionsFn(floating))
    };
  });
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// src/ui/Dependency.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i];
  child_ctx[43] = i;
  const constants_0 = child_ctx[17](child_ctx[40].taskLocation.path);
  child_ctx[41] = constants_0;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let ul;
  let mounted;
  let dispose;
  let each_value_1 = ctx[10];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ul, "class", "task-dependency-dropdown");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      ctx[31](ul);
      if (!mounted) {
        dispose = listen(ul, "mouseleave", ctx[32]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 928832) {
        each_value_1 = ctx2[10];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
      ctx[31](null);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  let t_value = ctx[41] + "";
  let t;
  let mounted;
  let dispose;
  function mouseenter_handler_1(...args) {
    return ctx[28](ctx[41], ...args);
  }
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "dependency-path");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "mouseenter", mouseenter_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1024 && t_value !== (t_value = ctx[41] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1(ctx) {
  let li;
  let div;
  let t0;
  let t1_value = ctx[40].status.symbol + "";
  let t1;
  let t2;
  let t3_value = descriptionAdjustedForDependencySearch(ctx[40]) + "";
  let t3;
  let div_class_value;
  let t4;
  let t5;
  let mounted;
  let dispose;
  function mouseenter_handler(...args) {
    return ctx[27](ctx[40], ...args);
  }
  let if_block = ctx[41] && create_if_block_2(ctx);
  function mousedown_handler() {
    return ctx[29](ctx[40]);
  }
  function mouseenter_handler_2() {
    return ctx[30](ctx[43]);
  }
  return {
    c() {
      li = element("li");
      div = element("div");
      t0 = text("[");
      t1 = text(t1_value);
      t2 = text("] ");
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      attr(div, "class", div_class_value = ctx[41] ? "dependency-name-shared" : "dependency-name");
      toggle_class(li, "selected", ctx[6] !== null && ctx[43] === ctx[11]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      append(li, t4);
      if (if_block)
        if_block.m(li, null);
      append(li, t5);
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", mouseenter_handler),
          listen(li, "mousedown", mousedown_handler),
          listen(li, "mouseenter", mouseenter_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1024 && t1_value !== (t1_value = ctx[40].status.symbol + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 1024 && t3_value !== (t3_value = descriptionAdjustedForDependencySearch(ctx[40]) + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 1024 && div_class_value !== (div_class_value = ctx[41] ? "dependency-name-shared" : "dependency-name")) {
        attr(div, "class", div_class_value);
      }
      if (ctx[41]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          if_block.m(li, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 2112) {
        toggle_class(li, "selected", ctx[6] !== null && ctx[43] === ctx[11]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let each_value = ctx[0][ctx[1]];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "task-dependencies-container results-dependency");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 802819) {
        each_value = ctx2[0][ctx2[1]];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0;
  let t1_value = ctx[5].status.symbol + "";
  let t1;
  let t2;
  let t3_value = descriptionAdjustedForDependencySearch(ctx[5]) + "";
  let t3;
  let t4;
  let button;
  let t5;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[33](ctx[5]);
  }
  function mouseenter_handler_3(...args) {
    return ctx[34](ctx[5], ...args);
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text("[");
      t1 = text(t1_value);
      t2 = text("] ");
      t3 = text(t3_value);
      t4 = space();
      button = element("button");
      button.innerHTML = `<svg style="display: block; margin: auto;" xmlns="http://www.w3.org/2000/svg" width="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>`;
      t5 = space();
      attr(span, "class", "task-dependency-name");
      attr(button, "type", "button");
      attr(button, "class", "task-dependency-delete");
      attr(div, "class", "task-dependency");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(div, t4);
      append(div, button);
      append(div, t5);
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          listen(div, "mouseenter", mouseenter_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 3 && t1_value !== (t1_value = ctx[5].status.symbol + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 3 && t3_value !== (t3_value = descriptionAdjustedForDependencySearch(ctx[5]) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let label;
  let raw_value = labelContentWithAccessKey(ctx[2], ctx[3]) + "";
  let t0;
  let span;
  let input_1;
  let span_resize_listener;
  let t1;
  let t2;
  let if_block1_anchor;
  let mounted;
  let dispose;
  let if_block0 = ctx[10] && ctx[10].length !== 0 && create_if_block_1(ctx);
  let if_block1 = ctx[0][ctx[1]].length !== 0 && create_if_block(ctx);
  return {
    c() {
      label = element("label");
      t0 = space();
      span = element("span");
      input_1 = element("input");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty2();
      attr(label, "for", ctx[1]);
      attr(input_1, "accesskey", ctx[3]);
      attr(input_1, "id", ctx[1]);
      attr(input_1, "class", "tasks-modal-dependency-input");
      attr(input_1, "type", "text");
      attr(input_1, "placeholder", ctx[4]);
      add_render_callback(() => ctx[26].call(span));
    },
    m(target, anchor) {
      insert(target, label, anchor);
      label.innerHTML = raw_value;
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, input_1);
      ctx[22](input_1);
      set_input_value(input_1, ctx[6]);
      span_resize_listener = add_iframe_resize_listener(span, ctx[26].bind(span));
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[23]),
          listen(input_1, "keydown", ctx[24]),
          listen(input_1, "focus", ctx[16]),
          listen(input_1, "blur", ctx[25])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 12 && raw_value !== (raw_value = labelContentWithAccessKey(ctx2[2], ctx2[3]) + ""))
        label.innerHTML = raw_value;
      ;
      if (dirty[0] & 2) {
        attr(label, "for", ctx2[1]);
      }
      if (dirty[0] & 8) {
        attr(input_1, "accesskey", ctx2[3]);
      }
      if (dirty[0] & 2) {
        attr(input_1, "id", ctx2[1]);
      }
      if (dirty[0] & 16) {
        attr(input_1, "placeholder", ctx2[4]);
      }
      if (dirty[0] & 64 && input_1.value !== ctx2[6]) {
        set_input_value(input_1, ctx2[6]);
      }
      if (ctx2[10] && ctx2[10].length !== 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0][ctx2[1]].length !== 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(label);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
      ctx[22](null);
      span_resize_listener();
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { task } = $$props;
  let { editableTask } = $$props;
  let { allTasks } = $$props;
  let { _onDescriptionKeyDown } = $$props;
  let { type } = $$props;
  let { labelText } = $$props;
  let { accesskey } = $$props;
  let { placeholder = "Type to search..." } = $$props;
  let search = "";
  let searchResults = null;
  let searchIndex = 0;
  let inputWidth;
  let inputFocused = false;
  let showDropdown = false;
  let input;
  let dropdown;
  function addTask(task2) {
    $$invalidate(0, editableTask[type] = [...editableTask[type], task2], editableTask);
    $$invalidate(6, search = "");
    $$invalidate(7, inputFocused = false);
  }
  function removeTask(task2) {
    $$invalidate(0, editableTask[type] = editableTask[type].filter((item) => item !== task2), editableTask);
  }
  function taskKeydown(e) {
    var _a;
    if (searchResults === null)
      return;
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        if (!!searchIndex && searchIndex > 0) {
          $$invalidate(11, searchIndex -= 1);
        } else {
          $$invalidate(11, searchIndex = searchResults.length - 1);
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (!!searchIndex && searchIndex < searchResults.length - 1) {
          $$invalidate(11, searchIndex += 1);
        } else {
          $$invalidate(11, searchIndex = 0);
        }
        break;
      case "Enter":
        if (searchIndex !== null) {
          e.preventDefault();
          addTask(searchResults[searchIndex]);
          $$invalidate(11, searchIndex = null);
          $$invalidate(7, inputFocused = false);
        } else {
          _onDescriptionKeyDown(e);
        }
        break;
      default:
        $$invalidate(11, searchIndex = 0);
        break;
    }
    searchIndex && ((_a = dropdown === null || dropdown === void 0 ? void 0 : dropdown.getElementsByTagName("li")[searchIndex]) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: "nearest" }));
  }
  function generateSearchResults(search2) {
    if (!search2 && !showDropdown)
      return [];
    showDropdown = false;
    return searchForCandidateTasksForDependency(search2, allTasks, task, editableTask.blockedBy, editableTask.blocking);
  }
  function onFocused() {
    $$invalidate(7, inputFocused = true);
    showDropdown = true;
  }
  function positionDropdown(input2, dropdown2) {
    if (!input2 || !dropdown2)
      return;
    computePosition2(input2, dropdown2, {
      middleware: [
        offset(6),
        shift(),
        flip(),
        size({
          apply() {
            dropdown2 && Object.assign(dropdown2.style, { width: `${inputWidth}px` });
          }
        })
      ]
    }).then(({ x, y }) => {
      dropdown2.style.left = `${x}px`;
      dropdown2.style.top = `${y}px`;
    });
  }
  function displayPath(path) {
    return path === task.taskLocation.path ? "" : path;
  }
  function descriptionTooltipText(task2) {
    return descriptionAdjustedForDependencySearch(task2);
  }
  function showDescriptionTooltip(element2, text2) {
    const tooltip = element2.createDiv();
    tooltip.addClasses(["tooltip", "pop-up"]);
    tooltip.innerText = text2;
    computePosition2(element2, tooltip, {
      placement: "top",
      middleware: [offset(-18), shift()]
    }).then(({ x, y }) => {
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    });
    element2.addEventListener("mouseleave", () => tooltip.remove());
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(8, input);
    });
  }
  function input_1_input_handler() {
    search = this.value;
    $$invalidate(6, search);
  }
  const keydown_handler = (e) => taskKeydown(e);
  const blur_handler = () => $$invalidate(7, inputFocused = false);
  function span_elementresize_handler() {
    inputWidth = this.clientWidth;
    $$invalidate(12, inputWidth);
  }
  const mouseenter_handler = (searchTask, e) => showDescriptionTooltip(e.currentTarget, descriptionTooltipText(searchTask));
  const mouseenter_handler_1 = (filepath, e) => showDescriptionTooltip(e.currentTarget, filepath);
  const mousedown_handler = (searchTask) => addTask(searchTask);
  const mouseenter_handler_2 = (index) => $$invalidate(11, searchIndex = index);
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdown = $$value;
      $$invalidate(9, dropdown);
    });
  }
  const mouseleave_handler = () => $$invalidate(11, searchIndex = null);
  const click_handler = (task2) => removeTask(task2);
  const mouseenter_handler_3 = (task2, e) => showDescriptionTooltip(e.currentTarget, descriptionTooltipText(task2));
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(5, task = $$props2.task);
    if ("editableTask" in $$props2)
      $$invalidate(0, editableTask = $$props2.editableTask);
    if ("allTasks" in $$props2)
      $$invalidate(20, allTasks = $$props2.allTasks);
    if ("_onDescriptionKeyDown" in $$props2)
      $$invalidate(21, _onDescriptionKeyDown = $$props2._onDescriptionKeyDown);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("labelText" in $$props2)
      $$invalidate(2, labelText = $$props2.labelText);
    if ("accesskey" in $$props2)
      $$invalidate(3, accesskey = $$props2.accesskey);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 768) {
      $: {
        positionDropdown(input, dropdown);
      }
    }
    if ($$self.$$.dirty[0] & 192) {
      $: {
        $$invalidate(10, searchResults = inputFocused ? generateSearchResults(search) : null);
      }
    }
  };
  return [
    editableTask,
    type,
    labelText,
    accesskey,
    placeholder,
    task,
    search,
    inputFocused,
    input,
    dropdown,
    searchResults,
    searchIndex,
    inputWidth,
    addTask,
    removeTask,
    taskKeydown,
    onFocused,
    displayPath,
    descriptionTooltipText,
    showDescriptionTooltip,
    allTasks,
    _onDescriptionKeyDown,
    input_1_binding,
    input_1_input_handler,
    keydown_handler,
    blur_handler,
    span_elementresize_handler,
    mouseenter_handler,
    mouseenter_handler_1,
    mousedown_handler,
    mouseenter_handler_2,
    ul_binding,
    mouseleave_handler,
    click_handler,
    mouseenter_handler_3
  ];
}
var Dependency = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        task: 5,
        editableTask: 0,
        allTasks: 20,
        _onDescriptionKeyDown: 21,
        type: 1,
        labelText: 2,
        accesskey: 3,
        placeholder: 4
      },
      null,
      [-1, -1]
    );
  }
};
var Dependency_default = Dependency;

// src/ui/RecurrenceEditor.svelte
function create_fragment3(ctx) {
  let label;
  let raw0_value = labelContentWithAccessKey("Recurs", ctx[2]) + "";
  let t0;
  let input;
  let t1;
  let code;
  let t2;
  let t3;
  let html_tag;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      t0 = space();
      input = element("input");
      t1 = space();
      code = element("code");
      t2 = text(ctx[4]);
      t3 = space();
      html_tag = new HtmlTag(false);
      attr(label, "for", "recurrence");
      attr(input, "id", "recurrence");
      attr(input, "type", "text");
      attr(input, "class", "tasks-modal-date-input");
      attr(input, "placeholder", "Try 'every day when done'");
      attr(input, "accesskey", ctx[2]);
      toggle_class(input, "tasks-modal-error", !ctx[1]);
      html_tag.a = null;
      attr(code, "class", "tasks-modal-parsed-date");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      label.innerHTML = raw0_value;
      insert(target, t0, anchor);
      insert(target, input, anchor);
      set_input_value(input, ctx[0].recurrenceRule);
      insert(target, t1, anchor);
      insert(target, code, anchor);
      append(code, t2);
      append(code, t3);
      html_tag.m(ctx[3], code);
      if (!mounted) {
        dispose = listen(input, "input", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && raw0_value !== (raw0_value = labelContentWithAccessKey("Recurs", ctx2[2]) + ""))
        label.innerHTML = raw0_value;
      ;
      if (dirty & 4) {
        attr(input, "accesskey", ctx2[2]);
      }
      if (dirty & 1 && input.value !== ctx2[0].recurrenceRule) {
        set_input_value(input, ctx2[0].recurrenceRule);
      }
      if (dirty & 2) {
        toggle_class(input, "tasks-modal-error", !ctx2[1]);
      }
      if (dirty & 8)
        html_tag.p(ctx2[3]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(label);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(input);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(code);
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { editableTask } = $$props;
  let { isRecurrenceValid } = $$props;
  let { accesskey } = $$props;
  let parsedRecurrence;
  const { recurrenceSymbol } = TASK_FORMATS.tasksPluginEmoji.taskSerializer.symbols;
  function input_input_handler() {
    editableTask.recurrenceRule = this.value;
    $$invalidate(0, editableTask);
  }
  $$self.$$set = ($$props2) => {
    if ("editableTask" in $$props2)
      $$invalidate(0, editableTask = $$props2.editableTask);
    if ("isRecurrenceValid" in $$props2)
      $$invalidate(1, isRecurrenceValid = $$props2.isRecurrenceValid);
    if ("accesskey" in $$props2)
      $$invalidate(2, accesskey = $$props2.accesskey);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(3, { parsedRecurrence, isRecurrenceValid } = parseAndValidateRecurrence(editableTask), parsedRecurrence, ($$invalidate(1, isRecurrenceValid), $$invalidate(0, editableTask)));
    }
  };
  return [
    editableTask,
    isRecurrenceValid,
    accesskey,
    parsedRecurrence,
    recurrenceSymbol,
    input_input_handler
  ];
}
var RecurrenceEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      editableTask: 0,
      isRecurrenceValid: 1,
      accesskey: 2
    });
  }
};
var RecurrenceEditor_default = RecurrenceEditor;

// src/ui/StatusEditor.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let option;
  let t0_value = ctx[7].name + "";
  let t0;
  let t1;
  let t2_value = ctx[7].symbol + "";
  let t2;
  let t3;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = text(" [");
      t2 = text(t2_value);
      t3 = text("]");
      option.__value = option_value_value = ctx[7].symbol;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
      append(option, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[7].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[7].symbol + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[7].symbol)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment4(ctx) {
  let label;
  let raw_value = labelContentWithAccessKey("Status", ctx[1]) + "";
  let t;
  let select;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      label = element("label");
      t = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(label, "for", "status");
      attr(select, "id", "status-type");
      attr(select, "class", "status-editor-status-selector");
      attr(select, "accesskey", ctx[1]);
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[6].call(select));
    },
    m(target, anchor) {
      insert(target, label, anchor);
      label.innerHTML = raw_value;
      insert(target, t, anchor);
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[2], true);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[6]),
          listen(select, "change", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && raw_value !== (raw_value = labelContentWithAccessKey("Status", ctx2[1]) + ""))
        label.innerHTML = raw_value;
      ;
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        attr(select, "accesskey", ctx2[1]);
      }
      if (dirty & 5) {
        select_option(select, ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(label);
      if (detaching)
        detach(t);
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { task } = $$props;
  let { editableTask } = $$props;
  let { statusOptions } = $$props;
  let { accesskey } = $$props;
  let statusSymbol = task.status.symbol;
  const _onStatusChange = () => {
    const selectedStatus = statusOptions.find((s) => s.symbol === statusSymbol);
    if (selectedStatus) {
      $$invalidate(4, editableTask.status = selectedStatus, editableTask);
    } else {
      console.log(`Error in EditTask: cannot find status with symbol ${statusSymbol}`);
      return;
    }
    const taskWithEditedStatusApplied = task.handleNewStatus(selectedStatus).pop();
    if (taskWithEditedStatusApplied) {
      $$invalidate(4, editableTask.doneDate = taskWithEditedStatusApplied.done.formatAsDate(), editableTask);
      $$invalidate(4, editableTask.cancelledDate = taskWithEditedStatusApplied.cancelled.formatAsDate(), editableTask);
    }
  };
  function select_change_handler() {
    statusSymbol = select_value(this);
    $$invalidate(2, statusSymbol);
    $$invalidate(0, statusOptions);
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(5, task = $$props2.task);
    if ("editableTask" in $$props2)
      $$invalidate(4, editableTask = $$props2.editableTask);
    if ("statusOptions" in $$props2)
      $$invalidate(0, statusOptions = $$props2.statusOptions);
    if ("accesskey" in $$props2)
      $$invalidate(1, accesskey = $$props2.accesskey);
  };
  return [
    statusOptions,
    accesskey,
    statusSymbol,
    _onStatusChange,
    editableTask,
    task,
    select_change_handler
  ];
}
var StatusEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      task: 5,
      editableTask: 4,
      statusOptions: 0,
      accesskey: 1
    });
  }
};
var StatusEditor_default = StatusEditor;

// src/ui/EditTask.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[56] = list[i].value;
  child_ctx[57] = list[i].label;
  child_ctx[58] = list[i].symbol;
  child_ctx[59] = list[i].accessKey;
  child_ctx[60] = list[i].accessKeyIndex;
  return child_ctx;
}
function create_else_block_1(ctx) {
  let span;
  let t_value = ctx[57] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_22(ctx) {
  let span0;
  let t0_value = ctx[57].substring(0, ctx[60]) + "";
  let t0;
  let span1;
  let t1_value = ctx[57].substring(ctx[60], ctx[60] + 1) + "";
  let t1;
  let span2;
  let t2_value = ctx[57].substring(ctx[60] + 1) + "";
  let t2;
  return {
    c() {
      span0 = element("span");
      t0 = text(t0_value);
      span1 = element("span");
      t1 = text(t1_value);
      span2 = element("span");
      t2 = text(t2_value);
      attr(span1, "class", "accesskey");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append(span0, t0);
      insert(target, span1, anchor);
      append(span1, t1);
      insert(target, span2, anchor);
      append(span2, t2);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(span1);
      if (detaching)
        detach(span2);
    }
  };
}
function create_if_block_12(ctx) {
  let span;
  let t_value = ctx[58] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block3(ctx) {
  let div;
  let input;
  let input_id_value;
  let input_value_value;
  let input_accesskey_value;
  let t0;
  let label;
  let t1;
  let show_if = ctx[58] && ctx[58].charCodeAt(0) >= 256;
  let label_for_value;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[12])
      return create_if_block_22;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = show_if && create_if_block_12(ctx);
  binding_group = init_binding_group(ctx[34][0]);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = "priority-" + ctx[56]);
      input.__value = input_value_value = ctx[56];
      input.value = input.__value;
      attr(input, "accesskey", input_accesskey_value = ctx[16](ctx[59]));
      attr(label, "for", label_for_value = "priority-" + ctx[56]);
      attr(div, "class", "task-modal-priority-option-container");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      input.checked = input.__value === ctx[3].priority;
      append(div, t0);
      append(div, label);
      if_block0.m(label, null);
      append(label, t1);
      if (if_block1)
        if_block1.m(label, null);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[33]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 65536 && input_accesskey_value !== (input_accesskey_value = ctx2[16](ctx2[59]))) {
        attr(input, "accesskey", input_accesskey_value);
      }
      if (dirty[0] & 8) {
        input.checked = input.__value === ctx2[3].priority;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(label, t1);
        }
      }
      if (show_if)
        if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i>Blocking and blocked by fields are disabled when vault tasks is empty</i>`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block2(ctx) {
  let dependency0;
  let t;
  let dependency1;
  let current;
  dependency0 = new Dependency_default({
    props: {
      type: "blockedBy",
      labelText: "Before this",
      task: ctx[0],
      editableTask: ctx[3],
      allTasks: ctx[2],
      _onDescriptionKeyDown: ctx[26],
      accesskey: ctx[16]("b"),
      placeholder: "Search for tasks that the task being edited depends on..."
    }
  });
  dependency1 = new Dependency_default({
    props: {
      type: "blocking",
      labelText: "After this",
      task: ctx[0],
      editableTask: ctx[3],
      allTasks: ctx[2],
      _onDescriptionKeyDown: ctx[26],
      accesskey: ctx[16]("e"),
      placeholder: "Search for tasks that depend on this task being done..."
    }
  });
  return {
    c() {
      create_component(dependency0.$$.fragment);
      t = space();
      create_component(dependency1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dependency0, target, anchor);
      insert(target, t, anchor);
      mount_component(dependency1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dependency0_changes = {};
      if (dirty[0] & 1)
        dependency0_changes.task = ctx2[0];
      if (dirty[0] & 8)
        dependency0_changes.editableTask = ctx2[3];
      if (dirty[0] & 4)
        dependency0_changes.allTasks = ctx2[2];
      if (dirty[0] & 65536)
        dependency0_changes.accesskey = ctx2[16]("b");
      dependency0.$set(dependency0_changes);
      const dependency1_changes = {};
      if (dirty[0] & 1)
        dependency1_changes.task = ctx2[0];
      if (dirty[0] & 8)
        dependency1_changes.editableTask = ctx2[3];
      if (dirty[0] & 4)
        dependency1_changes.allTasks = ctx2[2];
      if (dirty[0] & 65536)
        dependency1_changes.accesskey = ctx2[16]("e");
      dependency1.$set(dependency1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dependency0.$$.fragment, local);
      transition_in(dependency1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dependency0.$$.fragment, local);
      transition_out(dependency1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dependency0, detaching);
      if (detaching)
        detach(t);
      destroy_component(dependency1, detaching);
    }
  };
}
function create_fragment5(ctx) {
  let form;
  let section0;
  let label0;
  let raw0_value = labelContentWithAccessKey("Description", ctx[16]("t")) + "";
  let t0;
  let textarea;
  let textarea_accesskey_value;
  let t1;
  let section1;
  let label1;
  let t2;
  let label1_for_value;
  let t3;
  let t4;
  let hr0;
  let t5;
  let section2;
  let recurrenceeditor;
  let updating_isRecurrenceValid;
  let t6;
  let dateeditor0;
  let updating_date;
  let updating_isDateValid;
  let t7;
  let dateeditor1;
  let updating_date_1;
  let updating_isDateValid_1;
  let t8;
  let dateeditor2;
  let updating_date_2;
  let updating_isDateValid_2;
  let t9;
  let dateeditor3;
  let updating_date_3;
  let updating_isDateValid_3;
  let t10;
  let div;
  let label2;
  let raw1_value = labelContentWithAccessKey("Only future dates:", ctx[16]("f")) + "";
  let t11;
  let input;
  let input_accesskey_value;
  let t12;
  let hr1;
  let t13;
  let section3;
  let current_block_type_index;
  let if_block;
  let t14;
  let hr2;
  let t15;
  let section4;
  let statuseditor;
  let updating_editableTask;
  let t16;
  let dateeditor4;
  let updating_date_4;
  let updating_isDateValid_4;
  let t17;
  let dateeditor5;
  let updating_date_5;
  let updating_isDateValid_5;
  let t18;
  let dateeditor6;
  let updating_date_6;
  let updating_isDateValid_6;
  let t19;
  let section5;
  let button0;
  let t20;
  let button0_disabled_value;
  let t21;
  let button1;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[24];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  function recurrenceeditor_isRecurrenceValid_binding(value) {
    ctx[35](value);
  }
  let recurrenceeditor_props = {
    editableTask: ctx[3],
    accesskey: ctx[16]("r")
  };
  if (ctx[11] !== void 0) {
    recurrenceeditor_props.isRecurrenceValid = ctx[11];
  }
  recurrenceeditor = new RecurrenceEditor_default({ props: recurrenceeditor_props });
  binding_callbacks.push(() => bind(recurrenceeditor, "isRecurrenceValid", recurrenceeditor_isRecurrenceValid_binding));
  function dateeditor0_date_binding(value) {
    ctx[36](value);
  }
  function dateeditor0_isDateValid_binding(value) {
    ctx[37](value);
  }
  let dateeditor0_props = {
    id: "due",
    dateSymbol: ctx[19],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("d")
  };
  if (ctx[3].dueDate !== void 0) {
    dateeditor0_props.date = ctx[3].dueDate;
  }
  if (ctx[7] !== void 0) {
    dateeditor0_props.isDateValid = ctx[7];
  }
  dateeditor0 = new DateEditor_default({ props: dateeditor0_props });
  binding_callbacks.push(() => bind(dateeditor0, "date", dateeditor0_date_binding));
  binding_callbacks.push(() => bind(dateeditor0, "isDateValid", dateeditor0_isDateValid_binding));
  function dateeditor1_date_binding(value) {
    ctx[38](value);
  }
  function dateeditor1_isDateValid_binding(value) {
    ctx[39](value);
  }
  let dateeditor1_props = {
    id: "reminder",
    dateSymbol: ctx[20],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: null
  };
  if (ctx[3].reminderDate !== void 0) {
    dateeditor1_props.date = ctx[3].reminderDate;
  }
  if (ctx[8] !== void 0) {
    dateeditor1_props.isDateValid = ctx[8];
  }
  dateeditor1 = new DateEditor_default({ props: dateeditor1_props });
  binding_callbacks.push(() => bind(dateeditor1, "date", dateeditor1_date_binding));
  binding_callbacks.push(() => bind(dateeditor1, "isDateValid", dateeditor1_isDateValid_binding));
  function dateeditor2_date_binding(value) {
    ctx[40](value);
  }
  function dateeditor2_isDateValid_binding(value) {
    ctx[41](value);
  }
  let dateeditor2_props = {
    id: "scheduled",
    dateSymbol: ctx[18],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("s")
  };
  if (ctx[3].scheduledDate !== void 0) {
    dateeditor2_props.date = ctx[3].scheduledDate;
  }
  if (ctx[9] !== void 0) {
    dateeditor2_props.isDateValid = ctx[9];
  }
  dateeditor2 = new DateEditor_default({ props: dateeditor2_props });
  binding_callbacks.push(() => bind(dateeditor2, "date", dateeditor2_date_binding));
  binding_callbacks.push(() => bind(dateeditor2, "isDateValid", dateeditor2_isDateValid_binding));
  function dateeditor3_date_binding(value) {
    ctx[42](value);
  }
  function dateeditor3_isDateValid_binding(value) {
    ctx[43](value);
  }
  let dateeditor3_props = {
    id: "start",
    dateSymbol: ctx[17],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("a")
  };
  if (ctx[3].startDate !== void 0) {
    dateeditor3_props.date = ctx[3].startDate;
  }
  if (ctx[10] !== void 0) {
    dateeditor3_props.isDateValid = ctx[10];
  }
  dateeditor3 = new DateEditor_default({ props: dateeditor3_props });
  binding_callbacks.push(() => bind(dateeditor3, "date", dateeditor3_date_binding));
  binding_callbacks.push(() => bind(dateeditor3, "isDateValid", dateeditor3_isDateValid_binding));
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].length > 0 && ctx2[15])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function statuseditor_editableTask_binding(value) {
    ctx[45](value);
  }
  let statuseditor_props = {
    task: ctx[0],
    statusOptions: ctx[1],
    accesskey: ctx[16]("u")
  };
  if (ctx[3] !== void 0) {
    statuseditor_props.editableTask = ctx[3];
  }
  statuseditor = new StatusEditor_default({ props: statuseditor_props });
  binding_callbacks.push(() => bind(statuseditor, "editableTask", statuseditor_editableTask_binding));
  function dateeditor4_date_binding(value) {
    ctx[46](value);
  }
  function dateeditor4_isDateValid_binding(value) {
    ctx[47](value);
  }
  let dateeditor4_props = {
    id: "created",
    dateSymbol: ctx[22],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("c")
  };
  if (ctx[3].createdDate !== void 0) {
    dateeditor4_props.date = ctx[3].createdDate;
  }
  if (ctx[5] !== void 0) {
    dateeditor4_props.isDateValid = ctx[5];
  }
  dateeditor4 = new DateEditor_default({ props: dateeditor4_props });
  binding_callbacks.push(() => bind(dateeditor4, "date", dateeditor4_date_binding));
  binding_callbacks.push(() => bind(dateeditor4, "isDateValid", dateeditor4_isDateValid_binding));
  function dateeditor5_date_binding(value) {
    ctx[48](value);
  }
  function dateeditor5_isDateValid_binding(value) {
    ctx[49](value);
  }
  let dateeditor5_props = {
    id: "done",
    dateSymbol: ctx[23],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("x")
  };
  if (ctx[3].doneDate !== void 0) {
    dateeditor5_props.date = ctx[3].doneDate;
  }
  if (ctx[6] !== void 0) {
    dateeditor5_props.isDateValid = ctx[6];
  }
  dateeditor5 = new DateEditor_default({ props: dateeditor5_props });
  binding_callbacks.push(() => bind(dateeditor5, "date", dateeditor5_date_binding));
  binding_callbacks.push(() => bind(dateeditor5, "isDateValid", dateeditor5_isDateValid_binding));
  function dateeditor6_date_binding(value) {
    ctx[50](value);
  }
  function dateeditor6_isDateValid_binding(value) {
    ctx[51](value);
  }
  let dateeditor6_props = {
    id: "cancelled",
    dateSymbol: ctx[21],
    forwardOnly: ctx[3].forwardOnly,
    accesskey: ctx[16]("-")
  };
  if (ctx[3].cancelledDate !== void 0) {
    dateeditor6_props.date = ctx[3].cancelledDate;
  }
  if (ctx[4] !== void 0) {
    dateeditor6_props.isDateValid = ctx[4];
  }
  dateeditor6 = new DateEditor_default({ props: dateeditor6_props });
  binding_callbacks.push(() => bind(dateeditor6, "date", dateeditor6_date_binding));
  binding_callbacks.push(() => bind(dateeditor6, "isDateValid", dateeditor6_isDateValid_binding));
  return {
    c() {
      form = element("form");
      section0 = element("section");
      label0 = element("label");
      t0 = space();
      textarea = element("textarea");
      t1 = space();
      section1 = element("section");
      label1 = element("label");
      t2 = text("Priority");
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      hr0 = element("hr");
      t5 = space();
      section2 = element("section");
      create_component(recurrenceeditor.$$.fragment);
      t6 = space();
      create_component(dateeditor0.$$.fragment);
      t7 = space();
      create_component(dateeditor1.$$.fragment);
      t8 = space();
      create_component(dateeditor2.$$.fragment);
      t9 = space();
      create_component(dateeditor3.$$.fragment);
      t10 = space();
      div = element("div");
      label2 = element("label");
      t11 = space();
      input = element("input");
      t12 = space();
      hr1 = element("hr");
      t13 = space();
      section3 = element("section");
      if_block.c();
      t14 = space();
      hr2 = element("hr");
      t15 = space();
      section4 = element("section");
      create_component(statuseditor.$$.fragment);
      t16 = space();
      create_component(dateeditor4.$$.fragment);
      t17 = space();
      create_component(dateeditor5.$$.fragment);
      t18 = space();
      create_component(dateeditor6.$$.fragment);
      t19 = space();
      section5 = element("section");
      button0 = element("button");
      t20 = text("Apply");
      t21 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(label0, "for", "description");
      attr(textarea, "id", "description");
      attr(textarea, "class", "tasks-modal-description");
      attr(textarea, "placeholder", "Take out the trash");
      attr(textarea, "accesskey", textarea_accesskey_value = ctx[16]("t"));
      attr(section0, "class", "tasks-modal-description-section");
      attr(label1, "for", label1_for_value = "priority-" + ctx[3].priority);
      attr(section1, "class", "tasks-modal-priority-section");
      attr(label2, "for", "forwardOnly");
      attr(input, "id", "forwardOnly");
      attr(input, "type", "checkbox");
      attr(input, "class", "task-list-item-checkbox tasks-modal-checkbox");
      attr(input, "accesskey", input_accesskey_value = ctx[16]("f"));
      attr(div, "class", "future-dates-only");
      attr(section2, "class", "tasks-modal-dates-section");
      attr(section3, "class", "tasks-modal-dependencies-section");
      attr(section4, "class", "tasks-modal-dates-section");
      button0.disabled = button0_disabled_value = !ctx[14];
      attr(button0, "type", "submit");
      attr(button0, "class", "mod-cta");
      attr(button1, "type", "button");
      attr(section5, "class", "tasks-modal-button-section");
      attr(form, "class", "tasks-modal");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, section0);
      append(section0, label0);
      label0.innerHTML = raw0_value;
      append(section0, t0);
      append(section0, textarea);
      set_input_value(textarea, ctx[3].description);
      ctx[32](textarea);
      append(form, t1);
      append(form, section1);
      append(section1, label1);
      append(label1, t2);
      append(section1, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(section1, null);
        }
      }
      append(form, t4);
      append(form, hr0);
      append(form, t5);
      append(form, section2);
      mount_component(recurrenceeditor, section2, null);
      append(section2, t6);
      mount_component(dateeditor0, section2, null);
      append(section2, t7);
      mount_component(dateeditor1, section2, null);
      append(section2, t8);
      mount_component(dateeditor2, section2, null);
      append(section2, t9);
      mount_component(dateeditor3, section2, null);
      append(section2, t10);
      append(section2, div);
      append(div, label2);
      label2.innerHTML = raw1_value;
      append(div, t11);
      append(div, input);
      input.checked = ctx[3].forwardOnly;
      append(form, t12);
      append(form, hr1);
      append(form, t13);
      append(form, section3);
      if_blocks[current_block_type_index].m(section3, null);
      append(form, t14);
      append(form, hr2);
      append(form, t15);
      append(form, section4);
      mount_component(statuseditor, section4, null);
      append(section4, t16);
      mount_component(dateeditor4, section4, null);
      append(section4, t17);
      mount_component(dateeditor5, section4, null);
      append(section4, t18);
      mount_component(dateeditor6, section4, null);
      append(form, t19);
      append(form, section5);
      append(section5, button0);
      append(button0, t20);
      append(section5, t21);
      append(section5, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(textarea, "input", ctx[31]),
          listen(textarea, "keydown", ctx[26]),
          listen(textarea, "paste", ctx[27]),
          listen(textarea, "drop", ctx[27]),
          listen(input, "change", ctx[44]),
          listen(button1, "click", ctx[25]),
          listen(form, "submit", prevent_default(ctx[28]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 65536) && raw0_value !== (raw0_value = labelContentWithAccessKey("Description", ctx2[16]("t")) + ""))
        label0.innerHTML = raw0_value;
      ;
      if (!current || dirty[0] & 65536 && textarea_accesskey_value !== (textarea_accesskey_value = ctx2[16]("t"))) {
        attr(textarea, "accesskey", textarea_accesskey_value);
      }
      if (dirty[0] & 8) {
        set_input_value(textarea, ctx2[3].description);
      }
      if (!current || dirty[0] & 8 && label1_for_value !== (label1_for_value = "priority-" + ctx2[3].priority)) {
        attr(label1, "for", label1_for_value);
      }
      if (dirty[0] & 16846856) {
        each_value = ctx2[24];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(section1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      const recurrenceeditor_changes = {};
      if (dirty[0] & 8)
        recurrenceeditor_changes.editableTask = ctx2[3];
      if (dirty[0] & 65536)
        recurrenceeditor_changes.accesskey = ctx2[16]("r");
      if (!updating_isRecurrenceValid && dirty[0] & 2048) {
        updating_isRecurrenceValid = true;
        recurrenceeditor_changes.isRecurrenceValid = ctx2[11];
        add_flush_callback(() => updating_isRecurrenceValid = false);
      }
      recurrenceeditor.$set(recurrenceeditor_changes);
      const dateeditor0_changes = {};
      if (dirty[0] & 8)
        dateeditor0_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor0_changes.accesskey = ctx2[16]("d");
      if (!updating_date && dirty[0] & 8) {
        updating_date = true;
        dateeditor0_changes.date = ctx2[3].dueDate;
        add_flush_callback(() => updating_date = false);
      }
      if (!updating_isDateValid && dirty[0] & 128) {
        updating_isDateValid = true;
        dateeditor0_changes.isDateValid = ctx2[7];
        add_flush_callback(() => updating_isDateValid = false);
      }
      dateeditor0.$set(dateeditor0_changes);
      const dateeditor1_changes = {};
      if (dirty[0] & 8)
        dateeditor1_changes.forwardOnly = ctx2[3].forwardOnly;
      if (!updating_date_1 && dirty[0] & 8) {
        updating_date_1 = true;
        dateeditor1_changes.date = ctx2[3].reminderDate;
        add_flush_callback(() => updating_date_1 = false);
      }
      if (!updating_isDateValid_1 && dirty[0] & 256) {
        updating_isDateValid_1 = true;
        dateeditor1_changes.isDateValid = ctx2[8];
        add_flush_callback(() => updating_isDateValid_1 = false);
      }
      dateeditor1.$set(dateeditor1_changes);
      const dateeditor2_changes = {};
      if (dirty[0] & 8)
        dateeditor2_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor2_changes.accesskey = ctx2[16]("s");
      if (!updating_date_2 && dirty[0] & 8) {
        updating_date_2 = true;
        dateeditor2_changes.date = ctx2[3].scheduledDate;
        add_flush_callback(() => updating_date_2 = false);
      }
      if (!updating_isDateValid_2 && dirty[0] & 512) {
        updating_isDateValid_2 = true;
        dateeditor2_changes.isDateValid = ctx2[9];
        add_flush_callback(() => updating_isDateValid_2 = false);
      }
      dateeditor2.$set(dateeditor2_changes);
      const dateeditor3_changes = {};
      if (dirty[0] & 8)
        dateeditor3_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor3_changes.accesskey = ctx2[16]("a");
      if (!updating_date_3 && dirty[0] & 8) {
        updating_date_3 = true;
        dateeditor3_changes.date = ctx2[3].startDate;
        add_flush_callback(() => updating_date_3 = false);
      }
      if (!updating_isDateValid_3 && dirty[0] & 1024) {
        updating_isDateValid_3 = true;
        dateeditor3_changes.isDateValid = ctx2[10];
        add_flush_callback(() => updating_isDateValid_3 = false);
      }
      dateeditor3.$set(dateeditor3_changes);
      if ((!current || dirty[0] & 65536) && raw1_value !== (raw1_value = labelContentWithAccessKey("Only future dates:", ctx2[16]("f")) + ""))
        label2.innerHTML = raw1_value;
      ;
      if (!current || dirty[0] & 65536 && input_accesskey_value !== (input_accesskey_value = ctx2[16]("f"))) {
        attr(input, "accesskey", input_accesskey_value);
      }
      if (dirty[0] & 8) {
        input.checked = ctx2[3].forwardOnly;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(section3, null);
      }
      const statuseditor_changes = {};
      if (dirty[0] & 1)
        statuseditor_changes.task = ctx2[0];
      if (dirty[0] & 2)
        statuseditor_changes.statusOptions = ctx2[1];
      if (dirty[0] & 65536)
        statuseditor_changes.accesskey = ctx2[16]("u");
      if (!updating_editableTask && dirty[0] & 8) {
        updating_editableTask = true;
        statuseditor_changes.editableTask = ctx2[3];
        add_flush_callback(() => updating_editableTask = false);
      }
      statuseditor.$set(statuseditor_changes);
      const dateeditor4_changes = {};
      if (dirty[0] & 8)
        dateeditor4_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor4_changes.accesskey = ctx2[16]("c");
      if (!updating_date_4 && dirty[0] & 8) {
        updating_date_4 = true;
        dateeditor4_changes.date = ctx2[3].createdDate;
        add_flush_callback(() => updating_date_4 = false);
      }
      if (!updating_isDateValid_4 && dirty[0] & 32) {
        updating_isDateValid_4 = true;
        dateeditor4_changes.isDateValid = ctx2[5];
        add_flush_callback(() => updating_isDateValid_4 = false);
      }
      dateeditor4.$set(dateeditor4_changes);
      const dateeditor5_changes = {};
      if (dirty[0] & 8)
        dateeditor5_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor5_changes.accesskey = ctx2[16]("x");
      if (!updating_date_5 && dirty[0] & 8) {
        updating_date_5 = true;
        dateeditor5_changes.date = ctx2[3].doneDate;
        add_flush_callback(() => updating_date_5 = false);
      }
      if (!updating_isDateValid_5 && dirty[0] & 64) {
        updating_isDateValid_5 = true;
        dateeditor5_changes.isDateValid = ctx2[6];
        add_flush_callback(() => updating_isDateValid_5 = false);
      }
      dateeditor5.$set(dateeditor5_changes);
      const dateeditor6_changes = {};
      if (dirty[0] & 8)
        dateeditor6_changes.forwardOnly = ctx2[3].forwardOnly;
      if (dirty[0] & 65536)
        dateeditor6_changes.accesskey = ctx2[16]("-");
      if (!updating_date_6 && dirty[0] & 8) {
        updating_date_6 = true;
        dateeditor6_changes.date = ctx2[3].cancelledDate;
        add_flush_callback(() => updating_date_6 = false);
      }
      if (!updating_isDateValid_6 && dirty[0] & 16) {
        updating_isDateValid_6 = true;
        dateeditor6_changes.isDateValid = ctx2[4];
        add_flush_callback(() => updating_isDateValid_6 = false);
      }
      dateeditor6.$set(dateeditor6_changes);
      if (!current || dirty[0] & 16384 && button0_disabled_value !== (button0_disabled_value = !ctx2[14])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recurrenceeditor.$$.fragment, local);
      transition_in(dateeditor0.$$.fragment, local);
      transition_in(dateeditor1.$$.fragment, local);
      transition_in(dateeditor2.$$.fragment, local);
      transition_in(dateeditor3.$$.fragment, local);
      transition_in(if_block);
      transition_in(statuseditor.$$.fragment, local);
      transition_in(dateeditor4.$$.fragment, local);
      transition_in(dateeditor5.$$.fragment, local);
      transition_in(dateeditor6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recurrenceeditor.$$.fragment, local);
      transition_out(dateeditor0.$$.fragment, local);
      transition_out(dateeditor1.$$.fragment, local);
      transition_out(dateeditor2.$$.fragment, local);
      transition_out(dateeditor3.$$.fragment, local);
      transition_out(if_block);
      transition_out(statuseditor.$$.fragment, local);
      transition_out(dateeditor4.$$.fragment, local);
      transition_out(dateeditor5.$$.fragment, local);
      transition_out(dateeditor6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form);
      ctx[32](null);
      destroy_each(each_blocks, detaching);
      destroy_component(recurrenceeditor);
      destroy_component(dateeditor0);
      destroy_component(dateeditor1);
      destroy_component(dateeditor2);
      destroy_component(dateeditor3);
      if_blocks[current_block_type_index].d();
      destroy_component(statuseditor);
      destroy_component(dateeditor4);
      destroy_component(dateeditor5);
      destroy_component(dateeditor6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let accesskey;
  let { task } = $$props;
  let { onSubmit } = $$props;
  let { statusOptions } = $$props;
  let { allTasks } = $$props;
  const {
    prioritySymbols,
    startDateSymbol,
    scheduledDateSymbol,
    dueDateSymbol,
    reminderDateSymbol,
    cancelledDateSymbol,
    createdDateSymbol,
    doneDateSymbol
  } = TASK_FORMATS.tasksPluginEmoji.taskSerializer.symbols;
  let descriptionInput;
  let editableTask = {
    description: "",
    status: Status.TODO,
    priority: "none",
    recurrenceRule: "",
    createdDate: "",
    startDate: "",
    scheduledDate: "",
    dueDate: "",
    reminderDate: "",
    doneDate: "",
    cancelledDate: "",
    forwardOnly: true,
    blockedBy: [],
    blocking: []
  };
  let isDescriptionValid = true;
  let isCancelledDateValid = true;
  let isCreatedDateValid = true;
  let isDoneDateValid = true;
  let isDueDateValid = true;
  let isReminderDateValid = true;
  let isScheduledDateValid = true;
  let isStartDateValid = true;
  let isRecurrenceValid = true;
  let addGlobalFilterOnSave = false;
  let withAccessKeys = true;
  let formIsValid = true;
  let originalBlocking = [];
  let mountComplete = false;
  const priorityOptions = [
    {
      value: "lowest",
      label: "Lowest",
      symbol: prioritySymbols.Lowest,
      accessKey: "o",
      accessKeyIndex: 1
    },
    {
      value: "low",
      label: "Low",
      symbol: prioritySymbols.Low,
      accessKey: "l",
      accessKeyIndex: 0
    },
    {
      value: "none",
      label: "Normal",
      symbol: prioritySymbols.None,
      accessKey: "n",
      accessKeyIndex: 0
    },
    {
      value: "medium",
      label: "Medium",
      symbol: prioritySymbols.Medium,
      accessKey: "m",
      accessKeyIndex: 0
    },
    {
      value: "high",
      label: "High",
      symbol: prioritySymbols.High,
      accessKey: "h",
      accessKeyIndex: 0
    },
    {
      value: "highest",
      label: "Highest",
      symbol: prioritySymbols.Highest,
      accessKey: "i",
      accessKeyIndex: 1
    }
  ];
  function serialiseTaskId(task2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (task2.id !== "")
        return task2;
      const tasksWithId = allTasks.filter((task3) => task3.id !== "");
      const updatedTask = ensureTaskHasId(task2, tasksWithId.map((task3) => task3.id));
      yield replaceTaskWithTasks({
        originalTask: task2,
        newTasks: updatedTask
      });
      return updatedTask;
    });
  }
  onMount(() => {
    const { provideAccessKeys } = getSettings();
    $$invalidate(12, withAccessKeys = provideAccessKeys);
    const description = GlobalFilter.getInstance().removeAsWordFrom(task.description);
    if (description != task.description || !GlobalFilter.getInstance().includedIn(task.description)) {
      addGlobalFilterOnSave = true;
    }
    let priority = "none";
    if (task.priority === "5" /* Lowest */) {
      priority = "lowest";
    } else if (task.priority === "4" /* Low */) {
      priority = "low";
    } else if (task.priority === "2" /* Medium */) {
      priority = "medium";
    } else if (task.priority === "1" /* High */) {
      priority = "high";
    } else if (task.priority === "0" /* Highest */) {
      priority = "highest";
    }
    const blockedBy = [];
    for (const taskId of task.dependsOn) {
      const depTask = allTasks.find((cacheTask) => cacheTask.id === taskId);
      if (!depTask)
        continue;
      blockedBy.push(depTask);
    }
    originalBlocking = allTasks.filter((cacheTask) => cacheTask.dependsOn.includes(task.id));
    $$invalidate(3, editableTask = {
      description,
      status: task.status,
      priority,
      recurrenceRule: task.recurrence ? task.recurrence.toText() : "",
      createdDate: new TasksDate(task.createdDate).formatAsDate(),
      startDate: new TasksDate(task.startDate).formatAsDate(),
      scheduledDate: new TasksDate(task.scheduledDate).formatAsDate(),
      dueDate: new TasksDate(task.dueDate).formatAsDate(),
      reminderDate: new TasksDate(task.reminderDate).formatAsDateAndTimeOrDate(),
      doneDate: new TasksDate(task.doneDate).formatAsDate(),
      cancelledDate: new TasksDate(task.cancelledDate).formatAsDate(),
      forwardOnly: true,
      blockedBy,
      blocking: originalBlocking
    });
    $$invalidate(15, mountComplete = true);
    setTimeout(
      () => {
        descriptionInput.focus();
      },
      10
    );
  });
  const _onClose = () => {
    onSubmit([]);
  };
  const _onDescriptionKeyDown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (formIsValid)
        _onSubmit();
    }
  };
  const _removeLinebreaksFromDescription = () => {
    setTimeout(
      () => {
        $$invalidate(3, editableTask.description = editableTask.description.replace(/[\r\n]+/g, " "), editableTask);
      },
      0
    );
  };
  const _onSubmit = () => __awaiter(void 0, void 0, void 0, function* () {
    let description = editableTask.description.trim();
    if (addGlobalFilterOnSave) {
      description = GlobalFilter.getInstance().prependTo(description);
    }
    const startDate = parseTypedDateForSaving(editableTask.startDate, editableTask.forwardOnly);
    const scheduledDate = parseTypedDateForSaving(editableTask.scheduledDate, editableTask.forwardOnly);
    const dueDate = parseTypedDateForSaving(editableTask.dueDate, editableTask.forwardOnly);
    const reminderDate = parseTypedDateorDateTimeForSavingReminder(editableTask.reminderDate, editableTask.forwardOnly);
    const cancelledDate = parseTypedDateForSaving(editableTask.cancelledDate, editableTask.forwardOnly);
    const createdDate = parseTypedDateForSaving(editableTask.createdDate, editableTask.forwardOnly);
    const doneDate = parseTypedDateForSaving(editableTask.doneDate, editableTask.forwardOnly);
    let recurrence = null;
    if (editableTask.recurrenceRule) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: editableTask.recurrenceRule,
        startDate,
        scheduledDate,
        dueDate,
        reminderDate
      });
    }
    let parsedPriority;
    switch (editableTask.priority) {
      case "lowest":
        parsedPriority = "5" /* Lowest */;
        break;
      case "low":
        parsedPriority = "4" /* Low */;
        break;
      case "medium":
        parsedPriority = "2" /* Medium */;
        break;
      case "high":
        parsedPriority = "1" /* High */;
        break;
      case "highest":
        parsedPriority = "0" /* Highest */;
        break;
      default:
        parsedPriority = "3" /* None */;
    }
    let blockedByWithIds = [];
    for (const depTask of editableTask.blockedBy) {
      const newDep = yield serialiseTaskId(depTask);
      blockedByWithIds.push(newDep);
    }
    let id = task.id;
    let removedBlocking = [];
    let addedBlocking = [];
    if (editableTask.blocking.toString() !== originalBlocking.toString() || editableTask.blocking.length !== 0) {
      if (task.id === "") {
        id = generateUniqueId(allTasks.filter((task2) => task2.id !== "").map((task2) => task2.id));
      }
      removedBlocking = originalBlocking.filter((task2) => !editableTask.blocking.includes(task2));
      addedBlocking = editableTask.blocking.filter((task2) => !originalBlocking.includes(task2));
    }
    const updatedTask = new Task(Object.assign(Object.assign({}, task), {
      description,
      status: task.status,
      priority: parsedPriority,
      recurrence,
      startDate,
      scheduledDate,
      dueDate,
      reminderDate,
      doneDate,
      createdDate,
      cancelledDate,
      dependsOn: blockedByWithIds.map((task2) => task2.id),
      id
    }));
    for (const blocking of removedBlocking) {
      const newParent = removeDependency(blocking, updatedTask);
      yield replaceTaskWithTasks({
        originalTask: blocking,
        newTasks: newParent
      });
    }
    for (const blocking of addedBlocking) {
      const newParent = addDependencyToParent(blocking, updatedTask);
      yield replaceTaskWithTasks({
        originalTask: blocking,
        newTasks: newParent
      });
    }
    const today = doneDate ? doneDate : window.moment();
    const newTasks = updatedTask.handleNewStatusWithRecurrenceInUsersOrder(editableTask.status, today);
    onSubmit(newTasks);
  });
  const $$binding_groups = [[]];
  function textarea_input_handler() {
    editableTask.description = this.value;
    $$invalidate(3, editableTask);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      descriptionInput = $$value;
      $$invalidate(13, descriptionInput);
    });
  }
  function input_change_handler() {
    editableTask.priority = this.__value;
    $$invalidate(3, editableTask);
  }
  function recurrenceeditor_isRecurrenceValid_binding(value) {
    isRecurrenceValid = value;
    $$invalidate(11, isRecurrenceValid);
  }
  function dateeditor0_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.dueDate, value)) {
      editableTask.dueDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor0_isDateValid_binding(value) {
    isDueDateValid = value;
    $$invalidate(7, isDueDateValid);
  }
  function dateeditor1_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.reminderDate, value)) {
      editableTask.reminderDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor1_isDateValid_binding(value) {
    isReminderDateValid = value;
    $$invalidate(8, isReminderDateValid);
  }
  function dateeditor2_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.scheduledDate, value)) {
      editableTask.scheduledDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor2_isDateValid_binding(value) {
    isScheduledDateValid = value;
    $$invalidate(9, isScheduledDateValid);
  }
  function dateeditor3_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.startDate, value)) {
      editableTask.startDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor3_isDateValid_binding(value) {
    isStartDateValid = value;
    $$invalidate(10, isStartDateValid);
  }
  function input_change_handler_1() {
    editableTask.forwardOnly = this.checked;
    $$invalidate(3, editableTask);
  }
  function statuseditor_editableTask_binding(value) {
    editableTask = value;
    $$invalidate(3, editableTask);
  }
  function dateeditor4_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.createdDate, value)) {
      editableTask.createdDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor4_isDateValid_binding(value) {
    isCreatedDateValid = value;
    $$invalidate(5, isCreatedDateValid);
  }
  function dateeditor5_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.doneDate, value)) {
      editableTask.doneDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor5_isDateValid_binding(value) {
    isDoneDateValid = value;
    $$invalidate(6, isDoneDateValid);
  }
  function dateeditor6_date_binding(value) {
    if ($$self.$$.not_equal(editableTask.cancelledDate, value)) {
      editableTask.cancelledDate = value;
      $$invalidate(3, editableTask);
    }
  }
  function dateeditor6_isDateValid_binding(value) {
    isCancelledDateValid = value;
    $$invalidate(4, isCancelledDateValid);
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(0, task = $$props2.task);
    if ("onSubmit" in $$props2)
      $$invalidate(29, onSubmit = $$props2.onSubmit);
    if ("statusOptions" in $$props2)
      $$invalidate(1, statusOptions = $$props2.statusOptions);
    if ("allTasks" in $$props2)
      $$invalidate(2, allTasks = $$props2.allTasks);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4096) {
      $:
        $$invalidate(16, accesskey = (key) => withAccessKeys ? key : null);
    }
    if ($$self.$$.dirty[0] & 8) {
      $:
        $$invalidate(30, isDescriptionValid = editableTask.description.trim() !== "");
    }
    if ($$self.$$.dirty[0] & 1073745904) {
      $:
        $$invalidate(14, formIsValid = isDueDateValid && isReminderDateValid && isRecurrenceValid && isScheduledDateValid && isStartDateValid && isDescriptionValid && isCancelledDateValid && isCreatedDateValid && isDoneDateValid);
    }
  };
  return [
    task,
    statusOptions,
    allTasks,
    editableTask,
    isCancelledDateValid,
    isCreatedDateValid,
    isDoneDateValid,
    isDueDateValid,
    isReminderDateValid,
    isScheduledDateValid,
    isStartDateValid,
    isRecurrenceValid,
    withAccessKeys,
    descriptionInput,
    formIsValid,
    mountComplete,
    accesskey,
    startDateSymbol,
    scheduledDateSymbol,
    dueDateSymbol,
    reminderDateSymbol,
    cancelledDateSymbol,
    createdDateSymbol,
    doneDateSymbol,
    priorityOptions,
    _onClose,
    _onDescriptionKeyDown,
    _removeLinebreaksFromDescription,
    _onSubmit,
    onSubmit,
    isDescriptionValid,
    textarea_input_handler,
    textarea_binding,
    input_change_handler,
    $$binding_groups,
    recurrenceeditor_isRecurrenceValid_binding,
    dateeditor0_date_binding,
    dateeditor0_isDateValid_binding,
    dateeditor1_date_binding,
    dateeditor1_isDateValid_binding,
    dateeditor2_date_binding,
    dateeditor2_isDateValid_binding,
    dateeditor3_date_binding,
    dateeditor3_isDateValid_binding,
    input_change_handler_1,
    statuseditor_editableTask_binding,
    dateeditor4_date_binding,
    dateeditor4_isDateValid_binding,
    dateeditor5_date_binding,
    dateeditor5_isDateValid_binding,
    dateeditor6_date_binding,
    dateeditor6_isDateValid_binding
  ];
}
var EditTask = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        task: 0,
        onSubmit: 29,
        statusOptions: 1,
        allTasks: 2
      },
      null,
      [-1, -1, -1]
    );
  }
};
var EditTask_default = EditTask;

// src/Obsidian/TaskModal.ts
var TaskModal = class extends import_obsidian6.Modal {
  constructor({
    app: app2,
    task,
    onSubmit,
    allTasks
  }) {
    super(app2);
    this.task = task;
    this.allTasks = allTasks;
    this.onSubmit = (updatedTasks) => {
      updatedTasks.length && onSubmit(updatedTasks);
      this.close();
    };
  }
  onOpen() {
    this.titleEl.setText("Create or edit Task");
    this.modalEl.style.paddingBottom = "0";
    const { contentEl } = this;
    this.contentEl.style.paddingBottom = "0";
    const statusOptions = this.getKnownStatusesAndCurrentTaskStatusIfNotKnown();
    new EditTask_default({
      target: contentEl,
      props: { task: this.task, statusOptions, onSubmit: this.onSubmit, allTasks: this.allTasks }
    });
  }
  getKnownStatusesAndCurrentTaskStatusIfNotKnown() {
    const statusOptions = StatusRegistry.getInstance().registeredStatuses;
    if (StatusRegistry.getInstance().bySymbol(this.task.status.symbol) === Status.EMPTY) {
      statusOptions.push(this.task.status);
    }
    return statusOptions;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Commands/CreateOrEditTaskParser.ts
function getDefaultCreatedDate() {
  const { setCreatedDate } = getSettings();
  return setCreatedDate ? window.moment() : null;
}
function shouldUpdateCreatedDateForTask(task) {
  const { setCreatedDate } = getSettings();
  if (!setCreatedDate) {
    return false;
  }
  if (task.createdDate !== null) {
    return false;
  }
  const descriptionIsEmpty = task.description === "";
  const globalFilterEnabled = !GlobalFilter.getInstance().isEmpty();
  const taskDoesNotContainGlobalFilter = !GlobalFilter.getInstance().includedIn(task.description);
  const needsGlobalFilterToBeAdded = globalFilterEnabled && taskDoesNotContainGlobalFilter;
  return descriptionIsEmpty || needsGlobalFilterToBeAdded;
}
var taskFromLine = ({ line, path }) => {
  var _a, _b;
  const task = Task.parseTaskSignifiers(
    line,
    TaskLocation.fromUnknownPosition(new TasksFile(path)),
    DateFallback.fromPath(path)
  );
  const createdDate = getDefaultCreatedDate();
  if (task !== null) {
    if (shouldUpdateCreatedDateForTask(task)) {
      return new Task(__spreadProps(__spreadValues({}, task), { createdDate }));
    }
    return task;
  }
  const nonTaskMatch = line.match(TaskRegularExpressions.nonTaskRegex);
  if (nonTaskMatch === null) {
    console.error("Tasks: Cannot create task on line:", line);
    return new Task({
      status: Status.TODO,
      description: "",
      taskLocation: TaskLocation.fromUnknownPosition(new TasksFile(path)),
      indentation: "",
      listMarker: "-",
      priority: "3" /* None */,
      createdDate,
      startDate: null,
      scheduledDate: null,
      dueDate: null,
      reminderDate: null,
      doneDate: null,
      cancelledDate: null,
      recurrence: null,
      dependsOn: [],
      id: "",
      blockLink: "",
      tags: [],
      originalMarkdown: "",
      scheduledDateIsInferred: false
    });
  }
  const indentation = nonTaskMatch[1];
  const listMarker = (_a = nonTaskMatch[2]) != null ? _a : "-";
  const statusString = (_b = nonTaskMatch[4]) != null ? _b : " ";
  const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
  let description = nonTaskMatch[5];
  const blockLinkMatch = line.match(TaskRegularExpressions.blockLinkRegex);
  const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
  if (blockLink !== "") {
    description = description.replace(TaskRegularExpressions.blockLinkRegex, "");
  }
  return new Task({
    status,
    description,
    taskLocation: TaskLocation.fromUnknownPosition(new TasksFile(path)),
    indentation,
    listMarker,
    blockLink,
    priority: "3" /* None */,
    createdDate,
    startDate: null,
    scheduledDate: null,
    dueDate: null,
    reminderDate: null,
    doneDate: null,
    cancelledDate: null,
    recurrence: null,
    tags: [],
    originalMarkdown: "",
    scheduledDateIsInferred: false,
    id: "",
    dependsOn: []
  });
};

// src/Commands/CreateOrEdit.ts
var createOrEdit = (checking, editor, view, app2, allTasks) => {
  var _a;
  if (checking) {
    return view instanceof import_obsidian7.MarkdownView;
  }
  if (!(view instanceof import_obsidian7.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const cursorPosition = editor.getCursor();
  const lineNumber = cursorPosition.line;
  const line = editor.getLine(lineNumber);
  const task = taskFromLine({ line, path });
  const onSubmit = (updatedTasks) => {
    const serialized = DateFallback.removeInferredStatusIfNeeded(task, updatedTasks).map((task2) => task2.toFileLineString()).join("\n");
    editor.setLine(lineNumber, serialized);
  };
  const taskModal = new TaskModal({
    app: app2,
    task,
    onSubmit,
    allTasks
  });
  taskModal.open();
};

// src/Commands/ToggleDone.ts
var import_obsidian8 = require("obsidian");
var toggleDone = (checking, editor, view) => {
  var _a;
  if (checking) {
    if (!(view instanceof import_obsidian8.MarkdownView)) {
      return false;
    }
    return true;
  }
  if (!(view instanceof import_obsidian8.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const origCursorPos = editor.getCursor();
  const lineNumber = origCursorPos.line;
  const line = editor.getLine(lineNumber);
  const insertion = toggleLine(line, path);
  editor.setLine(lineNumber, insertion.text);
  editor.setCursor(getNewCursorPosition(origCursorPos, insertion));
};
var toggleLine = (line, path) => {
  const task = Task.fromLine({
    line,
    taskLocation: TaskLocation.fromUnknownPosition(new TasksFile(path)),
    fallbackDate: null
  });
  if (task !== null) {
    const lines = task.toggleWithRecurrenceInUsersOrder().map((t) => t.toFileLineString());
    return { text: lines.join("\n"), moveTo: { line: lines.length - 1 } };
  } else {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch !== null) {
      const statusString = regexMatch[3];
      const status = StatusRegistry.getInstance().bySymbol(statusString);
      const newStatusString = status.nextStatusSymbol;
      return { text: line.replace(TaskRegularExpressions.taskRegex, `$1- [${newStatusString}] $4`) };
    } else if (TaskRegularExpressions.listItemRegex.test(line)) {
      const text2 = line.replace(TaskRegularExpressions.listItemRegex, "$1$2 [ ]");
      return { text: text2, moveTo: { ch: text2.length } };
    } else {
      const text2 = line.replace(TaskRegularExpressions.indentationRegex, "$1- ");
      return { text: text2, moveTo: { ch: text2.length } };
    }
  }
};
var getNewCursorPosition = (startPos, insertion) => {
  var _a;
  const defaultMoveTo = { line: 0, ch: startPos.ch };
  const moveTo = __spreadValues(__spreadValues({}, defaultMoveTo), (_a = insertion.moveTo) != null ? _a : {});
  const destinationLineLength = insertion.text.split("\n")[moveTo.line].length;
  return {
    line: startPos.line + moveTo.line,
    ch: Math.min(moveTo.ch, destinationLineLength)
  };
};

// src/Commands/index.ts
var Commands = class {
  get app() {
    return this.plugin.app;
  }
  constructor({ plugin }) {
    this.plugin = plugin;
    plugin.addCommand({
      id: "edit-task",
      name: "Create or edit task",
      icon: "pencil",
      editorCheckCallback: (checking, editor, view) => {
        return createOrEdit(checking, editor, view, this.app, this.plugin.getTasks());
      }
    });
    plugin.addCommand({
      id: "toggle-done",
      name: "Toggle task done",
      icon: "check-in-circle",
      editorCheckCallback: toggleDone
    });
  }
};

// src/Layout/QueryLayoutOptions.ts
var QueryLayoutOptions = class {
  constructor() {
    this.hidePostponeButton = false;
    this.hideTaskCount = false;
    this.hideBacklinks = false;
    this.hideEditButton = false;
    this.hideUrgency = true;
    this.shortMode = false;
    this.explainQuery = false;
  }
};

// src/lib/ExceptionTools.ts
function errorMessageForException(whatWasHappening, exception) {
  const errorMessage = `Error: ${whatWasHappening}.
The error message was:
    `;
  let detail = "";
  if (exception instanceof Error) {
    detail += exception;
  } else {
    detail += "Unknown error";
  }
  return `${errorMessage}"${detail}"`;
}

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray2 = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray2(obj) ? "array" : typeof obj;
}
function escapeRegExp2(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp2(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp2(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp2("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index = this.tail.search(re), match;
  switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index = 0;
        while (intermediateValue != null && index < names.length) {
          if (index === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
          intermediateValue = intermediateValue[names[index++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse2(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value = this.unescapedValue(token, context);
    else if (symbol === "name")
      value = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self2 = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context, partials, config);
  }
  if (!value)
    return;
  if (isArray2(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray2(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray2(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray2(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse3(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// src/Scripting/ExpandPlaceholders.ts
var import_mustache_validator = __toESM(require_dist2());
function expandPlaceholders(template, view) {
  mustache_default.escape = function(text2) {
    return text2;
  };
  try {
    return mustache_default.render(template, (0, import_mustache_validator.default)(view));
  } catch (error) {
    let message = "";
    if (error instanceof Error) {
      message = `There was an error expanding one or more placeholders.

The error message was:
    ${error.message.replace(/ > /g, ".").replace("Missing Mustache data property", "Unknown property")}`;
    } else {
      message = "Unknown error expanding placeholders.";
    }
    message += `

The problem is in:
    ${template}`;
    throw Error(message);
  }
}

// src/Scripting/QueryContext.ts
function makeQueryContext(path) {
  return makeQueryContextWithTasks(path, []);
}
function makeQueryContextWithTasks(path, allTasks) {
  const tasksFile = new TasksFile(path);
  return {
    query: {
      file: tasksFile,
      allTasks
    }
  };
}

// src/Query/Explain/Explainer.ts
var Explainer = class {
  constructor(indentation = "") {
    this.indentation = indentation;
  }
  explainQuery(query) {
    if (query.error !== void 0) {
      return this.explainError(query);
    }
    const results = [];
    results.push(this.explainFilters(query));
    results.push(this.explainGroups(query));
    results.push(this.explainSorters(query));
    results.push(this.explainQueryLimits(query));
    results.push(this.explainDebugSettings());
    return results.filter((explanation) => explanation !== "").join("\n");
  }
  explainError(query) {
    let result = "";
    result += "Query has an error:\n";
    result += query.error + "\n";
    return result;
  }
  explainFilters(query) {
    const numberOfFilters = query.filters.length;
    if (numberOfFilters === 0) {
      return this.indent("No filters supplied. All tasks will match the query.\n");
    }
    return query.filters.map((filter) => {
      return filter.explainFilterIndented(this.indentation);
    }).join("\n");
  }
  explainGroups(query) {
    const numberOfGroups = query.grouping.length;
    if (numberOfGroups === 0) {
      return this.indent("No grouping instructions supplied.\n");
    }
    let result = "";
    for (let i = 0; i < numberOfGroups; i++) {
      result += this.indentation + query.grouping[i].instruction + "\n";
    }
    return result;
  }
  explainSorters(query) {
    const numberOfSorters = query.sorting.length;
    if (numberOfSorters === 0) {
      return this.indent("No sorting instructions supplied.\n");
    }
    let result = "";
    for (let i = 0; i < numberOfSorters; i++) {
      result += this.indentation + query.sorting[i].instruction + "\n";
    }
    return result;
  }
  explainQueryLimits(query) {
    function getPluralisedText(limit) {
      let text2 = `At most ${limit} task`;
      if (limit !== 1) {
        text2 += "s";
      }
      return text2;
    }
    const results = [];
    if (query.limit !== void 0) {
      const result = getPluralisedText(query.limit) + ".\n";
      results.push(this.indent(result));
    }
    if (query.taskGroupLimit !== void 0) {
      const result = getPluralisedText(query.taskGroupLimit) + ' per group (if any "group by" options are supplied).\n';
      results.push(this.indent(result));
    }
    return results.join("\n");
  }
  explainDebugSettings() {
    let result = "";
    const { debugSettings } = getSettings();
    if (debugSettings.ignoreSortInstructions) {
      result += this.indent(
        "NOTE: All sort instructions, including default sort order, are disabled, due to 'ignoreSortInstructions' setting.\n"
      );
    }
    return result;
  }
  indent(description) {
    return this.indentation + description;
  }
};

// src/Query/Explain/Explanation.ts
var Explanation = class {
  constructor(description, children2 = [], symbol = "") {
    this.description = description;
    this.symbol = symbol;
    this.children = children2;
  }
  static booleanAnd(children2) {
    return this.combineOrCreateExplanation("All of", children2, "AND");
  }
  static booleanOr(children2) {
    return this.combineOrCreateExplanation("At least one of", children2, "OR");
  }
  static booleanNot(children2) {
    return new Explanation("None of", children2, "NOT");
  }
  static booleanXor(children2) {
    return new Explanation("Exactly one of", children2, "XOR");
  }
  asString(currentIndentation = "") {
    if (this.children.length == 0) {
      return currentIndentation + this.description;
    }
    let result = currentIndentation;
    if (this.symbol === "") {
      result += this.description;
    } else {
      result += this.symbol;
      if (this.children.length > 1) {
        result += ` (${this.description})`;
      }
      result += ":";
    }
    const newIndentation = currentIndentation + "  ";
    for (let i = 0; i < this.children.length; i++) {
      result += `
${this.children[i].asString(newIndentation)}`;
    }
    return result;
  }
  static combineOrCreateExplanation(description, children2, symbol) {
    if (children2.length === 2) {
      const child0 = children2[0];
      const child1 = children2[1];
      if (child0.symbol === symbol && child1.symbol === "") {
        child0.children.push(child1);
        return child0;
      }
    }
    return new Explanation(description, children2, symbol);
  }
};

// src/Query/Matchers/IStringMatcher.ts
var IStringMatcher = class {
  matchesAnyOf(stringsToSearch) {
    return stringsToSearch.some((s) => this.matches(s));
  }
};

// src/Query/Matchers/SubstringMatcher.ts
var SubstringMatcher = class extends IStringMatcher {
  constructor(stringToFind) {
    super();
    this.stringToFind = stringToFind;
  }
  matches(stringToSearch) {
    return SubstringMatcher.stringIncludesCaseInsensitive(stringToSearch, this.stringToFind);
  }
  static stringIncludesCaseInsensitive(haystack, needle) {
    return haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase());
  }
  explanation(instruction) {
    return new Explanation(instruction);
  }
};

// src/Query/Matchers/RegexMatcher.ts
var RegexMatcher = class extends IStringMatcher {
  constructor(regex) {
    super();
    this.regex = regex;
  }
  static validateAndConstruct(regexInput) {
    const regexPattern = /^\/(.+)\/([^/]*)$/;
    const query = regexInput.match(regexPattern);
    if (query !== null) {
      const regExp = new RegExp(query[1], query[2]);
      return new RegexMatcher(regExp);
    } else {
      return null;
    }
  }
  matches(stringToSearch) {
    return stringToSearch.match(this.regex) !== null;
  }
  static helpMessage() {
    return String.raw`See https://publish.obsidian.md/tasks/Queries/Regular+Expressions

Regular expressions must look like this:
    /pattern/
or this:
    /pattern/flags

Where:
- pattern: The 'regular expression' pattern to search for.
- flags:   Optional characters that modify the search.
           i => make the search case-insensitive
           u => add Unicode support

Examples:  /^Log/
           /^Log/i
           /File Name\.md/
           /waiting|waits|waited/i
           /\d\d:\d\d/

The following characters have special meaning in the pattern:
to find them literally, you must add a \ before them:
    [\^$.|?*+()

CAUTION! Regular expression (or 'regex') searching is a powerful
but advanced feature that requires thorough knowledge in order to
use successfully, and not miss intended search results.
`;
  }
  explanation(instruction) {
    const intro = "using regex: ";
    const explanationText = alignRegexWithOriginalInstruction(instruction, intro, this.regexAsString());
    return new Explanation(explanationText);
  }
  regexAsString() {
    let result = `'${this.regex.source}' with `;
    switch (this.regex.flags.length) {
      case 0:
        result += "no flags";
        break;
      case 1:
        result += `flag '${this.regex.flags}'`;
        break;
      default:
        result += `flags '${this.regex.flags}'`;
        break;
    }
    return result;
  }
};
function alignRegexWithOriginalInstruction(instruction, intro, regexAsString) {
  var _a;
  const match = instruction.match(/\//);
  if (!match) {
    return "Error explaining instruction. Could not find a slash character";
  }
  const indentation = 2;
  const startOfRegex = ((_a = match.index) != null ? _a : indentation) - indentation;
  const prefixPadded = intro.padEnd(startOfRegex);
  return `${prefixPadded}${regexAsString}`;
}

// src/Query/Sort/Sorter.ts
var Sorter = class {
  constructor(instruction, property, comparator, reverse) {
    this.instruction = instruction;
    this.property = property;
    this.comparator = Sorter.maybeReverse(reverse, comparator);
  }
  static maybeReverse(reverse, comparator) {
    return reverse ? Sorter.makeReversedComparator(comparator) : comparator;
  }
  static makeReversedComparator(comparator) {
    return (a, b, searchInfo) => comparator(a, b, searchInfo) * -1;
  }
};

// src/Query/Group/Grouper.ts
var Grouper = class {
  constructor(instruction, property, grouper, reverse) {
    this.instruction = instruction;
    this.property = property;
    this.grouper = grouper;
    this.reverse = reverse;
  }
};

// src/Query/Filter/Field.ts
var Field = class {
  canCreateFilterForLine(line) {
    return Field.lineMatchesFilter(this.filterRegExp(), line);
  }
  static lineMatchesFilter(filter, line) {
    if (filter) {
      return filter.test(line);
    } else {
      return false;
    }
  }
  static getMatch(filterRegExp, line) {
    if (filterRegExp) {
      return line.match(filterRegExp);
    } else {
      return null;
    }
  }
  fieldNameSingular() {
    return this.fieldName();
  }
  fieldNameSingularEscaped() {
    return escapeRegExp(this.fieldNameSingular());
  }
  supportsSorting() {
    return false;
  }
  createSorterFromLine(line) {
    if (!this.supportsSorting()) {
      return null;
    }
    const match = Field.getMatch(this.sorterRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    return this.createSorter(reverse);
  }
  sorterRegExp() {
    if (!this.supportsSorting()) {
      throw Error(`sorterRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^sort by ${this.fieldNameSingularEscaped()}( reverse)?`, "i");
  }
  sorterInstruction(reverse) {
    let instruction = `sort by ${this.fieldNameSingular()}`;
    if (reverse) {
      instruction += " reverse";
    }
    return instruction;
  }
  comparator() {
    throw Error(`comparator() unimplemented for ${this.fieldNameSingular()}`);
  }
  createSorter(reverse) {
    return new Sorter(this.sorterInstruction(reverse), this.fieldNameSingular(), this.comparator(), reverse);
  }
  createNormalSorter() {
    return this.createSorter(false);
  }
  createReverseSorter() {
    return this.createSorter(true);
  }
  supportsGrouping() {
    return false;
  }
  createGrouperFromLine(line) {
    if (!this.supportsGrouping()) {
      return null;
    }
    const match = Field.getMatch(this.grouperRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    return this.createGrouper(reverse);
  }
  grouperRegExp() {
    if (!this.supportsGrouping()) {
      throw Error(`grouperRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^group by ${this.fieldNameSingularEscaped()}( reverse)?$`, "i");
  }
  grouperInstruction(reverse) {
    let instruction = `group by ${this.fieldNameSingular()}`;
    if (reverse) {
      instruction += " reverse";
    }
    return instruction;
  }
  grouper() {
    throw Error(`grouper() unimplemented for ${this.fieldNameSingular()}`);
  }
  createGrouper(reverse) {
    return new Grouper(this.grouperInstruction(reverse), this.fieldNameSingular(), this.grouper(), reverse);
  }
  createNormalGrouper() {
    return this.createGrouper(false);
  }
  createReverseGrouper() {
    return this.createGrouper(true);
  }
};

// src/Query/Statement.ts
var Statement = class {
  constructor(rawInstruction, instruction) {
    this._rawInstruction = rawInstruction;
    this._anyContinuationLinesRemoved = instruction.trim();
    this._anyPlaceholdersExpanded = this._anyContinuationLinesRemoved;
  }
  recordExpandedPlaceholders(line) {
    this._anyPlaceholdersExpanded = line;
  }
  get rawInstruction() {
    return this._rawInstruction;
  }
  get anyContinuationLinesRemoved() {
    return this._anyContinuationLinesRemoved;
  }
  get anyPlaceholdersExpanded() {
    return this._anyPlaceholdersExpanded;
  }
  explainStatement(indent) {
    function appendLineIfDifferent(previousLine, nextLine) {
      if (nextLine !== previousLine) {
        result += ` =>
${indent}${nextLine}`;
      }
    }
    const rawInstructionTrimmed = this._rawInstruction.trim();
    const raw = rawInstructionTrimmed.split("\n").join("\n" + indent);
    let result = `${indent}${raw}`;
    if (this._rawInstruction.includes("\n")) {
      result += "\n" + indent;
    }
    appendLineIfDifferent(rawInstructionTrimmed, this._anyContinuationLinesRemoved);
    appendLineIfDifferent(this._anyContinuationLinesRemoved, this._anyPlaceholdersExpanded);
    return result;
  }
  allLinesIdentical() {
    return this._rawInstruction === this._anyContinuationLinesRemoved && this._rawInstruction === this._anyPlaceholdersExpanded;
  }
};

// src/Query/Filter/Filter.ts
var Filter = class {
  constructor(instruction, filterFunction, explanation) {
    this._statement = new Statement(instruction, instruction);
    this.explanation = explanation;
    this.filterFunction = filterFunction;
  }
  get statement() {
    return this._statement;
  }
  setStatement(statement) {
    this._statement = statement;
  }
  get instruction() {
    return this._statement.anyPlaceholdersExpanded;
  }
  explainFilterIndented(indent) {
    const explainedStatement = this._statement.explainStatement(indent);
    if (this.onlyNeedsOneLineExplanation()) {
      return `${explainedStatement}
`;
    } else {
      return `${explainedStatement} =>
${this.explanation.asString(indent + "  ")}
`;
    }
  }
  simulateExplainFilter() {
    if (this.onlyNeedsOneLineExplanation()) {
      return this.explanation;
    } else {
      return new Explanation(this.instruction + " =>", [this.explanation]);
    }
  }
  onlyNeedsOneLineExplanation() {
    return this.explanation.asString("") === this.instruction;
  }
};

// src/Query/QueryComponentOrError.ts
var QueryComponentOrError = class {
  constructor(instruction) {
    this.instruction = instruction;
  }
  get queryComponent() {
    return this._queryComponent;
  }
  set queryComponent(value) {
    this._queryComponent = value;
  }
  get error() {
    return this._error;
  }
  set error(value) {
    this._error = value;
  }
  isValid() {
    return this._queryComponent !== void 0;
  }
  static fromObject(instruction, object) {
    const result = new QueryComponentOrError(instruction);
    result._queryComponent = object;
    return result;
  }
  static fromError(instruction, errorMessage) {
    const result = new QueryComponentOrError(instruction);
    result._error = errorMessage;
    return result;
  }
};

// src/Query/Filter/FilterOrErrorMessage.ts
var FilterOrErrorMessage = class {
  constructor(object) {
    this.object = object;
  }
  get instruction() {
    return this.object.instruction;
  }
  get filter() {
    return this.object.queryComponent;
  }
  isValid() {
    return this.object.isValid();
  }
  get error() {
    return this.object.error;
  }
  get filterFunction() {
    if (this.filter) {
      return this.filter.filterFunction;
    } else {
      return void 0;
    }
  }
  static fromFilter(filter) {
    return new FilterOrErrorMessage(QueryComponentOrError.fromObject(filter.instruction, filter));
  }
  static fromError(instruction, errorMessage) {
    return new FilterOrErrorMessage(QueryComponentOrError.fromError(instruction, errorMessage));
  }
};

// src/Query/Filter/TextField.ts
var TextField = class extends Field {
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const filterOperator = match[1].toLowerCase();
    const filterValue = match[2];
    let matcher = null;
    if (filterOperator.includes("include")) {
      matcher = new SubstringMatcher(filterValue);
    } else if (filterOperator.includes("regex")) {
      try {
        matcher = RegexMatcher.validateAndConstruct(filterValue);
      } catch (e) {
        const message = errorMessageForException("Parsing regular expression", e) + `

${RegexMatcher.helpMessage()}`;
        return FilterOrErrorMessage.fromError(line, message);
      }
      if (matcher === null) {
        return FilterOrErrorMessage.fromError(
          line,
          `Invalid instruction: '${line}'

${RegexMatcher.helpMessage()}`
        );
      }
    }
    if (matcher === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const negate = filterOperator.match(/not/) !== null;
    const filter = new Filter(line, this.getFilter(matcher, negate), matcher.explanation(line));
    return FilterOrErrorMessage.fromFilter(filter);
  }
  fieldPattern() {
    return this.fieldNameSingularEscaped();
  }
  filterOperatorPattern() {
    return "includes|does not include|regex matches|regex does not match";
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldPattern()}) (${this.filterOperatorPattern()}) (.*)`, "i");
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matches(this.value(task));
      return negate ? !match : match;
    };
  }
  comparator() {
    return (a, b) => {
      return this.value(a).localeCompare(this.value(b), void 0, { numeric: true });
    };
  }
  grouper() {
    return (task) => {
      return [this.value(task)];
    };
  }
  static escapeMarkdownCharacters(filename) {
    return filename.replace(/\\/g, "\\\\").replace(/_/g, "\\_");
  }
};

// src/Query/Filter/DescriptionField.ts
var DescriptionField = class extends TextField {
  fieldName() {
    return "description";
  }
  value(task) {
    return GlobalFilter.getInstance().removeAsSubstringFrom(task.description);
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const descriptionA = DescriptionField.cleanDescription(a.description);
      const descriptionB = DescriptionField.cleanDescription(b.description);
      return descriptionA.localeCompare(descriptionB, void 0, { numeric: true });
    };
  }
  static cleanDescription(description) {
    description = GlobalFilter.getInstance().removeAsSubstringFrom(description);
    const startsWithLinkRegex = /^\[\[?([^\]]*)]]?/;
    const linkRegexMatch = description.match(startsWithLinkRegex);
    if (linkRegexMatch !== null) {
      const innerLinkText = linkRegexMatch[1];
      description = innerLinkText.substring(innerLinkText.indexOf("|") + 1) + description.replace(startsWithLinkRegex, "");
    }
    description = this.replaceFormatting(description, /^\*\*([^*]+)\*\*/);
    description = this.replaceFormatting(description, /^\*([^*]+)\*/);
    description = this.replaceFormatting(description, /^==([^=]+)==/);
    description = this.replaceFormatting(description, /^__([^_]+)__/);
    description = this.replaceFormatting(description, /^_([^_]+)_/);
    return description;
  }
  static replaceFormatting(description, regExp) {
    const italicBoldRegexMatch = description.match(regExp);
    if (italicBoldRegexMatch !== null) {
      const innerItalicBoldText = italicBoldRegexMatch[1];
      description = innerItalicBoldText + description.replace(regExp, "");
    }
    return description;
  }
};

// src/lib/TemplatingPluginTools.ts
var TemplatingPluginTools = class {
  findUnexpandedDateText(line) {
    const templateTexts = ["<%", "YYYY-MM-DD"];
    for (const templateText of templateTexts) {
      if (line.includes(templateText)) {
        return this.unexpandedDateTextMessage(templateText);
      }
    }
    return null;
  }
  unexpandedDateTextMessage(templateText) {
    return `Instruction contains unexpanded template text: "${templateText}" - and cannot be interpreted.

Possible causes:
- The query is an a template file, and is not intended to be searched.
- A command such as "Replace templates in the active file" needs to be run.
- The core "Daily notes" plugin is in use, and the template contained
  date calculations that it does not support.
- Some sample template text was accidentally pasted in to a tasks query,
  instead of in to a template file.

See: https://publish.obsidian.md/tasks/Advanced/Instruction+contains+unexpanded+template+text
`;
  }
};

// src/Query/Filter/FilterInstruction.ts
var FilterInstruction = class {
  constructor(instruction, filter) {
    this._instruction = instruction;
    this._filter = filter;
  }
  canCreateFilterForLine(line) {
    return line.toLocaleLowerCase() === this._instruction.toLocaleLowerCase();
  }
  createFilterOrErrorMessage(line) {
    if (this.canCreateFilterForLine(line)) {
      return FilterOrErrorMessage.fromFilter(new Filter(line, this._filter, new Explanation(line)));
    }
    return FilterOrErrorMessage.fromError(line, `do not understand filter: ${line}`);
  }
};

// src/Query/Filter/FilterInstructions.ts
var FilterInstructions = class {
  constructor() {
    this._filters = [];
  }
  add(instruction, filter) {
    this._filters.push(new FilterInstruction(instruction, filter));
  }
  canCreateFilterForLine(line) {
    for (const filter of this._filters) {
      if (filter.canCreateFilterForLine(line)) {
        return true;
      }
    }
    return false;
  }
  createFilterOrErrorMessage(line) {
    for (const filter of this._filters) {
      const x = filter.createFilterOrErrorMessage(line);
      if (x.error === void 0) {
        return x;
      }
    }
    return FilterOrErrorMessage.fromError(line, `do not understand filter: ${line}`);
  }
};

// src/Query/Filter/DateField.ts
var DateField = class extends Field {
  constructor(filterInstructions = null) {
    super();
    if (filterInstructions !== null) {
      this.filterInstructions = filterInstructions;
    } else {
      this.filterInstructions = new FilterInstructions();
      this.filterInstructions.add(`has ${this.fieldName()} date`, (task) => this.date(task) !== null);
      this.filterInstructions.add(`no ${this.fieldName()} date`, (task) => this.date(task) === null);
      this.filterInstructions.add(`${this.fieldName()} date is invalid`, (task) => {
        const date = this.date(task);
        return date !== null && !date.isValid();
      });
    }
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    var _a;
    const errorText = this.checkForUnexpandedTemplateText(line);
    if (errorText) {
      return FilterOrErrorMessage.fromError(line, errorText);
    }
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.isValid()) {
      return filterResult;
    }
    const fieldNameKeywordDate = Field.getMatch(this.filterRegExp(), line);
    if (fieldNameKeywordDate === null) {
      return FilterOrErrorMessage.fromError(
        line,
        "do not understand query filter (" + this.fieldName() + " date)"
      );
    }
    const keywordAndDateString = fieldNameKeywordDate[1];
    const fieldKeyword = (_a = fieldNameKeywordDate[2]) == null ? void 0 : _a.toLowerCase();
    const fieldDateString = fieldNameKeywordDate[3];
    let fieldDates = DateParser.parseDateRange(fieldDateString);
    if (!fieldDates.isValid()) {
      const date = DateParser.parseDate(keywordAndDateString);
      if (date.isValid()) {
        fieldDates = new DateRange(date, date);
      }
    }
    if (!fieldDates.isValid()) {
      return FilterOrErrorMessage.fromError(line, "do not understand " + this.fieldName() + " date");
    }
    const filterFunction = this.buildFilterFunction(fieldKeyword, fieldDates);
    const explanation = DateField.buildExplanation(
      this.fieldNameForExplanation(),
      fieldKeyword,
      this.filterResultIfFieldMissing(),
      fieldDates
    );
    return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, explanation));
  }
  buildFilterFunction(fieldKeyword, fieldDates) {
    let dateFilter;
    switch (fieldKeyword) {
      case "before":
        dateFilter = (date) => date ? date.isBefore(fieldDates.start) : this.filterResultIfFieldMissing();
        break;
      case "after":
        dateFilter = (date) => date ? date.isAfter(fieldDates.end) : this.filterResultIfFieldMissing();
        break;
      case "on or before":
      case "in or before":
        dateFilter = (date) => date ? date.isSameOrBefore(fieldDates.end) : this.filterResultIfFieldMissing();
        break;
      case "on or after":
      case "in or after":
        dateFilter = (date) => date ? date.isSameOrAfter(fieldDates.start) : this.filterResultIfFieldMissing();
        break;
      default:
        dateFilter = (date) => date ? date.isSameOrAfter(fieldDates.start) && date.isSameOrBefore(fieldDates.end) : this.filterResultIfFieldMissing();
    }
    return this.getFilter(dateFilter);
  }
  getFilter(dateFilterFunction) {
    return (task) => {
      return dateFilterFunction(this.date(task));
    };
  }
  filterRegExp() {
    return new RegExp(
      `^${this.fieldNameForFilterInstruction()} (((?:on|in) or before|before|(?:on|in) or after|after|on|in)? ?(.*))`,
      "i"
    );
  }
  fieldNameForFilterInstruction() {
    return this.fieldName();
  }
  static buildExplanation(fieldName, fieldKeyword, filterResultIfFieldMissing, filterDates) {
    let relationship = fieldKeyword;
    const dateFormat = "YYYY-MM-DD (dddd Do MMMM YYYY)";
    let explanationDates;
    switch (fieldKeyword) {
      case "before":
      case "on or after":
        explanationDates = filterDates.start.format(dateFormat);
        break;
      case "after":
      case "on or before":
        explanationDates = filterDates.end.format(dateFormat);
        break;
      case "in or before":
        relationship = "on or before";
        explanationDates = filterDates.end.format(dateFormat);
        break;
      case "in or after":
        relationship = "on or after";
        explanationDates = filterDates.start.format(dateFormat);
        break;
      default:
        if (!filterDates.start.isSame(filterDates.end)) {
          const firstLine = `${fieldName} date is between:`;
          const subExplanations = [
            new Explanation(`${filterDates.start.format(dateFormat)} and`),
            new Explanation(`${filterDates.end.format(dateFormat)} inclusive`)
          ];
          if (filterResultIfFieldMissing) {
            subExplanations.push(new Explanation(`OR no ${fieldName} date`));
          }
          return new Explanation(firstLine, subExplanations);
        }
        relationship = "on";
        explanationDates = filterDates.start.format(dateFormat);
        break;
    }
    let oneLineExplanation = `${fieldName} date is ${relationship} ${explanationDates}`;
    if (filterResultIfFieldMissing) {
      oneLineExplanation += ` OR no ${fieldName} date`;
    }
    return new Explanation(oneLineExplanation);
  }
  fieldNameForExplanation() {
    return this.fieldName();
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return compareByDate(this.date(a), this.date(b));
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const date = this.date(task);
      if (date === null) {
        return ["No " + this.fieldName() + " date"];
      }
      if (!date.isValid()) {
        return ["%%0%% Invalid " + this.fieldName() + " date"];
      }
      return [date.format("YYYY-MM-DD dddd")];
    };
  }
  checkForUnexpandedTemplateText(line) {
    return new TemplatingPluginTools().findUnexpandedDateText(line);
  }
};

// src/Query/Filter/CreatedDateField.ts
var CreatedDateField = class extends DateField {
  fieldName() {
    return "created";
  }
  date(task) {
    return task.createdDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/DoneDateField.ts
var DoneDateField = class extends DateField {
  fieldName() {
    return "done";
  }
  date(task) {
    return task.doneDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/DueDateField.ts
var DueDateField = class extends DateField {
  fieldName() {
    return "due";
  }
  date(task) {
    return task.dueDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/ReminderDateField.ts
var ReminderDateField = class extends DateField {
  fieldName() {
    return "reminder";
  }
  date(task) {
    return task.reminderDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/FilterInstructionsBasedField.ts
var FilterInstructionsBasedField = class extends Field {
  constructor() {
    super(...arguments);
    this._filters = new FilterInstructions();
  }
  canCreateFilterForLine(line) {
    return this._filters.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    return this._filters.createFilterOrErrorMessage(line);
  }
  filterRegExp() {
    return null;
  }
};

// src/Query/Filter/ExcludeSubItemsField.ts
var ExcludeSubItemsField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("exclude sub-items", (task) => {
      if (task.indentation === "")
        return true;
      const lastBlockquoteMark = task.indentation.lastIndexOf(">");
      if (lastBlockquoteMark === -1)
        return false;
      return /^ ?$/.test(task.indentation.slice(lastBlockquoteMark + 1));
    });
  }
  fieldName() {
    return "exclude";
  }
};

// src/Scripting/Expression.ts
var FunctionOrError = class extends QueryComponentOrError {
};
function parseExpression(paramsArgs, arg) {
  const params = paramsArgs.map(([p]) => p);
  try {
    const input = arg.includes("return") ? arg : `return ${arg}`;
    const expression = arg && new Function(...params, input);
    if (expression instanceof Function) {
      return FunctionOrError.fromObject(arg, expression);
    }
    return FunctionOrError.fromError(arg, "Error parsing group function");
  } catch (e) {
    return FunctionOrError.fromError(arg, errorMessageForException(`Failed parsing expression "${arg}"`, e));
  }
}
function evaluateExpression(expression, paramsArgs) {
  const args = paramsArgs.map(([_, a]) => a);
  return expression(...args);
}
function evaluateExpressionOrCatch(expression, paramsArgs, arg) {
  try {
    return evaluateExpression(expression, paramsArgs);
  } catch (e) {
    return errorMessageForException(`Failed calculating expression "${arg}"`, e);
  }
}

// src/Scripting/TaskExpression.ts
function constructArguments(task, queryContext) {
  const paramsArgs = [
    ["task", task],
    ["query", queryContext ? queryContext.query : null]
  ];
  return paramsArgs;
}
function parseAndEvaluateExpression(task, arg, queryContext) {
  const paramsArgs = constructArguments(task, queryContext ? queryContext : null);
  const functionOrError = parseExpression(paramsArgs, arg);
  if (functionOrError.error) {
    return functionOrError.error;
  }
  return evaluateExpressionOrCatch(functionOrError.queryComponent, paramsArgs, arg);
}
var TaskExpression = class {
  constructor(line) {
    this.line = line;
    this.functionOrError = parseExpression(constructArguments(null, null), line);
  }
  isValid() {
    return this.functionOrError.isValid();
  }
  get parseError() {
    return this.functionOrError.error;
  }
  evaluate(task, queryContext) {
    if (!this.isValid()) {
      throw Error(
        `Error: Cannot evaluate an expression which is not valid: "${this.line}" gave error: "${this.parseError}"`
      );
    }
    return evaluateExpression(
      this.functionOrError.queryComponent,
      constructArguments(task, queryContext ? queryContext : null)
    );
  }
  evaluateOrCatch(task, queryContext) {
    if (!this.isValid()) {
      return `Error: Cannot evaluate an expression which is not valid: "${this.line}" gave error: "${this.parseError}"`;
    }
    return evaluateExpressionOrCatch(
      this.functionOrError.queryComponent,
      constructArguments(task, queryContext),
      this.line
    );
  }
};

// src/lib/TypeDetection.ts
function getValueType(value) {
  if (value === null) {
    return "null";
  }
  const type = typeof value;
  if (type === "object") {
    return value.constructor.name;
  }
  return type;
}

// src/Query/Filter/FunctionField.ts
var FunctionField = class extends Field {
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return FilterOrErrorMessage.fromError(line, "Unable to parse line");
    }
    const expression = match[1];
    const taskExpression = new TaskExpression(expression);
    if (!taskExpression.isValid()) {
      return FilterOrErrorMessage.fromError(line, taskExpression.parseError);
    }
    return FilterOrErrorMessage.fromFilter(
      new Filter(line, createFilterFunctionFromLine(taskExpression), new Explanation(line))
    );
  }
  fieldName() {
    return "function";
  }
  filterRegExp() {
    return new RegExp(`^filter by ${this.fieldNameSingularEscaped()} (.*)`, "i");
  }
  supportsSorting() {
    return true;
  }
  sorterRegExp() {
    return new RegExp(`^sort by ${this.fieldNameSingularEscaped()}( reverse)? (.*)`, "i");
  }
  createSorterFromLine(line) {
    const match = Field.getMatch(this.sorterRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const expression = match[2];
    const taskExpression = new TaskExpression(expression);
    if (!taskExpression.isValid()) {
      throw new Error(taskExpression.parseError);
    }
    const comparator = (a, b, searchInfo) => {
      try {
        const queryContext = searchInfo.queryContext();
        const valueA = this.validateTaskSortKey(taskExpression.evaluate(a, queryContext));
        const valueB = this.validateTaskSortKey(taskExpression.evaluate(b, queryContext));
        return this.compareTaskSortKeys(valueA, valueB);
      } catch (exception) {
        if (exception instanceof Error) {
          exception.message += `: while evaluating instruction '${line}'`;
        }
        throw exception;
      }
    };
    return new Sorter(line, this.fieldNameSingular(), comparator, reverse);
  }
  validateTaskSortKey(sortKey) {
    function throwSortKeyTypeError(sortKeyType) {
      throw new Error(`"${sortKeyType}" is not a valid sort key`);
    }
    if (sortKey === void 0) {
      throwSortKeyTypeError("undefined");
    }
    if (Number.isNaN(sortKey)) {
      throwSortKeyTypeError("NaN (Not a Number)");
    }
    if (Array.isArray(sortKey)) {
      throwSortKeyTypeError("array");
    }
    return sortKey;
  }
  compareTaskSortKeys(valueA, valueB) {
    const valueAType = getValueType(valueA);
    const valueBType = getValueType(valueB);
    const resultIfMoment = this.compareTaskSortKeysIfOptionalMoment(valueA, valueB, valueAType, valueBType);
    if (resultIfMoment !== void 0) {
      return resultIfMoment;
    }
    const resultIfNull = this.compareTaskSortKeysIfEitherIsNull(valueA, valueB);
    if (resultIfNull !== void 0) {
      return resultIfNull;
    }
    if (valueAType !== valueBType) {
      throw new Error(`Unable to compare two different sort key types '${valueAType}' and '${valueBType}' order`);
    }
    if (valueAType === "string") {
      return valueA.localeCompare(valueB, void 0, { numeric: true });
    }
    if (valueAType === "TasksDate") {
      return compareByDate(valueA.moment, valueB.moment);
    }
    if (valueAType === "boolean") {
      return Number(valueB) - Number(valueA);
    }
    const result = Number(valueA) - Number(valueB);
    if (isNaN(result)) {
      throw new Error(`Unable to determine sort order for sort key types '${valueAType}' and '${valueBType}'`);
    }
    return result;
  }
  compareTaskSortKeysIfOptionalMoment(valueA, valueB, valueAType, valueBType) {
    const aIsMoment = valueAType === "Moment";
    const bIsMoment = valueBType === "Moment";
    const bothAreMoment = aIsMoment && bIsMoment;
    const aIsMomentBIsNull = aIsMoment && valueB === null;
    const bIsMomentAIsNull = bIsMoment && valueA === null;
    if (bothAreMoment || aIsMomentBIsNull || bIsMomentAIsNull) {
      return compareByDate(valueA, valueB);
    }
    return void 0;
  }
  compareTaskSortKeysIfEitherIsNull(valueA, valueB) {
    if (valueA === null && valueB === null) {
      return 0;
    }
    if (valueA === null && valueB !== null) {
      return -1;
    }
    if (valueA !== null && valueB === null) {
      return 1;
    }
    return void 0;
  }
  supportsGrouping() {
    return true;
  }
  createGrouperFromLine(line) {
    const match = Field.getMatch(this.grouperRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const args = match[2];
    return new Grouper(line, "function", createGrouperFunctionFromLine(args), reverse);
  }
  grouperRegExp() {
    return new RegExp(`^group by ${this.fieldNameSingularEscaped()}( reverse)? (.*)`, "i");
  }
  grouper() {
    throw Error("grouper() function not valid for FunctionField. Use createGrouperFromLine() instead.");
  }
};
function createFilterFunctionFromLine(expression) {
  return (task, searchInfo) => {
    const queryContext = searchInfo.queryContext();
    return filterByFunction(expression, task, queryContext);
  };
}
function filterByFunction(expression, task, queryContext) {
  const result = expression.evaluate(task, queryContext);
  if (typeof result === "boolean") {
    return result;
  }
  throw Error(`filtering function must return true or false. This returned "${result}".`);
}
function createGrouperFunctionFromLine(line) {
  return (task, searchInfo) => {
    const queryContext = searchInfo.queryContext();
    return groupByFunction(task, line, queryContext);
  };
}
function groupByFunction(task, arg, queryContext) {
  try {
    const result = parseAndEvaluateExpression(task, arg, queryContext);
    if (Array.isArray(result)) {
      return result.map((h) => h.toString());
    }
    if (result === null) {
      return [];
    }
    const group = result.toString();
    return [group];
  } catch (e) {
    const errorMessage = `Error: Failed calculating expression "${arg}". The error message was: `;
    if (e instanceof Error) {
      return [errorMessage + e.message];
    } else {
      return [errorMessage + "Unknown error"];
    }
  }
}

// src/Query/Filter/HeadingField.ts
var HeadingField = class extends TextField {
  fieldName() {
    return "heading";
  }
  value(task) {
    if (task.precedingHeader) {
      return task.precedingHeader;
    } else {
      return "";
    }
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.precedingHeader === null || task.precedingHeader.length === 0) {
        return ["(No heading)"];
      }
      return [task.precedingHeader];
    };
  }
};

// src/Query/Filter/PathField.ts
var PathField = class extends TextField {
  fieldName() {
    return "path";
  }
  value(task) {
    return task.path;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(task.path.replace(".md", ""))];
    };
  }
};

// src/Query/Filter/PriorityField.ts
var _PriorityField = class extends Field {
  createFilterOrErrorMessage(line) {
    var _a;
    const priorityMatch = Field.getMatch(this.filterRegExp(), line);
    if (priorityMatch !== null) {
      const filterPriorityString = priorityMatch[5];
      let filterPriority = null;
      switch (filterPriorityString.toLowerCase()) {
        case "lowest":
          filterPriority = "5" /* Lowest */;
          break;
        case "low":
          filterPriority = "4" /* Low */;
          break;
        case "none":
          filterPriority = "3" /* None */;
          break;
        case "medium":
          filterPriority = "2" /* Medium */;
          break;
        case "high":
          filterPriority = "1" /* High */;
          break;
        case "highest":
          filterPriority = "0" /* Highest */;
          break;
      }
      if (filterPriority === null) {
        return FilterOrErrorMessage.fromError(line, "do not understand priority");
      }
      let explanation = line;
      let filter;
      switch ((_a = priorityMatch[3]) == null ? void 0 : _a.toLowerCase()) {
        case "above":
          filter = (task) => task.priority.localeCompare(filterPriority) < 0;
          break;
        case "below":
          filter = (task) => task.priority.localeCompare(filterPriority) > 0;
          break;
        case "not":
          filter = (task) => task.priority !== filterPriority;
          break;
        default:
          filter = (task) => task.priority === filterPriority;
          explanation = `${this.fieldName()} is ${filterPriorityString}`;
      }
      return FilterOrErrorMessage.fromFilter(new Filter(line, filter, new Explanation(explanation)));
    } else {
      return FilterOrErrorMessage.fromError(line, "do not understand query filter (priority)");
    }
  }
  fieldName() {
    return "priority";
  }
  filterRegExp() {
    return _PriorityField.priorityRegexp;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return a.priority.localeCompare(b.priority);
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [task.priorityNameGroupText];
    };
  }
};
var PriorityField = _PriorityField;
PriorityField.priorityRegexp = /^priority(\s+is)?(\s+(above|below|not))?(\s+(lowest|low|none|medium|high|highest))$/i;

// src/Query/Filter/ScheduledDateField.ts
var ScheduledDateField = class extends DateField {
  fieldName() {
    return "scheduled";
  }
  date(task) {
    return task.scheduledDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/StartDateField.ts
var StartDateField = class extends DateField {
  fieldName() {
    return "start";
  }
  fieldNameForFilterInstruction() {
    return "starts";
  }
  date(task) {
    return task.startDate;
  }
  filterResultIfFieldMissing() {
    return true;
  }
};

// src/Query/Filter/HappensDateField.ts
var HappensDateField = class extends DateField {
  constructor() {
    const filterInstructions = new FilterInstructions();
    filterInstructions.add("has happens date", (task) => this.dates(task).some((date) => date !== null));
    filterInstructions.add("no happens date", (task) => !this.dates(task).some((date) => date !== null));
    super(filterInstructions);
  }
  fieldName() {
    return "happens";
  }
  fieldNameForExplanation() {
    return "due, start or scheduled";
  }
  date(task) {
    return this.earliestDate(task);
  }
  dates(task) {
    return task.happensDates;
  }
  earliestDate(task) {
    return task.happens.moment;
  }
  filterResultIfFieldMissing() {
    return false;
  }
  getFilter(dateFilterFunction) {
    return (task) => {
      return this.dates(task).some((date) => dateFilterFunction(date));
    };
  }
};

// src/Query/Filter/RecurringField.ts
var RecurringField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("is recurring", (task) => task.recurrence !== null);
    this._filters.add("is not recurring", (task) => task.recurrence === null);
  }
  fieldName() {
    return "recurring";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      if (a.recurrence !== null && b.recurrence === null) {
        return -1;
      } else if (a.recurrence === null && b.recurrence !== null) {
        return 1;
      } else {
        return 0;
      }
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.recurrence !== null) {
        return ["Recurring"];
      } else {
        return ["Not Recurring"];
      }
    };
  }
};

// src/Query/Filter/StatusField.ts
var StatusField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("done", (task) => task.isDone);
    this._filters.add("not done", (task) => !task.isDone);
  }
  fieldName() {
    return "status";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const oldStatusNameA = StatusField.oldStatusName(a);
      const oldStatusNameB = StatusField.oldStatusName(b);
      if (oldStatusNameA < oldStatusNameB) {
        return 1;
      } else if (oldStatusNameA > oldStatusNameB) {
        return -1;
      } else {
        return 0;
      }
    };
  }
  static oldStatusName(a) {
    if (a.status.symbol === " ") {
      return "Todo";
    } else {
      return "Done";
    }
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [StatusField.oldStatusName(task)];
    };
  }
};

// src/Query/Filter/MultiTextField.ts
var MultiTextField = class extends TextField {
  fieldNamePlural() {
    return this.fieldNameSingular() + "s";
  }
  fieldName() {
    return `${this.fieldNameSingular()}/${this.fieldNamePlural()}`;
  }
  fieldPattern() {
    return `${this.fieldNameSingular()}|${this.fieldNamePlural()}`;
  }
  filterOperatorPattern() {
    return `${super.filterOperatorPattern()}|include|do not include`;
  }
  value(task) {
    return this.values(task).join(", ");
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matchesAnyOf(this.values(task));
      return negate ? !match : match;
    };
  }
  createGrouper(reverse) {
    return new Grouper(this.grouperInstruction(reverse), this.fieldNamePlural(), this.grouper(), reverse);
  }
  grouperRegExp() {
    if (!this.supportsGrouping()) {
      throw Error(`grouperRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^group by ${this.fieldNamePlural()}( reverse)?$`, "i");
  }
  grouperInstruction(reverse) {
    let instruction = `group by ${this.fieldNamePlural()}`;
    if (reverse) {
      instruction += " reverse";
    }
    return instruction;
  }
};

// src/Query/Filter/TagsField.ts
var TagsField = class extends MultiTextField {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add(`has ${this.fieldNameSingular()}`, (task) => this.values(task).length > 0);
    this.filterInstructions.add(`has ${this.fieldNamePlural()}`, (task) => this.values(task).length > 0);
    this.filterInstructions.add(`no ${this.fieldNameSingular()}`, (task) => this.values(task).length === 0);
    this.filterInstructions.add(`no ${this.fieldNamePlural()}`, (task) => this.values(task).length === 0);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.isValid()) {
      return filterResult;
    }
    return super.createFilterOrErrorMessage(line);
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  fieldNameSingular() {
    return "tag";
  }
  values(task) {
    return task.tags;
  }
  supportsSorting() {
    return true;
  }
  createSorterFromLine(line) {
    const match = line.match(this.sorterRegExp());
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const propertyInstance = isNaN(+match[2]) ? 1 : +match[2];
    const comparator = TagsField.makeCompareByTagComparator(propertyInstance);
    return new Sorter(line, this.fieldNameSingular(), comparator, reverse);
  }
  sorterRegExp() {
    return /^sort by tag( reverse)?[\s]*(\d+)?/i;
  }
  comparator() {
    return TagsField.makeCompareByTagComparator(1);
  }
  static makeCompareByTagComparator(propertyInstance) {
    return (a, b) => {
      if (a.tags.length === 0 && b.tags.length === 0) {
        return 0;
      } else if (a.tags.length === 0) {
        return 1;
      } else if (b.tags.length === 0) {
        return -1;
      }
      const tagInstanceToSortBy = propertyInstance - 1;
      if (a.tags.length < propertyInstance && b.tags.length >= propertyInstance) {
        return 1;
      } else if (b.tags.length < propertyInstance && a.tags.length >= propertyInstance) {
        return -1;
      } else if (a.tags.length < propertyInstance && b.tags.length < propertyInstance) {
        return 0;
      }
      const tagA = a.tags[tagInstanceToSortBy];
      const tagB = b.tags[tagInstanceToSortBy];
      return tagA.localeCompare(tagB, void 0, { numeric: true });
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.tags.length == 0) {
        return ["(No tags)"];
      }
      return task.tags;
    };
  }
};

// src/Query/Filter/BooleanField.ts
var import_boon_js = __toESM(require_lib());

// src/Query/Filter/BooleanDelimiters.ts
function anyOfTheseChars(allowedChars) {
  return new RegExp("[" + escapeRegExp(allowedChars) + "]").source;
}
var delimiterPairs = [
  ["(", ")"],
  ["[", "]"],
  ["{", "}"],
  ['"', '"']
];
var BooleanDelimiters = class {
  constructor(openFilterChars, closeFilterChars, openAndCloseFilterChars) {
    this.openFilterChars = openFilterChars;
    this.closeFilterChars = closeFilterChars;
    this.openAndCloseFilterChars = openAndCloseFilterChars;
    this.openFilter = anyOfTheseChars(this.openFilterChars);
    this.closeFilter = anyOfTheseChars(this.closeFilterChars);
  }
  static allSupportedDelimiters() {
    let opening = "";
    let closing = "";
    let openingAndClosing = "";
    for (const [openingDelimiter, closingDelimiter] of delimiterPairs) {
      opening += openingDelimiter;
      closing += closingDelimiter;
      openingAndClosing += BooleanDelimiters.openAndClosing(openingDelimiter, closingDelimiter);
    }
    return new BooleanDelimiters(opening, closing, openingAndClosing);
  }
  static fromInstructionLine(instruction) {
    const trimmedInstruction = instruction.trim();
    const findAnyInitialUnaryOperator = /^[A-Z ]*\s*(.*)/;
    const matches = findAnyInitialUnaryOperator.exec(trimmedInstruction);
    if (matches) {
      const instructionWithoutAnyLeadingOperators = matches[1];
      const firstChar = instructionWithoutAnyLeadingOperators[0];
      const lastChar = instructionWithoutAnyLeadingOperators.slice(-1);
      for (const [openingDelimiter, closingDelimiter] of delimiterPairs) {
        if (firstChar === openingDelimiter && lastChar === closingDelimiter) {
          const openingAndClosingDelimiters = this.openAndClosing(openingDelimiter, closingDelimiter);
          return new BooleanDelimiters(openingDelimiter, closingDelimiter, openingAndClosingDelimiters);
        }
      }
    }
    const message = "All filters in a Boolean instruction must be inside one of these pairs of delimiter characters: " + delimiterPairs.map(([open, close]) => {
      return open + "..." + close;
    }).join(" or ") + ". Combinations of those delimiters are no longer supported.";
    throw new Error(message);
  }
  static openAndClosing(openingDelimiter, closingDelimiter) {
    let openingAndClosingDelimiters = openingDelimiter;
    if (closingDelimiter != openingDelimiter) {
      openingAndClosingDelimiters += closingDelimiter;
    }
    return openingAndClosingDelimiters;
  }
};

// src/Query/Filter/BooleanPreprocessor.ts
var BooleanPreprocessor = class {
  static preprocessExpression(line, delimiters) {
    const parts = BooleanPreprocessor.splitLine(line, delimiters);
    return BooleanPreprocessor.getFiltersAndSimplifiedLine(parts, delimiters);
  }
  static splitLine(line, delimiters) {
    const binaryOperatorsRegex = new RegExp(
      "(" + delimiters.closeFilter + "\\s*(?:AND|OR|AND +NOT|OR +NOT|XOR)\\s*" + delimiters.openFilter + ")"
    );
    const substrings = line.split(binaryOperatorsRegex);
    const unaryOperatorsRegex = new RegExp("(NOT\\s*" + delimiters.openFilter + ")");
    const substringsSplitAtOperatorBoundaries = substrings.flatMap((substring) => substring.split(unaryOperatorsRegex)).filter((substring) => substring !== "");
    const openingDelimitersAndSpacesAtStartRegex = new RegExp(
      "(^" + anyOfTheseChars(delimiters.openFilterChars + " ") + "*)"
    );
    const closingDelimitersAndSpacesAtEndRegex = new RegExp(
      "(" + anyOfTheseChars(delimiters.closeFilterChars + " ") + "*$)"
    );
    return substringsSplitAtOperatorBoundaries.flatMap((substring) => substring.split(openingDelimitersAndSpacesAtStartRegex)).flatMap((substring) => substring.split(closingDelimitersAndSpacesAtEndRegex)).filter((substring) => substring !== "");
  }
  static getFiltersAndSimplifiedLine(parts, delimiters) {
    let simplifiedLine = "";
    let currentIndex = 1;
    const filters = {};
    parts.forEach((part) => {
      if (!BooleanPreprocessor.isAFilter(part, delimiters)) {
        simplifiedLine += `${part}`;
      } else {
        const placeholder = `f${currentIndex}`;
        filters[placeholder] = part;
        simplifiedLine += placeholder;
        currentIndex++;
      }
    });
    const operatorMissingPrecedingSpace = new RegExp(`(${delimiters.closeFilter})([A-Z])`, "g");
    simplifiedLine = simplifiedLine.replace(operatorMissingPrecedingSpace, "$1 $2");
    const operatorMissingFollowingSpace = new RegExp(`([A-Z])(${delimiters.openFilter})`, "g");
    simplifiedLine = simplifiedLine.replace(operatorMissingFollowingSpace, "$1 $2");
    const openChars = delimiters.openFilterChars;
    if (openChars != '"' && openChars != "(") {
      const openDelimiter = new RegExp(anyOfTheseChars(openChars), "g");
      simplifiedLine = simplifiedLine.replace(openDelimiter, "(");
      const closeChars = delimiters.closeFilterChars;
      const closeDelimiter = new RegExp(anyOfTheseChars(closeChars), "g");
      simplifiedLine = simplifiedLine.replace(closeDelimiter, ")");
    }
    return { simplifiedLine, filters };
  }
  static isAFilter(part, delimiters) {
    const onlySpacesAndParentheses = new RegExp(
      "^" + anyOfTheseChars(" " + delimiters.openAndCloseFilterChars) + "+$"
    );
    const binaryOperatorAndParentheses = new RegExp(
      "^ *" + delimiters.closeFilter + " *(AND|OR|XOR) *" + delimiters.openFilter + " *$"
    );
    const unaryOperatorAndParentheses = new RegExp("^(AND|OR|XOR|NOT) *" + delimiters.openFilter + "$");
    const remnantsOfNot = new RegExp("^" + delimiters.closeFilter + " *(AND|OR|XOR)$");
    const justOperators = /^(AND|OR|XOR|NOT)$/;
    return ![
      onlySpacesAndParentheses,
      binaryOperatorAndParentheses,
      unaryOperatorAndParentheses,
      remnantsOfNot,
      justOperators
    ].some((regex) => RegExp(regex).exec(part));
  }
};

// src/Query/Filter/BooleanField.ts
var BooleanField = class extends Field {
  constructor() {
    super();
    this.supportedOperators = ["AND", "OR", "XOR", "NOT"];
    this.subFields = {};
    const delimiters = BooleanDelimiters.allSupportedDelimiters();
    this.basicBooleanRegexp = new RegExp(
      "(.*(AND|OR|XOR|NOT)\\s*" + delimiters.openFilter + ".*|" + delimiters.openFilter + ".+" + delimiters.closeFilter + ")",
      "g"
    );
  }
  filterRegExp() {
    return this.basicBooleanRegexp;
  }
  createFilterOrErrorMessage(line) {
    return this.parseLine(line);
  }
  fieldName() {
    return "boolean query";
  }
  parseLine(line) {
    if (line.length === 0) {
      return FilterOrErrorMessage.fromError(line, "empty line");
    }
    let delimiters;
    try {
      delimiters = BooleanDelimiters.fromInstructionLine(line);
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error type";
      return FilterOrErrorMessage.fromError(line, this.helpMessageFromSimpleError(line, message));
    }
    const parseResult = BooleanPreprocessor.preprocessExpression(line, delimiters);
    const simplifiedLine = parseResult.simplifiedLine;
    const filters = parseResult.filters;
    try {
      const postfixExpression = (0, import_boon_js.parse)(simplifiedLine);
      for (const token of postfixExpression) {
        if (token.name === "IDENTIFIER" && token.value) {
          const placeholder = token.value.trim();
          const filter = filters[placeholder];
          token.value = filter;
          if (!(filter in this.subFields)) {
            const parsedField = parseFilter(filter);
            if (parsedField === null) {
              return this.helpMessage(line, `couldn't parse sub-expression '${filter}'`, parseResult);
            }
            if (parsedField.error) {
              return this.helpMessage(
                line,
                `couldn't parse sub-expression '${filter}': ${parsedField.error}`,
                parseResult
              );
            } else if (parsedField.filter) {
              this.subFields[filter] = parsedField.filter;
            }
          }
        } else if (token.name === "OPERATOR") {
          if (token.value == void 0) {
            return this.helpMessage(line, "empty operator in boolean query", parseResult);
          }
          if (!this.supportedOperators.includes(token.value)) {
            return this.helpMessage(line, `unknown boolean operator '${token.value}'`, parseResult);
          }
        }
      }
      const filterFunction = (task, searchInfo) => {
        return this.filterTaskWithParsedQuery(task, postfixExpression, searchInfo);
      };
      const explanation = this.constructExplanation(postfixExpression);
      return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, explanation));
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error type";
      return this.helpMessage(
        line,
        `malformed boolean query -- ${message} (check the documentation for guidelines)`,
        parseResult
      );
    }
  }
  filterTaskWithParsedQuery(task, postfixExpression, searchInfo) {
    const toBool = (s) => {
      return s === "true";
    };
    const toString = (b) => {
      return b ? "true" : "false";
    };
    const booleanStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        const result = filter.filterFunction(task, searchInfo);
        booleanStack.push(toString(result));
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = toBool(booleanStack.pop());
          booleanStack.push(toString(!arg1));
        } else if (token.value === "OR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 || arg2));
        } else if (token.value === "AND") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && arg2));
        } else if (token.value === "XOR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && !arg2 || !arg1 && arg2));
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token);
      }
    }
    return toBool(booleanStack[0]);
  }
  constructExplanation(postfixExpression) {
    const explanationStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        this.explainExpression(token, explanationStack);
      } else if (token.name === "OPERATOR") {
        this.explainOperator(token, explanationStack);
      } else {
        throw Error("Unsupported token type: " + token.name);
      }
    }
    return explanationStack[0];
  }
  explainExpression(token, explanationStack) {
    if (token.value == null) {
      throw Error("null token value");
    }
    const filter = this.subFields[token.value.trim()];
    const explanation = this.simulateExplainFilter(filter);
    explanationStack.push(explanation);
  }
  simulateExplainFilter(filter) {
    return filter.simulateExplainFilter();
  }
  explainOperator(token, explanationStack) {
    if (token.value === "NOT") {
      const arg1 = explanationStack.pop();
      explanationStack.push(Explanation.booleanNot([arg1]));
    } else if (token.value === "OR") {
      const arg2 = explanationStack.pop();
      const arg1 = explanationStack.pop();
      explanationStack.push(Explanation.booleanOr([arg1, arg2]));
    } else if (token.value === "AND") {
      const arg2 = explanationStack.pop();
      const arg1 = explanationStack.pop();
      explanationStack.push(Explanation.booleanAnd([arg1, arg2]));
    } else if (token.value === "XOR") {
      const arg2 = explanationStack.pop();
      const arg1 = explanationStack.pop();
      explanationStack.push(Explanation.booleanXor([arg1, arg2]));
    } else {
      throw Error("Unsupported operator: " + token.value);
    }
  }
  helpMessage(line, errorMessage, parseResult) {
    const filters = parseResult.filters;
    const expressions = this.stringifySubExpressionsForErrorMessage(filters);
    const simpleMessage = this.helpMessageFromSimpleError(line, errorMessage);
    const fullMessage = `${simpleMessage}

The instruction was converted to the following simplified line:
    ${parseResult.simplifiedLine}

Where the sub-expressions in the simplified line are:
${expressions}

For help, see:
    https://publish.obsidian.md/tasks/Queries/Combining+Filters
`;
    return FilterOrErrorMessage.fromError(line, fullMessage);
  }
  stringifySubExpressionsForErrorMessage(filters) {
    return Object.entries(filters).map(([placeholder, line]) => {
      return `    '${placeholder}': '${line}'
        => ${this.stringifySubExpressionStatus(line)}`;
    }).join("\n");
  }
  stringifySubExpressionStatus(line) {
    const parsedField = parseFilter(line);
    if (!parsedField) {
      return "ERROR:\n           do not understand query";
    }
    if (parsedField.error) {
      const formattedFilterStatus = parsedField.error.split("\n").map((line2) => line2.trim()).join("\n           ");
      return `ERROR:
           ${formattedFilterStatus}`;
    }
    return "OK";
  }
  helpMessageFromSimpleError(line, errorMessage) {
    return `Could not interpret the following instruction as a Boolean combination:
    ${line}

The error message is:
    ${errorMessage}`;
  }
};

// src/Query/Filter/FilenameField.ts
var FilenameField = class extends TextField {
  fieldName() {
    return "filename";
  }
  value(task) {
    const filename = task.filename;
    if (filename === null) {
      return "";
    }
    return filename + ".md";
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const filename = task.filename;
      if (filename === null) {
        return ["Unknown Location"];
      }
      return ["[[" + filename + "]]"];
    };
  }
};

// src/Query/Filter/UrgencyField.ts
var UrgencyField = class extends Field {
  canCreateFilterForLine(_line) {
    return false;
  }
  createFilterOrErrorMessage(line) {
    return FilterOrErrorMessage.fromError(line, "Filtering by urgency is not yet supported");
  }
  fieldName() {
    return "urgency";
  }
  filterRegExp() {
    throw Error(`filterRegExp() unimplemented for ${this.fieldName()}`);
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return b.urgency - a.urgency;
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [`${task.urgency.toFixed(2)}`];
    };
  }
  createGrouper(reverse) {
    return super.createGrouper(!reverse);
  }
  grouperInstruction(reverse) {
    return super.grouperInstruction(!reverse);
  }
};

// src/Query/Filter/StatusNameField.ts
var StatusNameField = class extends TextField {
  constructor() {
    super();
  }
  fieldName() {
    return "status.name";
  }
  value(task) {
    return task.status.name;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
};

// src/Query/Filter/StatusTypeField.ts
var StatusTypeField = class extends Field {
  canCreateFilterForLine(line) {
    const relaxedRegExp = new RegExp(`^(?:${this.fieldNameSingularEscaped()})`, "i");
    return Field.lineMatchesFilter(relaxedRegExp, line);
  }
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return this.helpMessage(line);
    }
    const filterOperator = match[1].toLowerCase();
    const statusTypeAsString = match[2];
    const statusTypeElement = StatusType[statusTypeAsString.toUpperCase()];
    if (!statusTypeElement) {
      return this.helpMessage(line);
    }
    let filterFunction;
    switch (filterOperator) {
      case "is":
        filterFunction = (task) => {
          return task.status.type === statusTypeElement;
        };
        break;
      case "is not":
        filterFunction = (task) => {
          return task.status.type !== statusTypeElement;
        };
        break;
      default:
        return this.helpMessage(line);
    }
    return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, new Explanation(line)));
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldNameSingularEscaped()}) (is|is not) ([^ ]+)$`, "i");
  }
  helpMessage(line) {
    const allowedTypes = Object.values(StatusType).filter((t) => t !== "EMPTY" /* EMPTY */).join(" ");
    const message = `Invalid ${this.fieldNameSingular()} instruction: '${line}'.
    Allowed options: 'is' and 'is not' (without quotes).
    Allowed values:  ${allowedTypes}
                     Note: values are case-insensitive,
                           so 'in_progress' works too, for example.
    Example:         ${this.fieldNameSingular()} is not NON_TASK`;
    return FilterOrErrorMessage.fromError(line, message);
  }
  fieldName() {
    return "status.type";
  }
  value(task) {
    return task.status.type;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const keyA = StatusTypeField.groupName(a);
      const keyB = StatusTypeField.groupName(b);
      return keyA.localeCompare(keyB, void 0, { numeric: true });
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [StatusTypeField.groupName(task)];
    };
  }
  static groupName(task) {
    return task.status.typeGroupText;
  }
};

// src/Query/Filter/RecurrenceField.ts
var RecurrenceField = class extends TextField {
  fieldName() {
    return "recurrence";
  }
  value(task) {
    if (task.recurrence !== null) {
      return task.recurrence.toText();
    } else {
      return "";
    }
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.recurrence !== null) {
        return [task.recurrence.toText()];
      } else {
        return ["None"];
      }
    };
  }
};

// src/Query/Filter/FolderField.ts
var FolderField = class extends TextField {
  fieldName() {
    return "folder";
  }
  value(task) {
    return task.file.folder;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(this.value(task))];
    };
  }
};

// src/Query/Filter/RootField.ts
var RootField = class extends TextField {
  fieldName() {
    return "root";
  }
  value(task) {
    return task.file.root;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(this.value(task))];
    };
  }
};

// src/Query/Filter/BacklinkField.ts
var BacklinkField = class extends TextField {
  fieldName() {
    return "backlink";
  }
  value(task) {
    const linkText = task.getLinkText({ isFilenameUnique: true });
    if (linkText === null) {
      return "Unknown Location";
    }
    return linkText;
  }
  createFilterOrErrorMessage(line) {
    return FilterOrErrorMessage.fromError(line, "backlink field does not support filtering");
  }
  canCreateFilterForLine(_line) {
    return false;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const filename = task.filename;
      if (filename === null) {
        return ["Unknown Location"];
      }
      const header = task.precedingHeader;
      if (header === null) {
        return ["[[" + filename + "]]"];
      }
      return [`[[${filename}#${header}|${filename} > ${header}]]`];
    };
  }
};

// src/Query/Filter/CancelledDateField.ts
var CancelledDateField = class extends DateField {
  fieldName() {
    return "cancelled";
  }
  date(task) {
    return task.cancelledDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/BlockingField.ts
var BlockingField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("is blocking", (task, searchInfo) => {
      return task.isBlocking(searchInfo.allTasks);
    });
    this._filters.add("is not blocking", (task, searchInfo) => {
      return !task.isBlocking(searchInfo.allTasks);
    });
    this._filters.add("is blocked", (task, searchInfo) => {
      return task.isBlocked(searchInfo.allTasks);
    });
    this._filters.add("is not blocked", (task, searchInfo) => {
      return !task.isBlocked(searchInfo.allTasks);
    });
  }
  fieldName() {
    return "blocking";
  }
};

// src/Query/Filter/IdField.ts
var IdField = class extends TextField {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add("has id", (task) => task.id.length > 0);
    this.filterInstructions.add("no id", (task) => task.id.length === 0);
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.isValid()) {
      return filterResult;
    }
    return super.createFilterOrErrorMessage(line);
  }
  fieldName() {
    return "id";
  }
  value(task) {
    return task.id;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
};

// src/Query/Filter/DependsOnField.ts
var DependsOnField = class extends Field {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add("has depends on", (task) => task.dependsOn.length > 0);
    this.filterInstructions.add("no depends on", (task) => task.dependsOn.length === 0);
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.isValid()) {
      return filterResult;
    }
    return FilterOrErrorMessage.fromError(line, "Unknown instruction");
  }
  fieldName() {
    return "blocked by";
  }
  filterRegExp() {
    return null;
  }
};

// src/Query/FilterParser.ts
var fieldCreators = [
  () => new StatusNameField(),
  () => new StatusTypeField(),
  () => new StatusField(),
  () => new RecurringField(),
  () => new PriorityField(),
  () => new HappensDateField(),
  () => new CancelledDateField(),
  () => new CreatedDateField(),
  () => new StartDateField(),
  () => new ScheduledDateField(),
  () => new DueDateField(),
  () => new ReminderDateField(),
  () => new DoneDateField(),
  () => new PathField(),
  () => new FolderField(),
  () => new RootField(),
  () => new BacklinkField(),
  () => new DescriptionField(),
  () => new TagsField(),
  () => new HeadingField(),
  () => new ExcludeSubItemsField(),
  () => new FilenameField(),
  () => new UrgencyField(),
  () => new RecurrenceField(),
  () => new FunctionField(),
  () => new IdField(),
  () => new DependsOnField(),
  () => new BlockingField(),
  () => new BooleanField()
];
function parseFilter(filterString) {
  for (const creator of fieldCreators) {
    const field = creator();
    if (field.canCreateFilterForLine(filterString))
      return field.createFilterOrErrorMessage(filterString);
  }
  return null;
}
function parseSorter(sorterString) {
  const sortByRegexp = /^sort by /i;
  if (sorterString.match(sortByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const sorter = field.createSorterFromLine(sorterString);
    if (sorter) {
      return sorter;
    }
  }
  return null;
}
function parseGrouper(line) {
  const groupByRegexp = /^group by /i;
  if (line.match(groupByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const grouper = field.createGrouperFromLine(line);
    if (grouper) {
      return grouper;
    }
  }
  return null;
}

// src/Query/Group/GroupDisplayHeading.ts
var GroupDisplayHeading = class {
  constructor(nestingLevel, displayName, property) {
    this.nestingLevel = nestingLevel;
    this.displayName = displayName;
    this.property = property;
  }
};

// src/Query/Group/GroupDisplayHeadingSelector.ts
var GroupDisplayHeadingSelector = class {
  constructor(taskGroupingTreeStorage, groupers) {
    this.lastHeadingAtLevel = new Array();
    this.groupers = groupers;
    const firstGroup = taskGroupingTreeStorage.keys().next().value;
    const groupCount = firstGroup.length;
    for (let i = 0; i < groupCount; i++) {
      this.lastHeadingAtLevel.push("");
    }
  }
  getHeadingsForTaskGroup(groupNames) {
    const headingsForGroup = new Array();
    for (let level = 0; level < groupNames.length; level++) {
      const group = groupNames[level];
      if (group != this.lastHeadingAtLevel[level]) {
        headingsForGroup.push(new GroupDisplayHeading(level, group, this.groupers[level].property));
        for (let j = level; j < groupNames.length; j++) {
          this.lastHeadingAtLevel[j] = "";
        }
        this.lastHeadingAtLevel[level] = group;
      }
    }
    return headingsForGroup;
  }
};

// src/Query/Group/GroupingTreeNode.ts
var GroupingTreeNode = class {
  constructor(values) {
    this.children = /* @__PURE__ */ new Map();
    this.values = [];
    this.values = values;
  }
  generateAllPaths(pathSoFar = []) {
    const resultMap = /* @__PURE__ */ new Map();
    if (this.children.size == 0) {
      resultMap.set([...pathSoFar], this.values);
      return resultMap;
    }
    for (const [property, child] of this.children) {
      pathSoFar.push(property);
      const childResult = child.generateAllPaths(pathSoFar);
      childResult.forEach((value, key) => resultMap.set(key, value));
      pathSoFar.pop();
    }
    return resultMap;
  }
};

// src/Query/Group/TaskGroupingTree.ts
var TaskGroupingTreeNode = class extends GroupingTreeNode {
};
var TaskGroupingTree = class {
  constructor(groupers, tasks, searchInfo) {
    this.root = new TaskGroupingTreeNode(tasks);
    this.buildGroupingTree(groupers, searchInfo);
  }
  buildGroupingTree(groupers, searchInfo) {
    let currentTreeLevel = [this.root];
    for (const grouper of groupers) {
      const nextTreeLevel = [];
      for (const currentTreeNode of currentTreeLevel) {
        for (const task of currentTreeNode.values) {
          const groupNames = grouper.grouper(task, searchInfo);
          if (groupNames.length === 0) {
            groupNames.push("");
          }
          for (const groupName of groupNames) {
            let child = currentTreeNode.children.get(groupName);
            if (child === void 0) {
              child = new TaskGroupingTreeNode([]);
              currentTreeNode.children.set(groupName, child);
              nextTreeLevel.push(child);
            }
            child.values.push(task);
          }
        }
      }
      currentTreeLevel = nextTreeLevel;
    }
  }
  generateTaskTreeStorage() {
    return this.root.generateAllPaths();
  }
};

// src/Query/Group/TaskGroup.ts
var TaskGroup = class {
  constructor(groups, tasks) {
    this.groups = groups;
    this.groupHeadings = [];
    this.tasks = tasks;
  }
  setGroupHeadings(headingsForTaskGroup) {
    for (const groupDisplayHeading of headingsForTaskGroup) {
      this.groupHeadings.push(groupDisplayHeading);
    }
  }
  applyTaskLimit(limit) {
    this.tasks = this.tasks.slice(0, limit);
  }
  tasksAsStringOfLines() {
    let output = "";
    for (const task of this.tasks) {
      output += task.toFileLineString() + "\n";
    }
    return output;
  }
  toString() {
    let output = "\n";
    output += `Group names: [${this.groups}]
`;
    for (const heading of this.groupHeadings) {
      const headingPrefix = "#".repeat(4 + heading.nestingLevel);
      output += `${headingPrefix} [${heading.property}] ${heading.displayName}
`;
    }
    output += this.tasksAsStringOfLines();
    return output;
  }
};

// src/Query/Group/TaskGroups.ts
var TaskGroups = class {
  constructor(groups, tasks, searchInfo) {
    this._groups = new Array();
    this._totalTaskCount = 0;
    this._totalTaskCount = tasks.length;
    this._groupers = groups;
    const taskGroupingTree = new TaskGroupingTree(groups, tasks, searchInfo);
    const groupingTreeStorage = taskGroupingTree.generateTaskTreeStorage();
    this.addTaskGroups(groupingTreeStorage);
    this.sortTaskGroups();
    this.setGroupsHeadings(groupingTreeStorage);
  }
  get groupers() {
    return this._groupers;
  }
  get groups() {
    return this._groups;
  }
  totalTasksCount() {
    return this._totalTaskCount;
  }
  toString() {
    let output = "";
    output += "Groupers (if any):\n";
    for (const grouper of this._groupers) {
      const reverseText = grouper.reverse ? " reverse" : "";
      output += `- ${grouper.property}${reverseText}
`;
    }
    for (const taskGroup of this.groups) {
      output += taskGroup.toString();
      output += "\n---\n";
    }
    const totalTasksCount = this.totalTasksCount();
    output += `
${totalTasksCount} tasks
`;
    return output;
  }
  addTaskGroups(groupingTreeStorage) {
    for (const [groups, tasks] of groupingTreeStorage) {
      const taskGroup = new TaskGroup(groups, tasks);
      this.addTaskGroup(taskGroup);
    }
  }
  addTaskGroup(taskGroup) {
    this._groups.push(taskGroup);
  }
  sortTaskGroups() {
    const compareFn = (group1, group2) => {
      const groupNames1 = group1.groups;
      const groupNames2 = group2.groups;
      for (let i = 0; i < groupNames1.length; i++) {
        const grouper = this._groupers[i];
        const result = groupNames1[i].localeCompare(groupNames2[i], void 0, { numeric: true });
        if (result !== 0) {
          return grouper.reverse ? -result : result;
        }
      }
      return 0;
    };
    this._groups.sort(compareFn);
  }
  setGroupsHeadings(groupingTreeStorage) {
    const displayHeadingSelector = new GroupDisplayHeadingSelector(groupingTreeStorage, this._groupers);
    for (const group of this._groups) {
      group.setGroupHeadings(displayHeadingSelector.getHeadingsForTaskGroup(group.groups));
    }
  }
  applyTaskLimit(limit) {
    if (this._groupers.length === 0) {
      return;
    }
    this._groups.forEach((group) => {
      group.applyTaskLimit(limit);
    });
    this.recalculateTotalTaskCount();
  }
  recalculateTotalTaskCount() {
    let concatenatedTasks = [];
    this._groups.forEach((group) => {
      concatenatedTasks = [...concatenatedTasks, ...group.tasks];
    });
    const uniqueTasks = [...new Set(concatenatedTasks)];
    this._totalTaskCount = uniqueTasks.length;
  }
};

// src/Query/SearchInfo.ts
var SearchInfo = class {
  constructor(queryPath, allTasks) {
    this.queryPath = queryPath;
    this.allTasks = [...allTasks];
  }
  static fromAllTasks(tasks) {
    return new SearchInfo(void 0, tasks);
  }
  queryContext() {
    return this.queryPath ? makeQueryContextWithTasks(this.queryPath, this.allTasks) : void 0;
  }
};

// src/Query/QueryResult.ts
function taskCountPluralised(tasksCount) {
  return `task${tasksCount !== 1 ? "s" : ""}`;
}
var QueryResult = class {
  constructor(groups, totalTasksCountBeforeLimit) {
    this.totalTasksCountBeforeLimit = 0;
    this._searchErrorMessage = void 0;
    this.taskGroups = groups;
    this.totalTasksCountBeforeLimit = totalTasksCountBeforeLimit;
  }
  get searchErrorMessage() {
    return this._searchErrorMessage;
  }
  set searchErrorMessage(value) {
    this._searchErrorMessage = value;
  }
  get totalTasksCount() {
    return this.taskGroups.totalTasksCount();
  }
  totalTasksCountDisplayText() {
    const tasksCount = this.totalTasksCount;
    const tasksCountBeforeLimit = this.totalTasksCountBeforeLimit;
    if (tasksCount === tasksCountBeforeLimit) {
      return `${tasksCount} ${taskCountPluralised(tasksCount)}`;
    } else {
      return `${tasksCount} of ${tasksCountBeforeLimit} ${taskCountPluralised(tasksCountBeforeLimit)}`;
    }
  }
  get groups() {
    return this.taskGroups.groups;
  }
  static fromError(message) {
    const result = new QueryResult(new TaskGroups([], [], SearchInfo.fromAllTasks([])), 0);
    result._searchErrorMessage = message;
    return result;
  }
};

// src/Query/Scanner.ts
function endsWith1Slash(inputLine) {
  return inputLine.endsWith("\\");
}
function endsWith2Slashes(inputLine) {
  return inputLine.endsWith("\\\\");
}
function stripLeadingWhitespace(adjustedInputLine) {
  return adjustedInputLine.replace(/^[ \t]*/, "");
}
function stripEndingSlashAndPrecedingWhitespace(adjustedInputLine) {
  return adjustedInputLine.replace(/[ \t]*\\$/, "");
}
function adjustLine(inputLine, continuePreviousLine) {
  let adjustedLine = inputLine;
  if (continuePreviousLine) {
    adjustedLine = stripLeadingWhitespace(inputLine);
  }
  if (endsWith2Slashes(adjustedLine)) {
    adjustedLine = adjustedLine.slice(0, -1);
  } else if (endsWith1Slash(inputLine)) {
    adjustedLine = stripEndingSlashAndPrecedingWhitespace(adjustedLine);
  }
  return adjustedLine;
}
function continueLines(input) {
  const instructions = [];
  let continuePreviousLine = false;
  let currentStatementRaw = "";
  let currentStatementProcessed = "";
  for (const inputLine of input.split("\n")) {
    const adjustedLine = adjustLine(inputLine, continuePreviousLine);
    if (continuePreviousLine) {
      currentStatementRaw += "\n" + inputLine;
      currentStatementProcessed += " " + adjustedLine;
    } else {
      currentStatementRaw = inputLine;
      currentStatementProcessed = adjustedLine;
    }
    if (endsWith2Slashes(inputLine)) {
      continuePreviousLine = false;
    } else {
      continuePreviousLine = endsWith1Slash(inputLine);
    }
    if (!continuePreviousLine) {
      if (currentStatementProcessed.trim() !== "") {
        instructions.push(new Statement(currentStatementRaw, currentStatementProcessed));
      }
      currentStatementRaw = "";
      currentStatementProcessed = "";
    }
  }
  return instructions;
}

// src/Query/Sort/Sort.ts
var Sort = class {
  static by(sorters, tasks, searchInfo) {
    const defaultComparators = this.defaultSorters().map((sorter) => sorter.comparator);
    const userComparators = [];
    for (const sorter of sorters) {
      userComparators.push(sorter.comparator);
    }
    return tasks.sort(Sort.makeCompositeComparator([...userComparators, ...defaultComparators], searchInfo));
  }
  static defaultSorters() {
    return [
      new StatusTypeField().createNormalSorter(),
      new UrgencyField().createNormalSorter(),
      new DueDateField().createNormalSorter(),
      new ReminderDateField().createNormalSorter(),
      new PriorityField().createNormalSorter(),
      new PathField().createNormalSorter()
    ];
  }
  static makeCompositeComparator(comparators, searchInfo) {
    return (a, b) => {
      for (const comparator of comparators) {
        const result = comparator(a, b, searchInfo);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    };
  }
};

// src/Query/Query.ts
var Query = class {
  constructor(source, path = void 0) {
    this._limit = void 0;
    this._taskGroupLimit = void 0;
    this._taskLayoutOptions = new TaskLayoutOptions();
    this._queryLayoutOptions = new QueryLayoutOptions();
    this._filters = [];
    this._error = void 0;
    this._sorting = [];
    this._grouping = [];
    this._ignoreGlobalQuery = false;
    this.hideOptionsRegexp = /^(hide|show) (task count|backlink|priority|cancelled date|created date|start date|scheduled date|done date|due date|reminder date|recurrence rule|edit button|postpone button|urgency|tags|depends on|id)/i;
    this.shortModeRegexp = /^short/i;
    this.fullModeRegexp = /^full/i;
    this.explainQueryRegexp = /^explain/i;
    this.ignoreGlobalQueryRegexp = /^ignore global query/i;
    this.logger = logging.getLogger("tasks.Query");
    this._queryId = "";
    this.limitRegexp = /^limit (groups )?(to )?(\d+)( tasks?)?/i;
    this.commentRegexp = /^#.*/;
    this._queryId = this.generateQueryId(10);
    this.source = source;
    this.filePath = path;
    this.debug(`Creating query: ${this.formatQueryForLogging()}`);
    continueLines(source).forEach((statement) => {
      const line = this.expandPlaceholders(statement, path);
      if (this.error !== void 0) {
        return;
      }
      try {
        this.parseLine(line, statement);
      } catch (e) {
        let message;
        if (e instanceof Error) {
          message = e.message;
        } else {
          message = "Unknown error";
        }
        this.setError(message, statement);
        return;
      }
    });
  }
  get queryId() {
    return this._queryId;
  }
  parseLine(line, statement) {
    switch (true) {
      case this.shortModeRegexp.test(line):
        this._queryLayoutOptions.shortMode = true;
        break;
      case this.fullModeRegexp.test(line):
        this._queryLayoutOptions.shortMode = false;
        break;
      case this.explainQueryRegexp.test(line):
        this._queryLayoutOptions.explainQuery = true;
        break;
      case this.ignoreGlobalQueryRegexp.test(line):
        this._ignoreGlobalQuery = true;
        break;
      case this.limitRegexp.test(line):
        this.parseLimit(line);
        break;
      case this.parseSortBy(line):
        break;
      case this.parseGroupBy(line):
        break;
      case this.hideOptionsRegexp.test(line):
        this.parseHideOptions(line);
        break;
      case this.commentRegexp.test(line):
        break;
      case this.parseFilter(line, statement):
        break;
      default:
        this.setError("do not understand query", statement);
    }
  }
  formatQueryForLogging() {
    return `[${this.source.split("\n").join(" ; ")}]`;
  }
  expandPlaceholders(statement, path) {
    const source = statement.anyContinuationLinesRemoved;
    if (source.includes("{{") && source.includes("}}")) {
      if (this.filePath === void 0) {
        this._error = `The query looks like it contains a placeholder, with "{{" and "}}"
but no file path has been supplied, so cannot expand placeholder values.
The query is:
${source}`;
        return source;
      }
    }
    let expandedSource = source;
    if (path) {
      const queryContext = makeQueryContext(path);
      try {
        expandedSource = expandPlaceholders(source, queryContext);
      } catch (error) {
        if (error instanceof Error) {
          this._error = error.message;
        } else {
          this._error = "Internal error. expandPlaceholders() threw something other than Error.";
        }
        return source;
      }
    }
    statement.recordExpandedPlaceholders(expandedSource);
    return expandedSource;
  }
  append(q2) {
    if (this.source === "")
      return q2;
    if (q2.source === "")
      return this;
    return new Query(`${this.source}
${q2.source}`, this.filePath);
  }
  explainQuery() {
    const explainer = new Explainer();
    return explainer.explainQuery(this);
  }
  get limit() {
    return this._limit;
  }
  get taskGroupLimit() {
    return this._taskGroupLimit;
  }
  get taskLayoutOptions() {
    return this._taskLayoutOptions;
  }
  get queryLayoutOptions() {
    return this._queryLayoutOptions;
  }
  get filters() {
    return this._filters;
  }
  addFilter(filter) {
    this._filters.push(filter);
  }
  get sorting() {
    return this._sorting;
  }
  get grouping() {
    return this._grouping;
  }
  get error() {
    return this._error;
  }
  setError(message, statement) {
    if (statement.allLinesIdentical()) {
      this._error = `${message}
Problem line: "${statement.rawInstruction}"`;
    } else {
      this._error = `${message}
Problem statement:
${statement.explainStatement("    ")}
`;
    }
  }
  get ignoreGlobalQuery() {
    return this._ignoreGlobalQuery;
  }
  applyQueryToTasks(tasks) {
    this.debug(`Executing query: ${this.formatQueryForLogging()}`);
    const searchInfo = new SearchInfo(this.filePath, tasks);
    try {
      this.filters.forEach((filter) => {
        tasks = tasks.filter((task) => filter.filterFunction(task, searchInfo));
      });
      const { debugSettings } = getSettings();
      const tasksSorted = debugSettings.ignoreSortInstructions ? tasks : Sort.by(this.sorting, tasks, searchInfo);
      const tasksSortedLimited = tasksSorted.slice(0, this.limit);
      const taskGroups = new TaskGroups(this.grouping, tasksSortedLimited, searchInfo);
      if (this._taskGroupLimit !== void 0) {
        taskGroups.applyTaskLimit(this._taskGroupLimit);
      }
      return new QueryResult(taskGroups, tasksSorted.length);
    } catch (e) {
      const description = "Search failed";
      return QueryResult.fromError(errorMessageForException(description, e));
    }
  }
  parseHideOptions(line) {
    const hideOptionsMatch = line.match(this.hideOptionsRegexp);
    if (hideOptionsMatch !== null) {
      const hide2 = hideOptionsMatch[1].toLowerCase() === "hide";
      const option = hideOptionsMatch[2].toLowerCase();
      switch (option) {
        case "task count":
          this._queryLayoutOptions.hideTaskCount = hide2;
          break;
        case "backlink":
          this._queryLayoutOptions.hideBacklinks = hide2;
          break;
        case "postpone button":
          this._queryLayoutOptions.hidePostponeButton = hide2;
          break;
        case "priority":
          this._taskLayoutOptions.setVisibility("priority" /* Priority */, !hide2);
          break;
        case "cancelled date":
          this._taskLayoutOptions.setVisibility("cancelledDate" /* CancelledDate */, !hide2);
          break;
        case "created date":
          this._taskLayoutOptions.setVisibility("createdDate" /* CreatedDate */, !hide2);
          break;
        case "start date":
          this._taskLayoutOptions.setVisibility("startDate" /* StartDate */, !hide2);
          break;
        case "scheduled date":
          this._taskLayoutOptions.setVisibility("scheduledDate" /* ScheduledDate */, !hide2);
          break;
        case "due date":
          this._taskLayoutOptions.setVisibility("dueDate" /* DueDate */, !hide2);
          break;
        case "reminder date":
          this._taskLayoutOptions.setVisibility("reminderDate" /* ReminderDate */, !hide2);
          break;
        case "done date":
          this._taskLayoutOptions.setVisibility("doneDate" /* DoneDate */, !hide2);
          break;
        case "recurrence rule":
          this._taskLayoutOptions.setVisibility("recurrenceRule" /* RecurrenceRule */, !hide2);
          break;
        case "edit button":
          this._queryLayoutOptions.hideEditButton = hide2;
          break;
        case "urgency":
          this._queryLayoutOptions.hideUrgency = hide2;
          break;
        case "tags":
          this._taskLayoutOptions.setTagsVisibility(!hide2);
          break;
        case "id":
          this._taskLayoutOptions.setVisibility("id" /* Id */, !hide2);
          break;
        case "depends on":
          this._taskLayoutOptions.setVisibility("dependsOn" /* DependsOn */, !hide2);
          break;
        default:
          this.setError("do not understand hide/show option", new Statement(line, line));
      }
    }
  }
  parseFilter(line, statement) {
    var _a;
    const filterOrError = parseFilter(line);
    if (filterOrError != null) {
      if (filterOrError.filter) {
        filterOrError.filter.setStatement(statement);
        this._filters.push(filterOrError.filter);
      } else {
        this.setError((_a = filterOrError.error) != null ? _a : "Unknown error", statement);
      }
      return true;
    }
    return false;
  }
  parseLimit(line) {
    const limitMatch = line.match(this.limitRegexp);
    if (limitMatch === null) {
      this.setError("do not understand query limit", new Statement(line, line));
      return;
    }
    const limitFromLine = Number.parseInt(limitMatch[3], 10);
    if (limitMatch[1] !== void 0) {
      this._taskGroupLimit = limitFromLine;
    } else {
      this._limit = limitFromLine;
    }
  }
  parseSortBy(line) {
    const sortingMaybe = parseSorter(line);
    if (sortingMaybe) {
      this._sorting.push(sortingMaybe);
      return true;
    }
    return false;
  }
  parseGroupBy(line) {
    const groupingMaybe = parseGrouper(line);
    if (groupingMaybe) {
      this._grouping.push(groupingMaybe);
      return true;
    }
    return false;
  }
  generateQueryId(length) {
    const chars = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890";
    const randomArray = Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]);
    const randomString = randomArray.join("");
    return randomString;
  }
  debug(message, objects) {
    this.logger.debugWithId(this._queryId, `"${this.filePath}": ${message}`, objects);
  }
};

// src/Config/GlobalQuery.ts
var _GlobalQuery = class {
  constructor(source = _GlobalQuery.empty) {
    this._source = source;
  }
  static getInstance() {
    if (!_GlobalQuery.instance) {
      _GlobalQuery.instance = new _GlobalQuery();
    }
    return _GlobalQuery.instance;
  }
  set(source) {
    this._source = source;
  }
  query(path = void 0) {
    return new Query(this._source, path);
  }
  hasInstructions() {
    return this._source.trim() !== _GlobalQuery.empty;
  }
};
var GlobalQuery = _GlobalQuery;
GlobalQuery.empty = "";

// src/Obsidian/TasksEvents.ts
var TasksEvents = class {
  constructor({ obsidianEvents }) {
    this.logger = logging.getLogger("tasks.Events");
    this.obsidianEvents = obsidianEvents;
  }
  onCacheUpdate(handler) {
    this.logger.debug("TasksEvents.onCacheUpdate()");
    return this.obsidianEvents.on("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, handler);
  }
  triggerCacheUpdate(cacheData) {
    this.logger.debug("TasksEvents.triggerCacheUpdate()");
    this.obsidianEvents.trigger("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, cacheData);
  }
  onRequestCacheUpdate(handler) {
    this.logger.debug("TasksEvents.onRequestCacheUpdate()");
    return this.obsidianEvents.on("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, handler);
  }
  triggerRequestCacheUpdate(fn) {
    this.logger.debug("TasksEvents.triggerRequestCacheUpdate()");
    this.obsidianEvents.trigger("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, fn);
  }
  off(eventRef) {
    this.logger.debug("TasksEvents.off()");
    this.obsidianEvents.offref(eventRef);
  }
};

// src/Obsidian/InlineRenderer.ts
var import_obsidian11 = require("obsidian");

// src/Renderer/TaskLineRenderer.ts
var import_obsidian10 = require("obsidian");

// src/ui/EditInstructions/StatusInstructions.ts
var SetStatus = class {
  constructor(status) {
    this.newStatus = status;
  }
  apply(task) {
    if (this.isCheckedForTask(task)) {
      return [task];
    } else {
      return task.handleNewStatusWithRecurrenceInUsersOrder(this.newStatus);
    }
  }
  instructionDisplayName() {
    const commonTitle = "Change status to:";
    return `${commonTitle} [${this.newStatus.symbol}] ${this.newStatus.name}`;
  }
  isCheckedForTask(task) {
    return this.newStatus.symbol === task.status.symbol;
  }
};
function allStatusInstructions(statusRegistry) {
  const instructions = [];
  const coreStatuses = new StatusSettings().coreStatuses.map((setting) => setting.symbol);
  for (const matchCoreTask of [true, false]) {
    for (const status of statusRegistry.registeredStatuses) {
      if (coreStatuses.includes(status.symbol) === matchCoreTask) {
        instructions.push(new SetStatus(status));
      }
    }
  }
  return instructions;
}

// src/ui/Menus/TaskEditingMenu.ts
var import_obsidian9 = require("obsidian");
function defaultTaskSaver(originalTask, newTasks) {
  return __async(this, null, function* () {
    yield replaceTaskWithTasks({
      originalTask,
      newTasks
    });
  });
}
var TaskEditingMenu = class extends import_obsidian9.Menu {
  constructor(taskSaver) {
    super();
    this.taskSaver = taskSaver;
  }
  addItemsForInstructions(instructions, task) {
    for (const instruction of instructions) {
      this.addItemForInstruction(task, instruction);
    }
  }
  addItemForInstruction(task, instruction) {
    this.addItem((item) => this.getMenuItemCallback(task, item, instruction));
  }
  getMenuItemCallback(task, item, instruction) {
    item.setTitle(instruction.instructionDisplayName()).setChecked(instruction.isCheckedForTask(task)).onClick(() => __async(this, null, function* () {
      const newTask = instruction.apply(task);
      const hasEdits = newTask.length !== 1 || !Object.is(newTask[0], task);
      if (hasEdits) {
        yield this.taskSaver(task, newTask);
      }
    }));
  }
};

// src/ui/Menus/StatusMenu.ts
var StatusMenu = class extends TaskEditingMenu {
  constructor(statusRegistry, task, taskSaver = defaultTaskSaver) {
    super(taskSaver);
    const instructions = allStatusInstructions(statusRegistry);
    this.addItemsForInstructions(instructions, task);
  }
};

// src/Renderer/TaskFieldRenderer.ts
var TaskFieldRenderer = class {
  constructor() {
    this.data = taskFieldHTMLData;
  }
  addDataAttribute(element2, task, component) {
    this.data[component].addDataAttribute(element2, task, component);
  }
  addClassName(element2, component) {
    const componentClass = this.data[component].className;
    element2.classList.add(...[componentClass]);
  }
};
var _TaskFieldHTMLData = class {
  constructor(className, attributeName, attributeValueCalculator) {
    if (className === "") {
      throw Error("Developer note: CSS class cannot be an empty string, please specify one.");
    }
    this.className = className;
    this.attributeName = attributeName;
    this.attributeValueCalculator = attributeValueCalculator;
  }
  addDataAttribute(element2, task, component) {
    if (this.attributeName === _TaskFieldHTMLData.noAttributeName) {
      return;
    }
    const attributeValue = this.attributeValueCalculator(component, task);
    if (attributeValue === "") {
      return;
    }
    element2.dataset[this.attributeName] = attributeValue;
  }
};
var TaskFieldHTMLData = _TaskFieldHTMLData;
TaskFieldHTMLData.noAttributeName = "";
TaskFieldHTMLData.noAttributeValueCalculator = () => {
  return "";
};
TaskFieldHTMLData.dateAttributeCalculator = (component, task) => {
  const MAX_DAY_VALUE_RANGE = 7;
  const DAY_VALUE_OVER_RANGE_POSTFIX = "far";
  function dateToAttribute(date2) {
    const today = window.moment().startOf("day");
    const diffDays = today.diff(date2, "days");
    if (isNaN(diffDays)) {
      return null;
    }
    if (diffDays === 0) {
      return "today";
    }
    let result = "";
    if (diffDays > 0) {
      result += "past-";
    } else if (diffDays < 0) {
      result += "future-";
    }
    if (Math.abs(diffDays) <= MAX_DAY_VALUE_RANGE) {
      result += Math.abs(diffDays).toString() + "d";
    } else {
      result += DAY_VALUE_OVER_RANGE_POSTFIX;
    }
    return result;
  }
  const date = task[component];
  if (!Array.isArray(date) && date instanceof window.moment) {
    const attributeValue = dateToAttribute(date);
    if (attributeValue) {
      return attributeValue;
    }
  }
  return "";
};
function createFieldWithoutDataAttributes(className) {
  return new TaskFieldHTMLData(
    className,
    TaskFieldHTMLData.noAttributeName,
    TaskFieldHTMLData.noAttributeValueCalculator
  );
}
function createDateField(className, attributeName) {
  return new TaskFieldHTMLData(className, attributeName, TaskFieldHTMLData.dateAttributeCalculator);
}
var taskFieldHTMLData = {
  createdDate: createDateField("task-created", "taskCreated"),
  dueDate: createDateField("task-due", "taskDue"),
  reminderDate: createDateField("task-reminder", "taskReminder"),
  startDate: createDateField("task-start", "taskStart"),
  scheduledDate: createDateField("task-scheduled", "taskScheduled"),
  doneDate: createDateField("task-done", "taskDone"),
  cancelledDate: createDateField("task-cancelled", "taskCancelled"),
  priority: new TaskFieldHTMLData("task-priority", "taskPriority", (_component, task) => {
    return PriorityTools.priorityNameUsingNormal(task.priority).toLocaleLowerCase();
  }),
  description: createFieldWithoutDataAttributes("task-description"),
  recurrenceRule: createFieldWithoutDataAttributes("task-recurring"),
  dependsOn: createFieldWithoutDataAttributes("task-dependsOn"),
  id: createFieldWithoutDataAttributes("task-id"),
  blockLink: createFieldWithoutDataAttributes("task-block-link")
};

// src/Renderer/TaskLineRenderer.ts
function createAndAppendElement(tagName, parentElement) {
  const el = document.createElement(tagName);
  parentElement.appendChild(el);
  return el;
}
var TaskLineRenderer = class {
  static obsidianMarkdownRenderer(text2, element2, path, obsidianComponent) {
    return __async(this, null, function* () {
      if (!obsidianComponent)
        throw new Error("Must call the Obsidian renderer with an Obsidian Component object");
      yield import_obsidian10.MarkdownRenderer.renderMarkdown(text2, element2, path, obsidianComponent);
    });
  }
  constructor({
    textRenderer = TaskLineRenderer.obsidianMarkdownRenderer,
    obsidianComponent,
    parentUlElement,
    taskLayoutOptions,
    queryLayoutOptions
  }) {
    this.textRenderer = textRenderer;
    this.obsidianComponent = obsidianComponent;
    this.parentUlElement = parentUlElement;
    this.taskLayoutOptions = taskLayoutOptions;
    this.queryLayoutOptions = queryLayoutOptions;
  }
  renderTaskLine(task, taskIndex, isFilenameUnique) {
    return __async(this, null, function* () {
      const li = createAndAppendElement("li", this.parentUlElement);
      li.classList.add("task-list-item", "plugin-tasks-list-item");
      const textSpan = createAndAppendElement("span", li);
      textSpan.classList.add("tasks-list-text");
      yield this.taskToHtml(task, textSpan, li);
      const checkbox = createAndAppendElement("input", li);
      checkbox.classList.add("task-list-item-checkbox");
      checkbox.type = "checkbox";
      if (task.status.symbol !== " ") {
        checkbox.checked = true;
        li.classList.add("is-checked");
      }
      const addEventListeners = task.taskLocation.hasKnownPath;
      if (addEventListeners) {
        checkbox.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          checkbox.disabled = true;
          const toggledTasks = task.toggleWithRecurrenceInUsersOrder();
          replaceTaskWithTasks({
            originalTask: task,
            newTasks: toggledTasks
          });
        });
        checkbox.addEventListener("contextmenu", (ev) => {
          const menu = new StatusMenu(StatusRegistry.getInstance(), task);
          menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
        });
        checkbox.setAttribute("title", "Right-click for options");
      }
      li.prepend(checkbox);
      li.setAttribute("data-task", task.status.symbol.trim());
      li.setAttribute("data-line", taskIndex.toString());
      li.setAttribute("data-task-status-name", task.status.name);
      li.setAttribute("data-task-status-type", task.status.type);
      checkbox.setAttribute("data-line", taskIndex.toString());
      if (this.queryLayoutOptions.shortMode) {
        this.addTooltip(task, textSpan, isFilenameUnique);
      }
      return li;
    });
  }
  taskToHtml(task, parentElement, li) {
    return __async(this, null, function* () {
      const fieldRenderer = new TaskFieldRenderer();
      const emojiSerializer = TASK_FORMATS.tasksPluginEmoji.taskSerializer;
      for (const component of this.taskLayoutOptions.shownComponents) {
        const componentString = emojiSerializer.componentToString(
          task,
          this.queryLayoutOptions.shortMode,
          component
        );
        if (componentString) {
          const span = createAndAppendElement("span", parentElement);
          const internalSpan = createAndAppendElement("span", span);
          yield this.renderComponentText(internalSpan, componentString, component, task);
          this.addInternalClasses(component, internalSpan);
          fieldRenderer.addClassName(span, component);
          fieldRenderer.addDataAttribute(span, task, component);
          fieldRenderer.addDataAttribute(li, task, component);
        }
      }
      for (const component of this.taskLayoutOptions.hiddenComponents) {
        fieldRenderer.addDataAttribute(li, task, component);
      }
      if (li.dataset.taskPriority === void 0) {
        fieldRenderer.addDataAttribute(li, task, "priority" /* Priority */);
      }
    });
  }
  renderComponentText(span, componentString, component, task) {
    return __async(this, null, function* () {
      if (component === "description" /* Description */) {
        componentString = GlobalFilter.getInstance().removeAsWordFromDependingOnSettings(componentString);
        const { debugSettings } = getSettings();
        if (debugSettings.showTaskHiddenData) {
          componentString += `<br>\u{1F41B} <b>${task.lineNumber}</b> . ${task.sectionStart} . ${task.sectionIndex} . '<code>${task.originalMarkdown}</code>'<br>'<code>${task.path}</code>' > '<code>${task.precedingHeader}</code>'<br>`;
        }
        yield this.textRenderer(componentString, span, task.path, this.obsidianComponent);
        const blockQuote = span.querySelector("blockquote");
        const directParentOfPTag = blockQuote != null ? blockQuote : span;
        const pElement = directParentOfPTag.querySelector("p");
        if (pElement !== null) {
          while (pElement.firstChild) {
            directParentOfPTag.insertBefore(pElement.firstChild, pElement);
          }
          pElement.remove();
        }
        span.querySelectorAll("p").forEach((pElement2) => {
          if (!pElement2.hasChildNodes()) {
            pElement2.remove();
          }
        });
        span.querySelectorAll(".footnotes").forEach((footnoteElement) => {
          footnoteElement.remove();
        });
      } else {
        span.innerHTML = componentString;
      }
    });
  }
  addInternalClasses(component, internalSpan) {
    function tagToAttributeValue(tag) {
      const illegalChars = /["&\x00\r\n]/g;
      let sanitizedTag = tag.replace(illegalChars, "-");
      sanitizedTag = sanitizedTag.replace(/^[-_]+/, "");
      if (sanitizedTag.length > 0)
        return sanitizedTag;
      else
        return null;
    }
    if (component === "description" /* Description */) {
      const tags = internalSpan.getElementsByClassName("tag");
      for (let i = 0; i < tags.length; i++) {
        const tagName = tags[i].textContent;
        if (tagName) {
          const className = tagToAttributeValue(tagName);
          const element2 = tags[i];
          if (className)
            element2.dataset.tagName = className;
        }
      }
    }
  }
  addTooltip(task, element2, isFilenameUnique) {
    const {
      recurrenceSymbol,
      startDateSymbol,
      createdDateSymbol,
      scheduledDateSymbol,
      dueDateSymbol,
      reminderDateSymbol,
      cancelledDateSymbol,
      doneDateSymbol
    } = TASK_FORMATS.tasksPluginEmoji.taskSerializer.symbols;
    element2.addEventListener("mouseenter", () => {
      function addDateToTooltip(tooltip2, date, signifier) {
        if (date) {
          const createdDateDiv = tooltip2.createDiv();
          createdDateDiv.setText(
            toTooltipDate({
              signifier,
              date
            })
          );
        }
      }
      function toTooltipDate({ signifier, date }) {
        const format = isDateTime(date) ? TaskRegularExpressions.dateTimeFormat : TaskRegularExpressions.dateFormat;
        return `${signifier} ${date.format(format)} (${date.from(window.moment().startOf("day"))})`;
      }
      const tooltip = element2.createDiv();
      tooltip.addClasses(["tooltip", "pop-up"]);
      if (task.recurrence) {
        const recurrenceDiv = tooltip.createDiv();
        recurrenceDiv.setText(`${recurrenceSymbol} ${task.recurrence.toText()}`);
      }
      addDateToTooltip(tooltip, task.createdDate, createdDateSymbol);
      addDateToTooltip(tooltip, task.startDate, startDateSymbol);
      addDateToTooltip(tooltip, task.scheduledDate, scheduledDateSymbol);
      addDateToTooltip(tooltip, task.dueDate, dueDateSymbol);
      addDateToTooltip(tooltip, task.reminderDate, reminderDateSymbol);
      addDateToTooltip(tooltip, task.cancelledDate, cancelledDateSymbol);
      addDateToTooltip(tooltip, task.doneDate, doneDateSymbol);
      const linkText = task.getLinkText({ isFilenameUnique });
      if (linkText) {
        const backlinkDiv = tooltip.createDiv();
        backlinkDiv.setText(`\u{1F517} ${linkText}`);
      }
      element2.addEventListener("mouseleave", () => {
        tooltip.remove();
      });
    });
  }
};

// src/Obsidian/InlineRenderer.ts
var InlineRenderer = class {
  constructor({ plugin }) {
    this.markdownPostProcessor = this._markdownPostProcessor.bind(this);
    plugin.registerMarkdownPostProcessor(this._markdownPostProcessor.bind(this));
  }
  _markdownPostProcessor(element2, context) {
    return __async(this, null, function* () {
      var _a;
      const childComponent = new import_obsidian11.MarkdownRenderChild(element2);
      context.addChild(childComponent);
      const renderedElements = element2.findAll(".task-list-item").filter((taskItem) => {
        var _a2;
        const linesText = (_a2 = taskItem.textContent) == null ? void 0 : _a2.split("\n");
        if (linesText === void 0) {
          return false;
        }
        let firstLineText = null;
        for (let i = 0; i < linesText.length; i = i + 1) {
          if (linesText[i] !== "") {
            firstLineText = linesText[i];
            break;
          }
        }
        if (firstLineText === null) {
          return false;
        }
        return GlobalFilter.getInstance().includedIn(firstLineText);
      });
      if (renderedElements.length === 0) {
        return;
      }
      const path = context.sourcePath;
      const section = context.getSectionInfo(element2);
      if (section === null) {
        return;
      }
      const fileLines = section.text.split("\n");
      let sectionIndex = 0;
      const fileTasks = [];
      for (let lineNumber = section.lineStart; lineNumber <= section.lineEnd; lineNumber++) {
        const line = fileLines[lineNumber];
        if (line === void 0) {
          continue;
        }
        const precedingHeader = null;
        const task = Task.fromLine({
          line,
          taskLocation: new TaskLocation(
            new TasksFile(path),
            lineNumber,
            section.lineStart,
            sectionIndex,
            precedingHeader
          ),
          fallbackDate: null
        });
        if (task !== null) {
          fileTasks.push(task);
          sectionIndex++;
        }
      }
      const taskLineRenderer = new TaskLineRenderer({
        obsidianComponent: childComponent,
        parentUlElement: element2,
        taskLayoutOptions: new TaskLayoutOptions(),
        queryLayoutOptions: new QueryLayoutOptions()
      });
      for (let sectionIndex2 = 0; sectionIndex2 < renderedElements.length; sectionIndex2++) {
        const task = fileTasks[sectionIndex2];
        const renderedElement = renderedElements[sectionIndex2];
        if (task === void 0 || renderedElement === void 0) {
          continue;
        }
        const dataLine = (_a = renderedElement.getAttr("data-line")) != null ? _a : "0";
        const taskIndex = Number.parseInt(dataLine, 10);
        const taskElement = yield taskLineRenderer.renderTaskLine(task, taskIndex);
        const renderedChildren = renderedElement.childNodes;
        for (let i = 0; i < renderedChildren.length; i = i + 1) {
          const renderedChild = renderedChildren[i];
          if (renderedChild.nodeName.toLowerCase() === "div") {
            taskElement.prepend(renderedChild);
          } else if (renderedChild.nodeName.toLowerCase() === "ul") {
            taskElement.append(renderedChild);
          }
        }
        const originalFootnotes = renderedElement.querySelectorAll("[data-footnote-id]");
        const newFootnotes = taskElement.querySelectorAll("[data-footnote-id]");
        if (originalFootnotes.length === newFootnotes.length) {
          for (let i = 0; i < originalFootnotes.length; i++) {
            newFootnotes[i].replaceWith(originalFootnotes[i]);
          }
        }
        renderedElement.replaceWith(taskElement);
      }
    });
  }
};

// src/Obsidian/LivePreviewExtension.ts
var import_view = require("@codemirror/view");
var import_obsidian12 = require("obsidian");
var newLivePreviewExtension = () => {
  return import_view.ViewPlugin.fromClass(LivePreviewExtension);
};
var LivePreviewExtension = class {
  constructor(view) {
    this.view = view;
    this.handleClickEvent = this.handleClickEvent.bind(this);
    this.view.dom.addEventListener("click", this.handleClickEvent);
  }
  destroy() {
    this.view.dom.removeEventListener("click", this.handleClickEvent);
  }
  handleClickEvent(event) {
    const { target } = event;
    if (!target || !(target instanceof HTMLInputElement) || target.type !== "checkbox") {
      return false;
    }
    const ancestor = target.closest("ul.plugin-tasks-query-result, div.callout-content");
    if (ancestor) {
      if (ancestor.matches("div.callout-content")) {
        const msg = 'obsidian-tasks-plugin warning: Tasks cannot add or remove completion dates or make the next copy of a recurring task for tasks written inside a callout when you click their checkboxes in Live Preview. \nIf you wanted Tasks to do these things, please undo your change, then either click the line of the task and use the "Toggle Task Done" command, or switch to Reading View to click the checkbox.';
        console.warn(msg);
        new import_obsidian12.Notice(msg, 45e3);
      }
      return false;
    }
    const { state } = this.view;
    const position = this.view.posAtDOM(target);
    const line = state.doc.lineAt(position);
    const task = Task.fromLine({
      line: line.text,
      taskLocation: TaskLocation.fromUnknownPosition(new TasksFile("")),
      fallbackDate: null
    });
    if (task === null) {
      return false;
    }
    event.preventDefault();
    const toggled = task.toggleWithRecurrenceInUsersOrder();
    const toggledString = toggled.map((t) => t.toFileLineString()).join(state.lineBreak);
    const transaction = state.update({
      changes: {
        from: line.from,
        to: line.to,
        insert: toggledString
      }
    });
    this.view.dispatch(transaction);
    const desiredCheckedStatus = target.checked;
    setTimeout(() => {
      target.checked = desiredCheckedStatus;
    }, 1);
    return true;
  }
};

// src/Renderer/QueryRenderer.ts
var import_obsidian14 = require("obsidian");

// src/Layout/LayoutHelpers.ts
function generateHiddenClassForTaskList(hiddenClasses, hide2, component) {
  if (hide2) {
    hiddenClasses.push(hiddenComponentClassName(component));
  }
}
function hiddenComponentClassName(component) {
  return `tasks-layout-hide-${component}`;
}

// src/Layout/QueryLayout.ts
var QueryLayout = class {
  constructor(queryLayoutOptions) {
    if (queryLayoutOptions) {
      this.queryLayoutOptions = queryLayoutOptions;
    } else {
      this.queryLayoutOptions = new QueryLayoutOptions();
    }
  }
  getHiddenClasses() {
    const hiddenClasses = [];
    const componentsToGenerateClassesOnly = [
      [this.queryLayoutOptions.hideUrgency, "urgency"],
      [this.queryLayoutOptions.hideBacklinks, "backlinks"],
      [this.queryLayoutOptions.hideEditButton, "edit-button"],
      [this.queryLayoutOptions.hidePostponeButton, "postpone-button"]
    ];
    for (const [hide2, component] of componentsToGenerateClassesOnly) {
      generateHiddenClassForTaskList(hiddenClasses, hide2, component);
    }
    if (this.queryLayoutOptions.shortMode)
      hiddenClasses.push("tasks-layout-short-mode");
    return hiddenClasses;
  }
};

// src/lib/QueryRendererHelper.ts
function explainResults(source, globalFilter, globalQuery, path = void 0) {
  let result = "";
  if (!globalFilter.isEmpty()) {
    result += `Only tasks containing the global filter '${globalFilter.get()}'.

`;
  }
  const explainer = new Explainer("  ");
  const tasksBlockQuery = new Query(source, path);
  if (!tasksBlockQuery.ignoreGlobalQuery) {
    if (globalQuery.hasInstructions()) {
      const globalQueryQuery = globalQuery.query(path);
      result += `Explanation of the global query:

${explainer.explainQuery(globalQueryQuery)}
`;
    }
  }
  result += `Explanation of this Tasks code block query:

${explainer.explainQuery(tasksBlockQuery)}`;
  return result;
}
function getQueryForQueryRenderer(source, globalQuery, path) {
  const tasksBlockQuery = new Query(source, path);
  if (tasksBlockQuery.ignoreGlobalQuery) {
    return tasksBlockQuery;
  }
  return globalQuery.query(path).append(tasksBlockQuery);
}

// src/Scripting/Postponer.ts
function shouldShowPostponeButton(task) {
  for (const dateField of Task.allDateFields()) {
    const taskElement = task[dateField];
    if (taskElement && !taskElement.isValid()) {
      return false;
    }
  }
  const hasAValidHappensDate = task.happensDates.some((date) => {
    return !!(date == null ? void 0 : date.isValid());
  });
  return !task.isDone && hasAValidHappensDate;
}
function getDateFieldToPostpone(task) {
  if (task.dueDate) {
    return "dueDate";
  }
  if (task.scheduledDate) {
    return "scheduledDate";
  }
  if (task.startDate) {
    return "startDate";
  }
  return null;
}
function createPostponedTask(task, dateFieldToPostpone, timeUnit, amount) {
  const dateToPostpone = task[dateFieldToPostpone];
  return createPostponedTaskFromDate(dateToPostpone, task, dateFieldToPostpone, timeUnit, amount);
}
function createFixedDateTask(task, dateFieldToPostpone, timeUnit, amount) {
  const dateToPostpone = window.moment();
  return createPostponedTaskFromDate(dateToPostpone, task, dateFieldToPostpone, timeUnit, amount);
}
function createPostponedTaskFromDate(dateToPostpone, task, dateFieldToPostpone, timeUnit, amount) {
  const postponedDate = new TasksDate(dateToPostpone).postpone(timeUnit, amount);
  const postponedTask = DateFallback.removeInferredStatusIfNeeded(task, [
    new Task(__spreadProps(__spreadValues({}, task), {
      [dateFieldToPostpone]: postponedDate
    }))
  ])[0];
  return { postponedDate, postponedTask };
}
function postponementSuccessMessage(postponedDate, dateFieldToPostpone) {
  const postponedDateString = postponedDate == null ? void 0 : postponedDate.format("DD MMM YYYY");
  return `Task's ${dateFieldToPostpone} changed to ${postponedDateString}`;
}
function postponeButtonTitle(task, amount, timeUnit) {
  const buttonText = postponeMenuItemTitle(task, amount, timeUnit);
  return `\u2139\uFE0F ${buttonText} (right-click for more options)`;
}
function postponeMenuItemTitle(task, amount, timeUnit) {
  const updatedDateType = getDateFieldToPostpone(task);
  const dateToUpdate = task[updatedDateType];
  return postponeMenuItemTitleFromDate(updatedDateType, dateToUpdate, amount, timeUnit);
}
function fixedDateMenuItemTitle(task, amount, timeUnit) {
  const updatedDateType = getDateFieldToPostpone(task);
  const dateToUpdate = window.moment().startOf("day");
  return postponeMenuItemTitleFromDate(updatedDateType, dateToUpdate, amount, timeUnit);
}
function postponeMenuItemTitleFromDate(updatedDateType, dateToUpdate, amount, timeUnit) {
  const postponedDate = new TasksDate(dateToUpdate).postpone(timeUnit, amount);
  const formattedNewDate = postponedDate.format("ddd Do MMM");
  const amountOrArticle = amount != 1 ? amount : "a";
  if (dateToUpdate.isSameOrBefore(window.moment(), "day")) {
    const updatedDateDisplayText = capitalizeFirstLetter(updatedDateType.replace("Date", ""));
    return `${updatedDateDisplayText} in ${amountOrArticle} ${timeUnit}, on ${formattedNewDate}`.replace(" in 0 days", " today").replace("in a day", "tomorrow");
  } else {
    const updatedDateDisplayText = updatedDateType.replace("Date", " date");
    return `Postpone ${updatedDateDisplayText} by ${amountOrArticle} ${timeUnit}, to ${formattedNewDate}`;
  }
}

// src/Layout/TaskLayout.ts
var TaskLayout = class {
  constructor(taskLayoutOptions) {
    if (taskLayoutOptions) {
      this.taskLayoutOptions = taskLayoutOptions;
    } else {
      this.taskLayoutOptions = new TaskLayoutOptions();
    }
  }
  generateHiddenClasses() {
    const hiddenClasses = [];
    this.taskLayoutOptions.toggleableComponents.forEach((component) => {
      generateHiddenClassForTaskList(hiddenClasses, !this.taskLayoutOptions.isShown(component), component);
    });
    generateHiddenClassForTaskList(hiddenClasses, !this.taskLayoutOptions.areTagsShown(), "tags");
    return hiddenClasses;
  }
};

// src/ui/Menus/PostponeMenu.ts
var import_obsidian13 = require("obsidian");
var PostponeMenu = class extends TaskEditingMenu {
  constructor(button, task, taskSaver = defaultTaskSaver) {
    super(taskSaver);
    const postponeMenuItemCallback = (button2, item, timeUnit, amount, itemNamingFunction, postponingFunction2) => {
      const title = itemNamingFunction(task, amount, timeUnit);
      item.setTitle(title).onClick(
        () => PostponeMenu.postponeOnClickCallback(button2, task, amount, timeUnit, postponingFunction2, taskSaver)
      );
    };
    const fixedTitle = fixedDateMenuItemTitle;
    const fixedDateFunction = createFixedDateTask;
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 0, fixedTitle, fixedDateFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "day", 1, fixedTitle, fixedDateFunction));
    this.addSeparator();
    const titlingFunction = postponeMenuItemTitle;
    const postponingFunction = createPostponedTask;
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 2, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 3, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 4, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 5, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "days", 6, titlingFunction, postponingFunction));
    this.addSeparator();
    this.addItem((item) => postponeMenuItemCallback(button, item, "week", 1, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "weeks", 2, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "weeks", 3, titlingFunction, postponingFunction));
    this.addItem((item) => postponeMenuItemCallback(button, item, "month", 1, titlingFunction, postponingFunction));
  }
  static postponeOnClickCallback(_0, _1, _2, _3) {
    return __async(this, arguments, function* (button, task, amount, timeUnit, postponingFunction = createPostponedTask, taskSaver = defaultTaskSaver) {
      const dateFieldToPostpone = getDateFieldToPostpone(task);
      if (dateFieldToPostpone === null) {
        const errorMessage = "\u26A0\uFE0F Postponement requires a date: due, scheduled or start.";
        return new import_obsidian13.Notice(errorMessage, 1e4);
      }
      const { postponedDate, postponedTask } = postponingFunction(task, dateFieldToPostpone, timeUnit, amount);
      yield taskSaver(task, postponedTask);
      PostponeMenu.postponeSuccessCallback(button, dateFieldToPostpone, postponedDate);
    });
  }
  static postponeSuccessCallback(button, updatedDateType, postponedDate) {
    button.style.pointerEvents = "none";
    const successMessage = postponementSuccessMessage(postponedDate, updatedDateType);
    new import_obsidian13.Notice(successMessage, 2e3);
  }
};

// src/lib/PerformanceTracker.ts
var PerformanceTracker = class {
  constructor(labelForPerformance) {
    this.label = labelForPerformance;
    this.start();
  }
  start() {
    if (!this.recordTimings()) {
      return;
    }
    performance.mark(this.labelForStart());
  }
  finish() {
    if (!this.recordTimings()) {
      return;
    }
    performance.mark(this.labelForEnd());
    performance.measure(this.label, this.labelForStart(), this.labelForEnd());
    this.printDuration();
  }
  printDuration() {
    const entries = performance.getEntriesByName(this.label);
    const lastEntry = entries[entries.length - 1];
    if (lastEntry) {
      console.log(this.label + ":", lastEntry.duration, "milliseconds");
    } else {
      console.log(`Measurement for ${this.label} not found`);
    }
  }
  labelForStart() {
    return `${this.label} - start`;
  }
  labelForEnd() {
    return `${this.label} - end`;
  }
  recordTimings() {
    const { debugSettings } = getSettings();
    return debugSettings.recordTimings;
  }
};

// src/Renderer/QueryRenderer.ts
var QueryRenderer = class {
  constructor({ plugin, events }) {
    this.addQueryRenderChild = this._addQueryRenderChild.bind(this);
    this.app = plugin.app;
    this.plugin = plugin;
    this.events = events;
    plugin.registerMarkdownCodeBlockProcessor("tasks", this._addQueryRenderChild.bind(this));
  }
  _addQueryRenderChild(source, element2, context) {
    return __async(this, null, function* () {
      context.addChild(
        new QueryRenderChild({
          app: this.app,
          plugin: this.plugin,
          events: this.events,
          container: element2,
          source,
          filePath: context.sourcePath
        })
      );
    });
  }
};
var QueryRenderChild = class extends import_obsidian14.MarkdownRenderChild {
  constructor({
    app: app2,
    plugin,
    events,
    container,
    source,
    filePath
  }) {
    super(container);
    this.app = app2;
    this.plugin = plugin;
    this.events = events;
    this.source = source;
    this.filePath = filePath;
    switch (this.containerEl.className) {
      case "block-language-tasks":
        this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
        this.queryType = "tasks";
        break;
      default:
        this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
        this.queryType = "tasks";
        break;
    }
  }
  onload() {
    this.events.triggerRequestCacheUpdate(this.render.bind(this));
    this.renderEventRef = this.events.onCacheUpdate(this.render.bind(this));
    this.reloadQueryAtMidnight();
  }
  onunload() {
    if (this.renderEventRef !== void 0) {
      this.events.off(this.renderEventRef);
    }
    if (this.queryReloadTimeout !== void 0) {
      clearTimeout(this.queryReloadTimeout);
    }
  }
  reloadQueryAtMidnight() {
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    const now = new Date();
    const millisecondsToMidnight = midnight.getTime() - now.getTime();
    this.queryReloadTimeout = setTimeout(() => {
      this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
      this.events.triggerRequestCacheUpdate(this.render.bind(this));
      this.reloadQueryAtMidnight();
    }, millisecondsToMidnight + 1e3);
  }
  render(_0) {
    return __async(this, arguments, function* ({ tasks, state }) {
      var _a;
      const content = createAndAppendElement("div", this.containerEl);
      if (state === "Warm" /* Warm */ && this.query.error === void 0) {
        yield this.renderQuerySearchResults(tasks, state, content);
      } else if (this.query.error !== void 0) {
        this.renderErrorMessage(content, this.query.error);
      } else {
        this.renderLoadingMessage(content);
      }
      (_a = this.containerEl.firstChild) == null ? void 0 : _a.replaceWith(content);
    });
  }
  renderQuerySearchResults(tasks, state, content) {
    return __async(this, null, function* () {
      const queryResult = this.explainAndPerformSearch(state, tasks, content);
      if (queryResult.searchErrorMessage !== void 0) {
        this.renderErrorMessage(content, queryResult.searchErrorMessage);
        return;
      }
      yield this.renderSearchResults(queryResult, content);
    });
  }
  explainAndPerformSearch(state, tasks, content) {
    const measureSearch = new PerformanceTracker(`Search: ${this.query.queryId} - ${this.filePath}`);
    measureSearch.start();
    this.query.debug(`[render] Render called: plugin state: ${state}; searching ${tasks.length} tasks`);
    if (this.query.queryLayoutOptions.explainQuery) {
      this.createExplanation(content);
    }
    const queryResult = this.query.applyQueryToTasks(tasks);
    measureSearch.finish();
    return queryResult;
  }
  renderSearchResults(queryResult, content) {
    return __async(this, null, function* () {
      const measureRender = new PerformanceTracker(`Render: ${this.query.queryId} - ${this.filePath}`);
      measureRender.start();
      yield this.addAllTaskGroups(queryResult.taskGroups, content);
      const totalTasksCount = queryResult.totalTasksCount;
      this.addTaskCount(content, queryResult);
      this.query.debug(`[render] ${totalTasksCount} tasks displayed`);
      measureRender.finish();
    });
  }
  renderErrorMessage(content, errorMessage) {
    content.createDiv().innerHTML = `<pre>Tasks query: ${errorMessage.replace(/\n/g, "<br>")}</pre>`;
  }
  renderLoadingMessage(content) {
    content.setText("Loading Tasks ...");
  }
  createExplanation(content) {
    const explanationAsString = explainResults(
      this.source,
      GlobalFilter.getInstance(),
      GlobalQuery.getInstance(),
      this.filePath
    );
    const explanationsBlock = createAndAppendElement("pre", content);
    explanationsBlock.addClasses(["plugin-tasks-query-explanation"]);
    explanationsBlock.setText(explanationAsString);
    content.appendChild(explanationsBlock);
  }
  createTaskList(tasks, content) {
    return __async(this, null, function* () {
      const taskList = createAndAppendElement("ul", content);
      taskList.addClasses(["contains-task-list", "plugin-tasks-query-result"]);
      const taskLayout = new TaskLayout(this.query.taskLayoutOptions);
      taskList.addClasses(taskLayout.generateHiddenClasses());
      const queryLayout = new QueryLayout(this.query.queryLayoutOptions);
      taskList.addClasses(queryLayout.getHiddenClasses());
      const groupingAttribute = this.getGroupingAttribute();
      if (groupingAttribute && groupingAttribute.length > 0)
        taskList.dataset.taskGroupBy = groupingAttribute;
      const taskLineRenderer = new TaskLineRenderer({
        obsidianComponent: this,
        parentUlElement: taskList,
        taskLayoutOptions: this.query.taskLayoutOptions,
        queryLayoutOptions: this.query.queryLayoutOptions
      });
      for (const [taskIndex, task] of tasks.entries()) {
        yield this.addTask(taskList, taskLineRenderer, task, taskIndex);
      }
      content.appendChild(taskList);
    });
  }
  addTask(taskList, taskLineRenderer, task, taskIndex) {
    return __async(this, null, function* () {
      const isFilenameUnique = this.isFilenameUnique({ task });
      const listItem = yield taskLineRenderer.renderTaskLine(task, taskIndex, isFilenameUnique);
      const footnotes = listItem.querySelectorAll("[data-footnote-id]");
      footnotes.forEach((footnote) => footnote.remove());
      const extrasSpan = listItem.createSpan("task-extras");
      if (!this.query.queryLayoutOptions.hideUrgency) {
        this.addUrgency(extrasSpan, task);
      }
      const shortMode = this.query.queryLayoutOptions.shortMode;
      if (!this.query.queryLayoutOptions.hideBacklinks) {
        this.addBacklinks(extrasSpan, task, shortMode, isFilenameUnique);
      }
      if (!this.query.queryLayoutOptions.hideEditButton) {
        this.addEditButton(extrasSpan, task, this.plugin.getTasks());
      }
      if (!this.query.queryLayoutOptions.hidePostponeButton && shouldShowPostponeButton(task)) {
        this.addPostponeButton(extrasSpan, task, shortMode);
      }
      taskList.appendChild(listItem);
    });
  }
  addEditButton(listItem, task, allTasks) {
    const editTaskPencil = createAndAppendElement("a", listItem);
    editTaskPencil.addClass("tasks-edit");
    editTaskPencil.title = "Edit task";
    editTaskPencil.href = "#";
    editTaskPencil.onClickEvent((event) => {
      event.preventDefault();
      const onSubmit = (updatedTasks) => __async(this, null, function* () {
        yield replaceTaskWithTasks({
          originalTask: task,
          newTasks: DateFallback.removeInferredStatusIfNeeded(task, updatedTasks)
        });
      });
      const taskModal = new TaskModal({
        app: this.app,
        task,
        onSubmit,
        allTasks
      });
      taskModal.open();
    });
  }
  addUrgency(listItem, task) {
    const text2 = new Intl.NumberFormat().format(task.urgency);
    listItem.createSpan({ text: text2, cls: "tasks-urgency" });
  }
  addAllTaskGroups(tasksSortedLimitedGrouped, content) {
    return __async(this, null, function* () {
      for (const group of tasksSortedLimitedGrouped.groups) {
        yield this.addGroupHeadings(content, group.groupHeadings);
        yield this.createTaskList(group.tasks, content);
      }
    });
  }
  addGroupHeadings(content, groupHeadings) {
    return __async(this, null, function* () {
      for (const heading of groupHeadings) {
        yield this.addGroupHeading(content, heading);
      }
    });
  }
  addGroupHeading(content, group) {
    return __async(this, null, function* () {
      let header = "h6";
      if (group.nestingLevel === 0) {
        header = "h4";
      } else if (group.nestingLevel === 1) {
        header = "h5";
      }
      const headerEl = createAndAppendElement(header, content);
      headerEl.addClass("tasks-group-heading");
      yield import_obsidian14.MarkdownRenderer.renderMarkdown(group.displayName, headerEl, this.filePath, this);
    });
  }
  addBacklinks(listItem, task, shortMode, isFilenameUnique) {
    var _a;
    const backLink = listItem.createSpan({ cls: "tasks-backlink" });
    if (!shortMode) {
      backLink.append(" (");
    }
    const link = createAndAppendElement("a", backLink);
    link.rel = "noopener";
    link.target = "_blank";
    link.addClass("internal-link");
    if (shortMode) {
      link.addClass("internal-link-short-mode");
    }
    let linkText;
    if (shortMode) {
      linkText = " \u{1F517}";
    } else {
      linkText = (_a = task.getLinkText({ isFilenameUnique })) != null ? _a : "";
    }
    link.setText(linkText);
    const vault2 = this.app.vault;
    link.addEventListener("click", (ev) => __async(this, null, function* () {
      const result = yield getTaskLineAndFile(task, vault2);
      if (result) {
        const [line, file] = result;
        const leaf = this.app.workspace.getLeaf(import_obsidian14.Keymap.isModEvent(ev));
        ev.preventDefault();
        yield leaf.openFile(file, { eState: { line } });
      }
    }));
    link.addEventListener("mousedown", (ev) => __async(this, null, function* () {
      if (ev.button === 1) {
        const result = yield getTaskLineAndFile(task, vault2);
        if (result) {
          const [line, file] = result;
          const leaf = this.app.workspace.getLeaf("tab");
          ev.preventDefault();
          yield leaf.openFile(file, { eState: { line } });
        }
      }
    }));
    if (!shortMode) {
      backLink.append(")");
    }
  }
  addPostponeButton(listItem, task, shortMode) {
    const amount = 1;
    const timeUnit = "day";
    const buttonTooltipText = postponeButtonTitle(task, amount, timeUnit);
    const button = createAndAppendElement("a", listItem);
    button.addClass("tasks-postpone");
    if (shortMode) {
      button.addClass("tasks-postpone-short-mode");
    }
    button.title = buttonTooltipText;
    button.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      PostponeMenu.postponeOnClickCallback(button, task, amount, timeUnit);
    });
    button.addEventListener("contextmenu", (ev) => __async(this, null, function* () {
      ev.preventDefault();
      ev.stopPropagation();
      const menu = new PostponeMenu(button, task);
      menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
    }));
  }
  addTaskCount(content, queryResult) {
    if (!this.query.queryLayoutOptions.hideTaskCount) {
      content.createDiv({
        text: queryResult.totalTasksCountDisplayText(),
        cls: "tasks-count"
      });
    }
  }
  isFilenameUnique({ task }) {
    const filenameMatch = task.path.match(/([^/]*)\..+$/i);
    if (filenameMatch === null) {
      return void 0;
    }
    const filename = filenameMatch[1];
    const allFilesWithSameName = this.app.vault.getMarkdownFiles().filter((file) => {
      if (file.basename === filename) {
        return true;
      }
    });
    return allFilesWithSameName.length < 2;
  }
  getGroupingAttribute() {
    const groupingRules = [];
    for (const group of this.query.grouping) {
      groupingRules.push(group.property);
    }
    return groupingRules.join(",");
  }
};

// src/Config/SettingsTab.ts
var import_obsidian16 = require("obsidian");

// src/lib/MarkdownTable.ts
var MarkdownTable = class {
  constructor(columnNames) {
    this._markdown = "";
    this.columnNames = columnNames;
    this.addTitleRow();
  }
  get markdown() {
    return this._markdown;
  }
  addTitleRow() {
    let titles = "|";
    let divider = "|";
    this.columnNames.forEach((s) => {
      titles += ` ${s} |`;
      divider += " ----- |";
    });
    this._markdown += `${titles}
`;
    this._markdown += `${divider}
`;
  }
  addRow(cells) {
    const row = this.makeRowText(cells);
    this._markdown += `${row}
`;
  }
  addRowIfNew(cells) {
    const row = this.makeRowText(cells);
    if (!this._markdown.includes(row)) {
      this._markdown += `${row}
`;
    }
  }
  makeRowText(cells) {
    let row = "|";
    cells.forEach((s) => {
      row += ` ${s} |`;
    });
    return row;
  }
};

// src/Statuses/StatusSettingsReport.ts
function getFirstIndex(statusConfigurations, wantedSymbol) {
  return statusConfigurations.findIndex((s) => s.symbol === wantedSymbol);
}
function getPrintableSymbol(symbol) {
  if (symbol === "") {
    return symbol;
  }
  const result = symbol !== " " ? symbol : "space";
  return "`" + result + "`";
}
function checkIfConventionalType(status, problems) {
  const conventionalType = Status.getTypeForUnknownSymbol(status.symbol);
  if (status.type === conventionalType) {
    return;
  }
  if (conventionalType === "TODO" /* TODO */ && status.symbol !== " ") {
    return;
  }
  problems.push(
    `For information, the conventional type for status symbol ${getPrintableSymbol(
      status.symbol
    )} is ${getPrintableSymbol(conventionalType)}: you may wish to review this type.`
  );
}
function checkNextStatusSymbol(statuses, status, problems) {
  const indexOfNextSymbol = getFirstIndex(statuses, status.nextStatusSymbol);
  if (indexOfNextSymbol === -1) {
    problems.push(
      `Next symbol ${getPrintableSymbol(
        status.nextStatusSymbol
      )} is unknown: create a status with symbol ${getPrintableSymbol(status.nextStatusSymbol)}.`
    );
    return;
  }
  if (status.type !== "DONE" /* DONE */) {
    return;
  }
  const nextStatus = statuses[indexOfNextSymbol];
  if (nextStatus) {
    if (nextStatus.type !== "TODO" && nextStatus.type !== "IN_PROGRESS") {
      const helpURL = "https://publish.obsidian.md/tasks/Getting+Started/Statuses/Recurring+Tasks+and+Custom+Statuses";
      const message = [
        `This \`DONE\` status is followed by ${getPrintableSymbol(
          nextStatus.type
        )}, not \`TODO\` or \`IN_PROGRESS\`.`,
        "If used to complete a recurring task, it will instead be followed by `TODO` or `IN_PROGRESS`, to ensure the next task matches the `not done` filter.",
        `See [Recurring Tasks and Custom Statuses](${helpURL}).`
      ].join("<br>");
      problems.push(message);
    }
  } else {
    problems.push("Unexpected failure to find the next status.");
  }
}
function getProblemsForStatus(statuses, status, index) {
  const problems = [];
  if (status.symbol === Status.EMPTY.symbol) {
    problems.push("Empty symbol: this status will be ignored.");
    return problems;
  }
  const firstIndex = getFirstIndex(statuses, status.symbol);
  if (firstIndex != index) {
    problems.push(`Duplicate symbol '${getPrintableSymbol(status.symbol)}': this status will be ignored.`);
    return problems;
  }
  checkIfConventionalType(status, problems);
  checkNextStatusSymbol(statuses, status, problems);
  return problems;
}
function tabulateStatusSettings(statusSettings) {
  const table = new MarkdownTable([
    "Status Symbol",
    "Next Status Symbol",
    "Status Name",
    "Status Type",
    "Problems (if any)"
  ]);
  const statuses = StatusSettings.allStatuses(statusSettings);
  statuses.forEach((status, index) => {
    table.addRow([
      getPrintableSymbol(status.symbol),
      getPrintableSymbol(status.nextStatusSymbol),
      status.name,
      getPrintableSymbol(status.type),
      getProblemsForStatus(statuses, status, index).join("<br>")
    ]);
  });
  return table.markdown;
}

// src/Statuses/StatusRegistryReport.ts
function createStatusRegistryReport(statusSettings, statusRegistry, buttonName, versionString) {
  const detailed = true;
  const settingsTable = tabulateStatusSettings(statusSettings);
  const mermaidText = statusRegistry.mermaidDiagram(detailed);
  return `# ${buttonName}

## About this file

This file was created by the Obsidian Tasks plugin (version ${versionString}) to help visualise the task statuses in this vault.

If you change the Tasks status settings, you can get an updated report by:

- Going to \`Settings\` -> \`Tasks\`.
- Clicking on \`Review and check your Statuses\`.

You can delete this file any time.

## Status Settings

<!--
Switch to Live Preview or Reading Mode to see the table.
If there are any Markdown formatting characters in status names, such as '*' or '_',
Obsidian may only render the table correctly in Reading Mode.
-->

These are the status values in the Core and Custom statuses sections.

${settingsTable}
## Loaded Settings

<!-- Switch to Live Preview or Reading Mode to see the diagram. -->

These are the settings actually used by Tasks.
${mermaidText}`;
}

// src/Config/Themes/AnuPpuccinThemeCollection.ts
function anuppuccinSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    [">", "Rescheduled", "x", "TODO"],
    ["<", "Scheduled", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    ["?", "Question", "x", "TODO"],
    ["*", "Star", "x", "TODO"],
    ["n", "Note", "x", "TODO"],
    ["l", "Location", "x", "TODO"],
    ["i", "Information", "x", "TODO"],
    ["I", "Idea", "x", "TODO"],
    ["S", "Amount", "x", "TODO"],
    ["p", "Pro", "x", "TODO"],
    ["c", "Con", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ['"', "Quote", "x", "TODO"],
    ["0", "Speech bubble 0", "0", "NON_TASK"],
    ["1", "Speech bubble 1", "1", "NON_TASK"],
    ["2", "Speech bubble 2", "2", "NON_TASK"],
    ["3", "Speech bubble 3", "3", "NON_TASK"],
    ["4", "Speech bubble 4", "4", "NON_TASK"],
    ["5", "Speech bubble 5", "5", "NON_TASK"],
    ["6", "Speech bubble 6", "6", "NON_TASK"],
    ["7", "Speech bubble 7", "7", "NON_TASK"],
    ["8", "Speech bubble 8", "8", "NON_TASK"],
    ["9", "Speech bubble 9", "9", "NON_TASK"]
  ];
  return zzz;
}

// src/Config/Themes/AuraThemeCollection.ts
function auraSupportedStatuses() {
  const zzz = [
    [" ", "incomplete", "x", "TODO"],
    ["x", "complete / done", " ", "DONE"],
    ["-", "cancelled", " ", "CANCELLED"],
    [">", "deferred", "x", "TODO"],
    ["/", "in progress, or half-done", "x", "IN_PROGRESS"],
    ["!", "Important", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["R", "review", "x", "TODO"],
    ["+", "Inbox / task that should be processed later", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["B", "brainstorm", "x", "TODO"],
    ["D", "deferred or scheduled", "x", "TODO"],
    ["I", "Info", "x", "TODO"],
    ["i", "idea", "x", "TODO"],
    ["N", "note", "x", "TODO"],
    ["Q", "quote", "x", "TODO"],
    ["W", "win / success / reward", "x", "TODO"],
    ["P", "pro", "x", "TODO"],
    ["C", "con", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/EbullientworksThemeCollection.ts
function ebullientworksSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    [">", "Deferred", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["?", "Question", "x", "TODO"],
    ["r", "Review", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/ITSThemeCollection.ts
function itsSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Regular", " ", "DONE"],
    ["X", "Checked", " ", "DONE"],
    ["-", "Dropped", " ", "CANCELLED"],
    [">", "Forward", "x", "TODO"],
    ["D", "Date", "x", "TODO"],
    ["?", "Question", "x", "TODO"],
    ["/", "Half Done", "x", "IN_PROGRESS"],
    ["+", "Add", "x", "TODO"],
    ["R", "Research", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["i", "Idea", "x", "TODO"],
    ["B", "Brainstorm", "x", "TODO"],
    ["P", "Pro", "x", "TODO"],
    ["C", "Con", "x", "TODO"],
    ["Q", "Quote", "x", "TODO"],
    ["N", "Note", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ["I", "Information", "x", "TODO"],
    ["p", "Paraphrase", "x", "TODO"],
    ["L", "Location", "x", "TODO"],
    ["E", "Example", "x", "TODO"],
    ["A", "Answer", "x", "TODO"],
    ["r", "Reward", "x", "TODO"],
    ["c", "Choice", "x", "TODO"],
    ["d", "Doing", "x", "IN_PROGRESS"],
    ["T", "Time", "x", "TODO"],
    ["@", "Character / Person", "x", "TODO"],
    ["t", "Talk", "x", "TODO"],
    ["O", "Outline / Plot", "x", "TODO"],
    ["~", "Conflict", "x", "TODO"],
    ["W", "World", "x", "TODO"],
    ["f", "Clue / Find", "x", "TODO"],
    ["F", "Foreshadow", "x", "TODO"],
    ["H", "Favorite / Health", "x", "TODO"],
    ["&", "Symbolism", "x", "TODO"],
    ["s", "Secret", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/LYTModeThemeCollection.ts
function lytModeSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    [">", "Rescheduled", "x", "TODO"],
    ["<", "Scheduled", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    ["?", "Question", "x", "TODO"],
    ["*", "Star", "x", "TODO"],
    ["n", "Note", "x", "TODO"],
    ["l", "Location", "x", "TODO"],
    ["i", "Information", "x", "TODO"],
    ["I", "Idea", "x", "TODO"],
    ["S", "Amount", "x", "TODO"],
    ["p", "Pro", "x", "TODO"],
    ["c", "Con", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ["f", "Fire", "x", "TODO"],
    ["k", "Key", "x", "TODO"],
    ["w", "Win", "x", "TODO"],
    ["u", "Up", "x", "TODO"],
    ["d", "Down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/MinimalThemeCollection.ts
function minimalSupportedStatuses() {
  const zzz = [
    [" ", "to-do", "x", "TODO"],
    ["/", "incomplete", "x", "IN_PROGRESS"],
    ["x", "done", " ", "DONE"],
    ["-", "canceled", " ", "CANCELLED"],
    [">", "forwarded", "x", "TODO"],
    ["<", "scheduling", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["!", "important", "x", "TODO"],
    ["*", "star", "x", "TODO"],
    ['"', "quote", "x", "TODO"],
    ["l", "location", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["i", "information", "x", "TODO"],
    ["S", "savings", "x", "TODO"],
    ["I", "idea", "x", "TODO"],
    ["p", "pros", "x", "TODO"],
    ["c", "cons", "x", "TODO"],
    ["f", "fire", "x", "TODO"],
    ["k", "key", "x", "TODO"],
    ["w", "win", "x", "TODO"],
    ["u", "up", "x", "TODO"],
    ["d", "down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/ThingsThemeCollection.ts
function thingsSupportedStatuses() {
  const zzz = [
    [" ", "to-do", "x", "TODO"],
    ["/", "incomplete", "x", "IN_PROGRESS"],
    ["x", "done", " ", "DONE"],
    ["-", "canceled", " ", "CANCELLED"],
    [">", "forwarded", "x", "TODO"],
    ["<", "scheduling", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["!", "important", "x", "TODO"],
    ["*", "star", "x", "TODO"],
    ['"', "quote", "x", "TODO"],
    ["l", "location", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["i", "information", "x", "TODO"],
    ["S", "savings", "x", "TODO"],
    ["I", "idea", "x", "TODO"],
    ["p", "pros", "x", "TODO"],
    ["c", "cons", "x", "TODO"],
    ["f", "fire", "x", "TODO"],
    ["k", "key", "x", "TODO"],
    ["w", "win", "x", "TODO"],
    ["u", "up", "x", "TODO"],
    ["d", "down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/settingsConfiguration.json
var settingsConfiguration_default = [
  {
    text: "Core Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: "<p>These are the core statuses that Tasks supports natively, with no need for custom CSS styling or theming.</p><p>You can add edit and add your own custom statuses in the section below.</p>"
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertTaskCoreStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  },
  {
    text: "Custom Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: `<p>You should first <b>select and install a CSS Snippet or Theme</b> to style custom checkboxes.</p><p>Then, use the buttons below to set up your custom statuses, to match your chosen CSS checkboxes.</p><p><b>Note</b> Any statuses with the same symbol as any earlier statuses will be ignored. You can confirm the actually loaded statuses by running the 'Create or edit task' command and looking at the Status drop-down.</p><p></p><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Statuses">documentation</a> to get started!</p>`
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertCustomTaskStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  }
];

// src/Config/CustomStatusModal.ts
var import_obsidian15 = require("obsidian");

// src/Statuses/StatusValidator.ts
var StatusValidator = class {
  validate(statusConfiguration) {
    const errors = [];
    errors.push(...this.validateSymbol(statusConfiguration));
    errors.push(...this.validateName(statusConfiguration));
    errors.push(...this.validateNextSymbol(statusConfiguration));
    return errors;
  }
  validateStatusCollectionEntry(entry) {
    const [symbol, _name, nextStatusSymbol, typeAsString] = entry;
    const errors = [];
    errors.push(...this.validateType(typeAsString));
    if (symbol === nextStatusSymbol && typeAsString !== "NON_TASK") {
      errors.push(`Status symbol '${symbol}' toggles to itself`);
    }
    if (errors.length > 0) {
      return errors;
    }
    const configuration = Status.createFromImportedValue(entry).configuration;
    errors.push(...this.validateSymbolTypeConventions(configuration));
    errors.push(...this.validate(configuration));
    return errors;
  }
  validateSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.symbol, "Task Status Symbol");
  }
  validateNextSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.nextStatusSymbol, "Task Next Status Symbol");
  }
  validateName(statusConfiguration) {
    const errors = [];
    if (statusConfiguration.name.length === 0) {
      errors.push("Task Status Name cannot be empty.");
    }
    return errors;
  }
  validateType(symbolName) {
    const statusTypeElement = StatusType[symbolName];
    const errors = [];
    if (!statusTypeElement) {
      errors.push(`Status Type "${symbolName}" is not a valid type`);
    }
    if (statusTypeElement == "EMPTY" /* EMPTY */) {
      errors.push('Status Type "EMPTY" is not permitted in user data');
    }
    return errors;
  }
  validateSymbolTypeConventions(configuration) {
    const errors = [];
    const symbol = configuration.symbol;
    const registry = new StatusRegistry();
    const symbolToSearchFor = symbol === "X" ? "x" : symbol;
    const defaultStatusFromRegistry = registry.bySymbol(symbolToSearchFor);
    if (defaultStatusFromRegistry.type !== "EMPTY" /* EMPTY */) {
      if (configuration.nextStatusSymbol !== defaultStatusFromRegistry.nextStatusSymbol) {
        errors.push(
          `Next Status Symbol for symbol '${symbol}': '${configuration.nextStatusSymbol}' is inconsistent with convention '${defaultStatusFromRegistry.nextStatusSymbol}'`
        );
      }
      if (configuration.type !== defaultStatusFromRegistry.type) {
        errors.push(
          `Status Type for symbol '${symbol}': '${configuration.type}' is inconsistent with convention '${defaultStatusFromRegistry.type}'`
        );
      }
    }
    return errors;
  }
  static validateOneSymbol(symbol, symbolName) {
    const errors = [];
    if (symbol.length === 0) {
      errors.push(`${symbolName} cannot be empty.`);
    }
    if (symbol.length > 1) {
      errors.push(`${symbolName} ("${symbol}") must be a single character.`);
    }
    return errors;
  }
};

// src/Config/CustomStatusModal.ts
var validator = new StatusValidator();
var CustomStatusModal = class extends import_obsidian15.Modal {
  constructor(plugin, statusType, isCoreStatus) {
    super(plugin.app);
    this.plugin = plugin;
    this.saved = false;
    this.error = false;
    this.statusSymbol = statusType.symbol;
    this.statusName = statusType.name;
    this.statusNextSymbol = statusType.nextStatusSymbol;
    this.statusAvailableAsCommand = statusType.availableAsCommand;
    this.type = statusType.type;
    this.isCoreStatus = isCoreStatus;
  }
  statusConfiguration() {
    return new StatusConfiguration(
      this.statusSymbol,
      this.statusName,
      this.statusNextSymbol,
      this.statusAvailableAsCommand,
      this.type
    );
  }
  display() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      const settingDiv = contentEl.createDiv();
      let statusSymbolText;
      new import_obsidian15.Setting(settingDiv).setName("Task Status Symbol").setDesc(
        "This is the character between the square braces. (It can only be edited for Custom statuses, and not Core statuses.)"
      ).addText((text2) => {
        statusSymbolText = text2;
        text2.setValue(this.statusSymbol).onChange((v) => {
          this.statusSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateSymbol(this.statusConfiguration()));
        });
      }).setDisabled(this.isCoreStatus).then((_setting) => {
        CustomStatusModal.setValid(statusSymbolText, validator.validateSymbol(this.statusConfiguration()));
      });
      let statusNameText;
      new import_obsidian15.Setting(settingDiv).setName("Task Status Name").setDesc("This is the friendly name of the task status.").addText((text2) => {
        statusNameText = text2;
        text2.setValue(this.statusName).onChange((v) => {
          this.statusName = v;
          CustomStatusModal.setValid(text2, validator.validateName(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(statusNameText, validator.validateName(this.statusConfiguration()));
      });
      let statusNextSymbolText;
      new import_obsidian15.Setting(settingDiv).setName("Task Next Status Symbol").setDesc("When clicked on this is the symbol that should be used next.").addText((text2) => {
        statusNextSymbolText = text2;
        text2.setValue(this.statusNextSymbol).onChange((v) => {
          this.statusNextSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateNextSymbol(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(
          statusNextSymbolText,
          validator.validateNextSymbol(this.statusConfiguration())
        );
      });
      new import_obsidian15.Setting(settingDiv).setName("Task Status Type").setDesc("Control how the status behaves for searching and toggling.").addDropdown((dropdown) => {
        const types = [
          "TODO" /* TODO */,
          "IN_PROGRESS" /* IN_PROGRESS */,
          "DONE" /* DONE */,
          "CANCELLED" /* CANCELLED */,
          "NON_TASK" /* NON_TASK */
        ];
        types.forEach((s) => {
          dropdown.addOption(s, s);
        });
        dropdown.setValue(this.type).onChange((v) => {
          this.type = Status.getTypeFromStatusTypeString(v);
        });
      });
      if (Status.tasksPluginCanCreateCommandsForStatuses()) {
        new import_obsidian15.Setting(settingDiv).setName("Available as command").setDesc(
          "If enabled this status will be available as a command so you can assign a hotkey and toggle the status using it."
        ).addToggle((toggle) => {
          toggle.setValue(this.statusAvailableAsCommand).onChange((value) => __async(this, null, function* () {
            this.statusAvailableAsCommand = value;
          }));
        });
      }
      const footerEl = contentEl.createDiv();
      const footerButtons = new import_obsidian15.Setting(footerEl);
      footerButtons.addButton((b) => {
        b.setTooltip("Save").setIcon("checkmark").onClick(() => __async(this, null, function* () {
          const errors = validator.validate(this.statusConfiguration());
          if (errors.length > 0) {
            const message = errors.join("\n") + "\n\nFix errors before saving.";
            new import_obsidian15.Notice(message);
            return;
          }
          this.saved = true;
          this.close();
        }));
        return b;
      });
      footerButtons.addExtraButton((b) => {
        b.setIcon("cross").setTooltip("Cancel").onClick(() => {
          this.saved = false;
          this.close();
        });
        return b;
      });
    });
  }
  onOpen() {
    this.display();
  }
  static setValidationError(textInput) {
    textInput.inputEl.addClass("tasks-settings-is-invalid");
  }
  static removeValidationError(textInput) {
    textInput.inputEl.removeClass("tasks-settings-is-invalid");
  }
  static setValid(text2, messages) {
    const valid = messages.length === 0;
    if (valid) {
      CustomStatusModal.removeValidationError(text2);
    } else {
      CustomStatusModal.setValidationError(text2);
    }
  }
};

// src/Config/SettingsTab.ts
var _SettingsTab = class extends import_obsidian16.PluginSettingTab {
  constructor({ plugin }) {
    super(plugin.app, plugin);
    this.customFunctions = {
      insertTaskCoreStatusSettings: this.insertTaskCoreStatusSettings.bind(this),
      insertCustomTaskStatusSettings: this.insertCustomTaskStatusSettings.bind(this)
    };
    this.plugin = plugin;
  }
  saveSettings(update2) {
    return __async(this, null, function* () {
      yield this.plugin.saveSettings();
      if (update2) {
        this.display();
      }
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.addClass("tasks-settings");
    containerEl.createEl("h3", { text: "Tasks Settings" });
    containerEl.createEl("p", {
      cls: "tasks-setting-important",
      text: "Changing any settings requires a restart of obsidian."
    });
    containerEl.createEl("h4", { text: "Task Format Settings" });
    new import_obsidian16.Setting(containerEl).setName("Task Format").setDesc(
      _SettingsTab.createFragmentWithHTML(
        '<p>The format that Tasks uses to read and write tasks.</p><p><b>Important:</b> Tasks currently only supports one format at a time. Selecting Dataview will currently <b>stop Tasks reading its own emoji signifiers</b>.</p><p>See the <a href="https://publish.obsidian.md/tasks/Reference/Task+Formats/About+Task+Formats">documentation</a>.</p>'
      )
    ).addDropdown((dropdown) => {
      for (const key of Object.keys(TASK_FORMATS)) {
        dropdown.addOption(key, TASK_FORMATS[key].displayName);
      }
      dropdown.setValue(getSettings().taskFormat).onChange((value) => __async(this, null, function* () {
        updateSettings({ taskFormat: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Global filter Settings" });
    new import_obsidian16.Setting(containerEl).setName("Global task filter").setDesc(
      _SettingsTab.createFragmentWithHTML(
        '<p><b>Recommended: Leave empty if you want all checklist items in your vault to be tasks managed by this plugin.</b></p><p>Use a global filter if you want Tasks to only act on a subset of your "<code>- [ ]</code>" checklist items, so that a checklist item must include the specified string in its description in order to be considered a task.<p><p>For example, if you set the global filter to <code>#task</code>, the Tasks plugin will only handle checklist items tagged with <code>#task</code>.</br>Other checklist items will remain normal checklist items and not appear in queries or get a done date set.</p><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Global+Filter">documentation</a>.</p>'
      )
    ).addText((text2) => {
      text2.setPlaceholder("e.g. #task or TODO").setValue(GlobalFilter.getInstance().get()).onChange((value) => __async(this, null, function* () {
        updateSettings({ globalFilter: value });
        GlobalFilter.getInstance().set(value);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Remove global filter from description").setDesc(
      "Enabling this removes the string that you set as global filter from the task description when displaying a task."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.removeGlobalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ removeGlobalFilter: value });
        GlobalFilter.getInstance().setRemoveGlobalFilter(value);
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Global Query" });
    makeMultilineTextSetting(
      new import_obsidian16.Setting(containerEl).setDesc(
        _SettingsTab.createFragmentWithHTML(
          '<p>A query that is automatically included at the start of every Tasks block in the vault. Useful for adding default filters, or layout options.</p><p>See the <a href="https://publish.obsidian.md/tasks/Queries/Global+Query">documentation</a>.</p>'
        )
      ).addTextArea((text2) => {
        const settings2 = getSettings();
        text2.inputEl.rows = 4;
        text2.setPlaceholder("# For example...\npath does not include _templates/\nlimit 300\nshow urgency").setValue(settings2.globalQuery).onChange((value) => __async(this, null, function* () {
          updateSettings({ globalQuery: value });
          GlobalQuery.getInstance().set(value);
          yield this.plugin.saveSettings();
        }));
      })
    );
    containerEl.createEl("h4", { text: "Task Statuses" });
    const { headingOpened } = getSettings();
    settingsConfiguration_default.forEach((heading) => {
      this.addOneSettingsBlock(containerEl, heading, headingOpened);
    });
    containerEl.createEl("h4", { text: "Date Settings" });
    new import_obsidian16.Setting(containerEl).setName("Set created date on every added task").setDesc(
      _SettingsTab.createFragmentWithHTML(
        `Enabling this will add a timestamp \u2795 YYYY-MM-DD before other date values, when a task is created with 'Create or edit task', or by completing a recurring task.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Dates#Created+date">documentation</a>.</p>`
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setCreatedDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setCreatedDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Set done date on every completed task").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will add a timestamp \u2705 YYYY-MM-DD at the end when a task is toggled to done.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Dates#Done+date">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setDoneDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setDoneDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Set cancelled date on every cancelled task").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will add a timestamp \u274C YYYY-MM-DD at the end when a task is toggled to cancelled.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Dates#Cancelled+date">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setCancelledDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setCancelledDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Use filename as Scheduled date for undated tasks").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Save time entering Scheduled (\u23F3) dates.</br>If this option is enabled, any undated tasks will be given a default Scheduled date extracted from their file name.</br>The date in the file name must be in one of <code>YYYY-MM-DD</code> or <code>YYYYMMDD</code> formats.</br>Undated tasks have none of Due (\u{1F4C5} ), Scheduled (\u23F3) and Start (\u{1F6EB}) dates.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Use+Filename+as+Default+Date">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.useFilenameAsScheduledDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ useFilenameAsScheduledDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Folders with default Scheduled dates").setDesc(
      "Leave empty if you want to use default Scheduled dates everywhere, or enter a comma-separated list of folders."
    ).addText((input) => __async(this, null, function* () {
      const settings2 = getSettings();
      yield this.plugin.saveSettings();
      input.setValue(_SettingsTab.renderFolderArray(settings2.filenameAsDateFolders)).onChange((value) => __async(this, null, function* () {
        const folders = _SettingsTab.parseCommaSeparatedFolders(value);
        updateSettings({ filenameAsDateFolders: folders });
        yield this.plugin.saveSettings();
      }));
    }));
    containerEl.createEl("h4", { text: "Recurring task Settings" });
    new import_obsidian16.Setting(containerEl).setName("Next recurrence appears on the line below").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will make the next recurrence of a task appear on the line below the completed task. Otherwise the next recurrence will appear before the completed one.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Recurring+Tasks">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const { recurrenceOnNextLine } = getSettings();
      toggle.setValue(recurrenceOnNextLine).onChange((value) => __async(this, null, function* () {
        updateSettings({ recurrenceOnNextLine: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Auto-suggest Settings" });
    new import_obsidian16.Setting(containerEl).setName("Auto-suggest task content").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will open an intelligent suggest menu while typing inside a recognized task line.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Auto-Suggest">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.autoSuggestInEditor).onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestInEditor: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Minimum match length for auto-suggest").setDesc(
      "If higher than 0, auto-suggest will be triggered only when the beginning of any supported keywords is recognized."
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(0, 3, 1).setValue(settings2.autoSuggestMinMatch).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMinMatch: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian16.Setting(containerEl).setName("Maximum number of auto-suggestions to show").setDesc(
      'How many suggestions should be shown when an auto-suggest menu pops up (including the "\u23CE" option).'
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(3, 12, 1).setValue(settings2.autoSuggestMaxItems).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMaxItems: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Dialog Settings" });
    new import_obsidian16.Setting(containerEl).setName("Provide access keys in dialogs").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'If the access keys (keyboard shortcuts) for various controls in dialog boxes conflict with system keyboard shortcuts or assistive technology functionality that is important for you, you may want to deactivate them here.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Create+or+edit+Task#Keyboard+shortcuts">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.provideAccessKeys).onChange((value) => __async(this, null, function* () {
        updateSettings({ provideAccessKeys: value });
        yield this.plugin.saveSettings();
      }));
    });
  }
  addOneSettingsBlock(containerEl, heading, headingOpened) {
    const detailsContainer = containerEl.createEl("details", {
      cls: "tasks-nested-settings",
      attr: __spreadValues({}, heading.open || headingOpened[heading.text] ? { open: true } : {})
    });
    detailsContainer.empty();
    detailsContainer.ontoggle = () => {
      headingOpened[heading.text] = detailsContainer.open;
      updateSettings({ headingOpened });
      this.plugin.saveSettings();
    };
    const summary = detailsContainer.createEl("summary");
    new import_obsidian16.Setting(summary).setHeading().setName(heading.text);
    summary.createDiv("collapser").createDiv("handle");
    if (heading.notice !== null) {
      const notice = detailsContainer.createEl("div", {
        cls: heading.notice.class,
        text: heading.notice.text
      });
      if (heading.notice.html !== null) {
        notice.insertAdjacentHTML("beforeend", heading.notice.html);
      }
    }
    heading.settings.forEach((setting) => {
      if (setting.featureFlag !== "" && !isFeatureEnabled(setting.featureFlag)) {
        return;
      }
      if (setting.type === "checkbox") {
        new import_obsidian16.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addToggle((toggle) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          toggle.setValue(settings2.generalSettings[setting.settingName]).onChange((value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          }));
        });
      } else if (setting.type === "text") {
        new import_obsidian16.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addText((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian16.debounce)(onChange, 500, true));
        });
      } else if (setting.type === "textarea") {
        new import_obsidian16.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addTextArea((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian16.debounce)(onChange, 500, true));
          text2.inputEl.rows = 8;
          text2.inputEl.cols = 40;
        });
      } else if (setting.type === "function") {
        this.customFunctions[setting.settingName](detailsContainer, this);
      }
      if (setting.notice !== null) {
        const notice = detailsContainer.createEl("p", {
          cls: setting.notice.class,
          text: setting.notice.text
        });
        if (setting.notice.html !== null) {
          notice.insertAdjacentHTML("beforeend", setting.notice.html);
        }
      }
    });
  }
  static parseCommaSeparatedFolders(input) {
    return input.split(",").map((folder) => folder.trim()).map((folder) => folder.replace(/^\/|\/$/g, "")).filter((folder) => folder !== "");
  }
  static renderFolderArray(folders) {
    return folders.join(",");
  }
  insertTaskCoreStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.coreStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.coreStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        true
      );
    });
    const createMermaidDiagram = new import_obsidian16.Setting(containerEl).addButton((button) => {
      const buttonName = "Review and check your Statuses";
      button.setButtonText(buttonName).setCta().onClick(() => __async(this, null, function* () {
        const now = window.moment();
        const formattedDateTime = now.format("YYYY-MM-DD HH-mm-ss");
        const filename = `Tasks Plugin - ${buttonName} ${formattedDateTime}.md`;
        const version = this.plugin.manifest.version;
        const statusRegistry = StatusRegistry.getInstance();
        const fileContent = createStatusRegistryReport(statusSettings, statusRegistry, buttonName, version);
        const file = yield app.vault.create(filename, fileContent);
        const leaf = this.app.workspace.getLeaf(true);
        yield leaf.openFile(file);
      }));
      button.setTooltip(
        "Create a new file in the root of the vault, containing a Mermaid diagram of the current status settings."
      );
    });
    createMermaidDiagram.infoEl.remove();
  }
  insertCustomTaskStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.customStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.customStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        false
      );
    });
    containerEl.createEl("div");
    const setting = new import_obsidian16.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add New Task Status").setCta().onClick(() => __async(this, null, function* () {
        StatusSettings.addStatus(
          statusSettings.customStatuses,
          new StatusConfiguration("", "", "", false, "TODO" /* TODO */)
        );
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    setting.infoEl.remove();
    const themes = [
      ["AnuPpuccin Theme", anuppuccinSupportedStatuses()],
      ["Aura Theme", auraSupportedStatuses()],
      ["Ebullientworks Theme", ebullientworksSupportedStatuses()],
      ["ITS Theme & SlRvb Checkboxes", itsSupportedStatuses()],
      ["Minimal Theme", minimalSupportedStatuses()],
      ["Things Theme", thingsSupportedStatuses()],
      ["LYT Mode Theme (Dark mode only)", lytModeSupportedStatuses()]
    ];
    for (const [name, collection] of themes) {
      const addStatusesSupportedByThisTheme = new import_obsidian16.Setting(containerEl).addButton((button) => {
        const label = `${name}: Add ${collection.length} supported Statuses`;
        button.setButtonText(label).onClick(() => __async(this, null, function* () {
          yield addCustomStatesToSettings(collection, statusSettings, settings2);
        }));
      });
      addStatusesSupportedByThisTheme.infoEl.remove();
    }
    const addAllUnknownStatuses = new import_obsidian16.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add All Unknown Status Types").setCta().onClick(() => __async(this, null, function* () {
        const tasks = this.plugin.getTasks();
        const allStatuses = tasks.map((task) => {
          return task.status;
        });
        const unknownStatuses = StatusRegistry.getInstance().findUnknownStatuses(allStatuses);
        if (unknownStatuses.length === 0) {
          return;
        }
        unknownStatuses.forEach((s) => {
          StatusSettings.addStatus(statusSettings.customStatuses, s);
        });
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    addAllUnknownStatuses.infoEl.remove();
    const clearCustomStatuses = new import_obsidian16.Setting(containerEl).addButton((button) => {
      button.setButtonText("Reset Custom Status Types to Defaults").setWarning().onClick(() => __async(this, null, function* () {
        StatusSettings.resetAllCustomStatuses(statusSettings);
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    clearCustomStatuses.infoEl.remove();
  }
};
var SettingsTab = _SettingsTab;
SettingsTab.createFragmentWithHTML = (html) => createFragment((documentFragment) => documentFragment.createDiv().innerHTML = html);
function createRowForTaskStatus(containerEl, statusType, statuses, statusSettings, settings2, plugin, isCoreStatus) {
  const taskStatusPreview = containerEl.createEl("pre");
  taskStatusPreview.addClass("row-for-status");
  taskStatusPreview.textContent = new Status(statusType).previewText();
  const setting = new import_obsidian16.Setting(containerEl);
  setting.infoEl.replaceWith(taskStatusPreview);
  if (!isCoreStatus) {
    setting.addExtraButton((extra) => {
      extra.setIcon("cross").setTooltip("Delete").onClick(() => __async(this, null, function* () {
        if (StatusSettings.deleteStatus(statuses, statusType)) {
          yield updateAndSaveStatusSettings(statusSettings, settings2);
        }
      }));
    });
  }
  setting.addExtraButton((extra) => {
    extra.setIcon("pencil").setTooltip("Edit").onClick(() => __async(this, null, function* () {
      const modal = new CustomStatusModal(plugin, statusType, isCoreStatus);
      modal.onClose = () => __async(this, null, function* () {
        if (modal.saved) {
          if (StatusSettings.replaceStatus(statuses, statusType, modal.statusConfiguration())) {
            yield updateAndSaveStatusSettings(statusSettings, settings2);
          }
        }
      });
      modal.open();
    }));
  });
  setting.infoEl.remove();
}
function addCustomStatesToSettings(supportedStatuses, statusSettings, settings2) {
  return __async(this, null, function* () {
    const notices = StatusSettings.bulkAddStatusCollection(statusSettings, supportedStatuses);
    notices.forEach((notice) => {
      new import_obsidian16.Notice(notice);
    });
    yield updateAndSaveStatusSettings(statusSettings, settings2);
  });
}
function updateAndSaveStatusSettings(statusTypes, settings2) {
  return __async(this, null, function* () {
    updateSettings({
      statusSettings: statusTypes
    });
    StatusSettings.applyToStatusRegistry(statusTypes, StatusRegistry.getInstance());
    yield settings2.saveSettings(true);
  });
}
function makeMultilineTextSetting(setting) {
  const { settingEl, infoEl, controlEl } = setting;
  const textEl = controlEl.querySelector("textarea");
  if (textEl === null) {
    return;
  }
  settingEl.style.display = "block";
  infoEl.style.marginRight = "0px";
  textEl.style.minWidth = "-webkit-fill-available";
}

// src/Suggestor/EditorSuggestorPopup.ts
var import_obsidian17 = require("obsidian");
var EditorSuggestor = class extends import_obsidian17.EditorSuggest {
  constructor(app2, settings2, plugin) {
    super(app2);
    this.settings = settings2;
    this.plugin = plugin;
    app2.scope.register([], "Tab", () => {
      var _a;
      const editor = (_a = this.context) == null ? void 0 : _a.editor;
      if (editor) {
        editor.exec("indentMore");
        return false;
      }
      return true;
    });
  }
  onTrigger(cursor, editor, _file) {
    if (!this.settings.autoSuggestInEditor)
      return null;
    const line = editor.getLine(cursor.line);
    if (canSuggestForLine(line, cursor, editor)) {
      return {
        start: { line: cursor.line, ch: 0 },
        end: {
          line: cursor.line,
          ch: line.length
        },
        query: line
      };
    }
    return null;
  }
  getSuggestions(context) {
    var _a, _b, _c;
    const line = context.query;
    const currentCursor = context.editor.getCursor();
    const allTasks = this.plugin.getTasks();
    const taskToSuggestFor = allTasks.find(
      (task) => task.taskLocation.path == context.file.path && task.taskLocation.lineNumber == currentCursor.line
    );
    const suggestions = (_c = (_b = (_a = getUserSelectedTaskFormat()).buildSuggestions) == null ? void 0 : _b.call(
      _a,
      line,
      currentCursor.ch,
      this.settings,
      allTasks,
      taskToSuggestFor
    )) != null ? _c : [];
    return suggestions.map((s) => __spreadProps(__spreadValues({}, s), { context }));
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const editor = value.context.editor;
      if (value.suggestionType === "empty") {
        this.close();
        const eventClone = new KeyboardEvent("keydown", {
          code: "Enter",
          key: "Enter"
        });
        (_b = (_a = editor == null ? void 0 : editor.cm) == null ? void 0 : _a.contentDOM) == null ? void 0 : _b.dispatchEvent(eventClone);
        return;
      }
      if (value.taskItDependsOn != null) {
        const newTask = ensureTaskHasId(
          value.taskItDependsOn,
          this.plugin.getTasks().map((task) => task.id)
        );
        value.appendText += ` ${newTask.id}`;
        if (value.context.file.basename == newTask.filename) {
          console.log(value.taskItDependsOn.toFileLineString());
          const start = {
            line: value.taskItDependsOn.lineNumber,
            ch: 0
          };
          const end = {
            line: value.taskItDependsOn.lineNumber,
            ch: value.taskItDependsOn.toFileLineString().length
          };
          value.context.editor.replaceRange(newTask.toFileLineString(), start, end);
        } else {
          replaceTaskWithTasks({ originalTask: value.taskItDependsOn, newTasks: newTask });
        }
      }
      const currentCursor = value.context.editor.getCursor();
      const replaceFrom = {
        line: currentCursor.line,
        ch: (_c = value.insertAt) != null ? _c : currentCursor.ch
      };
      const replaceTo = value.insertSkip ? {
        line: currentCursor.line,
        ch: replaceFrom.ch + value.insertSkip
      } : void 0;
      value.context.editor.replaceRange(value.appendText, replaceFrom, replaceTo);
      value.context.editor.setCursor({
        line: currentCursor.line,
        ch: replaceFrom.ch + value.appendText.length
      });
    });
  }
};

// src/Api/createTaskLineModal.ts
var createTaskLineModal = (app2, taskModalFactory) => {
  let resolvePromise;
  const waitForClose = new Promise((resolve, _) => {
    resolvePromise = resolve;
  });
  const onSubmit = (updatedTasks) => {
    const line = updatedTasks.map((task) => task.toFileLineString()).join("\n");
    resolvePromise(line);
  };
  const taskModal = taskModalFactory(app2, onSubmit);
  taskModal.open();
  return waitForClose;
};

// src/Api/createTaskLineModalHelper.ts
var defaultTaskModalFactory = (app2, onSubmit) => {
  const task = taskFromLine({ line: "", path: "" });
  return new TaskModal({ app: app2, task, onSubmit, allTasks: [] });
};

// src/Api/index.ts
var tasksApiV1 = (app2) => {
  return {
    createTaskLineModal: () => {
      return createTaskLineModal(app2, defaultTaskModalFactory);
    },
    executeToggleTaskDoneCommand: (line, path) => toggleLine(line, path).text
  };
};

// src/main.ts
var TasksPlugin = class extends import_obsidian18.Plugin {
  get apiV1() {
    return tasksApiV1(app);
  }
  onload() {
    return __async(this, null, function* () {
      logging.registerConsoleLogger();
      log("info", `loading plugin "${this.manifest.name}" v${this.manifest.version}`);
      yield this.loadSettings();
      const { loggingOptions } = getSettings();
      logging.configure(loggingOptions);
      this.addSettingTab(new SettingsTab({ plugin: this }));
      initializeFile({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        workspace: this.app.workspace
      });
      yield this.loadTaskStatuses();
      const events = new TasksEvents({ obsidianEvents: this.app.workspace });
      this.cache = new Cache2({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        events
      });
      this.inlineRenderer = new InlineRenderer({ plugin: this });
      this.queryRenderer = new QueryRenderer({ plugin: this, events });
      this.registerEditorExtension(newLivePreviewExtension());
      this.registerEditorSuggest(new EditorSuggestor(this.app, getSettings(), this));
      new Commands({ plugin: this });
    });
  }
  loadTaskStatuses() {
    return __async(this, null, function* () {
      const { statusSettings } = getSettings();
      StatusSettings.applyToStatusRegistry(statusSettings, StatusRegistry.getInstance());
    });
  }
  onunload() {
    var _a;
    log("info", `unloading plugin "${this.manifest.name}" v${this.manifest.version}`);
    (_a = this.cache) == null ? void 0 : _a.unload();
  }
  loadSettings() {
    return __async(this, null, function* () {
      let newSettings = yield this.loadData();
      updateSettings(newSettings);
      newSettings = getSettings();
      GlobalFilter.getInstance().set(newSettings.globalFilter);
      GlobalFilter.getInstance().setRemoveGlobalFilter(newSettings.removeGlobalFilter);
      GlobalQuery.getInstance().set(newSettings.globalQuery);
      yield this.loadTaskStatuses();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(getSettings());
    });
  }
  getTasks() {
    if (this.cache === void 0) {
      return [];
    } else {
      return this.cache.getTasks();
    }
  }
};
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy91dGlscy9wYXR0ZXJuLnRzIiwgIm5vZGVfbW9kdWxlcy9kYXlqcy9kYXlqcy5taW4uanMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jYWxjdWxhdGlvbi95ZWFycy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vcXVhcnRlck9mWWVhci5qcyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3V0aWxzL2RheWpzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdGltZXpvbmUudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9yZXN1bHRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvQWJzdHJhY3RQYXJzZXJXaXRoV29yZEJvdW5kYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5DYXN1YWxZZWFyTW9udGhEYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5TbGFzaE1vbnRoRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvQWJzdHJhY3RUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdXRpbHMvdGltZXVuaXRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lVW5pdExhdGVyRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL2Fic3RyYWN0UmVmaW5lcnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvQWJzdHJhY3RNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3JlZmluZXJzL0VOTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24vbWVyZ2luZ0NhbGN1bGF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0Fic3RyYWN0TWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3JlZmluZXJzL0VOTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRXh0cmFjdFRpbWV6b25lQWJiclJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRXh0cmFjdFRpbWV6b25lT2Zmc2V0UmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9PdmVybGFwUmVtb3ZhbFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRm9yd2FyZERhdGVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL1VubGlrZWx5Rm9ybWF0RmlsdGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvSVNPRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL01lcmdlV2Vla2RheUNvbXBvbmVudFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb25maWd1cmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9jYXN1YWxSZWZlcmVuY2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTkNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jYWxjdWxhdGlvbi93ZWVrcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5SZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jaHJvbm8udHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcGFyc2Vycy9TbGFzaERhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lVW5pdENhc3VhbFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlUmVsYXRpdmVEYXRlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVNwZWNpZmljVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3JlZmluZXJzL0RFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9yZWZpbmVycy9ERU1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERUNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVUaW1lVW5pdFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUkNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3JlZmluZXJzL0ZSTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3JlZmluZXJzL0ZSTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSU3BlY2lmaWNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lVW5pdFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9wYXJzZXJzL0pQU3RhbmRhcmRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL3JlZmluZXJzL0pQTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9wYXJzZXJzL0pQQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcmVmaW5lcnMvUFRNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcmVmaW5lcnMvUFRNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3JlZmluZXJzL05MTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9yZWZpbmVycy9OTE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTE1vbnRoTmFtZU1pZGRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTE1vbnRoTmFtZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFNsYXNoTW9udGhGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbFllYXJNb250aERheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbERhdGVUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRMYXRlckZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnREZWFkbGluZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFJlbGF0aW9uV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50V2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9yZWZpbmVycy9aSEhhbnRNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcmVmaW5lcnMvWkhIYW50TWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc0RhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNEZWFkbGluZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1JlbGF0aW9uV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1RpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9yZWZpbmVycy9aSEhhbnNNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcmVmaW5lcnMvWkhIYW5zTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lVW5pdFdpdGhpbkZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVU1vbnRoTmFtZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3JlZmluZXJzL1JVTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9yZWZpbmVycy9SVU1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVUNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMi9saWIvZXZlbnRlbWl0dGVyMi5qcyIsICJub2RlX21vZHVsZXMvbXVzdGFjaGUtdmFsaWRhdG9yL2Rpc3QvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9jb25zdC5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvbGV4L2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9sZXgvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2xleC9sZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3BhcnNlL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvZXZhbHVhdGUvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2V2YWx1YXRlL2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9ldmFsdWF0ZS9ldmFsdWF0ZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvaW5kZXguanMiLCAic3JjL21haW4udHMiLCAic3JjL09ic2lkaWFuL0NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy1tdXRleC9pbmRleC5tanMiLCAic3JjL1NjcmlwdGluZy9UYXNrc0ZpbGUudHMiLCAic3JjL1F1ZXJ5L0RhdGVQYXJzZXIudHMiLCAic3JjL1F1ZXJ5L0RhdGVSYW5nZS50cyIsICJzcmMvbGliL0RhdGVBYmJyZXZpYXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvd2Vla2RheS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldXRpbC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWxsYmFja2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ubHAvaTE4bi50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC90b3RleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ubHAvcGFyc2V0ZXh0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvdHlwZXMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ubHAvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldGltZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3BhcnNlb3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3BhcnNlc3RyaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvZGF0ZXdpdGh6b25lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvb3B0aW9uc3Rvc3RyaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvY2FjaGUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9tYXNrcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL3llYXJpbmZvLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8vbW9udGhpbmZvLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8vZWFzdGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8vaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyL3Bvc2xpc3QudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcnJ1bGUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcnJ1bGVzdHIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXNldC50cyIsICJzcmMvbGliL0RhdGVUb29scy50cyIsICJzcmMvVGFzay9SZWN1cnJlbmNlLnRzIiwgInNyYy9MYXlvdXQvVGFza0xheW91dE9wdGlvbnMudHMiLCAic3JjL1Rhc2svVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50cyIsICJzcmMvVGFza1NlcmlhbGl6ZXIvRGVmYXVsdFRhc2tTZXJpYWxpemVyLnRzIiwgInNyYy9UYXNrL1Rhc2tEZXBlbmRlbmN5LnRzIiwgInNyYy9saWIvUmVnRXhwVG9vbHMudHMiLCAic3JjL0NvbmZpZy9HbG9iYWxGaWx0ZXIudHMiLCAic3JjL3VpL0RlcGVuZGVuY3lIZWxwZXJzLnRzIiwgInNyYy9TdWdnZXN0b3IvU3VnZ2VzdG9yLnRzIiwgInNyYy9UYXNrU2VyaWFsaXplci9EYXRhdmlld1Rhc2tTZXJpYWxpemVyLnRzIiwgInNyYy9TdGF0dXNlcy9TdGF0dXNDb25maWd1cmF0aW9uLnRzIiwgInNyYy9TdGF0dXNlcy9TdGF0dXMudHMiLCAic3JjL0NvbmZpZy9EZWJ1Z1NldHRpbmdzLnRzIiwgInNyYy9Db25maWcvU3RhdHVzU2V0dGluZ3MudHMiLCAic3JjL0NvbmZpZy9GZWF0dXJlLnRzIiwgInNyYy9Db25maWcvU2V0dGluZ3MudHMiLCAic3JjL2xpYi9IVE1MQ2hhcmFjdGVyRW50aXRpZXMudHMiLCAic3JjL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5LnRzIiwgInNyYy9TY3JpcHRpbmcvVGFza3NEYXRlLnRzIiwgInNyYy9saWIvUHJvcGVydHlDYXRlZ29yeS50cyIsICJzcmMvbGliL1ByaW9yaXR5VG9vbHMudHMiLCAic3JjL2xpYi9sb2dnaW5nLnRzIiwgInNyYy9saWIvTG9nVGFza3NIZWxwZXIudHMiLCAic3JjL1Rhc2svRGF0ZUZhbGxiYWNrLnRzIiwgInNyYy9UYXNrL0xpc3RJdGVtLnRzIiwgInNyYy9UYXNrL1VyZ2VuY3kudHMiLCAic3JjL1Rhc2svVGFzay50cyIsICJzcmMvbGliL0xhenkudHMiLCAic3JjL1Rhc2svVGFza0xvY2F0aW9uLnRzIiwgInNyYy9Db21tYW5kcy9DcmVhdGVPckVkaXQudHMiLCAic3JjL09ic2lkaWFuL1Rhc2tNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2Lm1qcyIsICJzcmMvT2JzaWRpYW4vRmlsZS50cyIsICJzcmMvbGliL01vY2tEYXRhQ3JlYXRvci50cyIsICJzcmMvbGliL1N0cmluZ0hlbHBlcnMudHMiLCAic3JjL3VpL0VkaXRUYXNrSGVscGVycy50cyIsICJzcmMvdWkvRGF0ZUVkaXRvci5zdmVsdGUiLCAibm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcyIsICJub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsICJub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCAibm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzIiwgInNyYy91aS9EZXBlbmRlbmN5LnN2ZWx0ZSIsICJzcmMvdWkvUmVjdXJyZW5jZUVkaXRvci5zdmVsdGUiLCAic3JjL3VpL1N0YXR1c0VkaXRvci5zdmVsdGUiLCAic3JjL3VpL0VkaXRUYXNrLnN2ZWx0ZSIsICJzcmMvQ29tbWFuZHMvQ3JlYXRlT3JFZGl0VGFza1BhcnNlci50cyIsICJzcmMvQ29tbWFuZHMvVG9nZ2xlRG9uZS50cyIsICJzcmMvQ29tbWFuZHMvaW5kZXgudHMiLCAic3JjL0xheW91dC9RdWVyeUxheW91dE9wdGlvbnMudHMiLCAic3JjL2xpYi9FeGNlcHRpb25Ub29scy50cyIsICJub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUubWpzIiwgInNyYy9TY3JpcHRpbmcvRXhwYW5kUGxhY2Vob2xkZXJzLnRzIiwgInNyYy9TY3JpcHRpbmcvUXVlcnlDb250ZXh0LnRzIiwgInNyYy9RdWVyeS9FeHBsYWluL0V4cGxhaW5lci50cyIsICJzcmMvUXVlcnkvRXhwbGFpbi9FeHBsYW5hdGlvbi50cyIsICJzcmMvUXVlcnkvTWF0Y2hlcnMvSVN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1N1YnN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1JlZ2V4TWF0Y2hlci50cyIsICJzcmMvUXVlcnkvU29ydC9Tb3J0ZXIudHMiLCAic3JjL1F1ZXJ5L0dyb3VwL0dyb3VwZXIudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWVsZC50cyIsICJzcmMvUXVlcnkvU3RhdGVtZW50LnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVyLnRzIiwgInNyYy9RdWVyeS9RdWVyeUNvbXBvbmVudE9yRXJyb3IudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJPckVycm9yTWVzc2FnZS50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1RleHRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0Rlc2NyaXB0aW9uRmllbGQudHMiLCAic3JjL2xpYi9UZW1wbGF0aW5nUGx1Z2luVG9vbHMudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJJbnN0cnVjdGlvbi50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0ZpbHRlckluc3RydWN0aW9ucy50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0RhdGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0NyZWF0ZWREYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Eb25lRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRHVlRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvUmVtaW5kZXJEYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRXhjbHVkZVN1Ykl0ZW1zRmllbGQudHMiLCAic3JjL1NjcmlwdGluZy9FeHByZXNzaW9uLnRzIiwgInNyYy9TY3JpcHRpbmcvVGFza0V4cHJlc3Npb24udHMiLCAic3JjL2xpYi9UeXBlRGV0ZWN0aW9uLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRnVuY3Rpb25GaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0hlYWRpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1BhdGhGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1ByaW9yaXR5RmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TY2hlZHVsZWREYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TdGFydERhdGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0hhcHBlbnNEYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9SZWN1cnJpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvTXVsdGlUZXh0RmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9UYWdzRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Cb29sZWFuRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Cb29sZWFuRGVsaW1pdGVycy50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0Jvb2xlYW5QcmVwcm9jZXNzb3IudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWxlbmFtZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvVXJnZW5jeUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvU3RhdHVzTmFtZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvU3RhdHVzVHlwZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvUmVjdXJyZW5jZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRm9sZGVyRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Sb290RmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9CYWNrbGlua0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQ2FuY2VsbGVkRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQmxvY2tpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0lkRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9EZXBlbmRzT25GaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyUGFyc2VyLnRzIiwgInNyYy9RdWVyeS9Hcm91cC9Hcm91cERpc3BsYXlIZWFkaW5nLnRzIiwgInNyYy9RdWVyeS9Hcm91cC9Hcm91cERpc3BsYXlIZWFkaW5nU2VsZWN0b3IudHMiLCAic3JjL1F1ZXJ5L0dyb3VwL0dyb3VwaW5nVHJlZU5vZGUudHMiLCAic3JjL1F1ZXJ5L0dyb3VwL1Rhc2tHcm91cGluZ1RyZWUudHMiLCAic3JjL1F1ZXJ5L0dyb3VwL1Rhc2tHcm91cC50cyIsICJzcmMvUXVlcnkvR3JvdXAvVGFza0dyb3Vwcy50cyIsICJzcmMvUXVlcnkvU2VhcmNoSW5mby50cyIsICJzcmMvUXVlcnkvUXVlcnlSZXN1bHQudHMiLCAic3JjL1F1ZXJ5L1NjYW5uZXIudHMiLCAic3JjL1F1ZXJ5L1NvcnQvU29ydC50cyIsICJzcmMvUXVlcnkvUXVlcnkudHMiLCAic3JjL0NvbmZpZy9HbG9iYWxRdWVyeS50cyIsICJzcmMvT2JzaWRpYW4vVGFza3NFdmVudHMudHMiLCAic3JjL09ic2lkaWFuL0lubGluZVJlbmRlcmVyLnRzIiwgInNyYy9SZW5kZXJlci9UYXNrTGluZVJlbmRlcmVyLnRzIiwgInNyYy91aS9FZGl0SW5zdHJ1Y3Rpb25zL1N0YXR1c0luc3RydWN0aW9ucy50cyIsICJzcmMvdWkvTWVudXMvVGFza0VkaXRpbmdNZW51LnRzIiwgInNyYy91aS9NZW51cy9TdGF0dXNNZW51LnRzIiwgInNyYy9SZW5kZXJlci9UYXNrRmllbGRSZW5kZXJlci50cyIsICJzcmMvT2JzaWRpYW4vTGl2ZVByZXZpZXdFeHRlbnNpb24udHMiLCAic3JjL1JlbmRlcmVyL1F1ZXJ5UmVuZGVyZXIudHMiLCAic3JjL0xheW91dC9MYXlvdXRIZWxwZXJzLnRzIiwgInNyYy9MYXlvdXQvUXVlcnlMYXlvdXQudHMiLCAic3JjL2xpYi9RdWVyeVJlbmRlcmVySGVscGVyLnRzIiwgInNyYy9TY3JpcHRpbmcvUG9zdHBvbmVyLnRzIiwgInNyYy9MYXlvdXQvVGFza0xheW91dC50cyIsICJzcmMvdWkvTWVudXMvUG9zdHBvbmVNZW51LnRzIiwgInNyYy9saWIvUGVyZm9ybWFuY2VUcmFja2VyLnRzIiwgInNyYy9Db25maWcvU2V0dGluZ3NUYWIudHMiLCAic3JjL2xpYi9NYXJrZG93blRhYmxlLnRzIiwgInNyYy9TdGF0dXNlcy9TdGF0dXNTZXR0aW5nc1JlcG9ydC50cyIsICJzcmMvU3RhdHVzZXMvU3RhdHVzUmVnaXN0cnlSZXBvcnQudHMiLCAic3JjL0NvbmZpZy9UaGVtZXMvQW51UHB1Y2NpblRoZW1lQ29sbGVjdGlvbi50cyIsICJzcmMvQ29uZmlnL1RoZW1lcy9BdXJhVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL0VidWxsaWVudHdvcmtzVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL0lUU1RoZW1lQ29sbGVjdGlvbi50cyIsICJzcmMvQ29uZmlnL1RoZW1lcy9MWVRNb2RlVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL01pbmltYWxUaGVtZUNvbGxlY3Rpb24udHMiLCAic3JjL0NvbmZpZy9UaGVtZXMvVGhpbmdzVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvQ3VzdG9tU3RhdHVzTW9kYWwudHMiLCAic3JjL1N0YXR1c2VzL1N0YXR1c1ZhbGlkYXRvci50cyIsICJzcmMvU3VnZ2VzdG9yL0VkaXRvclN1Z2dlc3RvclBvcHVwLnRzIiwgInNyYy9BcGkvY3JlYXRlVGFza0xpbmVNb2RhbC50cyIsICJzcmMvQXBpL2NyZWF0ZVRhc2tMaW5lTW9kYWxIZWxwZXIudHMiLCAic3JjL0FwaS9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFtudWxsLCAiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSxEPVwiZW5cIix2PXt9O3ZbRF09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24odCxlLG4pe3ZhciByO2lmKCF0KXJldHVybiBEO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXZbdF0mJihyPXQpLGUmJih2W3RdPWUscj10KTtlbHNle3ZhciBpPXQubmFtZTt2W2ldPXQscj1pfXJldHVybiFuJiZyJiYoRD1yKSxyfHwhbiYmRH0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIEQ9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLHY9KHk8RD95Kzc6eSktRDtyZXR1cm4gJChyP20tdjptKyg2LXYpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zdWJzdHIoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sRD1PLm0odGhpcyxNKTtyZXR1cm4gRD0obD17fSxsW2NdPUQvMTIsbFtmXT1ELGxbaF09RC8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD9EOk8uYShEKX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdlt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxiPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1iLFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtiW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj12W0RdLHcuTHM9dix3LnA9e30sd30pKTsiLCBudWxsLCBudWxsLCAiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUobik6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fcXVhcnRlck9mWWVhcj1uKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9XCJtb250aFwiLG49XCJxdWFydGVyXCI7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHI9aS5wcm90b3R5cGU7ci5xdWFydGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiR1dGlscygpLnUodCk/TWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkrMSkvMyk6dGhpcy5tb250aCh0aGlzLm1vbnRoKCklMyszKih0LTEpKX07dmFyIHM9ci5hZGQ7ci5hZGQ9ZnVuY3Rpb24oZSxpKXtyZXR1cm4gZT1OdW1iZXIoZSksdGhpcy4kdXRpbHMoKS5wKGkpPT09bj90aGlzLmFkZCgzKmUsdCk6cy5iaW5kKHRoaXMpKGUsaSl9O3ZhciB1PXIuc3RhcnRPZjtyLnN0YXJ0T2Y9ZnVuY3Rpb24oZSxpKXt2YXIgcj10aGlzLiR1dGlscygpLHM9ISFyLnUoaSl8fGk7aWYoci5wKGUpPT09bil7dmFyIG89dGhpcy5xdWFydGVyKCktMTtyZXR1cm4gcz90aGlzLm1vbnRoKDMqbykuc3RhcnRPZih0KS5zdGFydE9mKFwiZGF5XCIpOnRoaXMubW9udGgoMypvKzIpLmVuZE9mKHQpLmVuZE9mKFwiZGF5XCIpfXJldHVybiB1LmJpbmQodGhpcykoZSxpKX19fSkpOyIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIvKiFcbiAqIEV2ZW50RW1pdHRlcjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWoxbngvRXZlbnRFbWl0dGVyMlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBoaWoxbnhcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuOyFmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgdmFyIGhhc093blByb3BlcnR5PSBPYmplY3QuaGFzT3duUHJvcGVydHk7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiBfaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfTtcbiAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbiAgdmFyIG5leHRUaWNrU3VwcG9ydGVkPSB0eXBlb2YgcHJvY2Vzcz09J29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2s9PSdmdW5jdGlvbic7XG4gIHZhciBzeW1ib2xzU3VwcG9ydGVkPSB0eXBlb2YgU3ltYm9sPT09J2Z1bmN0aW9uJztcbiAgdmFyIHJlZmxlY3RTdXBwb3J0ZWQ9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JztcbiAgdmFyIHNldEltbWVkaWF0ZVN1cHBvcnRlZD0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIF9zZXRJbW1lZGlhdGU9IHNldEltbWVkaWF0ZVN1cHBvcnRlZCA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXQ7XG4gIHZhciBvd25LZXlzPSBzeW1ib2xzU3VwcG9ydGVkPyAocmVmbGVjdFN1cHBvcnRlZCAmJiB0eXBlb2YgUmVmbGVjdC5vd25LZXlzPT09J2Z1bmN0aW9uJz8gUmVmbGVjdC5vd25LZXlzIDogZnVuY3Rpb24ob2JqKXtcbiAgICB2YXIgYXJyPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuICAgIGFyci5wdXNoLmFwcGx5KGFyciwgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbiAgICByZXR1cm4gYXJyO1xuICB9KSA6IE9iamVjdC5rZXlzO1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgaWYgKHRoaXMuX2NvbmYpIHtcbiAgICAgIGNvbmZpZ3VyZS5jYWxsKHRoaXMsIHRoaXMuX2NvbmYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZShjb25mKSB7XG4gICAgaWYgKGNvbmYpIHtcbiAgICAgIHRoaXMuX2NvbmYgPSBjb25mO1xuXG4gICAgICBjb25mLmRlbGltaXRlciAmJiAodGhpcy5kZWxpbWl0ZXIgPSBjb25mLmRlbGltaXRlcik7XG5cbiAgICAgIGlmKGNvbmYubWF4TGlzdGVuZXJzIT09dW5kZWZpbmVkKXtcbiAgICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnM9IGNvbmYubWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBjb25mLndpbGRjYXJkICYmICh0aGlzLndpbGRjYXJkID0gY29uZi53aWxkY2FyZCk7XG4gICAgICBjb25mLm5ld0xpc3RlbmVyICYmICh0aGlzLl9uZXdMaXN0ZW5lciA9IGNvbmYubmV3TGlzdGVuZXIpO1xuICAgICAgY29uZi5yZW1vdmVMaXN0ZW5lciAmJiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSBjb25mLnJlbW92ZUxpc3RlbmVyKTtcbiAgICAgIGNvbmYudmVyYm9zZU1lbW9yeUxlYWsgJiYgKHRoaXMudmVyYm9zZU1lbW9yeUxlYWsgPSBjb25mLnZlcmJvc2VNZW1vcnlMZWFrKTtcbiAgICAgIGNvbmYuaWdub3JlRXJyb3JzICYmICh0aGlzLmlnbm9yZUVycm9ycyA9IGNvbmYuaWdub3JlRXJyb3JzKTtcblxuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lclRyZWUgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2dQb3NzaWJsZU1lbW9yeUxlYWsoY291bnQsIGV2ZW50TmFtZSkge1xuICAgIHZhciBlcnJvck1zZyA9ICcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICcgKyBjb3VudCArICcgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Lic7XG5cbiAgICBpZih0aGlzLnZlcmJvc2VNZW1vcnlMZWFrKXtcbiAgICAgIGVycm9yTXNnICs9ICcgRXZlbnQgbmFtZTogJyArIGV2ZW50TmFtZSArICcuJztcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbWl0V2FybmluZyl7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICBlLm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIGUuZW1pdHRlciA9IHRoaXM7XG4gICAgICBlLmNvdW50ID0gY291bnQ7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnKTtcblxuICAgICAgaWYgKGNvbnNvbGUudHJhY2Upe1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHRvQXJyYXkgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gW2FdO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gW2EsIGJdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgIGFycltuXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0b09iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGtleTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlc0NvdW50ID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIG9ialtrZXldID0gaSA8IHZhbHVlc0NvdW50ID8gdmFsdWVzW2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVGFyZ2V0T2JzZXJ2ZXIoZW1pdHRlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50ID0gMDtcblxuICAgIHZhciBvbiwgb2ZmO1xuXG4gICAgaWYgKG9wdGlvbnMub24gfHwgb3B0aW9ucy5vZmYpIHtcbiAgICAgIG9uID0gb3B0aW9ucy5vbjtcbiAgICAgIG9mZiA9IG9wdGlvbnMub2ZmO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgb24gPSB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgIG9mZiA9IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmFkZExpc3RlbmVyKSB7XG4gICAgICBvbiA9IHRhcmdldC5hZGRMaXN0ZW5lcjtcbiAgICAgIG9mZiA9IHRhcmdldC5yZW1vdmVMaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5vbikge1xuICAgICAgb24gPSB0YXJnZXQub247XG4gICAgICBvZmYgPSB0YXJnZXQub2ZmO1xuICAgIH1cblxuICAgIGlmICghb24gJiYgIW9mZikge1xuICAgICAgdGhyb3cgRXJyb3IoJ3RhcmdldCBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IGtub3duIGV2ZW50IEFQSScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignb24gbWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2ZmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ29mZiBtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fb24gPSBvbjtcbiAgICB0aGlzLl9vZmYgPSBvZmY7XG5cbiAgICB2YXIgX29ic2VydmVycz0gZW1pdHRlci5fb2JzZXJ2ZXJzO1xuICAgIGlmKF9vYnNlcnZlcnMpe1xuICAgICAgX29ic2VydmVycy5wdXNoKHRoaXMpO1xuICAgIH1lbHNle1xuICAgICAgZW1pdHRlci5fb2JzZXJ2ZXJzPSBbdGhpc107XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihUYXJnZXRPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKGV2ZW50LCBsb2NhbEV2ZW50LCByZWR1Y2VyKXtcbiAgICAgIHZhciBvYnNlcnZlcj0gdGhpcztcbiAgICAgIHZhciB0YXJnZXQ9IHRoaXMuX3RhcmdldDtcbiAgICAgIHZhciBlbWl0dGVyPSB0aGlzLl9lbWl0dGVyO1xuICAgICAgdmFyIGxpc3RlbmVycz0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgdmFyIGhhbmRsZXI9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhcmdzPSB0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBldmVudE9iaj0ge1xuICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgbmFtZTogbG9jYWxFdmVudCxcbiAgICAgICAgICBvcmlnaW5hbDogZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgaWYocmVkdWNlcil7XG4gICAgICAgICAgdmFyIHJlc3VsdD0gcmVkdWNlci5jYWxsKHRhcmdldCwgZXZlbnRPYmopO1xuICAgICAgICAgIGlmKHJlc3VsdCE9PWZhbHNlKXtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdC5hcHBseShlbWl0dGVyLCBbZXZlbnRPYmoubmFtZV0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5lbWl0LmFwcGx5KGVtaXR0ZXIsIFtsb2NhbEV2ZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcblxuXG4gICAgICBpZihsaXN0ZW5lcnNbZXZlbnRdKXtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0V2ZW50IFxcJycgKyBldmVudCArICdcXCcgaXMgYWxyZWFkeSBsaXN0ZW5pbmcnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGlzdGVuZXJzQ291bnQrKztcblxuICAgICAgaWYoZW1pdHRlci5fbmV3TGlzdGVuZXIgJiYgZW1pdHRlci5fcmVtb3ZlTGlzdGVuZXIgJiYgIW9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKXtcblxuICAgICAgICB0aGlzLl9vbk5ld0xpc3RlbmVyID0gZnVuY3Rpb24gKF9ldmVudCkge1xuICAgICAgICAgIGlmIChfZXZlbnQgPT09IGxvY2FsRXZlbnQgJiYgbGlzdGVuZXJzW2V2ZW50XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGhhbmRsZXI7XG4gICAgICAgICAgICBvYnNlcnZlci5fb24uY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZW1pdHRlci5vbignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyPSBmdW5jdGlvbihfZXZlbnQpe1xuICAgICAgICAgIGlmKF9ldmVudCA9PT0gbG9jYWxFdmVudCAmJiAhZW1pdHRlci5oYXNMaXN0ZW5lcnMoX2V2ZW50KSAmJiBsaXN0ZW5lcnNbZXZlbnRdKXtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF09IG51bGw7XG4gICAgICAgICAgICBvYnNlcnZlci5fb2ZmLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbmVyc1tldmVudF09IG51bGw7XG5cbiAgICAgICAgZW1pdHRlci5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBoYW5kbGVyO1xuICAgICAgICBvYnNlcnZlci5fb24uY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIHZhciBvYnNlcnZlcj0gdGhpcztcbiAgICAgIHZhciBsaXN0ZW5lcnM9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBlbWl0dGVyPSB0aGlzLl9lbWl0dGVyO1xuICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICB2YXIgZXZlbnRzO1xuICAgICAgdmFyIG9mZj0gdGhpcy5fb2ZmO1xuICAgICAgdmFyIHRhcmdldD0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmKGV2ZW50ICYmIHR5cGVvZiBldmVudCE9PSdzdHJpbmcnKXtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdldmVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUmVmcygpe1xuICAgICAgICBpZihvYnNlcnZlci5fb25OZXdMaXN0ZW5lcil7XG4gICAgICAgICAgZW1pdHRlci5vZmYoJ25ld0xpc3RlbmVyJywgb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpO1xuICAgICAgICAgIGVtaXR0ZXIub2ZmKCdyZW1vdmVMaXN0ZW5lcicsIG9ic2VydmVyLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICBvYnNlcnZlci5fb25OZXdMaXN0ZW5lcj0gbnVsbDtcbiAgICAgICAgICBvYnNlcnZlci5fb25SZW1vdmVMaXN0ZW5lcj0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXg9IGZpbmRUYXJnZXRJbmRleC5jYWxsKGVtaXR0ZXIsIG9ic2VydmVyKTtcbiAgICAgICAgZW1pdHRlci5fb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGV2ZW50KXtcbiAgICAgICAgaGFuZGxlcj0gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgICAgb2ZmLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBpZighLS10aGlzLl9saXN0ZW5lcnNDb3VudCl7XG4gICAgICAgICAgY2xlYXJSZWZzKCk7XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBldmVudHM9IG93bktleXMobGlzdGVuZXJzKTtcbiAgICAgICAgaT0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUoaS0tPjApe1xuICAgICAgICAgIGV2ZW50PSBldmVudHNbaV07XG4gICAgICAgICAgb2ZmLmNhbGwodGFyZ2V0LCBldmVudCwgbGlzdGVuZXJzW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzPSB7fTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzQ291bnQ9IDA7XG4gICAgICAgIGNsZWFyUmVmcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCByZWR1Y2VycywgYWxsb3dVbmtub3duKSB7XG4gICAgdmFyIGNvbXB1dGVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYSk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybiBjb21wdXRlZE9wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBvcHRpb24sIHZhbHVlO1xuICAgIHZhciByZWR1Y2VyO1xuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgXCInICsgb3B0aW9uICsgJ1wiIG9wdGlvbiB2YWx1ZScgKyAocmVhc29uID8gJy4gUmVhc29uOiAnICsgcmVhc29uIDogJycpKVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG9wdGlvbiA9IGtleXNbaV07XG4gICAgICBpZiAoIWFsbG93VW5rbm93biAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIG9wdGlvbikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gXCInICsgb3B0aW9uICsgJ1wiIG9wdGlvbicpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWR1Y2VyID0gcmVkdWNlcnNbb3B0aW9uXTtcbiAgICAgICAgY29tcHV0ZWRPcHRpb25zW29wdGlvbl0gPSByZWR1Y2VyID8gcmVkdWNlcih2YWx1ZSwgcmVqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcHV0ZWRPcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3JSZWR1Y2VyKHZhbHVlLCByZWplY3QpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8ICF2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJykpIHtcbiAgICAgIHJlamVjdCgndmFsdWUgbXVzdCBiZSBhIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VUeXBlUmVkdWNlcih0eXBlcykge1xuICAgIHZhciBtZXNzYWdlPSAndmFsdWUgbXVzdCBiZSB0eXBlIG9mICcgKyB0eXBlcy5qb2luKCd8Jyk7XG4gICAgdmFyIGxlbj0gdHlwZXMubGVuZ3RoO1xuICAgIHZhciBmaXJzdFR5cGU9IHR5cGVzWzBdO1xuICAgIHZhciBzZWNvbmRUeXBlPSB0eXBlc1sxXTtcblxuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodiwgcmVqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gZmlyc3RUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodiwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBraW5kPSB0eXBlb2YgdjtcbiAgICAgICAgaWYgKGtpbmQgPT09IGZpcnN0VHlwZSB8fCBraW5kID09PSBzZWNvbmRUeXBlKSByZXR1cm4gdjtcbiAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodiwgcmVqZWN0KSB7XG4gICAgICB2YXIga2luZCA9IHR5cGVvZiB2O1xuICAgICAgdmFyIGkgPSBsZW47XG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICBpZiAoa2luZCA9PT0gdHlwZXNbaV0pIHJldHVybiB2O1xuICAgICAgfVxuICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmdW5jdGlvblJlZHVjZXI9IG1ha2VUeXBlUmVkdWNlcihbJ2Z1bmN0aW9uJ10pO1xuXG4gIHZhciBvYmplY3RGdW5jdGlvblJlZHVjZXI9IG1ha2VUeXBlUmVkdWNlcihbJ29iamVjdCcsICdmdW5jdGlvbiddKTtcblxuICBmdW5jdGlvbiBtYWtlQ2FuY2VsYWJsZVByb21pc2UoUHJvbWlzZSwgZXhlY3V0b3IsIG9wdGlvbnMpIHtcbiAgICB2YXIgaXNDYW5jZWxhYmxlO1xuICAgIHZhciBjYWxsYmFja3M7XG4gICAgdmFyIHRpbWVyPSAwO1xuICAgIHZhciBzdWJzY3JpcHRpb25DbG9zZWQ7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgIG92ZXJsb2FkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbih2YWx1ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YWx1ZSo9IDE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZWplY3QoJ3RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpc0NhbmNlbGFibGUgPSAhb3B0aW9ucy5vdmVybG9hZCAmJiB0eXBlb2YgUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgIGNhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICB0aW1lciA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9yZXNvbHZlPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX3JlamVjdD0gZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0NhbmNlbGFibGUpIHtcbiAgICAgICAgZXhlY3V0b3IoX3Jlc29sdmUsIF9yZWplY3QsIG9uQ2FuY2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAgIF9yZWplY3QocmVhc29uIHx8IEVycm9yKCdjYW5jZWxlZCcpKTtcbiAgICAgICAgfV07XG4gICAgICAgIGV4ZWN1dG9yKF9yZXNvbHZlLCBfcmVqZWN0LCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIHN1YnNjcmliZSBvbiBjYW5jZWwgZXZlbnQgYXN5bmNocm9ub3VzbHknKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ29uQ2FuY2VsIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzY3JpcHRpb25DbG9zZWQ9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHRpbWVyPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIHJlYXNvbj0gRXJyb3IoJ3RpbWVvdXQnKTtcbiAgICAgICAgICByZWFzb24uY29kZSA9ICdFVElNRURPVVQnXG4gICAgICAgICAgdGltZXI9IDA7XG4gICAgICAgICAgcHJvbWlzZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaXNDYW5jZWxhYmxlKSB7XG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0ocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnRlcm5hbCBjYWxsYmFjayB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgY2FsbGJhY2tzWzBdKHJlYXNvbik7XG4gICAgICAgIGNhbGxiYWNrcyA9IG51bGw7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFRhcmdldEluZGV4KG9ic2VydmVyKSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycztcbiAgICBpZighb2JzZXJ2ZXJzKXtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG9ic2VydmVyc1tpXS5fdGFyZ2V0ID09PSBvYnNlcnZlcikgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIEF0dGVudGlvbiwgZnVuY3Rpb24gcmV0dXJuIHR5cGUgbm93IGlzIGFycmF5LCBhbHdheXMgIVxuICAvLyBJdCBoYXMgemVybyBlbGVtZW50cyBpZiBubyBhbnkgbWF0Y2hlcyBmb3VuZCBhbmQgb25lIG9yIG1vcmVcbiAgLy8gZWxlbWVudHMgKGxlYWZzKSBpZiB0aGVyZSBhcmUgbWF0Y2hlc1xuICAvL1xuICBmdW5jdGlvbiBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIGksIHR5cGVMZW5ndGgpIHtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB2YXIga2luZCA9IHR5cGVvZiB0eXBlO1xuICAgICAgaWYgKGtpbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBucywgbiwgbCA9IDAsIGogPSAwLCBkZWxpbWl0ZXIgPSB0aGlzLmRlbGltaXRlciwgZGwgPSBkZWxpbWl0ZXIubGVuZ3RoO1xuICAgICAgICBpZiAoKG4gPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgIT09IC0xKSB7XG4gICAgICAgICAgbnMgPSBuZXcgQXJyYXkoNSk7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbnNbbCsrXSA9IHR5cGUuc2xpY2Uoaiwgbik7XG4gICAgICAgICAgICBqID0gbiArIGRsO1xuICAgICAgICAgIH0gd2hpbGUgKChuID0gdHlwZS5pbmRleE9mKGRlbGltaXRlciwgaikpICE9PSAtMSk7XG5cbiAgICAgICAgICBuc1tsKytdID0gdHlwZS5zbGljZShqKTtcbiAgICAgICAgICB0eXBlID0gbnM7XG4gICAgICAgICAgdHlwZUxlbmd0aCA9IGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgICB0eXBlTGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChraW5kID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0eXBlTGVuZ3RoID0gdHlwZS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgICB0eXBlTGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzPSBudWxsLCBicmFuY2gsIHhUcmVlLCB4eFRyZWUsIGlzb2xhdGVkQnJhbmNoLCBlbmRSZWFjaGVkLCBjdXJyZW50VHlwZSA9IHR5cGVbaV0sXG4gICAgICAgIG5leHRUeXBlID0gdHlwZVtpICsgMV0sIGJyYW5jaGVzLCBfbGlzdGVuZXJzO1xuXG4gICAgaWYgKGkgPT09IHR5cGVMZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBJZiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudChzKSBsaXN0IGFuZCB0aGUgdHJlZSBoYXMgbGlzdGVuZXJzXG4gICAgICAvLyBpbnZva2UgdGhvc2UgbGlzdGVuZXJzLlxuICAgICAgLy9cblxuICAgICAgaWYodHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaCh0cmVlLl9saXN0ZW5lcnMpO1xuICAgICAgICAgIGxpc3RlbmVycyA9IFt0cmVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoLmFwcGx5KGhhbmRsZXJzLCB0cmVlLl9saXN0ZW5lcnMpO1xuICAgICAgICAgIGxpc3RlbmVycyA9IFt0cmVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChjdXJyZW50VHlwZSA9PT0gJyonKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSBldmVudCBlbWl0dGVkIGlzICcqJyBhdCB0aGlzIHBhcnRcbiAgICAgICAgLy8gb3IgdGhlcmUgaXMgYSBjb25jcmV0ZSBtYXRjaCBhdCB0aGlzIHBhdGNoXG4gICAgICAgIC8vXG4gICAgICAgIGJyYW5jaGVzID0gb3duS2V5cyh0cmVlKTtcbiAgICAgICAgbiA9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICBicmFuY2ggPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoLmFwcGx5KGxpc3RlbmVycywgX2xpc3RlbmVycyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50VHlwZSA9PT0gJyoqJykge1xuICAgICAgICBlbmRSZWFjaGVkID0gKGkgKyAxID09PSB0eXBlTGVuZ3RoIHx8IChpICsgMiA9PT0gdHlwZUxlbmd0aCAmJiBuZXh0VHlwZSA9PT0gJyonKSk7XG4gICAgICAgIGlmIChlbmRSZWFjaGVkICYmIHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIFRoZSBuZXh0IGVsZW1lbnQgaGFzIGEgX2xpc3RlbmVycywgYWRkIGl0IHRvIHRoZSBoYW5kbGVycy5cbiAgICAgICAgICBsaXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJhbmNoZXMgPSBvd25LZXlzKHRyZWUpO1xuICAgICAgICBuID0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaGVzW25dO1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJykge1xuICAgICAgICAgICAgaWYgKGJyYW5jaCA9PT0gJyonIHx8IGJyYW5jaCA9PT0gJyoqJykge1xuICAgICAgICAgICAgICBpZiAodHJlZVticmFuY2hdLl9saXN0ZW5lcnMgJiYgIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoLmFwcGx5KGxpc3RlbmVycywgX2xpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGksIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFuY2ggPT09IG5leHRUeXBlKSB7XG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSArIDIsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gbWF0Y2ggb24gdGhpcyBvbmUsIHNoaWZ0IGludG8gdGhlIHRyZWUgYnV0IG5vdCBpbiB0aGUgdHlwZSBhcnJheS5cbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSBpZiAodHJlZVtjdXJyZW50VHlwZV0pIHtcbiAgICAgICAgbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2N1cnJlbnRUeXBlXSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgICAgeFRyZWUgPSB0cmVlWycqJ107XG4gICAgaWYgKHhUcmVlKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIGxpc3RlbmVyIHRyZWUgd2lsbCBhbGxvdyBhbnkgbWF0Y2ggZm9yIHRoaXMgcGFydCxcbiAgICAgIC8vIHRoZW4gcmVjdXJzaXZlbHkgZXhwbG9yZSBhbGwgYnJhbmNoZXMgb2YgdGhlIHRyZWVcbiAgICAgIC8vXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHhUcmVlLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgeHhUcmVlID0gdHJlZVsnKionXTtcbiAgICBpZiAoeHhUcmVlKSB7XG4gICAgICBpZiAoaSA8IHR5cGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHh4VHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGxpc3RlbmVyIG9uIGEgJyoqJywgaXQgd2lsbCBjYXRjaCBhbGwsIHNvIGFkZCBpdHMgaGFuZGxlci5cbiAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBhcnJheXMgb2YgbWF0Y2hpbmcgbmV4dCBicmFuY2hlcyBhbmQgb3RoZXJzLlxuICAgICAgICBicmFuY2hlcz0gb3duS2V5cyh4eFRyZWUpO1xuICAgICAgICBuPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKG4tLT4wKXtcbiAgICAgICAgICBicmFuY2g9IGJyYW5jaGVzW25dO1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJykge1xuICAgICAgICAgICAgaWYgKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgbmV4dCBlbGVtZW50IHdpbGwgbWF0Y2gsIHNvIGp1bXAgdHdpY2UuXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkgKyAyLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhbmNoID09PSBjdXJyZW50VHlwZSkge1xuICAgICAgICAgICAgICAvLyBDdXJyZW50IG5vZGUgbWF0Y2hlcywgbW92ZSBpbnRvIHRoZSB0cmVlLlxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaCA9IHt9O1xuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaFticmFuY2hdID0geHhUcmVlW2JyYW5jaF07XG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeycqKic6IGlzb2xhdGVkQnJhbmNofSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4eFRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBhbmQgc3RpbGwgb24gYSAnKionXG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAoeHhUcmVlWycqJ10gJiYgeHhUcmVlWycqJ10uX2xpc3RlbmVycykge1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVsnKiddLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdGVuZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ3Jvd0xpc3RlbmVyVHJlZSh0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgIHZhciBsZW4gPSAwLCBqID0gMCwgaSwgZGVsaW1pdGVyID0gdGhpcy5kZWxpbWl0ZXIsIGRsPSBkZWxpbWl0ZXIubGVuZ3RoLCBucztcblxuICAgIGlmKHR5cGVvZiB0eXBlPT09J3N0cmluZycpIHtcbiAgICAgIGlmICgoaSA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgbnMgPSBuZXcgQXJyYXkoNSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuc1tsZW4rK10gPSB0eXBlLnNsaWNlKGosIGkpO1xuICAgICAgICAgIGogPSBpICsgZGw7XG4gICAgICAgIH0gd2hpbGUgKChpID0gdHlwZS5pbmRleE9mKGRlbGltaXRlciwgaikpICE9PSAtMSk7XG5cbiAgICAgICAgbnNbbGVuKytdID0gdHlwZS5zbGljZShqKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBucz0gW3R5cGVdO1xuICAgICAgICBsZW49IDE7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBucz0gdHlwZTtcbiAgICAgIGxlbj0gdHlwZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBMb29rcyBmb3IgdHdvIGNvbnNlY3V0aXZlICcqKicsIGlmIHNvLCBkb24ndCBhZGQgdGhlIGV2ZW50IGF0IGFsbC5cbiAgICAvL1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChuc1tpXSA9PT0gJyoqJyAmJiBuc1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgdmFyIHRyZWUgPSB0aGlzLmxpc3RlbmVyVHJlZSwgbmFtZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbmFtZSA9IG5zW2ldO1xuXG4gICAgICB0cmVlID0gdHJlZVtuYW1lXSB8fCAodHJlZVtuYW1lXSA9IHt9KTtcblxuICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaWYgKCF0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBsaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gW3RyZWUuX2xpc3RlbmVyc107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRyZWUuX2xpc3RlbmVycy53YXJuZWQgJiZcbiAgICAgICAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID4gMCAmJlxuICAgICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhay5jYWxsKHRoaXMsIHRyZWUuX2xpc3RlbmVycy5sZW5ndGgsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUcmVlRXZlbnRzKHRyZWUsIGV2ZW50cywgcm9vdCwgYXNBcnJheSl7XG4gICAgIHZhciBicmFuY2hlcz0gb3duS2V5cyh0cmVlKTtcbiAgICAgdmFyIGk9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgdmFyIGJyYW5jaCwgYnJhbmNoTmFtZSwgcGF0aDtcbiAgICAgdmFyIGhhc0xpc3RlbmVycz0gdHJlZVsnX2xpc3RlbmVycyddO1xuICAgICB2YXIgaXNBcnJheVBhdGg7XG5cbiAgICAgd2hpbGUoaS0tPjApe1xuICAgICAgICAgYnJhbmNoTmFtZT0gYnJhbmNoZXNbaV07XG5cbiAgICAgICAgIGJyYW5jaD0gdHJlZVticmFuY2hOYW1lXTtcblxuICAgICAgICAgaWYoYnJhbmNoTmFtZT09PSdfbGlzdGVuZXJzJyl7XG4gICAgICAgICAgICAgcGF0aD0gcm9vdDtcbiAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICBwYXRoID0gcm9vdCA/IHJvb3QuY29uY2F0KGJyYW5jaE5hbWUpIDogW2JyYW5jaE5hbWVdO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpc0FycmF5UGF0aD0gYXNBcnJheSB8fCB0eXBlb2YgYnJhbmNoTmFtZT09PSdzeW1ib2wnO1xuXG4gICAgICAgICBoYXNMaXN0ZW5lcnMgJiYgZXZlbnRzLnB1c2goaXNBcnJheVBhdGg/IHBhdGggOiBwYXRoLmpvaW4odGhpcy5kZWxpbWl0ZXIpKTtcblxuICAgICAgICAgaWYodHlwZW9mIGJyYW5jaD09PSdvYmplY3QnKXtcbiAgICAgICAgICAgICBjb2xsZWN0VHJlZUV2ZW50cy5jYWxsKHRoaXMsIGJyYW5jaCwgZXZlbnRzLCBwYXRoLCBpc0FycmF5UGF0aCk7XG4gICAgICAgICB9XG4gICAgIH1cblxuICAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChyb290KSB7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKHJvb3QpO1xuICAgIHZhciBpPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgb2JqLCBrZXksIGZsYWc7XG4gICAgd2hpbGUoaS0tPjApe1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIG9iaiA9IHJvb3Rba2V5XTtcblxuICAgICAgaWYob2JqKXtcbiAgICAgICAgICBmbGFnPSB0cnVlO1xuICAgICAgICAgIGlmKGtleSAhPT0gJ19saXN0ZW5lcnMnICYmICFyZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KG9iaikpe1xuICAgICAgICAgICAgIGRlbGV0ZSByb290W2tleV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmbGFnO1xuICB9XG5cbiAgZnVuY3Rpb24gTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyKXtcbiAgICB0aGlzLmVtaXR0ZXI9IGVtaXR0ZXI7XG4gICAgdGhpcy5ldmVudD0gZXZlbnQ7XG4gICAgdGhpcy5saXN0ZW5lcj0gbGlzdGVuZXI7XG4gIH1cblxuICBMaXN0ZW5lci5wcm90b3R5cGUub2ZmPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZW1pdHRlci5vZmYodGhpcy5ldmVudCwgdGhpcy5saXN0ZW5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpe1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgcHJvbWlzaWZ5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0IG9yIHRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXN5bmMgPSBvcHRpb25zLmFzeW5jO1xuICAgICAgICB2YXIgcHJvbWlzaWZ5ID0gb3B0aW9ucy5wcm9taXNpZnk7XG4gICAgICAgIHZhciBuZXh0VGljayA9IG9wdGlvbnMubmV4dFRpY2s7XG4gICAgICAgIHZhciBvYmplY3RpZnkgPSBvcHRpb25zLm9iamVjdGlmeTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFzeW5jIHx8IG5leHRUaWNrIHx8IHByb21pc2lmeSkge1xuICAgICAgICB2YXIgX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHZhciBfb3JpZ2luID0gbGlzdGVuZXIuX29yaWdpbiB8fCBsaXN0ZW5lcjtcblxuICAgICAgICBpZiAobmV4dFRpY2sgJiYgIW5leHRUaWNrU3VwcG9ydGVkKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ3Byb2Nlc3MubmV4dFRpY2sgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2lmeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvbWlzaWZ5ID0gbGlzdGVuZXIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FzeW5jRnVuY3Rpb24nO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnQ7XG5cbiAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5ID8gKG5leHRUaWNrID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3NldEltbWVkaWF0ZShyZXNvbHZlKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiBfbGlzdGVuZXIuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgICB9KSkgOiAobmV4dFRpY2sgPyBwcm9jZXNzLm5leHRUaWNrIDogX3NldEltbWVkaWF0ZSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgX2xpc3RlbmVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuZXIuX2FzeW5jID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXIuX29yaWdpbiA9IF9vcmlnaW47XG4gICAgICB9XG5cbiAgICByZXR1cm4gW2xpc3RlbmVyLCBvYmplY3RpZnk/IG5ldyBMaXN0ZW5lcih0aGlzLCBldmVudCwgbGlzdGVuZXIpOiB0aGlzXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihjb25mKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgdGhpcy5fbmV3TGlzdGVuZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zZU1lbW9yeUxlYWsgPSBmYWxzZTtcbiAgICBjb25maWd1cmUuY2FsbCh0aGlzLCBjb25mKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgZXhwb3J0aW5nIEV2ZW50RW1pdHRlciBwcm9wZXJ0eVxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuVG89IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRzLCBvcHRpb25zKXtcbiAgICBpZih0eXBlb2YgdGFyZ2V0IT09J29iamVjdCcpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCd0YXJnZXQgbXVzdHMgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGVtaXR0ZXI9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgb246IHVuZGVmaW5lZCxcbiAgICAgIG9mZjogdW5kZWZpbmVkLFxuICAgICAgcmVkdWNlcnM6IHVuZGVmaW5lZFxuICAgIH0sIHtcbiAgICAgIG9uOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICBvZmY6IGZ1bmN0aW9uUmVkdWNlcixcbiAgICAgIHJlZHVjZXJzOiBvYmplY3RGdW5jdGlvblJlZHVjZXJcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbihldmVudHMpe1xuICAgICAgaWYodHlwZW9mIGV2ZW50cyE9PSdvYmplY3QnKXtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdldmVudHMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZHVjZXJzPSBvcHRpb25zLnJlZHVjZXJzO1xuICAgICAgdmFyIGluZGV4PSBmaW5kVGFyZ2V0SW5kZXguY2FsbChlbWl0dGVyLCB0YXJnZXQpO1xuICAgICAgdmFyIG9ic2VydmVyO1xuXG4gICAgICBpZihpbmRleD09PS0xKXtcbiAgICAgICAgb2JzZXJ2ZXI9IG5ldyBUYXJnZXRPYnNlcnZlcihlbWl0dGVyLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIG9ic2VydmVyPSBlbWl0dGVyLl9vYnNlcnZlcnNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cz0gb3duS2V5cyhldmVudHMpO1xuICAgICAgdmFyIGxlbj0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICB2YXIgaXNTaW5nbGVSZWR1Y2VyPSB0eXBlb2YgcmVkdWNlcnM9PT0nZnVuY3Rpb24nO1xuXG4gICAgICBmb3IodmFyIGk9MDsgaTxsZW47IGkrKyl7XG4gICAgICAgIGV2ZW50PSBrZXlzW2ldO1xuICAgICAgICBvYnNlcnZlci5zdWJzY3JpYmUoXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGV2ZW50c1tldmVudF0gfHwgZXZlbnQsXG4gICAgICAgICAgICBpc1NpbmdsZVJlZHVjZXIgPyByZWR1Y2VycyA6IHJlZHVjZXJzICYmIHJlZHVjZXJzW2V2ZW50XVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzQXJyYXkoZXZlbnRzKT9cbiAgICAgICAgbGlzdGVuKHRvT2JqZWN0KGV2ZW50cykpIDpcbiAgICAgICAgKHR5cGVvZiBldmVudHM9PT0nc3RyaW5nJz8gbGlzdGVuKHRvT2JqZWN0KGV2ZW50cy5zcGxpdCgvXFxzKy8pKSk6IGxpc3RlbihldmVudHMpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3RvcExpc3RlbmluZ1RvID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzO1xuXG4gICAgaWYoIW9ic2VydmVycyl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgbWF0Y2hlZD0gZmFsc2U7XG5cbiAgICBpZih0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCE9PSdvYmplY3QnKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcigndGFyZ2V0IHNob3VsZCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlcnNbaV07XG4gICAgICBpZiAoIXRhcmdldCB8fCBvYnNlcnZlci5fdGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUoZXZlbnQpO1xuICAgICAgICBtYXRjaGVkPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbiAgLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4gIC8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuICAvL1xuICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kZWxpbWl0ZXIgPSAnLic7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICAgIGlmICghdGhpcy5fY29uZikgdGhpcy5fY29uZiA9IHt9O1xuICAgICAgdGhpcy5fY29uZi5tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIH1cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudCA9ICcnO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbmNlKGV2ZW50LCBmbiwgZmFsc2UsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbmNlKGV2ZW50LCBmbiwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbiwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tYW55KGV2ZW50LCAxLCBmbiwgcHJlcGVuZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5tYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgdHRsLCBmbiwgZmFsc2UsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE1hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tYW55KGV2ZW50LCB0dGwsIGZuLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4sIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbnkgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKC0tdHRsID09PSAwKSB7XG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lci5fb3JpZ2luID0gZm47XG5cbiAgICByZXR1cm4gdGhpcy5fb24oZXZlbnQsIGxpc3RlbmVyLCBwcmVwZW5kLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyAmJiAhdGhpcy5fYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBucywgd2lsZGNhcmQ9IHRoaXMud2lsZGNhcmQ7XG4gICAgdmFyIGFyZ3MsbCxpLGosIGNvbnRhaW5zU3ltYm9sO1xuXG4gICAgaWYgKHR5cGUgPT09ICduZXdMaXN0ZW5lcicgJiYgIXRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBucz0gdHlwZTtcbiAgICAgIGlmKHR5cGUhPT0nbmV3TGlzdGVuZXInICYmIHR5cGUhPT0ncmVtb3ZlTGlzdGVuZXInKXtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGwgPSB0eXBlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoc3ltYm9sc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVbaV0gPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbnNTeW1ib2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29udGFpbnNTeW1ib2wpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmpvaW4odGhpcy5kZWxpbWl0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5fYWxsICYmIHRoaXMuX2FsbC5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9hbGwuc2xpY2UoKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBoYW5kbGVyID0gW107XG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDAsIGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gbWFrZSBjb3B5IG9mIGhhbmRsZXJzIGJlY2F1c2UgbGlzdCBjYW4gY2hhbmdlIGluIHRoZSBtaWRkbGVcbiAgICAgICAgLy8gb2YgZW1pdCBjYWxsXG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5sZW5ndGgpIHtcbiAgICAgIGlmIChhbCA+IDMpIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlnbm9yZUVycm9ycyAmJiAhdGhpcy5fYWxsICYmIHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5fYWxsO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdEFzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgJiYgIXRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgd2lsZGNhcmQ9IHRoaXMud2lsZGNhcmQsIG5zLCBjb250YWluc1N5bWJvbDtcbiAgICB2YXIgYXJncyxsLGksajtcblxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtmYWxzZV0pOyB9XG4gICAgfVxuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBucz0gdHlwZTtcbiAgICAgIGlmKHR5cGUhPT0nbmV3TGlzdGVuZXInICYmIHR5cGUhPT0ncmVtb3ZlTGlzdGVuZXInKXtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGwgPSB0eXBlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoc3ltYm9sc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVbaV0gPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbnNTeW1ib2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29udGFpbnNTeW1ib2wpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmpvaW4odGhpcy5kZWxpbWl0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9taXNlcz0gW107XG5cbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuX2FsbCkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuX2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgaGFuZGxlciA9IFtdO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlci5zbGljZSgpO1xuICAgICAgaWYgKGFsID4gMykge1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlnbm9yZUVycm9ycyAmJiAhdGhpcy5fYWxsICYmIHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYXJndW1lbnRzWzFdKTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lciwgZmFsc2UsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgbGlzdGVuZXIsIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25BbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiB0aGlzLl9vbkFueShmbiwgZmFsc2UpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZEFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQW55KGZuLCB0cnVlKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9vbkFueSA9IGZ1bmN0aW9uKGZuLCBwcmVwZW5kKXtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uQW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgdGhpcy5fYWxsID0gW107XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgZXZlbnQgbGlzdGVuZXIgY29sbGVjdGlvbi5cbiAgICBpZihwcmVwZW5kKXtcbiAgICAgIHRoaXMuX2FsbC51bnNoaWZ0KGZuKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuX2FsbC5wdXNoKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vbkFueSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uIG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciByZXR1cm5WYWx1ZT0gdGhpcywgdGVtcDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXAgPSBzZXR1cExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXIgPSB0ZW1wWzBdO1xuICAgICAgcmV0dXJuVmFsdWUgPSB0ZW1wWzFdO1xuICAgIH1cblxuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgICBpZiAodGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIGdyb3dMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZXZlbnRzW3R5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIENoYW5nZSB0byBhcnJheS5cbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFkZFxuICAgICAgaWYocHJlcGVuZCl7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkICYmXG4gICAgICAgIHRoaXMuX21heExpc3RlbmVycyA+IDAgJiZcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IHRoaXMuX21heExpc3RlbmVyc1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMsbGVhZnM9W107XG5cbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIGxlYWZzID0gc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgbnVsbCwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcbiAgICAgIGlmKCFsZWFmcykgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuICAgICAgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICBsZWFmcy5wdXNoKHtfbGlzdGVuZXJzOmhhbmRsZXJzfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaUxlYWY9MDsgaUxlYWY8bGVhZnMubGVuZ3RoOyBpTGVhZisrKSB7XG4gICAgICB2YXIgbGVhZiA9IGxlYWZzW2lMZWFmXTtcbiAgICAgIGhhbmRsZXJzID0gbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLmxpc3RlbmVyICYmIGhhbmRsZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5fb3JpZ2luICYmIGhhbmRsZXJzW2ldLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgICAgIGxlYWYuX2xpc3RlbmVycy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFmLl9saXN0ZW5lcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGhhbmRsZXJzID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAoaGFuZGxlcnMubGlzdGVuZXIgJiYgaGFuZGxlcnMubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB8fFxuICAgICAgICAoaGFuZGxlcnMuX29yaWdpbiAmJiBoYW5kbGVycy5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgICAgIGRlbGV0ZSBsZWFmLl9saXN0ZW5lcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJUcmVlICYmIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3QodGhpcy5saXN0ZW5lclRyZWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmZBbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBpID0gMCwgbCA9IDAsIGZucztcbiAgICBpZiAoZm4gJiYgdGhpcy5fYWxsICYmIHRoaXMuX2FsbC5sZW5ndGggPiAwKSB7XG4gICAgICBmbnMgPSB0aGlzLl9hbGw7XG4gICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmKGZuID09PSBmbnNbaV0pIHtcbiAgICAgICAgICBmbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyQW55XCIsIGZuKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmbnMgPSB0aGlzLl9hbGw7XG4gICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbnNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgIXRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIGxlYWZzID0gc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgbnVsbCwgdHlwZSwgdGhpcy5saXN0ZW5lclRyZWUsIDApLCBsZWFmLCBpO1xuICAgICAgaWYgKCFsZWFmcykgcmV0dXJuIHRoaXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVhZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVhZiA9IGxlYWZzW2ldO1xuICAgICAgICBsZWFmLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5saXN0ZW5lclRyZWUgJiYgcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdCh0aGlzLmxpc3RlbmVyVHJlZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICB2YXIga2V5cywgbGlzdGVuZXJzLCBhbGxMaXN0ZW5lcnM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxpc3RlbmVyVHJlZTtcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdldmVudCBuYW1lIHJlcXVpcmVkIGZvciB3aWxkY2FyZCBlbWl0dGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX2V2ZW50cykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGtleXMgPSBvd25LZXlzKF9ldmVudHMpO1xuICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgYWxsTGlzdGVuZXJzID0gW107XG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBfZXZlbnRzW2tleXNbaV1dO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFsbExpc3RlbmVycy5wdXNoKGxpc3RlbmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsTGlzdGVuZXJzLnB1c2guYXBwbHkoYWxsTGlzdGVuZXJzLCBsaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsTGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICBsaXN0ZW5lclRyZWU9IHRoaXMubGlzdGVuZXJUcmVlO1xuICAgICAgICBpZighbGlzdGVuZXJUcmVlKSByZXR1cm4gW107XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCBsaXN0ZW5lclRyZWUsIDApO1xuICAgICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgICB9XG5cbiAgICAgIGlmICghX2V2ZW50cykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IF9ldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nID8gW2xpc3RlbmVyc10gOiBsaXN0ZW5lcnM7XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKG5zQXNBcnJheSl7XG4gICAgdmFyIF9ldmVudHM9IHRoaXMuX2V2ZW50cztcbiAgICByZXR1cm4gdGhpcy53aWxkY2FyZD8gY29sbGVjdFRyZWVFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmxpc3RlbmVyVHJlZSwgW10sIG51bGwsIG5zQXNBcnJheSkgOiAoX2V2ZW50cz8gb3duS2V5cyhfZXZlbnRzKSA6IFtdKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVycywgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcbiAgICAgIHJldHVybiBoYW5kbGVycy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIHZhciBfYWxsID0gdGhpcy5fYWxsO1xuXG4gICAgcmV0dXJuICEhKF9hbGwgJiYgX2FsbC5sZW5ndGggfHwgX2V2ZW50cyAmJiAodHlwZSA9PT0gdW5kZWZpbmVkID8gb3duS2V5cyhfZXZlbnRzKS5sZW5ndGggOiBfZXZlbnRzW3R5cGVdKSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnNBbnkgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9wdGlvbnM7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zID0ge3RpbWVvdXQ6IG9wdGlvbnN9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucyA9IHtmaWx0ZXI6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICBmaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgIGhhbmRsZUVycm9yOiBmYWxzZSxcbiAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICBvdmVybG9hZDogZmFsc2VcbiAgICB9LCB7XG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uUmVkdWNlcixcbiAgICAgIFByb21pc2U6IGNvbnN0cnVjdG9yUmVkdWNlclxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1ha2VDYW5jZWxhYmxlUHJvbWlzZShvcHRpb25zLlByb21pc2UsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgdmFyIGZpbHRlcj0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5hcHBseShzZWxmLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChvcHRpb25zLmhhbmRsZUVycm9yKSB7XG4gICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpLnNsaWNlKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLl9vbihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9LCB7XG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICBvdmVybG9hZDogb3B0aW9ucy5vdmVybG9hZFxuICAgIH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICBvdmVybG9hZDogZmFsc2VcbiAgICB9LCB7XG4gICAgICBQcm9taXNlOiBjb25zdHJ1Y3RvclJlZHVjZXJcbiAgICB9KTtcblxuICAgIHZhciBfUHJvbWlzZT0gb3B0aW9ucy5Qcm9taXNlO1xuXG4gICAgcmV0dXJuIG1ha2VDYW5jZWxhYmxlUHJvbWlzZShfUHJvbWlzZSwgZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCl7XG4gICAgICB2YXIgaGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXI9ICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIHtvbmNlOiB0cnVlfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBldmVudExpc3RlbmVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZXJyb3JMaXN0ZW5lciAmJiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIChlcnIpe1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICBlcnJvckxpc3RlbmVyICYmIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9KTtcblxuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0sIHtcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICAgIG92ZXJsb2FkOiBvcHRpb25zLm92ZXJsb2FkXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50RW1pdHRlciwge1xuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlLl9tYXhMaXN0ZW5lcnM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlci5pc05hTihuKSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgICAgIH1cbiAgICAgICAgcHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIG9uY2U6IHtcbiAgICAgIHZhbHVlOiBvbmNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvdHlwZSwge1xuICAgICAgX21heExpc3RlbmVyczoge1xuICAgICAgICAgIHZhbHVlOiBkZWZhdWx0TWF4TGlzdGVuZXJzLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIF9vYnNlcnZlcnM6IHt2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX1cbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdsb2JhbCBmb3IgYW55IGtpbmQgb2YgZW52aXJvbm1lbnQuXG4gICAgdmFyIF9nbG9iYWw9IG5ldyBGdW5jdGlvbignJywncmV0dXJuIHRoaXMnKSgpO1xuICAgIF9nbG9iYWwuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcbiAgfVxufSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUGF0aFN5bWJvbCA9IFN5bWJvbChcIk11c3RhY2hlRGF0YVBhdGhcIik7XG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eVBhdGhBcnJheSh7IHRhcmdldCwgcHJvcGVydHlOYW1lLCB9KSB7XG4gICAgcmV0dXJuIFsuLi4odGFyZ2V0W1BhdGhTeW1ib2xdIHx8IFtdKSwgcHJvcGVydHlOYW1lXTtcbn1cbmZ1bmN0aW9uIHByb3h5TXVzdGFjaGVEYXRhKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJveHkoZGF0YSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShwcm9wZXJ0eU5hbWUgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhTZWdtZW50cyA9IGNyZWF0ZVByb3BlcnR5UGF0aEFycmF5KHsgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhhbmRsZUVycm9yKHBhdGhTZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc3NpbmcgTXVzdGFjaGUgZGF0YSBwcm9wZXJ0eTogJHtwYXRoU2VnbWVudHMuam9pbihcIiA+IFwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtQYXRoU3ltYm9sXSA9IGNyZWF0ZVByb3BlcnR5UGF0aEFycmF5KHsgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5TXVzdGFjaGVEYXRhKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByb3h5TXVzdGFjaGVEYXRhO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVG9rZW5zID0gZXhwb3J0cy5TdHJ1Y3R1cmFsQ2hhcmFjdGVycyA9IGV4cG9ydHMuT3BlcmF0b3JzID0gdm9pZCAwO1xudmFyIE9wZXJhdG9ycztcbihmdW5jdGlvbiAoT3BlcmF0b3JzKSB7XG4gICAgT3BlcmF0b3JzW1wiQU5EXCJdID0gXCJBTkRcIjtcbiAgICBPcGVyYXRvcnNbXCJPUlwiXSA9IFwiT1JcIjtcbiAgICBPcGVyYXRvcnNbXCJYT1JcIl0gPSBcIlhPUlwiO1xuICAgIE9wZXJhdG9yc1tcIk5PVFwiXSA9IFwiTk9UXCI7XG59KShPcGVyYXRvcnMgPSBleHBvcnRzLk9wZXJhdG9ycyB8fCAoZXhwb3J0cy5PcGVyYXRvcnMgPSB7fSkpO1xudmFyIFN0cnVjdHVyYWxDaGFyYWN0ZXJzO1xuKGZ1bmN0aW9uIChTdHJ1Y3R1cmFsQ2hhcmFjdGVycykge1xuICAgIFN0cnVjdHVyYWxDaGFyYWN0ZXJzW1wiT1BFTl9QQVJFTlRIRVNJU1wiXSA9IFwiKFwiO1xuICAgIFN0cnVjdHVyYWxDaGFyYWN0ZXJzW1wiQ0xPU0VfUEFSRU5USEVTSVNcIl0gPSBcIilcIjtcbn0pKFN0cnVjdHVyYWxDaGFyYWN0ZXJzID0gZXhwb3J0cy5TdHJ1Y3R1cmFsQ2hhcmFjdGVycyB8fCAoZXhwb3J0cy5TdHJ1Y3R1cmFsQ2hhcmFjdGVycyA9IHt9KSk7XG52YXIgVG9rZW5zO1xuKGZ1bmN0aW9uIChUb2tlbnMpIHtcbiAgICBUb2tlbnNbXCJJREVOVElGSUVSXCJdID0gXCJJREVOVElGSUVSXCI7XG4gICAgVG9rZW5zW1wiT1BFUkFUT1JcIl0gPSBcIk9QRVJBVE9SXCI7XG4gICAgVG9rZW5zW1wiU1RSVUNUVVJBTF9DSEFSQUNURVJcIl0gPSBcIlNUUlVDVFVSQUxfQ0hBUkFDVEVSXCI7XG4gICAgVG9rZW5zW1wiRU9GXCJdID0gXCJFT0ZcIjtcbiAgICBUb2tlbnNbXCJDT01NRU5UXCJdID0gXCJDT01NRU5UXCI7XG59KShUb2tlbnMgPSBleHBvcnRzLlRva2VucyB8fCAoZXhwb3J0cy5Ub2tlbnMgPSB7fSkpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVkFMSURfVE9LRU5TID0gZXhwb3J0cy5PUEVSQVRPUl9QUkVDRURFTkNFID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5leHBvcnRzLk9QRVJBVE9SX1BSRUNFREVOQ0UgPSB7XG4gICAgTk9UOiAwLFxuICAgIFhPUjogMSxcbiAgICBBTkQ6IDIsXG4gICAgT1I6IDNcbn07XG5leHBvcnRzLlZBTElEX1RPS0VOUyA9IHtcbiAgICBpZGVudGlmaWVyT25seTogW1xuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5PUEVOX1BBUkVOVEhFU0lTXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBpZGVudGlmaWVyT3JOb3Q6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSLFxuICAgICAgICAgICAgdmFsdWU6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuTk9UIH0sXG4gICAgXSxcbiAgICBiaW5hcnlPcGVyYXRvcjogW1xuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuQU5EIH0sXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5PUiB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuWE9SIH0sXG4gICAgXSxcbiAgICBiaW5hcnlPcGVyYXRvck9yQ2xvc2U6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuT1IgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUiB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUixcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLkNMT1NFX1BBUkVOVEhFU0lTXG4gICAgICAgIH0sXG4gICAgXVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVIgPSBleHBvcnRzLkVPTCA9IGV4cG9ydHMuQ09NTUVOVF9ERUxJTUlURVIgPSBleHBvcnRzLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUiA9IGV4cG9ydHMuU0VQQVJBVE9SUyA9IGV4cG9ydHMuT1BFUkFUT1JTID0gZXhwb3J0cy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlMgPSB2b2lkIDA7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmV4cG9ydHMuU1RSVUNUVVJBTF9DSEFSQUNURVJTID0ge1xuICAgICcoJzogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5PUEVOX1BBUkVOVEhFU0lTLFxuICAgICcpJzogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJU1xufTtcbmV4cG9ydHMuT1BFUkFUT1JTID0ge1xuICAgIEFORDogdHlwZXNfMS5PcGVyYXRvcnMuQU5ELFxuICAgIE9SOiB0eXBlc18xLk9wZXJhdG9ycy5PUixcbiAgICBYT1I6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUixcbiAgICBOT1Q6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVFxufTtcbmV4cG9ydHMuU0VQQVJBVE9SUyA9IG5ldyBTZXQoW1xuICAgIDB4MDAyMCxcbiAgICAweDAwMDksXG4gICAgMHgwMDBhLFxuICAgIDB4MDAwZCwgLy8gQ2FycmlhZ2UgcmV0dXJuXG5dLm1hcChmdW5jdGlvbiAoc2VwYXJhdG9yKSB7IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChzZXBhcmF0b3IpOyB9KSk7XG5leHBvcnRzLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDAyMik7XG5leHBvcnRzLkNPTU1FTlRfREVMSU1JVEVSID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDIzKTtcbmV4cG9ydHMuRU9MID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDBhKTtcbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDA1Yyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0UXVvdGVkSWRlbnRpZmllciA9IGV4cG9ydHMuZ2V0Q29tbWVudCA9IGV4cG9ydHMuY3JlYXRlUmVzdWx0ID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIGNyZWF0ZVJlc3VsdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcmVtYWluaW5nU3RyaW5nKSB7IHJldHVybiAoe1xuICAgIHRva2VuOiBfX2Fzc2lnbih7IG5hbWU6IG5hbWUgfSwgKHZhbHVlICE9PSBudWxsID8geyB2YWx1ZTogdmFsdWUgfSA6IHt9KSksXG4gICAgcmVtYWluaW5nU3RyaW5nOiByZW1haW5pbmdTdHJpbmdcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVSZXN1bHQgPSBjcmVhdGVSZXN1bHQ7XG52YXIgZ2V0Q29tbWVudCA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHRva2VuRW5kID0gZXhwcmVzc2lvbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZXR0ZXIgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICBpZiAobGV0dGVyID09PSBjb25zdF8xLkVPTCkge1xuICAgICAgICAgICAgdG9rZW5FbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmNyZWF0ZVJlc3VsdCkodHlwZXNfMS5Ub2tlbnMuQ09NTUVOVCwgZXhwcmVzc2lvbi5zbGljZSgwLCB0b2tlbkVuZCksIGV4cHJlc3Npb24uc2xpY2UodG9rZW5FbmQgKyAxKSk7XG59O1xuZXhwb3J0cy5nZXRDb21tZW50ID0gZ2V0Q29tbWVudDtcbnZhciBnZXRRdW90ZWRJZGVudGlmaWVyID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgZXNjYXBlUXVvdGF0aW9uID0gZmFsc2U7XG4gICAgdmFyIHZhbHVlID0gJyc7XG4gICAgdmFyIHRva2VuRW5kID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICBpZiAodG9rZW5FbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUikge1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVRdW90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgtMSkgKyBjb25zdF8xLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5FU0NBUEVfQ0hBUkFDVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVF1b3RhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVRdW90YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGNoYXIpICYmICFjb25zdF8xLlNUUlVDVFVSQUxfQ0hBUkFDVEVSU1tjaGFyXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIi5jb25jYXQoY2hhciwgXCIgRXhwZWN0ZWQgKSBjaGFyYWN0ZXIgb3Igc2VwYXJhdG9yXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0b2tlbkVuZCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBleHBlY3RlZCBcIi5jb25jYXQoY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIsIFwiIGNoYXJhY3RlclwiKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVSZXN1bHQpKHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIsIHZhbHVlLCBleHByZXNzaW9uLnNsaWNlKHRva2VuRW5kICsgMSkpO1xufTtcbmV4cG9ydHMuZ2V0UXVvdGVkSWRlbnRpZmllciA9IGdldFF1b3RlZElkZW50aWZpZXI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sZXggPSB2b2lkIDA7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGxleCA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHRva2VuU3RhcnQgPSBudWxsO1xuICAgIHZhciB0b2tlbkVuZCA9IG51bGw7XG4gICAgdmFyIGRlbGltaXRpbmdDaGFyYWN0ZXIgPSBudWxsO1xuICAgIC8vIExvb3BzIHRocm91Z2ggY2hhcmFjdGVycyBpbiB0aGUgZXhwcmVzc2lvbiB1bnRpbCB0aGUgbmV4dCB0b2tlbiBpcyBmb3VuZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hhciA9IGV4cHJlc3Npb25baV07XG4gICAgICAgIC8vIEZpbmRzIHRva2VtIHN0YXJ0IGFuZCByZXR1cm5zIGltbWVkaWF0ZWx5IHJldHVybnMgYW55IGlkZW50aWZpYWJsZSB0b2tlbnNcbiAgICAgICAgaWYgKHRva2VuU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJ1Y3R1cmFsQ2hhciA9IGNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdO1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmFsQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBleHByZXNzaW9uW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdHVyYWxDaGFyID09PSB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLkNMT1NFX1BBUkVOVEhFU0lTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnN0XzEuU0VQQVJBVE9SUy5oYXMobmV4dENoYXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciAhPT0gdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiLmNvbmNhdChuZXh0Q2hhciwgXCIuIEEgY2xvc2luZyBwYXJlbnRoZXNpcyBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYW5vdGhlciBjbG9zaW5nIHBhcmVudGhlc2lzIG9yIHdoaXRlc3BhY2VcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jcmVhdGVSZXN1bHQpKHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSLCBjb25zdF8xLlNUUlVDVFVSQUxfQ0hBUkFDVEVSU1tjaGFyXSwgZXhwcmVzc2lvbi5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIGEgcXVvdGVkIGlkZW50aWZpZXIgaGFzIGJlZW4gaWRlbnRpZmllZCBpdCBpcyByZXRyaWV2ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0UXVvdGVkSWRlbnRpZmllcikoZXhwcmVzc2lvbi5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIGEgY29tbWVudCBoYXMgYmVlbiBpZGVudGlmaWVkIGl0IGlzIHJldHJpZXZlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuQ09NTUVOVF9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmdldENvbW1lbnQpKGV4cHJlc3Npb24uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5TdGFydCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCcmVha3Mgb24gdGhlIGVuZCBvZiB0aGUgdG9rZW4gYW5kIHRocm93cyBvbiBpbnZhbGlkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmIChjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGNoYXIpIHx8IGNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5FbmQgPSBpO1xuICAgICAgICAgICAgICAgIGRlbGltaXRpbmdDaGFyYWN0ZXIgPSBjaGFyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09IGNvbnN0XzEuQ09NTUVOVF9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiLmNvbmNhdChjaGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNlcGFyYXRlcyBvcGVyYXRvcnMgZnJvbSBpZGVudGlmaWVycyBhbmQgcmV0dXJucyB0aGUgY29ycmVjdCB0b2tlblxuICAgIGlmICh0b2tlblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRva2VuRW5kID0gdG9rZW5FbmQgIT09IG51bGwgJiYgdG9rZW5FbmQgIT09IHZvaWQgMCA/IHRva2VuRW5kIDogZXhwcmVzc2lvbi5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHJlc3Npb24uc2xpY2UodG9rZW5TdGFydCwgdG9rZW5FbmQpO1xuICAgICAgICB2YXIgcmVtYWluaW5nU3RyaW5nID0gZXhwcmVzc2lvbi5zbGljZSh0b2tlbkVuZCk7XG4gICAgICAgIGlmIChjb25zdF8xLk9QRVJBVE9SU1t2YWx1ZV0pIHtcbiAgICAgICAgICAgIGlmIChkZWxpbWl0aW5nQ2hhcmFjdGVyICYmICFjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGRlbGltaXRpbmdDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiLmNvbmNhdChkZWxpbWl0aW5nQ2hhcmFjdGVyLCBcIi4gT3BlcmF0b3JzIHNob3VsZCBiZSBzZXBhcmF0ZWQgdXNpbmcgd2hpdGVzcGFjZVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY3JlYXRlUmVzdWx0KSh0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgY29uc3RfMS5PUEVSQVRPUlNbdmFsdWVdLCByZW1haW5pbmdTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNyZWF0ZVJlc3VsdCkodHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiwgdmFsdWUsIHJlbWFpbmluZ1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyByZWFjaGVkIG5vIHRva2VucyB3ZXJlIGZvdW5kIHNvIEVPRiBpcyByZXR1cm5lZFxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jcmVhdGVSZXN1bHQpKHR5cGVzXzEuVG9rZW5zLkVPRiwgbnVsbCwgJycpO1xufTtcbmV4cG9ydHMubGV4ID0gbGV4O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudmFsaWRhdGVUb2tlbiA9IGV4cG9ydHMucHJldmlvdXNPcGVyYXRvclRha2VzUHJlY2VkZW50ID0gZXhwb3J0cy5nZXRWYWx1ZSA9IGV4cG9ydHMubmV3VG9rZW5HZW5lcmF0b3IgPSB2b2lkIDA7XG52YXIgbGV4XzEgPSByZXF1aXJlKFwiLi4vbGV4L2xleFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbnZhciBuZXdUb2tlbkdlbmVyYXRvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHJlbWFpbmluZ0V4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsaWRUb2tlbnMsIGVuZElzVmFsaWQpIHtcbiAgICAgICAgaWYgKGVuZElzVmFsaWQgPT09IHZvaWQgMCkgeyBlbmRJc1ZhbGlkID0gZmFsc2U7IH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9ICgwLCBsZXhfMS5sZXgpKHJlbWFpbmluZ0V4cHJlc3Npb24pLCB0b2tlbiA9IF9hLnRva2VuLCByZW1haW5pbmdTdHJpbmcgPSBfYS5yZW1haW5pbmdTdHJpbmc7XG4gICAgICAgICAgICByZW1haW5pbmdFeHByZXNzaW9uID0gcmVtYWluaW5nU3RyaW5nO1xuICAgICAgICAgICAgaWYgKHRva2VuLm5hbWUgIT09IHR5cGVzXzEuVG9rZW5zLkNPTU1FTlQpIHtcbiAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy52YWxpZGF0ZVRva2VuKSh0b2tlbiwgdmFsaWRUb2tlbnMsIGVuZElzVmFsaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy5uZXdUb2tlbkdlbmVyYXRvciA9IG5ld1Rva2VuR2VuZXJhdG9yO1xudmFyIGdldFZhbHVlID0gZnVuY3Rpb24gKGdldE5leHRUb2tlbiwgcGFyc2VyKSB7XG4gICAgdmFyIG5leHRUb2tlbiA9IGdldE5leHRUb2tlbihjb25zdF8xLlZBTElEX1RPS0VOUy5pZGVudGlmaWVyT3JOb3QpO1xuICAgIHZhciBuZWdhdGVkVmFsdWUgPSBuZXh0VG9rZW4udmFsdWUgPT09IHR5cGVzXzEuT3BlcmF0b3JzLk5PVDtcbiAgICBpZiAobmVnYXRlZFZhbHVlKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IGdldE5leHRUb2tlbihjb25zdF8xLlZBTElEX1RPS0VOUy5pZGVudGlmaWVyT25seSk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5leHRUb2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlxuICAgICAgICA/IHBhcnNlcihnZXROZXh0VG9rZW4sIHRydWUpXG4gICAgICAgIDogW25leHRUb2tlbl07XG4gICAgcmV0dXJuIG5lZ2F0ZWRWYWx1ZVxuICAgICAgICA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgdmFsdWUsIHRydWUpLCBbeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCB9XSwgZmFsc2UpIDogdmFsdWU7XG59O1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xudmFyIHByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudCA9IGZ1bmN0aW9uIChwcmV2aW91c09wZXJhdG9yLCBuZXh0T3BlcmF0b3IpIHtcbiAgICByZXR1cm4gY29uc3RfMS5PUEVSQVRPUl9QUkVDRURFTkNFW3ByZXZpb3VzT3BlcmF0b3JdIDw9IGNvbnN0XzEuT1BFUkFUT1JfUFJFQ0VERU5DRVtuZXh0T3BlcmF0b3JdO1xufTtcbmV4cG9ydHMucHJldmlvdXNPcGVyYXRvclRha2VzUHJlY2VkZW50ID0gcHJldmlvdXNPcGVyYXRvclRha2VzUHJlY2VkZW50O1xudmFyIHZhbGlkYXRlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbGlkVG9rZW5zLCBlbmRJc1ZhbGlkKSB7XG4gICAgaWYgKGVuZElzVmFsaWQgPT09IHZvaWQgMCkgeyBlbmRJc1ZhbGlkID0gZmFsc2U7IH1cbiAgICBpZiAodG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuRU9GKSB7XG4gICAgICAgIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uJyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgdmFsaWRUb2tlbnNfMSA9IHZhbGlkVG9rZW5zOyBfaSA8IHZhbGlkVG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB2YWxpZFRva2VuID0gdmFsaWRUb2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh2YWxpZFRva2VuLm5hbWUgPT09IHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRUb2tlbi52YWx1ZSB8fCB2YWxpZFRva2VuLnZhbHVlID09PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVRva2VuID0gdmFsaWRhdGVUb2tlbjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnBhcnNlID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIFJldHVybnMgdGhlIHRva2VucyB1c2luZyBwb3N0Zml4IG5vdGF0aW9uXG52YXIgcGFyc2UgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCBcIi5jb25jYXQodHlwZW9mIGV4cHJlc3Npb24pKTtcbiAgICB9XG4gICAgLy8gZ2V0TmV4dFRva2VuIGtlZXBzIHRyYWNrIG9mIHRoZSByZW1haW5pbmcgZXhwcmVzc2lvblxuICAgIC8vIGFuZCByZXR1cm4gdGhlIG5leHQgdG9rZW4gZWFjaCB0aW1lIGl0IGlzIGNhbGxlZFxuICAgIHZhciBnZXROZXh0VG9rZW4gPSAoMCwgdXRpbHNfMS5uZXdUb2tlbkdlbmVyYXRvcikoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIHBhcnNlSW50ZXJuYWwoZ2V0TmV4dFRva2VuKTtcbn07XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyBwYXJzZUludGVybmFsIHdpbGwgcmVjdXJzZSBvdmVyIGJyYWNrZXRlZCBleHByZXNzaW9uc1xudmFyIHBhcnNlSW50ZXJuYWwgPSBmdW5jdGlvbiAoZ2V0TmV4dFRva2VuLCBuZXN0ZWQpIHtcbiAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHsgbmVzdGVkID0gZmFsc2U7IH1cbiAgICAvLyBUaGlzIGluaXRpYWxpc2VzIHRoZSBvdXRwdXQgd2l0aCBldmVyeXRoaW5nIHVwIHRoZSBmaXJzdCB1bm5lc3RlZCBvcGVyYXRvclxuICAgIHZhciBvdXRwdXQgPSBfX3NwcmVhZEFycmF5KFtdLCAoMCwgdXRpbHNfMS5nZXRWYWx1ZSkoZ2V0TmV4dFRva2VuLCBwYXJzZUludGVybmFsKSwgdHJ1ZSk7XG4gICAgdmFyIG9wZXJhdG9ycyA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciB2YWxpZFRva2VucyA9IG5lc3RlZFxuICAgICAgICAgICAgPyBjb25zdF8xLlZBTElEX1RPS0VOUy5iaW5hcnlPcGVyYXRvck9yQ2xvc2VcbiAgICAgICAgICAgIDogY29uc3RfMS5WQUxJRF9UT0tFTlMuYmluYXJ5T3BlcmF0b3I7XG4gICAgICAgIC8vIFJldHJpZXZlcyB0aGUgbmV4dCBUb2tlblxuICAgICAgICB2YXIgbmV4dFRva2VuID0gZ2V0TmV4dFRva2VuKHZhbGlkVG9rZW5zLCAhbmVzdGVkKTtcbiAgICAgICAgaWYgKG5leHRUb2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5FT0YgfHwgLy8gSWYgdGhlIGVuZCBvZiBmaWxlIGlzIGZvdW5kIGhlcmUgdGhlbiByZXR1cm4gd2hhdCB3ZSBoYXZlXG4gICAgICAgICAgICBuZXh0VG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIgLy8gVGhlIGV4cHJlc3Npb24gd2lsbCBiZSByZXR1cm5lZCBhbmQgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGZpbmFsIGV4cHJlc3Npb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvdXRwdXQsIHRydWUpLCBfX3NwcmVhZEFycmF5KFtdLCBvcGVyYXRvcnMsIHRydWUpLnJldmVyc2UoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gcG9zdGZpeCBub3RhdGlvbiBvcGVyYXRvciBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5IHByZWNlZGVuY2VcbiAgICAgICAgd2hpbGUgKG9wZXJhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c09wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdG9ycy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0b3IgJiZcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5wcmV2aW91c09wZXJhdG9yVGFrZXNQcmVjZWRlbnQpKHByZXZpb3VzT3BlcmF0b3IudmFsdWUsIG5leHRUb2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG91dHB1dCwgdHJ1ZSksIFtwcmV2aW91c09wZXJhdG9yXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9ycyA9IG9wZXJhdG9ycy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV3IG9wZXJhdG9yIGlzIG5vdyBhZGRlZCB0byB0aGUgc3RhY2tcbiAgICAgICAgb3BlcmF0b3JzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcGVyYXRvcnMsIHRydWUpLCBbbmV4dFRva2VuXSwgZmFsc2UpO1xuICAgICAgICAvLyBPbmNlIHRoaXMgaXMgZG9uZSB3ZSBjYW4gZ2V0IGV2ZXJ5dGhpbmcgdW50aWwgdGhlIG5leHQgdW5uZXN0ZWRcbiAgICAgICAgLy8gb3BlcmF0b3IgYW5kIGFkZCBpdCB0byB0aGUgb3V0cHV0XG4gICAgICAgIG91dHB1dCA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3V0cHV0LCB0cnVlKSwgKDAsIHV0aWxzXzEuZ2V0VmFsdWUpKGdldE5leHRUb2tlbiwgcGFyc2VJbnRlcm5hbCksIHRydWUpO1xuICAgIH1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy50aHJvd0ludmFsaWRFeHByZXNzaW9uID0gZXhwb3J0cy5pc09wZXJhdG9yID0gZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBleHBvcnRzLm5vdFV0aWwgPSBleHBvcnRzLnhvclV0aWwgPSBleHBvcnRzLm9yVXRpbCA9IGV4cG9ydHMuYW5kVXRpbCA9IHZvaWQgMDtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGFuZFV0aWwgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7IH07XG5leHBvcnRzLmFuZFV0aWwgPSBhbmRVdGlsO1xudmFyIG9yVXRpbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCB8fCByaWdodDsgfTtcbmV4cG9ydHMub3JVdGlsID0gb3JVdGlsO1xudmFyIHhvclV0aWwgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuICEobGVmdCA9PT0gcmlnaHQpOyB9O1xuZXhwb3J0cy54b3JVdGlsID0geG9yVXRpbDtcbnZhciBub3RVdGlsID0gZnVuY3Rpb24gKGlkZW50aWZpZXIpIHsgcmV0dXJuICFpZGVudGlmaWVyOyB9O1xuZXhwb3J0cy5ub3RVdGlsID0gbm90VXRpbDtcbnZhciBpc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn07XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbnZhciBpc09wZXJhdG9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBuYW1lID09PSB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcbmV4cG9ydHMuaXNPcGVyYXRvciA9IGlzT3BlcmF0b3I7XG52YXIgdGhyb3dJbnZhbGlkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcG9zdGZpeCBleHByZXNzaW9uOiBcIi5jb25jYXQobWVzc2FnZSkpO1xufTtcbmV4cG9ydHMudGhyb3dJbnZhbGlkRXhwcmVzc2lvbiA9IHRocm93SW52YWxpZEV4cHJlc3Npb247XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5PUEVSQVRPUl9NQVAgPSB2b2lkIDA7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLk9QRVJBVE9SX01BUCA9IChfYSA9IHt9LFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLkFORF0gPSB1dGlsc18xLmFuZFV0aWwsXG4gICAgX2FbdHlwZXNfMS5PcGVyYXRvcnMuT1JdID0gdXRpbHNfMS5vclV0aWwsXG4gICAgX2FbdHlwZXNfMS5PcGVyYXRvcnMuWE9SXSA9IHV0aWxzXzEueG9yVXRpbCxcbiAgICBfYSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5ldmFsdWF0ZSA9IGV4cG9ydHMuZ2V0RXZhbHVhdG9yID0gdm9pZCAwO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi4vcGFyc2UvcGFyc2VcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGdldEV2YWx1YXRvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHBhcnNlZEV4cHJlc3Npb24gPSAoMCwgcGFyc2VfMS5wYXJzZSkoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChib29sZWFuTWFwKSB7IHJldHVybiAoMCwgZXhwb3J0cy5ldmFsdWF0ZSkocGFyc2VkRXhwcmVzc2lvbiwgYm9vbGVhbk1hcCk7IH07XG59O1xuZXhwb3J0cy5nZXRFdmFsdWF0b3IgPSBnZXRFdmFsdWF0b3I7XG52YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgYm9vbGVhbk1hcCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHByZXNzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoZXhwcmVzc2lvbiwgXCIgc2hvdWxkIGJlIGFuIGFycmF5LiBldmFsdWF0ZSB0YWtlcyBpbiBhIHBhcnNlZCBleHByZXNzaW9uLiBVc2UgaW4gY29tYmluYXRpb24gd2l0aCBwYXJzZSBvciB1c2UgZ2V0RXZhbHVhdG9yXCIpKTtcbiAgICB9XG4gICAgLy8gUmVzb2x2ZXMgZWFjaCBpZGVudGlmaWVyIGFuZCBhZGRzIGl0IHRvIGEgc3RhY2tcbiAgICAvLyBXaGVuIG9wZXJhdG9yIGlzIGZvdW5kIGl0IG9wZXJhdGVzIG9uIHRoZSB0b3AgdmFsdWUocylcbiAgICAvLyBvbiB0aGUgc3RhY2ssIHJlbW92ZXMgdGhlbSBhbmQgcmVwbGFjZXMgdGhlbSB3aXRoIHRoZVxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBldmFsdWF0ZWRFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZWR1Y2UoZnVuY3Rpb24gKHN0YWNrLCB0b2tlbiwgaSkge1xuICAgICAgICBpZiAoISh0b2tlbiAmJiAoKDAsIHV0aWxzXzEuaXNJZGVudGlmaWVyKSh0b2tlbikgfHwgKDAsIHV0aWxzXzEuaXNPcGVyYXRvcikodG9rZW4pKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG9rZW46IFwiLmNvbmNhdCh0b2tlbiwgXCIuIEZvdW5kIGluIHBhcnNlZCBleHByZXNzaW9uIGF0IGluZGV4IFwiKS5jb25jYXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBzdGFjaywgdHJ1ZSksIFtCb29sZWFuKGJvb2xlYW5NYXBbdG9rZW4udmFsdWVdKV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vjb25kTGFzdEl0ZW0gPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGxhc3RJdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gdHlwZXNfMS5PcGVyYXRvcnMuTk9UKSB7XG4gICAgICAgICAgICBpZiAobGFzdEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24pKCdtaXNzaW5nIGlkZW50aWZpZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHN0YWNrLnNsaWNlKDAsIC0xKSwgdHJ1ZSksIFsoMCwgdXRpbHNfMS5ub3RVdGlsKShsYXN0SXRlbSldLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJdGVtID09PSB1bmRlZmluZWQgfHwgc2Vjb25kTGFzdEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbikoJ21pc3NpbmcgaWRlbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRvclV0aWwgPSBjb25zdF8xLk9QRVJBVE9SX01BUFt0b2tlbi52YWx1ZV07XG4gICAgICAgIGlmICghb3BlcmF0b3JVdGlsKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS50aHJvd0ludmFsaWRFeHByZXNzaW9uKSgndW5rbm93biBvcGVyYXRvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHN0YWNrLnNsaWNlKDAsIC0yKSwgdHJ1ZSksIFtvcGVyYXRvclV0aWwoc2Vjb25kTGFzdEl0ZW0sIGxhc3RJdGVtKV0sIGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGV2YWx1YXRlZEV4cHJlc3Npb24ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICgwLCB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24pKCd0b28gbWFueSBpZGVudGlmaWVycyBhZnRlciBldmFsdWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0ZWRFeHByZXNzaW9uWzBdO1xufTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuZXZhbHVhdGUgPSBleHBvcnRzLmdldEV2YWx1YXRvciA9IHZvaWQgMDtcbnZhciBldmFsdWF0ZV8xID0gcmVxdWlyZShcIi4vZXZhbHVhdGUvZXZhbHVhdGVcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgZXZhbHVhdGVfMSwgXCJnZXRFdmFsdWF0b3JcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgZXZhbHVhdGVfMSwgXCJldmFsdWF0ZVwiKTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vcGFyc2UvcGFyc2VcIik7XG5fX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgcGFyc2VfMSwgXCJwYXJzZVwiKTtcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJ1Rhc2svVGFzayc7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4vT2JzaWRpYW4vQ2FjaGUnO1xuaW1wb3J0IHsgQ29tbWFuZHMgfSBmcm9tICcuL0NvbW1hbmRzJztcbmltcG9ydCB7IEdsb2JhbFF1ZXJ5IH0gZnJvbSAnLi9Db25maWcvR2xvYmFsUXVlcnknO1xuaW1wb3J0IHsgVGFza3NFdmVudHMgfSBmcm9tICcuL09ic2lkaWFuL1Rhc2tzRXZlbnRzJztcbmltcG9ydCB7IGluaXRpYWxpemVGaWxlIH0gZnJvbSAnLi9PYnNpZGlhbi9GaWxlJztcbmltcG9ydCB7IElubGluZVJlbmRlcmVyIH0gZnJvbSAnLi9PYnNpZGlhbi9JbmxpbmVSZW5kZXJlcic7XG5pbXBvcnQgeyBuZXdMaXZlUHJldmlld0V4dGVuc2lvbiB9IGZyb20gJy4vT2JzaWRpYW4vTGl2ZVByZXZpZXdFeHRlbnNpb24nO1xuaW1wb3J0IHsgUXVlcnlSZW5kZXJlciB9IGZyb20gJy4vUmVuZGVyZXIvUXVlcnlSZW5kZXJlcic7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSBmcm9tICcuL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBTZXR0aW5nc1RhYiB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzVGFiJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi9TdGF0dXNlcy9TdGF0dXNSZWdpc3RyeSc7XG5pbXBvcnQgeyBsb2csIGxvZ2dpbmcgfSBmcm9tICcuL2xpYi9sb2dnaW5nJztcbmltcG9ydCB7IEVkaXRvclN1Z2dlc3RvciB9IGZyb20gJy4vU3VnZ2VzdG9yL0VkaXRvclN1Z2dlc3RvclBvcHVwJztcbmltcG9ydCB7IFN0YXR1c1NldHRpbmdzIH0gZnJvbSAnLi9Db25maWcvU3RhdHVzU2V0dGluZ3MnO1xuaW1wb3J0IHsgdGFza3NBcGlWMSB9IGZyb20gJy4vQXBpJztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBwcml2YXRlIGNhY2hlOiBDYWNoZSB8IHVuZGVmaW5lZDtcbiAgICBwdWJsaWMgaW5saW5lUmVuZGVyZXI6IElubGluZVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBxdWVyeVJlbmRlcmVyOiBRdWVyeVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgZ2V0IGFwaVYxKCkge1xuICAgICAgICByZXR1cm4gdGFza3NBcGlWMShhcHApO1xuICAgIH1cblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgbG9nZ2luZy5yZWdpc3RlckNvbnNvbGVMb2dnZXIoKTtcbiAgICAgICAgbG9nKCdpbmZvJywgYGxvYWRpbmcgcGx1Z2luIFwiJHt0aGlzLm1hbmlmZXN0Lm5hbWV9XCIgdiR7dGhpcy5tYW5pZmVzdC52ZXJzaW9ufWApO1xuXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIGxvZ2dpbmcuXG4gICAgICAgIGNvbnN0IHsgbG9nZ2luZ09wdGlvbnMgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGxvZ2dpbmcuY29uZmlndXJlKGxvZ2dpbmdPcHRpb25zKTtcblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHsgcGx1Z2luOiB0aGlzIH0pKTtcblxuICAgICAgICBpbml0aWFsaXplRmlsZSh7XG4gICAgICAgICAgICBtZXRhZGF0YUNhY2hlOiB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgdmF1bHQ6IHRoaXMuYXBwLnZhdWx0LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB0aGlzLmFwcC53b3Jrc3BhY2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvYWQgY29uZmlndXJlZCBzdGF0dXMgdHlwZXMuXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFRhc2tTdGF0dXNlcygpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBUYXNrc0V2ZW50cyh7IG9ic2lkaWFuRXZlbnRzOiB0aGlzLmFwcC53b3Jrc3BhY2UgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoe1xuICAgICAgICAgICAgbWV0YWRhdGFDYWNoZTogdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgIHZhdWx0OiB0aGlzLmFwcC52YXVsdCxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5saW5lUmVuZGVyZXIgPSBuZXcgSW5saW5lUmVuZGVyZXIoeyBwbHVnaW46IHRoaXMgfSk7XG4gICAgICAgIHRoaXMucXVlcnlSZW5kZXJlciA9IG5ldyBRdWVyeVJlbmRlcmVyKHsgcGx1Z2luOiB0aGlzLCBldmVudHMgfSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihuZXdMaXZlUHJldmlld0V4dGVuc2lvbigpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvclN1Z2dlc3QobmV3IEVkaXRvclN1Z2dlc3Rvcih0aGlzLmFwcCwgZ2V0U2V0dGluZ3MoKSwgdGhpcykpO1xuICAgICAgICBuZXcgQ29tbWFuZHMoeyBwbHVnaW46IHRoaXMgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFRhc2tTdGF0dXNlcygpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXNTZXR0aW5ncyB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgU3RhdHVzU2V0dGluZ3MuYXBwbHlUb1N0YXR1c1JlZ2lzdHJ5KHN0YXR1c1NldHRpbmdzLCBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgbG9nKCdpbmZvJywgYHVubG9hZGluZyBwbHVnaW4gXCIke3RoaXMubWFuaWZlc3QubmFtZX1cIiB2JHt0aGlzLm1hbmlmZXN0LnZlcnNpb259YCk7XG4gICAgICAgIHRoaXMuY2FjaGU/LnVubG9hZCgpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IG5ld1NldHRpbmdzID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgICB1cGRhdGVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHVwZGF0ZWQgc2V0dGluZ3MsIGluIGNhc2UgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgZWRpdGVkIHRoZSBzZXR0aW5ncyxcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSBuZXdTZXR0aW5ncyBpcyBjdXJyZW50bHkgZW1wdHkuXG4gICAgICAgIG5ld1NldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuc2V0KG5ld1NldHRpbmdzLmdsb2JhbEZpbHRlcik7XG4gICAgICAgIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnNldFJlbW92ZUdsb2JhbEZpbHRlcihuZXdTZXR0aW5ncy5yZW1vdmVHbG9iYWxGaWx0ZXIpO1xuICAgICAgICBHbG9iYWxRdWVyeS5nZXRJbnN0YW5jZSgpLnNldChuZXdTZXR0aW5ncy5nbG9iYWxRdWVyeSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkVGFza1N0YXR1c2VzKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKGdldFNldHRpbmdzKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUYXNrcygpOiBUYXNrW10ge1xuICAgICAgICBpZiAodGhpcy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW10gYXMgVGFza1tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0VGFza3MoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBNZXRhZGF0YUNhY2hlLCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgQ2FjaGVkTWV0YWRhdGEsIEV2ZW50UmVmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBIZWFkaW5nQ2FjaGUsIExpc3RJdGVtQ2FjaGUsIFNlY3Rpb25DYWNoZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IE11dGV4IH0gZnJvbSAnYXN5bmMtbXV0ZXgnO1xuaW1wb3J0IHsgVGFza3NGaWxlIH0gZnJvbSAnLi4vU2NyaXB0aW5nL1Rhc2tzRmlsZSc7XG5cbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi4vVGFzay9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgTGF6eSB9IGZyb20gJy4uL2xpYi9MYXp5JztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2svVGFza0xvY2F0aW9uJztcbmltcG9ydCB7IExvZ2dlciwgbG9nZ2luZyB9IGZyb20gJy4uL2xpYi9sb2dnaW5nJztcbmltcG9ydCB0eXBlIHsgVGFza3NFdmVudHMgfSBmcm9tICcuL1Rhc2tzRXZlbnRzJztcblxuZXhwb3J0IGVudW0gU3RhdGUge1xuICAgIENvbGQgPSAnQ29sZCcsXG4gICAgSW5pdGlhbGl6aW5nID0gJ0luaXRpYWxpemluZycsXG4gICAgV2FybSA9ICdXYXJtJyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhc2tzRnJvbUZpbGVDb250ZW50MihcbiAgICBmaWxlUGF0aDogc3RyaW5nLFxuICAgIGZpbGVDb250ZW50OiBzdHJpbmcsXG4gICAgbGlzdEl0ZW1zOiBMaXN0SXRlbUNhY2hlW10sXG4gICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgZmlsZUNhY2hlOiBDYWNoZWRNZXRhZGF0YSxcbiAgICBlcnJvclJlcG9ydGVyOiAoZTogYW55LCBmaWxlUGF0aDogc3RyaW5nLCBsaXN0SXRlbTogTGlzdEl0ZW1DYWNoZSwgbGluZTogc3RyaW5nKSA9PiB2b2lkLFxuKSB7XG4gICAgY29uc3QgdGFza3NGaWxlID0gbmV3IFRhc2tzRmlsZShmaWxlUGF0aCk7XG4gICAgY29uc3QgdGFza3M6IFRhc2tbXSA9IFtdO1xuICAgIGNvbnN0IGZpbGVMaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBsaW5lc0luRmlsZSA9IGZpbGVMaW5lcy5sZW5ndGg7XG5cbiAgICAvLyBMYXppbHkgc3RvcmUgZGF0ZSBleHRyYWN0ZWQgZnJvbSBmaWxlbmFtZSB0byBhdm9pZCBwYXJzaW5nIG1vcmUgdGhhbiBuZWVkZWRcbiAgICAvLyB0aGlzLmxvZ2dlci5kZWJ1ZyhgZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQoKSByZWFkaW5nICR7ZmlsZS5wYXRofWApO1xuICAgIGNvbnN0IGRhdGVGcm9tRmlsZU5hbWUgPSBuZXcgTGF6eSgoKSA9PiBEYXRlRmFsbGJhY2suZnJvbVBhdGgoZmlsZVBhdGgpKTtcblxuICAgIC8vIFdlIHdhbnQgdG8gc3RvcmUgc2VjdGlvbiBpbmZvcm1hdGlvbiB3aXRoIGV2ZXJ5IHRhc2sgc29cbiAgICAvLyB0aGF0IHdlIGNhbiB1c2UgdGhhdCB3aGVuIHdlIHBvc3QgcHJvY2VzcyB0aGUgbWFya2Rvd25cbiAgICAvLyByZW5kZXJlZCBsaXN0cy5cbiAgICBsZXQgY3VycmVudFNlY3Rpb246IFNlY3Rpb25DYWNoZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBzZWN0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgbGlzdEl0ZW0gb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbS50YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBsaXN0SXRlbS5wb3NpdGlvbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgPj0gbGluZXNJbkZpbGUpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBPYnNpZGlhbiBDYWNoZWRNZXRhZGF0YSBoYXMgdG9sZCB1cyB0aGF0IHRoZXJlIGlzIGEgdGFzayBvbiBsaW5lTnVtYmVyLCBidXQgdGhlcmUgYXJlXG4gICAgICAgICAgICAgICAgICAgIG5vdCB0aGF0IG1hbnkgbGluZXMgaW4gdGhlIGZpbGUuXG5cbiAgICAgICAgICAgICAgICAgICAgVGhpcyB3YXMgdGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgYWxsIHRoZSAnU3R1Y2sgb24gXCJMb2FkaW5nIFRhc2tzLi4uXCInIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICBhcyBpdCByZXN1bHRlZCBpbiB0aGUgbGluZSAndW5kZWZpbmVkJyBiZWluZyBwYXJzZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgU29tZWhvdyB0aGUgZmlsZSBoYWQgYmVlbiBzaG9ydGVuZWQgd2hpbHN0IE9ic2lkaWFuIHdhcyBjbG9zZWQsIG1lYW5pbmcgdGhhdFxuICAgICAgICAgICAgICAgICAgICB3aGVuIE9ic2lkaWFuIHN0YXJ0ZWQgdXAsIGl0IGdvdCB0aGUgbmV3IGZpbGUgY29udGVudCwgYnV0IHN0aWxsIGhhZCB0aGUgb2xkIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICBkYXRhIGFib3V0IGxvY2F0aW9ucyBvZiBsaXN0IGl0ZW1zIGluIHRoZSBmaWxlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgYCR7ZmlsZVBhdGh9IE9ic2lkaWFuIGdhdmUgdXMgYSBsaW5lIG51bWJlciAke2xpbmVOdW1iZXJ9IHBhc3QgdGhlIGVuZCBvZiB0aGUgZmlsZS4gJHtsaW5lc0luRmlsZX0uYCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50U2VjdGlvbi5wb3NpdGlvbi5lbmQubGluZSA8IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB3ZW50IHBhc3QgdGhlIGN1cnJlbnQgc2VjdGlvbiAob3IgdGhpcyBpcyB0aGUgZmlyc3QgdGFzaykuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc2VjdGlvbiB0aGF0IGlzIHJlbGV2YW50IGZvciB0aGlzIHRhc2sgYW5kIHRoZSBmb2xsb3dpbmcgb2YgdGhlIHNhbWUgc2VjdGlvbi5cbiAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IENhY2hlLmdldFNlY3Rpb24obGluZU51bWJlciwgZmlsZUNhY2hlLnNlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcHJvY2VzcyBhIHRhc2sgd2l0aG91dCBhIHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBmaWxlTGluZXNbbGluZU51bWJlcl07XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2ZpbGVQYXRofTogbGluZSAke2xpbmVOdW1iZXJ9IC0gaWdub3JpbmcgJ3VuZGVmaW5lZCcgbGluZS5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2sgPSBUYXNrLmZyb21MaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGFza0xvY2F0aW9uOiBuZXcgVGFza0xvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3NGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBDYWNoZS5nZXRQcmVjZWRpbmdIZWFkZXIobGluZU51bWJlciwgZmlsZUNhY2hlLmhlYWRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tEYXRlOiBkYXRlRnJvbUZpbGVOYW1lLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yUmVwb3J0ZXIoZSwgZmlsZVBhdGgsIGxpc3RJdGVtLCBsaW5lKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhc2tzO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIGxvZ2dlciA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd0YXNrcy5DYWNoZScpO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRhZGF0YUNhY2hlOiBNZXRhZGF0YUNhY2hlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlczogRXZlbnRSZWZbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhdWx0OiBWYXVsdDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhdWx0RXZlbnRSZWZlcmVuY2VzOiBFdmVudFJlZltdO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBUYXNrc0V2ZW50cztcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50c0V2ZW50UmVmZXJlbmNlczogRXZlbnRSZWZbXTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGFza3NNdXRleDogTXV0ZXg7XG4gICAgcHJpdmF0ZSBzdGF0ZTogU3RhdGU7XG4gICAgcHJpdmF0ZSB0YXNrczogVGFza1tdO1xuXG4gICAgLyoqXG4gICAgICogV2UgY2Fubm90IGtub3cgaWYgdGhpcyBjbGFzcyB3aWxsIGJlIGluc3RhbnRpYXRlZCBiZWNhdXNlIG9ic2lkaWFuIHN0YXJ0ZWRcbiAgICAgKiBvciBiZWNhdXNlIHRoZSBwbHVnaW4gd2FzIGFjdGl2YXRlZCBsYXRlci4gVGhpcyBtZWFucyB3ZSBoYXZlIHRvIGxvYWQgdGhlXG4gICAgICogd2hvbGUgdmF1bHQgb25jZSBhZnRlciB0aGUgZmlyc3QgbWV0YWRhdGEgY2FjaGUgcmVzb2x2ZSB0byBlbnN1cmUgdGhhdCB3ZVxuICAgICAqIGxvYWQgdGhlIGVudGlyZSB2YXVsdCBpbiBjYXNlIG9ic2lkaWFuIGlzIHN0YXJ0aW5nIHVwLiBJbiB0aGUgY2FzZSBvZlxuICAgICAqIG9ic2lkaWFuIHN0YXJ0aW5nLCB0aGUgdGFzayBjYWNoZSdzIGluaXRpYWwgbG9hZCB3b3VsZCBlbmQgdXAgd2l0aCAwIHRhc2tzLFxuICAgICAqIGFzIHRoZSBtZXRhZGF0YSBjYWNoZSB3b3VsZCBzdGlsbCBiZSBlbXB0eS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRlZEFmdGVyRmlyc3RSZXNvbHZlOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoeyBtZXRhZGF0YUNhY2hlLCB2YXVsdCwgZXZlbnRzIH06IHsgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTsgdmF1bHQ6IFZhdWx0OyBldmVudHM6IFRhc2tzRXZlbnRzIH0pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NyZWF0aW5nIENhY2hlIG9iamVjdCcpO1xuXG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG1ldGFkYXRhQ2FjaGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnZhdWx0ID0gdmF1bHQ7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgdGhpcy50YXNrc011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5Db2xkO1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2FjaGUuY29uc3RydWN0b3IoKTogc3RhdGUgPSBDb2xkJyk7XG5cbiAgICAgICAgdGhpcy50YXNrcyA9IFtdO1xuXG4gICAgICAgIHRoaXMubG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1ZhdWx0KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMoKTtcblxuICAgICAgICB0aGlzLmxvYWRWYXVsdCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1bmxvYWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1VubG9hZGluZyBDYWNoZScpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRSZWZlcmVuY2Ugb2YgdGhpcy5tZXRhZGF0YUNhY2hlRXZlbnRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUub2ZmcmVmKGV2ZW50UmVmZXJlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRSZWZlcmVuY2Ugb2YgdGhpcy52YXVsdEV2ZW50UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgdGhpcy52YXVsdC5vZmZyZWYoZXZlbnRSZWZlcmVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBldmVudFJlZmVyZW5jZSBvZiB0aGlzLmV2ZW50c0V2ZW50UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMub2ZmKGV2ZW50UmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUYXNrcygpOiBUYXNrW10ge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3RhdGUoKTogU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG5vdGlmeVN1YnNjcmliZXJzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2FjaGUubm90aWZ5U3Vic2NyaWJlcnMoKScpO1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyQ2FjaGVVcGRhdGUoe1xuICAgICAgICAgICAgdGFza3M6IHRoaXMudGFza3MsXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb0NhY2hlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2FjaGUuc3Vic2NyaWJlVG9DYWNoZSgpJyk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRXZlbnRlUmVmZXJlbmNlID0gdGhpcy5tZXRhZGF0YUNhY2hlLm9uKCdyZXNvbHZlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmVkIGZpcmVzIG9uIGV2ZXJ5IGNoYW5nZS5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBpbml0aWFsaXplIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRBZnRlckZpcnN0UmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZFZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChyZXNvbHZlZEV2ZW50ZVJlZmVyZW5jZSk7XG5cbiAgICAgICAgLy8gRG9lcyBub3QgZmlyZSB3aGVuIHN0YXJ0aW5nIHVwIG9ic2lkaWFuIGFuZCBvbmx5IHdvcmtzIGZvciBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBjaGFuZ2VkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLm1ldGFkYXRhQ2FjaGUub24oJ2NoYW5nZWQnLCAoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChjaGFuZ2VkRXZlbnRSZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9WYXVsdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NhY2hlLnN1YnNjcmliZVRvVmF1bHQoKScpO1xuICAgICAgICBjb25zdCB7IHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRFdmVudFJlZmVyZW5jZSA9IHRoaXMudmF1bHQub24oJ2NyZWF0ZScsIChmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYENhY2hlLnN1YnNjcmliZVRvVmF1bHQuY3JlYXRlZEV2ZW50UmVmZXJlbmNlKCkgJHtmaWxlLnBhdGh9YCk7XG5cbiAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2goY3JlYXRlZEV2ZW50UmVmZXJlbmNlKTtcblxuICAgICAgICBjb25zdCBkZWxldGVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdkZWxldGUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDYWNoZS5zdWJzY3JpYmVUb1ZhdWx0LmRlbGV0ZWRFdmVudFJlZmVyZW5jZSgpICR7ZmlsZS5wYXRofWApO1xuXG4gICAgICAgICAgICB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5maWx0ZXIoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCAhPT0gZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2goZGVsZXRlZEV2ZW50UmVmZXJlbmNlKTtcblxuICAgICAgICBjb25zdCByZW5hbWVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYENhY2hlLnN1YnNjcmliZVRvVmF1bHQucmVuYW1lZEV2ZW50UmVmZXJlbmNlKCkgJHtmaWxlLnBhdGh9YCk7XG5cbiAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzRmlsZSA9IG5ldyBUYXNrc0ZpbGUoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja0RhdGUgPSBuZXcgTGF6eSgoKSA9PiBEYXRlRmFsbGJhY2suZnJvbVBhdGgoZmlsZS5wYXRoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5tYXAoKHRhc2s6IFRhc2spOiBUYXNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sucGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogdGFzay50YXNrTG9jYXRpb24uZnJvbVJlbmFtZWRGaWxlKHRhc2tzRmlsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlRmFsbGJhY2sudXBkYXRlVGFza1BhdGgodGFzaywgZmlsZS5wYXRoLCBmYWxsYmFja0RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXVsdEV2ZW50UmVmZXJlbmNlcy5wdXNoKHJlbmFtZWRFdmVudFJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb0V2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NhY2hlLnN1YnNjcmliZVRvRXZlbnRzKCknKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFJlZmVyZW5jZSA9IHRoaXMuZXZlbnRzLm9uUmVxdWVzdENhY2hlVXBkYXRlKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKHsgdGFza3M6IHRoaXMudGFza3MsIHN0YXRlOiB0aGlzLnN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHNFdmVudFJlZmVyZW5jZXMucHVzaChyZXF1ZXN0UmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxvYWRWYXVsdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NhY2hlLmxvYWRWYXVsdCgpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5Jbml0aWFsaXppbmc7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2FjaGUubG9hZFZhdWx0KCk6IHN0YXRlID0gSW5pdGlhbGl6aW5nJyk7XG5cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLm1hcCgoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XYXJtO1xuICAgICAgICAgICAgLy8gVE9ETyBXaHkgaXMgdGhpcyBkaXNwbGF5ZWQgdHdpY2U6XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2FjaGUubG9hZFZhdWx0KCk6IHN0YXRlID0gV2FybScpO1xuXG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgY2FjaGUgaXMgbm93IHdhcm06XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW5kZXhGaWxlKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgIGlmIChmaWxlQ2FjaGUgPT09IG51bGwgfHwgZmlsZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZS5wYXRoLmVuZHNXaXRoKCcubWQnKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ2luZGV4RmlsZTogc2tpcHBpbmcgbm9uLW1hcmtkb3duIGZpbGU6ICcgKyBmaWxlLnBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NhY2hlLmluZGV4RmlsZTogJyArIGZpbGUucGF0aCk7XG5cbiAgICAgICAgY29uc3Qgb2xkVGFza3MgPSB0aGlzLnRhc2tzLmZpbHRlcigodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCA9PT0gZmlsZS5wYXRoO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSBmaWxlQ2FjaGUubGlzdEl0ZW1zO1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGxpc3QgaXRlbXMgY2FjaGUsIHRoZXJlIGFyZSBubyB0YXNrcy5cbiAgICAgICAgLy8gU3RpbGwgY29udGludWUgdG8gbm90aWZ5IHdhdGNoZXJzIG9mIHJlbW92YWwuXG5cbiAgICAgICAgbGV0IG5ld1Rhc2tzOiBUYXNrW10gPSBbXTtcbiAgICAgICAgaWYgKGxpc3RJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlYWQgdGhlIGZpbGUgYW5kIHByb2Nlc3MgZm9yIHRhc2tzIGlmIHRoZXJlIGFyZSBsaXN0IGl0ZW1zLlxuICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XG4gICAgICAgICAgICBuZXdUYXNrcyA9IHRoaXMuZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgZmlsZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbGlzdEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbGVDYWNoZSxcbiAgICAgICAgICAgICAgICBmaWxlLnBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRUYXNrUGFyc2luZ0Vycm9yVG9Vc2VyLFxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzIGluIGFueSBvZiB0aGUgdGFza3MsIHRoZXJlJ3NcbiAgICAgICAgLy8gbm90aGluZyB0byBkbywgc28ganVzdCByZXR1cm4uXG4gICAgICAgIGlmIChUYXNrLnRhc2tzTGlzdHNJZGVudGljYWwob2xkVGFza3MsIG5ld1Rhc2tzKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGtlcHQgZm9yIG5vdywgdG8gYWxsb3cgZm9yIGRlYnVnZ2luZyBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gICAgICAgICAgICAvLyBJdCBpcyB0b28gdmVyYm9zZSB0byByZWxlYXNlIHRvIHVzZXJzLlxuICAgICAgICAgICAgLy8gaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PSBTdGF0ZS5XYXJtKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFRhc2tzIHVuY2hhbmdlZCBpbiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBvcmFyeSBlZGl0IC0gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbi10YXNrcy1ncm91cC9vYnNpZGlhbi10YXNrcy9pc3N1ZXMvMjE2MFxuICAgICAgICAvKlxuICAgICAgICBpZiAodGhpcy5nZXRTdGF0ZSgpID09IFN0YXRlLldhcm0pIHtcbiAgICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmRlYnVnKGBDYWNoZSByZWFkOiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgIGBBdCBsZWFzdCBvbmUgdGFzaywgaXRzIGxpbmUgbnVtYmVyIG9yIGl0cyBoZWFkaW5nIGhhcyBjaGFuZ2VkIGluICR7ZmlsZS5wYXRofTogdHJpZ2dlcmluZyBhIHJlZnJlc2ggb2YgYWxsIGFjdGl2ZSBUYXNrcyBibG9ja3MgaW4gTGl2ZSBQcmV2aWV3IGFuZCBSZWFkaW5nIG1vZGUgdmlld3MuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICAvLyBSZW1vdmUgYWxsIHRhc2tzIGZyb20gdGhpcyBmaWxlIGZyb20gdGhlIGNhY2hlIGJlZm9yZVxuICAgICAgICAvLyBhZGRpbmcgdGhlIG9uZXMgdGhhdCBhcmUgY3VycmVudGx5IGluIHRoZSBmaWxlLlxuICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5maWx0ZXIoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLnBhdGggIT09IGZpbGUucGF0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50YXNrcy5wdXNoKC4uLm5ld1Rhc2tzKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NhY2hlLmluZGV4RmlsZTogJyArIGZpbGUucGF0aCArIGA6IHJlYWQgJHtuZXdUYXNrcy5sZW5ndGh9IHRhc2socylgKTtcblxuICAgICAgICAvLyBBbGwgdXBkYXRlZCwgaW5mb3JtIG91ciBzdWJzY3JpYmVycy5cbiAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQoXG4gICAgICAgIGZpbGVDb250ZW50OiBzdHJpbmcsXG4gICAgICAgIGxpc3RJdGVtczogTGlzdEl0ZW1DYWNoZVtdLFxuICAgICAgICBmaWxlQ2FjaGU6IENhY2hlZE1ldGFkYXRhLFxuICAgICAgICBmaWxlUGF0aDogc3RyaW5nLFxuICAgICAgICBlcnJvclJlcG9ydGVyOiAoZTogYW55LCBmaWxlUGF0aDogc3RyaW5nLCBsaXN0SXRlbTogTGlzdEl0ZW1DYWNoZSwgbGluZTogc3RyaW5nKSA9PiB2b2lkLFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICApOiBUYXNrW10ge1xuICAgICAgICByZXR1cm4gZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQyKGZpbGVQYXRoLCBmaWxlQ29udGVudCwgbGlzdEl0ZW1zLCBsb2dnZXIsIGZpbGVDYWNoZSwgZXJyb3JSZXBvcnRlcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXBvcnRUYXNrUGFyc2luZ0Vycm9yVG9Vc2VyKGU6IGFueSwgZmlsZVBhdGg6IHN0cmluZywgbGlzdEl0ZW06IExpc3RJdGVtQ2FjaGUsIGxpbmU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhlcmUgd2FzIGFuIGVycm9yIHJlYWRpbmcgb25lIG9mIHRoZSB0YXNrcyBpbiB0aGlzIHZhdWx0LlxuVGhlIGZvbGxvd2luZyB0YXNrIGhhcyBiZWVuIGlnbm9yZWQsIHRvIHByZXZlbnQgVGFza3MgcXVlcmllcyBnZXR0aW5nIHN0dWNrIHdpdGggJ0xvYWRpbmcgVGFza3MgLi4uJ1xuRXJyb3I6ICR7ZX1cbkZpbGU6ICR7ZmlsZVBhdGh9XG5MaW5lIG51bWJlcjogJHtsaXN0SXRlbS5wb3NpdGlvbi5zdGFydC5saW5lfVxuVGFzayBsaW5lOiAke2xpbmV9XG5cblBsZWFzZSBjcmVhdGUgYSBidWcgcmVwb3J0IGZvciB0aGlzIG1lc3NhZ2UgYXRcbmh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbi10YXNrcy1ncm91cC9vYnNpZGlhbi10YXNrcy9pc3N1ZXMvbmV3L2Nob29zZVxudG8gaGVscCB1cyBmaW5kIGFuZCBmaXggdGhlIHVuZGVybHlpbmcgaXNzdWUuXG5cbkluY2x1ZGU6XG4tIGVpdGhlciBhIHNjcmVlbnNob3Qgb2YgdGhlIGVycm9yIHBvcHVwLCBvciBjb3B5IHRoZSB0ZXh0IGZyb20gdGhlIGNvbnNvbGUsIGlmIG9uIGEgZGVza3RvcCBtYWNoaW5lLlxuLSB0aGUgb3V0cHV0IGZyb20gcnVubmluZyB0aGUgT2JzaWRpYW4gY29tbWFuZCAnU2hvdyBkZWJ1ZyBpbmZvJ1xuXG5UaGUgZXJyb3IgcG9wdXAgd2lsbCBvbmx5IGJlIHNob3duIHdoZW4gVGFza3MgaXMgc3RhcnRpbmcgdXAsIGJ1dCBpZiB0aGUgZXJyb3IgcGVyc2lzdHMsXG5pdCB3aWxsIGJlIHNob3duIGluIHRoZSBjb25zb2xlIGV2ZXJ5IHRpbWUgdGhpcyBmaWxlIGlzIGVkaXRlZCBkdXJpbmcgdGhlIE9ic2lkaWFuXG5zZXNzaW9uLlxuYDtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5zdGFjayA/IGUuc3RhY2sgOiAnQ2Fubm90IGRldGVybWluZSBzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5Jbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UobXNnLCAxMDAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldFNlY3Rpb24obGluZU51bWJlclRhc2s6IG51bWJlciwgc2VjdGlvbnM6IFNlY3Rpb25DYWNoZVtdIHwgdW5kZWZpbmVkKTogU2VjdGlvbkNhY2hlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZSA8PSBsaW5lTnVtYmVyVGFzayAmJiBzZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lID49IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldFByZWNlZGluZ0hlYWRlcihsaW5lTnVtYmVyVGFzazogbnVtYmVyLCBoZWFkaW5nczogSGVhZGluZ0NhY2hlW10gfCB1bmRlZmluZWQpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKGhlYWRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChjb25zdCBoZWFkaW5nIG9mIGhlYWRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGluZy5wb3NpdGlvbi5zdGFydC5saW5lID4gbGluZU51bWJlclRhc2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2VkaW5nSGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyID0gaGVhZGluZy5oZWFkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVjZWRpbmdIZWFkZXI7XG4gICAgfVxufVxuIiwgImNvbnN0IEVfVElNRU9VVCA9IG5ldyBFcnJvcigndGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBtdXRleCB0byBiZWNvbWUgYXZhaWxhYmxlJyk7XG5jb25zdCBFX0FMUkVBRFlfTE9DS0VEID0gbmV3IEVycm9yKCdtdXRleCBhbHJlYWR5IGxvY2tlZCcpO1xuY29uc3QgRV9DQU5DRUxFRCA9IG5ldyBFcnJvcigncmVxdWVzdCBmb3IgbG9jayBjYW5jZWxlZCcpO1xuXG52YXIgX19hd2FpdGVyJDIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfY2FuY2VsRXJyb3IgPSBFX0NBTkNFTEVEKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jYW5jZWxFcnJvciA9IF9jYW5jZWxFcnJvcjtcbiAgICAgICAgdGhpcy5fd2VpZ2h0ZWRRdWV1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzID0gW107XG4gICAgfVxuICAgIGFjcXVpcmUod2VpZ2h0ID0gMSkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWlnaHRlZFF1ZXVlc1t3ZWlnaHQgLSAxXSlcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFF1ZXVlc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRRdWV1ZXNbd2VpZ2h0IC0gMV0ucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHdlaWdodCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCByZWxlYXNlXSA9IHlpZWxkIHRoaXMuYWNxdWlyZSh3ZWlnaHQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jayh3ZWlnaHQgPSAxKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0pXG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0ucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlIDw9IDA7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKCk7XG4gICAgfVxuICAgIHJlbGVhc2Uod2VpZ2h0ID0gMSkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICB0aGlzLl92YWx1ZSArPSB3ZWlnaHQ7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fd2VpZ2h0ZWRRdWV1ZXMuZm9yRWFjaCgocXVldWUpID0+IHF1ZXVlLmZvckVhY2goKGVudHJ5KSA9PiBlbnRyeS5yZWplY3QodGhpcy5fY2FuY2VsRXJyb3IpKSk7XG4gICAgICAgIHRoaXMuX3dlaWdodGVkUXVldWVzID0gW107XG4gICAgfVxuICAgIF9kaXNwYXRjaCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlRW50cnkgPSAoX2EgPSB0aGlzLl93ZWlnaHRlZFF1ZXVlc1t3ZWlnaHQgLSAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1dlaWdodCA9IHdlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlIC09IHdlaWdodDtcbiAgICAgICAgICAgIHdlaWdodCA9IHRoaXMuX3ZhbHVlICsgMTtcbiAgICAgICAgICAgIHF1ZXVlRW50cnkucmVzb2x2ZShbcHJldmlvdXNWYWx1ZSwgdGhpcy5fbmV3UmVsZWFzZXIocHJldmlvdXNXZWlnaHQpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gICAgfVxuICAgIF9uZXdSZWxlYXNlcih3ZWlnaHQpIHtcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9kcmFpblVubG9ja1dhaXRlcnMoKSB7XG4gICAgICAgIGZvciAobGV0IHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0uZm9yRWFjaCgod2FpdGVyKSA9PiB3YWl0ZXIoKSk7XG4gICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciQxID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBNdXRleCB7XG4gICAgY29uc3RydWN0b3IoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc2VtYXBob3JlID0gbmV3IFNlbWFwaG9yZSgxLCBjYW5jZWxFcnJvcik7XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHJlbGVhc2VyXSA9IHlpZWxkIHRoaXMuX3NlbWFwaG9yZS5hY3F1aXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5ydW5FeGNsdXNpdmUoKCkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUud2FpdEZvclVubG9jaygpO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCkpXG4gICAgICAgICAgICB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuY2FuY2VsKCk7XG4gICAgfVxufVxuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiB3aXRoVGltZW91dChzeW5jLCB0aW1lb3V0LCB0aW1lb3V0RXJyb3IgPSBFX1RJTUVPVVQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3F1aXJlOiAod2VpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIHN5bmMuYWNxdWlyZSh3ZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlID0gQXJyYXkuaXNBcnJheSh0aWNrZXQpID8gdGlja2V0WzFdIDogdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRpY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHdlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGlja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh0aWNrZXRbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGVhc2Uod2VpZ2h0KSB7XG4gICAgICAgICAgICBzeW5jLnJlbGVhc2Uod2VpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN5bmMuY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3JVbmxvY2s6ICh3ZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB3ZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHN5bmMud2FpdEZvclVubG9jayh3ZWlnaHQpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QodGltZW91dEVycm9yKSwgdGltZW91dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNMb2NrZWQ6ICgpID0+IHN5bmMuaXNMb2NrZWQoKSxcbiAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHN5bmMuZ2V0VmFsdWUoKSxcbiAgICAgICAgc2V0VmFsdWU6ICh2YWx1ZSkgPT4gc3luYy5zZXRWYWx1ZSh2YWx1ZSksXG4gICAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saXNuZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB0cnlBY3F1aXJlKHN5bmMsIGFscmVhZHlBY3F1aXJlZEVycm9yID0gRV9BTFJFQURZX0xPQ0tFRCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIHdpdGhUaW1lb3V0KHN5bmMsIDAsIGFscmVhZHlBY3F1aXJlZEVycm9yKTtcbn1cblxuZXhwb3J0IHsgRV9BTFJFQURZX0xPQ0tFRCwgRV9DQU5DRUxFRCwgRV9USU1FT1VULCBNdXRleCwgU2VtYXBob3JlLCB0cnlBY3F1aXJlLCB3aXRoVGltZW91dCB9O1xuIiwgIi8qKlxuICogQSBzaW1wbGUgY2xhc3MgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gZmlsZSBpbmZvcm1hdGlvbiB2aWEgJ3Rhc2suZmlsZScgaW4gc2NyaXB0aW5nIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrc0ZpbGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BhdGg6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHBhdGg6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXRoIHRvIHRoZSBmaWxlLCB3aXRoIHRoZSBmaWxlbmFtZSBleHRlbnNpb24gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aFdpdGhvdXRFeHRlbnNpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbih0aGlzLnBhdGgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgd2l0aG91dEV4dGVuc2lvbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXC5tZCQvLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByb290IHRvIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGdldCByb290KCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5wYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblxuICAgICAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBwYXRoLmluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKHNlcGFyYXRvckluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCArIDEpO1xuICAgIH1cblxuICAgIGdldCBmb2xkZXIoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgY29uc3QgZmlsZU5hbWVXaXRoRXh0ZW5zaW9uID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZihmaWxlTmFtZVdpdGhFeHRlbnNpb24pKTtcbiAgICAgICAgaWYgKGZvbGRlciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpbGVuYW1lIGluY2x1ZGluZyB0aGUgZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIGdldCBmaWxlbmFtZSgpOiBzdHJpbmcge1xuICAgICAgICAvLyBDb3BpZWQgZnJvbSBUYXNrLmZpbGVuYW1lIGFuZCBGaWxlbmFtZUZpZWxkLnZhbHVlKCkgaW5pdGlhbGx5XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lTWF0Y2ggPSB0aGlzLnBhdGgubWF0Y2goLyhbXi9dKykkLyk7XG4gICAgICAgIGlmIChmaWxlTmFtZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWVNYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbih0aGlzLmZpbGVuYW1lKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0ICogYXMgY2hyb25vIGZyb20gJ2Nocm9uby1ub2RlJztcbmltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4vRGF0ZVJhbmdlJztcblxuZXhwb3J0IGNsYXNzIERhdGVQYXJzZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlKGlucHV0OiBzdHJpbmcsIGZvcndhcmREYXRlOiBib29sZWFuID0gZmFsc2UpOiBNb21lbnQge1xuICAgICAgICAvLyBVc2luZyBzdGFydCBvZiBkYXkgdG8gY29ycmVjdGx5IG1hdGNoIG9uIGNvbXBhcmlzb24gd2l0aCBvdGhlciBkYXRlcyAobGlrZSBlcXVhbGl0eSkuXG4gICAgICAgIHJldHVybiB3aW5kb3dcbiAgICAgICAgICAgIC5tb21lbnQoXG4gICAgICAgICAgICAgICAgY2hyb25vLnBhcnNlRGF0ZShpbnB1dCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmREYXRlOiBmb3J3YXJkRGF0ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdGFydE9mKCdkYXknKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIGxpbmUgYW5kIGV4dHJhY3QgYSBwYWlyIG9mIGRhdGVzLCByZXR1cm5lZCBpbiBhIHR1cGxlLCBzb3J0ZWQgYnkgZGF0ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBhbnkgcGFpciBvZiBkYXRlcywgc2VwYXJhdGUgYnkgb25lIG9yIG1vcmUgc3BhY2VzICcxNyBBdWd1c3QgMjAxMyAxOSBBdWd1c3QgMjAxMycsXG4gICAgICogICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgZGF0ZS5cbiAgICAgKiBAcGFyYW0gZm9yd2FyZERhdGUgLSBpZiB0cnVlLCBhbmQgZGF0ZSBpcyBhbWJpZ3VvdXMsIGNocm9ubyB3aWxsIHJldHVybiBkYXRlcyBpbiB0aGUgZnV0dXJlXG4gICAgICogQHJldHVybiAtIEEgVHVwbGUgb2YgZGF0ZXMuIElmIGJvdGggaW5wdXQgZGF0ZXMgYXJlIGludmFsaWQsIHRoZW4gYm90aCBvdXRwdXQgZGF0ZXMgd2lsbCBiZSBpbnZhbGlkLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlUmFuZ2UoaW5wdXQ6IHN0cmluZywgZm9yd2FyZERhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IERhdGVSYW5nZSB7XG4gICAgICAgIGNvbnN0IGRhdGVSYW5nZVBhcnNlcnMgPSBbXG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBhIHJlbGF0aXZlIGRhdGUgcmFuZ2UgbGlrZSAnY3VycmVudCBtb250aCdcbiAgICAgICAgICAgIERhdGVQYXJzZXIucGFyc2VSZWxhdGl2ZURhdGVSYW5nZSxcbiAgICAgICAgICAgIC8vIFRyeSAnMjAyMi1XMTAnIG90aGVyd2lzZVxuICAgICAgICAgICAgRGF0ZVBhcnNlci5wYXJzZU51bWJlcmVkRGF0ZVJhbmdlLFxuICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgZmFpbGVkLCBmYWxsYmFjayBvbiBhYnNvbHV0ZSBkYXRlIHJhbmdlIHdpdGggY2hyb25vXG4gICAgICAgICAgICBEYXRlUGFyc2VyLnBhcnNlQWJzb2x1dGVEYXRlUmFuZ2UsXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChjb25zdCBwYXJzZXIgb2YgZGF0ZVJhbmdlUGFyc2Vycykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0ZVJhbmdlID0gcGFyc2VyKGlucHV0LCBmb3J3YXJkRGF0ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0ZVJhbmdlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWREYXRlUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBub3RoaW5nIHdvcmtlZCByZXR1cm4gYW5kIGludmFsaWQgZGF0ZSByYW5nZVxuICAgICAgICByZXR1cm4gRGF0ZVJhbmdlLmJ1aWxkSW52YWxpZCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBhcnNlQWJzb2x1dGVEYXRlUmFuZ2UoaW5wdXQ6IHN0cmluZywgZm9yd2FyZERhdGU6IGJvb2xlYW4pOiBEYXRlUmFuZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjaHJvbm8ucGFyc2UoaW5wdXQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgZm9yd2FyZERhdGU6IGZvcndhcmREYXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBjaHJvbm8gcGFyc2luZ1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGVSYW5nZS5idWlsZEludmFsaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IHJlc3VsdFswXS5zdGFydDtcbiAgICAgICAgY29uc3QgZW5kRGF0ZSA9IHJlc3VsdFsxXSAmJiByZXN1bHRbMV0uc3RhcnQgPyByZXN1bHRbMV0uc3RhcnQgOiBzdGFydERhdGU7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gd2luZG93Lm1vbWVudChzdGFydERhdGUuZGF0ZSgpKTtcbiAgICAgICAgY29uc3QgZW5kID0gd2luZG93Lm1vbWVudChlbmREYXRlLmRhdGUoKSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VSZWxhdGl2ZURhdGVSYW5nZShpbnB1dDogc3RyaW5nLCBfZm9yd2FyZERhdGU6IGJvb2xlYW4pOiBEYXRlUmFuZ2Uge1xuICAgICAgICBjb25zdCByZWxhdGl2ZURhdGVSYW5nZVJlZ2V4cCA9IC8obGFzdHx0aGlzfG5leHQpICh3ZWVrfG1vbnRofHF1YXJ0ZXJ8eWVhcikvO1xuICAgICAgICBjb25zdCByZWxhdGl2ZURhdGVSYW5nZU1hdGNoID0gaW5wdXQubWF0Y2gocmVsYXRpdmVEYXRlUmFuZ2VSZWdleHApO1xuICAgICAgICBpZiAocmVsYXRpdmVEYXRlUmFuZ2VNYXRjaCAmJiByZWxhdGl2ZURhdGVSYW5nZU1hdGNoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY29uc3QgbGFzdFRoaXNOZXh0ID0gcmVsYXRpdmVEYXRlUmFuZ2VNYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVEYXRlUmFuZ2VNYXRjaFsyXTtcblxuICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gRGF0ZVJhbmdlLmJ1aWxkUmVsYXRpdmUocmFuZ2UgYXMgbW9tZW50LnVuaXRPZlRpbWUuU3RhcnRPZik7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobGFzdFRoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFzdCc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGVSYW5nZS5tb3ZlVG9QcmV2aW91cyhyYW5nZSBhcyBtb21lbnQudW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgICAgIGRhdGVSYW5nZS5tb3ZlVG9OZXh0KHJhbmdlIGFzIG1vbWVudC51bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGVSYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlUmFuZ2UuYnVpbGRJbnZhbGlkKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VOdW1iZXJlZERhdGVSYW5nZShpbnB1dDogc3RyaW5nLCBfZm9yd2FyZERhdGU6IGJvb2xlYW4pOiBEYXRlUmFuZ2Uge1xuICAgICAgICBjb25zdCBwYXJzaW5nVmVjdG9yczogW1JlZ0V4cCwgc3RyaW5nLCBtb21lbnQudW5pdE9mVGltZS5TdGFydE9mXVtdID0gW1xuICAgICAgICAgICAgWy9eXFxzKlswLTldezR9XFxzKiQvLCAnWVlZWScsICd5ZWFyJ10sXG4gICAgICAgICAgICBbL15cXHMqWzAtOV17NH0tUVsxLTRdXFxzKiQvLCAnWVlZWS1RJywgJ3F1YXJ0ZXInXSxcbiAgICAgICAgICAgIFsvXlxccypbMC05XXs0fS1bMC05XXsyfVxccyokLywgJ1lZWVktTU0nLCAnbW9udGgnXSxcbiAgICAgICAgICAgIFsvXlxccypbMC05XXs0fS1XWzAtOV17Mn1cXHMqJC8sICdZWVlZLVdXJywgJ2lzb1dlZWsnXSxcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtyZWdleHAsIGRhdGVGb3JtYXQsIHJhbmdlXSBvZiBwYXJzaW5nVmVjdG9ycykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGlucHV0Lm1hdGNoKHJlZ2V4cCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIFJlZ0V4cHMgYWxsb3cgc3BhY2VzIChcXHMqKSwgcmVtb3ZlIHRoZW0gYmVmb3JlIGNhbGxpbmcgd2luZG93Lm1vbWVudCgpXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG1hdGNoZWRbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZVJhbmdlKFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW9tZW50KGRhdGUsIGRhdGVGb3JtYXQpLnN0YXJ0T2YocmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW9tZW50KGRhdGUsIGRhdGVGb3JtYXQpLmVuZE9mKHJhbmdlKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERhdGVSYW5nZS5idWlsZEludmFsaWQoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhbiBpbmNsdXNpdmUgc3BhbiBvZiB0aW1lIGJldHdlZW4gdHdvIGRheXMgYXQgMDA6MDAgbG9jYWwgdGltZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGVSYW5nZSB7XG4gICAgc3RhcnQ6IE1vbWVudDtcbiAgICBlbmQ6IE1vbWVudDtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgZGF0ZSByYW5nZS4gSWYgc3RhcnQgaXMgYWZ0ZXIgdGhlIGVuZCwgdGhlIGRhdGVzIHdpbGwgYmUgYXV0b21hdGljYWxseSByZXZlcnNlZC5cbiAgICAgKiBTdGFydCBhbmQgZW5kIHdpbGwgYmUgc2F2ZWQgYXQgMDA6MDAgbG9jYWwgdGltZS5cbiAgICAgKiBUaGUgc3RvcmVkIHZhbHVlcyBvZiBhcmUgbXV0YWJsZS5cbiAgICAgKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gdmFsaWRhdGlvbiBvZiB0aGUgc3RhcnQgYW5kIGVuZCBtb21lbnQuIFRoZXkgY2FuIGJlIGNoZWNrZWQgd2l0aCBzdGFydC5pc1ZhbGlkKCkgYW5kIGVuZC5pc1ZhbGlkKCkuXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0OiBNb21lbnQsIGVuZDogTW9tZW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG5cbiAgICAgICAgaWYgKGVuZC5pc0JlZm9yZShzdGFydCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGF0ZXMgc2hhbGwgYmUgYXQgbWlkbmlnaHQgZWcgMDA6MDBcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuc3RhcnRPZignZGF5Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgZGF0ZSByYW5nZSByZWxhdGl2ZSB0byB0b2RheSBsaWtlIHRoaXMgd2Vlay9tb250aC9xdWFydGVyL3llYXIuXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+IGNvbnN0cnVjdCBhIGRhdGUgcmFuZ2UgY29udGFpbmluZyB0aGUgY3VycmVudCBtb250aC48L2NhcHRpb24+XG4gICAgICogY29uc3QgdGhpc01vbnRoID0gRGF0ZVJhbmdlLmJ1aWxkUmVsYXRpdmUoJ21vbnRoJyk7XG4gICAgICogQHBhcmFtIHJhbmdlIG9uZSBvZiAnd2VlaycsICdtb250aCcsICdxdWFydGVyJywgJ3llYXInXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJ1aWxkUmVsYXRpdmUocmFuZ2U6IG1vbWVudC51bml0T2ZUaW1lLlN0YXJ0T2YpIHtcbiAgICAgICAgLy8gVHJlYXQgYWxsIHdlZWtzIGFzIElTTyA4NjAxIHdlZWtzXG4gICAgICAgIGNvbnN0IHVuaXRPZlRpbWUgPSByYW5nZSA9PT0gJ3dlZWsnID8gJ2lzb1dlZWsnIDogcmFuZ2U7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlUmFuZ2UoXG4gICAgICAgICAgICB3aW5kb3cubW9tZW50KCkuc3RhcnRPZih1bml0T2ZUaW1lKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoKS5lbmRPZih1bml0T2ZUaW1lKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW52YWxpZCBkYXRlIHJhbmdlIHdpdGggaW52YWxpZCBtb21lbnRrcyBvYmplY3RzIChodHRwczovL21vbWVudGpzY29tLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9tb21lbnQvMDktdXRpbGl0aWVzLzAyLWludmFsaWQvKS5cbiAgICAgKiBGb3IgZXhhbXBsZSBpZiB0aGUgcGFyc2luZyBoYXMgZ29uZSB3cm9uZy5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYnVpbGRJbnZhbGlkKCk6IERhdGVSYW5nZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVJhbmdlKHdpbmRvdy5tb21lbnQuaW52YWxpZCgpLCB3aW5kb3cubW9tZW50LmludmFsaWQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGJvdGggZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2UgYXJlIHZhbGlkIGluIHRlcm1zIG9mIG1vbWVudGpzLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgYm90aCBkYXRlcyBhcmUgdmFsaWRcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuaXNWYWxpZCgpICYmIHRoaXMuZW5kLmlzVmFsaWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBkYXRlIHJhbmdlIHRvIHRoZSBwcmV2aW91cyB3ZWVrL21vbnRoL3F1YXJ0ZXIveWVhci5cbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB0aGUgZHVyYXRpb24gaW4gdGhlIHBhcmFtZXRlcnMgbWF0Y2hlcyB0aGUgcmFuZ2Ugc2l6ZSwgZm9yIGV4YW1wbGUgc3VidHJhY3RpbmcgYSBtb250aCBmcm9tIGEgd2VlayBsb25nIHJhbmdlIHdhcyBub3QgdGVzdGVkLlxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBvbmUgb2YgJ3dlZWsnLydtb250aCcvJ3F1YXJ0ZXInLyd5ZWFyJ1xuICAgICAqL1xuICAgIHB1YmxpYyBtb3ZlVG9QcmV2aW91cyhkdXJhdGlvbjogbW9tZW50LnVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3Rvcikge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHdpbmRvdy5tb21lbnQuZHVyYXRpb24oMSwgZHVyYXRpb24pO1xuICAgICAgICB0aGlzLnN0YXJ0LnN1YnRyYWN0KGRlbHRhKTtcbiAgICAgICAgdGhpcy5lbmQuc3VidHJhY3QoZGVsdGEpO1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gJ21vbnRoJyB8fCBkdXJhdGlvbiA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAvLyBNb250aCBhbmQgcXVhcnRlciBkdXJhdGlvbnMgaW4gZGF5cyBtYXkgZGlmZmVyICgyOC8zMC8zMSBkYXlzKS5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhZGp1c3QgdGhlIGVuZC5cbiAgICAgICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuZW5kT2YoZHVyYXRpb24pLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgZGF0ZSByYW5nZSB0byB0aGUgbmV4dCB3ZWVrL21vbnRoL3F1YXJ0ZXIveWVhci5cbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB0aGUgZHVyYXRpb24gaW4gdGhlIHBhcmFtZXRlcnMgbWF0Y2hlcyB0aGUgcmFuZ2Ugc2l6ZSwgZm9yIGV4YW1wbGUgc3VidHJhY3RpbmcgYSBtb250aCBmcm9tIGEgd2VlayBsb25nIHJhbmdlIHdhcyBub3QgdGVzdGVkLlxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBvbmUgb2YgJ3dlZWsnLydtb250aCcvJ3F1YXJ0ZXInLyd5ZWFyJ1xuICAgICAqL1xuICAgIHB1YmxpYyBtb3ZlVG9OZXh0KGR1cmF0aW9uOiBtb21lbnQudW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbigxLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuc3RhcnQuYWRkKGRlbHRhKTtcbiAgICAgICAgdGhpcy5lbmQuYWRkKGRlbHRhKTtcblxuICAgICAgICBpZiAoZHVyYXRpb24gPT09ICdtb250aCcgfHwgZHVyYXRpb24gPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgLy8gTW9udGggYW5kIHF1YXJ0ZXIgZHVyYXRpb25zIGluIGRheXMgbWF5IGRpZmZlciAoMjgvMzAvMzEgZGF5cykuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmQuXG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMuZW5kLmVuZE9mKGR1cmF0aW9uKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICIvLyBBYmJyZXZpYXRpb25zIGZvciBlbnRlcmluZyBkYXRlcyB3aXRoIGNocm9ub1xuLy8gTUFJTlRFTkFOQ0UgTk9URTpcbi8vICAgICAgSWYgYWRkaW5nIG1vcmUgYWJicmV2aWF0aW9ucywgcGxlYXNlIHJldmlldyBkYXRlUGxhY2Vob2xkZXIgaW4gc3JjL3VpL0VkaXRUYXNrLnN2ZWx0ZVxuY29uc3QgYWJicmV2aWF0aW9ucyA9IHtcbiAgICB0ZDogJ3RvZGF5JyxcbiAgICB0bTogJ3RvbW9ycm93JyxcbiAgICB5ZDogJ3llc3RlcmRheScsXG4gICAgdHc6ICd0aGlzIHdlZWsnLFxuICAgIG53OiAnbmV4dCB3ZWVrJyxcbiAgICB3ZWVrZW5kOiAnc2F0JyxcbiAgICB3ZTogJ3NhdCcsXG59O1xuXG4vKipcbiAqIEV4cGFuZCBhbnkgcmVjb2duaXNlZCBhYmJyZXZpYXRpb25zIGZvciBkYXRlcy5cbiAqXG4gKiBJbXBvcnRhbnQ6IHRoZSBhYmJyZXZpYXRpb24gaXMgb25seSBleHBhbmRlZCBpZiBpdCBpcyBmb29sb3dlZCBieSBhIHNwYWNlLlxuICpcbiAqIEZvciBleGFtcGxlLCAndGQgJyBpcyBleHBhbmRlZCB0byAndG9kYXknXG4gKiBAcGFyYW0gZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZG9BdXRvY29tcGxldGUoZGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoYWJicmV2aWF0aW9ucykpIHtcbiAgICAgICAgZGF0ZSA9IGRhdGUucmVwbGFjZShSZWdFeHAoYFxcXFxiJHtrZXl9XFxcXHNgLCAnaScpLCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XHJcbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xyXG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcclxuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgZG9uZSA9IHRydWU7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xyXG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XHJcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59O1xyXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0ICogYXMgY2hyb25vIGZyb20gJ2Nocm9uby1ub2RlJztcbmltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50L21vbWVudCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnlEYXRlKGE6IG1vbWVudC5Nb21lbnQgfCBudWxsLCBiOiBtb21lbnQuTW9tZW50IHwgbnVsbCk6IC0xIHwgMCB8IDEge1xuICAgIGlmIChhICE9PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PT0gbnVsbCAmJiBiICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoIShhICE9PSBudWxsICYmIGIgIT09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhLmlzVmFsaWQoKSAmJiAhYi5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICghYS5pc1ZhbGlkKCkgJiYgYi5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmIChhLmlzQWZ0ZXIoYikpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLmlzQmVmb3JlKGIpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5cbi8qXG4gICAgTUFJTlRFTkFOQ0UgTk9URSBvbiB0aGVzZSBEYXRlIGZ1bmN0aW9uczpcbiAgICAgICAgUmVwZXRpdGlvdXMgZGF0ZS1yZWxhdGVkIGNvZGUgaW4gdGhpcyBmaWxlIGhhcyBiZWVuIGV4dHJhY3RlZFxuICAgICAgICBvdXQgaW4gdG8gc2V2ZXJhbCBwYXJzZVR5cGVkRGF0ZUZvci4uLi4oKSBmdW5jdGlvbnMgb3ZlciB0aW1lLlxuXG4gICAgICAgIFRoZXJlIGlzIHNvbWUgc2ltaWxhcml0eSBiZXR3ZWVuIHRoZXNlIGZ1bmN0aW9ucywgYW5kIGFsc29cbiAgICAgICAgc29tZSBzdWJ0bGUgZGlmZmVyZW5jZXMuXG5cbiAgICAgICAgRnV0dXJlIHJlZmFjdG9yaW5nIHRvIHNpbXBsaWZ5IHRoZW0gd291bGQgYmUgd2VsY29tZWQuXG5cbiAgICAgICAgV2hlbiBlZGl0aW5nIG9mIERvbmUgZGF0ZSBpcyBpbnRyb2R1Y2VkLCB0aGUgZnVuY3Rpb25zXG4gICAgICAgIHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheVVzaW5nRnV0dXJlRGF0ZSgpIGFuZCBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXkoKVxuICAgICAgICBtYXkgY29sbGFwc2UgaW4gdG8gYSBzaW5nbGUgY2FzZS5cbiovXG5cbi8qKlxuICogUGFyc2UgYW5kIHJldHVybiB0aGUgZW50ZXJlZCB2YWx1ZSBmb3IgYSBkYXRlIGZpZWxkLlxuICogQHBhcmFtIGZpZWxkTmFtZVxuICogQHBhcmFtIHR5cGVkRGF0ZSAtIHdoYXQgdGhlIHVzZXIgaGFzIGVudGVyZWQsIHN1Y2ggYXMgJzIwMjMtMDEtMjMnIG9yICd0b21vcnJvdydcbiAqIEBwYXJhbSBmb3J3YXJkRGF0ZVxuICogQHJldHVybnMgdGhlIHBhcnNlZCBkYXRlIHN0cmluZy4gSW5jbHVkZXMgXCJpbnZhbGlkXCIgaWYge0Bjb2RlIHR5cGVkRGF0ZX0gd2FzIGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXkoXG4gICAgZmllbGROYW1lOiAnY3JlYXRlZCcgfCAnc3RhcnQnIHwgJ3NjaGVkdWxlZCcgfCAnZHVlJyB8ICdyZW1pbmRlcicgfCAnZG9uZScgfCAnY2FuY2VsbGVkJyxcbiAgICB0eXBlZERhdGU6IHN0cmluZyxcbiAgICBmb3J3YXJkRGF0ZTogRGF0ZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbik6IHN0cmluZyB7XG4gICAgaWYgKCF0eXBlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGA8aT5ubyAke2ZpZWxkTmFtZX0gZGF0ZTwvaT5gO1xuICAgIH1cblxuICAgIC8vIGNocm9uby5wYXJzZURhdGUgaGVyZSBsb3NlcyBwb3RlbnRpYWwgZm9ybWF0dGluZyBvZiB0eXBlZERhdGUgc3RyaW5nXG4gICAgY29uc3QgcGFyc2VkID0gY2hyb25vLnBhcnNlRGF0ZSh0eXBlZERhdGUsIGZvcndhcmREYXRlLCB7XG4gICAgICAgIGZvcndhcmREYXRlOiBmb3J3YXJkRGF0ZSAhPSB1bmRlZmluZWQsXG4gICAgfSk7XG5cbiAgICBpZiAocGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZE1vbWVudCA9IHdpbmRvdy5tb21lbnQocGFyc2VkKTtcblxuICAgICAgICBpZiAoZmllbGROYW1lID09PSAncmVtaW5kZXInKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIG9yaWdpbmFsIHR5cGVkIGRhdGUgc3RyaW5nIGlzIGZvcm1hdHRlZCBhcyBkYXRlIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkRGF0ZUZvcm1hdElzRGF0ZVRpbWUgPSBpc0RhdGVUaW1lKHdpbmRvdy5tb21lbnQodHlwZWREYXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWREYXRlRm9ybWF0SXNEYXRlVGltZVxuICAgICAgICAgICAgICAgID8gcGFyc2VkTW9tZW50LmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbScpXG4gICAgICAgICAgICAgICAgOiBwYXJzZWRNb21lbnQuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZE1vbWVudC5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGA8aT5pbnZhbGlkICR7ZmllbGROYW1lfSBkYXRlPC9pPmA7XG59XG5cbi8qKlxuICogTGlrZSB7QGxpbmsgcGFyc2VUeXBlZERhdGVGb3JEaXNwbGF5fSBidXQgYWxzbyBhY2NvdW50cyBmb3IgdGhlICdPbmx5IGZ1dHVyZSBkYXRlcycgc2V0dGluZy5cbiAqIEBwYXJhbSBmaWVsZE5hbWVcbiAqIEBwYXJhbSB0eXBlZERhdGUgLSB3aGF0IHRoZSB1c2VyIGhhcyBlbnRlcmVkLCBzdWNoIGFzICcyMDIzLTAxLTIzJyBvciAndG9tb3Jyb3cnXG4gKiBAcmV0dXJucyB0aGUgcGFyc2VkIGRhdGUgc3RyaW5nLiBJbmNsdWRlcyBcImludmFsaWRcIiBpZiB7QGNvZGUgdHlwZWREYXRlfSB3YXMgaW52YWxpZC5cbiAqIEBwYXJhbSBmb3J3YXJkT25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUeXBlZERhdGVGb3JEaXNwbGF5VXNpbmdGdXR1cmVEYXRlKFxuICAgIGZpZWxkTmFtZTogJ3N0YXJ0JyB8ICdzY2hlZHVsZWQnIHwgJ2R1ZScgfCAncmVtaW5kZXInIHwgJ2RvbmUnIHwgJ2NyZWF0ZWQnIHwgJ2NhbmNlbGxlZCcsXG4gICAgdHlwZWREYXRlOiBzdHJpbmcsXG4gICAgZm9yd2FyZE9ubHk6IGJvb2xlYW4sXG4pOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXkoZmllbGROYW1lLCB0eXBlZERhdGUsIGZvcndhcmRPbmx5ID8gbmV3IERhdGUoKSA6IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogUmVhZCB0aGUgZW50ZXJlZCB2YWx1ZSBmb3IgYSBkYXRlIGZpZWxkLCBhbmQgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSBzYXZlZCBpbiB0aGUgZWRpdGVkIHRhc2suXG4gKiBAcGFyYW0gdHlwZWREYXRlIC0gd2hhdCB0aGUgdXNlciBoYXMgZW50ZXJlZCwgc3VjaCBhcyAnMjAyMy0wMS0yMycgb3IgJ3RvbW9ycm93J1xuICogQHBhcmFtIGZvcndhcmREYXRlXG4gKi9cbi8vIEhFUkUhXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcodHlwZWREYXRlOiBzdHJpbmcsIGZvcndhcmREYXRlOiBib29sZWFuKTogbW9tZW50Lk1vbWVudCB8IG51bGwge1xuICAgIGxldCBkYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IGNocm9uby5wYXJzZURhdGUodHlwZWREYXRlLCBuZXcgRGF0ZSgpLCB7IGZvcndhcmREYXRlIH0pO1xuICAgIGlmIChwYXJzZWREYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGUgPSB3aW5kb3cubW9tZW50KHBhcnNlZERhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLyoqXG4gKiBSZWFkIHRoZSBlbnRlcmVkIHZhbHVlIGZvciBhIGRhdGUgZmllbGQsIGFuZCByZXR1cm4gdGhlIHZhbHVlIHRvIGJlIHNhdmVkIGluIHRoZSBlZGl0ZWQgdGFzay5cbiAqIEBwYXJhbSB0eXBlZERhdGUgLSB3aGF0IHRoZSB1c2VyIGhhcyBlbnRlcmVkLCBzdWNoIGFzICcyMDIzLTAxLTIzJyBvciAndG9tb3Jyb3cnXG4gKiBAcGFyYW0gZm9yd2FyZERhdGVcbiAqL1xuLy8gSEVSRSFcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVR5cGVkRGF0ZW9yRGF0ZVRpbWVGb3JTYXZpbmdSZW1pbmRlcihcbiAgICB0eXBlZERhdGU6IHN0cmluZyxcbiAgICBmb3J3YXJkRGF0ZTogYm9vbGVhbixcbik6IG1vbWVudC5Nb21lbnQgfCBudWxsIHtcbiAgICBsZXQgZGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGNvbnN0IHBhcnNlZERhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKHR5cGVkRGF0ZSwgbmV3IERhdGUoKSwgeyBmb3J3YXJkRGF0ZSB9KTtcbiAgICBpZiAocGFyc2VkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRlID0gd2luZG93Lm1vbWVudChwYXJzZWREYXRlKTtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGlzRGF0ZVRpbWUod2luZG93Lm1vbWVudCh0eXBlZERhdGUpKVxuICAgICAgICAgICAgPyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbScpXG4gICAgICAgICAgICA6IGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG5cbiAgICAgICAgZGF0ZSA9IHdpbmRvdy5tb21lbnQoZGF0ZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgbW9tZW50IG9iamVjdCB3YXMgaW5pdGlhbGl6ZWQgd2l0aCBhIHRpbWUuIFVzZWQgZm9yIHJlbWluZGVyc1xuICogcmV0dXJucyBmYWxzZSBpZiB0YXNrIGhhcyBubyBtb21lbnRcbiAqIEBwYXJhbSBkYXRlT2JqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVUaW1lKGRhdGVPYmo6IE1vbWVudCB8IG51bGwpOiBib29sZWFuIHtcbiAgICBsZXQgaGFzVGltZSA9IGZhbHNlO1xuICAgIGlmIChkYXRlT2JqICE9IG51bGwpIHtcbiAgICAgICAgaGFzVGltZSA9IGRhdGVPYmouY3JlYXRpb25EYXRhKCkuZm9ybWF0ID09PSAnWVlZWS1NTS1ERCBISDptbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc1RpbWU7XG59XG4iLCAiLy8gYmVnaW4tc25pcHBldDogZGVjbGFyZS1Nb21lbnQtdHlwZS1pbi1zcmNcbmltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50Jztcbi8vIGVuZC1zbmlwcGV0XG5cbmltcG9ydCB7IFJSdWxlIH0gZnJvbSAncnJ1bGUnO1xuaW1wb3J0IHsgY29tcGFyZUJ5RGF0ZSB9IGZyb20gJy4uL2xpYi9EYXRlVG9vbHMnO1xuXG5leHBvcnQgY2xhc3MgUmVjdXJyZW5jZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBycnVsZTogUlJ1bGU7XG4gICAgcHJpdmF0ZSByZWFkb25seSBiYXNlT25Ub2RheTogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHJpdmF0ZSByZWFkb25seSBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVtaW5kZXJEYXRlOiBNb21lbnQgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZmVyZW5jZSBkYXRlIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGZ1dHVyZSBvY2N1cnJlbmNlcy5cbiAgICAgKlxuICAgICAqIEZ1dHVyZSBvY2N1cnJlbmNlcyB3aWxsIHJlY3VyIGJhc2VkIG9uIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAgICAgKiBUaGUgcmVmZXJlbmNlIGRhdGUgaXMgdGhlIGR1ZSBkYXRlLCBpZiBpdCBpcyBnaXZlbi5cbiAgICAgKiBPdGhlcndpc2UgdGhlIHNjaGVkdWxlZCBkYXRlLCBpZiBpdCBpcyBnaXZlbi4gQW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogUmVjdXJyZW5jZSBvZiBhbGwgZGF0ZXMgd2lsbCBiZSBrZXB0IHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAgICAgKiBGb3IgZXhhbXBsZTogaWYgdGhlIGR1ZSBkYXRlIGFuZCB0aGUgc3RhcnQgZGF0ZSBhcmUgZ2l2ZW4sIHRoZSBkdWUgZGF0ZVxuICAgICAqIGlzIHRoZSByZWZlcmVuY2UgZGF0ZS4gRnV0dXJlIG9jY3VycmVuY2VzIHdpbGwgaGF2ZSBhIHN0YXJ0IGRhdGUgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHJlbGF0aXZlIGRpc3RhbmNlIHRvIHRoZSBkdWUgZGF0ZSBhcyB0aGUgb3JpZ2luYWwgdGFzay4gRm9yIGV4YW1wbGVcbiAgICAgKiBcInN0YXJ0cyBvbmUgd2VlayBiZWZvcmUgaXQgaXMgZHVlXCIuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWZlcmVuY2VEYXRlOiBNb21lbnQgfCBudWxsO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBycnVsZSxcbiAgICAgICAgYmFzZU9uVG9kYXksXG4gICAgICAgIHJlZmVyZW5jZURhdGUsXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgcmVtaW5kZXJEYXRlLFxuICAgIH06IHtcbiAgICAgICAgcnJ1bGU6IFJSdWxlO1xuICAgICAgICBiYXNlT25Ub2RheTogYm9vbGVhbjtcbiAgICAgICAgcmVmZXJlbmNlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICByZW1pbmRlckRhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSkge1xuICAgICAgICB0aGlzLnJydWxlID0gcnJ1bGU7XG4gICAgICAgIHRoaXMuYmFzZU9uVG9kYXkgPSBiYXNlT25Ub2RheTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEYXRlID0gcmVmZXJlbmNlRGF0ZTtcbiAgICAgICAgdGhpcy5zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkRGF0ZSA9IHNjaGVkdWxlZERhdGU7XG4gICAgICAgIHRoaXMuZHVlRGF0ZSA9IGR1ZURhdGU7XG4gICAgICAgIHRoaXMucmVtaW5kZXJEYXRlID0gcmVtaW5kZXJEYXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbVRleHQoe1xuICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQsXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgcmVtaW5kZXJEYXRlLFxuICAgIH06IHtcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGVUZXh0OiBzdHJpbmc7XG4gICAgICAgIHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgcmVtaW5kZXJEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0pOiBSZWN1cnJlbmNlIHwgbnVsbCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlY3VycmVuY2VSdWxlVGV4dC5tYXRjaCgvXihbYS16QS1aMC05LCAhXSs/KSggd2hlbiBkb25lKT8kL2kpO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXNvbGF0ZWRSdWxlVGV4dCA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VPblRvZGF5ID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFJSdWxlLnBhcnNlVGV4dChpc29sYXRlZFJ1bGVUZXh0KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUGljayB0aGUgcmVmZXJlbmNlIGRhdGUgZm9yIHJlY3VycmVuY2UgYmFzZWQgb24gaW1wb3J0YW5jZS5cbiAgICAgICAgICAgICAgICAvLyBBc3N1bWluZyBkdWUgZGF0ZSBoYXMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgbGV0IHJlZmVyZW5jZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBtb21lbnQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICBpZiAoZHVlRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChkdWVEYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbWluZGVyRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChyZW1pbmRlckRhdGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChzY2hlZHVsZWREYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYmFzZU9uVG9kYXkgJiYgcmVmZXJlbmNlRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmR0c3RhcnQgPSB3aW5kb3cubW9tZW50KHJlZmVyZW5jZURhdGUpLnN0YXJ0T2YoJ2RheScpLnV0Yyh0cnVlKS50b0RhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmR0c3RhcnQgPSB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5JykudXRjKHRydWUpLnRvRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJydWxlID0gbmV3IFJSdWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdXJyZW5jZSh7XG4gICAgICAgICAgICAgICAgICAgIHJydWxlLFxuICAgICAgICAgICAgICAgICAgICBiYXNlT25Ub2RheSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgICAgICAgICByZW1pbmRlckRhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIENvdWxkIG5vdCByZWFkIHJlY3VycmVuY2UgcnVsZS4gVXNlciBwb3NzaWJseSBub3QgZG9uZSB0eXBpbmcuXG4gICAgICAgICAgICAvLyBQcmludCBlcnJvciBtZXNzYWdlLCBhcyBpdCBpcyB1c2VmdWwgaWYgYSB0ZXN0IGZpbGUgaGFzIG5vdCBzZXQgdXAgd2luZG93Lm1vbWVudFxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9UZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5ycnVsZS50b1RleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuYmFzZU9uVG9kYXkpIHtcbiAgICAgICAgICAgIHRleHQgKz0gJyB3aGVuIGRvbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZXMgb2YgdGhlIG5leHQgb2NjdXJyZW5jZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIG5leHQgb2NjdXJyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2RheSAtIE9wdGlvbmFsIGRhdGUgcmVwcmVzZW50aW5nIHRoZSBjb21wbGV0aW9uIGRhdGUuIERlZmF1bHRzIHRvIHRvZGF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0KHRvZGF5ID0gd2luZG93Lm1vbWVudCgpKToge1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHJlbWluZGVyRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICB9IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRSZWZlcmVuY2VEYXRlKHRvZGF5KTtcblxuICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZGF0ZSBhbmRcbiAgICAgICAgICAgIC8vIHN0YXJ0L3NjaGVkdWxlZC9kdWUuXG4gICAgICAgICAgICBsZXQgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkdWVEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCByZW1pbmRlckRhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGlmIGEgcmVmZXJlbmNlIGRhdGUgaXMgZ2l2ZW4uIEEgcmVmZXJlbmNlIGRhdGUgd2lsbCBleGlzdCBpZiBhdFxuICAgICAgICAgICAgLy8gbGVhc3Qgb25lIG9mIHRoZSBvdGhlciBkYXRlcyBpcyBzZXQuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGlmZmVyZW5jZSA9IHdpbmRvdy5tb21lbnQuZHVyYXRpb24odGhpcy5zdGFydERhdGUuZGlmZih0aGlzLnJlZmVyZW5jZURhdGUpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uaW5nIHNvIHRoYXQgb3JpZ2luYWwgd29uJ3QgYmUgbWFuaXB1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIGRheXMgdG8gaGFuZGxlIGNyb3NzIGRheWxpZ2h0LXNhdmluZ3MtdGltZSByZWN1cnJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZChNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjaGVkdWxlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbih0aGlzLnNjaGVkdWxlZERhdGUuZGlmZih0aGlzLnJlZmVyZW5jZURhdGUpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uaW5nIHNvIHRoYXQgb3JpZ2luYWwgd29uJ3QgYmUgbWFuaXB1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUgPSB3aW5kb3cubW9tZW50KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyBkYXlzIHRvIGhhbmRsZSBjcm9zcyBkYXlsaWdodC1zYXZpbmdzLXRpbWUgcmVjdXJyZW5jZXMuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUuYWRkKE1hdGgucm91bmQob3JpZ2luYWxEaWZmZXJlbmNlLmFzRGF5cygpKSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHVlRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbERpZmZlcmVuY2UgPSB3aW5kb3cubW9tZW50LmR1cmF0aW9uKHRoaXMuZHVlRGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25pbmcgc28gdGhhdCBvcmlnaW5hbCB3b24ndCBiZSBtYW5pcHVsYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgZHVlRGF0ZSA9IHdpbmRvdy5tb21lbnQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIGRheXMgdG8gaGFuZGxlIGNyb3NzIGRheWxpZ2h0LXNhdmluZ3MtdGltZSByZWN1cnJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgZHVlRGF0ZS5hZGQoTWF0aC5yb3VuZChvcmlnaW5hbERpZmZlcmVuY2UuYXNEYXlzKCkpLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW1pbmRlckRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbih0aGlzLnJlbWluZGVyRGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25pbmcgc28gdGhhdCBvcmlnaW5hbCB3b24ndCBiZSBtYW5pcHVsYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgcmVtaW5kZXJEYXRlID0gd2luZG93Lm1vbWVudChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgZGF5cyB0byBoYW5kbGUgY3Jvc3MgZGF5bGlnaHQtc2F2aW5ncy10aW1lIHJlY3VycmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICByZW1pbmRlckRhdGUuYWRkKE1hdGgucm91bmQob3JpZ2luYWxEaWZmZXJlbmNlLmFzRGF5cygpKSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgICAgICByZW1pbmRlckRhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGlkZW50aWNhbFRvKG90aGVyOiBSZWN1cnJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5ICE9PSBvdGhlci5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBpZiAoY29tcGFyZUJ5RGF0ZSh0aGlzLnN0YXJ0RGF0ZSwgb3RoZXIuc3RhcnREYXRlKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlQnlEYXRlKHRoaXMuc2NoZWR1bGVkRGF0ZSwgb3RoZXIuc2NoZWR1bGVkRGF0ZSkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZUJ5RGF0ZSh0aGlzLmR1ZURhdGUsIG90aGVyLmR1ZURhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVCeURhdGUodGhpcy5yZW1pbmRlckRhdGUsIG90aGVyLnJlbWluZGVyRGF0ZSkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvVGV4dCgpID09PSBvdGhlci50b1RleHQoKTsgLy8gdGhpcyBhbHNvIGNoZWNrcyBiYXNlT25Ub2RheVxuICAgIH1cblxuICAgIHByaXZhdGUgbmV4dFJlZmVyZW5jZURhdGUodG9kYXk6IE1vbWVudCk6IERhdGUge1xuICAgICAgICBpZiAodGhpcy5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgLy8gVGhlIG5leHQgb2NjdXJyZW5jZSBzaG91bGQgaGFwcGVuIGJhc2VkIG9mZiB0aGUgY3VycmVudCBkYXRlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFJlZmVyZW5jZURhdGVGcm9tVG9kYXkodG9kYXkpLnRvRGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFJlZmVyZW5jZURhdGVGcm9tT3JpZ2luYWxSZWZlcmVuY2VEYXRlKCkudG9EYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG5leHRSZWZlcmVuY2VEYXRlRnJvbVRvZGF5KHRvZGF5OiBNb21lbnQpOiBNb21lbnQge1xuICAgICAgICBjb25zdCBydWxlQmFzZWRPblRvZGF5ID0gbmV3IFJSdWxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMucnJ1bGUub3JpZ09wdGlvbnMsXG4gICAgICAgICAgICBkdHN0YXJ0OiB0b2RheS5zdGFydE9mKCdkYXknKS51dGModHJ1ZSkudG9EYXRlKCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRBZnRlcih0b2RheS5lbmRPZignZGF5JyksIHJ1bGVCYXNlZE9uVG9kYXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbmV4dFJlZmVyZW5jZURhdGVGcm9tT3JpZ2luYWxSZWZlcmVuY2VEYXRlKCk6IE1vbWVudCB7XG4gICAgICAgIC8vIFRoZSBuZXh0IG9jY3VycmVuY2Ugc2hvdWxkIGhhcHBlbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGRhdGUgaWYgcG9zc2libGUuIE90aGVyd2lzZSwgYmFzZSBpdCBvbiB0b2RheSBpZiB3ZSBkbyBub3QgaGF2ZSBhXG4gICAgICAgIC8vIHJlZmVyZW5jZSBkYXRlLlxuICAgICAgICBjb25zdCBhZnRlciA9IHdpbmRvd1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNlIGRhdGUgY2FuIGJlIGB1bmRlZmluZWRgIHRvIG1lYW4gXCJ0b2RheVwiLlxuICAgICAgICAgICAgLy8gTW9tZW50IG9ubHkgYWNjZXB0cyBgdW5kZWZpbmVkYCwgbm90IGBudWxsYC5cbiAgICAgICAgICAgIC5tb21lbnQodGhpcy5yZWZlcmVuY2VEYXRlID8/IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5lbmRPZignZGF5Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEFmdGVyKGFmdGVyLCB0aGlzLnJydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXIgcmV0dXJucyB0aGUgbmV4dCBvY2N1cnJlbmNlJ3MgZGF0ZSBhZnRlciBgYWZ0ZXJgLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcnJ1bGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29tbW9uIGNhc2UgaXMgdGhhdCBgcnJ1bGUuYWZ0ZXJgIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhbmQgaXRcbiAgICAgKiBjYW4gYmUgdXNlZCBhcyBpcy5cbiAgICAgKlxuICAgICAqIEluIHRoZSBzcGVjaWFsIGNhc2VzIG9mIG1vbnRobHkgYW5kIHllYXJseSByZWN1cnJlbmNlcywgdGhlcmUgZXhpc3RzIGFuXG4gICAgICogZWRnZSBjYXNlIHdoZXJlIGFuIG9jY3VycmVuY2UgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZiBtb250aHMgb3IgeWVhcnNcbiAgICAgKiBpcyBub3QgcG9zc2libGUuIEZvciBleGFtcGxlOiBBIHRhc2sgaXMgZHVlIG9uIDIwMjItMDEtMzEgYW5kIGhhcyBhXG4gICAgICogcmVjdXJyZW5jZSBvZiBgZXZlcnkgbW9udGhgLiBXaGVuIG1hcmtpbmcgdGhlIHRhc2sgYXMgZG9uZSwgdGhlIG5leHRcbiAgICAgKiBvY2N1cnJlbmNlIHdpbGwgaGFwcGVuIG9uIDIwMjItMDMtMzEuIFRoZSByZWFzb24gYmVpbmcgdGhhdCBGZWJydWFyeVxuICAgICAqIGRvZXMgbm90IGhhdmUgMzEgZGF5cywgeWV0IFJSdWxlIHNldHMgYGJ5bW9udGhkYXlgIHRvIGAzMWAgZm9yIGxhY2sgb2ZcbiAgICAgKiBoYXZpbmcgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUuXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBmaXggdGhpcywgYGFmdGVyYCB3aWxsIG1vdmUgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LiBFYWNoXG4gICAgICogZGF5LCB0aGUgbmV4dCBvY2N1cnJlbmNlIGlzIGNoZWNrZWQgdG8gYmUgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZlxuICAgICAqIG1vbnRocyBvciB5ZWFycy4gQnkgbW92aW5nIGBhZnRlcmAgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LCBpdCB3aWxsXG4gICAgICogZXZlbnR1YWxseSBjYWxjdWxhdGUgdGhlIG5leHQgb2NjdXJyZW5jZSBiYXNlZCBvbiBgMjAyMi0wMS0yOGAsIGVuZGluZyB1cFxuICAgICAqIGluIEZlYnJ1YXJ5IGFzIHRoZSB1c2VyIHdvdWxkIGV4cGVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5leHRBZnRlcihhZnRlcjogTW9tZW50LCBycnVsZTogUlJ1bGUpOiBNb21lbnQge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgdGltZXpvbmUsIGFzIHJydWxlIGRvZXMgbm90IHJlZ2FyZCB0aW1lem9uZXMgYW5kIGFsd2F5c1xuICAgICAgICAvLyBjYWxjdWxhdGVzIGluIFVUQy5cbiAgICAgICAgLy8gVGhlIHRpbWV6b25lIGlzIGFkZGVkIGFnYWluIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5leHQgZGF0ZS5cbiAgICAgICAgYWZ0ZXIudXRjKHRydWUpO1xuICAgICAgICBsZXQgbmV4dCA9IHdpbmRvdy5tb21lbnQocnJ1bGUuYWZ0ZXIoYWZ0ZXIudG9EYXRlKCkpKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbW9udGhseSByZWN1cnJlbmNlLCB0cmVhdCBpdCBzcGVjaWFsLlxuICAgICAgICBjb25zdCBhc1RleHQgPSB0aGlzLnRvVGV4dCgpO1xuICAgICAgICBjb25zdCBtb250aE1hdGNoID0gYXNUZXh0Lm1hdGNoKC9ldmVyeSggXFxkKyk/IG1vbnRoKHMpPyguKik/Lyk7XG4gICAgICAgIGlmIChtb250aE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyAuLi4gdW5sZXNzIHRoZSBydWxlIGZpeGVzIHRoZSBkYXRlLCBzdWNoIGFzICdldmVyeSBtb250aCBvbiB0aGUgMzFzdCdcbiAgICAgICAgICAgIGlmICghYXNUZXh0LmluY2x1ZGVzKCcgb24gJykpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gUmVjdXJyZW5jZS5uZXh0QWZ0ZXJNb250aHMoYWZ0ZXIsIG5leHQsIHJydWxlLCBtb250aE1hdGNoWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB5ZWFybHkgcmVjdXJyZW5jZSwgdHJlYXQgaXQgc3BlY2lhbC5cbiAgICAgICAgY29uc3QgeWVhck1hdGNoID0gYXNUZXh0Lm1hdGNoKC9ldmVyeSggXFxkKyk/IHllYXIocyk/KC4qKT8vKTtcbiAgICAgICAgaWYgKHllYXJNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UubmV4dEFmdGVyWWVhcnMoYWZ0ZXIsIG5leHQsIHJydWxlLCB5ZWFyTWF0Y2hbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBhZGQgdGhlIHRpbWV6b25lIGFnYWluIHRoYXQgd2UgcmVtb3ZlZCBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgbWV0aG9kLlxuICAgICAgICByZXR1cm4gUmVjdXJyZW5jZS5hZGRUaW1lem9uZShuZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXJNb250aHMgY2FsY3VsYXRlcyB0aGUgbmV4dCBkYXRlIGFmdGVyIGBza2lwcGluZ01vbnRoc2AgbW9udGhzLlxuICAgICAqXG4gICAgICogYHNraXBwaW5nTW9udGhzYCBkZWZhdWx0cyB0byBgMWAgaWYgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIG5leHRBZnRlck1vbnRocyhcbiAgICAgICAgYWZ0ZXI6IE1vbWVudCxcbiAgICAgICAgbmV4dDogTW9tZW50LFxuICAgICAgICBycnVsZTogUlJ1bGUsXG4gICAgICAgIHNraXBwaW5nTW9udGhzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgKTogTW9tZW50IHtcbiAgICAgICAgLy8gUGFyc2UgYHNraXBwaW5nTW9udGhzYCwgaWYgaXQgZXhpc3RzLlxuICAgICAgICBsZXQgcGFyc2VkU2tpcHBpbmdNb250aHM6IG51bWJlciA9IDE7XG4gICAgICAgIGlmIChza2lwcGluZ01vbnRocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJzZWRTa2lwcGluZ01vbnRocyA9IE51bWJlci5wYXJzZUludChza2lwcGluZ01vbnRocy50cmltKCksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoaWxlIHdlIHNraXAgdGhlIHdyb25nIG51bWJlciBvZiBtb250aHMsIG1vdmUgYGFmdGVyYCBvbmUgZGF5IGludG8gdGhlIHBhc3QuXG4gICAgICAgIHdoaWxlIChSZWN1cnJlbmNlLmlzU2tpcHBpbmdUb29NYW55TW9udGhzKGFmdGVyLCBuZXh0LCBwYXJzZWRTa2lwcGluZ01vbnRocykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgYWx0ZXJzIGBhZnRlcmAgdG8gYmUgb25lIGRheSBlYXJsaWVyLlxuICAgICAgICAgICAgLy8gVGhlbiByZXR1cm5zIGBuZXh0YCBiYXNlZCBvbiB0aGF0LlxuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UuZnJvbU9uZURheUVhcmxpZXIoYWZ0ZXIsIHJydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlzU2tpcHBpbmdUb29NYW55TW9udGhzIHJldHVybnMgdHJ1ZSBpZiBgbmV4dGAgaXMgbW9yZSB0aGFuIGBza2lwcGluZ01vbnRoc2AgbW9udGhzIGFmdGVyIGBhZnRlcmAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNTa2lwcGluZ1Rvb01hbnlNb250aHMoYWZ0ZXI6IE1vbWVudCwgbmV4dDogTW9tZW50LCBza2lwcGluZ01vbnRoczogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkaWZmTW9udGhzID0gbmV4dC5tb250aCgpIC0gYWZ0ZXIubW9udGgoKTtcblxuICAgICAgICAvLyBNYXliZSBzb21lIHllYXJzIGhhdmUgcGFzc2VkP1xuICAgICAgICBjb25zdCBkaWZmWWVhcnMgPSBuZXh0LnllYXIoKSAtIGFmdGVyLnllYXIoKTtcbiAgICAgICAgZGlmZk1vbnRocyArPSBkaWZmWWVhcnMgKiAxMjtcblxuICAgICAgICByZXR1cm4gZGlmZk1vbnRocyA+IHNraXBwaW5nTW9udGhzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5leHRBZnRlclllYXJzIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhZnRlciBgc2tpcHBpbmdZZWFyc2AgeWVhcnMuXG4gICAgICpcbiAgICAgKiBgc2tpcHBpbmdZZWFyc2AgZGVmYXVsdHMgdG8gYDFgIGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBuZXh0QWZ0ZXJZZWFycyhcbiAgICAgICAgYWZ0ZXI6IE1vbWVudCxcbiAgICAgICAgbmV4dDogTW9tZW50LFxuICAgICAgICBycnVsZTogUlJ1bGUsXG4gICAgICAgIHNraXBwaW5nWWVhcnM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICApOiBNb21lbnQge1xuICAgICAgICAvLyBQYXJzZSBgc2tpcHBpbmdZZWFyc2AsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgbGV0IHBhcnNlZFNraXBwaW5nWWVhcnM6IG51bWJlciA9IDE7XG4gICAgICAgIGlmIChza2lwcGluZ1llYXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnNlZFNraXBwaW5nWWVhcnMgPSBOdW1iZXIucGFyc2VJbnQoc2tpcHBpbmdZZWFycy50cmltKCksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoaWxlIHdlIHNraXAgdGhlIHdyb25nIG51bWJlciBvZiB5ZWFycywgbW92ZSBgYWZ0ZXJgIG9uZSBkYXkgaW50byB0aGUgcGFzdC5cbiAgICAgICAgd2hpbGUgKFJlY3VycmVuY2UuaXNTa2lwcGluZ1Rvb01hbnlZZWFycyhhZnRlciwgbmV4dCwgcGFyc2VkU2tpcHBpbmdZZWFycykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgYWx0ZXJzIGBhZnRlcmAgdG8gYmUgb25lIGRheSBlYXJsaWVyLlxuICAgICAgICAgICAgLy8gVGhlbiByZXR1cm5zIGBuZXh0YCBiYXNlZCBvbiB0aGF0LlxuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UuZnJvbU9uZURheUVhcmxpZXIoYWZ0ZXIsIHJydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlzU2tpcHBpbmdUb29NYW55WWVhcnMgcmV0dXJucyB0cnVlIGlmIGBuZXh0YCBpcyBtb3JlIHRoYW4gYHNraXBwaW5nWWVhcnNgIHllYXJzIGFmdGVyIGBhZnRlcmAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNTa2lwcGluZ1Rvb01hbnlZZWFycyhhZnRlcjogTW9tZW50LCBuZXh0OiBNb21lbnQsIHNraXBwaW5nWWVhcnM6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBkaWZmID0gbmV4dC55ZWFyKCkgLSBhZnRlci55ZWFyKCk7XG5cbiAgICAgICAgcmV0dXJuIGRpZmYgPiBza2lwcGluZ1llYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZyb21PbmVEYXlFYXJsaWVyIHJldHVybnMgdGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlciBtb3ZpbmcgYGFmdGVyYCBvbmUgZGF5IGludG8gdGhlIHBhc3QuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCBtYW5pcHVsYXRlcyB0aGUgZ2l2ZW4gaW5zdGFuY2Ugb2YgYGFmdGVyYC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBmcm9tT25lRGF5RWFybGllcihhZnRlcjogTW9tZW50LCBycnVsZTogUlJ1bGUpOiBNb21lbnQge1xuICAgICAgICBhZnRlci5zdWJ0cmFjdCgxLCAnZGF5cycpLmVuZE9mKCdkYXknKTtcblxuICAgICAgICBjb25zdCBvcHRpb25zID0gcnJ1bGUub3JpZ09wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMuZHRzdGFydCA9IGFmdGVyLnN0YXJ0T2YoJ2RheScpLnRvRGF0ZSgpO1xuICAgICAgICBycnVsZSA9IG5ldyBSUnVsZShvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gd2luZG93Lm1vbWVudChycnVsZS5hZnRlcihhZnRlci50b0RhdGUoKSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGFkZFRpbWV6b25lKGRhdGU6IE1vbWVudCk6IE1vbWVudCB7XG4gICAgICAgIGNvbnN0IGxvY2FsVGltZVpvbmUgPSB3aW5kb3cubW9tZW50LnV0YyhkYXRlKS5sb2NhbCh0cnVlKTtcblxuICAgICAgICByZXR1cm4gbG9jYWxUaW1lWm9uZS5zdGFydE9mKCdkYXknKTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiB7QGxpbmsgVGFza30gZmllbGRzIHVzZWQgZm9yIHJlbmRlcmluZy4gVXNlIHJlZmVyZW5jZXMgdG8gdGhpcyBlbnVtICh7QGxpbmsgVGFza0xheW91dENvbXBvbmVudC5JZH0pXG4gKiBpbnN0ZWFkIG9mIHBsYWluIHN0cmluZyB2YWx1ZXMgKGBpZGApLlxuICpcbiAqIFRoZSBvcmRlciBoZXJlIGRldGVybWluZXMgdGhlIG9yZGVyIHRoYXQgdGFzayBmaWVsZHMgYXJlIHJlbmRlcmVkIGFuZCB3cml0dGVuIHRvIG1hcmtkb3duLlxuICovXG5leHBvcnQgZW51bSBUYXNrTGF5b3V0Q29tcG9uZW50IHtcbiAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgRGVzY3JpcHRpb24gPSAnZGVzY3JpcHRpb24nLFxuICAgIElkID0gJ2lkJyxcbiAgICBEZXBlbmRzT24gPSAnZGVwZW5kc09uJyxcbiAgICBQcmlvcml0eSA9ICdwcmlvcml0eScsXG4gICAgUmVjdXJyZW5jZVJ1bGUgPSAncmVjdXJyZW5jZVJ1bGUnLFxuICAgIENyZWF0ZWREYXRlID0gJ2NyZWF0ZWREYXRlJyxcbiAgICBTdGFydERhdGUgPSAnc3RhcnREYXRlJyxcbiAgICBTY2hlZHVsZWREYXRlID0gJ3NjaGVkdWxlZERhdGUnLFxuICAgIER1ZURhdGUgPSAnZHVlRGF0ZScsXG4gICAgUmVtaW5kZXJEYXRlID0gJ3JlbWluZGVyRGF0ZScsXG4gICAgQ2FuY2VsbGVkRGF0ZSA9ICdjYW5jZWxsZWREYXRlJyxcbiAgICBEb25lRGF0ZSA9ICdkb25lRGF0ZScsXG4gICAgQmxvY2tMaW5rID0gJ2Jsb2NrTGluaycsXG59XG5cbmV4cG9ydCBjb25zdCB0YXNrTGF5b3V0Q29tcG9uZW50cyA9IE9iamVjdC52YWx1ZXMoVGFza0xheW91dENvbXBvbmVudCk7XG5cbi8qKlxuICogVmFyaW91cyByZW5kZXJpbmcgb3B0aW9ucyBvZiB0YXNrcyBpbiBhIHF1ZXJ5LlxuICpcbiAqIFNlZSB7QGxpbmsgVGFza0xheW91dENvbXBvbmVudH0gZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgYW4gYWRkaXRpb25hbCBzcGVjaWFsIGNhc2UsIGZvciB3aGV0aGVyIHRhZ3MgYXJlIHNob3duLlxuICpcbiAqIEBzZWUgUXVlcnlMYXlvdXRPcHRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrTGF5b3V0T3B0aW9ucyB7XG4gICAgcHJpdmF0ZSB2aXNpYmxlOiB7IFtjb21wb25lbnQ6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAgIHByaXZhdGUgdGFnc1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRhc2tMYXlvdXRDb21wb25lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlW2NvbXBvbmVudF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNTaG93bihjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVtjb21wb25lbnRdO1xuICAgIH1cblxuICAgIHB1YmxpYyBhcmVUYWdzU2hvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3NWaXNpYmxlO1xuICAgIH1cblxuICAgIHB1YmxpYyBoaWRlKGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICB0aGlzLnZpc2libGVbY29tcG9uZW50XSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRWaXNpYmlsaXR5KGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCwgdmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnZpc2libGVbY29tcG9uZW50XSA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFRhZ3NWaXNpYmlsaXR5KHZpc2liaWxpdHk6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy50YWdzVmlzaWJsZSA9IHZpc2liaWxpdHk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzaG93bkNvbXBvbmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0YXNrTGF5b3V0Q29tcG9uZW50cy5maWx0ZXIoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVtjb21wb25lbnRdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhpZGRlbkNvbXBvbmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0YXNrTGF5b3V0Q29tcG9uZW50cy5maWx0ZXIoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnZpc2libGVbY29tcG9uZW50XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlc2UgcmVwcmVzZW50IHRoZSBleGlzdGluZyB0YXNrIG9wdGlvbnMsIHNvIHNvbWUgY29tcG9uZW50cyAoZGVzY3JpcHRpb24gJiBibG9jayBsaW5rIGZvciBub3cpIGFyZSBub3RcbiAgICAgKiBoZXJlIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxheW91dCBvcHRpb25zIHRvIHJlbW92ZSB0aGVtLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG9nZ2xlYWJsZUNvbXBvbmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0YXNrTGF5b3V0Q29tcG9uZW50cy5maWx0ZXIoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gRGVzY3JpcHRpb24gYW5kIGJsb2NrTGluayBhcmUgYWx3YXlzIHNob3duXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50ICE9PSBUYXNrTGF5b3V0Q29tcG9uZW50LkRlc2NyaXB0aW9uICYmIGNvbXBvbmVudCAhPT0gVGFza0xheW91dENvbXBvbmVudC5CbG9ja0xpbms7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b2dnbGVWaXNpYmlsaXR5RXhjZXB0RGVzY3JpcHRpb25BbmRCbG9ja0xpbmsoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlYWJsZUNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVbY29tcG9uZW50XSA9ICF0aGlzLnZpc2libGVbY29tcG9uZW50XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRUYWdzVmlzaWJpbGl0eSghdGhpcy5hcmVUYWdzU2hvd24oKSk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBUYXNrUmVndWxhckV4cHJlc3Npb25zIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRhdGVGb3JtYXQgPSAnWVlZWS1NTS1ERCc7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkYXRlVGltZUZvcm1hdCA9ICdZWVlZLU1NLUREIEhIOm1tJztcblxuICAgIC8vIE1hdGNoZXMgaW5kZW50YXRpb24gYmVmb3JlIGEgbGlzdCBtYXJrZXIgKGluY2x1ZGluZyA+IGZvciBwb3RlbnRpYWxseSBuZXN0ZWQgYmxvY2txdW90ZXMgb3IgT2JzaWRpYW4gY2FsbG91dHMpXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpbmRlbnRhdGlvblJlZ2V4ID0gL14oW1xcc1xcdD5dKikvO1xuXG4gICAgLy8gTWF0Y2hlcyAtICogYW5kICsgbGlzdCBtYXJrZXJzLCBvciBudW1iZXJlZCBsaXN0IG1hcmtlcnMgKGVnIDEuKVxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbGlzdE1hcmtlclJlZ2V4ID0gLyhbLSorXXxbMC05XStcXC4pLztcblxuICAgIC8vIE1hdGNoZXMgYSBjaGVja2JveCBhbmQgc2F2ZXMgdGhlIHN0YXR1cyBjaGFyYWN0ZXIgaW5zaWRlXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBjaGVja2JveFJlZ2V4ID0gL1xcWyguKVxcXS91O1xuXG4gICAgLy8gTWF0Y2hlcyB0aGUgcmVzdCBvZiB0aGUgdGFzayBhZnRlciB0aGUgY2hlY2tib3guXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBhZnRlckNoZWNrYm94UmVnZXggPSAvICooLiopL3U7XG5cbiAgICAvLyBNYWluIHJlZ2V4IGZvciBwYXJzaW5nIGEgbGluZS4gSXQgbWF0Y2hlcyB0aGUgZm9sbG93aW5nOlxuICAgIC8vIC0gSW5kZW50YXRpb25cbiAgICAvLyAtIExpc3QgbWFya2VyXG4gICAgLy8gLSBTdGF0dXMgY2hhcmFjdGVyXG4gICAgLy8gLSBSZXN0IG9mIHRhc2sgYWZ0ZXIgY2hlY2tib3ggbWFya2Rvd25cbiAgICAvLyBTZWUgVGFzay5leHRyYWN0VGFza0NvbXBvbmVudHMoKSBmb3IgYWJzdHJhY3Rpb24gYXJvdW5kIHRoaXMgcmVndWxhciBleHByZXNzaW9uLlxuICAgIC8vIFRoYXQgaXMgcHJpdmF0ZSBmb3Igbm93LCBidXQgY291bGQgYmUgbWFkZSBwdWJsaWMgaW4gZnV0dXJlIGlmIG5lZWRlZC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRhc2tSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaW5kZW50YXRpb25SZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0TWFya2VyUmVnZXguc291cmNlICtcbiAgICAgICAgICAgICcgKycgK1xuICAgICAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5jaGVja2JveFJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmFmdGVyQ2hlY2tib3hSZWdleC5zb3VyY2UsXG4gICAgICAgICd1JyxcbiAgICApO1xuXG4gICAgLy8gVXNlZCB3aXRoIHRoZSBcIkNyZWF0ZSBvciBFZGl0IFRhc2tcIiBjb21tYW5kIHRvIHBhcnNlIGluZGVudGF0aW9uIGFuZCBzdGF0dXMgaWYgcHJlc2VudFxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbm9uVGFza1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5pbmRlbnRhdGlvblJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RNYXJrZXJSZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgJz8gKignICtcbiAgICAgICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuY2hlY2tib3hSZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgJyk/JyArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmFmdGVyQ2hlY2tib3hSZWdleC5zb3VyY2UsXG4gICAgICAgICd1JyxcbiAgICApO1xuXG4gICAgLy8gVXNlZCB3aXRoIFwiVG9nZ2xlIERvbmVcIiBjb21tYW5kIHRvIGRldGVjdCBhIGxpc3QgaXRlbSB0aGF0IGNhbiBnZXQgYSBjaGVja2JveCBhZGRlZCB0byBpdC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGxpc3RJdGVtUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmluZGVudGF0aW9uUmVnZXguc291cmNlICsgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0TWFya2VyUmVnZXguc291cmNlLFxuICAgICk7XG5cbiAgICAvLyBNYXRjaCBvbiBibG9jayBsaW5rIGF0IGVuZC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJsb2NrTGlua1JlZ2V4ID0gLyBcXF5bYS16QS1aMC05LV0rJC91O1xuXG4gICAgLy8gUmVnZXggdG8gbWF0Y2ggYWxsIGhhc2ggdGFncywgYmFzaWNhbGx5IGhhc2ggZm9sbG93ZWQgYnkgYW55dGhpbmcgYnV0IHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBuZWdhdGlvbi5cbiAgICAvLyBUbyBlbnN1cmUgVVJMcyBhcmUgbm90IGNhdWdodCBpdCBpcyBsb29raW5nIG9mIGJlZ2lubmluZyBvZiBzdHJpbmcgdGFnIGFuZCBhbnlcbiAgICAvLyB0YWcgdGhhdCBoYXMgYSBzcGFjZSBpbiBmcm9udCBvZiBpdC4gQW55ICMgdGhhdCBoYXMgYSBjaGFyYWN0ZXIgaW4gZnJvbnRcbiAgICAvLyBvZiBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgLy8gRVhBTVBMRTpcbiAgICAvLyBkZXNjcmlwdGlvbjogJyNkb2cgI2NhciBodHRwOi8vd3d3L2RkZCNlcmUgI2hvdXNlJ1xuICAgIC8vIG1hdGNoZXM6ICNkb2csICNjYXIsICNob3VzZVxuICAgIC8vIE1BSU5URU5BTkNFIE5PVEU6XG4gICAgLy8gIElmIGhhc2hUYWdzIGlzIG1vZGlmaWVkLCBwbGVhc2UgdXBkYXRlICdSZWNvZ25pc2luZyBUYWdzJyBpbiBUYWdzLm1kIGluIHRoZSBkb2NzLlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaGFzaFRhZ3MgPSAvKF58XFxzKSNbXiAhQCMkJV4mKigpLC4/XCI6e318PD5dKy9nO1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaGFzaFRhZ3NGcm9tRW5kID0gbmV3IFJlZ0V4cCh0aGlzLmhhc2hUYWdzLnNvdXJjZSArICckJyk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgVGFza0xheW91dENvbXBvbmVudCwgVGFza0xheW91dE9wdGlvbnMgfSBmcm9tICcuLi9MYXlvdXQvVGFza0xheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgUmVjdXJyZW5jZSB9IGZyb20gJy4uL1Rhc2svUmVjdXJyZW5jZSc7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFByaW9yaXR5IH0gZnJvbSAnLi4vVGFzay9Qcmlvcml0eSc7XG5pbXBvcnQgeyBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzay9UYXNrUmVndWxhckV4cHJlc3Npb25zJztcbmltcG9ydCB7IGlzRGF0ZVRpbWUgfSBmcm9tICcuLi9saWIvRGF0ZVRvb2xzJztcbmltcG9ydCB0eXBlIHsgVGFza0RldGFpbHMsIFRhc2tTZXJpYWxpemVyIH0gZnJvbSAnLic7XG5cbi8qIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBzeW1ib2xzIHRoYXQge0BsaW5rIERlZmF1bHRUYXNrU2VyaWFsaXplcn1cbiAqIHVzZXMgdG8gc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSB0YXNrcy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIERlZmF1bHRUYXNrU2VyaWFsaXplclN5bWJvbHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzIHtcbiAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgcmVhZG9ubHkgcHJpb3JpdHlTeW1ib2xzOiB7XG4gICAgICAgIEhpZ2hlc3Q6IHN0cmluZztcbiAgICAgICAgSGlnaDogc3RyaW5nO1xuICAgICAgICBNZWRpdW06IHN0cmluZztcbiAgICAgICAgTG93OiBzdHJpbmc7XG4gICAgICAgIExvd2VzdDogc3RyaW5nO1xuICAgICAgICBOb25lOiBzdHJpbmc7XG4gICAgfTtcbiAgICByZWFkb25seSBzdGFydERhdGVTeW1ib2w6IHN0cmluZztcbiAgICByZWFkb25seSBjcmVhdGVkRGF0ZVN5bWJvbDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHNjaGVkdWxlZERhdGVTeW1ib2w6IHN0cmluZztcbiAgICByZWFkb25seSBkdWVEYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgcmVtaW5kZXJEYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZG9uZURhdGVTeW1ib2w6IHN0cmluZztcbiAgICByZWFkb25seSBjYW5jZWxsZWREYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgcmVjdXJyZW5jZVN5bWJvbDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGlkU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZGVwZW5kc09uU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9uczoge1xuICAgICAgICBwcmlvcml0eVJlZ2V4OiBSZWdFeHA7XG4gICAgICAgIHN0YXJ0RGF0ZVJlZ2V4OiBSZWdFeHA7XG4gICAgICAgIGNyZWF0ZWREYXRlUmVnZXg6IFJlZ0V4cDtcbiAgICAgICAgc2NoZWR1bGVkRGF0ZVJlZ2V4OiBSZWdFeHA7XG4gICAgICAgIGR1ZURhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICByZW1pbmRlckRhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICByZW1pbmRlckRhdGVUaW1lUmVnZXg6IFJlZ0V4cDtcbiAgICAgICAgZG9uZURhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICBjYW5jZWxsZWREYXRlUmVnZXg6IFJlZ0V4cDtcbiAgICAgICAgcmVjdXJyZW5jZVJlZ2V4OiBSZWdFeHA7XG4gICAgICAgIGlkUmVnZXg6IFJlZ0V4cDtcbiAgICAgICAgZGVwZW5kc09uUmVnZXg6IFJlZ0V4cDtcbiAgICB9O1xufVxuXG4vLyBUaGUgYWxsb3dlZCBjaGFyYWN0ZXJzIGluIGEgc2luZ2xlIHRhc2sgaWQ6XG5leHBvcnQgY29uc3QgdGFza0lkUmVnZXggPSAvW2EtekEtWjAtOS1fXSsvO1xuXG4vLyBUaGUgYWxsb3dlZCBjaGFyYWN0ZXJzIGluIGEgY29tbWEtc2VwYXJhdGVkIHNlcXVlbmNlIG9mIHRhc2sgaWRzOlxuZXhwb3J0IGNvbnN0IHRhc2tJZFNlcXVlbmNlUmVnZXggPSBuZXcgUmVnRXhwKHRhc2tJZFJlZ2V4LnNvdXJjZSArICcoICosIConICsgdGFza0lkUmVnZXguc291cmNlICsgJyAqKSonKTtcblxuLyoqXG4gKiBBIHN5bWJvbCBtYXAgZm9yIG9ic2lkaWFuLXRhc2sncyBkZWZhdWx0IHRhc2sgc3R5bGUuXG4gKiBVc2VzIGVtb2ppcyB0byBjb25jaXNlbHkgY29udmV5IG1lYW5pbmdcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU1lNQk9MUzogRGVmYXVsdFRhc2tTZXJpYWxpemVyU3ltYm9scyA9IHtcbiAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgcHJpb3JpdHlTeW1ib2xzOiB7XG4gICAgICAgIEhpZ2hlc3Q6ICdcdUQ4M0RcdUREM0EnLFxuICAgICAgICBIaWdoOiAnXHUyM0VCJyxcbiAgICAgICAgTWVkaXVtOiAnXHVEODNEXHVERDNDJyxcbiAgICAgICAgTG93OiAnXHVEODNEXHVERDNEJyxcbiAgICAgICAgTG93ZXN0OiAnXHUyM0VDJyxcbiAgICAgICAgTm9uZTogJycsXG4gICAgfSxcbiAgICBzdGFydERhdGVTeW1ib2w6ICdcdUQ4M0RcdURFRUInLFxuICAgIGNyZWF0ZWREYXRlU3ltYm9sOiAnXHUyNzk1JyxcbiAgICBzY2hlZHVsZWREYXRlU3ltYm9sOiAnXHUyM0YzJyxcbiAgICBkdWVEYXRlU3ltYm9sOiAnXHVEODNEXHVEQ0M1JyxcbiAgICByZW1pbmRlckRhdGVTeW1ib2w6ICdcdTIzRjAnLFxuICAgIGRvbmVEYXRlU3ltYm9sOiAnXHUyNzA1JyxcbiAgICBjYW5jZWxsZWREYXRlU3ltYm9sOiAnXHUyNzRDJyxcbiAgICByZWN1cnJlbmNlU3ltYm9sOiAnXHVEODNEXHVERDAxJyxcbiAgICBkZXBlbmRzT25TeW1ib2w6ICdcdTI2RDQnLFxuICAgIGlkU3ltYm9sOiAnXHVEODNDXHVERDk0JyxcbiAgICBUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zOiB7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXgncyBlbmQgd2l0aCBgJGAgYmVjYXVzZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBlbmQgdW50aWwgbm9uZSBhcmUgbGVmdC5cbiAgICAgICAgLy8gXFx1RkUwRj8gYWxsb3dzIGFuIG9wdGlvbmFsIFZhcmlhbnQgU2VsZWN0b3IgMTYgb24gZW1vamlzLlxuICAgICAgICBwcmlvcml0eVJlZ2V4OiAvKFtcdUQ4M0RcdUREM0FcdTIzRUJcdUQ4M0RcdUREM0NcdUQ4M0RcdUREM0RcdTIzRUNdKVxcdUZFMEY/JC91LFxuICAgICAgICBzdGFydERhdGVSZWdleDogL1x1RDgzRFx1REVFQiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdSxcbiAgICAgICAgY3JlYXRlZERhdGVSZWdleDogL1x1Mjc5NSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZVJlZ2V4OiAvW1x1MjNGM1x1MjMxQl0gKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3UsXG4gICAgICAgIGR1ZURhdGVSZWdleDogL1tcdUQ4M0RcdURDQzVcdUQ4M0RcdURDQzZcdUQ4M0RcdURERDNdICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pJC91LFxuICAgICAgICByZW1pbmRlckRhdGVSZWdleDogL1tcdTIzRjBdICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pJC91LFxuICAgICAgICByZW1pbmRlckRhdGVUaW1lUmVnZXg6IC9bXHUyM0YwXSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9IFxcZHsyfTpcXGR7Mn0pJC91LFxuICAgICAgICBkb25lRGF0ZVJlZ2V4OiAvXHUyNzA1ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pJC91LFxuICAgICAgICBjYW5jZWxsZWREYXRlUmVnZXg6IC9cdTI3NEMgKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3UsXG4gICAgICAgIHJlY3VycmVuY2VSZWdleDogL1x1RDgzRFx1REQwMSA/KFthLXpBLVowLTksICFdKykkL2l1LFxuICAgICAgICBkZXBlbmRzT25SZWdleDogbmV3IFJlZ0V4cCgnXHUyNkQ0XFx1RkUwRj8gKignICsgdGFza0lkU2VxdWVuY2VSZWdleC5zb3VyY2UgKyAnKSQnLCAnaXUnKSxcbiAgICAgICAgaWRSZWdleDogbmV3IFJlZ0V4cCgnXHVEODNDXHVERDk0ICooJyArIHRhc2tJZFJlZ2V4LnNvdXJjZSArICcpJCcsICdpdScpLFxuICAgIH0sXG59IGFzIGNvbnN0O1xuXG5mdW5jdGlvbiBzeW1ib2xBbmRTdHJpbmdWYWx1ZShzaG9ydE1vZGU6IGJvb2xlYW4sIHN5bWJvbDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuICcnO1xuICAgIHJldHVybiBzaG9ydE1vZGUgPyAnICcgKyBzeW1ib2wgOiBgICR7c3ltYm9sfSAke3ZhbHVlfWA7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbEFuZERhdGVWYWx1ZShzaG9ydE1vZGU6IGJvb2xlYW4sIHN5bWJvbDogc3RyaW5nLCBkYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCkge1xuICAgIGlmICghZGF0ZSkgcmV0dXJuICcnO1xuICAgIC8vIFdlIGNvdWxkIGNhbGwgc3ltYm9sQW5kU3RyaW5nVmFsdWUoKSB0byByZW1vdmUgYSBsaXR0bGUgY29kZSByZXBldGl0aW9uLFxuICAgIC8vIGJ1dCBkb2luZyBzbyB3b3VsZCBkbyBzb21lIHdhc3RlZCBkYXRlLWZvcm1hdHRpbmcgd2hlbiBpbiAnc2hvcnQgbW9kZScsXG4gICAgLy8gc28gaW5zdGVhZCB3ZSByZXBlYXQgdGhlIGNoZWNrIG9uIHNob3J0TW9kZSB2YWx1ZS5cbiAgICByZXR1cm4gc2hvcnRNb2RlXG4gICAgICAgID8gJyAnICsgc3ltYm9sXG4gICAgICAgIDogYCAke3N5bWJvbH0gJHtkYXRlLmZvcm1hdChcbiAgICAgICAgICAgICAgaXNEYXRlVGltZShkYXRlKSA/IFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZVRpbWVGb3JtYXQgOiBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQsXG4gICAgICAgICAgKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsVGFza1BsdWdpbkVtb2ppcygpIHtcbiAgICBjb25zdCBhbGxFbW9qaXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBBbGwgdGhlIHByaW9yaXR5IGVtb2ppczpcbiAgICBPYmplY3QudmFsdWVzKERFRkFVTFRfU1lNQk9MUy5wcmlvcml0eVN5bWJvbHMpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhbGxFbW9qaXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFsbCB0aGUgb3RoZXIgZmllbGQgZW1vamlzOlxuICAgIE9iamVjdC52YWx1ZXMoREVGQVVMVF9TWU1CT0xTKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWxsRW1vamlzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFsbEVtb2ppcztcbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHRUYXNrU2VyaWFsaXplciBpbXBsZW1lbnRzIFRhc2tTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgc3ltYm9sczogRGVmYXVsdFRhc2tTZXJpYWxpemVyU3ltYm9scykge31cblxuICAgIC8qIENvbnZlcnQgYSB0YXNrIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXNrIFRoZSB0YXNrIHRvIHNlcmlhbGl6ZVxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YXNrXG4gICAgICovXG4gICAgcHVibGljIHNlcmlhbGl6ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdGFza0xheW91dE9wdGlvbnMgPSBuZXcgVGFza0xheW91dE9wdGlvbnMoKTtcbiAgICAgICAgbGV0IHRhc2tTdHJpbmcgPSAnJztcbiAgICAgICAgY29uc3Qgc2hvcnRNb2RlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIHRhc2tMYXlvdXRPcHRpb25zLnNob3duQ29tcG9uZW50cykge1xuICAgICAgICAgICAgdGFza1N0cmluZyArPSB0aGlzLmNvbXBvbmVudFRvU3RyaW5nKHRhc2ssIHNob3J0TW9kZSwgY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFza1N0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3BlY2lmaWMgVGFza0xheW91dENvbXBvbmVudCBvZiB0aGUgdGFzayAoaXRzIGRlc2NyaXB0aW9uLCBwcmlvcml0eSwgZXRjKSBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcG9uZW50VG9TdHJpbmcodGFzazogVGFzaywgc2hvcnRNb2RlOiBib29sZWFuLCBjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICAgICAgcHJpb3JpdHlTeW1ib2xzLFxuICAgICAgICAgICAgc3RhcnREYXRlU3ltYm9sLFxuICAgICAgICAgICAgY3JlYXRlZERhdGVTeW1ib2wsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICAgICAgZG9uZURhdGVTeW1ib2wsXG4gICAgICAgICAgICBjYW5jZWxsZWREYXRlU3ltYm9sLFxuICAgICAgICAgICAgcmVjdXJyZW5jZVN5bWJvbCxcbiAgICAgICAgICAgIGR1ZURhdGVTeW1ib2wsXG4gICAgICAgICAgICByZW1pbmRlckRhdGVTeW1ib2wsXG4gICAgICAgICAgICBkZXBlbmRzT25TeW1ib2wsXG4gICAgICAgICAgICBpZFN5bWJvbCxcbiAgICAgICAgfSA9IHRoaXMuc3ltYm9scztcblxuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LkRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LlByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgbGV0IHByaW9yaXR5OiBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5IaWdoZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkhpZ2hlc3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5IaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkhpZ2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5NZWRpdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnICcgKyBwcmlvcml0eVN5bWJvbHMuTWVkaXVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkxvdztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5Lkxvd2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICcgJyArIHByaW9yaXR5U3ltYm9scy5Mb3dlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGFza0xheW91dENvbXBvbmVudC5TdGFydERhdGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbEFuZERhdGVWYWx1ZShzaG9ydE1vZGUsIHN0YXJ0RGF0ZVN5bWJvbCwgdGFzay5zdGFydERhdGUpO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LkNyZWF0ZWREYXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xBbmREYXRlVmFsdWUoc2hvcnRNb2RlLCBjcmVhdGVkRGF0ZVN5bWJvbCwgdGFzay5jcmVhdGVkRGF0ZSk7XG4gICAgICAgICAgICBjYXNlIFRhc2tMYXlvdXRDb21wb25lbnQuU2NoZWR1bGVkRGF0ZTpcbiAgICAgICAgICAgICAgICBpZiAodGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZCkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xBbmREYXRlVmFsdWUoc2hvcnRNb2RlLCBzY2hlZHVsZWREYXRlU3ltYm9sLCB0YXNrLnNjaGVkdWxlZERhdGUpO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LkRvbmVEYXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xBbmREYXRlVmFsdWUoc2hvcnRNb2RlLCBkb25lRGF0ZVN5bWJvbCwgdGFzay5kb25lRGF0ZSk7XG4gICAgICAgICAgICBjYXNlIFRhc2tMYXlvdXRDb21wb25lbnQuQ2FuY2VsbGVkRGF0ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sQW5kRGF0ZVZhbHVlKHNob3J0TW9kZSwgY2FuY2VsbGVkRGF0ZVN5bWJvbCwgdGFzay5jYW5jZWxsZWREYXRlKTtcbiAgICAgICAgICAgIGNhc2UgVGFza0xheW91dENvbXBvbmVudC5EdWVEYXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xBbmREYXRlVmFsdWUoc2hvcnRNb2RlLCBkdWVEYXRlU3ltYm9sLCB0YXNrLmR1ZURhdGUpO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LlJlbWluZGVyRGF0ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sQW5kRGF0ZVZhbHVlKHNob3J0TW9kZSwgcmVtaW5kZXJEYXRlU3ltYm9sLCB0YXNrLnJlbWluZGVyRGF0ZSk7XG4gICAgICAgICAgICBjYXNlIFRhc2tMYXlvdXRDb21wb25lbnQuUmVjdXJyZW5jZVJ1bGU6XG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrLnJlY3VycmVuY2UpIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sQW5kU3RyaW5nVmFsdWUoc2hvcnRNb2RlLCByZWN1cnJlbmNlU3ltYm9sLCB0YXNrLnJlY3VycmVuY2UudG9UZXh0KCkpO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LkRlcGVuZHNPbjoge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrLmRlcGVuZHNPbi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sQW5kU3RyaW5nVmFsdWUoc2hvcnRNb2RlLCBkZXBlbmRzT25TeW1ib2wsIHRhc2suZGVwZW5kc09uLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRhc2tMYXlvdXRDb21wb25lbnQuSWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbEFuZFN0cmluZ1ZhbHVlKHNob3J0TW9kZSwgaWRTeW1ib2wsIHRhc2suaWQpO1xuICAgICAgICAgICAgY2FzZSBUYXNrTGF5b3V0Q29tcG9uZW50LkJsb2NrTGluazpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5ibG9ja0xpbmsgPz8gJyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9uJ3Qga25vdyBob3cgdG8gcmVuZGVyIHRhc2sgY29tcG9uZW50IG9mIHR5cGUgJyR7Y29tcG9uZW50fSdgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBzdHJpbmcgY2FwdHVyZWQgaW4gdGhlIGZpcnN0IGNhcHR1cmUgZ3JvdXAgb2ZcbiAgICAgKiAgICB7QGxpbmsgRGVmYXVsdFRhc2tTZXJpYWxpemVyU3ltYm9scy5UYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLnByaW9yaXR5UmVnZXh9LFxuICAgICAqICAgIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgUHJpb3JpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcCBTdHJpbmcgY2FwdHVyZWQgYnkgcHJpb3JpdHlSZWdleFxuICAgICAqIEByZXR1cm5zIENvcnJlc3BvbmRpbmcgcHJpb3JpdHkgaWYgcGFyc2luZyB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIHtAbGluayBQcmlvcml0eS5Ob25lfVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwYXJzZVByaW9yaXR5KHA6IHN0cmluZyk6IFByaW9yaXR5IHtcbiAgICAgICAgY29uc3QgeyBwcmlvcml0eVN5bWJvbHMgfSA9IHRoaXMuc3ltYm9scztcbiAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5Mb3dlc3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lkxvd2VzdDtcbiAgICAgICAgICAgIGNhc2UgcHJpb3JpdHlTeW1ib2xzLkxvdzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTG93O1xuICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuTWVkaXVtOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmlvcml0eS5NZWRpdW07XG4gICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5IaWdoOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuSGlnaGVzdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuSGlnaGVzdDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lk5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQYXJzZSBUYXNrRGV0YWlscyBmcm9tIHRoZSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIGEge0BsaW5rIFRhc2t9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUYXNrRGV0YWlsc31cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZXJpYWxpemUobGluZTogc3RyaW5nKTogVGFza0RldGFpbHMge1xuICAgICAgICBjb25zdCB7IFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMgfSA9IHRoaXMuc3ltYm9scztcblxuICAgICAgICAvLyBLZWVwIG1hdGNoaW5nIGFuZCByZW1vdmluZyBzcGVjaWFsIHN0cmluZ3MgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBkZXNjcmlwdGlvbiBpbiBhbnkgb3JkZXIuIFRoZSBsb29wIHNob3VsZCBvbmx5IHJ1biBvbmNlIGlmIHRoZVxuICAgICAgICAvLyBzdHJpbmdzIGFyZSBpbiB0aGUgZXhwZWN0ZWQgb3JkZXIgYWZ0ZXIgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgIGxldCBtYXRjaGVkOiBib29sZWFuO1xuICAgICAgICBsZXQgcHJpb3JpdHk6IFByaW9yaXR5ID0gUHJpb3JpdHkuTm9uZTtcbiAgICAgICAgbGV0IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGR1ZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcmVtaW5kZXJEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGRvbmVEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGNhbmNlbGxlZERhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgY3JlYXRlZERhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZVJ1bGU6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgaWQ6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgZGVwZW5kc09uOiBzdHJpbmdbXSB8IFtdID0gW107XG4gICAgICAgIC8vIFRhZ3MgdGhhdCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlbmQgd2hpbGUgcGFyc2luZywgYnV0IHdlIHdhbnQgdG8gYWRkIHRoZW0gYmFjayBmb3IgYmVpbmcgcGFydCBvZiB0aGUgZGVzY3JpcHRpb24uXG4gICAgICAgIC8vIEluIHRoZSBvcmlnaW5hbCB0YXNrIGRlc2NyaXB0aW9uIHRoZXkgYXJlIHBvc3NpYmx5IG1peGVkIHdpdGggb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAvLyAoZS5nLiAjdGFnMSA8ZHVlIGRhdGU+ICN0YWcyKSwgdGhleSBkbyBub3QgaGF2ZSB0byBhbGwgdHJhaWwgYWxsIHRhc2sgY29tcG9uZW50cyxcbiAgICAgICAgLy8gYnV0IGV2ZW50dWFsbHkgd2Ugd2FudCB0byBwYXN0ZSB0aGVtIGJhY2sgdG8gdGhlIHRhc2sgZGVzY3JpcHRpb24gYXQgdGhlIGVuZFxuICAgICAgICBsZXQgdHJhaWxpbmdUYWdzID0gJyc7XG4gICAgICAgIC8vIEFkZCBhIFwibWF4IHJ1bnNcIiBmYWlsc2FmZSB0byBuZXZlciBlbmQgaW4gYW4gZW5kbGVzcyBsb29wOlxuICAgICAgICBjb25zdCBtYXhSdW5zID0gMjA7XG4gICAgICAgIGxldCBydW5zID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5wcmlvcml0eVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChwcmlvcml0eU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSB0aGlzLnBhcnNlUHJpb3JpdHkocHJpb3JpdHlNYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLnByaW9yaXR5UmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRvbmVEYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuZG9uZURhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoZG9uZURhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRvbmVEYXRlID0gd2luZG93Lm1vbWVudChkb25lRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5kb25lRGF0ZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZWREYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuY2FuY2VsbGVkRGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWREYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZWREYXRlID0gd2luZG93Lm1vbWVudChjYW5jZWxsZWREYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmNhbmNlbGxlZERhdGVSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHVlRGF0ZU1hdGNoID0gbGluZS5tYXRjaChUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmR1ZURhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoZHVlRGF0ZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZHVlRGF0ZSA9IHdpbmRvdy5tb21lbnQoZHVlRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5kdWVEYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlbWluZGVyRGF0ZVRpbWVNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5yZW1pbmRlckRhdGVUaW1lUmVnZXgpO1xuICAgICAgICAgICAgY29uc3QgcmVtaW5kZXJEYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMucmVtaW5kZXJEYXRlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHJlbWluZGVyRGF0ZVRpbWVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbWluZGVyRGF0ZSA9IHdpbmRvdy5tb21lbnQocmVtaW5kZXJEYXRlVGltZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVUaW1lRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMucmVtaW5kZXJEYXRlVGltZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1pbmRlckRhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbWluZGVyRGF0ZSA9IHdpbmRvdy5tb21lbnQocmVtaW5kZXJEYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLnJlbWluZGVyRGF0ZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZWREYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuc2NoZWR1bGVkRGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWREYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gd2luZG93Lm1vbWVudChzY2hlZHVsZWREYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLnNjaGVkdWxlZERhdGVSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhcnREYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuc3RhcnREYXRlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlID0gd2luZG93Lm1vbWVudChzdGFydERhdGVNYXRjaFsxXSwgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuc3RhcnREYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWREYXRlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuY3JlYXRlZERhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZERhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWREYXRlID0gd2luZG93Lm1vbWVudChjcmVhdGVkRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5jcmVhdGVkRGF0ZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZWN1cnJlbmNlTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMucmVjdXJyZW5jZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChyZWN1cnJlbmNlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSByZWN1cnJlbmNlIHJ1bGUsIGJ1dCAqZG8gbm90IHBhcnNlIGl0IHlldCouXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIFJlY3VycmVuY2Ugb2JqZWN0IHJlcXVpcmVzIGEgcmVmZXJlbmNlIGRhdGUgKGUuZy4gYSBkdWUgZGF0ZSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IG1pZ2h0IGFwcGVhciBpbiB0aGUgbmV4dCAoZWFybGllciBpbiB0aGUgbGluZSkgdG9rZW5zIHRvIHBhcnNlXG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZVJ1bGUgPSByZWN1cnJlbmNlTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5yZWN1cnJlbmNlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIHRhZ3MgZnJvbSB0aGUgZW5kIHRvIGFsbG93IHVzZXJzIHRvIG1peCB0aGUgdmFyaW91cyB0YXNrIGNvbXBvbmVudHMgd2l0aFxuICAgICAgICAgICAgLy8gdGFncy4gVGhlc2UgdGFncyB3aWxsIGJlIGFkZGVkIGJhY2sgdG8gdGhlIGRlc2NyaXB0aW9uIGJlbG93XG4gICAgICAgICAgICBjb25zdCB0YWdzTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaGFzaFRhZ3NGcm9tRW5kKTtcbiAgICAgICAgICAgIGlmICh0YWdzTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5oYXNoVGFnc0Zyb21FbmQsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhZ3NNYXRjaFswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSBsZWZ0IGJlY2F1c2UgdGhlIG1hdGNoaW5nIGlzIGRvbmUgcmlnaHQtdG8tbGVmdFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nVGFncyA9IHRyYWlsaW5nVGFncy5sZW5ndGggPiAwID8gW3RhZ05hbWUsIHRyYWlsaW5nVGFnc10uam9pbignICcpIDogdGFnTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaWRNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5pZFJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGlkTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5pZFJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlkID0gaWRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlcGVuZHNPbk1hdGNoID0gbGluZS5tYXRjaChUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmRlcGVuZHNPblJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGRlcGVuZHNPbk1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuZGVwZW5kc09uUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgZGVwZW5kc09uID0gZGVwZW5kc09uTWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09ICcnKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVucysrO1xuICAgICAgICB9IHdoaWxlIChtYXRjaGVkICYmIHJ1bnMgPD0gbWF4UnVucyk7XG5cbiAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhbGwgdGhlIHRhc2sgZGV0YWlscywgcGFyc2UgdGhlIHJlY3VycmVuY2UgcnVsZSBpZiB3ZSBmb3VuZCBhbnlcbiAgICAgICAgaWYgKHJlY3VycmVuY2VSdWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlY3VycmVuY2UgPSBSZWN1cnJlbmNlLmZyb21UZXh0KHtcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IHJlY3VycmVuY2VSdWxlLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICAgICAgcmVtaW5kZXJEYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGJhY2sgYW55IHRyYWlsaW5nIHRhZ3MgdG8gdGhlIGRlc2NyaXB0aW9uLiBXZSByZW1vdmVkIHRoZW0gc28gd2UgY2FuIHBhcnNlIHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIGJ1dCBub3cgd2Ugd2FudCB0aGVtIGJhY2suXG4gICAgICAgIC8vIFRoZSBnb2FsIGlzIGZvciBhIHRhc2sgb2YgdGhlbSBmb3JtICdEbyBzb21ldGhpbmcgI3RhZzEgKGR1ZSkgdG9tb3Jyb3cgI3RhZzIgKHN0YXJ0KSB0b2RheSdcbiAgICAgICAgLy8gdG8gYWN0dWFsbHkgaGF2ZSB0aGUgZGVzY3JpcHRpb24gJ0RvIHNvbWV0aGluZyAjdGFnMSAjdGFnMidcbiAgICAgICAgaWYgKHRyYWlsaW5nVGFncy5sZW5ndGggPiAwKSBsaW5lICs9ICcgJyArIHRyYWlsaW5nVGFncztcblxuICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbGluZSxcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgY3JlYXRlZERhdGUsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIHJlbWluZGVyRGF0ZSxcbiAgICAgICAgICAgIGRvbmVEYXRlLFxuICAgICAgICAgICAgY2FuY2VsbGVkRGF0ZSxcbiAgICAgICAgICAgIHJlY3VycmVuY2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRlcGVuZHNPbixcbiAgICAgICAgICAgIHRhZ3M6IFRhc2suZXh0cmFjdEhhc2h0YWdzKGxpbmUpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlSWQoZXhpc3RpbmdJZHM6IHN0cmluZ1tdKSB7XG4gICAgbGV0IGlkID0gJyc7XG4gICAgbGV0IGtlZXBHZW5lcmF0aW5nID0gdHJ1ZTtcblxuICAgIHdoaWxlIChrZWVwR2VuZXJhdGluZykge1xuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vd3d3LmNvZGVtenkuY29tL2Jsb2cvcmFuZG9tLXVuaXF1ZS1pZC1qYXZhc2NyaXB0XG4gICAgICAgIGlkID0gTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgICAgICAgLnN1YnN0cmluZygyLCA2ICsgMik7XG5cbiAgICAgICAgaWYgKCFleGlzdGluZ0lkcy5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgIGtlZXBHZW5lcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVGFza0hhc0lkKGNoaWxkOiBUYXNrLCBleGlzdGluZ0lkczogc3RyaW5nW10pIHtcbiAgICBpZiAoY2hpbGQuaWQgIT09ICcnKSByZXR1cm4gY2hpbGQ7XG5cbiAgICByZXR1cm4gbmV3IFRhc2soeyAuLi5jaGlsZCwgaWQ6IGdlbmVyYXRlVW5pcXVlSWQoZXhpc3RpbmdJZHMpIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVwZW5kZW5jaWVzT25UYXNrc1dpdGhJZHMocGFyZW50OiBUYXNrLCBjaGlsZHJlbldpdGhJZHM6IFRhc2tbXSk6IFRhc2sge1xuICAgIGNvbnN0IG5ld0RlcGVuZHNPbiA9IGNoaWxkcmVuV2l0aElkcy5tYXAoKHRhc2spID0+IHtcbiAgICAgICAgcmV0dXJuIHRhc2suaWQ7XG4gICAgfSk7XG4gICAgbGV0IG5ld1BhcmVudCA9IHBhcmVudDtcbiAgICBpZiAocGFyZW50LmRlcGVuZHNPbi50b1N0cmluZygpICE9PSBuZXdEZXBlbmRzT24udG9TdHJpbmcoKSkge1xuICAgICAgICBuZXdQYXJlbnQgPSBuZXcgVGFzayh7IC4uLnBhcmVudCwgZGVwZW5kc09uOiBuZXdEZXBlbmRzT24gfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhcmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERlcGVuZGVuY3lUb1BhcmVudChwYXJlbnQ6IFRhc2ssIGNoaWxkOiBUYXNrKSB7XG4gICAgbGV0IG5ld1BhcmVudCA9IHBhcmVudDtcbiAgICBpZiAoIXBhcmVudC5kZXBlbmRzT24uaW5jbHVkZXMoY2hpbGQuaWQpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RlcGVuZHNPbiA9IFsuLi5wYXJlbnQuZGVwZW5kc09uLCBjaGlsZC5pZF07XG4gICAgICAgIG5ld1BhcmVudCA9IG5ldyBUYXNrKHsgLi4ucGFyZW50LCBkZXBlbmRzT246IG5ld0RlcGVuZHNPbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BhcmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERlcGVuZGVuY3kocGFyZW50OiBUYXNrLCBjaGlsZDogVGFzaywgZXhpc3RpbmdJZHM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgbmV3Q2hpbGQgPSBlbnN1cmVUYXNrSGFzSWQoY2hpbGQsIGV4aXN0aW5nSWRzKTtcblxuICAgIHJldHVybiBbYWRkRGVwZW5kZW5jeVRvUGFyZW50KHBhcmVudCwgbmV3Q2hpbGQpLCBuZXdDaGlsZF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEZXBlbmRlbmN5KHBhcmVudDogVGFzaywgY2hpbGQ6IFRhc2spIHtcbiAgICBsZXQgbmV3UGFyZW50ID0gcGFyZW50O1xuICAgIGlmIChwYXJlbnQuZGVwZW5kc09uLmluY2x1ZGVzKGNoaWxkLmlkKSkge1xuICAgICAgICBjb25zdCBuZXdEZXBlbmRzT24gPSBwYXJlbnQuZGVwZW5kc09uLmZpbHRlcigoZGVwZW5kc09uKSA9PiBkZXBlbmRzT24gIT09IGNoaWxkLmlkKTtcbiAgICAgICAgbmV3UGFyZW50ID0gbmV3IFRhc2soeyAuLi5wYXJlbnQsIGRlcGVuZHNPbjogbmV3RGVwZW5kc09uIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQYXJlbnQ7XG59XG4iLCAiLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgYXMgcGFydCBvZiBhIFJlZ0V4cCBsaXRlcmFsbHkuXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucyNlc2NhcGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHM6IHN0cmluZykge1xuICAgIC8vIE5PVEU6ID0gaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXD13b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vIE5PVEU6ICEgaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXCF3b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vIE5PVEU6IDogaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXDp3b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vXG4gICAgLy8gRXhwbGFuYXRpb24gZnJvbSBAQW5uYUtvcm5mZWxkU2ltcHNvbiBpbjpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXNtNy9vYnNpZGlhbi10YXNrcy9wdWxsLzE4I2lzc3VlY29tbWVudC0xMTk2MTE1NDA3XG4gICAgLy8gRnJvbSB3aGF0IEkgY2FuIHRlbGwsIHRoZSB0aHJlZSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSB0aGUgb3JpZ2luYWwgcmVnZXggLSA6ICEgPVxuICAgIC8vIGFyZSBhbGwgb25seSBjb25zaWRlcmVkIHRvIGhhdmUgc3BlY2lhbCBtZWFuaW5ncyBpZiB0aGV5IGRpcmVjdGx5IGZvbGxvd1xuICAgIC8vIGEgPyAoYWxsIDMpIG9yIGEgPzwgKCEgYW5kID0pLlxuICAgIC8vIFNvIHRoZW9yZXRpY2FsbHkgaWYgdGhlID8gYXJlIGFsbCBlc2NhcGVkLCB0aG9zZSB0aHJlZSBjaGFyYWN0ZXJzIGRvIG5vdCBoYXZlIHRvIGJlLlxuICAgIHJldHVybiBzLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxdL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgdGhhdCB0d28gcmVndWxhciBleHByZXNzaW9ucyBhcmUgZXhhY3RseSBpZGVudGljYWwuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiByZWZhY3RvcmluZyByZWd1bGFyIGV4cHJlc3Npb25zLCB0byBhdm9pZCBhY2NpZGVudGFsIGRpZmZlcmVuY2VzLlxuICogSXQgcmVwb3J0cyBhbnkgZGlmZmVyZW5jZXMgYnkgdGhyb3dpbmcgRXJyb3IuXG5cbiAqIEFzIGlzIGludGVuZGVkIG9ubHkgZHVyaW5nIGRldmVsb3BtZW50LCB1cG9uIGVycm9yIGl0IGFsc28gbG9ncyB0byB0aGUgY29uc29sZSxcbiAqIGZvciBlYXNlIG9mIGZpbmRpbmcgYW55IGVycm9ycy5cbiAqXG4gKiBAcGFyYW0gcmVnZXhwMVxuICogQHBhcmFtIHJlZ2V4cDJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVnRXhwc0lkZW50aWNhbChyZWdleHAxOiBSZWdFeHAsIHJlZ2V4cDI6IFJlZ0V4cCkge1xuICAgIGlmIChyZWdleHAxLnRvU3RyaW5nKCkgIT09IHJlZ2V4cDIudG9TdHJpbmcoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhyZWdleHAxLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhyZWdleHAyLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlZ3VsYXIgZXhwcmVzc2lvbnMgZGlmZmVyOlxuJHtyZWdleHAxLnRvU3RyaW5nKCl9XG4ke3JlZ2V4cDIudG9TdHJpbmcoKX1cbmApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsICJpbXBvcnQgKiBhcyBSZWdFeHBUb29scyBmcm9tICcuLi9saWIvUmVnRXhwVG9vbHMnO1xuXG4vKipcbiAqIEdsb2JhbEZpbHRlciBoYXMgaXRzIG93biBkYXRhLCBpbmRlcGVuZGVudCBvZiB7QGxpbmsgU2V0dGluZ3MuZ2xvYmFsRmlsdGVyfSB2YWx1ZSBpbiB7QGxpbmsgU2V0dGluZ3N9LlxuICpcbiAqIFNlZSBodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0dsb2JhbCtGaWx0ZXJcbiAqXG4gKiBMaW1pdGF0aW9uczpcbiAqIC0gQWxsIG1ldGhvZHMgYXJlIHN0YXRpYywgc28gaXQgaXMgYSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIHN0YXRpYyB0aGluZ3NcbiAqICAgICAtIFRoaXMgaXMgaW4gY29udHJhc3QgdG8ge0BsaW5rIEdsb2JhbFF1ZXJ5fSB3aGF0IGhhcyBqdXN0IHRoZSBvbmUgc3RhdGljIG1ldGhvZCwge0BsaW5rIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlfS5cbiAqICAgICAtIFRoZXNlIHN0YXRpYyBtZXRob2RzIHdpbGwgYmUgbWFkZSBub24tc3RhdGljIGluIGEgZnV0dXJlIGNoYW5nZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEdsb2JhbEZpbHRlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdsb2JhbEZpbHRlcjtcblxuICAgIHN0YXRpYyBlbXB0eSA9ICcnO1xuICAgIHByaXZhdGUgX2dsb2JhbEZpbHRlciA9ICcnO1xuICAgIHByaXZhdGUgX3JlbW92ZUdsb2JhbEZpbHRlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBzaW5nbGUgZ2xvYmFsIGluc3RhbmNlIG9mIEdsb2JhbEZpbHRlci5cbiAgICAgKiBUaGlzIHNob3VsZCBldmVudHVhbGx5IG9ubHkgYmUgdXNlZCBpbiB0aGUgcGx1Z2luIGNvZGUuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBHbG9iYWxGaWx0ZXIge1xuICAgICAgICBpZiAoIUdsb2JhbEZpbHRlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgR2xvYmFsRmlsdGVyLmluc3RhbmNlID0gbmV3IEdsb2JhbEZpbHRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEdsb2JhbEZpbHRlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxGaWx0ZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbEZpbHRlciA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zZXQoR2xvYmFsRmlsdGVyLmVtcHR5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCkgPT09IEdsb2JhbEZpbHRlci5lbXB0eTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXF1YWxzKHRhZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgpID09PSB0YWc7XG4gICAgfVxuXG4gICAgcHVibGljIGluY2x1ZGVkSW4oZGVzY3JpcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBnbG9iYWxGaWx0ZXIgPSB0aGlzLmdldCgpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uaW5jbHVkZXMoZ2xvYmFsRmlsdGVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcHJlcGVuZFRvKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoKSArICcgJyArIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVBc1dvcmRGcm9tRGVwZW5kaW5nT25TZXR0aW5ncyhkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlR2xvYmFsRmlsdGVyID0gdGhpcy5nZXRSZW1vdmVHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgaWYgKHJlbW92ZUdsb2JhbEZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXNXb3JkRnJvbShkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBzZXRSZW1vdmVHbG9iYWxGaWx0ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmVtb3ZlR2xvYmFsRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlR2xvYmFsRmlsdGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgZ2V0UmVtb3ZlR2xvYmFsRmlsdGVyXG4gICAgICovXG4gICAgcHVibGljIHNldFJlbW92ZUdsb2JhbEZpbHRlcihyZW1vdmVHbG9iYWxGaWx0ZXI6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlR2xvYmFsRmlsdGVyID0gcmVtb3ZlR2xvYmFsRmlsdGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgZm9yIHRoZSBwdXJwb3NlIG9mIHJlbW92aW5nIGl0IGZyb20gdGhlIGRlc2NyaXB0aW9uLCBidXQgZG8gc28gb25seVxuICAgICAqIGlmIGl0IGlzIGEgc2VwYXJhdGUgd29yZCAocHJlY2VkaW5nIHRoZSBiZWdpbm5pbmcgb2YgbGluZSBvciBhIHNwYWNlIGFuZCBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIGxpbmVcbiAgICAgKiBvciBhIHNwYWNlKSwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGN1dC1vZmYgbmVzdGVkIHRhZ3MgbGlrZSAjdGFzay9zdWJ0YWcuXG4gICAgICogSWYgdGhlIGdsb2JhbCBmaWx0ZXIgZXhpc3RzIGFzIHBhcnQgb2YgYSBuZXN0ZWQgdGFnLCB3ZSBrZWVwIGl0IHVudG91Y2hlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlQXNXb3JkRnJvbShkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIGdsb2JhbCBmaWx0ZXIgKGFmdGVyIGVzY2FwaW5nIGl0KSBvbmx5IHdoZW4gaXQncyBhIGNvbXBsZXRlIHdvcmRcbiAgICAgICAgY29uc3QgdGhlUmVnRXhwID0gUmVnRXhwKCcoXnxcXFxccyknICsgUmVnRXhwVG9vbHMuZXNjYXBlUmVnRXhwKHRoaXMuZ2V0KCkpICsgJygkfFxcXFxzKScsICd1ZycpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi5zZWFyY2godGhlUmVnRXhwKSA+IC0xKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnJlcGxhY2UodGhlUmVnRXhwLCAnJDEkMicpLnJlcGxhY2UoJyAgJywgJyAnKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUFzU3Vic3RyaW5nRnJvbShkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsRmlsdGVyID0gdGhpcy5nZXQoKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLnJlcGxhY2UoZ2xvYmFsRmlsdGVyLCAnJykudHJpbSgpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyB0eXBlIEZ1enp5TWF0Y2gsIHByZXBhcmVTaW1wbGVTZWFyY2ggfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5cbmNvbnN0IE1BWF9TRUFSQ0hfUkVTVUxUUyA9IDIwO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdGV4dCB0byB1c2UgZm9yIHNlYXJjaGluZyBhbmQgZGlzcGxheWluZyB0YXNrcywgZm9yIHRoZSBkZXBlbmRlbmN5IGZpZWxkcy5cbiAqXG4gKiBUaGUgZ2xvYmFsIGZpbHRlciBpcyByZW1vdmVkLCBidXQgc3ViLXRhZ3Mgb2YgdGhlIGdsb2JhbCBmaWx0ZXIgYXJlXG4gKiBub3QgcmVtb3ZlZC5cbiAqIEBwYXJhbSB0YXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmlwdGlvbkFkanVzdGVkRm9yRGVwZW5kZW5jeVNlYXJjaCh0YXNrOiBUYXNrKSB7XG4gICAgcmV0dXJuIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnJlbW92ZUFzV29yZEZyb20odGFzay5kZXNjcmlwdGlvbik7XG59XG5cbmZ1bmN0aW9uIHNlYXJjaERlc2NyaXB0aW9uV2l0aG91dFRhZ3MocXVlcnk6IHN0cmluZywgYWxsVGFza3M6IFRhc2tbXSk6IFRhc2tbXSB7XG4gICAgaWYgKHF1ZXJ5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gYWxsVGFza3M7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlcGFyZWRTZWFyY2ggPSBwcmVwYXJlU2ltcGxlU2VhcmNoKHF1ZXJ5KTtcblxuICAgIC8vIFRoZSBjdXRvZmYgd2FzIGNob3NlbiBlbXBpcmljYWxseSwgdG8gZmlsdGVyIG91dCB2ZXJ5IHBvb3IgbWF0Y2hlczpcbiAgICBjb25zdCBtaW5pbXVtU2NvcmVDdXRvZmYgPSAtNC4wO1xuXG4gICAgY29uc3QgbWF0Y2hlczogRnV6enlNYXRjaDxUYXNrPltdID0gYWxsVGFza3NcbiAgICAgICAgLm1hcCgodGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJlcGFyZWRTZWFyY2goZGVzY3JpcHRpb25BZGp1c3RlZEZvckRlcGVuZGVuY3lTZWFyY2godGFzaykpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc2NvcmUgPiBtaW5pbXVtU2NvcmVDdXRvZmYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBGdXp6eU1hdGNoPFRhc2s+W107XG5cbiAgICAvLyBBbGwgc2NvcmVzIGFyZSBuZWdhdGl2ZS4gQ2xvc2VyIHRvIHplcm8gaXMgYmV0dGVyLlxuICAgIGNvbnN0IHNvcnRlZE1hdGNoZXMgPSBtYXRjaGVzLnNvcnQoKGEsIGIpID0+IGIubWF0Y2guc2NvcmUgLSBhLm1hdGNoLnNjb3JlKTtcblxuICAgIC8vIFJldGFpbiBjb21tZW50ZWQtb3V0IGxvZ2dpbmcgdW50aWwgY29uZmlkZW50IGluIHRoZSBtaW5pbXVtU2NvcmVDdXRvZmYgdmFsdWUuXG4gICAgLy8gY29uc29sZS5sb2coJz4+Pj4+Pj4+Pj4gc3RhcnQgb2YgbWF0Y2hlcycpO1xuICAgIC8vIHNvcnRlZE1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAvLyAgICAgY29uc29sZS5sb2coYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gubWF0Y2gpfTogJHtkZXNjcmlwdGlvbkFkanVzdGVkRm9yRGVwZW5kZW5jeVNlYXJjaChtYXRjaC5pdGVtKX1gKTtcbiAgICAvLyB9KTtcbiAgICAvLyBjb25zb2xlLmxvZygnPDw8PDw8PDw8PCBlbmQgb2YgbWF0Y2hlcycpO1xuXG4gICAgcmV0dXJuIHNvcnRlZE1hdGNoZXMubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoRm9yQ2FuZGlkYXRlVGFza3NGb3JEZXBlbmRlbmN5KFxuICAgIHNlYXJjaDogc3RyaW5nLFxuICAgIGFsbFRhc2tzOiBUYXNrW10sXG4gICAgdGFzaz86IFRhc2ssXG4gICAgYmxvY2tlZEJ5PzogVGFza1tdLFxuICAgIGJsb2NraW5nPzogVGFza1tdLFxuKSB7XG4gICAgbGV0IHJlc3VsdHMgPSBzZWFyY2hEZXNjcmlwdGlvbldpdGhvdXRUYWdzKHNlYXJjaCwgYWxsVGFza3MpO1xuXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIC8vIERvIG5vdCBvZmZlciB0byBkZXBlbmQgb24gRE9ORSwgQ0FOQ0VMTEVEIG9yIE5PTl9UQVNLIHRhc2tzOlxuICAgICAgICBpZiAoaXRlbS5pc0RvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBzaG93IGFueSB0YXNrcyB0aGF0IGxvb2sgbGlrZSB0ZW1wbGF0ZXM6XG4gICAgICAgIGlmIChpdGVtLmRlc2NyaXB0aW9uLmluY2x1ZGVzKCc8JScpICYmIGl0ZW0uZGVzY3JpcHRpb24uaW5jbHVkZXMoJyU+JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBpdHNlbGYgZnJvbSByZXN1bHRzXG4gICAgICAgIC8vIEtub3duIGlzc3VlIC0gZmlsdGVycyBvdXQgZHVwbGljYXRlIGxpbmVzIGluIHRhc2sgZmlsZVxuICAgICAgICBjb25zdCBzYW1lVGFzayA9XG4gICAgICAgICAgICBpdGVtLmRlc2NyaXB0aW9uID09PSB0YXNrPy5kZXNjcmlwdGlvbiAmJlxuICAgICAgICAgICAgaXRlbS50YXNrTG9jYXRpb24ucGF0aCA9PT0gdGFzaz8udGFza0xvY2F0aW9uLnBhdGggJiZcbiAgICAgICAgICAgIGl0ZW0ub3JpZ2luYWxNYXJrZG93biA9PT0gdGFzaz8ub3JpZ2luYWxNYXJrZG93bjtcbiAgICAgICAgaWYgKHNhbWVUYXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbW92ZSB0YXNrcyB0aGlzIHRhc2sgYWxyZWFkeSBoYXMgYSByZWxhdGlvbnNoaXAgd2l0aCBmcm9tIHJlc3VsdHNcbiAgICAgICAgaWYgKGJsb2NrZWRCeT8uaW5jbHVkZXMoaXRlbSkgfHwgYmxvY2tpbmc/LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGlmIGEgdGFzayBpcyBwcm92aWRlZCwgc2hvdyBjbG9zZSBSZWxhdGlvbnMgaGlnaGVyXG4gICAgaWYgKHRhc2spIHtcbiAgICAgICAgLy8gc2VhcmNoIHJlc3VsdHMgZmF2b3VyIHRhc2tzIGZyb20gdGhlIHNhbWUgZmlsZSBhcyB0aGlzIHRhc2tcbiAgICAgICAgcmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhSW5TYW1lUGF0aCA9IGEudGFza0xvY2F0aW9uLnBhdGggPT09IHRhc2sudGFza0xvY2F0aW9uLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBiSW5TYW1lUGF0aCA9IGIudGFza0xvY2F0aW9uLnBhdGggPT09IHRhc2sudGFza0xvY2F0aW9uLnBhdGg7XG5cbiAgICAgICAgICAgIC8vIHByaW9yaXRpc2UgdGFza3MgY2xvc2UgdG8gdGhpcyB0YXNrIGluIHRoZSBzYW1lIGZpbGVcbiAgICAgICAgICAgIGlmIChhSW5TYW1lUGF0aCAmJiBiSW5TYW1lUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGEudGFza0xvY2F0aW9uLmxpbmVOdW1iZXIgLSB0YXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyKSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGIudGFza0xvY2F0aW9uLmxpbmVOdW1iZXIgLSB0YXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFJblNhbWVQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiSW5TYW1lUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuc2xpY2UoMCwgTUFYX1NFQVJDSF9SRVNVTFRTKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvciwgRWRpdG9yUG9zaXRpb24gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IERhdGVQYXJzZXIgfSBmcm9tICcuLi9RdWVyeS9EYXRlUGFyc2VyJztcbmltcG9ydCB7IGRvQXV0b2NvbXBsZXRlIH0gZnJvbSAnLi4vbGliL0RhdGVBYmJyZXZpYXRpb25zJztcbmltcG9ydCB7IFJlY3VycmVuY2UgfSBmcm9tICcuLi9UYXNrL1JlY3VycmVuY2UnO1xuaW1wb3J0IHsgdHlwZSBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzLCB0YXNrSWRSZWdleCB9IGZyb20gJy4uL1Rhc2tTZXJpYWxpemVyL0RlZmF1bHRUYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IGdlbmVyYXRlVW5pcXVlSWQgfSBmcm9tICcuLi9UYXNrL1Rhc2tEZXBlbmRlbmN5JztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4uL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgVGFza1JlZ3VsYXJFeHByZXNzaW9ucyB9IGZyb20gJy4uL1Rhc2svVGFza1JlZ3VsYXJFeHByZXNzaW9ucyc7XG5pbXBvcnQgeyBzZWFyY2hGb3JDYW5kaWRhdGVUYXNrc0ZvckRlcGVuZGVuY3kgfSBmcm9tICcuLi91aS9EZXBlbmRlbmN5SGVscGVycyc7XG5pbXBvcnQgdHlwZSB7IFN1Z2dlc3RJbmZvLCBTdWdnZXN0aW9uQnVpbGRlciB9IGZyb20gJy4nO1xuXG4vKipcbiAqIFJlY29tbWVuZGVkIGRlZmF1bHQgdmFsdWUgdG8gcGFzcyBpbiB0byB7QGxpbmsgbWFrZURlZmF1bHRTdWdnZXN0aW9uQnVpbGRlcn0gbWF4R2VuZXJpY1N1Z2dlc3Rpb25zIHBhcmFtZXRlclxuICogZm9yIHByb2R1Y3Rpb24gY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0dFTkVSSUNfU1VHR0VTVElPTlMgPSA1O1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgIHZhciBTSE9XX0RFUEVOREVOQ1lfU1VHR0VTVElPTlM6IGJvb2xlYW47XG59XG5cbi8vIFNldCBkZWZhdWx0IHZhbHVlIGZvciBwcm9kdWN0aW9uIHRvIG9mZiwgdGVtcG9yYXJpbHkuIEl0IHdpbGwgYmUgdHVybmVkIG9uIGluIHRlc3RzLlxuZXhwb3J0IGNvbnN0IHNob3dEZXBlbmRlbmN5U3VnZ2VzdGlvbnNEZWZhdWx0ID0gZmFsc2U7XG5nbG9iYWxUaGlzLlNIT1dfREVQRU5ERU5DWV9TVUdHRVNUSU9OUyA9IHNob3dEZXBlbmRlbmN5U3VnZ2VzdGlvbnNEZWZhdWx0O1xuXG5leHBvcnQgZnVuY3Rpb24gbWFrZURlZmF1bHRTdWdnZXN0aW9uQnVpbGRlcihcbiAgICBzeW1ib2xzOiBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzLFxuICAgIG1heEdlbmVyaWNTdWdnZXN0aW9uczogbnVtYmVyIC8qKiBTZWUge0BsaW5rIERFRkFVTFRfTUFYX0dFTkVSSUNfU1VHR0VTVElPTlN9ICovLFxuICAgIGRhdGF2aWV3TW9kZTogYm9vbGVhbixcbik6IFN1Z2dlc3Rpb25CdWlsZGVyIHtcbiAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgY29uc3QgZGF0ZVByZWZpeFJlZ2V4ID0gW1xuICAgICAgICBzeW1ib2xzLnN0YXJ0RGF0ZVN5bWJvbCxcbiAgICAgICAgc3ltYm9scy5zY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICBzeW1ib2xzLmR1ZURhdGVTeW1ib2wsXG4gICAgICAgIHN5bWJvbHMucmVtaW5kZXJEYXRlU3ltYm9sLFxuICAgIF0uam9pbignfCcpO1xuICAgIC8qXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiBzdWdnZXN0aW9ucywgZWl0aGVyIGdlbmVyaWMgb3IgbW9yZSBmaW5lLWdyYWluZWQgdG8gdGhlIHdvcmRzIGF0IHRoZSBjdXJzb3IuXG4gICAgICovXG4gICAgcmV0dXJuIChcbiAgICAgICAgbGluZTogc3RyaW5nLFxuICAgICAgICBjdXJzb3JQb3M6IG51bWJlcixcbiAgICAgICAgc2V0dGluZ3M6IFNldHRpbmdzLFxuICAgICAgICBhbGxUYXNrczogVGFza1tdLFxuICAgICAgICB0YXNrVG9TdWdnZXN0Rm9yPzogVGFzayxcbiAgICApOiBTdWdnZXN0SW5mb1tdID0+IHtcbiAgICAgICAgbGV0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gW107XG5cbiAgICAgICAgLy8gYWRkIGRhdGUgc3VnZ2VzdGlvbnMgaWYgcmVsZXZhbnRcbiAgICAgICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucy5jb25jYXQoXG4gICAgICAgICAgICBhZGREYXRlc1N1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MsIGRhdGVQcmVmaXhSZWdleCwgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zLCBkYXRhdmlld01vZGUpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGFkZCByZWN1cnJlbmNlIHN1Z2dlc3Rpb25zIGlmIHJlbGV2YW50XG4gICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KFxuICAgICAgICAgICAgYWRkUmVjdXJyZW5jZVN1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MsIHN5bWJvbHMucmVjdXJyZW5jZVN5bWJvbCwgZGF0YXZpZXdNb2RlKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgQXV0byBJRCBzdWdnZXN0aW9uc1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5TSE9XX0RFUEVOREVOQ1lfU1VHR0VTVElPTlMpIHtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KGFkZElEU3VnZ2VzdGlvbihsaW5lLCBjdXJzb3JQb3MsIHN5bWJvbHMuaWRTeW1ib2wsIGFsbFRhc2tzKSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBkZXBlbmRlY3kgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KFxuICAgICAgICAgICAgICAgIGFkZERlcGVuZHNPblN1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MsIHN5bWJvbHMuZGVwZW5kc09uU3ltYm9sLCBhbGxUYXNrcywgdGFza1RvU3VnZ2VzdEZvciksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRhc2sgcHJvcGVydHkgc3VnZ2VzdGlvbnMgKCdkdWUnLCAncmVjdXJyZW5jZScgZXRjKVxuICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChhZGRUYXNrUHJvcGVydHlTdWdnZXN0aW9ucyhsaW5lLCBjdXJzb3JQb3MsIHNldHRpbmdzLCBzeW1ib2xzLCBkYXRhdmlld01vZGUpKTtcblxuICAgICAgICAvLyBVbmxlc3Mgd2UgaGF2ZSBhIHN1Z2dlc3Rpb24gdGhhdCBpcyBhIG1hdGNoIGZvciBzb21ldGhpbmcgdGhlIHVzZXIgaXMgY3VycmVudGx5IHR5cGluZywgYWRkXG4gICAgICAgIC8vIGFuICdFbnRlcicgZW50cnkgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgbWVudSwgc28gYW4gRW50ZXIgcHJlc3Mgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gaW5zZXJ0IGEgc3VnZ2VzdGlvblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCAmJiAhc3VnZ2VzdGlvbnMuc29tZSgodmFsdWUpID0+IHZhbHVlLnN1Z2dlc3Rpb25UeXBlID09PSAnbWF0Y2gnKSkge1xuICAgICAgICAgICAgLy8gTm8gYWN0dWFsIG1hdGNoLCBvbmx5IGRlZmF1bHQgb25lc1xuICAgICAgICAgICAgaWYgKCFkYXRhdmlld01vZGUpIHtcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdlbXB0eScsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiAnXHUyM0NFJyxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogJ1xcbicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFaXRoZXIgd2F5LCBhZnRlciBhbGwgdGhlIGFnZ3JlZ2F0aW9ucyBhYm92ZSwgbmV2ZXIgc3VnZ2VzdCBtb3JlIHRoYW4gdGhlIG1heCBpdGVtc1xuICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLnNsaWNlKDAsIHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMpO1xuXG4gICAgICAgIHJldHVybiBzdWdnZXN0aW9ucztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBZGp1c3RlcnMoZGF0YXZpZXdNb2RlOiBib29sZWFuLCBsaW5lOiBzdHJpbmcsIGN1cnNvclBvczogbnVtYmVyKSB7XG4gICAgY29uc3QgY2xvc2luZ0JyYWNrZXQgPVxuICAgICAgICBsYXN0T3BlbkJyYWNrZXQobGluZS5zdWJzdHJpbmcoMCwgY3Vyc29yUG9zKSwgW1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGFycmF5IGR1cGxpY2F0ZXMgY29kZSBpbiBTZXR0aW5ncy50cy4gQ2FuIHdlIGludHJvZHVjZSBhbiBhYnN0cmFjdGlvbiBmb3IgdGhpcz9cbiAgICAgICAgICAgIFsnKCcsICcpJ10sXG4gICAgICAgICAgICBbJ1snLCAnXSddLFxuICAgICAgICBdKSA9PSAnKCdcbiAgICAgICAgICAgID8gJyknXG4gICAgICAgICAgICA6ICddJztcbiAgICBjb25zdCBwb3N0Zml4ID0gZGF0YXZpZXdNb2RlID8gY2xvc2luZ0JyYWNrZXQgKyAnICcgOiAnICc7XG4gICAgY29uc3QgaW5zZXJ0U2tpcCA9IGRhdGF2aWV3TW9kZSAmJiBsaW5lLmxlbmd0aCA+IGN1cnNvclBvcyAmJiBsaW5lLmNoYXJBdChjdXJzb3JQb3MpID09PSBjbG9zaW5nQnJhY2tldCA/IDEgOiAwO1xuICAgIHJldHVybiB7IHBvc3RmaXgsIGluc2VydFNraXAgfTtcbn1cblxuLypcbiAqIEdldCBzdWdnZXN0aW9ucyBmb3IgZ2VuZXJpYyB0YXNrIGNvbXBvbmVudHMsIGUuZy4gYSBwcmlvcml0eSBvciBhICdkdWUnIHN5bWJvbFxuICovXG5mdW5jdGlvbiBhZGRUYXNrUHJvcGVydHlTdWdnZXN0aW9ucyhcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgY3Vyc29yUG9zOiBudW1iZXIsXG4gICAgX3NldHRpbmdzOiBTZXR0aW5ncyxcbiAgICBzeW1ib2xzOiBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzLFxuICAgIGRhdGF2aWV3TW9kZTogYm9vbGVhbixcbik6IFN1Z2dlc3RJbmZvW10ge1xuICAgIGNvbnN0IGhhc1ByaW9yaXR5ID0gKGxpbmU6IHN0cmluZykgPT5cbiAgICAgICAgT2JqZWN0LnZhbHVlcyhzeW1ib2xzLnByaW9yaXR5U3ltYm9scykuc29tZSgodmFsdWUpID0+IHZhbHVlLmxlbmd0aCA+IDAgJiYgbGluZS5pbmNsdWRlcyh2YWx1ZSkpO1xuXG4gICAgY29uc3QgZ2VuZXJpY1N1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gW107XG4gICAgY29uc3QgeyBwb3N0Zml4LCBpbnNlcnRTa2lwIH0gPSBnZXRBZGp1c3RlcnMoZGF0YXZpZXdNb2RlLCBsaW5lLCBjdXJzb3JQb3MpO1xuXG4gICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLmR1ZURhdGVTeW1ib2wpKVxuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5kdWVEYXRlU3ltYm9sfSBkdWUgZGF0ZWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLmR1ZURhdGVTeW1ib2x9IGAsXG4gICAgICAgIH0pO1xuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLnJlbWluZGVyRGF0ZVN5bWJvbCkpXG4gICAgICAgIGdlbmVyaWNTdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtzeW1ib2xzLnJlbWluZGVyRGF0ZVN5bWJvbH0gcmVtaW5kZXIgZGF0ZWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLnJlbWluZGVyRGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFsaW5lLmluY2x1ZGVzKHN5bWJvbHMuc3RhcnREYXRlU3ltYm9sKSlcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMuc3RhcnREYXRlU3ltYm9sfSBzdGFydCBkYXRlYCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMuc3RhcnREYXRlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcbiAgICBpZiAoIWxpbmUuaW5jbHVkZXMoc3ltYm9scy5zY2hlZHVsZWREYXRlU3ltYm9sKSlcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMuc2NoZWR1bGVkRGF0ZVN5bWJvbH0gc2NoZWR1bGVkIGRhdGVgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7c3ltYm9scy5zY2hlZHVsZWREYXRlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcblxuICAgIGlmIChnbG9iYWxUaGlzLlNIT1dfREVQRU5ERU5DWV9TVUdHRVNUSU9OUykge1xuICAgICAgICBpZiAoIWxpbmUuaW5jbHVkZXMoc3ltYm9scy5pZFN5bWJvbCkpXG4gICAgICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMuaWRTeW1ib2x9IFRhc2sgSURgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMuaWRTeW1ib2x9YCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLmRlcGVuZHNPblN5bWJvbCkpXG4gICAgICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMuZGVwZW5kc09uU3ltYm9sfSBUYXNrIGRlcGVuZHMgb24gSURgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMuZGVwZW5kc09uU3ltYm9sfWAsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1ByaW9yaXR5KGxpbmUpKSB7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5U3ltYm9sczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHN5bWJvbHMucHJpb3JpdHlTeW1ib2xzO1xuICAgICAgICBjb25zdCBwcmlvcml0eVRleHRzID0gWydIaWdoJywgJ01lZGl1bScsICdMb3cnLCAnSGlnaGVzdCcsICdMb3dlc3QnXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByaW9yaXR5VGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5VGV4dCA9IHByaW9yaXR5VGV4dHNbaV07XG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eVN5bWJvbCA9IHByaW9yaXR5U3ltYm9sc1twcmlvcml0eVRleHRdO1xuXG4gICAgICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGRhdGF2aWV3TW9kZVxuICAgICAgICAgICAgICAgICAgICA/IGAke3ByaW9yaXR5U3ltYm9sfSBwcmlvcml0eWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtwcmlvcml0eVN5bWJvbH0gJHtwcmlvcml0eVRleHQudG9Mb3dlckNhc2UoKX0gcHJpb3JpdHlgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3ByaW9yaXR5U3ltYm9sfSR7cG9zdGZpeH1gLFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGRhdGF2aWV3TW9kZSA/IGluc2VydFNraXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLnJlY3VycmVuY2VTeW1ib2wpKVxuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5yZWN1cnJlbmNlU3ltYm9sfSByZWN1cnJpbmcgKHJlcGVhdClgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7c3ltYm9scy5yZWN1cnJlbmNlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcbiAgICBpZiAoIWxpbmUuaW5jbHVkZXMoc3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IERhdGVQYXJzZXIucGFyc2VEYXRlKCd0b2RheScsIHRydWUpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gcGFyc2VkRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KTtcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGlzIHRvIG1hdGNoIHdoZW4gdGhlIHVzZXIgdHlwZXMgXCJ0b2RheVwiXG4gICAgICAgICAgICB0ZXh0VG9NYXRjaDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gY3JlYXRlZGAsXG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gY3JlYXRlZCB0b2RheSAoJHtmb3JtYXR0ZWREYXRlfSlgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gJHtmb3JtYXR0ZWREYXRlfWAgKyBwb3N0Zml4LFxuICAgICAgICAgICAgaW5zZXJ0U2tpcDogZGF0YXZpZXdNb2RlID8gaW5zZXJ0U2tpcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2Ugbm93IGZpbHRlciB0aGUgZ2VuZXJhbCBzdWdnZXN0aW9ucyBhY2NvcmRpbmcgdG8gdGhlIHdvcmQgYXQgdGhlIGN1cnNvci4gSWYgdGhlcmUnc1xuICAgIC8vIHNvbWV0aGluZyB0byBtYXRjaCwgd2UgZmlsdGVyIHRoZSBzdWdnZXN0aW9ucyBhY2NvcmRpbmdseSwgc28gdGhlIHVzZXIgY2FuIGdldCBtb3JlIHNwZWNpZmljXG4gICAgLy8gcmVzdWx0cyBhY2NvcmRpbmcgdG8gd2hhdCBzaGUncyB0eXBpbmcuXG4gICAgLy8gSWYgdGhlcmUncyBubyBnb29kIG1hdGNoLCBwcmVzZW50IHRoZSBzdWdnZXN0aW9ucyBhcyB0aGV5IGFyZVxuICAgIGNvbnN0IHdvcmRNYXRjaCA9IG1hdGNoSWZDdXJzb3JJblJlZ2V4KGxpbmUsIC8oW2EtekEtWidfLV0qKS9nLCBjdXJzb3JQb3MpO1xuICAgIGNvbnN0IG1hdGNoaW5nU3VnZ2VzdGlvbnM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcbiAgICBpZiAod29yZE1hdGNoICYmIHdvcmRNYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmRVbmRlckN1cnNvciA9IHdvcmRNYXRjaFswXTtcbiAgICAgICAgaWYgKHdvcmRVbmRlckN1cnNvci5sZW5ndGggPj0gTWF0aC5tYXgoMSwgX3NldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN1Z2dlc3Rpb25zID0gZ2VuZXJpY1N1Z2dlc3Rpb25zLmZpbHRlcigoc3VnZ2VzdEluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0VG9NYXRjaCA9IHN1Z2dlc3RJbmZvLnRleHRUb01hdGNoIHx8IHN1Z2dlc3RJbmZvLmRpc3BsYXlUZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0VG9NYXRjaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHdvcmRVbmRlckN1cnNvci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXJlZCBvZiBmaWx0ZXJlZFN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0U2tpcFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgZGF0YXZpZXdNb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWx0ZXJlZC5kaXNwbGF5VGV4dC5pbmNsdWRlcygncHJpb3JpdHknKSB8fCBmaWx0ZXJlZC5kaXNwbGF5VGV4dC5pbmNsdWRlcygnY3JlYXRlZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3b3JkVW5kZXJDdXJzb3IubGVuZ3RoICsgaW5zZXJ0U2tpcFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB3b3JkVW5kZXJDdXJzb3IubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogZmlsdGVyZWQuZGlzcGxheVRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGZpbHRlcmVkLmFwcGVuZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEF0OiB3b3JkTWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGluc2VydFNraXBWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGF0J3Mgd2hlcmUgd2UncmUgYWRkaW5nIGFsbCB0aGUgc3VnZ2VzdGlvbnMgaW4gY2FzZSB0aGVyZSdzIG5vdGhpbmcgc3BlY2lmaWMgdG8gbWF0Y2hcbiAgICAvLyAoYW5kIHdlJ3JlIGFsbG93ZWQgYnkgdGhlIHNldHRpbmdzIHRvIGJyaW5nIGJhY2sgYSB6ZXJvLXNpemVkIG1hdGNoKVxuICAgIGlmIChtYXRjaGluZ1N1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBfc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCA9PT0gMCkgcmV0dXJuIGdlbmVyaWNTdWdnZXN0aW9ucztcblxuICAgIHJldHVybiBtYXRjaGluZ1N1Z2dlc3Rpb25zO1xufVxuXG4vKlxuICogSWYgdGhlIGN1cnNvciBpcyBsb2NhdGVkIGluIGEgc2VjdGlvbiB0aGF0IHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGRhdGUgKGR1ZSwgc3RhcnQgZGF0ZSBvciBzY2hlZHVsZWQgZGF0ZSksXG4gKiBzdWdnZXN0IG9wdGlvbnMgZm9yIHdoYXQgdG8gZW50ZXIgYXMgYSBkYXRlLlxuICogVGhpcyBoYXMgdHdvIHBhcnRzOiBlaXRoZXIgZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLCBvciBhIHNpbmdsZSBzdWdnZXN0aW9uIHRoYXQgaXMgYSBwYXJzZWQgcmVzdWx0XG4gKiBvZiB3aGF0IHRoZSB1c2VyIGlzIHR5cGluZy5cbiAqIEdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgaW4gdHVybiwgYWxzbyBoYXZlIHR3byBvcHRpb25zOiBlaXRoZXIgZmlsdGVyZWQgKGlmIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nXG4gKiBzb21ldGhpbmcgd2hlcmUgYSBkYXRlIGlzIGV4cGVjdGVkKSBvciB1bmZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGVzU3VnZ2VzdGlvbnMoXG4gICAgbGluZTogc3RyaW5nLFxuICAgIGN1cnNvclBvczogbnVtYmVyLFxuICAgIHNldHRpbmdzOiBTZXR0aW5ncyxcbiAgICBkYXRlUHJlZml4UmVnZXg6IHN0cmluZyxcbiAgICBtYXhHZW5lcmljU3VnZ2VzdGlvbnM6IG51bWJlcixcbiAgICBkYXRhdmlld01vZGU6IGJvb2xlYW4sXG4pOiBTdWdnZXN0SW5mb1tdIHtcbiAgICBjb25zdCBnZW5lcmljU3VnZ2VzdGlvbnMgPSBbXG4gICAgICAgICd0b2RheScsXG4gICAgICAgICd0b21vcnJvdycsXG4gICAgICAgICdTdW5kYXknLFxuICAgICAgICAnTW9uZGF5JyxcbiAgICAgICAgJ1R1ZXNkYXknLFxuICAgICAgICAnV2VkbmVzZGF5JyxcbiAgICAgICAgJ1RodXJzZGF5JyxcbiAgICAgICAgJ0ZyaWRheScsXG4gICAgICAgICdTYXR1cmRheScsXG4gICAgICAgICduZXh0IHdlZWsnLFxuICAgICAgICAnbmV4dCBtb250aCcsXG4gICAgICAgICduZXh0IHllYXInLFxuICAgIF07XG5cbiAgICBjb25zdCB7IHBvc3RmaXgsIGluc2VydFNraXAgfSA9IGdldEFkanVzdGVycyhkYXRhdmlld01vZGUsIGxpbmUsIGN1cnNvclBvcyk7XG5cbiAgICBjb25zdCByZXN1bHRzOiBTdWdnZXN0SW5mb1tdID0gW107XG4gICAgY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgKCR7ZGF0ZVByZWZpeFJlZ2V4fSlcXFxccyooWzAtOWEtekEtWiBdKilgLCAndWcnKTtcbiAgICBjb25zdCBkYXRlTWF0Y2ggPSBtYXRjaElmQ3Vyc29ySW5SZWdleChsaW5lLCBkYXRlUmVnZXgsIGN1cnNvclBvcyk7XG4gICAgaWYgKGRhdGVNYXRjaCAmJiBkYXRlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgZGF0ZVByZWZpeCA9IGRhdGVNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGRhdGVNYXRjaFsyXTtcbiAgICAgICAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoIDwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZW50ZXJlZCB0ZXh0IGFzIGEgdmFsaWQgZGF0ZS5cbiAgICAgICAgLy8gV2UgcGFzcyBmb3J3YXJkRGF0ZT10cnVlIHRvIHBhcnNlRGF0ZSBiZWNhdXNlIHdlIGV4cGVjdCBkdWUsIHN0YXJ0IGFuZCBzY2hlZHVsZWQgZGF0ZXMgdG9cbiAgICAgICAgLy8gYmUgaW4gdGhlIGZ1dHVyZSwgaS5lLiBpZiB0b2RheSBpcyBTdW5kYXkgYW5kIHRoZSB1c2VyIHR5cGVkIFwiZHVlIDxFbnRlcj4gU2F0dXJkYXlcIiwgc2hlXG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IG1lYW5zIFNhdHVyZGF5ICppbiB0aGUgZnV0dXJlKiBhbmQgbm90IHllc3RlcmRheS5cbiAgICAgICAgY29uc3QgcG9zc2libGVEYXRlID1cbiAgICAgICAgICAgIGRhdGVTdHJpbmcgJiYgZGF0ZVN0cmluZy5sZW5ndGggPiAxID8gRGF0ZVBhcnNlci5wYXJzZURhdGUoZG9BdXRvY29tcGxldGUoZGF0ZVN0cmluZyksIHRydWUpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvc3NpYmxlRGF0ZSAmJiBwb3NzaWJsZURhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWVtcyBsaWtlIHRoZSB0ZXh0IHRoYXQgdGhlIHVzZXIgdHlwZWQgY2FuIGJlIHBhcnNlZCBhcyBhIHZhbGlkIGRhdGUuXG4gICAgICAgICAgICAvLyBQcmVzZW50IGl0cyBjb21wbGV0ZWQgZm9ybSBhcyBhIDFzdCBzdWdnZXN0aW9uXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtwb3NzaWJsZURhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtkYXRlUHJlZml4fSAke3Bvc3NpYmxlRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogZGF0ZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGRhdGVNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB0byBnZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMuXG4gICAgICAgIC8vIElmIHdlIGdldCBhIHBhcnRpYWwgbWF0Y2ggd2l0aCBzb21lIG9mIHRoZSBzdWdnZXN0aW9ucyAoZS5nLiB0aGUgdXNlciBzdGFydGVkIHR5cGluZyBcInRvXCIpLFxuICAgICAgICAvLyB3ZSB1c2UgdGhhdCBmb3IgbWF0Y2hlcyAoXCJ0b21vcnJvd1wiLCBcInRvZGF5XCIgZXRjKS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBqdXN0IGRpc3BsYXkgdGhlIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMsIGFuZCBlaXRoZXIgd2F5LCB0cnVuY2F0ZSB0aGVtIGV2ZW50dWFsbHkgdG9cbiAgICAgICAgLy8gYSBtYXggbnVtYmVyLiBXZSB3YW50IHRoZSBtYXggbnVtYmVyIHRvIGJlIGFyb3VuZCBoYWxmIHRoZSB0b3RhbCBhbGxvd2VkIG1hdGNoZXMsIHRvIGFsc28gYWxsb3dcbiAgICAgICAgLy8gc29tZSBnbG9iYWwgZ2VuZXJpYyBtYXRjaGVzIChlLmcuIHRhc2sgY29tcG9uZW50cykgdG8gZmluZCB0aGVpciB3YXkgdG8gdGhlIG1lbnVcbiAgICAgICAgY29uc3QgbWluTWF0Y2ggPSAxO1xuICAgICAgICBsZXQgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICBkYXRlU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJpbmcubGVuZ3RoID49IG1pbk1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZGF0ZVN0cmluZy50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zbGljZSgwLCBtYXhHZW5lcmljU3VnZ2VzdGlvbnMpO1xuICAgICAgICBpZiAoZ2VuZXJpY01hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEbyBjb21wbGV0ZWx5IGdlbmVyaWMgZGF0ZSBzdWdnZXN0aW9uc1xuICAgICAgICAgICAgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnMuc2xpY2UoMCwgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGdlbmVyaWNNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gRGF0ZVBhcnNlci5wYXJzZURhdGUobWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGAke3BhcnNlZERhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydFNraXBWYWx1ZSA9IGRhdGF2aWV3TW9kZSA/IGRhdGVNYXRjaFswXS5sZW5ndGggKyBpbnNlcnRTa2lwIDogZGF0ZU1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke21hdGNofSAoJHtmb3JtYXR0ZWREYXRlfSlgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke2RhdGVQcmVmaXh9ICR7Zm9ybWF0dGVkRGF0ZX1gICsgcG9zdGZpeCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogZGF0ZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGluc2VydFNraXBWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKlxuICogSWYgdGhlIGN1cnNvciBpcyBsb2NhdGVkIGluIGEgc2VjdGlvbiB0aGF0IHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIHJlY3VycmVuY2UgZGVzY3JpcHRpb24sIHN1Z2dlc3Qgb3B0aW9uc1xuICogZm9yIHdoYXQgdG8gZW50ZXIgYXMgYSByZWN1cnJlbmNlLlxuICogVGhpcyBoYXMgdHdvIHBhcnRzOiBlaXRoZXIgZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLCBvciBhIHNpbmdsZSBzdWdnZXN0aW9uIHRoYXQgaXMgYSBwYXJzZWQgcmVzdWx0XG4gKiBvZiB3aGF0IHRoZSB1c2VyIGlzIHR5cGluZy5cbiAqIEdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgaW4gdHVybiwgYWxzbyBoYXZlIHR3byBvcHRpb25zOiBlaXRoZXIgZmlsdGVyZWQgKGlmIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nXG4gKiBzb21ldGhpbmcgd2hlcmUgYSByZWN1cnJlbmNlIGlzIGV4cGVjdGVkKSBvciB1bmZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIGFkZFJlY3VycmVuY2VTdWdnZXN0aW9ucyhcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgY3Vyc29yUG9zOiBudW1iZXIsXG4gICAgc2V0dGluZ3M6IFNldHRpbmdzLFxuICAgIHJlY3VycmVuY2VTeW1ib2w6IHN0cmluZyxcbiAgICBkYXRhdmlld01vZGU6IGJvb2xlYW4sXG4pIHtcbiAgICBjb25zdCBnZW5lcmljU3VnZ2VzdGlvbnMgPSBbXG4gICAgICAgICdldmVyeScsXG4gICAgICAgICdldmVyeSBkYXknLFxuICAgICAgICAnZXZlcnkgd2VlaycsXG4gICAgICAgICdldmVyeSBtb250aCcsXG4gICAgICAgICdldmVyeSBtb250aCBvbiB0aGUnLFxuICAgICAgICAnZXZlcnkgeWVhcicsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFN1bmRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIE1vbmRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFR1ZXNkYXknLFxuICAgICAgICAnZXZlcnkgd2VlayBvbiBXZWRuZXNkYXknLFxuICAgICAgICAnZXZlcnkgd2VlayBvbiBUaHVyc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIEZyaWRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFNhdHVyZGF5JyxcbiAgICBdO1xuXG4gICAgY29uc3QgeyBwb3N0Zml4LCBpbnNlcnRTa2lwIH0gPSBnZXRBZGp1c3RlcnMoZGF0YXZpZXdNb2RlLCBsaW5lLCBjdXJzb3JQb3MpO1xuXG4gICAgY29uc3QgcmVzdWx0czogU3VnZ2VzdEluZm9bXSA9IFtdO1xuICAgIGNvbnN0IHJlY3VycmVuY2VSZWdleCA9IG5ldyBSZWdFeHAoYCgke3JlY3VycmVuY2VTeW1ib2x9KVxcXFxzKihbMC05YS16QS1aIF0qKWAsICd1ZycpO1xuICAgIGNvbnN0IHJlY3VycmVuY2VNYXRjaCA9IG1hdGNoSWZDdXJzb3JJblJlZ2V4KGxpbmUsIHJlY3VycmVuY2VSZWdleCwgY3Vyc29yUG9zKTtcbiAgICBpZiAocmVjdXJyZW5jZU1hdGNoICYmIHJlY3VycmVuY2VNYXRjaC5sZW5ndGggPj0gMikge1xuICAgICAgICBjb25zdCByZWN1cnJlbmNlUHJlZml4ID0gcmVjdXJyZW5jZU1hdGNoWzFdO1xuICAgICAgICBjb25zdCByZWN1cnJlbmNlU3RyaW5nID0gcmVjdXJyZW5jZU1hdGNoWzJdO1xuICAgICAgICBpZiAocmVjdXJyZW5jZVN0cmluZy5sZW5ndGggPCBzZXR0aW5ncy5hdXRvU3VnZ2VzdE1pbk1hdGNoKSByZXR1cm4gW107XG4gICAgICAgIGlmIChyZWN1cnJlbmNlU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0ZXh0IG1hdGNoZXMgYSB2YWxpZCByZWN1cmVuY2UgZGVzY3JpcHRpb24sIHByZXNlbnQgaXQgYXMgYSAxc3Qgc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgIC8vIFdlIGFsc28gYWRkIGEgbmljZSBjaGVja21hcmsgaW4gdGhpcyBjYXNlIHRvIGRlbm90ZSBpdCdzIGEgY29tcGxldGUgdmFsaWQgcmVjdXJyZW5jZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVjdXJyZW5jZSA9IFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogcmVjdXJyZW5jZVN0cmluZyxcbiAgICAgICAgICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbWluZGVyRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIH0pPy50b1RleHQoKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRSZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwZW5kZWRUZXh0ID0gYCR7cmVjdXJyZW5jZVByZWZpeH0gJHtwYXJzZWRSZWN1cnJlbmNlfWAgKyBwb3N0Zml4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydFNraXBWYWx1ZSA9IGRhdGF2aWV3TW9kZVxuICAgICAgICAgICAgICAgICAgICA/IHJlY3VycmVuY2VNYXRjaFswXS5sZW5ndGggKyBpbnNlcnRTa2lwXG4gICAgICAgICAgICAgICAgICAgIDogcmVjdXJyZW5jZU1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGBcdTI3MDUgJHtwYXJzZWRSZWN1cnJlbmNlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGFwcGVuZGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IHJlY3VycmVuY2VNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U2tpcDogaW5zZXJ0U2tpcFZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdWxsIG1hdGNoIGluY2x1ZGVzIGEgY29tcGxldGUgdmFsaWQgc3VnZ2VzdGlvbiAqZW5kaW5nIHdpdGggc3BhY2UqLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3QgYW55dGhpbmcuIFRoZSB1c2VyIGlzIHRyeWluZyB0byBjb250aW51ZSB0byB0eXBlIHNvbWV0aGluZyB0aGF0IGlzIGxpa2VseVxuICAgICAgICAgICAgICAgIC8vIG5vdCByZWxhdGVkIHRvIHJlY3VycmVuY2UuIFdoZW4gc2hlIHN0YXJ0cyBhIG5ldyB3b3JkLCBtYXliZSB0aGUgcmVjdXJyZW5jZSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZWxldmFudCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnJlbmNlTWF0Y2hbMF0gPT0gYXBwZW5kZWRUZXh0KSByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdG8gZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLlxuICAgICAgICAvLyBJZiB3ZSBnZXQgYSBwYXJ0aWFsIG1hdGNoIHdpdGggc29tZSBvZiB0aGUgc3VnZ2VzdGlvbnMgKGUuZy4gdGhlIHVzZXIgc3RhcnRlZCB0eXBpbmcgXCJldmVyeSBkXCIpLFxuICAgICAgICAvLyB3ZSB1c2UgdGhhdCBmb3IgbWF0Y2hlcyAoXCJldmVyeSBkYXlcIikuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIHN1Z2dlc3Rpb25zLCBhbmQgZWl0aGVyIHdheSwgdHJ1bmNhdGUgdGhlbSBldmVudHVhbGx5IHRvXG4gICAgICAgIC8vIGEgbWF4IG51bWJlci5cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgcmVjdXJyZW5jZSBydWxlcywgdGhlIG1heCBudW1iZXIgc2hvdWxkIGJlIHNtYWxsIGVub3VnaCB0byBhbGxvdyB1c2VycyB0byBcImVzY2FwZVwiXG4gICAgICAgIC8vIHRoZSBtb2RlIG9mIHdyaXRpbmcgYSByZWN1cnJlbmNlIHJ1bGUsIGkuZS4gd2Ugc2hvdWxkIGxlYXZlIGVub3VnaCBzcGFjZSBmb3IgY29tcG9uZW50IHN1Z2dlc3Rpb25zXG4gICAgICAgIGNvbnN0IG1pbk1hdGNoID0gMTtcbiAgICAgICAgY29uc3QgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyA9IHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMgLyAyO1xuICAgICAgICBsZXQgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICByZWN1cnJlbmNlU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoID49IG1pbk1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocmVjdXJyZW5jZVN0cmluZy50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zbGljZSgwLCBtYXhHZW5lcmljRGF0ZVN1Z2dlc3Rpb25zKTtcbiAgICAgICAgaWYgKGdlbmVyaWNNYXRjaGVzLmxlbmd0aCA9PT0gMCAmJiByZWN1cnJlbmNlU3RyaW5nLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgbm8gYWN0dWFsIG1hdGNoIHNvIGRvIGNvbXBsZXRlbHkgZ2VuZXJpYyByZWN1cnJlbmNlIHN1Z2dlc3Rpb25zLCBidXQgbm90IGlmXG4gICAgICAgICAgICAvLyB0aGVyZSAqd2FzKiBhIHRleHQgdG8gbWF0Y2ggKGJlY2F1c2UgaXQgbWVhbnMgdGhlIHVzZXIgaXMgYWN0dWFsbHkgdHlwaW5nIHNvbWV0aGluZyBlbHNlKVxuICAgICAgICAgICAgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnMuc2xpY2UoMCwgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGdlbmVyaWNNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHttYXRjaH1gLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3JlY3VycmVuY2VQcmVmaXh9ICR7bWF0Y2h9IGAsXG4gICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IHJlY3VycmVuY2VNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiByZWN1cnJlbmNlTWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gYWRkSURTdWdnZXN0aW9uKGxpbmU6IHN0cmluZywgY3Vyc29yUG9zOiBudW1iZXIsIGlkU3ltYm9sOiBzdHJpbmcsIGFsbFRhc2tzOiBUYXNrW10pIHtcbiAgICBjb25zdCByZXN1bHRzOiBTdWdnZXN0SW5mb1tdID0gW107XG4gICAgY29uc3QgaWRSZWdleCA9IG5ldyBSZWdFeHAoYCgke2lkU3ltYm9sfSlcXFxccyooJHt0YXNrSWRSZWdleC5zb3VyY2V9KT9gLCAndWcnKTtcbiAgICBjb25zdCBpZE1hdGNoID0gbWF0Y2hJZkN1cnNvckluUmVnZXgobGluZSwgaWRSZWdleCwgY3Vyc29yUG9zKTtcblxuICAgIGlmIChpZE1hdGNoICYmIGlkTWF0Y2hbMF0udHJpbSgpLmxlbmd0aCA8PSBpZFN5bWJvbC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgSUQgPSBnZW5lcmF0ZVVuaXF1ZUlkKGFsbFRhc2tzLm1hcCgodGFzaykgPT4gdGFzay5pZCkpO1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogJ0F1dG8gR2VuZXJhdGUgVW5pcXVlIElEJyxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke2lkU3ltYm9sfSAke0lEfWAsXG4gICAgICAgICAgICBpbnNlcnRBdDogaWRNYXRjaC5pbmRleCxcbiAgICAgICAgICAgIGluc2VydFNraXA6IGlkU3ltYm9sLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qXG4gKiBJZiB0aGUgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gYSBzZWN0aW9uIHRoYXQgaXMgZm9sbG93ZWQgYnkgYSBEZXBlbmRzIE9uIFN5bWJvbCwgc3VnZ2VzdCBvcHRpb25zXG4gKiBmb3Igd2hhdCB0byBlbnRlciBhcyBEZXBlbmQgb24gT3B0aW9uLlxuICogSXQgc2hvdWxkIGNvbnRhaW4gc3VnZ2VzdGlvbiBvZiBQb3NzaWJsZSBEZXBlbmRhbnQgVGFza3NcbiAqIG9mIHdoYXQgdGhlIHVzZXIgaXMgdHlwaW5nLlxuICovXG5mdW5jdGlvbiBhZGREZXBlbmRzT25TdWdnZXN0aW9ucyhcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgY3Vyc29yUG9zOiBudW1iZXIsXG4gICAgc2V0dGluZ3M6IFNldHRpbmdzLFxuICAgIGRlcGVuZHNPblN5bWJvbDogc3RyaW5nLFxuICAgIGFsbFRhc2tzOiBUYXNrW10sXG4gICAgdGFza1RvU3VnZ2VzdEZvcj86IFRhc2ssXG4pIHtcbiAgICBjb25zdCByZXN1bHRzOiBTdWdnZXN0SW5mb1tdID0gW107XG5cbiAgICBjb25zdCBkZXBlbmRzT25SZWdleCA9IG5ldyBSZWdFeHAoYCgke2RlcGVuZHNPblN5bWJvbH0pKFswLTlhLXpBLVotXyBeLF0qLCkqKFswLTlhLXpBLVogXixdKilgLCAndWcnKTtcbiAgICBjb25zdCBkZXBlbmRzT25NYXRjaCA9IG1hdGNoSWZDdXJzb3JJblJlZ2V4KGxpbmUsIGRlcGVuZHNPblJlZ2V4LCBjdXJzb3JQb3MpO1xuICAgIGlmIChkZXBlbmRzT25NYXRjaCAmJiBkZXBlbmRzT25NYXRjaC5sZW5ndGggPj0gMSkge1xuICAgICAgICAvLyBkZXBlbmRzT25NYXRjaFsxXSA9IERlcGVuZHMgT24gU3ltYm9sXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGVwZW5kc09uSWRTdHJpbmdzID0gZGVwZW5kc09uTWF0Y2hbMl0gfHwgJyc7XG4gICAgICAgIGNvbnN0IG5ld1Rhc2tUb0FwcGVuZCA9IGRlcGVuZHNPbk1hdGNoWzNdO1xuXG4gICAgICAgIC8vIEZpbmQgYWxsIFRhc2tzLCBBbHJlYWR5IEFkZGVkXG4gICAgICAgIGxldCBibG9ja2luZ1Rhc2tzOiBUYXNrW10gPSBbXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRGVwZW5kc09uSWRTdHJpbmdzKSB7XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGludG8gYW4gYXJyYXkgYnkgY29tbWFzLCB0aGVuIG1hcCBvdmVyIGl0IHRvIHRyaW0gd2hpdGVzcGFjZSBmcm9tIGVhY2ggZWxlbWVudC5cbiAgICAgICAgICAgIGNvbnN0IGlkc0FycmF5ID0gZXhpc3RpbmdEZXBlbmRzT25JZFN0cmluZ3Muc3BsaXQoJywnKS5tYXAoKGlkKSA9PiBpZC50cmltKCkpO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgYGFsbFRhc2tzYCB0byBvbmx5IGluY2x1ZGUgdGFza3Mgd2hvc2UgYGlkYCBpcyBleGFjdGx5IGluIHRoZSBgaWRzQXJyYXlgLlxuICAgICAgICAgICAgYmxvY2tpbmdUYXNrcyA9IGFsbFRhc2tzLmZpbHRlcigodGFzaykgPT4gdGFzay5pZCAmJiBpZHNBcnJheS5pbmNsdWRlcyh0YXNrLmlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3VGFza1RvQXBwZW5kLmxlbmd0aCA+PSBzZXR0aW5ncy5hdXRvU3VnZ2VzdE1pbk1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmljTWF0Y2hlcyA9IHNlYXJjaEZvckNhbmRpZGF0ZVRhc2tzRm9yRGVwZW5kZW5jeShcbiAgICAgICAgICAgICAgICBuZXdUYXNrVG9BcHBlbmQudHJpbSgpLFxuICAgICAgICAgICAgICAgIGFsbFRhc2tzLFxuICAgICAgICAgICAgICAgIHRhc2tUb1N1Z2dlc3RGb3IsXG4gICAgICAgICAgICAgICAgW10gYXMgVGFza1tdLFxuICAgICAgICAgICAgICAgIGJsb2NraW5nVGFza3MsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgZ2VuZXJpY01hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2suZGVzY3JpcHRpb25XaXRob3V0VGFnc30gLSBGcm9tOiAke3Rhc2suZmlsZW5hbWV9Lm1kYCxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7ZGVwZW5kc09uU3ltYm9sfSR7ZXhpc3RpbmdEZXBlbmRzT25JZFN0cmluZ3N9YCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IGRlcGVuZHNPbk1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiBkZXBlbmRzT25TeW1ib2wubGVuZ3RoICsgZXhpc3RpbmdEZXBlbmRzT25JZFN0cmluZ3MubGVuZ3RoICsgbmV3VGFza1RvQXBwZW5kLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdGFza0l0RGVwZW5kc09uOiB0YXNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IGFjY29yZGluZyB0byBhIHBvc2l0aW9uICh0eXBpY2FsbHkgb2YgYSBjdXJzb3IpLlxuICogV2lsbCByZXR1cm4gYSByZXN1bHQgb25seSBpZiBhIG1hdGNoIGV4aXN0cyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHBhcnQgb2YgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaElmQ3Vyc29ySW5SZWdleChzOiBzdHJpbmcsIHI6IFJlZ0V4cCwgcG9zaXRpb246IG51bWJlcik6IFJlZ0V4cE1hdGNoQXJyYXkgfCB2b2lkIHtcbiAgICBjb25zdCBtYXRjaGVzID0gcy5tYXRjaEFsbChyKTtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoPy5pbmRleCAmJiBtYXRjaC5pbmRleCA8IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIF9hbnlfIG9mIHRoZSBicmFja2V0IHBhaXJzIGluIHtAbGluayBicmFja2V0c30gaXMgb3BlbiBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcge0BsaW5rIGxpbmV9XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBpc0FueUJyYWNrZXRPcGVuKFwiKGhlbGxvIHdvcmxkXCIsICAgW1snKCcsICcpJ11dKTsgICAgICAgICAgICAgLy8gdHJ1ZVxuICogICAgIGlzQW55QnJhY2tldE9wZW4oXCJbaGVsbG8gd29ybGRcIiwgICBbWydbJywgJ10nXV0pOyAgICAgICAgICAgICAvLyB0cnVlXG4gKiAgICAgaXNBbnlCcmFja2V0T3BlbihcIltoZWxsbyB3b3JsZFwiLCAgIFtbJygnLCAnKSddLCBbJ1snLCAnXSddXSk7IC8vIHRydWVcbiAqICAgICBpc0FueUJyYWNrZXRPcGVuKFwiKFtoZWxsbyB3b3JsZClcIiwgW1snKCcsICcpJ10sIFsnWycsICddJ11dKSAgLy8gdHJ1ZVxuICogICAgIGlzQW55QnJhY2tldE9wZW4oXCIpKSkpKFwiLCAgICAgICAgICBbWycoJywgJyknXV0pICAgICAgICAgICAgICAvLyB0cnVlXG4gKiAgICAgaXNBbnlCcmFja2V0T3BlbihcIihoZWxsbyB3b3JsZClcIiwgIFtbJygnLCAnKSddXSk7ICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiAgICAgaXNBbnlCcmFja2V0T3BlbihcIihoZWxsbyB3b3JsZClcIiwgIFtdKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIGxpbmUgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIHNjYW5cbiAqIEBwYXJhbSBicmFja2V0cyAtIEEgbGlzdCBvZiB0dXBsZXMgdGhhdCBkZWZpbmVzIGJyYWNrZXQgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIGlzQW55QnJhY2tldE9wZW4obGluZTogc3RyaW5nLCBicmFja2V0czogW29wZW5pbmdfYnJhY2tldDogc3RyaW5nLCBjbG9zaW5nX2JyYWNrZXQ6IHN0cmluZ11bXSk6IGJvb2xlYW4ge1xuICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE1hcHMgYW4gb3BlbmluZyBicmFja2V0IHRvIHRoZSBudW1iZXIgb2Ygb3BlbiBicmFja2V0cyBvZiB0aGF0IHR5cGVcbiAgICBjb25zdCBudW1PcGVuaW5nQnJhY2tldHMgPSBPYmplY3QuZnJvbUVudHJpZXMoYnJhY2tldHMubWFwKChbb3BlbiwgX10pID0+IFtvcGVuLCAwXSkpO1xuICAgIC8vIE1hcHMgYSBjbG9zaW5nIGJyYWNrZXQgdG8gYW4gb3BlbmluZyBicmFja2V0XG4gICAgY29uc3Qgb3BlbmluZ09mID0gT2JqZWN0LmZyb21FbnRyaWVzKGJyYWNrZXRzLm1hcCgoW29wZW4sIGNsb3NlXSkgPT4gW2Nsb3NlLCBvcGVuXSkpO1xuXG4gICAgZm9yIChjb25zdCBjIG9mIGxpbmUpIHtcbiAgICAgICAgaWYgKGMgaW4gbnVtT3BlbmluZ0JyYWNrZXRzKSB7XG4gICAgICAgICAgICBudW1PcGVuaW5nQnJhY2tldHNbY10rKztcbiAgICAgICAgfSBlbHNlIGlmIChjIGluIG9wZW5pbmdPZikge1xuICAgICAgICAgICAgbnVtT3BlbmluZ0JyYWNrZXRzW29wZW5pbmdPZltjXV0gPSBNYXRoLm1heCgwLCBudW1PcGVuaW5nQnJhY2tldHNbb3BlbmluZ09mW2NdXSAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobnVtT3BlbmluZ0JyYWNrZXRzKS5zb21lKChuKSA9PiBuID4gMCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgX2FueV8gb2YgdGhlIGJyYWNrZXQgcGFpcnMgaW4ge0BsaW5rIGJyYWNrZXRzfSBpcyBvcGVuIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyB7QGxpbmsgbGluZX1cbiAqIElmIHRoZXJlIGFyZSBhbnkgb3BlbiBicmFja2V0cywgcmV0dXJucyB0aGUgbGFzdCBvbmUuIEVsc2UsIHJldHVybnMgbnVsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGxhc3RPcGVuQnJhY2tldChcIihoZWxsbyB3b3JsZFwiLCAgIFtbJygnLCAnKSddXSk7ICAgICAgICAgICAgIC8vICcoJ1xuICogICAgIGxhc3RPcGVuQnJhY2tldChcIltoZWxsbyB3b3JsZFwiLCAgIFtbJ1snLCAnXSddXSk7ICAgICAgICAgICAgIC8vICdbJ1xuICogICAgIGxhc3RPcGVuQnJhY2tldChcIltoZWxsbyB3b3JsZFwiLCAgIFtbJygnLCAnKSddLCBbJ1snLCAnXSddXSk7IC8vICdbJ1xuICogICAgIGxhc3RPcGVuQnJhY2tldChcIihbaGVsbG8gd29ybGQpXCIsIFtbJygnLCAnKSddLCBbJ1snLCAnXSddXSkgIC8vICdbJ1xuICogICAgIGxhc3RPcGVuQnJhY2tldChcIikpKSkoXCIsICAgICAgICAgIFtbJygnLCAnKSddXSkgICAgICAgICAgICAgIC8vICcoJ1xuICogICAgIGxhc3RPcGVuQnJhY2tldChcIihoZWxsbyB3b3JsZClcIiwgIFtbJygnLCAnKSddXSk7ICAgICAgICAgICAgIC8vIG51bGxcbiAqICAgICBsYXN0T3BlbkJyYWNrZXQoXCIoaGVsbG8gd29ybGQpXCIsICBbXSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsXG4gKlxuICogQHBhcmFtIGxpbmUgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIHNjYW5cbiAqIEBwYXJhbSBicmFja2V0cyAtIEEgbGlzdGVkIG9mIHR1cGxlcyB0aGF0IGRlZmluZXMgYnJhY2tldCBwYWlycy5cbiAqIEByZXR1cm5zIFRoZSBsYXN0IG9wZW4gYnJhY2tldCBpbiBsaW5lIGFtb25nIHRoZSBnaXZlbiBicmFja2V0IHBhaXJzLiBJZiBubyBzdWNoIGJyYWNrZXQgZXhpc3RzLCByZXR1cm4gbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3RPcGVuQnJhY2tldChcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgYnJhY2tldHM6IFtvcGVuaW5nX2JyYWNrZXQ6IHN0cmluZywgY2xvc2luZ19icmFja2V0OiBzdHJpbmddW10sXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBudW1PcGVuaW5nQnJhY2tldHMgPSBPYmplY3QuZnJvbUVudHJpZXMoYnJhY2tldHMubWFwKChbb3BlbiwgX10pID0+IFtvcGVuLCAwXSkpO1xuICAgIGNvbnN0IG9wZW5pbmdPZiA9IE9iamVjdC5mcm9tRW50cmllcyhicmFja2V0cy5tYXAoKFtvcGVuLCBjbG9zZV0pID0+IFtjbG9zZSwgb3Blbl0pKTtcbiAgICBjb25zdCBvcGVuQnJhY2tldHNTdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbGluZVtpXTtcbiAgICAgICAgaWYgKGMgaW4gbnVtT3BlbmluZ0JyYWNrZXRzKSB7XG4gICAgICAgICAgICBudW1PcGVuaW5nQnJhY2tldHNbY10rKztcbiAgICAgICAgICAgIG9wZW5CcmFja2V0c1N0YWNrLnB1c2goeyBicmFja2V0OiBjLCBpZHg6IGkgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyBpbiBvcGVuaW5nT2YpIHtcbiAgICAgICAgICAgIGlmIChudW1PcGVuaW5nQnJhY2tldHNbb3BlbmluZ09mW2NdXSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gb3BlbkJyYWNrZXRzU3RhY2subGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuQnJhY2tldHNTdGFja1tpZHhdLmJyYWNrZXQgPT0gb3BlbmluZ09mW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQnJhY2tldHNTdGFjay5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtT3BlbmluZ0JyYWNrZXRzW29wZW5pbmdPZltjXV0gPSBNYXRoLm1heCgwLCBudW1PcGVuaW5nQnJhY2tldHNbb3BlbmluZ09mW2NdXSAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVuQnJhY2tldHNTdGFjay5sZW5ndGggPiAwID8gb3BlbkJyYWNrZXRzU3RhY2tbb3BlbkJyYWNrZXRzU3RhY2subGVuZ3RoIC0gMV0uYnJhY2tldCA6IG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBTdWdnZXN0aW9uQnVpbGRlciB7QGxpbmsgZm59LCByZXR1cm5zIGEgbmV3IFN1Z2dlc3Rpb25CdWlsZGVyIHdpdGggaWRlbnRpY2FsIGJlaGF2aW9yIHRvIHtAbGluayBmbn0gZXhjZXB0XG4gKiAgICAgaXQgb25seSByZXR1cm5zIHN1Z2dlc3Rpb25zIGlmIHRoZXJlIGlzIGFuIG9wZW4gYnJhY2tldCBhdCB0aGUgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSBmbiAtIEEgc3VnZ2VzdGlvbiBidWlsZGVyIHRvIHdyYXBcbiAqIEBwYXJhbSBicmFja2V0cyAtIEEgbGlzdCBvZiB0dXBsZXMgdGhhdCBkZWZpbmVzIGJyYWNrZXQgcGFpcnMuXG4gKiBAcmV0dXJucyBBIHtAbGluayBTdWdnZXN0aW9uQnVpbGRlcn0gdGhhdCByZXR1cm5zOlxuICogICAqIGBbXWAgaWYgdGhlcmUgYXJlIG5vIG9wZW4gYnJhY2tldHMgYXQgdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvblxuICogICAqIHtAbGluayBmbn1gKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MpYCBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ubHlTdWdnZXN0SWZCcmFja2V0T3BlbihmbjogU3VnZ2VzdGlvbkJ1aWxkZXIsIGJyYWNrZXRzOiBbc3RyaW5nLCBzdHJpbmddW10pOiBTdWdnZXN0aW9uQnVpbGRlciB7XG4gICAgcmV0dXJuIChsaW5lLCBjdXJzb3JQb3MsIHNldHRpbmdzLCB0YXNrVG9TdWdnZXN0Rm9yLCBhbGxUYXNrcyk6IFN1Z2dlc3RJbmZvW10gPT4ge1xuICAgICAgICBpZiAoIWlzQW55QnJhY2tldE9wZW4obGluZS5zbGljZSgwLCBjdXJzb3JQb3MpLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4obGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncywgdGFza1RvU3VnZ2VzdEZvciwgYWxsVGFza3MpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIEF1dG8tU3VnZ2VzdCBtZW51IG1heSBiZSBzaG93biBvbiB0aGUgY3VycmVudCBsaW5lLFxuICogYW5kIGZhbHNlIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBUaGlzIGNoZWNrcyBmb3Igc2ltcGxlIHByZS1jb25kaXRpb25zOlxuICogIC0gRG9lcyB0aGUgcGFyZW50IGVkaXRvciBleHBsaWNpdGx5IHJlcXVlc3QgaXQ/XG4gKiAgLSBJcyB0aGUgZ2xvYmFsIGZpbHRlciAoaWYgc2V0KSBpbiB0aGUgbGluZT9cbiAqICAtIElzIHRoZSBsaW5lIGEgdGFzayBsaW5lICh3aXRoIGEgY2hlY2tib3gpP1xuICogQHBhcmFtIGxpbmVcbiAqIEBwYXJhbSBjdXJzb3IgLSB0aGUgY3Vyc29yIHBvc2l0aW9uLCB3aGVuIGNoIGlzIDAgaXQgaXMgcHJlc3VtZWQgdG8gbWVhbiAnYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly9kb2NzLm9ic2lkaWFuLm1kL1JlZmVyZW5jZS9UeXBlU2NyaXB0K0FQSS9FZGl0b3JQb3NpdGlvblxuICogQHBhcmFtIGVkaXRvciAtIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG8gd2hpY2ggdGhlIHN1Z2dlc3QgYmVsb25nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuU3VnZ2VzdEZvckxpbmUobGluZTogc3RyaW5nLCBjdXJzb3I6IEVkaXRvclBvc2l0aW9uLCBlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGxpbmVIYXNHbG9iYWxGaWx0ZXIgPSBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5pbmNsdWRlZEluKGxpbmUpO1xuICAgIGNvbnN0IGRpZEVkaXRvclJlcXVlc3QgPSBlZGl0b3JJc1JlcXVlc3RpbmdTdWdnZXN0KGVkaXRvciwgY3Vyc29yLCBsaW5lSGFzR2xvYmFsRmlsdGVyKTtcblxuICAgIGlmICh0eXBlb2YgZGlkRWRpdG9yUmVxdWVzdCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gZGlkRWRpdG9yUmVxdWVzdDtcbiAgICByZXR1cm4gbGluZUhhc0dsb2JhbEZpbHRlciAmJiBjdXJzb3JJc0luVGFza0xpbmVEZXNjcmlwdGlvbihsaW5lLCBjdXJzb3IuY2gpO1xufVxuXG4vKipcbiAqIFJldHVyblxuICogLSB0cnVlIGlmIHRoZSBwYXJlbnQgZWRpdG9yIGlzIGV4cGxpY2l0bHkgcmVxdWVzdGluZyB0aGF0IHRoZSBzdWdnZXN0IGJlIGRpc3BsYXllZFxuICogLSBmYWxzZSBpZiBpdCBpcyByZXF1ZXN0aW5nIHRoYXQgaXQgYmUgaGlkZGVuXG4gKiAtIHVuZGVmaW5lZCBpZiB0aGUgcGFyZW50IGVkaXRvciB3YW50cyB0byBkZWZlciB0byB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICpcbiAqIEBwYXJhbSBlZGl0b3IgLSB0aGUgZWRpdG9yIGluc3RhbmNlIHRvIHdoaWNoIHRoZSBzdWdnZXN0IGJlbG9uZ3NcbiAqIEBwYXJhbSBjdXJzb3IgLSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGVkaXRvcklzUmVxdWVzdGluZ1N1Z2dlc3QoXG4gICAgZWRpdG9yOiBFZGl0b3IsXG4gICAgY3Vyc29yOiBFZGl0b3JQb3NpdGlvbixcbiAgICBsaW5lSGFzR2xvYmFsRmlsdGVyOiBib29sZWFuLFxuKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIChlZGl0b3IgYXMgYW55KT8uZWRpdG9yQ29tcG9uZW50Py5zaG93VGFza3NQbHVnaW5BdXRvU3VnZ2VzdD8uKGN1cnNvciwgZWRpdG9yLCBsaW5lSGFzR2xvYmFsRmlsdGVyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZjpcbiAqIC0gbGluZSBpcyBhIHRhc2sgbGluZSwgdGhhdCBpcywgaXQgaXMgYSBsaXN0IGl0ZW0gd2l0aCBhIGNoZWNrYm94LlxuICogLSB0aGUgY3Vyc29yIGlzIGluIGEgdGFzayBsaW5lJ3MgZGVzY3JpcHRpb24uXG4gKlxuICogSGVyZSwgZGVzY3JpcHRpb24gaW5jbHVkZXMgYW55IHRhc2sgc2lnbmlmaWVycywgYXMgd2VsbCBhcyB0aGUgdmFuaWxsYSBkZXNjcmlwdGlvbi5cbiAqIEBwYXJhbSBsaW5lXG4gKiBAcGFyYW0gY3Vyc29yUG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY3Vyc29ySXNJblRhc2tMaW5lRGVzY3JpcHRpb24obGluZTogc3RyaW5nLCBjdXJzb3JQb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzID0gVGFzay5leHRyYWN0VGFza0NvbXBvbmVudHMobGluZSk7XG4gICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgIC8vIEl0IGlzIG5vdCBhIHRhc2sgbGluZSwgdGhhdCBpcywgaXQgaXMgbm90IGEgbGlzdCBpdGVtIHdpdGggYSBjaGVja2JveDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlY29uc3RydWN0IHRoZSBjb250ZW50cyBvZiB0aGUgbGluZSwgdXAgdG8gdGhlIHNwYWNlIGFmdGVyIHRoZSBjbG9zaW5nICddJyBpbiB0aGUgY2hlY2tib3g6XG4gICAgY29uc3QgYmVmb3JlRGVzY3JpcHRpb24gPSBjb21wb25lbnRzLmluZGVudGF0aW9uICsgY29tcG9uZW50cy5saXN0TWFya2VyICsgJyBbJyArIGNvbXBvbmVudHMuc3RhdHVzLnN5bWJvbCArICddICc7XG5cbiAgICByZXR1cm4gY3Vyc29yUG9zaXRpb24gPj0gYmVmb3JlRGVzY3JpcHRpb24ubGVuZ3RoO1xufVxuIiwgImltcG9ydCB7IFRhc2tMYXlvdXRDb21wb25lbnQgfSBmcm9tICcuLi9MYXlvdXQvVGFza0xheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi9UYXNrL1ByaW9yaXR5JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEZWZhdWx0VGFza1NlcmlhbGl6ZXIsIHRhc2tJZFJlZ2V4LCB0YXNrSWRTZXF1ZW5jZVJlZ2V4IH0gZnJvbSAnLi9EZWZhdWx0VGFza1NlcmlhbGl6ZXInO1xuXG4vKipcbiAqIFRha2VzIGEgcmVnZXggb2YgdGhlIGZvcm0gJ2tleTo6IHZhbHVlJyBhbmQgdHVybnMgaXQgaW50byBhIHJlZ2V4IHRoYXQgY2FuIHBhcnNlXG4gKiBEYXRhdmlldyBpbmxpbmUgZmllbGQsIGkuZSBlaXRoZXI7XG4gKiAgICAgKiAoa2V5OjogdmFsdWUpXG4gKiAgICAgKiBba2V5OjogdmFsdWVdXG4gKlxuICogVGhlcmUgY2FuIGJlIGFuIGFyYml0cmFyeSBhbW91bnQgb2YgaG9yaXpvbnRhbCB3aGl0ZXNwYWNlIGFyb3VuZCB0aGUga2V5IHZhbHVlIHBhaXIsXG4gKiBhbmQgYWZ0ZXIgdGhlICc6OidcbiAqL1xuZnVuY3Rpb24gdG9JbmxpbmVGaWVsZFJlZ2V4KGlubmVyRmllbGRSZWdleDogUmVnRXhwKTogUmVnRXhwIHtcbiAgICAvKipcbiAgICAgKiBGaXJzdCwgSSdtIHNvcnJ5IHRoaXMgbG9va3Mgc28gYmFkLiBKYXZhc2NyaXB0J3MgcmVnZXggZW5naW5lIGxhY2tzIHNvbWVcbiAgICAgKiBjb252ZW5pZW5jZXMgZnJvbSBvdGhlciBlbmdpbmVzIGxpa2UgUENSRSAoZHVwbGljYXRlIG5hbWVkIGdyb3VwcylcbiAgICAgKiB0aGF0IHdvdWxkJ3ZlIG1hZGUgdGhpcyBlYXNpZXIgdG8gZXhwcmVzcyBpbiBhIHJlYWRhYmxlIHdheS5cbiAgICAgKlxuICAgICAqIFRoZSBpZGVhIGhlcmUgaXMgdGhhdCB3ZSdyZSB0cnlpbmcgdG8gc2F5LCBpbiBFbmdsaXNoOlxuICAgICAqXG4gICAgICogICAgIFwie0BsaW5rIGlubmVyRmllbGRSZWdleH0gY2FuIGVpdGhlciBiZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBgW11gXG4gICAgICogICAgIG9yIHBhcmVucyBgKClgXCJcbiAgICAgKlxuICAgICAqIEJ1dCB0aGVyZSBpcyBhZGRlZCBjb21wbGV4aXR5IGJlY2F1c2Ugd2Ugd2FudCB0byBkaXNhbGxvdyBtaXNtYXRjaGVkIHBhaXJzXG4gICAgICogICAoaS5lLiBubyBgW2tleTo6dmFsdWUpIG9yIChrZXk6OnZhbHVlXWApLiBBbmQgd2UgaGF2ZSB0byB0YWtlIGNhcmUgdG8gbm90XG4gICAgICogaW50cm9kdWNlIG5ldyBjYXB0dXJlIGdyb3Vwcywgc2luY2UgaW5uZXJGaWVsZFJlZ2V4IG1heSBjb250YWluIGNhcHR1cmUgZ3JvdXBzXG4gICAgICogYW5kIGRlcGVuZCBvbiB0aGUgbnVtYmVyaW5nLlxuICAgICAqXG4gICAgICogV2UgYWNoaWV2ZSB0aGlzIGJ5IHVzaW5nIGEgdmFyaWFibGUgbGVuZ3RoLCBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gYXNzZXJ0XG4gICAgICogXCJPbmx5IG1hdGNoIGEgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHBhaXIgaWYgdGhlIG90aGVyIGVsZW1lbnQgaXMgc29tZXdoZXJlIGZ1cnRoZXIgaW4gdGhlIHN0cmluZ1wiLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBsaWtlbHkgc29tZXdoYXQgZnJhZ2lsZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IGZpZWxkUmVnZXggPSAoXG4gICAgICAgIFtcbiAgICAgICAgICAgICcoPzonLFxuICAgICAgICAgICAgLyogICAgICovIC8oPz1bXlxcXV0rXFxdKVxcWy8sIC8vIFRyeSB0byBtYXRjaCAnWycgaWYgdGhlcmUncyBhICddJyBsYXRlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAvKiAgICAqLyAnfCcsXG4gICAgICAgICAgICAvKiAgICAgKi8gLyg/PVteKV0rXFwpKVxcKC8sIC8vIE90aGVyd2lzZSwgbWF0Y2ggJygnIGlmIHRoZXJlJ3MgYSAnKScgbGF0ZXIgaW4gdGhlIHN0cmluZ1xuICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgLyAqLyxcbiAgICAgICAgICAgIGlubmVyRmllbGRSZWdleCxcbiAgICAgICAgICAgIC8gKi8sXG4gICAgICAgICAgICAvWylcXF1dLyxcbiAgICAgICAgICAgIC8oPzogKiwpPy8sIC8vIEFsbG93IHRyYWlsaW5nIGNvbW1hLCBlbmFibGVzIHdvcmthcm91bmQgZnJvbSAjMTkxMyBmb3IgcmVuZGVyaW5nIGlzc3VlXG4gICAgICAgICAgICAvJC8sIC8vIFJlZ2V4ZXMgYXJlIG1hdGNoZWQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgZm9yd2FyZHNcbiAgICAgICAgXSBhcyBjb25zdFxuICAgIClcbiAgICAgICAgLm1hcCgodmFsKSA9PiAodmFsIGluc3RhbmNlb2YgUmVnRXhwID8gdmFsLnNvdXJjZSA6IHZhbCkpXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmaWVsZFJlZ2V4LCBpbm5lckZpZWxkUmVnZXguZmxhZ3MpO1xufVxuXG4vKipcbiAqIEEgc3ltYm9sIG1hcCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgdGFzayBmb3JtYXQgdGhhdCBzdHJpdmVzIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogICBbRGF0YXZpZXdde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGFja3NtaXRoZ3Uvb2JzaWRpYW4tZGF0YXZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCBEQVRBVklFV19TWU1CT0xTID0ge1xuICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICBwcmlvcml0eVN5bWJvbHM6IHtcbiAgICAgICAgSGlnaGVzdDogJ3ByaW9yaXR5OjogaGlnaGVzdCcsXG4gICAgICAgIEhpZ2g6ICdwcmlvcml0eTo6IGhpZ2gnLFxuICAgICAgICBNZWRpdW06ICdwcmlvcml0eTo6IG1lZGl1bScsXG4gICAgICAgIExvdzogJ3ByaW9yaXR5OjogbG93JyxcbiAgICAgICAgTG93ZXN0OiAncHJpb3JpdHk6OiBsb3dlc3QnLFxuICAgICAgICBOb25lOiAnJyxcbiAgICB9LFxuICAgIHN0YXJ0RGF0ZVN5bWJvbDogJ3N0YXJ0OjonLFxuICAgIGNyZWF0ZWREYXRlU3ltYm9sOiAnY3JlYXRlZDo6JyxcbiAgICBzY2hlZHVsZWREYXRlU3ltYm9sOiAnc2NoZWR1bGVkOjonLFxuICAgIGR1ZURhdGVTeW1ib2w6ICdkdWU6OicsXG4gICAgcmVtaW5kZXJEYXRlU3ltYm9sOiAncmVtaW5kZXI6OicsXG4gICAgZG9uZURhdGVTeW1ib2w6ICdjb21wbGV0aW9uOjonLFxuICAgIGNhbmNlbGxlZERhdGVTeW1ib2w6ICdjYW5jZWxsZWQ6OicsXG4gICAgcmVjdXJyZW5jZVN5bWJvbDogJ3JlcGVhdDo6JyxcbiAgICBpZFN5bWJvbDogJ2lkOjonLFxuICAgIGRlcGVuZHNPblN5bWJvbDogJ2RlcGVuZHNPbjo6JyxcbiAgICBUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zOiB7XG4gICAgICAgIHByaW9yaXR5UmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvcHJpb3JpdHk6OiAqKGhpZ2hlc3R8aGlnaHxtZWRpdW18bG93fGxvd2VzdCkvKSxcbiAgICAgICAgc3RhcnREYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvc3RhcnQ6OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBjcmVhdGVkRGF0ZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL2NyZWF0ZWQ6OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBzY2hlZHVsZWREYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvc2NoZWR1bGVkOjogKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkvKSxcbiAgICAgICAgZHVlRGF0ZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL2R1ZTo6ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pLyksXG4gICAgICAgIHJlbWluZGVyRGF0ZVRpbWVSZWdleDogdG9JbmxpbmVGaWVsZFJlZ2V4KC9yZW1pbmRlcjo6ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0gXFxkezJ9OlxcZHsyfSkvKSxcbiAgICAgICAgcmVtaW5kZXJEYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvcmVtaW5kZXI6OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBkb25lRGF0ZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL2NvbXBsZXRpb246OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBjYW5jZWxsZWREYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvY2FuY2VsbGVkOjogKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkvKSxcbiAgICAgICAgcmVjdXJyZW5jZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL3JlcGVhdDo6ICooW2EtekEtWjAtOSwgIV0rKS8pLFxuICAgICAgICBkZXBlbmRzT25SZWdleDogdG9JbmxpbmVGaWVsZFJlZ2V4KG5ldyBSZWdFeHAoJ2RlcGVuZHNPbjo6ICooJyArIHRhc2tJZFNlcXVlbmNlUmVnZXguc291cmNlICsgJyknKSksXG4gICAgICAgIGlkUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleChuZXcgUmVnRXhwKCdpZDo6ICooJyArIHRhc2tJZFJlZ2V4LnNvdXJjZSArICcpJykpLFxuICAgIH0sXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEEge0BsaW5rIFRhc2tTZXJpYWxpemVyfSB0aGF0IHRoYXQgcmVhZHMgYW5kIHdyaXRlcyB0YXNrcyBjb21wYXRpYmxlIHdpdGhcbiAqICAgW0RhdGF2aWV3XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYmxhY2tzbWl0aGd1L29ic2lkaWFuLWRhdGF2aWV3fVxuICovXG5leHBvcnQgY2xhc3MgRGF0YXZpZXdUYXNrU2VyaWFsaXplciBleHRlbmRzIERlZmF1bHRUYXNrU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKERBVEFWSUVXX1NZTUJPTFMpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVByaW9yaXR5KHA6IHN0cmluZyk6IFByaW9yaXR5IHtcbiAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICBjYXNlICdoaWdoZXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuSGlnaGVzdDtcbiAgICAgICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTWVkaXVtO1xuICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTG93O1xuICAgICAgICAgICAgY2FzZSAnbG93ZXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTG93ZXN0O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnRUb1N0cmluZyh0YXNrOiBUYXNrLCBzaG9ydE1vZGU6IGJvb2xlYW4sIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBzdHJpbmdDb21wb25lbnQgPSBzdXBlci5jb21wb25lbnRUb1N0cmluZyh0YXNrLCBzaG9ydE1vZGUsIGNvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IG5vdElubGluZUZpZWxkQ29tcG9uZW50czogVGFza0xheW91dENvbXBvbmVudFtdID0gW1xuICAgICAgICAgICAgVGFza0xheW91dENvbXBvbmVudC5CbG9ja0xpbmssXG4gICAgICAgICAgICBUYXNrTGF5b3V0Q29tcG9uZW50LkRlc2NyaXB0aW9uLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzaG91bGRNYWtlSW5saW5lRmllbGQgPSBzdHJpbmdDb21wb25lbnQgIT09ICcnICYmICFub3RJbmxpbmVGaWVsZENvbXBvbmVudHMuaW5jbHVkZXMoY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIHNob3VsZE1ha2VJbmxpbmVGaWVsZFxuICAgICAgICAgICAgPyAvLyBIYXZpbmcgMiAoVFdPKSBsZWFkaW5nIHNwYWNlcyBhdm9pZHMgYSByZW5kZXJpbmcgaXNzdWVzIHRoYXQgbWFrZXMgZXZlcnkgb3RoZXJcbiAgICAgICAgICAgICAgLy8gc3F1YXJlLWJyYWNrZXRlZCBpbmxpbmUtZmllbGQgaW52aXNpYmxlLlxuICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy8xOTEzXG4gICAgICAgICAgICAgIGAgIFske3N0cmluZ0NvbXBvbmVudC50cmltKCl9XWBcbiAgICAgICAgICAgIDogc3RyaW5nQ29tcG9uZW50O1xuICAgIH1cbn1cbiIsICIvKipcbiAqIENvbGxlY3Rpb24gb2Ygc3RhdHVzIHR5cGVzIHN1cHBvcnRlZCBieSB0aGUgcGx1Z2luLlxuICovXG5leHBvcnQgZW51bSBTdGF0dXNUeXBlIHtcbiAgICBUT0RPID0gJ1RPRE8nLFxuICAgIERPTkUgPSAnRE9ORScsXG4gICAgSU5fUFJPR1JFU1MgPSAnSU5fUFJPR1JFU1MnLFxuICAgIENBTkNFTExFRCA9ICdDQU5DRUxMRUQnLFxuICAgIE5PTl9UQVNLID0gJ05PTl9UQVNLJyxcbiAgICBFTVBUWSA9ICdFTVBUWScsXG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHN0b3JlZCBieSB0aGUgT2JzaWRpYW4gY29uZmlndXJhdGlvbiBhbmQgdXNlZCB0byBjcmVhdGUgdGhlIHN0YXR1c1xuICogb2JqZWN0cyBmb3IgdGhlIHNlc3Npb25cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU3RhdHVzQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzQ29uZmlndXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGNoYXJhY3RlciB1c2VkIGJldHdlZW4gdGhlIHR3byBzcXVhcmUgYnJhY2tldHMgaW4gdGhlIG1hcmtkb3duIHRhc2suXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgc3ltYm9sOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBzdGF0dXMgZm9yIGRpc3BsYXkgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBzdGF0dXMgZm9yIGEgdGFzayB3aGVuIHRvZ2dsZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmV4dFN0YXR1c1N5bWJvbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSB0aGVuIGl0IGlzIHJlZ2lzdGVyZWQgYXMgYSBjb21tYW5kIHRoYXQgdGhlIHVzZXIgY2FuIG1hcCB0by5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYXZhaWxhYmxlQXNDb21tYW5kOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdHVzIHR5cGUuIFNlZSB7QGxpbmsgU3RhdHVzVHlwZX0gZm9yIGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFN0YXR1c1R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN0YXR1cy4gVGhlIHJlZ2lzdHJ5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhlIGNhc2VcbiAgICAgKiBvZiB0aGUgZGVmYXVsdCBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBuZXh0U3RhdHVzU3ltYm9sXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhdmFpbGFibGVBc0NvbW1hbmRcbiAgICAgKiBAcGFyYW0ge1N0YXR1c1R5cGV9IHR5cGVcbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHN5bWJvbDogc3RyaW5nLFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIG5leHRTdGF0dXNTeW1ib2w6IHN0cmluZyxcbiAgICAgICAgYXZhaWxhYmxlQXNDb21tYW5kOiBib29sZWFuLFxuICAgICAgICB0eXBlOiBTdGF0dXNUeXBlID0gU3RhdHVzVHlwZS5UT0RPLCAvLyBUT0RPIFJlbW92ZSBkZWZhdWx0IHZhbHVlXG4gICAgKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm5leHRTdGF0dXNTeW1ib2wgPSBuZXh0U3RhdHVzU3ltYm9sO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZUFzQ29tbWFuZCA9IGF2YWlsYWJsZUFzQ29tbWFuZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU3RhdHVzQ29uZmlndXJhdGlvbiwgU3RhdHVzVHlwZSB9IGZyb20gJy4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb25FbnRyeSB9IGZyb20gJy4vU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogVHJhY2tzIHRoZSBwb3NzaWJsZSBzdGF0ZXMgdGhhdCBhIHRhc2sgY2FuIGJlIGluLlxuICpcbiAqIFJlbGF0ZWQgY2xhc3NlczpcbiAqIEBzZWUgU3RhdHVzQ29uZmlndXJhdGlvblxuICogQHNlZSBTdGF0dXNSZWdpc3RyeVxuICogQHNlZSBTdGF0dXNTZXR0aW5nc1xuICogQHNlZSBTdGF0dXNTZXR0aW5nc0hlbHBlcnMudHNcbiAqIEBzZWUgQ3VzdG9tU3RhdHVzTW9kYWxcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU3RhdHVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXMge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IERvbmUgc3RhdHVzLiBHb2VzIHRvIFRvZG8gd2hlbiB0b2dnbGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgRE9ORTogU3RhdHVzID0gU3RhdHVzLm1ha2VEb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgc3RhdHVzIG9mIGVtcHR5LCB1c2VkIHdoZW4gdGhpbmdzIGdvIHdyb25nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIEVNUFRZOiBTdGF0dXMgPSBTdGF0dXMubWFrZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBUb2RvIHN0YXR1cy4gR29lcyB0byBEb25lIHdoZW4gdG9nZ2xlZC5cbiAgICAgKiBVc2VyIG1heSBsYXRlciBiZSBhYmxlIHRvIG92ZXJyaWRlIHRoaXMgdG8gZ28gdG8gSW4gUHJvZ3Jlc3MgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRPRE86IFN0YXR1cyA9IFN0YXR1cy5tYWtlVG9kbygpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gc3RvcmVkIGluIHRoZSBkYXRhLmpzb24gZmlsZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0dXNDb25maWd1cmF0aW9ufVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzeW1ib2wgdXNlZCBiZXR3ZWVuIHRoZSB0d28gc3F1YXJlIGJyYWNrZXRzIGluIHRoZSBtYXJrZG93biB0YXNrLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGdldCBzeW1ib2woKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5zeW1ib2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgc3RhdHVzIGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHN0YXR1cyBmb3IgYSB0YXNrIHdoZW4gdG9nZ2xlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqIEBzZWUgbmV4dFN5bWJvbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbmV4dFN0YXR1c1N5bWJvbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm5leHRTdGF0dXNTeW1ib2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBzdGF0dXMgZm9yIGEgdGFzayB3aGVuIHRvZ2dsZWQuXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIG5leHRTdGF0dXNTeW1ib2x9IHdoaWNoIGlzIHByb3ZpZGVkIGZvciBicmV2aXR5IGluIHVzZXIgc2NyaXB0cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqIEBzZWUgbmV4dFN0YXR1c1N5bWJvbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbmV4dFN5bWJvbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm5leHRTdGF0dXNTeW1ib2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSB0aGVuIGl0IGlzIHJlZ2lzdGVyZWQgYXMgYSBjb21tYW5kIHRoYXQgdGhlIHVzZXIgY2FuIG1hcCB0by5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGF2YWlsYWJsZUFzQ29tbWFuZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5hdmFpbGFibGVBc0NvbW1hbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdHVzIHR5cGUuIFNlZSB7QGxpbmsgU3RhdHVzVHlwZX0gZm9yIGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0eXBlKCk6IFN0YXR1c1R5cGUge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCB0byBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUge0BsaW5rIFN0YXR1c1R5cGV9IGluIGdyb3VwIGhlYWRpbmdzLlxuICAgICAqXG4gICAgICogVGhlIHN0YXR1cyB0eXBlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgZ2l2ZW4gYnkgJ2dyb3VwIGJ5IHN0YXR1cy50eXBlJy5cbiAgICAgKiBUaGlzIGlzIHByb3ZpZGVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHVzZSBpbiBjdXN0b20gZ3JvdXBpbmcuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0eXBlR3JvdXBUZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIGxldCBwcmVmaXg6IHN0cmluZztcbiAgICAgICAgLy8gQWRkIGEgbnVtZXJpYyBwcmVmaXggdG8gc29ydCBpbiB0byBhIG1lYW5pbmdmdWwgb3JkZXIgZm9yIHVzZXJzXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLklOX1BST0dSRVNTOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICcxJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5UT0RPOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICcyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5ET05FOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICczJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5DQU5DRUxMRUQ6XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLk5PTl9UQVNLOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICc1JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5FTVBUWTpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnNic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGV4dCBpbnNpZGUgdGhlICUlLi4lJSBjb21tZW50cyBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIHNvcnRpbmcgaW4gYm90aCBzb3J0aW5nIG9mIHRhc2tzIGFuZCBuYW1pbmcgb2YgZ3JvdXBzLlxuICAgICAgICAvLyBUaGUgY29tbWVudHMgYXJlIGhpZGRlbiBieSBPYnNpZGlhbiB3aGVuIHRoZSBoZWFkaW5ncyBhcmUgcmVuZGVyZWQuXG4gICAgICAgIHJldHVybiBgJSUke3ByZWZpeH0lJSR7dHlwZX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3RhdHVzLiBUaGUgcmVnaXN0cnkgd2lsbCBiZSBhZGRlZCBsYXRlciBpbiB0aGUgY2FzZVxuICAgICAqIG9mIHRoZSBkZWZhdWx0IHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdGF0dXNDb25maWd1cmF0aW9ufSBjb25maWd1cmF0aW9uXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb246IFN0YXR1c0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBEb25lIHN0YXR1cy4gR29lcyB0byBUb2RvIHdoZW4gdG9nZ2xlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZURvbmUoKTogU3RhdHVzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXMobmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJ3gnLCAnRG9uZScsICcgJywgdHJ1ZSwgU3RhdHVzVHlwZS5ET05FKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHN0YXR1cyBvZiBlbXB0eSwgdXNlZCB3aGVuIHRoaW5ncyBnbyB3cm9uZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZUVtcHR5KCk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCcnLCAnRU1QVFknLCAnJywgdHJ1ZSwgU3RhdHVzVHlwZS5FTVBUWSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IFRvZG8gc3RhdHVzLiBHb2VzIHRvIERvbmUgd2hlbiB0b2dnbGVkLlxuICAgICAqIFVzZXIgbWF5IGxhdGVyIGJlIGFibGUgdG8gb3ZlcnJpZGUgdGhpcyB0byBnbyB0byBJbiBQcm9ncmVzcyBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYWtlVG9kbygpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignICcsICdUb2RvJywgJ3gnLCB0cnVlLCBTdGF0dXNUeXBlLlRPRE8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBDYW5jZWxsZWQgc3RhdHVzLiBHb2VzIHRvIFRvZG8gd2hlbiB0b2dnbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYWtlQ2FuY2VsbGVkKCk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCctJywgJ0NhbmNlbGxlZCcsICcgJywgdHJ1ZSwgU3RhdHVzVHlwZS5DQU5DRUxMRUQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBJbiBQcm9ncmVzcyBzdGF0dXMuIEdvZXMgdG8gRG9uZSB3aGVuIHRvZ2dsZWQuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VJblByb2dyZXNzKCk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCcvJywgJ0luIFByb2dyZXNzJywgJ3gnLCB0cnVlLCBTdGF0dXNUeXBlLklOX1BST0dSRVNTKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzYW1wbGUgTm9uLVRhc2sgc3RhdHVzLiBHb2VzIHRvIE5PTl9UQVNLIHdoZW4gdG9nZ2xlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZU5vblRhc2soKTogU3RhdHVzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXMobmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJ1EnLCAnTm9uLVRhc2snLCAnQScsIHRydWUsIFN0YXR1c1R5cGUuTk9OX1RBU0spKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFN0YXR1c1R5cGUgdG8gdXNlIGZvciBhIHN5bWJvbCwgaWYgaXQgaXMgbm90IGluIHRoZSBTdGF0dXNSZWdpc3RyeS5cbiAgICAgKiBUaGUgY29yZSBzeW1ib2xzIGFyZSByZWNvZ25pc2VkLlxuICAgICAqIE90aGVyIHN5bWJvbHMgYXJlIHRyZWF0ZWQgYXMgU3RhdHVzVHlwZS5UT0RPXG4gICAgICogQHBhcmFtIHN5bWJvbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUeXBlRm9yVW5rbm93blN5bWJvbChzeW1ib2w6IHN0cmluZyk6IFN0YXR1c1R5cGUge1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzVHlwZS5ET05FO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1M7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzVHlwZS5DQU5DRUxMRUQ7XG4gICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLkVNUFRZO1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLlRPRE87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRleHQgdGhhdCB3YXMgc2F2ZWQgZnJvbSBhIFN0YXR1c1R5cGUgdmFsdWUgYmFjayB0byBhIFN0YXR1c1R5cGUuXG4gICAgICogUmV0dXJucyBTdGF0dXNUeXBlLlRPRE8gaWYgdGhlIHN0cmluZyBpcyBub3QgdmFsaWQuXG4gICAgICogQHBhcmFtIHN0YXR1c1R5cGVBc1N0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcoc3RhdHVzVHlwZUFzU3RyaW5nOiBzdHJpbmcpOiBTdGF0dXNUeXBlIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGVbc3RhdHVzVHlwZUFzU3RyaW5nIGFzIGtleW9mIHR5cGVvZiBTdGF0dXNUeXBlXSB8fCBTdGF0dXNUeXBlLlRPRE87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU3RhdHVzIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4sIHVua25vd24gc3ltYm9sLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gU3RhdHVzUmVnaXN0cnkgZG9lcyBub3QgcmVjb2duaXNlIGEgc3ltYm9sLFxuICAgICAqIGFuZCB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIHVzZXIncyBkYXRhIHRvIHRoZSBTdGF0dXMuRU1QVFkgc3RhdHVzLlxuICAgICAqXG4gICAgICogVGhlIHR5cGUgaXMgc2V0IHRvIFRPRE8uXG4gICAgICogQHBhcmFtIHVua25vd25TeW1ib2xcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVW5rbm93blN0YXR1cyh1bmtub3duU3ltYm9sOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXMobmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24odW5rbm93blN5bWJvbCwgJ1Vua25vd24nLCAneCcsIGZhbHNlLCBTdGF0dXNUeXBlLlRPRE8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGJ1bGstaW1wb3J0aW5nIHNldHRpbmdzIGZyb20gYXJyYXlzIG9mIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW1wb3J0ZWQgQW4gYXJyYXkgb2Ygc3ltYm9sLCBuYW1lLCBuZXh0IHN5bWJvbCwgc3RhdHVzIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUltcG9ydGVkVmFsdWUoaW1wb3J0ZWQ6IFN0YXR1c0NvbGxlY3Rpb25FbnRyeSkge1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBpbXBvcnRlZFswXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IFN0YXR1cy5nZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcoaW1wb3J0ZWRbM10pO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbihzeW1ib2wsIGltcG9ydGVkWzFdLCBpbXBvcnRlZFsyXSwgZmFsc2UsIHR5cGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wbGV0aW9uIHN0YXR1cyBmb3IgYSB0YXNrLCB0aGlzIGlzIG9ubHkgc3VwcG9ydGVkXG4gICAgICogd2hlbiB0aGUgdGFzayBpcyBkb25lL3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSAge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3RhdHVzVHlwZS5ET05FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHRhc2sgc3RhdHVzIHR5cGUgaXMge0BsaW5rIENBTkNFTExFRH0uXG4gICAgICovXG4gICAgcHVibGljIGlzQ2FuY2VsbGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTdGF0dXNUeXBlLkNBTkNFTExFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGFsbCB0aGUgZmllbGRzIGluIGFub3RoZXIgU3RhdHVzLCB0byBkZXRlY3QgYW55IGRpZmZlcmVuY2VzIGZyb20gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgZmllbGQgaXMgZGlmZmVyZW50IGluIGFueSB3YXksIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyXG4gICAgICovXG4gICAgcHVibGljIGlkZW50aWNhbFRvKG90aGVyOiBTdGF0dXMpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYXJnczogQXJyYXk8a2V5b2YgU3RhdHVzQ29uZmlndXJhdGlvbj4gPSBbXG4gICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICduZXh0U3RhdHVzU3ltYm9sJyxcbiAgICAgICAgICAgICdhdmFpbGFibGVBc0NvbW1hbmQnLFxuICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2VsXSAhPT0gb3RoZXJbZWxdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgb25lLWxpbmUgc3VtbWFyeSBvZiB0aGUgc3RhdHVzLCBmb3IgcHJlc2VudGF0aW9uIHRvIHVzZXJzLlxuICAgICAqL1xuICAgIHB1YmxpYyBwcmV2aWV3VGV4dCgpIHtcbiAgICAgICAgbGV0IGNvbW1hbmROb3RpY2UgPSAnJztcbiAgICAgICAgaWYgKFN0YXR1cy50YXNrc1BsdWdpbkNhbkNyZWF0ZUNvbW1hbmRzRm9yU3RhdHVzZXMoKSAmJiB0aGlzLmF2YWlsYWJsZUFzQ29tbWFuZCkge1xuICAgICAgICAgICAgY29tbWFuZE5vdGljZSA9ICcgQXZhaWxhYmxlIGFzIGEgY29tbWFuZC4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgLSBbJHt0aGlzLnN5bWJvbH1dYCArIC8vIGNvbW1lbnQgdG8gYnJlYWsgbGluZVxuICAgICAgICAgICAgYCA9PiBbJHt0aGlzLm5leHRTdGF0dXNTeW1ib2x9XSxgICtcbiAgICAgICAgICAgIGAgbmFtZTogJyR7dGhpcy5uYW1lfScsYCArXG4gICAgICAgICAgICBgIHR5cGU6ICcke3RoaXMuY29uZmlndXJhdGlvbi50eXBlfScuYCArXG4gICAgICAgICAgICBgJHtjb21tYW5kTm90aWNlfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIFRhc2tzIGNhbiB5ZXQgY3JlYXRlICdUb2dnbGUgU3RhdHVzJyBjb21tYW5kcyBmb3Igc3RhdHVzZXNcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IHlldCBwb3NzaWJsZSwgYW5kIHNvIHNvbWUgVUkgZmVhdHVyZXMgYXJlIHRlbXBvcmFyaWx5IGhpZGRlbi5cbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy8xNDg2XG4gICAgICogT25jZSB0aGF0IGlzc3VlIGlzIGFkZHJlc3NlZCwgdGhpcyBtZXRob2QgY2FuIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB0YXNrc1BsdWdpbkNhbkNyZWF0ZUNvbW1hbmRzRm9yU3RhdHVzZXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNsYXNzIERlYnVnU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKGlnbm9yZVNvcnRJbnN0cnVjdGlvbnMgPSBmYWxzZSwgc2hvd1Rhc2tIaWRkZW5EYXRhID0gZmFsc2UsIHJlY29yZFRpbWluZ3MgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlnbm9yZVNvcnRJbnN0cnVjdGlvbnMgPSBpZ25vcmVTb3J0SW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLnNob3dUYXNrSGlkZGVuRGF0YSA9IHNob3dUYXNrSGlkZGVuRGF0YTtcbiAgICAgICAgdGhpcy5yZWNvcmRUaW1pbmdzID0gcmVjb3JkVGltaW5nczsgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyBQZXJmb3JtYW5jZVRyYWNrZXJcbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IGRpc2FibGUgYWxsIHNvcnRpbmcgb2Ygc2VhcmNoIHJlc3VsdHMsIHNvIHRoYXQgdGFza3MgYXJlXG4gICAgLy8gZGlzcGxheWVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhciBpbiB0aGUgZmlsZS5cbiAgICByZWFkb25seSBpZ25vcmVTb3J0SW5zdHJ1Y3Rpb25zOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHNob3dUYXNrSGlkZGVuRGF0YTogYm9vbGVhbjtcbiAgICByZWFkb25seSByZWNvcmRUaW1pbmdzOiBib29sZWFuO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU3RhdHVzQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1cyc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgZW5jYXBzdWxhdGluZyB0aGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIGN1c3RvbSBzdGF0dXNlcy5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGxpc3RzIG9mIHtAbGluayBTdGF0dXNDb25maWd1cmF0aW9ufSBvYmplY3RzOlxuICpcbiAqIC0ge0BsaW5rIGNvcmVTdGF0dXNlc30gLSB3aGljaCB3aWxsIGFsd2F5cyBoYXZlIHR3byB2YWx1ZXMgaW4uXG4gKiAtIHtAbGluayBjdXN0b21TdGF0dXNlc30gLSB3aGljaCBzdGFydHMgdHdvIHZhbHVlcywgYnV0IHRoZXNlIGNhbiBiZSBkZWxldGVkIGFuZCBtb3JlIGFkZGVkLlxuICpcbiAqIE1vc3QgbWV0aG9kcyBhcmUgc3RhdGljIHRvIGFsbG93IHRoZW0gdG8gYmUgY2FsbGVkIGZyb20gY2FsbC1iYWNrcy5cbiAqXG4gKiBVc2Uge0BsaW5rIGFwcGx5VG9TdGF0dXNSZWdpc3RyeX0gdG8gYXBwbHkgdGhlc2Ugc2V0dGluZ3MgdG8gYSB7QGxpbmsgU3RhdHVzUmVnaXN0cnl9XG4gKlxuICogQHNlZSBTdGF0dXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1c1NldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3JlU3RhdHVzZXMgPSBbXG4gICAgICAgICAgICAvLyBUaGUgdHdvIHN0YXR1c2VzIHRoYXQgZG8gbm90IG5lZWQgQ1NTIHN0eWxpbmdcbiAgICAgICAgICAgIFN0YXR1cy5tYWtlVG9kbygpLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICBTdGF0dXMubWFrZURvbmUoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICBdOyAvLyBEbyBub3QgbW9kaWZ5IGRpcmVjdGx5OiB1c2UgdGhlIHN0YXRpYyBtdXRhdGlvbiBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gICAgICAgIHRoaXMuY3VzdG9tU3RhdHVzZXMgPSBbXG4gICAgICAgICAgICAvLyBBbnkgc3RhdHVzZXMgdGhhdCBhcmUgYWx3YXlzIHN1cHBvcnRlZCwgYnV0IG5lZWQgY3VzdG9tIENTUyBzdHlsaW5nXG4gICAgICAgICAgICBTdGF0dXMubWFrZUluUHJvZ3Jlc3MoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgU3RhdHVzLm1ha2VDYW5jZWxsZWQoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICBdOyAvLyBEbyBub3QgbW9kaWZ5IGRpcmVjdGx5OiB1c2UgdGhlIHN0YXRpYyBtdXRhdGlvbiBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gICAgfVxuICAgIHJlYWRvbmx5IGNvcmVTdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdO1xuICAgIHJlYWRvbmx5IGN1c3RvbVN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW107XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgY3VzdG9tIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc3RhdGljIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIG1vZGFsIG9uQ2xpY2soKSBjYWxsLWJhY2tzLlxuICAgICAqXG4gICAgICogLSBDdXJyZW50bHksIGR1cGxpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gICAgICogLSBBbGxvd3MgZW1wdHkgU3RhdHVzQ29uZmlndXJhdGlvbiBvYmplY3RzIC0gd2hlcmUgZXZlcnkgc3RyaW5nIGlzIGVtcHR5XG4gICAgICogQHBhcmFtIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIG5ld1N0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkU3RhdHVzKHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10sIG5ld1N0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBzdGF0dXNlcy5wdXNoKG5ld1N0YXR1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZ2l2ZW4gc3RhdHVzLCB0byBlZmZlY3RpdmVseSBlZGl0IGl0LlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2V0dGluZ3Mgd2VyZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBzdGF0aWMgc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gbW9kYWwgb25DbGljaygpIGNhbGwtYmFja3MuXG4gICAgICpcbiAgICAgKiAtIERvZXMgbm90IGN1cnJlbnRseSBjaGVjayB3aGV0aGVyIHRoZSBzdGF0dXMgY2hhcmFjdGVyIGlzIHRoZSBzYW1lXG4gICAgICogLSBJZiB0aGUgc3RhdHVzIGNoYXJhY3RlciBpcyBkaWZmZXJlbnQsIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBvbmUgaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgc3RhdHVzXG4gICAgICogQHBhcmFtIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIG9yaWdpbmFsU3RhdHVzXG4gICAgICogQHBhcmFtIG5ld1N0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVwbGFjZVN0YXR1cyhcbiAgICAgICAgc3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSxcbiAgICAgICAgb3JpZ2luYWxTdGF0dXM6IFN0YXR1c0NvbmZpZ3VyYXRpb24sXG4gICAgICAgIG5ld1N0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbixcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRTdGF0dXNJbmRleChvcmlnaW5hbFN0YXR1cywgc3RhdHVzZXMpO1xuICAgICAgICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXNlcy5zcGxpY2UoaW5kZXgsIDEsIG5ld1N0YXR1cyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgZmFjdCB0aGF0IHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c1R5cGVzLmluZGV4T2Yoc3RhdHVzQ29uZmlndXJhdGlvbilcbiAgICAgKiBzdG9wcGVkIGZpbmRpbmcgaWRlbnRpY2FsIHN0YXR1c2VzIHNpbmNlIHRoZSBhZGRpdGlvbiBvZiBTdGF0dXNDb25maWd1cmF0aW9uLnR5cGUuXG4gICAgICogQHBhcmFtIHN0YXR1c0NvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gc3RhdHVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGZpbmRTdGF0dXNJbmRleChzdGF0dXNDb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uLCBzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdHVzQXNTdGF0dXMgPSBuZXcgU3RhdHVzKHN0YXR1c0NvbmZpZ3VyYXRpb24pO1xuICAgICAgICByZXR1cm4gc3RhdHVzZXMuZmluZEluZGV4KChzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhzKS5wcmV2aWV3VGV4dCgpID09IG9yaWdpbmFsU3RhdHVzQXNTdGF0dXMucHJldmlld1RleHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBnaXZlbiBzdGF0dXMuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGRlbGV0ZWQsIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNlc1xuICAgICAqIEBwYXJhbSBzdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVN0YXR1cyhzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdLCBzdGF0dXM6IFN0YXR1c0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRTdGF0dXNJbmRleChzdGF0dXMsIHN0YXR1c2VzKTtcbiAgICAgICAgaWYgKGluZGV4IDw9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHVzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFsbCBjdXN0b20gc3RhdHVzZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlQWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzKSB7XG4gICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLnNwbGljZSgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBkZWZhdWx0IGN1c3RvbSBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVzZXRBbGxDdXN0b21TdGF0dXNlcyhzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MpIHtcbiAgICAgICAgU3RhdHVzU2V0dGluZ3MuZGVsZXRlQWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3MpO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3MgPSBuZXcgU3RhdHVzU2V0dGluZ3MoKTtcbiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmN1c3RvbVN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLmFkZFN0YXR1cyhzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcywgcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbGxlY3Rpb24gb2YgY3VzdG9tIHN1cHBvcnRlZCBzdGF0dXNlcyB0byBhIFN0YXR1c1NldHRpbmdzLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcXVpY2tseSBwb3B1bGF0ZSB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgICAqIElmIHRoZXJlIGFyZSBhbnkgZXhhY3QgZHVwbGljYXRlcyBhbHJlYWR5IHByZXNlbnQsIHRoZXkgYXJlIHNraXBwZWQsIGFuZCBub3RlZCBpbiB0aGUgcmV0dXJuZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5ncyBhIFN0YXR1c1NldHRpbmdzXG4gICAgICogQHBhcmFtIHN1cHBvcnRlZFN0YXR1c2VzIC0gYW4gYXJyYXkgb2Ygc3RhdHVzIHNwZWNpZmljYXRpb25zLCBmb3IgZXhhbXBsZSBgWydiJywgJ0Jvb2ttYXJrJywgJ3gnXWBcbiAgICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIHdhcm5pbmcgbWVzc2FnZXMgdG8gc2hvdyB0aGUgdXNlciwgb25lIGZvciBlYWNoIHJlamVjdGVkIGV4YWN0IGR1cGxpY2F0ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtaW5pbWFsU3VwcG9ydGVkU3RhdHVzZXN9LCB7QGxpbmsgaXRzU3VwcG9ydGVkU3RhdHVzZXN9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBidWxrQWRkU3RhdHVzQ29sbGVjdGlvbihcbiAgICAgICAgc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzLFxuICAgICAgICBzdXBwb3J0ZWRTdGF0dXNlczogU3RhdHVzQ29sbGVjdGlvbixcbiAgICApOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IG5vdGljZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIHN1cHBvcnRlZFN0YXR1c2VzLmZvckVhY2goKGltcG9ydGVkU3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGF0dXMgPSBzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcy5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zeW1ib2wgPT0gaW1wb3J0ZWRTdGF0dXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5uYW1lID09IGltcG9ydGVkU3RhdHVzWzFdICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubmV4dFN0YXR1c1N5bWJvbCA9PSBpbXBvcnRlZFN0YXR1c1syXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaGFzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgU3RhdHVzU2V0dGluZ3MuYWRkU3RhdHVzKHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLCBTdGF0dXMuY3JlYXRlRnJvbUltcG9ydGVkVmFsdWUoaW1wb3J0ZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90aWNlcy5wdXNoKGBUaGUgc3RhdHVzICR7aW1wb3J0ZWRTdGF0dXNbMV19ICgke2ltcG9ydGVkU3RhdHVzWzBdfSkgaXMgYWxyZWFkeSBhZGRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub3RpY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVuIGEgbGlzdCBvZiBhbGwgdGhlIHN0YXR1c2VzIGluIHRoZSBzZXR0aW5ncyAtIGZpcnN0IHRoZSBjb3JlIG9uZXMsIHRoZW4gdGhlIGN1c3RvbSBvbmVzLlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWxsU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXNTZXR0aW5ncy5jb3JlU3RhdHVzZXMuY29uY2F0KHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgY3VzdG9tIHN0YXR1c2VzIGluIHRoZSBzdGF0dXNTZXR0aW5ncyBvYmplY3QgdG8gdGhlIHN0YXR1c1JlZ2lzdHJ5LlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqIEBwYXJhbSBzdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXBwbHlUb1N0YXR1c1JlZ2lzdHJ5KHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncywgc3RhdHVzUmVnaXN0cnk6IFN0YXR1c1JlZ2lzdHJ5KSB7XG4gICAgICAgIHN0YXR1c1JlZ2lzdHJ5LmNsZWFyU3RhdHVzZXMoKTtcbiAgICAgICAgU3RhdHVzU2V0dGluZ3MuYWxsU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3MpLmZvckVhY2goKHN0YXR1c1R5cGUpID0+IHtcbiAgICAgICAgICAgIHN0YXR1c1JlZ2lzdHJ5LmFkZChzdGF0dXNUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCBmZWF0dXJlc0pzb24gZnJvbSAnLi9mZWF0dXJlQ29uZmlndXJhdGlvbi5qc29uJztcblxuZXhwb3J0IHR5cGUgRmVhdHVyZUZsYWcgPSB7XG4gICAgW2ludGVybmFsTmFtZTogc3RyaW5nXTogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogVGhlIEZlYXR1cmUgY2xhc3MgdHJhY2tzIGFsbCB0aGUgcG9zc2libGUgZmVhdHVyZXMgdGhhdCB1c2VycyBjYW4gZW5hYmxlZCB0aGF0IGFyZSBpbiBkZXZlbG9wbWVudC4gVGhpcyBhbGxvd3NcbiAqIG5ldyBmZWF0dXJlcyB0byBiZSBhZGRlZCB0byB0aGUgcGxhdGZvcm0gYnV0IG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQuIFRoaXMgcmVkdWNlcyB0aGUgY29tcGxpY2F0aW9ucyB3aGVuIGl0XG4gKiBjb21lcyB0byBhZGRpbmcgbmV3IGZlYXR1cmVzIGFuZCBhIGxhcmdlIGNhc2NhZGUgb2YgZGVwZW5kZW50IGJyYW5jaGVzLlxuICpcbiAqIFdoZW4geW91IGFkZCBhIG5ldyBmZWF0dXJlIHlvdSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZmVhdHVyZUNvbmZpZ3VyYXRpb24uanNvbiBmaWxlLiBJdCB0aGVuIG5lZWRzIHRvIGJlIGFkZGVkIHRvXG4gKiBzZXR0aW5ncyBzbyBhIHVzZXIgY2FuIGVuYWJsZSBpdC4gSWYgeW91IHdhbnQgaXQgaGlkZGVuIHlvdSB3aWxsIG5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIHRoZSBkYXRhLmpzb24gZmlsZS4gSW4gdGhlXG4gKiBwbHVnaW4gZm9sZGVyLlxuICpcbiAqIEBzaW5jZSAyMDIyLTA1LTI5XG4gKi9cbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgaW50ZXJuYWxOYW1lOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBpbmRleDogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBlbmFibGVkQnlEZWZhdWx0OiBib29sZWFuLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgc3RhYmxlOiBib29sZWFuLFxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RmVhdHVyZVtdfVxuICAgICAqIEBtZW1iZXJvZiBGZWF0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGdldCB2YWx1ZXMoKTogRmVhdHVyZVtdIHtcbiAgICAgICAgbGV0IGF2YWlsYWJsZUZlYXR1cmVzOiBGZWF0dXJlW10gPSBbXTtcblxuICAgICAgICBmZWF0dXJlc0pzb24uZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgYXZhaWxhYmxlRmVhdHVyZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uYXZhaWxhYmxlRmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgbmV3IEZlYXR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaW50ZXJuYWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmVuYWJsZWRCeURlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3RhYmxlLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZUZlYXR1cmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIGZlYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0ZlYXR1cmVGbGFnfVxuICAgICAqIEBtZW1iZXJvZiBGZWF0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBzZXR0aW5nc0ZsYWdzKCk6IEZlYXR1cmVGbGFnIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZUZsYWdzOiB7IFtpbnRlcm5hbE5hbWU6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4gICAgICAgIEZlYXR1cmUudmFsdWVzLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGZlYXR1cmVGbGFnc1tmZWF0dXJlLmludGVybmFsTmFtZV0gPSBmZWF0dXJlLmVuYWJsZWRCeURlZmF1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZUZsYWdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbmFtZSB0byBpdHMgY29ycmVzcG9uZGluZyBkZWZhdWx0IEZlYXR1cmUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBjb252ZXJ0IHRvIEZlYXR1cmVcbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IsIGlmIGEgc3RyaW5nIHRoYXQgaGFzIG5vIGNvcnJlc3BvbmRpbmcgRmVhdHVyZSB2YWx1ZSB3YXMgcGFzc2VkLlxuICAgICAqIEByZXR1cm5zIHRoZSBtYXRjaGluZyBGZWF0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcobmFtZTogc3RyaW5nKTogRmVhdHVyZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBGZWF0dXJlLnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGZlYXR1cmUuaW50ZXJuYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgIGBJbGxlZ2FsIGFyZ3VtZW50IHBhc3NlZCB0byBmcm9tU3RyaW5nKCk6ICR7bmFtZX0gZG9lcyBub3QgY29ycmVzcG9uZCB0byBhbnkgYXZhaWxhYmxlIEZlYXR1cmUgJHtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBERUZBVUxUX01BWF9HRU5FUklDX1NVR0dFU1RJT05TLFxuICAgIG1ha2VEZWZhdWx0U3VnZ2VzdGlvbkJ1aWxkZXIsXG4gICAgb25seVN1Z2dlc3RJZkJyYWNrZXRPcGVuLFxufSBmcm9tICcuLi9TdWdnZXN0b3IvU3VnZ2VzdG9yJztcbmltcG9ydCB7IERFRkFVTFRfU1lNQk9MUyB9IGZyb20gJy4uL1Rhc2tTZXJpYWxpemVyL0RlZmF1bHRUYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgeyBEQVRBVklFV19TWU1CT0xTIH0gZnJvbSAnLi4vVGFza1NlcmlhbGl6ZXIvRGF0YXZpZXdUYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXMnO1xuaW1wb3J0IHsgRGVmYXVsdFRhc2tTZXJpYWxpemVyLCB0eXBlIFRhc2tTZXJpYWxpemVyIH0gZnJvbSAnLi4vVGFza1NlcmlhbGl6ZXInO1xuaW1wb3J0IHR5cGUgeyBTdWdnZXN0aW9uQnVpbGRlciB9IGZyb20gJy4uL1N1Z2dlc3Rvcic7XG5pbXBvcnQgdHlwZSB7IExvZ09wdGlvbnMgfSBmcm9tICcuLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQgeyBEYXRhdmlld1Rhc2tTZXJpYWxpemVyIH0gZnJvbSAnLi4vVGFza1NlcmlhbGl6ZXIvRGF0YXZpZXdUYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgeyBEZWJ1Z1NldHRpbmdzIH0gZnJvbSAnLi9EZWJ1Z1NldHRpbmdzJztcbmltcG9ydCB7IFN0YXR1c1NldHRpbmdzIH0gZnJvbSAnLi9TdGF0dXNTZXR0aW5ncyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi9GZWF0dXJlJztcbmltcG9ydCB0eXBlIHsgRmVhdHVyZUZsYWcgfSBmcm9tICcuL0ZlYXR1cmUnO1xuXG5pbnRlcmZhY2UgU2V0dGluZ3NNYXAge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIEhlYWRpbmdTdGF0ZSA9IHtcbiAgICBbaWQ6IHN0cmluZ106IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIEludGVyZmFjZSBlbmNhcHN1bGF0aW5nIGhvdyBhIFRhc2sgaXMgd3JpdHRlbiB0byBhbmQgcmVhZCBmcm9tIHRleHRcbiAqXG4gKi9cbmludGVyZmFjZSBUYXNrRm9ybWF0IHtcbiAgICAvKiogVXNlciBmYWNpbmcgbmFtZSBvZiB0aGUge0BsaW5rIFRhc2tGb3JtYXR9ICovXG4gICAgZGlzcGxheU5hbWU6IHN0cmluZztcbiAgICAvKioge0BsaW5rIFRhc2tTZXJpYWxpemVyfSByZXNwb25zaWJsZSBmb3IgcmVhZGluZyBUYXNrcyBmcm9tIHRleHQgYW5kIHdyaXRpbmcgdGhlbSBiYWNrIGludG8gdGV4dCAqL1xuICAgIHRhc2tTZXJpYWxpemVyOiBUYXNrU2VyaWFsaXplcjtcbiAgICAvKiogRnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgSW50ZWxsaXNlbnNlLWxpa2Ugc3VnZ2VzdGlvbnMgYXMgYSB1c2VyIGlzIHR5cGluZyBhIFRhc2sgKi9cbiAgICBidWlsZFN1Z2dlc3Rpb25zPzogU3VnZ2VzdGlvbkJ1aWxkZXI7XG59XG5cbi8qKiBNYXAgb2YgYWxsIGRlZmluZWQge0BsaW5rIFRhc2tGb3JtYXR9cyAqL1xuZXhwb3J0IGNvbnN0IFRBU0tfRk9STUFUUyA9IHtcbiAgICB0YXNrc1BsdWdpbkVtb2ppOiB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiAnVGFza3MgRW1vamkgRm9ybWF0JyxcbiAgICAgICAgdGFza1NlcmlhbGl6ZXI6IG5ldyBEZWZhdWx0VGFza1NlcmlhbGl6ZXIoREVGQVVMVF9TWU1CT0xTKSxcbiAgICAgICAgYnVpbGRTdWdnZXN0aW9uczogbWFrZURlZmF1bHRTdWdnZXN0aW9uQnVpbGRlcihERUZBVUxUX1NZTUJPTFMsIERFRkFVTFRfTUFYX0dFTkVSSUNfU1VHR0VTVElPTlMsIGZhbHNlKSxcbiAgICB9LFxuICAgIGRhdGF2aWV3OiB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiAnRGF0YXZpZXcnLFxuICAgICAgICB0YXNrU2VyaWFsaXplcjogbmV3IERhdGF2aWV3VGFza1NlcmlhbGl6ZXIoKSxcbiAgICAgICAgYnVpbGRTdWdnZXN0aW9uczogb25seVN1Z2dlc3RJZkJyYWNrZXRPcGVuKFxuICAgICAgICAgICAgbWFrZURlZmF1bHRTdWdnZXN0aW9uQnVpbGRlcihEQVRBVklFV19TWU1CT0xTLCBERUZBVUxUX01BWF9HRU5FUklDX1NVR0dFU1RJT05TLCB0cnVlKSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbJygnLCAnKSddLFxuICAgICAgICAgICAgICAgIFsnWycsICddJ10sXG4gICAgICAgICAgICBdLFxuICAgICAgICApLFxuICAgIH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBUQVNLX0ZPUk1BVFMgPSB0eXBlb2YgVEFTS19GT1JNQVRTOyAvLyBGb3IgY29udmVuaWVuY2UgdG8gbWFrZSBzb21lIHR5cGluZyBlYXNpZXJcblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5ncyB7XG4gICAgZ2xvYmFsUXVlcnk6IHN0cmluZztcbiAgICBnbG9iYWxGaWx0ZXI6IHN0cmluZztcbiAgICByZW1vdmVHbG9iYWxGaWx0ZXI6IGJvb2xlYW47XG4gICAgdGFza0Zvcm1hdDoga2V5b2YgVEFTS19GT1JNQVRTO1xuICAgIHNldENyZWF0ZWREYXRlOiBib29sZWFuO1xuICAgIHNldERvbmVEYXRlOiBib29sZWFuO1xuICAgIHNldENhbmNlbGxlZERhdGU6IGJvb2xlYW47XG4gICAgYXV0b1N1Z2dlc3RJbkVkaXRvcjogYm9vbGVhbjtcbiAgICBhdXRvU3VnZ2VzdE1pbk1hdGNoOiBudW1iZXI7XG4gICAgYXV0b1N1Z2dlc3RNYXhJdGVtczogbnVtYmVyO1xuICAgIHByb3ZpZGVBY2Nlc3NLZXlzOiBib29sZWFuO1xuICAgIHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlOiBib29sZWFuO1xuICAgIGZpbGVuYW1lQXNEYXRlRm9sZGVyczogc3RyaW5nW107XG4gICAgcmVjdXJyZW5jZU9uTmV4dExpbmU6IGJvb2xlYW47XG5cbiAgICAvLyBUaGUgY3VzdG9tIHN0YXR1cyBzdGF0ZXMuXG4gICAgc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzO1xuXG4gICAgLy8gQ29sbGVjdGlvbiBvZiBmZWF0dXJlIGZsYWcgSURzIGFuZCB0aGVpciBzdGF0ZS5cbiAgICBmZWF0dXJlczogRmVhdHVyZUZsYWc7XG5cbiAgICAvLyBTZXR0aW5ncyBhcmUgbW92ZWQgdG8gYSBtb3JlIGdlbmVyYWwgbWFwIHRvIGFsbG93IHRoZSBzZXR0aW5ncyBVSSB0byBiZVxuICAgIC8vIGR5bmFtaWNhbGx5IGdlbmVyYXRlZC5cbiAgICBnZW5lcmFsU2V0dGluZ3M6IFNldHRpbmdzTWFwO1xuXG4gICAgLy8gVHJhY2tzIHRoZSBzdGFnZSBvZiB0aGUgaGVhZGluZ3MgaW4gdGhlIHNldHRpbmdzIFVJLlxuICAgIGhlYWRpbmdPcGVuZWQ6IEhlYWRpbmdTdGF0ZTtcbiAgICBkZWJ1Z1NldHRpbmdzOiBEZWJ1Z1NldHRpbmdzO1xuXG4gICAgbG9nZ2luZ09wdGlvbnM6IExvZ09wdGlvbnM7XG59XG5cbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogU2V0dGluZ3MgPSB7XG4gICAgZ2xvYmFsUXVlcnk6ICcnLFxuICAgIGdsb2JhbEZpbHRlcjogJycsXG4gICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiBmYWxzZSxcbiAgICB0YXNrRm9ybWF0OiAndGFza3NQbHVnaW5FbW9qaScsXG4gICAgc2V0Q3JlYXRlZERhdGU6IGZhbHNlLFxuICAgIHNldERvbmVEYXRlOiB0cnVlLFxuICAgIHNldENhbmNlbGxlZERhdGU6IHRydWUsXG4gICAgYXV0b1N1Z2dlc3RJbkVkaXRvcjogdHJ1ZSxcbiAgICBhdXRvU3VnZ2VzdE1pbk1hdGNoOiAwLFxuICAgIGF1dG9TdWdnZXN0TWF4SXRlbXM6IDYsXG4gICAgcHJvdmlkZUFjY2Vzc0tleXM6IHRydWUsXG4gICAgdXNlRmlsZW5hbWVBc1NjaGVkdWxlZERhdGU6IGZhbHNlLFxuICAgIGZpbGVuYW1lQXNEYXRlRm9sZGVyczogW10sXG4gICAgcmVjdXJyZW5jZU9uTmV4dExpbmU6IGZhbHNlLFxuICAgIHN0YXR1c1NldHRpbmdzOiBuZXcgU3RhdHVzU2V0dGluZ3MoKSxcbiAgICBmZWF0dXJlczogRmVhdHVyZS5zZXR0aW5nc0ZsYWdzLFxuICAgIGdlbmVyYWxTZXR0aW5nczoge1xuICAgICAgICAvKiBQcmV2ZW50IGR1cGxpY2F0ZSB2YWx1ZXMgaW4gdXNlciBzZXR0aW5ncyBmb3Igbm93LFxuICAgICAgICAgICBhdCBsZWFzdCB1bnRpbCBJIHN0YXJ0IHBvcnRpbmcgdGhlIHByZS0xLjIzLjAgc2V0dGluZ3NcbiAgICAgICAgICAgY29kZSB0byBiZSBnZW5lcmF0ZWQgZnJvbSBzZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGdsb2JhbEZpbHRlcjogJycsXG4gICAgICAgIC8vIHJlbW92ZUdsb2JhbEZpbHRlcjogZmFsc2UsXG4gICAgICAgIC8vIHNldERvbmVEYXRlOiB0cnVlLFxuICAgIH0sXG4gICAgaGVhZGluZ09wZW5lZDoge30sXG4gICAgZGVidWdTZXR0aW5nczogbmV3IERlYnVnU2V0dGluZ3MoKSxcblxuICAgIC8qXG4gICAgYGxvZ2dpbmdPcHRpb25zYCBpcyBhIHByb3BlcnR5IGluIHRoZSBgU2V0dGluZ3NgIGludGVyZmFjZSB0aGF0IGRlZmluZXMgdGhlIGxvZ2dpbmcgb3B0aW9ucyBmb3JcbiAgICB0aGUgYXBwbGljYXRpb24uIEl0IGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgYG1pbkxldmVsc2AgcHJvcGVydHksIHdoaWNoIGlzIGEgbWFwIG9mIGxvZ2dlclxuICAgIG5hbWVzIHRvIHRoZWlyIG1pbmltdW0gbG9nZ2luZyBsZXZlbHMuIFRoaXMgYWxsb3dzIHRoZSBhcHBsaWNhdGlvbiB0byBjb250cm9sIHRoZSBhbW91bnQgb2ZcbiAgICBsb2dnaW5nIG91dHB1dCBiYXNlZCBvbiB0aGUgbG9nZ2VyIG5hbWUgYW5kIHRoZSBtaW5pbXVtIGxvZ2dpbmcgbGV2ZWwuIEZvciBleGFtcGxlLCB0aGUgbG9nZ2VyXG4gICAgbmFtZSBgdGFza3NgIG1pZ2h0IGhhdmUgYSBtaW5pbXVtIGxvZ2dpbmcgbGV2ZWwgb2YgYGRlYnVnYCwgd2hpbGUgdGhlIHJvb3QgbG9nZ2VyIG1pZ2h0IGhhdmUgYVxuICAgIG1pbmltdW0gbG9nZ2luZyBsZXZlbCBvZiBgaW5mb2AuXG4gICAgKi9cbiAgICBsb2dnaW5nT3B0aW9uczoge1xuICAgICAgICBtaW5MZXZlbHM6IHtcbiAgICAgICAgICAgICcnOiAnaW5mbycsXG4gICAgICAgICAgICB0YXNrczogJ2luZm8nLFxuICAgICAgICAgICAgJ3Rhc2tzLkNhY2hlJzogJ2luZm8nLCAvLyBDYWNoZS50c1xuICAgICAgICAgICAgJ3Rhc2tzLkV2ZW50cyc6ICdpbmZvJywgLy8gVGFza3NFdmVudHMudHNcbiAgICAgICAgICAgICd0YXNrcy5GaWxlJzogJ2luZm8nLCAvLyBGaWxlLnRzXG4gICAgICAgICAgICAndGFza3MuUXVlcnknOiAnaW5mbycsIC8vIFF1ZXJ5LnRzICYgUXVlcnlSZW5kZXJlci50c1xuICAgICAgICAgICAgJ3Rhc2tzLlRhc2snOiAnaW5mbycsIC8vIFRhc2sudHNcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxubGV0IHNldHRpbmdzOiBTZXR0aW5ncyA9IHsgLi4uZGVmYXVsdFNldHRpbmdzIH07XG5cbmZ1bmN0aW9uIGFkZE5ld09wdGlvbnNUb1VzZXJTZXR0aW5nczxLZXlzQW5kVmFsdWVzPihkZWZhdWx0VmFsdWVzOiBLZXlzQW5kVmFsdWVzLCB1c2VyVmFsdWVzOiBLZXlzQW5kVmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBmbGFnIGluIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHVzZXJWYWx1ZXNbZmxhZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlclZhbHVlc1tmbGFnXSA9IGRlZmF1bHRWYWx1ZXNbZmxhZ107XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzZXR0aW5ncyBhcyBhIG9iamVjdCwgaXQgd2lsbCBhbHNvIGNoZWNrIGFuZFxuICogdXBkYXRlIHRoZSBmbGFncyB0byBtYWtlIHN1cmUgdGhleSBhcmUgYWxsIHNob3duIGluIHRoZSBkYXRhLmpzb25cbiAqIGZpbGUuIEV4cG9zdXJlIHZpYSB0aGUgc2V0dGluZ3MgVUkgaXMgb3B0aW9uYWwuXG4gKlxuICogQGV4cG9ydFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgZ2V0U2V0dGluZ3MgPSAoKTogU2V0dGluZ3MgPT4ge1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IG5ldyBvcHRpb25zIHRoYXQgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgIGFkZE5ld09wdGlvbnNUb1VzZXJTZXR0aW5ncyhGZWF0dXJlLnNldHRpbmdzRmxhZ3MsIHNldHRpbmdzLmZlYXR1cmVzKTtcbiAgICBhZGROZXdPcHRpb25zVG9Vc2VyU2V0dGluZ3MoZGVmYXVsdFNldHRpbmdzLmxvZ2dpbmdPcHRpb25zLm1pbkxldmVscywgc2V0dGluZ3MubG9nZ2luZ09wdGlvbnMubWluTGV2ZWxzKTtcbiAgICBhZGROZXdPcHRpb25zVG9Vc2VyU2V0dGluZ3MoZGVmYXVsdFNldHRpbmdzLmRlYnVnU2V0dGluZ3MsIHNldHRpbmdzLmRlYnVnU2V0dGluZ3MpO1xuXG4gICAgLy8gSW4gY2FzZSBzYXZlcyBwcmUtZGF0ZWQgU3RhdHVzQ29uZmlndXJhdGlvbi50eXBlXG4gICAgLy8gVE9ETyBTcGVjaWFsIGNhc2UgZm9yIHN5bWJvbCAnWCcgb3IgJ3gnIChqdXN0IGluIGNhc2UpXG4gICAgc2V0dGluZ3Muc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuZm9yRWFjaCgocywgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1R5cGUgPSBTdGF0dXMuZ2V0VHlwZUZyb21TdGF0dXNUeXBlU3RyaW5nKHMudHlwZSk7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgcy5zeW1ib2wgPz8gJyAnLFxuICAgICAgICAgICAgcy5uYW1lLFxuICAgICAgICAgICAgcy5uZXh0U3RhdHVzU3ltYm9sID8/ICd4JyxcbiAgICAgICAgICAgIHMuYXZhaWxhYmxlQXNDb21tYW5kLFxuICAgICAgICAgICAgbmV3VHlwZSxcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IC4uLnNldHRpbmdzIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSAobmV3U2V0dGluZ3M6IFBhcnRpYWw8U2V0dGluZ3M+KTogU2V0dGluZ3MgPT4ge1xuICAgIHNldHRpbmdzID0geyAuLi5zZXR0aW5ncywgLi4ubmV3U2V0dGluZ3MgfTtcblxuICAgIHJldHVybiBnZXRTZXR0aW5ncygpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlc2V0U2V0dGluZ3MgPSAoKTogU2V0dGluZ3MgPT4ge1xuICAgIHJldHVybiB1cGRhdGVTZXR0aW5ncyhkZWZhdWx0U2V0dGluZ3MpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUdlbmVyYWxTZXR0aW5nID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IGJvb2xlYW4pOiBTZXR0aW5ncyA9PiB7XG4gICAgc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW25hbWVdID0gdmFsdWU7XG5cbiAgICAvKiBQcmV2ZW50IGR1cGxpY2F0ZSB2YWx1ZXMgaW4gdXNlciBzZXR0aW5ncyBmb3Igbm93LFxuICAgICAgIGF0IGxlYXN0IHVudGlsIEkgc3RhcnQgcG9ydGluZyB0aGUgcHJlLTEuMjMuMCBzZXR0aW5nc1xuICAgICAgIGNvZGUgdG8gYmUgZ2VuZXJhdGVkIGZyb20gc2V0dGluZ3NDb25maWd1cmF0aW9uLmpzb24uXG4gICAgICovXG4gICAgLy8gc3luYyB0aGUgb2xkIHNldHRpbmdzIGZvciB0aGUgbW9tZW50IHNvIGEgbGFyZ2VyIGNoYW5nZSBpcyBub3QgbmVlZGVkLlxuICAgIC8vIHVwZGF0ZVNldHRpbmdzKHtcbiAgICAvLyAgICAgZ2xvYmFsRmlsdGVyOiA8c3RyaW5nPnNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1snZ2xvYmFsRmlsdGVyJ10sXG4gICAgLy8gICAgIHJlbW92ZUdsb2JhbEZpbHRlcjogPGJvb2xlYW4+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzWydyZW1vdmVHbG9iYWxGaWx0ZXInXSxcbiAgICAvLyAgICAgc2V0RG9uZURhdGU6IDxib29sZWFuPnNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1snc2V0RG9uZURhdGUnXSxcbiAgICAvLyB9KTtcblxuICAgIHJldHVybiBnZXRTZXR0aW5ncygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBmZWF0dXJlIGZyb20gc2V0dGluZ3MuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIGludGVybmFsTmFtZSB0aGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgZmVhdHVyZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRmVhdHVyZUVuYWJsZWQgPSAoaW50ZXJuYWxOYW1lOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gc2V0dGluZ3MuZmVhdHVyZXNbaW50ZXJuYWxOYW1lXSA/PyBmYWxzZTtcbn07XG5cbi8qKlxuICogZW5hYmxlcyB0b2dnbGluZyB0aGUgZmVhdHVyZSBhbmQgcmV0dXJuaW5nIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gd2l0aCBzdGF0ZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gaW50ZXJuYWxOYW1lIHRoZSBpbnRlcm5hbCBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICogQHBhcmFtIGVuYWJsZWQgdGhlIGV4cGVjdGVkIHN0YXRlIG9mIHRoZSBmZWF0dXJlLlxuICogQHJldHVybnMgdGhlIGZlYXR1cmVzIHdpdGggdGhlIHNwZWNpZmllZCBmZWF0dXJlIHRvZ2dsZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGZWF0dXJlID0gKGludGVybmFsTmFtZTogc3RyaW5nLCBlbmFibGVkOiBib29sZWFuKTogRmVhdHVyZUZsYWcgPT4ge1xuICAgIHNldHRpbmdzLmZlYXR1cmVzW2ludGVybmFsTmFtZV0gPSBlbmFibGVkO1xuICAgIHJldHVybiBzZXR0aW5ncy5mZWF0dXJlcztcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB7QGxpbmsgVGFza0Zvcm1hdH0gdGhhdCBjb3JyZXNwb25kcyB0byB1c2VyJ3Mgc2VsZWN0aW9uICh7QGxpbmsgU2V0dGluZ3MudGFza0Zvcm1hdH0pXG4gKlxuICogQGV4cG9ydHNcbiAqIEByZXR1cm5zIHtUYXNrRm9ybWF0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlclNlbGVjdGVkVGFza0Zvcm1hdCgpOiBUYXNrRm9ybWF0IHtcbiAgICByZXR1cm4gVEFTS19GT1JNQVRTW2dldFNldHRpbmdzKCkudGFza0Zvcm1hdF07XG59XG4iLCAiLyoqXG4gKiBDb252ZXJ0IGFueSBzaW5nbGUgcmVzZXJ2ZWQgSFRNTCBjaGFyYWN0ZXIgdG8gaXRzIGVudGl0eSBuYW1lLlxuICogQHBhcmFtIGNoYXJhY3RlclxuICpcbiAqIEBzZWUgaHRtbEVuY29kZVN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbEVuY29kZUNoYXJhY3RlcihjaGFyYWN0ZXI6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYXJhY3RlcnNUb0VudGl0eU5hbWVzOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICB9O1xuXG4gICAgY29uc3QgY2FuZGlkYXRlRW50aXR5TmFtZSA9IGNoYXJhY3RlcnNUb0VudGl0eU5hbWVzW2NoYXJhY3Rlcl07XG4gICAgaWYgKGNhbmRpZGF0ZUVudGl0eU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlRW50aXR5TmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcmFjdGVyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgcmVzZXJ2ZWQgSFRNTCBjaGFyYWN0ZXJzIHRvIHRoZWlyIGVudGl0eSBuYW1lcy5cbiAqIEBwYXJhbSBjaGFyYWN0ZXJzXG4gKlxuICogQHNlZSBodG1sRW5jb2RlQ2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sRW5jb2RlU3RyaW5nKGNoYXJhY3RlcnM6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYXJzID0gWy4uLmNoYXJhY3RlcnNdO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjaGFycy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBodG1sRW5jb2RlQ2hhcmFjdGVyKGMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJpbXBvcnQgeyBodG1sRW5jb2RlQ2hhcmFjdGVyLCBodG1sRW5jb2RlU3RyaW5nIH0gZnJvbSAnLi4vbGliL0hUTUxDaGFyYWN0ZXJFbnRpdGllcyc7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuL1N0YXR1cyc7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcblxuLyoqXG4gKiBUcmFja3MgYWxsIHRoZSByZWdpc3RlcmVkIHN0YXR1c2VzIGEgdGFzayBjYW4gaGF2ZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgb2YgdXNpbmcgdGhpcyBjbGFzcy5cbiAqIC0gSW4gJ3Byb2R1Y3Rpb24nIGNvZGUsIHRoYXQgaXMgaW4gdGhlIGFjdHVhbCBwbHVnaW4gY29kZSB0aGF0IGlzIHJlbGVhc2VkLFxuICogICBjYWxsIGBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpYCAtIHtAbGluayBnZXRJbnN0YW5jZX0gLSB0byBvYnRhaW4gdGhlIHNpbmdsZSBnbG9iYWwgaW5zdGFuY2UuXG4gKiAgIEFueSBjaGFuZ2VzIHRvIHRoZSBzdGF0dXNlcyBpbiB0aGF0IGluc3RhbmNlIGFyZSByZWZsZWN0ZWQgZXZlcnl3aGVyZSB0aHJvdWdob3V0XG4gKiAgIHRoZSBwbHVnaW4uXG4gKiAgIEZvciBleGFtcGxlLCB0aGUgY29kZSB0byB0b2dnbGUgdGFzayBzdGF0dXNlcyB1c2UgdGhlIGdsb2JhbCBpbnN0YW5jZS5cbiAqIC0gVGVzdHMgb2YgU3RhdHVzUmVnaXN0cnkgY2FwYWJpbGl0aWVzIGRvIG5vdCBuZWVkIHRvIG1vZGlmeSB0aGUgZ2xvYmFsIGluc3RhbmNlOlxuICogICBUaGV5IHNob3VsZCB1c2UgYG5ldyBTdGF0dXNSZWdpc3RyeSgpYCwgd2hpY2ggbWFrZXMgZm9yIHNpbXBsZXIsIG1vcmUgcmVhZGFibGVcbiAqICAgdGVzdHMgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNSZWdpc3RyeVxuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzUmVnaXN0cnkge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBTdGF0dXNSZWdpc3RyeTtcblxuICAgIHByaXZhdGUgX3JlZ2lzdGVyZWRTdGF0dXNlczogU3RhdHVzW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3RhdHVzIGFuZCByZWdpc3RlcnMgaXQgZm9yIHVzZS4gSXQgd2lsbCBhbHNvIGNoZWNrIHRvIHNlZVxuICAgICAqIGlmIHRoZSBkZWZhdWx0IHRvZG8gYW5kIGRvbmUgYXJlIHJlZ2lzdGVyZWQgYW5kIGlmIG5vdCBoYW5kbGUgaXQgaW50ZXJuYWxseS5cbiAgICAgKlxuICAgICAqIENvZGUgaW4gdGhlIHBsdWdpbiBzaG91bGQgdXNlIHtAbGluayBnZXRJbnN0YW5jZX0gdG8gdXNlIGFuZCBtb2RpZnkgdGhlIGdsb2JhbFxuICAgICAqIFN0YXR1c1JlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFkZERlZmF1bHRTdGF0dXNUeXBlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoaXMgaW5zdGFuY2UgdG8gY29udGFpbiBvbmx5IHRoZSBnaXZlbiBzdGF0dXMgbGlzdCwgaW4gdGhlIHN1cHBsaWVkIG9yZGVyLlxuICAgICAqXG4gICAgICogRHVwbGljYXRlIHN0YXR1cyBzeW1ib2xzIGFyZSBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSBzdGF0dXNlc1xuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoc3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSB8IFN0YXR1c1tdKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0dXNlcygpO1xuICAgICAgICBzdGF0dXNlcy5mb3JFYWNoKChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHN0YXR1c2VzIG1pbnVzIHRoZSBlbXB0eSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RhdHVzW119XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGdldCByZWdpc3RlcmVkU3RhdHVzZXMoKTogU3RhdHVzW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBzeW1ib2wgfSkgPT4gc3ltYm9sICE9PSBTdGF0dXMuRU1QVFkuc3ltYm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdGljIG1ldGhvZCB0aGF0IGNvbnRyb2xzIHRoZSBhY2Nlc3MgdG8gdGhlIFN0YXR1c1JlZ2lzdHJ5IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzUmVnaXN0cnl9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBTdGF0dXNSZWdpc3RyeSB7XG4gICAgICAgIGlmICghU3RhdHVzUmVnaXN0cnkuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIFN0YXR1c1JlZ2lzdHJ5Lmluc3RhbmNlID0gbmV3IFN0YXR1c1JlZ2lzdHJ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzUmVnaXN0cnkuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBTdGF0dXMgdG8gdGhlIHJlZ2lzdHJ5IGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0YXR1c0NvbmZpZ3VyYXRpb24gfCBTdGF0dXN9IHN0YXR1c1xuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGQoc3RhdHVzOiBTdGF0dXNDb25maWd1cmF0aW9uIHwgU3RhdHVzKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTeW1ib2woc3RhdHVzLnN5bWJvbCkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgaW5zdGFuY2VvZiBTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMucHVzaChzdGF0dXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMucHVzaChuZXcgU3RhdHVzKHN0YXR1cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBzdGF0dXMgYnkgdGhlIHN5bWJvbCBiZXR3ZWVuIHRoZVxuICAgICAqIHNxdWFyZSBicmFjZXMgaW4gdGhlIG1hcmtkb3duIHRhc2suXG4gICAgICogUmV0dXJucyBhbiBFTVBUWSBzdGF0dXMgaWYgc3ltYm9sIGlzIHVua25vd24uXG4gICAgICpcbiAgICAgKiBAc2VlIGJ5U3ltYm9sT3JDcmVhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHsqfSAge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwdWJsaWMgYnlTeW1ib2woc3ltYm9sOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5oYXNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLkVNUFRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgc3RhdHVzIGJ5IHRoZSBzeW1ib2wgYmV0d2VlbiB0aGVcbiAgICAgKiBzcXVhcmUgYnJhY2VzIGluIHRoZSBtYXJrZG93biB0YXNrLlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHVzYWJsZSBuZXcgU3RhdHVzIHdpdGggdGhpcyBnaXZlbiBzeW1ib2wgaWYgc3ltYm9sIGlzIHVua25vd24uXG4gICAgICogTm90ZTogQW4gdW5rbm93biBzeW1ib2wgaXMgbm90IGFkZGVkIHRvIHRoZSByZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBzZWUgaGFzU3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGJ5U3ltYm9sT3JDcmVhdGUoc3ltYm9sOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5oYXNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLmNyZWF0ZVVua25vd25TdGF0dXMoc3ltYm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIHN0YXR1cyBieSB0aGUgbmFtZSBhc3NpZ25lZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGJ5TmFtZShuYW1lVG9GaW5kOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBuYW1lIH0pID0+IG5hbWUgPT09IG5hbWVUb0ZpbmQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMuZmlsdGVyKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gbmFtZVRvRmluZClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLkVNUFRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYXJyYXkgb2YgU3RhdHVzIHR5cGVzIHRvIHRoZSBkZWZhdWx0IHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIHJlc2V0VG9EZWZhdWx0U3RhdHVzZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0dXNlcygpO1xuICAgICAgICB0aGlzLmFkZERlZmF1bHRTdGF0dXNUeXBlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYXJyYXkgb2YgU3RhdHVzIHR5cGVzIHRvIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhclN0YXR1c2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBhbGxvdyBjdXN0b20gcHJvZ3Jlc3Npb24gb2YgdGFzayBzdGF0dXMgZWFjaCBzdGF0dXMga25vd3NcbiAgICAgKiB3aGljaCBzdGF0dXMgY2FuIGNvbWUgYWZ0ZXIgaXQgYXMgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICogQHNlZSBnZXROZXh0U3RhdHVzT3JDcmVhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TmV4dFN0YXR1cyhzdGF0dXM6IFN0YXR1cyk6IFN0YXR1cyB7XG4gICAgICAgIGlmIChzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCAhPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0dXMgPSB0aGlzLmJ5U3ltYm9sKHN0YXR1cy5uZXh0U3RhdHVzU3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5FTVBUWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgc3RhdHVzIGlmIGl0IGV4aXN0cywgYW5kIGlmIG5vdCwgY3JlYXRlIGEgbmV3XG4gICAgICogVE9ETyBzdGF0dXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBuZXh0IHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqIEBzZWUgZ2V0TmV4dFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXROZXh0U3RhdHVzT3JDcmVhdGUoc3RhdHVzOiBTdGF0dXMpOiBTdGF0dXMge1xuICAgICAgICBjb25zdCBuZXh0U3RhdHVzID0gdGhpcy5nZXROZXh0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIGlmIChuZXh0U3RhdHVzLnR5cGUgIT09IFN0YXR1c1R5cGUuRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXR1cyBpcyBjb25maWd1cmVkIHRvIGFkdmFuY2UgdG8gYSBzeW1ib2wgdGhhdCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gU28gd2UgZ28gYWhlYWQgYW5kIGNyZWF0ZSBpdCBhbnl3YXkgLSB3ZSBqdXN0IGNhbm5vdCBnaXZlIGl0IGEgbWVhbmluZ2Z1bCBuYW1lLlxuICAgICAgICByZXR1cm4gU3RhdHVzLmNyZWF0ZVVua25vd25TdGF0dXMoc3RhdHVzLm5leHRTdGF0dXNTeW1ib2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RhdHVzIHRvIHVzZSBmb3IgYSByZWN1cnJpbmcgdGFzayB0aGF0IGhhcyBqdXN0IGJlZW4gY29tcGxldGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIG5leHQgc3RhdHVzIGlzIG5vdCBUT0RPOlxuICAgICAqICAgLSBpdCBmaXJzdCBhZHZhbmNlcyB0aHJvdWdoIHRoZSBuZXh0IHN0YXR1c2VzIHVudGlsIGl0IGZpbmRzIGEge0BsaW5rIFN0YXR1c1R5cGUuVE9ET30gc3RhdHVzIC0gd2hpY2ggaXQgcmV0dXJuc1xuICAgICAqICAgLSBvciBpdCB0aGVuIGFkdmFuY2VzIHRocm91Z2ggdGhlIG5leHQgc3RhdHVzZXMgdW50aWwgaXQgZmluZHMgYW4ge0BsaW5rIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1N9IHN0YXR1cyAtIHdoaWNoIGl0IHJldHVybnNcbiAgICAgKiAgIC0gb3RoZXJ3aXNlLCBpdCB1c2VzIHRoZSBzdGF0dXMgd2l0aCBzeW1ib2wgJ3NwYWNlJywgd2hpY2ggaXMgdGhlIGRlZmF1bHQgJ1RPRE8nIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdTdGF0dXMgLSB0aGUgbmV3IHN0YXR1cyBvZiB0aGUgdGFzayB0aGF0IGhhcyBqdXN0IGJlZW4gdG9nZ2xlZCwgd2hpY2hcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSB7QGxpbmsgU3RhdHVzVHlwZS5ET05FfSwgYnV0IHRoaXMgaXMgbm90IGNoZWNrZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldE5leHRSZWN1cnJlbmNlU3RhdHVzT3JDcmVhdGUobmV3U3RhdHVzOiBTdGF0dXMpIHtcbiAgICAgICAgY29uc3QgbmV4dFN0YXR1cyA9IHRoaXMuZ2V0TmV4dFN0YXR1c09yQ3JlYXRlKG5ld1N0YXR1cyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0MSA9IHRoaXMuZ2V0TmV4dFJlY3VycmVuY2VTdGF0dXNPZlR5cGUobmV4dFN0YXR1cywgU3RhdHVzVHlwZS5UT0RPKTtcbiAgICAgICAgaWYgKHJlc3VsdDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuZ2V0TmV4dFJlY3VycmVuY2VTdGF0dXNPZlR5cGUobmV4dFN0YXR1cywgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUyk7XG4gICAgICAgIGlmIChyZXN1bHQyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIFRPRE8gb3IgSU5fUFJPR1JFU1Mgc3RhdHVzIGluIHRoZSBjaGFpbiwgc28gd2Ugd2lsbCB1c2UgYSBzcGFjZS5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIG5ldyByZWN1cnJlbmNlIGlzIGFsd2F5cyBmb3VuZCBieSAnbm90IGRvbmUnIHNlYXJjaGVzLFxuICAgICAgICAvLyBmb3Igc2FmZXR5IGluIHZhdWx0cyB3aGVyZSB1c2VycyBkaWQgbm90IGZ1bGx5IHNldCB1cCBhbGwgc3RhdHVzZXMuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgdGhlIHNpbXBsaWZ5aW5nIGFzc3VtcHRpb24gdGhhdCBubyB1c2VyIGlzIGxpa2VseSB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIHN0YXR1cyB0eXBlIG9mIHNwYWNlIHRvIGFueXRoaW5nIG90aGVyIHRoYW4gVE9ETyAtIGJ1dCBpZiB0aGV5IGRvLCBpdCdzIG5vdFxuICAgICAgICAvLyBvdXIgcHJvYmxlbS5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnlTeW1ib2xPckNyZWF0ZSgnICcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TmV4dFJlY3VycmVuY2VTdGF0dXNPZlR5cGUobmV4dFN0YXR1czogU3RhdHVzLCB3YW50ZWQ6IFN0YXR1c1R5cGUpIHtcbiAgICAgICAgaWYgKG5leHRTdGF0dXMudHlwZSA9PT0gd2FudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VhcmNoU3RhdHVzID0gbmV4dFN0YXR1cztcbiAgICAgICAgLy8gVGhlIGdvYWwgaGVyZSBpcyB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wLiBCeSBsaW1pdGluZyB0aGUgc2VhcmNoIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gY29uZmlndXJlZCBzdGF0dXNlcywgd2UgZW5zdXJlIGl0IGRvZXNuJ3QgY29udGludWUgaW5kZWZpbml0ZWx5LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVnaXN0ZXJlZFN0YXR1c2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgc2VhcmNoU3RhdHVzID0gdGhpcy5nZXROZXh0U3RhdHVzT3JDcmVhdGUoc2VhcmNoU3RhdHVzKTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hTdGF0dXMudHlwZSA9PT0gd2FudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW55IHN0YXR1c2VzIGluIHRoZSBnaXZlbiBsaXN0IHRoYXQgYXJlIG5vdCBrbm93biB0byB0aGlzIHJlZ2lzdHJ5LlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWRkIGFsbCB1bmtub3duIHN0YXR1cyB0eXBlcyB0byB0aGUgc2V0dGluZ3MsXG4gICAgICogdG8gc2F2ZSB1c2VycyBmcm9tIGhhdmluZyB0byBkbyB0aGF0IG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogU3RhdHVzZXMgYXJlIHJldHVybmVkIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGZpcnN0IGZvdW5kIGluIHRoZVxuICAgICAqIHN1cHBsaWVkIGxpc3QuXG4gICAgICogQHBhcmFtIGFsbFN0YXR1c2VzXG4gICAgICovXG4gICAgcHVibGljIGZpbmRVbmtub3duU3RhdHVzZXMoYWxsU3RhdHVzZXM6IFN0YXR1c1tdKTogU3RhdHVzW10ge1xuICAgICAgICBjb25zdCB1bmtub3duU3RhdHVzZXMgPSBhbGxTdGF0dXNlcy5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNTeW1ib2wocy5zeW1ib2wpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2UgYSBzZXBhcmF0ZSBTdGF0dXNSZWdpc3RyeSB0byBrZWVwIHRyYWNrIG9mIGR1cGxpY2F0ZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgU2V0IGlzIG5vIHVzZSB0byB1czpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjk3NTk0ODAvaG93LXRvLWN1c3RvbWl6ZS1vYmplY3QtZXF1YWxpdHktZm9yLWphdmFzY3JpcHQtc2V0XG4gICAgICAgIGNvbnN0IG5ld1N0YXR1c1JlZ2lzdHJ5ID0gbmV3IFN0YXR1c1JlZ2lzdHJ5KCk7XG5cbiAgICAgICAgY29uc3QgbmFtZWRVbmlxdWVTdGF0dXNlczogU3RhdHVzW10gPSBbXTtcbiAgICAgICAgdW5rbm93blN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgc2VlbiB0aGlzIHN5bWJvbCBhbHJlYWR5OlxuICAgICAgICAgICAgaWYgKG5ld1N0YXR1c1JlZ2lzdHJ5Lmhhc1N5bWJvbChzLnN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIGFoZWFkIGFuZCBjcmVhdGUgYSBzdWl0YWJseS1uYW1lZCBjb3B5LFxuICAgICAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBzeW1ib2wgaW4gdGhlIG5hbWUuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5jb3B5U3RhdHVzV2l0aE5ld05hbWUocywgYFVua25vd24gKCR7cy5zeW1ib2x9KWApO1xuICAgICAgICAgICAgbmFtZWRVbmlxdWVTdGF0dXNlcy5wdXNoKG5ld1N0YXR1cyk7XG4gICAgICAgICAgICAvLyBBbmQgYWRkIGl0IHRvIG91ciBsb2NhbCByZWdpc3RyeSwgdG8gcHJldmVudCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgbmV3U3RhdHVzUmVnaXN0cnkuYWRkKG5ld1N0YXR1cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuYW1lZFVuaXF1ZVN0YXR1c2VzLnNvcnQoKHN0YXR1czEsIHN0YXR1czIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXMxLnN5bWJvbC5sb2NhbGVDb21wYXJlKHN0YXR1czIuc3ltYm9sLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29weVN0YXR1c1dpdGhOZXdOYW1lKHM6IFN0YXR1cywgbmV3TmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c0NvbmZpZ3VyYXRpb24gPSBuZXcgU3RhdHVzQ29uZmlndXJhdGlvbihcbiAgICAgICAgICAgIHMuc3ltYm9sLFxuICAgICAgICAgICAgbmV3TmFtZSxcbiAgICAgICAgICAgIHMubmV4dFN0YXR1c1N5bWJvbCxcbiAgICAgICAgICAgIHMuYXZhaWxhYmxlQXNDb21tYW5kLFxuICAgICAgICAgICAgcy50eXBlLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhzdGF0dXNDb25maWd1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHRoZSBTdGF0dXMgdHlwZXMgYnkgdGhlIHN5bWJvbCBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgb25lIGZvdW5kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTeW1ib2woc3ltYm9sVG9GaW5kOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBzeW1ib2wgfSkgPT4gc3ltYm9sID09PSBzeW1ib2xUb0ZpbmQpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgYWxsIHRoZSBTdGF0dXMgdHlwZXMgYnkgdGhlIHN5bWJvbCBhbmQgcmV0dXJucyB0cnVlIGlmIGZvdW5kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHByaXZhdGUgaGFzU3ltYm9sKHN5bWJvbFRvRmluZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMuZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnN5bWJvbCA9PT0gc3ltYm9sVG9GaW5kO1xuICAgICAgICAgICAgfSkgIT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgcmVnaXN0cnkgYW5kIGFkZHMgdGhlIGRlZmF1bHQgc3RhdHVzIHR5cGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGFkZERlZmF1bHRTdGF0dXNUeXBlcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0YXR1c2VzID0gW1N0YXR1cy5tYWtlVG9kbygpLCBTdGF0dXMubWFrZUluUHJvZ3Jlc3MoKSwgU3RhdHVzLm1ha2VEb25lKCksIFN0YXR1cy5tYWtlQ2FuY2VsbGVkKCldO1xuXG4gICAgICAgIGRlZmF1bHRTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIE1lcm1haWQgZGlhZ3JhbSBmcm9tIHRoZSBzdGF0dXNlcyBpbiB0aGlzIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogVGhlIHRleHQgY2FuIGJlIHBhc3RlZCBpbiB0byBhbiBPYnNpZGlhbiBub3RlIHRvIHZpc3VhbGlzZSB0aGUgdHJhbnNpdGlvbnMgYmV0d2VlblxuICAgICAqIHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogTm90ZTogQW55IG9mIHRoZSAnbmV4dCBzdGF0dXMgc3ltYm9scycgdGhhdCBhcmUgbm90IGluIHRoZSByZWdpc3RyeSBhcmUgaWdub3JlZCwgYW5kIGludmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZURldGFpbHMgLSB3aGV0aGVyIHRvIGluY2x1ZGUgdGhlIHN0YXR1cyBzeW1ib2xzIGFuZCB0eXBlcyBpbiB0aGUgZGlhZ3JhbS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgcHVibGljIG1lcm1haWREaWFncmFtKGluY2x1ZGVEZXRhaWxzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlU3RhdHVzZXMgPSB0aGlzLnJlZ2lzdGVyZWRTdGF0dXNlcztcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9ICdtZXJtYWlkJztcblxuICAgICAgICBjb25zdCBub2Rlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgZWRnZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIHVuaXF1ZVN0YXR1c2VzLmZvckVhY2goKHN0YXR1cywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRNZXJtYWlkTm9kZUxhYmVsKHN0YXR1cywgaW5jbHVkZURldGFpbHMpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChgJHtpbmRleCArIDF9JHtsYWJlbH1gKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG5leHQgc3RhdHVzOlxuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXR1cyA9IHRoaXMuZ2V0TmV4dFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy5hZGRFZGdlSWZOb3RUb0ludGVybmFsKHVuaXF1ZVN0YXR1c2VzLCBuZXh0U3RhdHVzLCBlZGdlcywgaW5kZXgsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gRm9yIHJlY3VycmluZyB0YXNrcywgaWYgVGFza3Mgd291bGQgb3ZlcnJpZGUgdGhlIG5leHQgc3RhdHVzIGFmdGVyIGEgRE9ORSB0YXNrLFxuICAgICAgICAgICAgLy8gdG8gZm9yY2UgaXQgdG8gYmUgVE9ETyBvciBJTl9QUk9HUkVTUywgdGhlbiB3ZSB3YW50IHRvIHNob3cgdGhpcyB2aXN1YWxseS5cbiAgICAgICAgICAgIGlmIChzdGF0dXMudHlwZSA9PT0gU3RhdHVzVHlwZS5ET05FKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFJlY3VycmluZ1N0YXR1cyA9IHRoaXMuZ2V0TmV4dFJlY3VycmVuY2VTdGF0dXNPckNyZWF0ZShzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWN1cnJpbmdUeXBlRGlmZmVycyA9IG5leHRSZWN1cnJpbmdTdGF0dXMuc3ltYm9sICE9PSBuZXh0U3RhdHVzLnN5bWJvbDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJlY3VycmluZ1R5cGVEaWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRnZUlmTm90VG9JbnRlcm5hbCh1bmlxdWVTdGF0dXNlcywgbmV4dFJlY3VycmluZ1N0YXR1cywgZWRnZXMsIGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBgXG5cXGBcXGBcXGAke2xhbmd1YWdlfVxuZmxvd2NoYXJ0IExSXG5cbmNsYXNzRGVmIFRPRE8gICAgICAgIHN0cm9rZTojZjMzLHN0cm9rZS13aWR0aDozcHg7XG5jbGFzc0RlZiBET05FICAgICAgICBzdHJva2U6IzBjMCxzdHJva2Utd2lkdGg6M3B4O1xuY2xhc3NEZWYgSU5fUFJPR1JFU1Mgc3Ryb2tlOiNmYTAsc3Ryb2tlLXdpZHRoOjNweDtcbmNsYXNzRGVmIENBTkNFTExFRCAgIHN0cm9rZTojZGRkLHN0cm9rZS13aWR0aDozcHg7XG5jbGFzc0RlZiBOT05fVEFTSyAgICBzdHJva2U6Izk5ZSxzdHJva2Utd2lkdGg6M3B4O1xuXG4ke25vZGVzLmpvaW4oJ1xcbicpfVxuJHtlZGdlcy5qb2luKCdcXG4nKX1cblxubGlua1N0eWxlIGRlZmF1bHQgc3Ryb2tlOmdyYXlcblxcYFxcYFxcYFxuYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZEVkZ2VJZk5vdFRvSW50ZXJuYWwoXG4gICAgICAgIHVuaXF1ZVN0YXR1c2VzOiBTdGF0dXNbXSxcbiAgICAgICAgbmV4dFN0YXR1czogU3RhdHVzLFxuICAgICAgICBlZGdlczogc3RyaW5nW10sXG4gICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgIGlzRm9yUmVjY3VyZW5jZU92ZXJyaWRlOiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBjb25zdCBuZXh0U3RhdHVzSW5kZXggPSB1bmlxdWVTdGF0dXNlcy5maW5kSW5kZXgoKHN0YXR1cykgPT4gc3RhdHVzLnN5bWJvbCA9PT0gbmV4dFN0YXR1cy5zeW1ib2wpO1xuICAgICAgICBjb25zdCBuZXh0U3RhdHVzSXNLbm93biA9IG5leHRTdGF0dXNJbmRleCAhPT0gLTE7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0dXNJc05vdEludGVybmFsID0gbmV4dFN0YXR1cy50eXBlICE9PSBTdGF0dXNUeXBlLkVNUFRZO1xuXG4gICAgICAgIGlmIChuZXh0U3RhdHVzSXNLbm93biAmJiBuZXh0U3RhdHVzSXNOb3RJbnRlcm5hbCkge1xuICAgICAgICAgICAgbGV0IGpvaW5lcjtcbiAgICAgICAgICAgIGlmIChpc0ZvclJlY2N1cmVuY2VPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGpvaW5lciA9ICctLiBcIlx1RDgzRFx1REQwMVwiIC4tPiAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqb2luZXIgPSAnIC0tPiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGAke2luZGV4ICsgMX0ke2pvaW5lcn0ke25leHRTdGF0dXNJbmRleCArIDF9YDtcbiAgICAgICAgICAgIGVkZ2VzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1lcm1haWROb2RlTGFiZWwoc3RhdHVzOiBTdGF0dXMsIGluY2x1ZGVEZXRhaWxzOiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c05hbWUgPSBodG1sRW5jb2RlU3RyaW5nKHN0YXR1cy5uYW1lKTtcbiAgICAgICAgY29uc3Qgc3RhdHVzVHlwZSA9IHN0YXR1cy50eXBlO1xuICAgICAgICBpZiAoaW5jbHVkZURldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1N5bWJvbCA9IGh0bWxFbmNvZGVDaGFyYWN0ZXIoc3RhdHVzLnN5bWJvbCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNOZXh0U3RhdHVzU3ltYm9sID0gaHRtbEVuY29kZUNoYXJhY3RlcihzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25UZXh0ID0gYFske3N0YXR1c1N5bWJvbH1dIC0+IFske3N0YXR1c05leHRTdGF0dXNTeW1ib2x9XWA7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNOYW1lVGV4dCA9IGAnJHtzdGF0dXNOYW1lfSdgO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzVHlwZVRleHQgPSBgKCR7c3RhdHVzVHlwZX0pYDtcblxuICAgICAgICAgICAgcmV0dXJuIGBbXCIke3N0YXR1c05hbWVUZXh0fTxicj4ke3RyYW5zaXRpb25UZXh0fTxicj4ke3N0YXR1c1R5cGVUZXh0fVwiXTo6OiR7c3RhdHVzVHlwZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBbXCIke3N0YXR1c05hbWV9XCJdOjo6JHtzdGF0dXNUeXBlfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBEdXJhdGlvbklucHV0QXJnMiwgTW9tZW50LCB1bml0T2ZUaW1lIH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFByb3BlcnR5Q2F0ZWdvcnkgfSBmcm9tICcuLi9saWIvUHJvcGVydHlDYXRlZ29yeSc7XG5pbXBvcnQgeyBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzay9UYXNrUmVndWxhckV4cHJlc3Npb25zJztcbmltcG9ydCB7IGlzRGF0ZVRpbWUgfSBmcm9tICcuLi9saWIvRGF0ZVRvb2xzJztcblxuLyoqXG4gKiBUYXNrc0RhdGUgZW5jYXBzdWxhdGVzIGEgZGF0ZSwgZm9yIHNpbXBsaWZ5aW5nIHRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb25zIHVzZXJzIG5lZWQgdG9cbiAqIHdyaXRlIGluICdncm91cCBieSBmdW5jdGlvbicgbGluZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrc0RhdGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2RhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGU6IE1vbWVudCB8IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZGF0ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByYXcgdW5kZXJseWluZyBtb21lbnQgKG9yIG51bGwsIGlmIHRoZXJlIGlzIG5vIGRhdGUpXG4gICAgICovXG4gICAgZ2V0IG1vbWVudCgpOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRlIGZvcm1hdHRlZCBhcyBZWVlZLU1NLURELCBvciB7QGxpbmsgZmFsbEJhY2tUZXh0fSBpZiB0aGVyZSBpcyBubyBkYXRlLlxuICAgICBAcGFyYW0gZmFsbEJhY2tUZXh0IC0gdGhlIHN0cmluZyB0byB1c2UgaWYgdGhlIGRhdGUgaXMgbnVsbC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JtYXRBc0RhdGUoZmFsbEJhY2tUZXh0OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQsIGZhbGxCYWNrVGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRlIGZvcm1hdHRlZCBhcyBZWVlZLU1NLUREIEhIOm1tLCBvciB7QGxpbmsgZmFsbEJhY2tUZXh0fSBpZiB0aGVyZSBpcyBubyBkYXRlLlxuICAgICBAcGFyYW0gZmFsbEJhY2tUZXh0IC0gdGhlIHN0cmluZyB0byB1c2UgaWYgdGhlIGRhdGUgaXMgbnVsbC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JtYXRBc0RhdGVBbmRUaW1lKGZhbGxCYWNrVGV4dDogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlVGltZUZvcm1hdCwgZmFsbEJhY2tUZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgZm9ybWF0dGVkIGFzIFlZWVktTU0tREQgSEg6bW0sIG9yIHtAbGluayBmYWxsQmFja1RleHR9IGlmIHRoZXJlIGlzIG5vIGRhdGUuXG4gICAgIEBwYXJhbSBmYWxsQmFja1RleHQgLSB0aGUgc3RyaW5nIHRvIHVzZSBpZiB0aGUgZGF0ZSBpcyBudWxsLiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdEFzRGF0ZUFuZFRpbWVPckRhdGUoZmFsbEJhY2tUZXh0OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpc0RhdGVUaW1lKHRoaXMubW9tZW50KSA/IHRoaXMuZm9ybWF0QXNEYXRlQW5kVGltZShmYWxsQmFja1RleHQpIDogdGhpcy5mb3JtYXRBc0RhdGUoZmFsbEJhY2tUZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgZm9ybWF0dGVkIHdpdGggdGhlIGdpdmVuIGZvcm1hdCBzdHJpbmcsIG9yIHtAbGluayBmYWxsQmFja1RleHR9IGlmIHRoZXJlIGlzIG5vIGRhdGUuXG4gICAgICogU2VlIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9kaXNwbGF5aW5nLyBmb3IgYWxsIHRoZSBhdmFpbGFibGUgZm9ybWF0dGluZyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBmb3JtYXRcbiAgICAgKiBAcGFyYW0gZmFsbEJhY2tUZXh0IC0gdGhlIHN0cmluZyB0byB1c2UgaWYgdGhlIGRhdGUgaXMgbnVsbC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JtYXQoZm9ybWF0OiBzdHJpbmcsIGZhbGxCYWNrVGV4dDogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZSA/IHRoaXMuX2RhdGUuZm9ybWF0KGZvcm1hdCkgOiBmYWxsQmFja1RleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRlIGFzIGFuIElTTyBzdHJpbmcsIGZvciBleGFtcGxlICcyMDIzLTEwLTEzVDAwOjAwOjAwLjAwMFonLlxuICAgICAqIEBwYXJhbSBrZWVwT2Zmc2V0XG4gICAgICogQHJldHVybnMgLSBUaGUgZGF0ZSBhcyBhbiBJU08gc3RyaW5nLCBmb3IgZXhhbXBsZTogJzIwMjMtMTAtMTNUMDA6MDA6MDAuMDAwWicsXG4gICAgICogICAgICAgICAgICBPUiBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gZGF0ZSwgT1IgbnVsbCBmb3IgYW4gaW52YWxpZCBkYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0PzogYm9vbGVhbik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZSA/IHRoaXMuX2RhdGUudG9JU09TdHJpbmcoa2VlcE9mZnNldCkgOiAnJztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNhdGVnb3J5KCk6IFByb3BlcnR5Q2F0ZWdvcnkge1xuICAgICAgICAvLyBiZWdpbi1zbmlwcGV0OiB1c2UtbW9tZW50LWluLXNyY1xuICAgICAgICBjb25zdCB0b2RheSA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgLy8gZW5kLXNuaXBwZXRcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMubW9tZW50O1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlDYXRlZ29yeSgnVW5kYXRlZCcsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlLmlzQmVmb3JlKHRvZGF5LCAnZGF5JykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlDYXRlZ29yeSgnT3ZlcmR1ZScsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlLmlzU2FtZSh0b2RheSwgJ2RheScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5Q2F0ZWdvcnkoJ1RvZGF5JywgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUNhdGVnb3J5KCdJbnZhbGlkIGRhdGUnLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5Q2F0ZWdvcnkoJ0Z1dHVyZScsIDMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZnJvbU5vdygpOiBQcm9wZXJ0eUNhdGVnb3J5IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMubW9tZW50O1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlDYXRlZ29yeSgnJywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JkZXIgPSB0aGlzLmZyb21Ob3dPcmRlcihkYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUNhdGVnb3J5KGRhdGUuZnJvbU5vdygpLCBvcmRlcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmcm9tTm93T3JkZXIoZGF0ZTogbW9tZW50Lk1vbWVudCkge1xuICAgICAgICAvLyBBbHdheXMgcHV0IGludmFsaWQgZGF0ZXMgZmlyc3Q6XG4gICAgICAgIGlmICghZGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGEgbnVtYmVyIHRoYXQ6XG4gICAgICAgIC8vICAgLSBpcyB0aGUgc2FtZSBmb3IgYWxsIGRhdGVzIHdpdGggdGhlIHNhbWUgJ2Zyb21Ob3coKScgbmFtZSxcbiAgICAgICAgLy8gICAtIHNvcnRzIGluIGFzY2VuZGluZyBvcmRlciBvZiB0aGUgZGF0ZS5cblxuICAgICAgICBjb25zdCBub3cgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgIGNvbnN0IGVhcmxpZXIgPSBkYXRlLmlzU2FtZU9yQmVmb3JlKG5vdywgJ2RheScpO1xuICAgICAgICBjb25zdCBzdGFydERhdGVPZlRoaXNHcm91cCA9IHRoaXMuZnJvbU5vd1N0YXJ0RGF0ZU9mR3JvdXAoZGF0ZSwgZWFybGllciwgbm93KTtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXN0QW5kRnV0dXJlRGF0ZXMgPSBlYXJsaWVyID8gMSA6IDM7XG4gICAgICAgIHJldHVybiBOdW1iZXIoc3BsaXRQYXN0QW5kRnV0dXJlRGF0ZXMgKyBzdGFydERhdGVPZlRoaXNHcm91cC5mb3JtYXQoJ1lZWVlNTUREJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZnJvbU5vd1N0YXJ0RGF0ZU9mR3JvdXAoZGF0ZTogbW9tZW50Lk1vbWVudCwgZWFybGllcjogYm9vbGVhbiwgbm93OiBhbnkpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBlYXJsaWVzdCBvZiBhbGwgZGF0ZXMgd2l0aCB0aGUgc2FtZSAnZnJvbU5vdygpJyBuYW1lLlxuXG4gICAgICAgIC8vIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9kaXNwbGF5aW5nL2Zyb21ub3cvXG4gICAgICAgIC8vICdJZiB5b3UgcGFzcyB0cnVlLCB5b3UgY2FuIGdldCB0aGUgdmFsdWUgd2l0aG91dCB0aGUgc3VmZml4LidcbiAgICAgICAgY29uc3Qgd29yZHMgPSBkYXRlLmZyb21Ob3codHJ1ZSkuc3BsaXQoJyAnKTtcblxuICAgICAgICBsZXQgbXVsdGlwbGllcjogbnVtYmVyO1xuICAgICAgICBjb25zdCB3b3JkMEFzTnVtYmVyID0gTnVtYmVyKHdvcmRzWzBdKTtcbiAgICAgICAgaWYgKGlzTmFOKHdvcmQwQXNOdW1iZXIpKSB7XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gMTsgLy8gZXhhbXBsZXM6ICdhIHllYXInLCAnYSBtb250aCcsICdhIGRheSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSB3b3JkMEFzTnVtYmVyOyAvLyBleGFtcGxlczogJzEwIHllYXJzJywgJzYgbW9udGhzJywgJzExIGhvdXJzJ1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuaXQgPSB3b3Jkc1sxXSBhcyBEdXJhdGlvbklucHV0QXJnMjsgLy8gZGF5LCBkYXlzLCB3ZWVrcywgbW9udGgsIHllYXJcbiAgICAgICAgcmV0dXJuIGVhcmxpZXIgPyBub3cuc3VidHJhY3QobXVsdGlwbGllciwgdW5pdCkgOiBub3cuYWRkKG11bHRpcGxpZXIsIHVuaXQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBwb3N0cG9uZSh1bml0T2ZUaW1lOiB1bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IgPSAnZGF5cycsIGFtb3VudDogbnVtYmVyID0gMSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGUpIHRocm93IG5ldyBOb3RpY2UoJ0Nhbm5vdCBwb3N0cG9uZSBhIG51bGwgZGF0ZScpO1xuXG4gICAgICAgIGNvbnN0IHRvZGF5ID0gd2luZG93Lm1vbWVudCgpLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIG1vbWVudC5qcyBkb2NzLCBpc0JlZm9yZSBpcyBub3Qgc3RhYmxlIHNvIHdlIHVzZSAhaXNTYW1lT3JBZnRlcjogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3F1ZXJ5L2lzLWJlZm9yZS9cbiAgICAgICAgY29uc3QgaXNEYXRlQmVmb3JlVG9kYXkgPSAhdGhpcy5fZGF0ZS5pc1NhbWVPckFmdGVyKHRvZGF5LCAnZGF5Jyk7XG5cbiAgICAgICAgaWYgKGlzRGF0ZUJlZm9yZVRvZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9kYXkuYWRkKGFtb3VudCwgdW5pdE9mVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZS5jbG9uZSgpLmFkZChhbW91bnQsIHVuaXRPZlRpbWUpO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEEgaGVscGVyIGNsYXNzIHRvIGNvbnN0cnVjdCBncm91cCBuYW1lcyBmb3IgZGF0YSB0eXBlcyB0aGF0IGRvIG5vdCBuYXR1cmFsbHkgc29ydCBpbiBhbHBoYWJldGljYWwgb3JkZXIuXG4gKlxuICogQSBjb252ZW50aW9uIGhhcyBiZWVuIGFkb3B0ZWQgaW4gdGhlIFRhc2tzIGdyb3VwaW5nIGNvZGUgdG8gdXNlIGNvbW1lbnRlZC1vdXQgbnVtYmVycyB0byBjb250cm9sXG4gKiB0aGUgc29ydCBvcmRlciBpbiBncm91cCBoZWFkaW5ncyBmb3IgdGhpbmdzIGxpa2Uge0BsaW5rIFByaW9yaXR5fSwgd2hpY2ggd2Ugd2FudCB0b1xuICogc29ydCBmcm9tIHtAbGluayBQcmlvcml0eS5IaWdoZXN0fSB0byB7QGxpbmsgUHJpb3JpdHkuTG93ZXN0fSwgaW5zdGVhZCBvZiBhbHBoYWJldGljYWxseS5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgd2F5IHRvIHN0b3JlIGEge0BsaW5rIG5hbWV9IGFuZCBhIHtAbGluayBzb3J0T3JkZXJ9LCBmcm9tIHdoaWNoIHtAbGluayBncm91cFRleHR9XG4gKiBjYW4gYmUgY29uc3RydWN0ZWQuXG4gKlxuICogRm9yIGFuIGV4YW1wbGUgb2YgdXNlLCBzZWUge0BsaW5rIFRhc2tzRGF0ZS5jYXRlZ29yeX0uXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUNhdGVnb3J5IHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBzb3J0T3JkZXI6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2F0ZWdvcnkuIFRoaXMgaXMgdHlwaWNhbGx5IHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gYSBncm91cCBoZWFkaW5nLlxuICAgICAqIEBwYXJhbSBzb3J0T3JkZXIgQSBudW1lcmljIHNvcnQgb3JkZXIgZm9yIHRoaXMgaGVhZGluZy4gTG93ZXIgbnVtYmVycyBhcmUgZGlzcGxheWVkIGJlZm9yZSBoaWdoZXIgb25lcy5cbiAgICAgKi9cbiAgICAvLyBQYXNzIGluIGFuIGVtcHR5IG5hbWUgaWYgeW91IHdhbnQgZ3JvdXBUZXh0IHRvIGJlICcnXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBzb3J0T3JkZXI6IG51bWJlcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHNvcnRPcmRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdyb3VwIGhlYWRpbmcgZm9yIHRoaXMgY2F0ZWdvcnkuXG4gICAgICpcbiAgICAgKiBJdCBwcmVmaXhlcyB0aGUgbmFtZSB3aXRoIGEgY29tbWVudCB0aGF0IHdpbGwgZW5zdXJlIHRoZSBncm91cHMgc29ydCBpbiB0aGUgZGVzaXJlZCBvcmRlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgY29tbWVudGVkLW91dCBzb3J0T3JkZXIgd2lsbCBiZSBoaWRkZW4gd2hlbiBPYnNpZGlhblxuICAgICAqIHJlbmRlcnMgdGhlIGdyb3VwIGhlYWRpbmcuXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cFRleHQoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgJSUke3RoaXMuc29ydE9yZGVyfSUlICR7dGhpcy5uYW1lfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi9UYXNrL1ByaW9yaXR5JztcblxuZXhwb3J0IGNsYXNzIFByaW9yaXR5VG9vbHMge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiBhIHtAbGluayBQcmlvcml0eX0gdmFsdWUsIHJldHVybmluZyAnTm9uZScgZm9yIHtAbGluayBQcmlvcml0eS5Ob25lfVxuICAgICAqIEBwYXJhbSBwcmlvcml0eVxuICAgICAqIEBzZWUgcHJpb3JpdHlOYW1lVXNpbmdOb3JtYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHByaW9yaXR5TmFtZVVzaW5nTm9uZShwcmlvcml0eTogUHJpb3JpdHkpIHtcbiAgICAgICAgbGV0IHByaW9yaXR5TmFtZSA9ICdFUlJPUic7XG4gICAgICAgIHN3aXRjaCAocHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuSGlnaDpcbiAgICAgICAgICAgICAgICBwcmlvcml0eU5hbWUgPSAnSGlnaCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5LkhpZ2hlc3Q6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ0hpZ2hlc3QnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5NZWRpdW06XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ01lZGl1bSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5Lk5vbmU6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ05vbmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5Mb3c6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ0xvdyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5Lkxvd2VzdDpcbiAgICAgICAgICAgICAgICBwcmlvcml0eU5hbWUgPSAnTG93ZXN0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpb3JpdHlOYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiBhIHtAbGluayBQcmlvcml0eX0gdmFsdWUsIHJldHVybmluZyAnTm9ybWFsJyBmb3Ige0BsaW5rIFByaW9yaXR5Lk5vbmV9XG4gICAgICogQHBhcmFtIHByaW9yaXR5XG4gICAgICogQHNlZSBwcmlvcml0eU5hbWVVc2luZ05vbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHByaW9yaXR5TmFtZVVzaW5nTm9ybWFsKHByaW9yaXR5OiBQcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlUb29scy5wcmlvcml0eU5hbWVVc2luZ05vbmUocHJpb3JpdHkpLnJlcGxhY2UoJ05vbmUnLCAnTm9ybWFsJyk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFBsYXRmb3JtLCBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG4vKlxuICogRXZlbnRFbWl0dGVyMiBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRXZlbnRFbWl0dGVyIG1vZHVsZSBmb3VuZCBpbiBOb2RlLmpzLlxuICogSW4gYWRkaXRpb24gdG8gaGF2aW5nIGEgYmV0dGVyIGJlbmNobWFyayBwZXJmb3JtYW5jZSB0aGFuIEV2ZW50RW1pdHRlciBhbmQgYmVpbmdcbiAqIGJyb3dzZXItY29tcGF0aWJsZSwgaXQgYWxzbyBleHRlbmRzIHRoZSBpbnRlcmZhY2Ugb2YgRXZlbnRFbWl0dGVyIHdpdGggbWFueVxuICogYWRkaXRpb25hbCBub24tYnJlYWtpbmcgZmVhdHVyZXMuXG4gKlxuICogVGhpcyBoYXMgYmVlbiBhZGRlZCBhcyBFdmVudEVtaXR0ZXIgaW4gTm9kZS5KUyBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLlxuICogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXZlbnRlbWl0dGVyMlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMic7XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGxvZyBsZXZlbHNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJTG9nTGV2ZWwge1xuICAgIDE6ICd0cmFjZSc7XG4gICAgMjogJ2RlYnVnJztcbiAgICAzOiAnaW5mbyc7XG4gICAgNDogJ3dhcm4nO1xuICAgIDU6ICdlcnJvcic7XG59XG5cbi8qKlxuICogTG9nZ2VyIGNsYXNzIHRvIGhhbmRsZSBjb25zaXN0ZW5jeSBvZiBsb2dzIGFjcm9zcyB0aGUgcGx1Z2luLlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgTG9nRW50cnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2dFbnRyeSB7XG4gICAgdHJhY2VJZD86IHN0cmluZztcbiAgICBsZXZlbDogc3RyaW5nO1xuICAgIG1vZHVsZTogc3RyaW5nO1xuICAgIGxvY2F0aW9uPzogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBvYmplY3RzOiBhbnk7XG59XG5cbi8qKlxuICogTG9nZ2luZyBvcHRpb25zIHN0cnVjdHVyZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIExvZ09wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2dPcHRpb25zIHtcbiAgICBtaW5MZXZlbHM6IHsgW21vZHVsZTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbi8qKlxuICogTG9nIGxldmVsIElEcyAoMSAtIDUpXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFRMb2dMZXZlbElkID0ga2V5b2YgSUxvZ0xldmVsO1xuXG4vKipcbiAqIExvZyBsZXZlbCBuYW1lcyAodHJhY2UgLSBlcnJvcilcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgVExvZ0xldmVsTmFtZSA9IElMb2dMZXZlbFtUTG9nTGV2ZWxJZF07XG5cbi8qKlxuICogTG9nZ2VyIGNsYXNzIHRvIGhhbmRsZSBjb25zaXN0ZW5jeSBvZiBsb2dzIGFjcm9zcyB0aGUgcGx1Z2luLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBMb2dNYW5hZ2VyXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyMn1cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ01hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgICBwcml2YXRlIG9wdGlvbnM6IExvZ09wdGlvbnMgPSB7XG4gICAgICAgIG1pbkxldmVsczoge1xuICAgICAgICAgICAgJyc6ICdpbmZvJyxcbiAgICAgICAgICAgIHRhc2tzOiAnaW5mbycsXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIFByZXZlbnQgdGhlIGNvbnNvbGUgbG9nZ2VyIGZyb20gYmVpbmcgYWRkZWQgdHdpY2VcbiAgICBwcml2YXRlIGNvbnNvbGVMb2dnZXJSZWdpc3RlcmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1pbmltdW0gbG9nIGxldmVscyBmb3IgdGhlIG1vZHVsZSBuYW1lIG9yIGdsb2JhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9nT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4geyp9ICB7TG9nTWFuYWdlcn1cbiAgICAgKiBAbWVtYmVyb2YgTG9nTWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyBjb25maWd1cmUob3B0aW9uczogTG9nT3B0aW9ucyk6IExvZ01hbmFnZXIge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbG9nZ2VyIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbW9kdWxlIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlXG4gICAgICogQHJldHVybiB7Kn0gIHtMb2dnZXJ9XG4gICAgICogQG1lbWJlcm9mIExvZ01hbmFnZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TG9nZ2VyKG1vZHVsZTogc3RyaW5nKTogTG9nZ2VyIHtcbiAgICAgICAgbGV0IG1pbkxldmVsID0gJ25vbmUnO1xuICAgICAgICBsZXQgbWF0Y2ggPSAnJztcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLm9wdGlvbnMubWluTGV2ZWxzKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlLnN0YXJ0c1dpdGgoa2V5KSAmJiBrZXkubGVuZ3RoID49IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1pbkxldmVsID0gdGhpcy5vcHRpb25zLm1pbkxldmVsc1trZXldO1xuICAgICAgICAgICAgICAgIG1hdGNoID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMsIG1vZHVsZSwgbWluTGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhsb2dFbnRyeTogTG9nRW50cnkpID0+IHZvaWR9IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Kn0gIHtMb2dNYW5hZ2VyfVxuICAgICAqIEBtZW1iZXJvZiBMb2dNYW5hZ2VyXG4gICAgICovXG4gICAgcHVibGljIG9uTG9nRW50cnkobGlzdGVuZXI6IChsb2dFbnRyeTogTG9nRW50cnkpID0+IHZvaWQpOiBMb2dNYW5hZ2VyIHtcbiAgICAgICAgdGhpcy5vbignbG9nJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBwcml2YXRlIHBlcmlvZDogbnVtYmVyID0gMDtcbiAgICBhcnJBdmcgPSAoYXJyOiBudW1iZXJbXSkgPT4gYXJyLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gYXJyLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxvZ2dlciB0aGF0IHdyaXRlIHRvIHRoZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gIHtMb2dNYW5hZ2VyfVxuICAgICAqIEBtZW1iZXJvZiBMb2dNYW5hZ2VyXG4gICAgICovXG4gICAgcHVibGljIHJlZ2lzdGVyQ29uc29sZUxvZ2dlcigpOiBMb2dNYW5hZ2VyIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc29sZUxvZ2dlclJlZ2lzdGVyZWQpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHRoaXMub25Mb2dFbnRyeSgobG9nRW50cnkpID0+IHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBgWyR7d2luZG93Lm1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERC1ISDptbTpzcy5TU1MnKX1dWyR7bG9nRW50cnkubGV2ZWx9XVske2xvZ0VudHJ5Lm1vZHVsZX1dYDtcblxuICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LnRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gYFske2xvZ0VudHJ5LnRyYWNlSWR9XWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1zZyArPSBgICR7bG9nRW50cnkubWVzc2FnZX1gO1xuICAgICAgICAgICAgaWYgKGxvZ0VudHJ5Lm9iamVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZ0VudHJ5Lm9iamVjdHMgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChsb2dFbnRyeS5sZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShtc2csIGxvZ0VudHJ5Lm9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWJ1Zyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobXNnLCBsb2dFbnRyeS5vYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtc2csIGxvZ0VudHJ5Lm9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZywgbG9nRW50cnkub2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2csIGxvZ0VudHJ5Lm9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgeyR7bG9nRW50cnkubGV2ZWx9fSAke21zZ31gLCBsb2dFbnRyeS5vYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb25zb2xlTG9nZ2VyUmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvZ2dpbmcgPSBuZXcgTG9nTWFuYWdlcigpO1xuXG4vKipcbiAqIE1haW4gbG9nZ2luZyBsaWJyYXJ5LCB0byB2aWV3IHRoZSBsb2dzIGEgbG9nZ2VyIGxpc3RlbmVyIG11c3QgYmUgYWRkZWQuIFRoZVxuICogQ29uc29sZSBMb2dnZXIgaXMgYWxyZWFkeSBpbXBsZW1lbnRlZCBmb3IgdGhpcyBwcm9qZWN0LlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBMb2dnZXJcbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gICAgcHJpdmF0ZSBsb2dNYW5hZ2VyOiBFdmVudEVtaXR0ZXIyO1xuICAgIHByaXZhdGUgbWluTGV2ZWw6IG51bWJlcjtcbiAgICBwcml2YXRlIG1vZHVsZTogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbGV2ZWxzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xuICAgICAgICB0cmFjZTogMSxcbiAgICAgICAgZGVidWc6IDIsXG4gICAgICAgIGluZm86IDMsXG4gICAgICAgIHdhcm46IDQsXG4gICAgICAgIGVycm9yOiA1LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIExvZ2dlci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcjJ9IGxvZ01hbmFnZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbkxldmVsXG4gICAgICogQG1lbWJlcm9mIExvZ2dlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZ01hbmFnZXI6IEV2ZW50RW1pdHRlcjIsIG1vZHVsZTogc3RyaW5nLCBtaW5MZXZlbDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubG9nTWFuYWdlciA9IGxvZ01hbmFnZXI7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB0aGlzLm1pbkxldmVsID0gdGhpcy5sZXZlbFRvSW50KG1pbkxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBsZXZlbCAodHJhY2UvZGVidWcvaW5mby93YXJuL2Vycm9yKSBpbnRvIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluTGV2ZWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGxldmVsVG9JbnQobWluTGV2ZWw6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGlmIChtaW5MZXZlbC50b0xvd2VyQ2FzZSgpIGluIHRoaXMubGV2ZWxzKSByZXR1cm4gdGhpcy5sZXZlbHNbbWluTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGVsc2UgcmV0dXJuIDk5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENlbnRyYWwgbG9nZ2luZyBtZXRob2QuXG4gICAgICogQHBhcmFtIGxvZ0xldmVsXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9nKGxvZ0xldmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMubGV2ZWxUb0ludChsb2dMZXZlbCk7XG4gICAgICAgIGlmIChsZXZlbCA8IHRoaXMubWluTGV2ZWwpIHJldHVybjtcblxuICAgICAgICBjb25zdCBsb2dFbnRyeTogTG9nRW50cnkgPSB7XG4gICAgICAgICAgICBsZXZlbDogbG9nTGV2ZWwsXG4gICAgICAgICAgICBtb2R1bGU6IHRoaXMubW9kdWxlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIG9iamVjdHMsXG4gICAgICAgICAgICB0cmFjZUlkOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT2J0YWluIHRoZSBsaW5lL2ZpbGUgdGhyb3VnaCBhIHRob3JvdWdobHkgaGFja3kgbWV0aG9kXG4gICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIG5ldyBzdGFjayB0cmFjZSBhbmQgcHVsbHMgdGhlIGNhbGxlciBmcm9tIGl0LiAgSWYgdGhlIGNhbGxlclxuICAgICAgICAvLyBpZiAudHJhY2UoKVxuICAgICAgICAvLyBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignJyk7XG4gICAgICAgIC8vIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAvLyAgICAgY29uc3QgY2xhID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICAvLyAgICAgbGV0IGlkeCA9IDE7XG4gICAgICAgIC8vICAgICB3aGlsZSAoaWR4IDwgY2xhLmxlbmd0aCAmJiBjbGFbaWR4XS5pbmNsdWRlcygnYXQgTG9nZ2VyLk9iamVjdC4nKSkgaWR4Kys7XG4gICAgICAgIC8vICAgICBpZiAoaWR4IDwgY2xhLmxlbmd0aCkge1xuICAgICAgICAvLyAgICAgICAgIGxvZ0VudHJ5LmxvY2F0aW9uID0gY2xhW2lkeF0uc2xpY2UoY2xhW2lkeF0uaW5kZXhPZignYXQgJykgKyAzLCBjbGFbaWR4XS5sZW5ndGgpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgdGhpcy5sb2dNYW5hZ2VyLmVtaXQoJ2xvZycsIGxvZ0VudHJ5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJhY2UobWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nKCd0cmFjZScsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cbiAgICBwdWJsaWMgZGVidWcobWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nKCdkZWJ1ZycsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cbiAgICBwdWJsaWMgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2coJ2luZm8nLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIHdhcm4obWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nKCd3YXJuJywgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2VudHJhbCBsb2dnaW5nIG1ldGhvZCB3aXRoIGEgdHJhY2UgSUQgdG8gdHJhY2sgY2FsbHMgYmV0d2VlbiBtb2R1bGVzL2NvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIGxvZ0xldmVsXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9nV2l0aElkKGxvZ0xldmVsOiBzdHJpbmcsIHRyYWNlSWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbFRvSW50KGxvZ0xldmVsKTtcbiAgICAgICAgaWYgKGxldmVsIDwgdGhpcy5taW5MZXZlbCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5OiBMb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIGxldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5tb2R1bGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgb2JqZWN0cyxcbiAgICAgICAgICAgIHRyYWNlSWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5sb2dNYW5hZ2VyLmVtaXQoJ2xvZycsIGxvZ0VudHJ5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJhY2VXaXRoSWQodHJhY2VJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dXaXRoSWQoJ3RyYWNlJywgdHJhY2VJZCwgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyBkZWJ1Z1dpdGhJZCh0cmFjZUlkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ1dpdGhJZCgnZGVidWcnLCB0cmFjZUlkLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIGluZm9XaXRoSWQodHJhY2VJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dXaXRoSWQoJ2luZm8nLCB0cmFjZUlkLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIHdhcm5XaXRoSWQodHJhY2VJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dXaXRoSWQoJ3dhcm4nLCB0cmFjZUlkLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIGVycm9yV2l0aElkKHRyYWNlSWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nV2l0aElkKCdlcnJvcicsIHRyYWNlSWQsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cbn1cblxudHlwZSBUaW1pbmdNYXAgPSB7XG4gICAgLy8gY291bnQsIGF2ZywgbWluLCBtYXhcbiAgICBbaWQ6IHN0cmluZ106IG51bWJlcltdO1xufTtcblxuY29uc3QgdGltaW5nTWFwOiBUaW1pbmdNYXAgPSB7fTtcblxuLyoqXG4gKiBUaGlzIGRlY2VsZXJhdGlvbiB3aWxsIGxvZyB0aGUgdGltZSB0YWtlbiB0byBydW4gdGhlIGZ1bmN0aW9uIGl0IGlzIGF0dGFjaGVkIHRvLiBCZVxuICogY2FyZWZ1bCB3aGVyZSBpdCBpcyBhZGRlZCBhcyBpdCBpbmNyZWFzZXMgdGhlIG91dHB1dC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgY29uc3QgbG9nQ2FsbCA9ICh0YXJnZXQ6IE9iamVjdCwgcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIC8vY29uc3QgbG9nZ2VyID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzc3FsLnBlcmYnKTtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7dGFyZ2V0Py5jb25zdHJ1Y3Rvcj8ubmFtZX0ke3Byb3BlcnR5S2V5fWA7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBlbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCk7XG4gICAgICAgIGlmICh0aW1pbmdNYXBbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltaW5nTWFwW25hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGltaW5nTWFwW25hbWVdLnB1c2godGltZSk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aW1pbmdNYXApO1xuICAgICAgICAvLyBpZiAoZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpID4gNTApIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIC8vICAgICAgICAgYFtkZWJ1Z11bdGFza3NzcWwucGVyZl0gJHtTdHJpbmcodGltaW5nTWFwW25hbWVdLmF2ZykucGFkRW5kKDQpfSR7U3RyaW5nKFxuICAgICAgICAvLyAgICAgICAgICAgICBlbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCksXG4gICAgICAgIC8vICAgICAgICAgKS5wYWRFbmQoNCl9ICR7dGFyZ2V0Py5jb25zdHJ1Y3Rvcj8ubmFtZS5wYWRFbmQoMTApfSR7cHJvcGVydHlLZXkucGFkRW5kKDIwKX1gLFxuICAgICAgICAvLyAgICAgKTtcblxuICAgICAgICAvLyAgICAgLy8gbG9nZ2VyLmRlYnVnKFxuICAgICAgICAvLyAgICAgLy8gICAgIGAke3RhcmdldD8uY29uc3RydWN0b3I/Lm5hbWV9OiR7cHJvcGVydHlLZXl9OmNhbGxlZCB3aXRoICR7YXJncy5sZW5ndGh9IGFyZ3VtZW50cy4gVG9vazogJHtcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpXG4gICAgICAgIC8vICAgICAvLyAgICAgfW1zYCxcbiAgICAgICAgLy8gICAgIC8vICk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nQ2FsbERldGFpbHMoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzJyk7XG5cbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpKTtcbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBlbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgJHt0eXBlb2YgdGFyZ2V0fToke3Byb3BlcnR5S2V5fSBjYWxsZWQgd2l0aCAke1xuICAgICAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0gYXJndW1lbnRzLiBUb29rOiAke2VsYXBzZWR9bXMgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBzaW1wbGUgbG9nIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9nIG1lc3NhZ2VzIGFnYWluc3QgZGVmYXVsdCBtb2R1bGUuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHtUTG9nTGV2ZWxOYW1lfSBsb2dMZXZlbFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyhsb2dMZXZlbDogVExvZ0xldmVsTmFtZSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzJyk7XG5cbiAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgIGNhc2UgJ3RyYWNlJzpcbiAgICAgICAgICAgIGxvZ2dlci50cmFjZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWJ1Zyc6XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgYWxsb3dzIHRoZSBwbHVnaW4gdG8gYmUgZGVidWdnZWQgaW4gYSBtb2JpbGUgYXBwbGljYXRpb25cbiAqIGFkZCBpdCB3aGVuIGRlYnVnZ2luZyBvbiBhIGRldmljZS4gTm90IG1lYW50IHRvIGJlIHVzZWQgYnlcbiAqIGVuZCB1c2Vycy4gQWRkIGl0IGludG8gbWFpbi50cyBhbmQgcmVtb3ZlIGJlZm9yZSB5b3UgY29tbWl0LlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW5cbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb25rZXlQYXRjaENvbnNvbGUocGx1Z2luOiBQbHVnaW4pIHtcbiAgICBpZiAoIVBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dGaWxlID0gYCR7cGx1Z2luLm1hbmlmZXN0LmRpcn0vdGFza3MtbG9ncy50eHRgO1xuICAgIGNvbnN0IGxvZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgbG9nTWVzc2FnZXMgPVxuICAgICAgICAocHJlZml4OiBzdHJpbmcpID0+XG4gICAgICAgICguLi5tZXNzYWdlczogdW5rbm93bltdKSA9PiB7XG4gICAgICAgICAgICBsb2dzLnB1c2goYFxcblske3ByZWZpeH1dYCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci53cml0ZShsb2dGaWxlLCBsb2dzLmpvaW4oJyAnKSk7XG4gICAgICAgIH07XG5cbiAgICBjb25zb2xlLmRlYnVnID0gbG9nTWVzc2FnZXMoJ2RlYnVnJyk7XG4gICAgY29uc29sZS5lcnJvciA9IGxvZ01lc3NhZ2VzKCdlcnJvcicpO1xuICAgIGNvbnNvbGUuaW5mbyA9IGxvZ01lc3NhZ2VzKCdpbmZvJyk7XG4gICAgY29uc29sZS5sb2cgPSBsb2dNZXNzYWdlcygnbG9nJyk7XG4gICAgY29uc29sZS53YXJuID0gbG9nTWVzc2FnZXMoJ3dhcm4nKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXIgfSBmcm9tICcuL2xvZ2dpbmcnO1xuXG4vKipcbiAqIERlYnVnIGxvZ2dpbmcgaGVscGVyLCBmb3IgdGhlIHN0YXJ0IG9mIFRhc2stZWRpdGluZyAob3IgZmlsZS1lZGl0aW5nKSBvcGVyYXRpb25zXG4gKiBAcGFyYW0gbG9nZ2VyXG4gKiBAcGFyYW0gY29kZUxvY2F0aW9uIC0gYSBzdHJpbmcgZGVzY3JpcHRpb24sIHN1Y2ggYXMgJ2NhbGxpbmdGdW5jdGlvbk5hbWUoKScuXG4gKiBAcGFyYW0gb3JpZ2luYWxUYXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dTdGFydE9mVGFza0VkaXQobG9nZ2VyOiBMb2dnZXIsIGNvZGVMb2NhdGlvbjogc3RyaW5nLCBvcmlnaW5hbFRhc2s6IFRhc2spIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGAke2NvZGVMb2NhdGlvbn06IHRhc2sgbGluZSBudW1iZXI6ICR7b3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyfS4gZmlsZSBwYXRoOiBcIiR7b3JpZ2luYWxUYXNrLnBhdGh9XCJgLFxuICAgICk7XG4gICAgbG9nZ2VyLmRlYnVnKGAke2NvZGVMb2NhdGlvbn0gb3JpZ2luYWw6ICR7b3JpZ2luYWxUYXNrLm9yaWdpbmFsTWFya2Rvd259YCk7XG59XG5cbi8qKlxuICogRGVidWcgbG9nZ2luZyBoZWxwZXIsIGZvciB0aGUgY29tcGxldGlvbiBvZiBUYXNrLWVkaXRpbmcgKG9yIGZpbGUtZWRpdGluZykgb3BlcmF0aW9uc1xuICogQHBhcmFtIGxvZ2dlclxuICogQHBhcmFtIGNvZGVMb2NhdGlvbiAtIGEgc3RyaW5nIGRlc2NyaXB0aW9uLCBzdWNoIGFzICdjYWxsaW5nRnVuY3Rpb25OYW1lKCknLlxuICogQHBhcmFtIG5ld1Rhc2tzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dFbmRPZlRhc2tFZGl0KGxvZ2dlcjogTG9nZ2VyLCBjb2RlTG9jYXRpb246IHN0cmluZywgbmV3VGFza3M6IFRhc2tbXSkge1xuICAgIG5ld1Rhc2tzLm1hcCgodGFzazogVGFzaywgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAvLyBBbGlnbm1lbnQgb2YgdGFzayBsaW5lcyBpcyBpbnRlbnRpb25hbGx5IGNvbnNpc3RlbnQgYmV0d2VlbiBsb2dTdGFydE9mVGFza0VkaXQoKSBhbmQgdGhpczpcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NvZGVMb2NhdGlvbn0gPT0+ICR7aW5kZXggKyAxfSAgIDogJHt0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKX1gKTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBUYXNrc0ZpbGUgfSBmcm9tICcuLi9TY3JpcHRpbmcvVGFza3NGaWxlJztcbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG4vKipcbiAqIEltcGxlbWVudCBkYXRlIGZyb20gcGF0aCBkZXRlY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGVGYWxsYmFjayB7XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBwYXJzZSB0aGUgZmlsZW5hbWUgdG8gZXh0cmFjdCBhIGRhdGUgdGFraW5nIHVzZXIgc2V0dGluZ3MgaW50byBhY2NvdW50LiBJZiBkYXRlIGluZmVyZW5jZSBpcyBub3RcbiAgICAgKiBlbmFibGVkIHBhcnNpbmcgaXMgYnlwYXNzZWQgYW5kIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZVxuICAgICAqIEByZXR1cm4gYSBNb21lbnQgb3IgbnVsbCBpZiBubyBkYXRlIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21QYXRoKHBhdGg6IHN0cmluZyk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCB7IHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlLCBmaWxlbmFtZUFzRGF0ZUZvbGRlcnMgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgLy8gZmVhdHVyZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlc0FueUZvbGRlcihmaWxlbmFtZUFzRGF0ZUZvbGRlcnMsIHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBmaWxlIGlzIG5vdCBpbiBhbnkgZm9sZGVyIG9yIHN1YmZvbGRlciB0aGF0IHdhcyBzZWxlY3RlZCBmb3IgZGF0ZSBpbmZlcmVuY2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGVGcm9tUGF0aChwYXRoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYXRjaGVzQW55Rm9sZGVyKGZvbGRlcnM6IHN0cmluZ1tdLCBwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGZvbGRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBubyBjb25zdHJhaW50cyBvbiBtYXRjaGluZyBmb2xkZXJzXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvbGRlcnMgbmV2ZXIgZW5kIHdpdGggYSAnLycsIGFuZCBwYXRocyBjb250YWluIGF0IGxlYXN0IG9uIHNsYXNoIChzZXBhcmF0aW5nIHRoZSBmb2xkZXIgZnJvbSB0aGVcbiAgICAgICAgLy8gZmlsZW5hbWUpXG4gICAgICAgIHJldHVybiBmb2xkZXJzLnNvbWUoKGZvbGRlcikgPT4gcGF0aC5zdGFydHNXaXRoKGZvbGRlciArICcvJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGV4dHJhY3REYXRlRnJvbVBhdGgocGF0aDogc3RyaW5nKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gTWF0aC5tYXgoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb3MgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLnN1YnN0cmluZyhmaXJzdFBvcywgbGFzdFBvcyk7XG5cbiAgICAgICAgbGV0IGRhdGVNYXRjaCA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KS8uZXhlYyhiYXNlbmFtZSk7XG4gICAgICAgIGlmICghZGF0ZU1hdGNoKSBkYXRlTWF0Y2ggPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pLy5leGVjKGJhc2VuYW1lKTtcblxuICAgICAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gd2luZG93Lm1vbWVudChbcGFyc2VJbnQoZGF0ZU1hdGNoWzFdKSwgcGFyc2VJbnQoZGF0ZU1hdGNoWzJdKSAtIDEsIHBhcnNlSW50KGRhdGVNYXRjaFszXSldKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWZmIGEgZmFsbGJhY2sgY2FuIGJlIHNldFxuICAgICAqKi9cbiAgICBwdWJsaWMgc3RhdGljIGNhbkFwcGx5RmFsbGJhY2soe1xuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgfToge1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3RhcnREYXRlID09PSBudWxsICYmIGR1ZURhdGUgPT09IG51bGwgJiYgc2NoZWR1bGVkRGF0ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdGhlIGxvZ2ljIHRvIHVwZGF0ZSB0aGUgZmllbGRzIHJlbGF0ZWQgdG8gZGF0ZSBmYWxsYmFjayBvZiBhIHRhc2sgd2hlbiBpdHMgZmlsZSBoYXMgbW92ZWRcbiAgICAgKiBAcGFyYW0gdGFzayAgICAgICAgIC0gdGFzayB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gbmV3UGF0aCAgICAgIC0gbmV3IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIGZhbGxiYWNrRGF0ZSAtIGZhbGxiYWNrIGRhdGUgZnJvbSBuZXcgbG9jYXRpb24sIGZvciBlZmZpY2llbmN5LiBDYW4gYmUgbnVsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlVGFza1BhdGgodGFzazogVGFzaywgbmV3UGF0aDogc3RyaW5nLCBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGwpOiBUYXNrIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB3aXRoIHZhbHVlcyBmcm9tIGJlZm9yZSB0aGUgcGF0aCB3YXMgY2hhbmdlZFxuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZSA9IHRhc2suc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gdGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZDtcblxuICAgICAgICBpZiAoZmFsbGJhY2tEYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggZG9lc24ndCBjb250YWluIGEgZGF0ZS4uLlxuXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhlIHByZXZpb3VzIHBhdGggaGFkIG9uZSA6IHJlbW92ZSBpbmZlcnJlZCBkYXRlIGZyb20gVGFza1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB0aGUgb2xkIHBhdGggZGlkbid0IGNvbnRhaW4gYW55IGVpdGhlciA6XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZywgYW5kIGtlZXAgYW55IGV4cGxpY2l0bHkgc2V0IHNjaGVkdWxlZCBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggY29udGFpbnMgYSBkYXRlLi4uXG5cbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCkge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB3ZSB1c2VkIHRoZSBmYWxsYmFjayBkYXRlIGZyb20gdGhlIHByZXZpb3VzIHBhdGggOlxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgbmV3IHBhdGhcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gZmFsbGJhY2tEYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbkFwcGx5RmFsbGJhY2sodGFzaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5hbmQgdGhlIHRhc2sgaXMgY2FuZGlkYXRlIHRvIGRhdGUgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBzZXN0IHRoZSBzY2hlZHVsZWQgZGF0ZSBmcm9tIHRoZSBuZXcgcGF0aFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUgPSBmYWxsYmFja0RhdGU7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBleGlzdGluZyBkYXRlcywgaW5jbHVkaW5nIGV4cGxpY2l0IHNjaGVkdWxlZERhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50YXNrLFxuICAgICAgICAgICAgdGFza0xvY2F0aW9uOiB0YXNrLnRhc2tMb2NhdGlvbi5mcm9tUmVuYW1lZEZpbGUobmV3IFRhc2tzRmlsZShuZXdQYXRoKSksXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBhcnJheSBvZiB1cGRhdGVkIHRhc2tzIHRvIHJlbW92ZSB0aGUgaW5mZXJyZWQgc2NoZWR1bGVkIGRhdGUgc3RhdHVzIGlmIHRoZSBzY2hlZHVsZWQgZGF0ZSBoYXMgYmVlblxuICAgICAqIG1vZGlmaWVkIGFzIGNvbXBhcmVkIHRvIHRoZSBvcmlnaW5hbCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVJbmZlcnJlZFN0YXR1c0lmTmVlZGVkKG9yaWdpbmFsVGFzazogVGFzaywgdXBkYXRlZFRhc2tzOiBUYXNrW10pOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFNjaGVkdWxlZERhdGUgPSBvcmlnaW5hbFRhc2suc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPyBvcmlnaW5hbFRhc2suc2NoZWR1bGVkRGF0ZSA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUYXNrcy5tYXAoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNjaGVkdWxlZERhdGUgIT09IG51bGwgJiYgIWluZmVycmVkU2NoZWR1bGVkRGF0ZS5pc1NhbWUodGFzay5zY2hlZHVsZWREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGZhbGxiYWNrIGRhdGUgd2FzIHVzZWQgYmVmb3JlIG1vZGlmaWNhdGlvbiwgYW5kIHRoZSBzY2hlZHVsZWQgZGF0ZSB3YXMgbW9kaWZpZWQsIHdlIGhhdmUgdG8gbWFya1xuICAgICAgICAgICAgICAgIC8vIHRoZSBzY2hlZHVsZWQgZGF0ZSBhcyBub3QgaW5mZXJyZWQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICB0YXNrID0gbmV3IFRhc2soeyAuLi50YXNrLCBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNsYXNzIExpc3RJdGVtIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcGFyZW50OiBMaXN0SXRlbSB8IG51bGwgPSBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBjaGlsZHJlbjogTGlzdEl0ZW1bXTtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogTGlzdEl0ZW0gfCBudWxsLCBjaGlsZHJlbjogTGlzdEl0ZW1bXSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG5leHBvcnQgY2xhc3MgVXJnZW5jeSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZHVlQ29lZmZpY2llbnQgPSAxMi4wO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHNjaGVkdWxlZENvZWZmaWNpZW50ID0gNS4wO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHN0YXJ0ZWRDb2VmZmljaWVudCA9IC0zLjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcHJpb3JpdHlDb2VmZmljaWVudCA9IDYuMDtcblxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IG1pbGxpU2Vjb25kc1BlckRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG5cbiAgICBwdWJsaWMgc3RhdGljIGNhbGN1bGF0ZSh0YXNrOiBUYXNrKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHVyZ2VuY3kgPSAwLjA7XG5cbiAgICAgICAgaWYgKHRhc2suZHVlRGF0ZT8uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBNYXAgYSByYW5nZSBvZiAyMSBkYXlzIHRvIHRoZSB2YWx1ZSAwLjIgLSAxLjBcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2ZUb2RheSA9IHdpbmRvdy5tb21lbnQoKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGRheXNPdmVyZHVlID0gTWF0aC5yb3VuZChzdGFydE9mVG9kYXkuZGlmZih0YXNrLmR1ZURhdGUpIC8gVXJnZW5jeS5taWxsaVNlY29uZHNQZXJEYXkpO1xuXG4gICAgICAgICAgICBsZXQgZHVlTXVsdGlwbGllcjogbnVtYmVyO1xuICAgICAgICAgICAgaWYgKGRheXNPdmVyZHVlID49IDcuMCkge1xuICAgICAgICAgICAgICAgIGR1ZU11bHRpcGxpZXIgPSAxLjA7IC8vIDwgMSB3ayBhZ29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF5c092ZXJkdWUgPj0gLTE0LjApIHtcbiAgICAgICAgICAgICAgICAvLyBEdWUgYmV0d2VlbiA3IGRheXMgKCs3KSBhZ28gYW5kIGluIDE0IGRheXMgKC0xNClcbiAgICAgICAgICAgICAgICBkdWVNdWx0aXBsaWVyID0gKChkYXlzT3ZlcmR1ZSArIDE0LjApICogMC44KSAvIDIxLjAgKyAwLjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1ZU11bHRpcGxpZXIgPSAwLjI7IC8vID4gMiB3a3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJnZW5jeSArPSBkdWVNdWx0aXBsaWVyICogVXJnZW5jeS5kdWVDb2VmZmljaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLnNjaGVkdWxlZERhdGU/LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tb21lbnQoKS5pc1NhbWVPckFmdGVyKHRhc2suc2NoZWR1bGVkRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDEgKiBVcmdlbmN5LnNjaGVkdWxlZENvZWZmaWNpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2suc3RhcnREYXRlPy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubW9tZW50KCkuaXNCZWZvcmUodGFzay5zdGFydERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAxICogVXJnZW5jeS5zdGFydGVkQ29lZmZpY2llbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRhc2sucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIC8vIEhpZ2hlc3RcbiAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMS41ICogVXJnZW5jeS5wcmlvcml0eUNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSGlnaFxuICAgICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAxLjAgKiBVcmdlbmN5LnByaW9yaXR5Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBNZWRpdW1cbiAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMC42NSAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIE5vbmVcbiAgICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMC4zMjUgKiBVcmdlbmN5LnByaW9yaXR5Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBubyBtb2RpZmljYXRpb24gZm9yIFwiTG93XCIgcHJpb3JpdHlcbiAgICAgICAgICAgIC8vIExvd2VzdFxuICAgICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSAtPSAwLjMgKiBVcmdlbmN5LnByaW9yaXR5Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJnZW5jeTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB0eXBlIHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzJztcbmltcG9ydCB7IGNvbXBhcmVCeURhdGUgfSBmcm9tICcuLi9saWIvRGF0ZVRvb2xzJztcbmltcG9ydCB7IFRhc2tzRGF0ZSB9IGZyb20gJy4uL1NjcmlwdGluZy9UYXNrc0RhdGUnO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBUYXNrc0ZpbGUgfSBmcm9tICcuLi9TY3JpcHRpbmcvVGFza3NGaWxlJztcbmltcG9ydCB7IFByaW9yaXR5VG9vbHMgfSBmcm9tICcuLi9saWIvUHJpb3JpdHlUb29scyc7XG5pbXBvcnQgeyBsb2dnaW5nIH0gZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgbG9nRW5kT2ZUYXNrRWRpdCwgbG9nU3RhcnRPZlRhc2tFZGl0IH0gZnJvbSAnLi4vbGliL0xvZ1Rhc2tzSGVscGVyJztcbmltcG9ydCB7IERhdGVGYWxsYmFjayB9IGZyb20gJy4vRGF0ZUZhbGxiYWNrJztcbmltcG9ydCB7IExpc3RJdGVtIH0gZnJvbSAnLi9MaXN0SXRlbSc7XG5pbXBvcnQgeyBVcmdlbmN5IH0gZnJvbSAnLi9VcmdlbmN5JztcbmltcG9ydCB0eXBlIHsgUmVjdXJyZW5jZSB9IGZyb20gJy4vUmVjdXJyZW5jZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4vVGFza0xvY2F0aW9uJztcbmltcG9ydCB0eXBlIHsgUHJpb3JpdHkgfSBmcm9tICcuL1ByaW9yaXR5JztcbmltcG9ydCB7IFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMgfSBmcm9tICcuL1Rhc2tSZWd1bGFyRXhwcmVzc2lvbnMnO1xuXG4vKipcbiAqIFN0b3JhZ2UgZm9yIHRoZSB0YXNrIGxpbmUsIGJyb2tlbiBkb3duIGluIHRvIHNlY3Rpb25zLlxuICogU2VlIHtAbGluayBUYXNrLmV4dHJhY3RUYXNrQ29tcG9uZW50c30gZm9yIHVzZS5cbiAqL1xuaW50ZXJmYWNlIFRhc2tDb21wb25lbnRzIHtcbiAgICBpbmRlbnRhdGlvbjogc3RyaW5nO1xuICAgIGxpc3RNYXJrZXI6IHN0cmluZztcbiAgICBzdGF0dXM6IFN0YXR1cztcbiAgICBib2R5OiBzdHJpbmc7XG4gICAgYmxvY2tMaW5rOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGFzayBlbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIE1hcmtEb3duIHRhc2sgYWxvbmcgd2l0aFxuICogdGhlIGV4dGVuc2lvbnMgcHJvdmlkZWQgYnkgdGhpcyBwbHVnaW4uIFRoaXMgaXMgdXNlZCB0byBwYXJzZSBhbmRcbiAqIGdlbmVyYXRlIHRoZSBtYXJrZG93biB0YXNrIGZvciBhbGwgdXBkYXRlcyBhbmQgcmVwbGFjZW1lbnRzLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUYXNrXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrIGV4dGVuZHMgTGlzdEl0ZW0ge1xuICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhdHVzOiBTdGF0dXM7XG4gICAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGluZGVudGF0aW9uOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGxpc3RNYXJrZXI6IHN0cmluZztcblxuICAgIHB1YmxpYyByZWFkb25seSB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbjtcblxuICAgIHB1YmxpYyByZWFkb25seSB0YWdzOiBzdHJpbmdbXTtcblxuICAgIHB1YmxpYyByZWFkb25seSBwcmlvcml0eTogUHJpb3JpdHk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY3JlYXRlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVtaW5kZXJEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBkb25lRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsbGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcblxuICAgIHB1YmxpYyByZWFkb25seSByZWN1cnJlbmNlOiBSZWN1cnJlbmNlIHwgbnVsbDtcblxuICAgIHB1YmxpYyByZWFkb25seSBkZXBlbmRzT246IHN0cmluZ1tdO1xuICAgIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBibG9ja0xpbmsgaXMgYSBcIl5cIiBhbm5vdGF0aW9uIGFmdGVyIHRoZSBkYXRlcy9yZWN1cnJlbmNlIHJ1bGVzLlxuICAgICAqIEFueSBub24tZW1wdHkgdmFsdWUgbXVzdCBiZWdpbiB3aXRoICcgXicuICovXG4gICAgcHVibGljIHJlYWRvbmx5IGJsb2NrTGluazogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBvcmlnaW5hbCBsaW5lIHJlYWQgZnJvbSBmaWxlLlxuICAgICAqXG4gICAgICogV2lsbCBiZSBlbXB0eSBpZiBUYXNrIHdhcyBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgKiAoZm9yIGV4YW1wbGUsIGJ5IENyZWF0ZSBvciBFZGl0IFRhc2ssIG9yIGluIHRlc3RzLCBpbmNsdWRpbmcgdmlhIHtAbGluayBUYXNrQnVpbGRlcn0pLiAqL1xuICAgIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbE1hcmtkb3duOiBzdHJpbmc7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQ6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF91cmdlbmN5OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB0YXNrTG9jYXRpb24sXG4gICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICBsaXN0TWFya2VyLFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgY3JlYXRlZERhdGUsXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgcmVtaW5kZXJEYXRlLFxuICAgICAgICBkb25lRGF0ZSxcbiAgICAgICAgY2FuY2VsbGVkRGF0ZSxcbiAgICAgICAgcmVjdXJyZW5jZSxcbiAgICAgICAgZGVwZW5kc09uLFxuICAgICAgICBpZCxcbiAgICAgICAgYmxvY2tMaW5rLFxuICAgICAgICB0YWdzLFxuICAgICAgICBvcmlnaW5hbE1hcmtkb3duLFxuICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCxcbiAgICB9OiB7XG4gICAgICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICAgICAgc3RhdHVzOiBTdGF0dXM7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uO1xuICAgICAgICBpbmRlbnRhdGlvbjogc3RyaW5nO1xuICAgICAgICBsaXN0TWFya2VyOiBzdHJpbmc7XG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eTtcbiAgICAgICAgY3JlYXRlZERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICBzdGFydERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIHJlbWluZGVyRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIGRvbmVEYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgY2FuY2VsbGVkRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsO1xuICAgICAgICBkZXBlbmRzT246IHN0cmluZ1tdIHwgW107XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIGJsb2NrTGluazogc3RyaW5nO1xuICAgICAgICB0YWdzOiBzdHJpbmdbXSB8IFtdO1xuICAgICAgICBvcmlnaW5hbE1hcmtkb3duOiBzdHJpbmc7XG4gICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkOiBib29sZWFuO1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIobnVsbCwgW10pO1xuICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgdGhpcy5saXN0TWFya2VyID0gbGlzdE1hcmtlcjtcbiAgICAgICAgdGhpcy50YXNrTG9jYXRpb24gPSB0YXNrTG9jYXRpb247XG5cbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcblxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVkRGF0ZSA9IGNyZWF0ZWREYXRlO1xuICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREYXRlID0gc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgdGhpcy5kdWVEYXRlID0gZHVlRGF0ZTtcbiAgICAgICAgdGhpcy5yZW1pbmRlckRhdGUgPSByZW1pbmRlckRhdGU7XG4gICAgICAgIHRoaXMuZG9uZURhdGUgPSBkb25lRGF0ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWREYXRlID0gY2FuY2VsbGVkRGF0ZTtcblxuICAgICAgICB0aGlzLnJlY3VycmVuY2UgPSByZWN1cnJlbmNlO1xuXG4gICAgICAgIHRoaXMuZGVwZW5kc09uID0gZGVwZW5kc09uO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAgICAgdGhpcy5ibG9ja0xpbmsgPSBibG9ja0xpbms7XG4gICAgICAgIHRoaXMub3JpZ2luYWxNYXJrZG93biA9IG9yaWdpbmFsTWFya2Rvd247XG5cbiAgICAgICAgdGhpcy5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZCA9IHNjaGVkdWxlZERhdGVJc0luZmVycmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSBnaXZlbiBsaW5lIGZyb20gYW4gT2JzaWRpYW4gbm90ZSBhbmQgcmV0dXJucyBhIFRhc2sgb2JqZWN0LlxuICAgICAqIFdpbGwgY2hlY2sgaWYgR2xvYmFsIEZpbHRlciBpcyBwcmVzZW50IGluIHRoZSBsaW5lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIC0gVGhlIGZ1bGwgbGluZSBpbiB0aGUgbm90ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge1Rhc2tMb2NhdGlvbn0gdGFza0xvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIG9mIHRoZSB0YXNrIGxpbmVcbiAgICAgKiBAcGFyYW0geyhNb21lbnQgfCBudWxsKX0gZmFsbGJhY2tEYXRlIC0gVGhlIGRhdGUgdG8gdXNlIGFzIHRoZSBzY2hlZHVsZWQgZGF0ZSBpZiBubyBvdGhlciBkYXRlIGlzIHNldFxuICAgICAqIEByZXR1cm4geyp9ICB7KFRhc2sgfCBudWxsKX1cbiAgICAgKiBAbWVtYmVyb2YgVGFza1xuICAgICAqIEBzZWUgcGFyc2VUYXNrU2lnbmlmaWVyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUxpbmUoe1xuICAgICAgICBsaW5lLFxuICAgICAgICB0YXNrTG9jYXRpb24sXG4gICAgICAgIGZhbGxiYWNrRGF0ZSxcbiAgICB9OiB7XG4gICAgICAgIGxpbmU6IHN0cmluZztcbiAgICAgICAgdGFza0xvY2F0aW9uOiBUYXNrTG9jYXRpb247XG4gICAgICAgIGZhbGxiYWNrRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICB9KTogVGFzayB8IG51bGwge1xuICAgICAgICBjb25zdCB0YXNrQ29tcG9uZW50cyA9IFRhc2suZXh0cmFjdFRhc2tDb21wb25lbnRzKGxpbmUpO1xuICAgICAgICAvLyBDaGVjayB0aGUgbGluZSB0byBzZWUgaWYgaXQgaXMgYSBtYXJrZG93biB0YXNrLlxuICAgICAgICBpZiAodGFza0NvbXBvbmVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGlmIHRoZSBsaW5lIGRvZXMgbm90IGhhdmUgdGhlIGdsb2JhbCBmaWx0ZXIuIERvIHRoaXMgYmVmb3JlXG4gICAgICAgIC8vIGFueSBvdGhlciBwcm9jZXNzaW5nIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIGlmICghR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuaW5jbHVkZWRJbih0YXNrQ29tcG9uZW50cy5ib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVGFzay5wYXJzZVRhc2tTaWduaWZpZXJzKGxpbmUsIHRhc2tMb2NhdGlvbiwgZmFsbGJhY2tEYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGxpbmUgaW4gYXR0ZW1wdCB0byBnZXQgdGhlIHRhc2sgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVhZHMgdGhlIHRhc2sgZXZlbiBpZiB0aGUgR2xvYmFsIEZpbHRlciBpcyBtaXNzaW5nLlxuICAgICAqIElmIGEgR2xvYmFsIEZpbHRlciBjaGVjayBpcyBuZWVkZWQsIHVzZSB7QGxpbmsgVGFzay5mcm9tTGluZX0uXG4gICAgICpcbiAgICAgKiBUYXNrIGlzIHJldHVybmVkIHJlZ2FyZGxlc3MgaWYgR2xvYmFsIEZpbHRlciBpcyBwcmVzZW50IG9yIG5vdC5cbiAgICAgKiBIb3dldmVyLCBpZiBpdCBpcywgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHRhZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSAtIHRoZSBmdWxsIGxpbmUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0gdGFza0xvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIG9mIHRoZSB0YXNrIGxpbmVcbiAgICAgKiBAcGFyYW0gZmFsbGJhY2tEYXRlIC0gVGhlIGRhdGUgdG8gdXNlIGFzIHRoZSBzY2hlZHVsZWQgZGF0ZSBpZiBubyBvdGhlciBkYXRlIGlzIHNldFxuICAgICAqIEByZXR1cm5zIHsqfSB7KFRhc2sgfCBudWxsKX1cbiAgICAgKiBAc2VlIGZyb21MaW5lXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZVRhc2tTaWduaWZpZXJzKFxuICAgICAgICBsaW5lOiBzdHJpbmcsXG4gICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLFxuICAgICAgICBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGwsXG4gICAgKTogVGFzayB8IG51bGwge1xuICAgICAgICBjb25zdCB0YXNrQ29tcG9uZW50cyA9IFRhc2suZXh0cmFjdFRhc2tDb21wb25lbnRzKGxpbmUpO1xuICAgICAgICAvLyBDaGVjayB0aGUgbGluZSB0byBzZWUgaWYgaXQgaXMgYSBtYXJrZG93biB0YXNrLlxuICAgICAgICBpZiAodGFza0NvbXBvbmVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB0YXNrU2VyaWFsaXplciB9ID0gZ2V0VXNlclNlbGVjdGVkVGFza0Zvcm1hdCgpO1xuICAgICAgICBjb25zdCB0YXNrSW5mbyA9IHRhc2tTZXJpYWxpemVyLmRlc2VyaWFsaXplKHRhc2tDb21wb25lbnRzLmJvZHkpO1xuXG4gICAgICAgIGxldCBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJbmZlciB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgZmlsZSBuYW1lIGlmIG5vdCBzZXQgZXhwbGljaXRseVxuICAgICAgICBpZiAoRGF0ZUZhbGxiYWNrLmNhbkFwcGx5RmFsbGJhY2sodGFza0luZm8pICYmIGZhbGxiYWNrRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGFza0luZm8uc2NoZWR1bGVkRGF0ZSA9IGZhbGxiYWNrRGF0ZTtcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdoaXRlc3BhY2UgaXMgcmVtb3ZlZCBhcm91bmQgdGFnc1xuICAgICAgICB0YXNrSW5mby50YWdzID0gdGFza0luZm8udGFncy5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBHbG9iYWwgRmlsdGVyIGlmIGl0IGlzIHRoZXJlXG4gICAgICAgIHRhc2tJbmZvLnRhZ3MgPSB0YXNrSW5mby50YWdzLmZpbHRlcigodGFnKSA9PiAhR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuZXF1YWxzKHRhZykpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50YXNrQ29tcG9uZW50cyxcbiAgICAgICAgICAgIC4uLnRhc2tJbmZvLFxuICAgICAgICAgICAgdGFza0xvY2F0aW9uOiB0YXNrTG9jYXRpb24sXG4gICAgICAgICAgICBvcmlnaW5hbE1hcmtkb3duOiBsaW5lLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGNvbXBvbmVudCBwYXJ0cyBvZiB0aGUgdGFzayBsaW5lLlxuICAgICAqIEBwYXJhbSBsaW5lXG4gICAgICogQHJldHVybnMgYSB7QGxpbmsgVGFza0NvbXBvbmVudHN9IG9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnQgcGFydHMgb2YgdGhlIHRhc2sgbGluZVxuICAgICAqL1xuICAgIHN0YXRpYyBleHRyYWN0VGFza0NvbXBvbmVudHMobGluZTogc3RyaW5nKTogVGFza0NvbXBvbmVudHMgfCBudWxsIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxpbmUgdG8gc2VlIGlmIGl0IGlzIGEgbWFya2Rvd24gdGFzay5cbiAgICAgICAgY29uc3QgcmVnZXhNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgpO1xuICAgICAgICBpZiAocmVnZXhNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IHJlZ2V4TWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IGxpc3RNYXJrZXIgPSByZWdleE1hdGNoWzJdO1xuXG4gICAgICAgIC8vIEdldCB0aGUgc3RhdHVzIG9mIHRoZSB0YXNrLlxuICAgICAgICBjb25zdCBzdGF0dXNTdHJpbmcgPSByZWdleE1hdGNoWzNdO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLmJ5U3ltYm9sT3JDcmVhdGUoc3RhdHVzU3RyaW5nKTtcblxuICAgICAgICAvLyBtYXRjaFs0XSBpbmNsdWRlcyB0aGUgd2hvbGUgYm9keSBvZiB0aGUgdGFzayBhZnRlciB0aGUgYnJhY2tldHMuXG4gICAgICAgIGxldCBib2R5ID0gcmVnZXhNYXRjaFs0XS50cmltKCk7XG5cbiAgICAgICAgLy8gTWF0Y2ggZm9yIGJsb2NrIGxpbmsgYW5kIHJlbW92ZSBpZiBmb3VuZC4gQWx3YXlzIGV4cGVjdGVkIHRvIGJlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgIGNvbnN0IGJsb2NrTGlua01hdGNoID0gYm9keS5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLmJsb2NrTGlua1JlZ2V4KTtcbiAgICAgICAgY29uc3QgYmxvY2tMaW5rID0gYmxvY2tMaW5rTWF0Y2ggIT09IG51bGwgPyBibG9ja0xpbmtNYXRjaFswXSA6ICcnO1xuXG4gICAgICAgIGlmIChibG9ja0xpbmsgIT09ICcnKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYmxvY2tMaW5rUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW5kZW50YXRpb24sIGxpc3RNYXJrZXIsIHN0YXR1cywgYm9keSwgYmxvY2tMaW5rIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW4gdGhlIHRhc2sgYXMgYSBzdHJpbmcgdGhhdCBpbmNsdWRlcyBhbGwgaXRzIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAbm90ZSBPdXRwdXQgZGVwZW5kcyBvbiB7QGxpbmsgU2V0dGluZ3MudGFza0Zvcm1hdH1cbiAgICAgKiBAcmV0dXJuIHsqfSAge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgVGFza1xuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZ2V0VXNlclNlbGVjdGVkVGFza0Zvcm1hdCgpLnRhc2tTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUYXNrIGFzIGEgbGlzdCBpdGVtIHdpdGggYSBjaGVja2JveC5cbiAgICAgKlxuICAgICAqIEBub3RlIE91dHB1dCBkZXBlbmRzIG9uIHtAbGluayBTZXR0aW5ncy50YXNrRm9ybWF0fVxuICAgICAqIEByZXR1cm4geyp9ICB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBUYXNrXG4gICAgICovXG4gICAgcHVibGljIHRvRmlsZUxpbmVTdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaW5kZW50YXRpb259JHt0aGlzLmxpc3RNYXJrZXJ9IFske3RoaXMuc3RhdHVzLnN5bWJvbH1dICR7dGhpcy50b1N0cmluZygpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGlzIHRhc2sgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0YXNrKHMpLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIGtub3cgd2hpY2ggaXMgdGhlIG9yaWdpbmFsIChjb21wbGV0ZWQpXG4gICAgICogdGFzayBhbmQgd2hpY2ggaXMgdGhlIG5ldyByZWN1cnJlbmNlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRhc2sgaXMgbm90IHJlY3VycmluZywgaXQgd2lsbCByZXR1cm4gYFt0b2dnbGVkXWAuXG4gICAgICpcbiAgICAgKiBUb2dnbGluZyBjYW4gcmVzdWx0IGluIG1vcmUgdGhhbiBvbmUgcmV0dXJuZWQgdGFzayBpbiB0aGUgY2FzZSBvZlxuICAgICAqIHJlY3VycmVuY2UuIEluIHRoaXMgY2FzZSwgdGhlIHRvZ2dsZWQgdGFzayB3aWxsIGJlIHJldHVybmVkXG4gICAgICogdG9nZXRoZXIgd2l0aCB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZSBvcmRlciBgW25leHQsIHRvZ2dsZWRdYC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdG8gdXNlIHVzZXIgc2V0IG9yZGVyIGBbbmV4dCwgdG9nZ2xlZF1gXG4gICAgICogb3IgYFt0b2dnbGVkLCBuZXh0XWAgLSB7QGxpbmsgdG9nZ2xlV2l0aFJlY3VycmVuY2VJblVzZXJzT3JkZXJ9LlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBsb2dnZXIgPSBsb2dnaW5nLmdldExvZ2dlcigndGFza3MuVGFzaycpO1xuICAgICAgICBjb25zdCBjb2RlTG9jYXRpb24gPSAndG9nZ2xlKCknO1xuICAgICAgICBsb2dTdGFydE9mVGFza0VkaXQobG9nZ2VyLCBjb2RlTG9jYXRpb24sIHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IG5ld1N0YXR1cyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuZ2V0TmV4dFN0YXR1c09yQ3JlYXRlKHRoaXMuc3RhdHVzKTtcblxuICAgICAgICBjb25zdCBuZXdUYXNrcyA9IHRoaXMuaGFuZGxlTmV3U3RhdHVzKG5ld1N0YXR1cyk7XG4gICAgICAgIGxvZ0VuZE9mVGFza0VkaXQobG9nZ2VyLCBjb2RlTG9jYXRpb24sIG5ld1Rhc2tzKTtcbiAgICAgICAgcmV0dXJuIG5ld1Rhc2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXRzIHRoZSB7QGxpbmsgc3RhdHVzfSBvZiB0aGlzIHRhc2sgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0YXNrKHMpLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIGtub3cgd2hpY2ggaXMgdGhlIG9yaWdpbmFsIChlZGl0ZWQpXG4gICAgICogdGFzayBhbmQgd2hpY2ggaXMgdGhlIG5ldyByZWN1cnJlbmNlLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFzayBpcyBub3QgcmVjdXJyaW5nLCBpdCB3aWxsIHJldHVybiBgW2VkaXRlZF1gLFxuICAgICAqIG9yIGBbdGhpc11gIGlmIHRoZSBzdGF0dXMgaXMgdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogRWRpdGluZyB0aGUgc3RhdHVzIGNhbiByZXN1bHQgaW4gbW9yZSB0aGFuIG9uZSByZXR1cm5lZCB0YXNrIGluIHRoZSBjYXNlIG9mXG4gICAgICogcmVjdXJyZW5jZS4gSW4gdGhpcyBjYXNlLCB0aGUgZWRpdGVkIHRhc2sgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIHRvZ2V0aGVyIHdpdGggdGhlIG5leHQgb2NjdXJyZW5jZSBpbiB0aGUgb3JkZXIgYFtuZXh0LCBlZGl0ZWRdYC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdG8gdXNlIHVzZXIgc2V0IG9yZGVyIGBbbmV4dCwgZWRpdGVkXWBcbiAgICAgKiBvciBgW3RvZ2dsZWQsIG5leHRdYCAtIHtAbGluayBoYW5kbGVOZXdTdGF0dXNXaXRoUmVjdXJyZW5jZUluVXNlcnNPcmRlcn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3U3RhdHVzXG4gICAgICogQHBhcmFtIHRvZGF5IC0gT3B0aW9uYWwgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBsZXRpb24gZGF0ZS4gVGhpcyBkZWZhdWx0cyB0byB0b2RheS5cbiAgICAgKiAgICAgICAgICAgICAgICBJdCBpcyB1c2VkIGZvciBhbnkgbmV3IGRvbmUgZGF0ZSwgYW5kIGZvciB0aGUgY2FsY3VsYXRpb24gb2YgbmV3XG4gICAgICogICAgICAgICAgICAgICAgZGF0ZXMgb24gcmVjdXJyaW5nIHRhc2tzIHRoYXQgYXJlIG1hcmtlZCBhcyAnd2hlbiBkb25lJy5cbiAgICAgKiAgICAgICAgICAgICAgICBIb3dldmVyLCBhbnkgY3JlYXRlZCBkYXRlIG9uIGEgbmV3IHJlY3VycmVuY2UgaXMsIGZvciBub3csIGNhbGN1bGF0ZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICBhY3R1YWwgY3VycmVudCBkYXRlLCByYXRoZXIgdGhhbiB0aGlzIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlTmV3U3RhdHVzKG5ld1N0YXR1czogU3RhdHVzLCB0b2RheSA9IHdpbmRvdy5tb21lbnQoKSk6IFRhc2tbXSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMuaWRlbnRpY2FsVG8odGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBUYXNrIG9iamVjdCBpZiB0aGUgbmV3IHN0YXR1cyBiZWhhdmlvdXIgaXMgaWRlbnRpY2FsIHRvIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNldERvbmVEYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zdCBuZXdEb25lRGF0ZSA9IHRoaXMubmV3RGF0ZShuZXdTdGF0dXMsIFN0YXR1c1R5cGUuRE9ORSwgdGhpcy5kb25lRGF0ZSwgc2V0RG9uZURhdGUsIHRvZGF5KTtcblxuICAgICAgICBjb25zdCB7IHNldENhbmNlbGxlZERhdGUgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnN0IG5ld0NhbmNlbGxlZERhdGUgPSB0aGlzLm5ld0RhdGUoXG4gICAgICAgICAgICBuZXdTdGF0dXMsXG4gICAgICAgICAgICBTdGF0dXNUeXBlLkNBTkNFTExFRCxcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkRGF0ZSxcbiAgICAgICAgICAgIHNldENhbmNlbGxlZERhdGUsXG4gICAgICAgICAgICB0b2RheSxcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgbmV4dE9jY3VycmVuY2U6IHtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgcmVtaW5kZXJEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChuZXdTdGF0dXMuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1cy5pc0NvbXBsZXRlZCgpICYmIHRoaXMucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHRPY2N1cnJlbmNlID0gdGhpcy5yZWN1cnJlbmNlLm5leHQodG9kYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9nZ2xlZFRhc2sgPSBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgc3RhdHVzOiBuZXdTdGF0dXMsXG4gICAgICAgICAgICBkb25lRGF0ZTogbmV3RG9uZURhdGUsXG4gICAgICAgICAgICBjYW5jZWxsZWREYXRlOiBuZXdDYW5jZWxsZWREYXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBuZXdUYXNrczogVGFza1tdID0gW107XG5cbiAgICAgICAgaWYgKG5leHRPY2N1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VGFzayA9IHRoaXMuY3JlYXRlTmV4dE9jY3VycmVuY2UobmV3U3RhdHVzLCBuZXh0T2NjdXJyZW5jZSk7XG4gICAgICAgICAgICBuZXdUYXNrcy5wdXNoKG5leHRUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIG5leHQgb2NjdXJyZW5jZSBiZWZvcmUgcHJldmlvdXMgb2NjdXJyZW5jZS5cbiAgICAgICAgbmV3VGFza3MucHVzaCh0b2dnbGVkVGFzayk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1Rhc2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldyB2YWx1ZSB0byB1c2UgZm9yIGEgZGF0ZSB0aGF0IHRyYWNrcyBwcm9ncmVzcyBvbiB0YXNrcyB1cG9uIHRyYW5zaXRpb24gdG8gYSBkaWZmZXJlbnRcbiAgICAgKiB7QGxpbmsgU3RhdHVzVHlwZX0uXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHksIHRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5ldyBEb25lIERhdGUgb3IgQ2FuY2VsbGVkIERhdGUsXG4gICAgICovXG4gICAgcHJpdmF0ZSBuZXdEYXRlKFxuICAgICAgICBuZXdTdGF0dXM6IFN0YXR1cyxcbiAgICAgICAgc3RhdHVzVHlwZTogU3RhdHVzVHlwZSxcbiAgICAgICAgb2xkRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGwsXG4gICAgICAgIGRhdGVFbmFibGVkSW5TZXR0aW5nczogYm9vbGVhbixcbiAgICAgICAgdG9kYXk6IG1vbWVudC5Nb21lbnQsXG4gICAgKSB7XG4gICAgICAgIGxldCBuZXdEYXRlID0gbnVsbDtcbiAgICAgICAgaWYgKG5ld1N0YXR1cy50eXBlID09PSBzdGF0dXNUeXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSAhPT0gc3RhdHVzVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkYXRlIG9ubHkgaWYgc2V0dGluZyB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgICAgICAgIGlmIChkYXRlRW5hYmxlZEluU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZSA9IHRvZGF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0YXNrIHdhcyBhbHJlYWR5IGluIHN0YXR1c1R5cGUsIHNvIHByZXNlcnZlIGl0cyBleGlzdGluZyBkYXRlLlxuICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBvbGREYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlTmV4dE9jY3VycmVuY2UoXG4gICAgICAgIG5ld1N0YXR1czogU3RhdHVzLFxuICAgICAgICBuZXh0T2NjdXJyZW5jZToge1xuICAgICAgICAgICAgc3RhcnREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgZHVlRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICByZW1pbmRlckRhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICB9LFxuICAgICkge1xuICAgICAgICBjb25zdCB7IHNldENyZWF0ZWREYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBsZXQgY3JlYXRlZERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKHNldENyZWF0ZWREYXRlKSB7XG4gICAgICAgICAgICBjcmVhdGVkRGF0ZSA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBjYXNlIHRoZSB0YXNrIGJlaW5nIHRvZ2dsZWQgd2FzIHByZXZpb3VzbHkgY2FuY2VsbGVkLCBlbnN1cmUgdGhlIG5ldyB0YXNrIGhhcyBubyBjYW5jZWxsZWQgZGF0ZTpcbiAgICAgICAgY29uc3QgY2FuY2VsbGVkRGF0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gQWxzbyBzZXQgdGhlIG5ldyBkb25lIGRhdGUgdG8gemVybywgdG8gc2ltcGxpZnkgdGhlXG4gICAgICAgIC8vIHNhdmluZyBvZiBlZGl0ZWQgdGFza3MgaW4gdGhlIEVkaXQgVGFzayBtb2RhbDpcbiAgICAgICAgY29uc3QgZG9uZURhdGUgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IHN0YXR1c1JlZ2lzdHJ5ID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgbmV4dFN0YXR1cyA9IHN0YXR1c1JlZ2lzdHJ5LmdldE5leHRSZWN1cnJlbmNlU3RhdHVzT3JDcmVhdGUobmV3U3RhdHVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrKHtcbiAgICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgICAuLi5uZXh0T2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHN0YXR1czogbmV4dFN0YXR1cyxcbiAgICAgICAgICAgIC8vIE5ldyBvY2N1cnJlbmNlcyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBibG9jayBsaW5rLlxuICAgICAgICAgICAgLy8gQW5kIHJhbmRvbSBibG9jayBsaW5rcyBkb24ndCBoZWxwLlxuICAgICAgICAgICAgYmxvY2tMaW5rOiAnJyxcblxuICAgICAgICAgICAgLy8gTmV3IG9jY3VycmVuY2VzIGFsc28gY2Fubm90IGhhdmUgdGhlIHNhbWUgZGVwZW5kZW5jeSBmaWVsZHMuIFNlZSAjMjY1NC5cbiAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgIGRlcGVuZHNPbjogW10sXG5cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgY3JlYXRlZERhdGUgb24gcmVjdXJyaW5nIHRhc2tzXG4gICAgICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgICAgIGNhbmNlbGxlZERhdGUsXG4gICAgICAgICAgICBkb25lRGF0ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGlzIHRhc2sgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0YXNrKHMpLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGlmIHRoZSB1cGRhdGVkIHRhc2socykgYXJlIHRvIGJlIHNhdmVkLFxuICAgICAqIGFzIHRoaXMgaG9ub3VycyB0aGUgdXNlciBzZXR0aW5nIHRvIGNvbnRyb2wgdGhlIG9yZGVyXG4gICAgICogdGhlIHRhc2tzIHNob3VsZCBiZSBzYXZlZCBpbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXNrIGlzIG5vdCByZWN1cnJpbmcsIGl0IHdpbGwgcmV0dXJuIGBbdG9nZ2xlZF1gLlxuICAgICAqXG4gICAgICogVG9nZ2xpbmcgY2FuIHJlc3VsdCBpbiBtb3JlIHRoYW4gb25lIHJldHVybmVkIHRhc2sgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiByZWN1cnJlbmNlLiBJbiB0aGlzIGNhc2UsIHRoZSB0b2dnbGVkIHRhc2sgd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAqIHVzZXIgc2V0IG9yZGVyIGBbbmV4dCwgdG9nZ2xlZF1gIG9yIGBbdG9nZ2xlZCwgbmV4dF1gIGRlcGVuZGluZ1xuICAgICAqIG9uIHtAbGluayBTZXR0aW5nc30uXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbnNpZGVyIHVzZXIgc2V0dGluZ3MgY2FsbCB7QGxpbmsgdG9nZ2xlfS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVXaXRoUmVjdXJyZW5jZUluVXNlcnNPcmRlcigpOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBuZXdUYXNrcyA9IHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dFJlY3VycmVuY2VJblVzZXJzT3JkZXIobmV3VGFza3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVOZXdTdGF0dXNXaXRoUmVjdXJyZW5jZUluVXNlcnNPcmRlcihuZXdTdGF0dXM6IFN0YXR1cywgdG9kYXkgPSB3aW5kb3cubW9tZW50KCkpOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBsb2dnZXIgPSBsb2dnaW5nLmdldExvZ2dlcigndGFza3MuVGFzaycpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgY2hhbmdlZCB0YXNrICR7dGhpcy50YXNrTG9jYXRpb24ucGF0aH0gJHt0aGlzLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyfSAke3RoaXMub3JpZ2luYWxNYXJrZG93bn0gc3RhdHVzIHRvICcke25ld1N0YXR1cy5zeW1ib2x9J2AsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbmV3VGFza3MgPSB0aGlzLmhhbmRsZU5ld1N0YXR1cyhuZXdTdGF0dXMsIHRvZGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0UmVjdXJyZW5jZUluVXNlcnNPcmRlcihuZXdUYXNrcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwdXRSZWN1cnJlbmNlSW5Vc2Vyc09yZGVyKG5ld1Rhc2tzOiBUYXNrW10pIHtcbiAgICAgICAgY29uc3QgeyByZWN1cnJlbmNlT25OZXh0TGluZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIHJlY3VycmVuY2VPbk5leHRMaW5lID8gbmV3VGFza3MucmV2ZXJzZSgpIDogbmV3VGFza3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHRhc2sgaXMgY29uc2lkZXJlZCBkb25lLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHN0YXR1cyB0eXBlIGlzIHtAbGluayBTdGF0dXNUeXBlLkRPTkV9LCB7QGxpbmsgU3RhdHVzVHlwZS5DQU5DRUxMRUR9IG9yIHtAbGluayBTdGF0dXNUeXBlLk5PTl9UQVNLfSwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzRG9uZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnR5cGUgPT09IFN0YXR1c1R5cGUuRE9ORSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMudHlwZSA9PT0gU3RhdHVzVHlwZS5DQU5DRUxMRUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnR5cGUgPT09IFN0YXR1c1R5cGUuTk9OX1RBU0tcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHRhc2sgaXMgdHJlYXRlZCBhcyBibG9ja2VkIGlmIGl0IGRlcGVuZHMgb24gYW55IGV4aXN0aW5nIHRhc2sgaWRzIG9uIHRhc2tzIHRoYXQgYXJlIFRPRE8gb3IgSU5fUFJPR1JFU1MuXG4gICAgICpcbiAgICAgKiAnRG9uZScgdGFza3MgKHdpdGggc3RhdHVzIERPTkUsIENBTkNFTExFRCBvciBOT05fVEFTSykgYXJlIG5ldmVyIGJsb2NrZWQuXG4gICAgICogT25seSBkaXJlY3QgZGVwZW5kZW5jaWVzIGFyZSBjb25zaWRlcmVkLlxuICAgICAqIEBwYXJhbSBhbGxUYXNrcyAtIGFsbCB0aGUgdGFza3MgaW4gdGhlIHZhdWx0LiBJbiBjdXN0b20gcXVlcmllcywgdGhpcyBpcyBhdmFpbGFibGUgdmlhIHF1ZXJ5LmFsbFRhc2tzLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0Jsb2NrZWQoYWxsVGFza3M6IFJlYWRvbmx5PFRhc2tbXT4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kc09uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGRlcElkIG9mIHRoaXMuZGVwZW5kc09uKSB7XG4gICAgICAgICAgICBjb25zdCBkZXBUYXNrID0gYWxsVGFza3MuZmluZCgodGFzaykgPT4gdGFzay5pZCA9PT0gZGVwSWQgJiYgIXRhc2suaXNEb25lKTtcbiAgICAgICAgICAgIGlmICghZGVwVGFzaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5vdC1kb25lIHRhc2sgd2l0aCB0aGlzIGlkLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG5vdC1kb25lIHRhc2sgdGhhdCB0aGlzIGRlcGVuZHMgb24sIG1lYW5pbmcgdGhpcyBvbmUgaXMgYmxvY2tlZDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgVGFzayBpcyBibG9ja2luZyBpZiB0aGVyZSBpcyBhbnkgb3RoZXIgbm90LWRvbmUgdGFzayBkZXBlbmRzT24gdmFsdWUgd2l0aCBpdHMgaWQuXG4gICAgICpcbiAgICAgKiAnRG9uZScgdGFza3MgKHdpdGggc3RhdHVzIERPTkUsIENBTkNFTExFRCBvciBOT05fVEFTSykgYXJlIG5ldmVyIGJsb2NraW5nLlxuICAgICAqIE9ubHkgZGlyZWN0IGRlcGVuZGVuY2llcyBhcmUgY29uc2lkZXJlZC5cbiAgICAgKiBAcGFyYW0gYWxsVGFza3MgLSBhbGwgdGhlIHRhc2tzIGluIHRoZSB2YXVsdC4gSW4gY3VzdG9tIHF1ZXJpZXMsIHRoaXMgaXMgYXZhaWxhYmxlIHZpYSBxdWVyeS5hbGxUYXNrcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNCbG9ja2luZyhhbGxUYXNrczogUmVhZG9ubHk8VGFza1tdPikge1xuICAgICAgICBpZiAodGhpcy5pZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsbFRhc2tzLnNvbWUoKHRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLmlzRG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhc2suZGVwZW5kc09uLmluY2x1ZGVzKHRoaXMuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiB0aGUgVGFzaydzIHByaW9yaXR5LlxuICAgICAqICAgICAtIEhpZ2hlc3QgPSAwXG4gICAgICogICAgIC0gSGlnaCA9IDFcbiAgICAgKiAgICAgLSBNZWRpdW0gPSAyXG4gICAgICogICAgIC0gTm9uZSA9IDNcbiAgICAgKiAgICAgLSBMb3cgPSA0XG4gICAgICogICAgIC0gTG93ZXN0ID0gNVxuICAgICAqIEBzZWUgcHJpb3JpdHlOYW1lXG4gICAgICovXG4gICAgcHVibGljIGdldCBwcmlvcml0eU51bWJlcigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRoaXMucHJpb3JpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgdG8gYmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHtAbGluayBwcmlvcml0eX0gaW4gZ3JvdXAgaGVhZGluZ3MuXG4gICAgICpcbiAgICAgKiBIaWRkZW4gdGV4dCBpcyB1c2VkIHRvIHNvcnQgdGhlIHByaW9yaXRpZXMgaW4gZGVjcmVhc2luZyBvcmRlciwgZnJvbVxuICAgICAqIHtAbGluayBQcmlvcml0eS5IaWdoZXN0fSB0byB7QGxpbmsgUHJpb3JpdHkuTG93ZXN0fS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHByaW9yaXR5TmFtZUdyb3VwVGV4dCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwcmlvcml0eU5hbWUgPSBQcmlvcml0eVRvb2xzLnByaW9yaXR5TmFtZVVzaW5nTm9ybWFsKHRoaXMucHJpb3JpdHkpO1xuICAgICAgICAvLyBUZXh0IGluc2lkZSB0aGUgJSUuLiUlIGNvbW1lbnRzIGlzIHVzZWQgdG8gY29udHJvbCB0aGUgc29ydCBvcmRlci5cbiAgICAgICAgLy8gVGhlIGNvbW1lbnRzIGFyZSBoaWRkZW4gYnkgT2JzaWRpYW4gd2hlbiB0aGUgaGVhZGluZ3MgYXJlIHJlbmRlcmVkLlxuICAgICAgICByZXR1cm4gYCUlJHt0aGlzLnByaW9yaXR5fSUlJHtwcmlvcml0eU5hbWV9IHByaW9yaXR5YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBkZXNjcmlwdGlvbiwgd2l0aCBhbnkgdGFncyByZW1vdmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcmVtb3ZlcyB0YWdzIHJlY29nbmlzZWQgYnkgVGFza3MgKGluY2x1ZGluZyByZW1vdmluZyAjMTIzLCBmb3IgZXhhbXBsZSksXG4gICAgICogYXMgb3Bwb3NlZCB0byB0YWdzIHJlY29nbmlzZWQgYnkgT2JzaWRpYW4sIHdoaWNoIGRvZXMgbm90IHRyZWF0IG51bWJlcnMtb25seSBhcyB2YWxpZCB0YWdzLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZGVzY3JpcHRpb25XaXRob3V0VGFncygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbi5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaGFzaFRhZ3MsICcnKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBUYXNrJ3MgcHJpb3JpdHkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgY2FsbGVkICdOb3JtYWwnLCBub3QgJ05vbmUnLlxuICAgICBAc2VlIHByaW9yaXR5TnVtYmVyXG4gICAgICovXG4gICAgcHVibGljIGdldCBwcmlvcml0eU5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFByaW9yaXR5VG9vbHMucHJpb3JpdHlOYW1lVXNpbmdOb3JtYWwodGhpcy5wcmlvcml0eSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB1cmdlbmN5KCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl91cmdlbmN5ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91cmdlbmN5ID0gVXJnZW5jeS5jYWxjdWxhdGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdXJnZW5jeTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHBhdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza0xvY2F0aW9uLnBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBjYW5jZWxsZWREYXRlfSBhcyBhIHtAbGluayBUYXNrc0RhdGV9LCBzbyB0aGUgZmllbGQgbmFtZXMgaW4gc2NyaXB0aW5nIGRvY3MgYXJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhpc3Rpbmcgc2VhcmNoIGluc3RydWN0aW9uIG5hbWVzLCBhbmQgbnVsbCB2YWx1ZXMgYXJlIGVhc3kgdG8gZGVhbCB3aXRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2FuY2VsbGVkKCk6IFRhc2tzRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKHRoaXMuY2FuY2VsbGVkRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBjcmVhdGVkRGF0ZX0gYXMgYSB7QGxpbmsgVGFza3NEYXRlfSwgc28gdGhlIGZpZWxkIG5hbWVzIGluIHNjcmlwdGluZyBkb2NzIGFyZSBjb25zaXN0ZW50IHdpdGggdGhlIGV4aXN0aW5nIHNlYXJjaCBpbnN0cnVjdGlvbiBuYW1lcywgYW5kIG51bGwgdmFsdWVzIGFyZSBlYXN5IHRvIGRlYWwgd2l0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNyZWF0ZWQoKTogVGFza3NEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrc0RhdGUodGhpcy5jcmVhdGVkRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBkb25lRGF0ZX0gYXMgYSB7QGxpbmsgVGFza3NEYXRlfSwgc28gdGhlIGZpZWxkIG5hbWVzIGluIHNjcmlwdGluZyBkb2NzIGFyZSBjb25zaXN0ZW50IHdpdGggdGhlIGV4aXN0aW5nIHNlYXJjaCBpbnN0cnVjdGlvbiBuYW1lcywgYW5kIG51bGwgdmFsdWVzIGFyZSBlYXN5IHRvIGRlYWwgd2l0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRvbmUoKTogVGFza3NEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrc0RhdGUodGhpcy5kb25lRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBkdWVEYXRlfSBhcyBhIHtAbGluayBUYXNrc0RhdGV9LCBzbyB0aGUgZmllbGQgbmFtZXMgaW4gc2NyaXB0aW5nIGRvY3MgYXJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhpc3Rpbmcgc2VhcmNoIGluc3RydWN0aW9uIG5hbWVzLCBhbmQgbnVsbCB2YWx1ZXMgYXJlIGVhc3kgdG8gZGVhbCB3aXRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHVlKCk6IFRhc2tzRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKHRoaXMuZHVlRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayByZW1pbmRlckRhdGV9IGFzIGEge0BsaW5rIFRhc2tzRGF0ZX0sIHNvIHRoZSBmaWVsZCBuYW1lcyBpbiBzY3JpcHRpbmcgZG9jcyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBleGlzdGluZyBzZWFyY2ggaW5zdHJ1Y3Rpb24gbmFtZXMsIGFuZCBudWxsIHZhbHVlcyBhcmUgZWFzeSB0byBkZWFsIHdpdGguXG4gICAgICovXG4gICAgcHVibGljIGdldCByZW1pbmRlcigpOiBUYXNrc0RhdGUge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tzRGF0ZSh0aGlzLnJlbWluZGVyRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBzY2hlZHVsZWREYXRlfSBhcyBhIHtAbGluayBUYXNrc0RhdGV9LCBzbyB0aGUgZmllbGQgbmFtZXMgaW4gc2NyaXB0aW5nIGRvY3MgYXJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhpc3Rpbmcgc2VhcmNoIGluc3RydWN0aW9uIG5hbWVzLCBhbmQgbnVsbCB2YWx1ZXMgYXJlIGVhc3kgdG8gZGVhbCB3aXRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2NoZWR1bGVkKCk6IFRhc2tzRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKHRoaXMuc2NoZWR1bGVkRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtAbGluayBzdGFydERhdGV9IGFzIGEge0BsaW5rIFRhc2tzRGF0ZX0sIHNvIHRoZSBmaWVsZCBuYW1lcyBpbiBzY3JpcHRpbmcgZG9jcyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBleGlzdGluZyBzZWFyY2ggaW5zdHJ1Y3Rpb24gbmFtZXMsIGFuZCBudWxsIHZhbHVlcyBhcmUgZWFzeSB0byBkZWFsIHdpdGguXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGFydCgpOiBUYXNrc0RhdGUge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tzRGF0ZSh0aGlzLnN0YXJ0RGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRlIGZpZWxkcyB0aGF0IGNvbnRyaWJ1dGUgdG8gJ2hhcHBlbnMnIHNlYXJjaGVzLlxuICAgICAqXG4gICAgICogQHNlZSBoYXBwZW5zXG4gICAgICogQHNlZSB7QGxpbmsgSGFwcGVuc0RhdGVGaWVsZH1cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhcHBlbnNEYXRlcygpOiAoTW9tZW50IHwgbnVsbClbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5vZih0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5zY2hlZHVsZWREYXRlLCB0aGlzLmR1ZURhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWFybGllc3Qgb2YgdGhlIGRhdGVzIHVzZWQgYnkgJ2hhcHBlbnMnIGluIHRoaXMgZ2l2ZW4gdGFzayBhcyBhIHtAbGluayBUYXNrc0RhdGV9LlxuICAgICAqXG4gICAgICogR2VuZXJhbGx5IHNwZWFraW5nLCB0aGUgZWFybGllc3QgZGF0ZSBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBoaWdoZXN0IHByaW9yaXR5LFxuICAgICAqIGFzIGl0IGlzIHRoZSBmaXJzdCBwb2ludCBhdCB3aGljaCB0aGUgdXNlciBtaWdodCB3aXNoIHRvIGFjdCBvbiB0aGUgdGFzay5cbiAgICAgKlxuICAgICAqIEludmFsaWQgZGF0ZXMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAc2VlIGhhcHBlbnNEYXRlc1xuICAgICAqIEBzZWUge0BsaW5rIEhhcHBlbnNEYXRlRmllbGR9XG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXBwZW5zKCk6IFRhc2tzRGF0ZSB7XG4gICAgICAgIGNvbnN0IGhhcHBlbnNEYXRlcyA9IHRoaXMuaGFwcGVuc0RhdGVzO1xuICAgICAgICAvLyBBcnJheS5mcm9tKCkgY3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFycmF5LCB0byBzdG9wIFNvbmFyTGludFxuICAgICAgICAvLyBjb21wbGFpbmluZyBhYm91dCBzb3J0KCkgbXV0YXRpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAgICAvLyBUaGUgcHJlZmVycmVkIHNvbHV0aW9uIHdvdWxkIHRvIHVzZSB0b1NvcnRlZCgpLCBidXQgdGhhdCBpcyBub3QgY3VycmVudGx5IGF2YWlsYWJsZVxuICAgICAgICAvLyBpbiB0aGUgcHJvamVjdCBjb25maWd1cmF0aW9uLCB3aXRob3V0IGNoYW5naW5nIHRoZSBjb21waWxlciBvcHRpb25zLCB3aGljaCBzZWVtc1xuICAgICAgICAvLyBhIHN0ZXAgdG9vIGZhciBpbiB0aGUgbWlkZGxlIG9mIGEgYnVnLWZpeCBicmFuY2guXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2NTkzODkyL2hvdy10by11c2UtdG9zb3J0ZWQtbWV0aG9kLWluLXR5cGVzY3JpcHRcbiAgICAgICAgY29uc3Qgc29ydGVkSGFwcGVuc0RhdGVzID0gQXJyYXkuZnJvbShoYXBwZW5zRGF0ZXMpLnNvcnQoY29tcGFyZUJ5RGF0ZSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBub24tbnVsbCwgdmFsaWQgZGF0ZTpcbiAgICAgICAgZm9yIChjb25zdCBkYXRlIG9mIHNvcnRlZEhhcHBlbnNEYXRlcykge1xuICAgICAgICAgICAgaWYgKGRhdGU/LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBUYXNrIGhhcyBhIHZhbGlkIHJlY3VycmVuY2UgcnVsZSwgYW5kIGZhbHNlIG90aGVyd2lzZSxcbiAgICAgKiB0aGF0IGlzLCBmYWxzZSBpZiBpdCBkb2VzIG5vdCBoYXZlIGEgcmVjdXJyZW5jZSBydWxlLCBvciB0aGUgcmVjdXJyZW5jZSBydWxlIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1JlY3VycmluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJyZW5jZSAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRleHQgb2YgdGhlIFRhc2sncyByZWN1cnJlbmNlIHJ1bGUsIGlmIGl0IGlzIHN1cHBsaWVkIGFuZCBpcyB2YWxpZCxcbiAgICAgKiBhbmQgYW4gZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJlY3VycmVuY2VSdWxlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3VycmVuY2UgPyB0aGlzLnJlY3VycmVuY2UudG9UZXh0KCkgOiAnJztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWRpbmcoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGluZ0hlYWRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhhc0hlYWRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGluZ0hlYWRlciAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpbGUoKTogVGFza3NGaWxlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza0xvY2F0aW9uLnRhc2tzRmlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY29udGFpbmluZyB0aGUgdGFzaywgd2l0aCB0aGUgLm1kIGV4dGVuc2lvbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZmlsZW5hbWUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lTWF0Y2ggPSB0aGlzLnBhdGgubWF0Y2goLyhbXi9dKylcXC5tZCQvKTtcbiAgICAgICAgaWYgKGZpbGVOYW1lTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZU1hdGNoWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGluZU51bWJlcigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrTG9jYXRpb24ubGluZU51bWJlcjtcbiAgICB9XG5cbiAgICBnZXQgc2VjdGlvblN0YXJ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tMb2NhdGlvbi5zZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgZ2V0IHNlY3Rpb25JbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrTG9jYXRpb24uc2VjdGlvbkluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcHJlY2VkaW5nSGVhZGVyKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrTG9jYXRpb24ucHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIHdoZW4gbGlua2luZyB0byB0aGUgb3JpZ2luIG9mIHRoZSB0YXNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNGaWxlbmFtZVVuaXF1ZSB7Ym9vbGVhbnxudWxsfSBXaGV0aGVyIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgaXMgdW5pcXVlIGluIHRoZSB2YXVsdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBpdCBpcyB1bmRlZmluZWQsIHRoZSBvdXRjb21lIHdpbGwgYmUgdGhlIHNhbWUgYXMgd2l0aCBhIHVuaXF1ZSBmaWxlIG5hbWU6IHRoZSBmaWxlIG5hbWUgb25seS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBzZXQgdG8gYHRydWVgLCB0aGUgZnVsbCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldExpbmtUZXh0KHsgaXNGaWxlbmFtZVVuaXF1ZSB9OiB7IGlzRmlsZW5hbWVVbmlxdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQgfSk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBsZXQgbGlua1RleHQ6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGlmIChpc0ZpbGVuYW1lVW5pcXVlKSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBIHNsYXNoIGF0IHRoZSBiZWdpbm5pbmcgaW5kaWNhdGVzIHRoaXMgaXMgYSBwYXRoLCBub3QgYSBmaWxlbmFtZS5cbiAgICAgICAgICAgIGxpbmtUZXh0ID0gJy8nICsgdGhpcy5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmtUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyB3b3VsZG4ndCBwcm92aWRlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYW5kIG9ubHkgdGFrZSB1cCBzcGFjZS5cbiAgICAgICAgaWYgKHRoaXMucHJlY2VkaW5nSGVhZGVyICE9PSBudWxsICYmIHRoaXMucHJlY2VkaW5nSGVhZGVyICE9PSBsaW5rVGV4dCkge1xuICAgICAgICAgICAgbGlua1RleHQgPSBsaW5rVGV4dCArICcgPiAnICsgdGhpcy5wcmVjZWRpbmdIZWFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlua1RleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gbGlzdHMgb2YgVGFzayBvYmplY3RzLCBhbmQgcmVwb3J0IHdoZXRoZXIgdGhlaXJcbiAgICAgKiB0YXNrcyBhcmUgaWRlbnRpY2FsIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBvcHRpbWlzaW5nIGNvZGUgaWYgaXQgaXMgZ3VhcmFudGVlZCB0aGF0XG4gICAgICogdGhlcmUgYXJlIG5vIHBvc3NpYmxlIGRpZmZlcmVuY2VzIGluIHRoZSB0YXNrcyBpbiBhIGZpbGVcbiAgICAgKiBhZnRlciBhbiBlZGl0LCBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIElmIGFueSBmaWVsZCBpcyBkaWZmZXJlbnQgaW4gYW55IHRhc2ssIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9sZFRhc2tzXG4gICAgICogQHBhcmFtIG5ld1Rhc2tzXG4gICAgICovXG4gICAgc3RhdGljIHRhc2tzTGlzdHNJZGVudGljYWwob2xkVGFza3M6IFRhc2tbXSwgbmV3VGFza3M6IFRhc2tbXSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAob2xkVGFza3MubGVuZ3RoICE9PSBuZXdUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkVGFza3MuZXZlcnkoKG9sZFRhc2ssIGluZGV4KSA9PiBvbGRUYXNrLmlkZW50aWNhbFRvKG5ld1Rhc2tzW2luZGV4XSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgYWxsIHRoZSBmaWVsZHMgaW4gYW5vdGhlciBUYXNrLCB0byBkZXRlY3QgYW55IGRpZmZlcmVuY2VzIGZyb20gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBJZiBhbnkgZmllbGQgaXMgZGlmZmVyZW50IGluIGFueSB3YXksIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIGluIHNvbWUgb3B0aW1pc2F0aW9ucywgdG8gYXZvaWQgd29yayBpZiBhbiBlZGl0IHRvIGZpbGVcbiAgICAgKiBkb2VzIG5vdCBjaGFuZ2UgYW55IHRhc2tzLCBzbyBpdCBpcyB2aXRhbCB0aGF0IGl0cyBkZWZpbml0aW9uXG4gICAgICogb2YgaWRlbnRpY2FsIGlzIHZlcnkgc3RyaWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyXG4gICAgICovXG4gICAgcHVibGljIGlkZW50aWNhbFRvKG90aGVyOiBUYXNrKSB7XG4gICAgICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcblxuICAgICAgICAvLyBCYXNlZCBvbiBpZGVhcyBmcm9tIGtvYWxhLiBBcXVhQ2F0IGFuZCBqYXZhbGVudCBpbiBEaXNjb3JkOlxuICAgICAgICAvLyBodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY4NjA1MzcwODI2MTIyODU3Ny84NDAyODYyNjQ5NjQwMjIzMDIvOTk2NzM1MjAwMzg4MTg2MTgyXG4gICAgICAgIC8vIGFuZCBsYXRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogc2VjdGlvblN0YXJ0IGNoYW5nZXMgZXZlcnkgdGltZSBhIGxpbmUgaXMgYWRkZWQgb3IgZGVsZXRlZCBiZWZvcmVcbiAgICAgICAgLy8gICAgICAgYW55IG9mIHRoZSB0YXNrcyBpbiBhIGZpbGUuIFRoaXMgZG9lcyBtZWFuIHRoYXQgcmVkcmF3aW5nIG9mIHRhc2tzIGJsb2Nrc1xuICAgICAgICAvLyAgICAgICBoYXBwZW5zIG1vcmUgb2Z0ZW4gdGhhbiBpcyBpZGVhbC5cbiAgICAgICAgbGV0IGFyZ3M6IEFycmF5PGtleW9mIFRhc2s+ID0gW1xuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwYXRoJyxcbiAgICAgICAgICAgICdpbmRlbnRhdGlvbicsXG4gICAgICAgICAgICAnbGlzdE1hcmtlcicsXG4gICAgICAgICAgICAnbGluZU51bWJlcicsXG4gICAgICAgICAgICAnc2VjdGlvblN0YXJ0JyxcbiAgICAgICAgICAgICdzZWN0aW9uSW5kZXgnLFxuICAgICAgICAgICAgJ3ByZWNlZGluZ0hlYWRlcicsXG4gICAgICAgICAgICAncHJpb3JpdHknLFxuICAgICAgICAgICAgJ2Jsb2NrTGluaycsXG4gICAgICAgICAgICAnc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQnLFxuICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICdkZXBlbmRzT24nLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2VsXT8udG9TdHJpbmcoKSAhPT0gb3RoZXJbZWxdPy50b1N0cmluZygpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzLmlkZW50aWNhbFRvKG90aGVyLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgdGFnc1xuICAgICAgICBpZiAodGhpcy50YWdzLmxlbmd0aCAhPT0gb3RoZXIudGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWdzIGFyZSB0aGUgc2FtZSBvbmx5IGlmIHRoZSB2YWx1ZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLnRhZ3MuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG90aGVyLnRhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIERhdGUgZmllbGRzXG4gICAgICAgIGFyZ3MgPSBUYXNrLmFsbERhdGVGaWVsZHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlMSA9IHRoaXNbZWxdIGFzIE1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICBjb25zdCBkYXRlMiA9IG90aGVyW2VsXSBhcyBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVCeURhdGUoZGF0ZTEsIGRhdGUyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY3VycmVuY2UxID0gdGhpcy5yZWN1cnJlbmNlO1xuICAgICAgICBjb25zdCByZWN1cnJlbmNlMiA9IG90aGVyLnJlY3VycmVuY2U7XG4gICAgICAgIGlmIChyZWN1cnJlbmNlMSA9PT0gbnVsbCAmJiByZWN1cnJlbmNlMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY3VycmVuY2UxICE9PSBudWxsICYmIHJlY3VycmVuY2UyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjdXJyZW5jZTEgJiYgcmVjdXJyZW5jZTIgJiYgIXJlY3VycmVuY2UxLmlkZW50aWNhbFRvKHJlY3VycmVuY2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBhbGxEYXRlRmllbGRzKCk6IChrZXlvZiBUYXNrKVtdIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdjcmVhdGVkRGF0ZScgYXMga2V5b2YgVGFzayxcbiAgICAgICAgICAgICdzdGFydERhdGUnIGFzIGtleW9mIFRhc2ssXG4gICAgICAgICAgICAnc2NoZWR1bGVkRGF0ZScgYXMga2V5b2YgVGFzayxcbiAgICAgICAgICAgICdkdWVEYXRlJyBhcyBrZXlvZiBUYXNrLFxuICAgICAgICAgICAgJ3JlbWluZGVyRGF0ZScgYXMga2V5b2YgVGFzayxcbiAgICAgICAgICAgICdkb25lRGF0ZScgYXMga2V5b2YgVGFzayxcbiAgICAgICAgICAgICdjYW5jZWxsZWREYXRlJyBhcyBrZXlvZiBUYXNrLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaGFzaHRhZ3MgZm91bmQgaW4gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gQSB0YXNrIGRlc2NyaXB0aW9uIHRoYXQgbWF5IGNvbnRhaW4gaGFzaHRhZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGhhc2hUYWdzIGZvdW5kIGluIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGV4dHJhY3RIYXNodGFncyhkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24ubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5oYXNoVGFncyk/Lm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKSA/PyBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQSB0YXNrIGlzIHRyZWF0ZWQgYXMgYmxvY2tlZCBpZiBpdCBkZXBlbmRzIG9uIGFueSBleGlzdGluZyB0YXNrIGlkcyBvbiB0YXNrcyB0aGF0IGFyZSBUT0RPIG9yIElOX1BST0dSRVNTLlxuICpcbiAqICdEb25lJyB0YXNrcyAod2l0aCBzdGF0dXMgRE9ORSwgQ0FOQ0VMTEVEIG9yIE5PTl9UQVNLKSBhcmUgbmV2ZXIgYmxvY2tlZC5cbiAqIEBwYXJhbSB0aGlzVGFza1xuICogQHBhcmFtIGFsbFRhc2tzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2NrZWQodGhpc1Rhc2s6IFRhc2ssIGFsbFRhc2tzOiBUYXNrW10pIHtcbiAgICBpZiAodGhpc1Rhc2suZGVwZW5kc09uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNUYXNrLmlzRG9uZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBkZXBJZCBvZiB0aGlzVGFzay5kZXBlbmRzT24pIHtcbiAgICAgICAgY29uc3QgZGVwVGFzayA9IGFsbFRhc2tzLmZpbmQoKHRhc2spID0+IHRhc2suaWQgPT09IGRlcElkICYmICF0YXNrLmlzRG9uZSk7XG4gICAgICAgIGlmICghZGVwVGFzaykge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbm90LWRvbmUgdGFzayB3aXRoIHRoaXMgaWQuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGZvdW5kIGEgbm90LWRvbmUgdGFzayB0aGF0IHRoaXMgZGVwZW5kcyBvbiwgbWVhbmluZyB0aGlzIG9uZSBpcyBibG9ja2VkOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCAiLyoqXG4gKiBMYXp5IGxvYWRlZCB2YXJpYWJsZSA6IGZldGNoaW5nIHRoZSB2YWx1ZSBpcyBwb3N0cG9uZWQgdW50aWwgdGhlIGZpcnN0IGdldCgpXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5PFQ+IHtcbiAgICBwcml2YXRlIF92YWx1ZTogVCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGxhenkgb2JqZWN0XG4gICAgICogQHBhcmFtIGZldGNoIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBmZXRjaDogKCkgPT4gVCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsYXp5IHZhbHVlLCBjYWxsaW5nIHRoZSBmZXRjaCBmdW5jdGlvbiB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKTogVCB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZmV0Y2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrc0ZpbGUgfSBmcm9tICcuLi9TY3JpcHRpbmcvVGFza3NGaWxlJztcblxuLyoqXG4gKiBUYXNrTG9jYXRpb24gaXMgdGhlIHBsYWNlIHdoZXJlIGFsbCBpbmZvcm1hdGlvbiBhYm91dCBhIHRhc2sgbGluZSdzIGxvY2F0aW9uXG4gKiBpbiBhIG1hcmtkb3duIGZpbGUgaXMgc3RvcmVkLCBzbyB0aGF0IHRlc3RhYmxlIGFsZ29yaXRobXMgY2FuIHRoZW4gYmUgYWRkZWQgaGVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tMb2NhdGlvbiB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfdGFza3NGaWxlOiBUYXNrc0ZpbGU7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbGluZU51bWJlcjogbnVtYmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3NlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3NlY3Rpb25JbmRleDogbnVtYmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3ByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgdGFza3NGaWxlOiBUYXNrc0ZpbGUsXG4gICAgICAgIGxpbmVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgc2VjdGlvblN0YXJ0OiBudW1iZXIsXG4gICAgICAgIHNlY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IHN0cmluZyB8IG51bGwsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuX3Rhc2tzRmlsZSA9IHRhc2tzRmlsZTtcbiAgICAgICAgdGhpcy5fbGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHNlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gc2VjdGlvbkluZGV4O1xuICAgICAgICB0aGlzLl9wcmVjZWRpbmdIZWFkZXIgPSBwcmVjZWRpbmdIZWFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IsIGZvciB1c2Ugd2hlbiB0aGUgVGFzaydzIGV4YWN0IGxvY2F0aW9uIGluIGEgZmlsZSBpcyBlaXRoZXIgdW5rbm93biwgb3Igbm90IG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gdGFza3NGaWxlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVW5rbm93blBvc2l0aW9uKHRhc2tzRmlsZTogVGFza3NGaWxlKTogVGFza0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrTG9jYXRpb24odGFza3NGaWxlLCAwLCAwLCAwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciwgZm9yIHdoZW4gdGhlIGZpbGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGFsbCBvdGhlciBkYXRhIHJlbWFpbnMgdGhlIHNhbWUuXG4gICAgICogQHBhcmFtIG5ld1Rhc2tzRmlsZVxuICAgICAqL1xuICAgIGZyb21SZW5hbWVkRmlsZShuZXdUYXNrc0ZpbGU6IFRhc2tzRmlsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tMb2NhdGlvbihcbiAgICAgICAgICAgIG5ld1Rhc2tzRmlsZSxcbiAgICAgICAgICAgIHRoaXMubGluZU51bWJlcixcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0LFxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICB0aGlzLnByZWNlZGluZ0hlYWRlcixcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHRhc2tzRmlsZSgpOiBUYXNrc0ZpbGUge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFza3NGaWxlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcGF0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFza3NGaWxlLnBhdGg7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBsaW5lTnVtYmVyKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTnVtYmVyO1xuICAgIH1cblxuICAgIC8qKiBMaW5lIG51bWJlciB3aGVyZSB0aGUgc2VjdGlvbiBzdGFydHMgdGhhdCBjb250YWlucyB0aGlzIHRhc2suICovXG4gICAgZ2V0IHNlY3Rpb25TdGFydCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIG50aCB0YXNrIGluIGl0cyBzZWN0aW9uLiAqL1xuICAgIGdldCBzZWN0aW9uSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25JbmRleDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHByZWNlZGluZ0hlYWRlcigpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNlZGluZ0hlYWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwYXRoIGlzIGtub3duLCB0aGF0LWlzLCBub24tZW1wdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXNuJ3QgY2hlY2sgd2hldGhlciB0aGUgcGF0aCBwb2ludHMgdG8gYW4gZXhpc3RpbmcgZmlsZS5cbiAgICAgKlxuICAgICAqIEl0IHdhcyB3cml0dGVuIHRvIGFsbG93IGRldGVjdGlvbiBvZiB0YXNrcyBpbiBDYW52YXMgY2FyZHMsIGJ1dCBub3RlXG4gICAgICogdGhhdCBzb21lIGVkaXRpbmcgY29kZSBpbiB0aGlzIHBsdWdpbiBkb2VzIG5vdCBib3RoZXIgdG8gc2V0IHRoZSBsb2NhdGlvblxuICAgICAqIG9mIHRoZSB0YXNrLCBpZiBub3QgbmVlZGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFzS25vd25QYXRoKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoICE9PSAnJztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRhc2tNb2RhbCB9IGZyb20gJy4uL09ic2lkaWFuL1Rhc2tNb2RhbCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi4vVGFzay9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgdGFza0Zyb21MaW5lIH0gZnJvbSAnLi9DcmVhdGVPckVkaXRUYXNrUGFyc2VyJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9yRWRpdCA9IChjaGVja2luZzogYm9vbGVhbiwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IFZpZXcsIGFwcDogQXBwLCBhbGxUYXNrczogVGFza1tdKSA9PiB7XG4gICAgaWYgKGNoZWNraW5nKSB7XG4gICAgICAgIHJldHVybiB2aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3O1xuICAgIH1cblxuICAgIGlmICghKHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpKSB7XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gZHVlIHRvIGNoZWNrIGFib3ZlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9IHZpZXcuZmlsZT8ucGF0aDtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gY3Vyc29yUG9zaXRpb24ubGluZTtcbiAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG4gICAgY29uc3QgdGFzayA9IHRhc2tGcm9tTGluZSh7IGxpbmUsIHBhdGggfSk7XG5cbiAgICBjb25zdCBvblN1Ym1pdCA9ICh1cGRhdGVkVGFza3M6IFRhc2tbXSk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gRGF0ZUZhbGxiYWNrLnJlbW92ZUluZmVycmVkU3RhdHVzSWZOZWVkZWQodGFzaywgdXBkYXRlZFRhc2tzKVxuICAgICAgICAgICAgLm1hcCgodGFzazogVGFzaykgPT4gdGFzay50b0ZpbGVMaW5lU3RyaW5nKCkpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHNlcmlhbGl6ZWQpO1xuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBldmVyeSB0aW1lLCBhcyBjdXJzb3IvdGFzayBjYW4gY2hhbmdlLlxuICAgIGNvbnN0IHRhc2tNb2RhbCA9IG5ldyBUYXNrTW9kYWwoe1xuICAgICAgICBhcHAsXG4gICAgICAgIHRhc2ssXG4gICAgICAgIG9uU3VibWl0LFxuICAgICAgICBhbGxUYXNrcyxcbiAgICB9KTtcbiAgICB0YXNrTW9kYWwub3BlbigpO1xufTtcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IEVkaXRUYXNrIGZyb20gJy4uL3VpL0VkaXRUYXNrLnN2ZWx0ZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXNSZWdpc3RyeSc7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXMnO1xuXG5leHBvcnQgY2xhc3MgVGFza01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHB1YmxpYyByZWFkb25seSB0YXNrOiBUYXNrO1xuICAgIHB1YmxpYyByZWFkb25seSBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkO1xuICAgIHB1YmxpYyByZWFkb25seSBhbGxUYXNrczogVGFza1tdO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBhcHAsXG4gICAgICAgIHRhc2ssXG4gICAgICAgIG9uU3VibWl0LFxuICAgICAgICBhbGxUYXNrcyxcbiAgICB9OiB7XG4gICAgICAgIGFwcDogQXBwO1xuICAgICAgICB0YXNrOiBUYXNrO1xuICAgICAgICBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkO1xuICAgICAgICBhbGxUYXNrczogVGFza1tdO1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcblxuICAgICAgICB0aGlzLnRhc2sgPSB0YXNrO1xuICAgICAgICB0aGlzLmFsbFRhc2tzID0gYWxsVGFza3M7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZWRUYXNrcy5sZW5ndGggJiYgb25TdWJtaXQodXBkYXRlZFRhc2tzKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRpdGxlRWwuc2V0VGV4dCgnQ3JlYXRlIG9yIGVkaXQgVGFzaycpO1xuICAgICAgICB0aGlzLm1vZGFsRWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcwJztcblxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZW50RWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcwJztcblxuICAgICAgICBjb25zdCBzdGF0dXNPcHRpb25zID0gdGhpcy5nZXRLbm93blN0YXR1c2VzQW5kQ3VycmVudFRhc2tTdGF0dXNJZk5vdEtub3duKCk7XG5cbiAgICAgICAgbmV3IEVkaXRUYXNrKHtcbiAgICAgICAgICAgIHRhcmdldDogY29udGVudEVsLFxuICAgICAgICAgICAgcHJvcHM6IHsgdGFzazogdGhpcy50YXNrLCBzdGF0dXNPcHRpb25zOiBzdGF0dXNPcHRpb25zLCBvblN1Ym1pdDogdGhpcy5vblN1Ym1pdCwgYWxsVGFza3M6IHRoaXMuYWxsVGFza3MgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhc2sgYmVpbmcgZWRpdGVkIGhhcyBhbiB1bmtub3duIHN0YXR1cywgbWFrZSBzdXJlIGl0IGlzIGFkZGVkXG4gICAgICogdG8gdGhlIGRyb3Bkb3duIGxpc3QuXG4gICAgICogVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gc3dpdGNoIHRvIGEgZGlmZmVyZW50IHN0YXR1cyBhbmQgdGhlbiBjaGFuZ2UgdGhlaXJcbiAgICAgKiBtaW5kIGFuZCByZXR1cm4gdG8gdGhlIGluaXRpYWwgc3RhdHVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0S25vd25TdGF0dXNlc0FuZEN1cnJlbnRUYXNrU3RhdHVzSWZOb3RLbm93bigpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzT3B0aW9uczogU3RhdHVzW10gPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyZWRTdGF0dXNlcztcbiAgICAgICAgaWYgKFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuYnlTeW1ib2wodGhpcy50YXNrLnN0YXR1cy5zeW1ib2wpID09PSBTdGF0dXMuRU1QVFkpIHtcbiAgICAgICAgICAgIHN0YXR1c09wdGlvbnMucHVzaCh0aGlzLnRhc2suc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzT3B0aW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIH1cbn1cbiIsICJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cbmZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG4gICAgY29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcbiAgICByZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogW3ZhbHVlLCAncHgnXTtcbn1cbmNvbnN0IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzID0gWycnLCB0cnVlLCAxLCAndHJ1ZScsICdjb250ZW50ZWRpdGFibGUnXTtcblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldE9ic2VydmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9vYnNlcnZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vLyBOZWVkcyB0byBiZSB3cml0dGVuIGxpa2UgdGhpcyB0byBwYXNzIHRoZSB0cmVlLXNoYWtlLXRlc3RcblJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZS5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCAmJiBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcbiAgICBPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuICAgIHJldHVybiAoLy0vLnRlc3QodGFnKSkgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG4gICAgbGV0IF9pbnB1dHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBncm91cC5wdXNoKGlucHV0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIHJlbW92ZSAqLyByKCkge1xuICAgICAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG4gICAgbGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcbiAgICBsZXQgX2lucHV0cztcbiAgICBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuICAgICAgICAgICAgaW5kZXhlcyA9IG5ld19pbmRleGVzO1xuICAgICAgICAgICAgY29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgaWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgX2dyb3VwID0gbmV3X2dyb3VwO1xuICAgICAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogcmVtb3ZlICovIHI6IHJlbW92ZVxuICAgIH07XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LCAobm9kZSkgPT4ge1xuICAgICAgICBub2RlLmRhdGEgPSAnJyArIGRhdGE7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY29tbWVudChkYXRhKSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG4gICAgaWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG4gICAgICAgIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldF9kYXRhKHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2NvbnRlbnQtYm94JyB9KTtcbmNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2JvcmRlci1ib3gnIH0pO1xuY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzdGFydGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCAtPSAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICAvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqL1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQoKHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lKSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJyA/IHRhcmdldCA6IHRhcmdldC5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvd25lck5vZGUgfSA9IGluZm8uc3R5bGVzaGVldDtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG93bmVyTm9kZSBpZiBpdCBydW5zIG9uIGpzZG9tLlxuICAgICAgICAgICAgaWYgKG93bmVyTm9kZSlcbiAgICAgICAgICAgICAgICBkZXRhY2gob3duZXJOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWJlZm9yZXVwZGF0ZVxuICovXG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKC9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbm1vdW50XG4gKi9cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICovXG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbmRlc3Ryb3lcbiAqL1xuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKC9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWNyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1zZXRjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWdldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0YWxsY29udGV4dHNcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWhhc2NvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cbiAgICAvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG4gICAgLy8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG4gICAgaWYgKGZsdXNoaWR4ICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG4gICAgICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICovXG5mdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgY29uc3QgdGFyZ2V0cyA9IFtdO1xuICAgIHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSk7XG4gICAgdGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgIHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8gXHUyMDE0IHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8gXHUyMDE0IG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJ1bl9hbGwodXBkYXRlcyk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG5jb25zdCBfYm9vbGVhbl9hdHRyaWJ1dGVzID0gW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpbmVydCcsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl07XG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKi9cbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIHJlZ2V4IG9mIGFsbCBodG1sIHZvaWQgZWxlbWVudCBuYW1lcyAqL1xuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzLiBPdGhlcndpc2UgeW91IG1heSBuZWVkIHRvIGZpeCBhIDwke25hbWV9Pi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuICAgICAgICAgICAgLy8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcygkJC5hZnRlcl91cGRhdGUpO1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBhcHBlbmRfc3R5bGVzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgICBjdHg6IFtdLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiAnMy41OS4yJyB9LCBkZXRhaWwpLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24sIGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBpZiAoaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuICAgIGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuICAgICAgICBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcbiAgICBpZiAodGFnICYmICFpc19zdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2Rldihjb21wb25lbnQsIHByb3BzKSB7XG4gICAgY29uc3QgZXJyb3JfbWVzc2FnZSA9ICd0aGlzPXsuLi59IG9mIDxzdmVsdGU6Y29tcG9uZW50PiBzaG91bGQgc3BlY2lmeSBhIFN2ZWx0ZSBjb21wb25lbnQuJztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlLiQkIHx8ICFpbnN0YW5jZS4kc2V0IHx8ICFpbnN0YW5jZS4kb24gfHwgIWluc3RhbmNlLiRkZXN0cm95KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UuaW5kZXhPZignaXMgbm90IGEgY29uc3RydWN0b3InKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIEh0bWxUYWdIeWRyYXRpb24sIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbW1lbnQsIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbW1lbnQsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQsIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2RldiwgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZW5kX2h5ZHJhdGluZywgZXNjYXBlLCBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlLCBlc2NhcGVfb2JqZWN0LCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsIGdldEFsbENvbnRleHRzLCBnZXRDb250ZXh0LCBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9yb290X2Zvcl9zdHlsZSwgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBoZWFkX3NlbGVjdG9yLCBpZGVudGl0eSwgaW5pdCwgaW5pdF9iaW5kaW5nX2dyb3VwLCBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYywgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnNlcnRfaHlkcmF0aW9uLCBpbnNlcnRfaHlkcmF0aW9uX2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBpc192b2lkLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1lcmdlX3Nzcl9zdHlsZXMsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3gsIHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCwgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAsIHNldF9kYXRhLCBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9kYXRhX2Rldiwgc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlLCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2LCBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcGxpdF9jc3NfdW5pdCwgc3ByZWFkLCBzcmNfdXJsX2VxdWFsLCBzdGFydF9oeWRyYXRpbmcsIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gIHZhciBpLCBwO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICByZXR1cm4gY29va2VkO1xufTtcblxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlO1xuICAgIGlmIChhc3luYykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICB9XG4gIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcbiAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWMuZGlzcG9zZSAmJiByZWMuZGlzcG9zZS5jYWxsKHJlYy52YWx1ZSk7XG4gICAgICAgIGlmIChyZWMuYXN5bmMpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG59O1xuIiwgImltcG9ydCB7IHR5cGUgTGlzdEl0ZW1DYWNoZSwgTWV0YWRhdGFDYWNoZSwgTm90aWNlLCBURmlsZSwgVmF1bHQsIFdvcmtzcGFjZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4uL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgdHlwZSBNb2NrTGlzdEl0ZW1DYWNoZSwgdHlwZSBNb2NrVGFzaywgc2F2ZU1vY2tEYXRhRm9yVGVzdGluZyB9IGZyb20gJy4uL2xpYi9Nb2NrRGF0YUNyZWF0b3InO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IGxvZ2dpbmcgfSBmcm9tICcuLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQgeyBsb2dFbmRPZlRhc2tFZGl0LCBsb2dTdGFydE9mVGFza0VkaXQgfSBmcm9tICcuLi9saWIvTG9nVGFza3NIZWxwZXInO1xuXG5sZXQgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZSB8IHVuZGVmaW5lZDtcbmxldCB2YXVsdDogVmF1bHQgfCB1bmRlZmluZWQ7XG5sZXQgd29ya3NwYWNlOiBXb3Jrc3BhY2UgfCB1bmRlZmluZWQ7XG5cbmNvbnN0IHN1cHBvcnRlZEZpbGVFeHRlbnNpb25zID0gWydtZCddO1xuXG5mdW5jdGlvbiBnZXRGaWxlTG9nZ2VyKCkge1xuICAgIC8vIEZvciBsb2dnaW5nIHRvIGFjdHVhbGx5IHByb2R1Y2UgZGVidWcgb3V0cHV0IHdoZW4gZW5hYmxlZCBpbiBzZXR0aW5ncyxcbiAgICAvLyBpdCBhcHBlYXJzIHRoYXQgdGhlIGxvZ2dlciBjYW5ub3QgYmUgY3JlYXRlZCB1bnRpbCBleGVjdXRpb24gdGltZS5cbiAgICByZXR1cm4gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzLkZpbGUnKTtcbn1cblxuZXhwb3J0IHR5cGUgRXJyb3JMb2dnaW5nRnVuY3Rpb24gPSAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkO1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUZpbGUgPSAoe1xuICAgIG1ldGFkYXRhQ2FjaGU6IG5ld01ldGFkYXRhQ2FjaGUsXG4gICAgdmF1bHQ6IG5ld1ZhdWx0LFxuICAgIHdvcmtzcGFjZTogbmV3V29ya3NwYWNlLFxufToge1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgdmF1bHQ6IFZhdWx0O1xuICAgIHdvcmtzcGFjZTogV29ya3NwYWNlO1xufSkgPT4ge1xuICAgIG1ldGFkYXRhQ2FjaGUgPSBuZXdNZXRhZGF0YUNhY2hlO1xuICAgIHZhdWx0ID0gbmV3VmF1bHQ7XG4gICAgd29ya3NwYWNlID0gbmV3V29ya3NwYWNlO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgb3JpZ2luYWwgdGFzayB3aXRoIG9uZSBvciBtb3JlIG5ldyB0YXNrcy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBtb3JlIHRoYW4gb25lIHJlcGxhY2VtZW50IHRhc2ssIGFsbCBzdWJzZXF1ZW50IHRhc2tzIGluIHRoZSBzYW1lXG4gKiBzZWN0aW9uIG11c3QgYmUgcmUtcmVuZGVyZWQsIGFzIHRoZWlyIHNlY3Rpb24gaW5kZXhlcyBjaGFuZ2UuIEFzc3VtaW5nIHRoYXRcbiAqIHRoaXMgaXMgZG9uZSBmYXN0ZXIgdGhhbiB1c2VyIGludGVyYWN0aW9uIGluIHByYWN0aWNlLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGlzIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGJlIGNhbGxlZCB3aXRoIHJlYXNvbmFibGUgY29uZmlkZW5jZVxuICogdGhhdCB0aGUge0Bjb2RlIG9yaWdpbmFsVGFza30gaXMgdW5tb2RpZmllZCBhbmQgYXQgdGhlIGV4YWN0IHNhbWUgc2VjdGlvbiBhbmRcbiAqIHNlY3Rpb25JZHggaW4gdGhlIHNvdXJjZSBmaWxlIGl0IHdhcyBvcmlnaW5hbGx5IGZvdW5kIGluLiBJdCB3aWxsIGZhaWwgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVRhc2tXaXRoVGFza3MgPSBhc3luYyAoe1xuICAgIG9yaWdpbmFsVGFzayxcbiAgICBuZXdUYXNrcyxcbn06IHtcbiAgICBvcmlnaW5hbFRhc2s6IFRhc2s7XG4gICAgbmV3VGFza3M6IFRhc2sgfCBUYXNrW107XG59KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHZhdWx0ID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGFDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IHdvcmtzcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yQW5kTm90aWNlKCdUYXNrczogY2Fubm90IHVzZSBGaWxlIGJlZm9yZSBpbml0aWFsaXppbmcgaXQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3VGFza3MpKSB7XG4gICAgICAgIG5ld1Rhc2tzID0gW25ld1Rhc2tzXTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKCk7XG4gICAgY29uc3QgY29kZUxvY2F0aW9uID0gJ3JlcGxhY2VUYXNrV2l0aFRhc2tzKCknO1xuICAgIGxvZ1N0YXJ0T2ZUYXNrRWRpdChsb2dnZXIsIGNvZGVMb2NhdGlvbiwgb3JpZ2luYWxUYXNrKTtcbiAgICBsb2dFbmRPZlRhc2tFZGl0KGxvZ2dlciwgY29kZUxvY2F0aW9uLCBuZXdUYXNrcyk7XG5cbiAgICBhd2FpdCB0cnlSZXBldGl0aXZlKHtcbiAgICAgICAgb3JpZ2luYWxUYXNrLFxuICAgICAgICBuZXdUYXNrcyxcbiAgICAgICAgdmF1bHQsXG4gICAgICAgIG1ldGFkYXRhQ2FjaGUsXG4gICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgcHJldmlvdXNUcmllczogMCxcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yQW5kTm90aWNlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgbmV3IE5vdGljZShtZXNzYWdlLCAxNTAwMCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BbmROb3RpY2UobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIG5ldyBOb3RpY2UobWVzc2FnZSwgMTAwMDApO1xufVxuXG5mdW5jdGlvbiBkZWJ1Z0xvZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKCk7XG4gICAgbG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xufVxuXG4vLyBXaGVuIHRoaXMgZXhjZXB0aW9uIGlzIHRocm93biwgaXQgaXMgbWVhbnQgdG8gaW5kaWNhdGUgdGhhdCB0aGUgY2FsbGVyIHNob3VsZCBjb25zaWRlciB0byB0cnkgdGhlIG9wZXJhdGlvblxuLy8gYWdhaW4gc29vblxuY2xhc3MgV2FybmluZ1dvcnRoUmV0cnlpbmcgZXh0ZW5kcyBFcnJvciB7fVxuLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGJlIHNpbGVudCBhYm91dCBpdFxuY2xhc3MgUmV0cnlXaXRob3V0V2FybmluZyBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gcmUtdHJ5IHdoZW4gdGhlIHJldHVybmVkIGZpbGUgY2FjaGUgaXMgYHVuZGVmaW5lZGAuXG4gKiBSZXRyeWluZyBhZnRlciBhIHdoaWxlIG1heSByZXR1cm4gYSB2YWxpZCBmaWxlIGNhY2hlLlxuICogUmVwb3J0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy84N1xuICovXG5jb25zdCB0cnlSZXBldGl0aXZlID0gYXN5bmMgKHtcbiAgICBvcmlnaW5hbFRhc2ssXG4gICAgbmV3VGFza3MsXG4gICAgdmF1bHQsXG4gICAgbWV0YWRhdGFDYWNoZSxcbiAgICB3b3Jrc3BhY2UsXG4gICAgcHJldmlvdXNUcmllcyxcbn06IHtcbiAgICBvcmlnaW5hbFRhc2s6IFRhc2s7XG4gICAgbmV3VGFza3M6IFRhc2tbXTtcbiAgICB2YXVsdDogVmF1bHQ7XG4gICAgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTtcbiAgICB3b3Jrc3BhY2U6IFdvcmtzcGFjZTtcbiAgICBwcmV2aW91c1RyaWVzOiBudW1iZXI7XG59KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcigpO1xuICAgIGxvZ2dlci5kZWJ1ZyhgdHJ5UmVwZXRpdGl2ZSBhZnRlciAke3ByZXZpb3VzVHJpZXN9IHByZXZpb3VzIHRyaWVzYCk7XG4gICAgY29uc3QgcmV0cnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91c1RyaWVzID4gMTApIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGFza3M6IENvdWxkIG5vdCBmaW5kIHRoZSBjb3JyZWN0IHRhc2sgbGluZSB0byB1cGRhdGUuXG5cblRoZSB0YXNrIGxpbmUgbm90IHVwZGF0ZWQgaXM6XG4ke29yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3dufVxuXG5JbiB0aGlzIG1hcmtkb3duIGZpbGU6XG5cIiR7b3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5wYXRofVwiXG5cbk5vdGU6IGZ1cnRoZXIgY2xpY2tzIG9uIHRoaXMgY2hlY2tib3ggd2lsbCB1c3VhbGx5IG5vdyBiZSBpZ25vcmVkIHVudGlsIHRoZSBmaWxlIGlzIG9wZW5lZCAob3IgY2VydGFpbiwgc3BlY2lmaWMgZWRpdHMgYXJlIG1hZGUgLSBpdCdzIGNvbXBsaWNhdGVkKS5cblxuUmVjb21tZW5kYXRpb25zOlxuXG4xLiBDbG9zZSBhbGwgcGFuZXMgdGhhdCBoYXZlIHRoZSBhYm92ZSBmaWxlIG9wZW4sIGFuZCB0aGVuIHJlLW9wZW4gdGhlIGZpbGUuXG5cbjIuIENoZWNrIGZvciBleGFjdGx5IGlkZW50aWNhbCBjb3BpZXMgb2YgdGhlIHRhc2sgbGluZSwgaW4gdGhpcyBmaWxlLCBhbmQgc2VlIGlmIHlvdSBjYW4gbWFrZSB0aGVtIGRpZmZlcmVudC5cbmA7XG4gICAgICAgICAgICBlcnJvckFuZE5vdGljZShtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLnBvdygxMCwgcHJldmlvdXNUcmllcyksIDEwMCk7IC8vIDEsIDEwLCAxMDAsIDEwMCwgMTAwLCAuLi5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKGB0aW1lb3V0ID0gJHt0aW1lb3V0fWApO1xuICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRyeVJlcGV0aXRpdmUoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzayxcbiAgICAgICAgICAgICAgICBuZXdUYXNrcyxcbiAgICAgICAgICAgICAgICB2YXVsdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1RyaWVzOiBwcmV2aW91c1RyaWVzICsgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW3Rhc2tMaW5lTnVtYmVyLCBmaWxlLCBmaWxlTGluZXNdID0gYXdhaXQgZ2V0VGFza0FuZEZpbGVMaW5lcyhvcmlnaW5hbFRhc2ssIHZhdWx0KTtcbiAgICAgICAgLy8gRmluYWxseSwgd2UgY2FuIGluc2VydCAxIG9yIG1vcmUgbGluZXMgb3ZlciB0aGUgb3JpZ2luYWwgdGFzayBsaW5lOlxuICAgICAgICBjb25zdCB1cGRhdGVkRmlsZUxpbmVzID0gW1xuICAgICAgICAgICAgLi4uZmlsZUxpbmVzLnNsaWNlKDAsIHRhc2tMaW5lTnVtYmVyKSxcbiAgICAgICAgICAgIC4uLm5ld1Rhc2tzLm1hcCgodGFzazogVGFzaykgPT4gdGFzay50b0ZpbGVMaW5lU3RyaW5nKCkpLFxuICAgICAgICAgICAgLi4uZmlsZUxpbmVzLnNsaWNlKHRhc2tMaW5lTnVtYmVyICsgMSksIC8vIE9ubHkgc3VwcG9ydHMgc2luZ2xlLWxpbmUgdGFza3MuXG4gICAgICAgIF07XG5cbiAgICAgICAgYXdhaXQgdmF1bHQubW9kaWZ5KGZpbGUsIHVwZGF0ZWRGaWxlTGluZXMuam9pbignXFxuJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYXJuaW5nV29ydGhSZXRyeWluZykge1xuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSkgd2FybkFuZE5vdGljZShlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgYXdhaXQgcmV0cnkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgUmV0cnlXaXRob3V0V2FybmluZykge1xuICAgICAgICAgICAgYXdhaXQgcmV0cnkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yQW5kTm90aWNlKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgbGluZSBvbiB3aGljaCBgdGFza2AgaXMgZGVmaW5lZCwgdG9nZXRoZXIgd2l0aCB0aGUgZmlsZSBpdCBpcyBkZWZpbmVkIGluLCBhbmQgdGhlXG4gKiBsaW5lcyBvZiB0aGF0IGZpbGUsIHBvc3NpYmx5IGZvciB0aGUgcHVycG9zZSBvZiB1cGRhdGluZyB0aGUgdGFzayBpbiB0aGUgZmlsZSBvciBqdW1waW5nIHRvIGl0LlxuICogSXQgbWF5IHRocm93IGEgV2FybmluZ1dvcnRoUmV0cnlpbmcgZXhjZXB0aW9uIGluIHNldmVyYWwgY2FzZXMgdGhhdCBqdXN0aWZ5IGEgcmV0cnkgKHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBjYWxsZXIpXG4gKiBvciBhbiBFcnJvciBleGNlcHRpb24gaW4gY2FzZSBvZiBhbiB1bnJlY292ZXJhYmxlIGVycm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRUYXNrQW5kRmlsZUxpbmVzKHRhc2s6IFRhc2ssIHZhdWx0OiBWYXVsdCk6IFByb21pc2U8W251bWJlciwgVEZpbGUsIHN0cmluZ1tdXT4ge1xuICAgIGlmIChtZXRhZGF0YUNhY2hlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBXYXJuaW5nV29ydGhSZXRyeWluZygpO1xuICAgIC8vIFZhbGlkYXRlIG91ciBpbnB1dHMuXG4gICAgLy8gRm9yIHBlcm1hbmVudCBmYWlsdXJlcywgcmV0dXJuIG5vdGhpbmcuXG4gICAgLy8gRm9yIGZhaWx1cmVzIHRoYXQgbWlnaHQgYmUgZml4ZWQgaWYgd2Ugd2FpdCBmb3IgYSBsaXR0bGUgd2hpbGUsIHJldHVybiByZXRyeSgpLlxuICAgIGNvbnN0IGZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGFzay5wYXRoKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBXYXJuaW5nV29ydGhSZXRyeWluZyhgVGFza3M6IE5vIGZpbGUgZm91bmQgZm9yIHRhc2sgJHt0YXNrLmRlc2NyaXB0aW9ufS4gUmV0cnlpbmcgLi4uYCk7XG4gICAgfVxuXG4gICAgaWYgKCFzdXBwb3J0ZWRGaWxlRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlLmV4dGVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXNrczogRG9lcyBub3Qgc3VwcG9ydCBmaWxlcyB3aXRoIHRoZSAke2ZpbGUuZXh0ZW5zaW9ufSBmaWxlIGV4dGVuc2lvbi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlQ2FjaGUgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICBpZiAoZmlsZUNhY2hlID09IHVuZGVmaW5lZCB8fCBmaWxlQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhcm5pbmdXb3J0aFJldHJ5aW5nKGBUYXNrczogTm8gZmlsZSBjYWNoZSBmb3VuZCBmb3IgZmlsZSAke2ZpbGUucGF0aH0uIFJldHJ5aW5nIC4uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RJdGVtc0NhY2hlID0gZmlsZUNhY2hlLmxpc3RJdGVtcztcbiAgICBpZiAobGlzdEl0ZW1zQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBsaXN0SXRlbXNDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhcm5pbmdXb3J0aFJldHJ5aW5nKGBUYXNrczogTm8gbGlzdCBpdGVtcyBmb3VuZCBpbiBmaWxlIGNhY2hlIG9mICR7ZmlsZS5wYXRofS4gUmV0cnlpbmcgLi4uYCk7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIG5vdyB0cnkgYW5kIGZpbmQgd2hpY2ggbGluZSBpbiB0aGUgZmlsZSBjdXJyZW50bHkgY29udGFpbnMgb3JpZ2luYWxUYXNrLFxuICAgIC8vIHNvIHRoYXQgd2Uga25vdyB3aGljaCBsaW5lIHRvIHVwZGF0ZS5cbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHZhdWx0LnJlYWQoZmlsZSk7IC8vIFRPRE86IHJlcGxhY2Ugd2l0aCB2YXVsdC5wcm9jZXNzLlxuICAgIGNvbnN0IGZpbGVMaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCB0YXNrTGluZU51bWJlciA9IGZpbmRMaW5lTnVtYmVyT2ZUYXNrVG9Ub2dnbGUodGFzaywgZmlsZUxpbmVzLCBsaXN0SXRlbXNDYWNoZSwgZGVidWdMb2cpO1xuXG4gICAgaWYgKHRhc2tMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbG9nRGF0YUZvck1vY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvZ0RhdGFGb3JNb2NraW5nKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZmluZGluZyB0aGUgY29ycmVjdCBsaW5lIHRvIHRvZ2dsZSxcbiAgICAgICAgICAgIC8vIHNvIHdyaXRlIG91dCB0byB0aGUgY29uc29sZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhIG5lZWRlZCB0byByZWNvbnN0cnVjdCB0aGUgYWJvdmVcbiAgICAgICAgICAgIC8vIGZpbmRMaW5lTnVtYmVyT2ZUYXNrVG9Ub2dnbGUoKSBjYWxsLCBzbyB0aGF0IHRoZSBjb250ZW50IGNhbiBiZSBzYXZlZFxuICAgICAgICAgICAgLy8gdG8gYSBKU09OIGZpbGUgYW5kIHRoZW4gcmUtdXNlZCBpbiBhICd1bml0JyB0ZXN0LlxuICAgICAgICAgICAgc2F2ZU1vY2tEYXRhRm9yVGVzdGluZyh0YXNrLCBmaWxlTGluZXMsIGxpc3RJdGVtc0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmV0cnlXaXRob3V0V2FybmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gW3Rhc2tMaW5lTnVtYmVyLCBmaWxlLCBmaWxlTGluZXNdO1xufVxuXG4vLyBBIHNpbXBsZXIgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGFib3ZlLCB3aGljaCBkb2Vzbid0IHJldHVybiB0aGUgbGluZXMgb2YgdGhlIGZpbGUsIGFuZCBoYW5kbGVzIGV4Y2VwdGlvbnNcbi8vIGludGVybmFsbHkgcmF0aGVyIHRoYW4gdGhyb3cgdGhlbSB0byB0aGUgb3V0c2lkZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhc2tMaW5lQW5kRmlsZSh0YXNrOiBUYXNrLCB2YXVsdDogVmF1bHQpOiBQcm9taXNlPFtudW1iZXIsIFRGaWxlXSB8IHVuZGVmaW5lZD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFt0YXNrTGluZU51bWJlciwgZmlsZSwgX10gPSBhd2FpdCBnZXRUYXNrQW5kRmlsZUxpbmVzKHRhc2ssIHZhdWx0KTtcbiAgICAgICAgcmV0dXJuIFt0YXNrTGluZU51bWJlciwgZmlsZV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFdhcm5pbmdXb3J0aFJldHJ5aW5nKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlKSB3YXJuQW5kTm90aWNlKGUubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckFuZE5vdGljZShlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRMaW5lTnVtYmVyKGxpc3RJdGVtTGluZU51bWJlcjogbnVtYmVyLCBmaWxlTGluZXM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGxpc3RJdGVtTGluZU51bWJlciA8IGZpbGVMaW5lcy5sZW5ndGg7XG59XG5cbi8qKlxuICogVHJ5IHRvIGZpbmQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2sgLSB0aGUge0BsaW5rIFRhc2t9IGxpbmUgdGhhdCB0aGUgdXNlciBjbGlja2VkIG9uXG4gKiBAcGFyYW0gZmlsZUxpbmVzIC0gdGhlIGxpbmVzIHJlYWQgZnJvbSB0aGUgZmlsZS5cbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICogQHBhcmFtIGVycm9yTG9nZ2luZ0Z1bmN0aW9uIC0gYSBmdW5jdGlvbiBvZiB0eXBlIHtAbGluayBFcnJvckxvZ2dpbmdGdW5jdGlvbn0gLSB3aGljaCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgZm91bmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgZGlmZmVycyBmcm9tIHRoZSBvcmlnaW5hbCBtYXJrZG93biBpbiB7QGxpbmsgb3JpZ2luYWxUYXNrfS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkIHRvIGFsbG93IHRlc3RzIHRvIGJlIHdyaXR0ZW4gZm9yIHRoaXMgY29kZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBkbyBub3QgZGlzcGxheSBhIHBvcHVwIHdhcm5pbmcsIGJ1dCBpbnN0ZWFkIGNhcHR1cmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGluZU51bWJlck9mVGFza1RvVG9nZ2xlKFxuICAgIG9yaWdpbmFsVGFzazogVGFzayB8IE1vY2tUYXNrLFxuICAgIGZpbGVMaW5lczogc3RyaW5nW10sXG4gICAgbGlzdEl0ZW1zQ2FjaGU6IExpc3RJdGVtQ2FjaGVbXSB8IE1vY2tMaXN0SXRlbUNhY2hlW10sXG4gICAgZXJyb3JMb2dnaW5nRnVuY3Rpb246IEVycm9yTG9nZ2luZ0Z1bmN0aW9uLFxuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgcmVzdWx0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB0cnlGaW5kaW5nRXhhY3RNYXRjaEF0T3JpZ2luYWxMaW5lTnVtYmVyKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnlGaW5kaW5nSWRlbnRpY2FsVW5pcXVlTWFya2Rvd25MaW5lSW5GaWxlKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ5RmluZGluZ0xpbmVOdW1iZXJGcm9tVGFza1NlY3Rpb25JbmZvKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzLCBsaXN0SXRlbXNDYWNoZSwgZXJyb3JMb2dnaW5nRnVuY3Rpb24pO1xufVxuXG4vKipcbiAqICBJZiB0aGUgbGluZSBhdCBsaW5lIG51bWJlciBpbiBvcmlnaW5hbFRhc2sgbWF0Y2hlcyBvcmlnaW5hbCBtYXJrZG93bixcbiAqICB0cmVhdCB0aGF0IGFzIHRoZSBjb3JyZWN0IGFuc3dlci5cbiAqXG4gKiAgVGhpcyBjb3VsZCBnbyB3cm9uZyBpZjpcbiAqICAgICAtIFNvbWUgbGluZXMgaGF2ZSBiZWVuIGFkZGVkIHNpbmNlIG9yaWdpbmFsVGFzayB3YXMgcmVuZGVyZWQgaW4gUmVhZGluZyB2aWV3LFxuICogICAgICAgYW5kIGFuIGlkZW50aWNhbCB0YXNrIGxpbmUgd2FzIGFkZGVkLCB0aGF0IGhhcHBlbmVkIGJ5IGNvaW5jaWRlbmNlIHRvIGJlIGluIHRoZSBzYW1lXG4gKiAgICAgICBsaW5lIG51bWJlciBhcyB0aGUgb3JpZ2luYWwgdGFzay5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxUYXNrXG4gKiBAcGFyYW0gZmlsZUxpbmVzXG4gKi9cbmZ1bmN0aW9uIHRyeUZpbmRpbmdFeGFjdE1hdGNoQXRPcmlnaW5hbExpbmVOdW1iZXIob3JpZ2luYWxUYXNrOiBUYXNrIHwgTW9ja1Rhc2ssIGZpbGVMaW5lczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBvcmlnaW5hbFRhc2tMaW5lTnVtYmVyID0gb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyO1xuICAgIGlmIChpc1ZhbGlkTGluZU51bWJlcihvcmlnaW5hbFRhc2tMaW5lTnVtYmVyLCBmaWxlTGluZXMpKSB7XG4gICAgICAgIGlmIChmaWxlTGluZXNbb3JpZ2luYWxUYXNrTGluZU51bWJlcl0gPT09IG9yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3duKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIG9yaWdpbmFsIG1hcmtkb3duIGF0IG9yaWdpbmFsIGxpbmUgbnVtYmVyICR7b3JpZ2luYWxUYXNrTGluZU51bWJlcn1gKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRhc2tMaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSWYgdGhlIGxpbmUgb25seSBhcHBlYXJzIG9uY2UgaW4gdGhlIGZpbGUsIHVzZSB0aGF0IGxpbmUgbnVtYmVyLlxuICpcbiAqIFRoaXMgY291bGQgZ28gd3JvbmcgaWY6XG4gKiAgICAtIHRoZSB1c2VyIGhhZCBjb21tZW50ZWQgb3V0IHRoZSBvcmlnaW5hbCB0YXNrIGxpbmUsIGFuZCB0aGUgc2VjdGlvbiBoYWQgbm90IHlldCBiZWVuIHJlZHJhd25cbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqL1xuZnVuY3Rpb24gdHJ5RmluZGluZ0lkZW50aWNhbFVuaXF1ZU1hcmtkb3duTGluZUluRmlsZShvcmlnaW5hbFRhc2s6IFRhc2sgfCBNb2NrVGFzaywgZmlsZUxpbmVzOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IG1hdGNoaW5nTGluZU51bWJlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZmlsZUxpbmVzW2ldID09PSBvcmlnaW5hbFRhc2sub3JpZ2luYWxNYXJrZG93bikge1xuICAgICAgICAgICAgbWF0Y2hpbmdMaW5lTnVtYmVycy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGluZ0xpbmVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGUgbGluZSBpbiB0aGUgZmlsZSwgc28gaXQgbXVzdCBiZSB0aGVcbiAgICAgICAgLy8gbGluZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0xpbmVOdW1iZXJzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEZhbGwgYmFjayBvbiB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtLCB3aGljaCB1c2VzIHRoZSBzZWN0aW9uIGluZm9ybWF0aW9uIGluc2lkZSB0aGUgdGFzaydzIHtAbGluayBUYXNrTG9jYXRpb259LlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICogQHBhcmFtIGVycm9yTG9nZ2luZ0Z1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRyeUZpbmRpbmdMaW5lTnVtYmVyRnJvbVRhc2tTZWN0aW9uSW5mbyhcbiAgICBvcmlnaW5hbFRhc2s6IFRhc2sgfCBNb2NrVGFzayxcbiAgICBmaWxlTGluZXM6IHN0cmluZ1tdLFxuICAgIGxpc3RJdGVtc0NhY2hlOiBMaXN0SXRlbUNhY2hlW10gfCBNb2NrTGlzdEl0ZW1DYWNoZVtdLFxuICAgIGVycm9yTG9nZ2luZ0Z1bmN0aW9uOiBFcnJvckxvZ2dpbmdGdW5jdGlvbixcbikge1xuICAgIGxldCB0YXNrTGluZU51bWJlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGxldCBzZWN0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgbGlzdEl0ZW1DYWNoZSBvZiBsaXN0SXRlbXNDYWNoZSkge1xuICAgICAgICBjb25zdCBsaXN0SXRlbUxpbmVOdW1iZXIgPSBsaXN0SXRlbUNhY2hlLnBvc2l0aW9uLnN0YXJ0LmxpbmU7XG4gICAgICAgIGlmICghaXNWYWxpZExpbmVOdW1iZXIobGlzdEl0ZW1MaW5lTnVtYmVyLCBmaWxlTGluZXMpKSB7XG4gICAgICAgICAgICAvLyBPbmUgb3IgbW9yZSBsaW5lcyBoYXMgYmVlbiBkZWxldGVkIHNpbmNlIHRoZSBjYWNoZSB3YXMgcG9wdWxhdGVkLFxuICAgICAgICAgICAgLy8gc28gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3QgaXRlbSBpbiB0aGUgY2FjaGUgdGhhdCBpcyBiZXlvbmRcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIGFjdHVhbCBmaWxlIG9uIGRpc2suXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RJdGVtTGluZU51bWJlciA8IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24uc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0SXRlbUNhY2hlLnRhc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5lID0gZmlsZUxpbmVzW2xpc3RJdGVtTGluZU51bWJlcl07XG4gICAgICAgIGlmIChHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5pbmNsdWRlZEluKGxpbmUpKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbkluZGV4ID09PSBvcmlnaW5hbFRhc2sudGFza0xvY2F0aW9uLnNlY3Rpb25JbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSBvcmlnaW5hbFRhc2sub3JpZ2luYWxNYXJrZG93bikge1xuICAgICAgICAgICAgICAgICAgICB0YXNrTGluZU51bWJlciA9IGxpc3RJdGVtTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckxvZ2dpbmdGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUYXNrczogVW5hYmxlIHRvIGZpbmQgdGFzayBpbiBmaWxlICR7b3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5wYXRofS5cbkV4cGVjdGVkIHRhc2s6XG4ke29yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3dufVxuRm91bmQgdGFzazpcbiR7bGluZX1gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFza0xpbmVOdW1iZXI7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBMaXN0SXRlbUNhY2hlLCBQb3MgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuXG4vLyBTZWUgRmlsZS50ZXN0LnRzIGZvciBob3cgdG8gdXNlIHRoaXMuXG5cbnR5cGUgTW9ja1Rhc2tMb2NhdGlvbiA9IHtcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgbGluZU51bWJlcjogbnVtYmVyO1xuICAgIHNlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgIHNlY3Rpb25JbmRleDogbnVtYmVyO1xuICAgIHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbDtcbn07XG5cbi8qKiBhIG1vY2sgZm9yIHtAbGluayBMaXN0SXRlbUNhY2hlLnRhc2t9ICovXG50eXBlIE1vY2tMaXN0SXRlbUNhY2hlVGFzayA9IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuLyoqIGEgbW9jayBmb3Ige0BsaW5rIFBvc30gKi9cbnR5cGUgTW9ja1BvcyA9IFBvcztcblxuLyoqIGEgbW9jayBmb3Ige0BsaW5rIExpc3RJdGVtQ2FjaGV9ICovXG5leHBvcnQgdHlwZSBNb2NrTGlzdEl0ZW1DYWNoZSA9IHsgdGFzazogc3RyaW5nIHwgdW5kZWZpbmVkOyBwb3NpdGlvbjogUG9zIH07XG50eXBlIE1vY2tMaXN0SXRlbUNhY2hlcyA9IE1vY2tMaXN0SXRlbUNhY2hlW107XG5cbi8qKiBhIG1vY2sgZm9yIHtAbGluayBUYXNrfSAqL1xuZXhwb3J0IHR5cGUgTW9ja1Rhc2sgPSB7XG4gICAgb3JpZ2luYWxNYXJrZG93bjogc3RyaW5nO1xuICAgIHRhc2tMb2NhdGlvbjogTW9ja1Rhc2tMb2NhdGlvbjtcbn07XG5cbi8qKiBBbGwgdGhlIGRhdGEgcmVxdWlyZWQgdG8gY2FsbCB7QGxpbmsgZmluZExpbmVOdW1iZXJPZlRhc2tUb1RvZ2dsZX0gKi9cbmV4cG9ydCB0eXBlIE1vY2tUb2dnbGluZ0RhdGFGb3JUZXN0aW5nID0ge1xuICAgIGNhY2hlRGF0YTogeyBsaXN0SXRlbXNDYWNoZTogTW9ja0xpc3RJdGVtQ2FjaGVbXSB9O1xuICAgIGZpbGVEYXRhOiB7IGZpbGVMaW5lczogc3RyaW5nW10gfTtcbiAgICB0YXNrRGF0YTogTW9ja1Rhc2s7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gc2F2ZSBkYXRhIHRoYXQgaXMgdXNlZFxuICogd2hlbiBmaW5kaW5nIHdoaWNoIGxpbmUgdG8gdG9nZ2xlIGluIGEgZmlsZS5cbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICpcbiAqIEBzZWUgc2F2ZU1vY2tEYXRhRm9yVGVzdGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9ja0RhdGFGb3JUZXN0aW5nKFxuICAgIG9yaWdpbmFsVGFzazogVGFzayxcbiAgICBmaWxlTGluZXM6IHN0cmluZ1tdLFxuICAgIGxpc3RJdGVtc0NhY2hlOiBMaXN0SXRlbUNhY2hlW10sXG4pOiBNb2NrVG9nZ2xpbmdEYXRhRm9yVGVzdGluZyB7XG4gICAgY29uc3QgYWxsRGF0YUZyb21MaXN0SXRlbUNhY2hlOiBNb2NrTGlzdEl0ZW1DYWNoZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxpc3RJdGVtQ2FjaGUgb2YgbGlzdEl0ZW1zQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgcG9zOiBNb2NrUG9zID0gbGlzdEl0ZW1DYWNoZS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdGFzazogTW9ja0xpc3RJdGVtQ2FjaGVUYXNrID0gbGlzdEl0ZW1DYWNoZS50YXNrO1xuICAgICAgICBjb25zdCBkYXRhRnJvbUxpc3RJdGVtQ2FjaGU6IE1vY2tMaXN0SXRlbUNhY2hlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgIH07XG4gICAgICAgIGFsbERhdGFGcm9tTGlzdEl0ZW1DYWNoZS5wdXNoKGRhdGFGcm9tTGlzdEl0ZW1DYWNoZSk7XG4gICAgfVxuICAgIGNvbnN0IG1vY2tUYXNrTG9jYXRpb246IE1vY2tUYXNrTG9jYXRpb24gPSB7XG4gICAgICAgIHBhdGg6IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24ucGF0aCxcbiAgICAgICAgbGluZU51bWJlcjogb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyLFxuICAgICAgICBzZWN0aW9uU3RhcnQ6IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24uc2VjdGlvblN0YXJ0LFxuICAgICAgICBzZWN0aW9uSW5kZXg6IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24uc2VjdGlvbkluZGV4LFxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24ucHJlY2VkaW5nSGVhZGVyLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFza0RhdGE6IHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFya2Rvd246IG9yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3duLFxuICAgICAgICAgICAgdGFza0xvY2F0aW9uOiBtb2NrVGFza0xvY2F0aW9uLFxuICAgICAgICB9LFxuICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZUxpbmVzOiBmaWxlTGluZXMsXG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlRGF0YToge1xuICAgICAgICAgICAgbGlzdEl0ZW1zQ2FjaGU6IGFsbERhdGFGcm9tTGlzdEl0ZW1DYWNoZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFdyaXRlIHRoZSBzdXBwbGllZCBkYXRhIHRvIHRoZSBjb25zb2xlLCBzbyBpdCBjYW4gYmUgc2F2ZWQgZm9yIHVzZSBpbiB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZU1vY2tEYXRhRm9yVGVzdGluZyhvcmlnaW5hbFRhc2s6IFRhc2ssIGZpbGVMaW5lczogc3RyaW5nW10sIGxpc3RJdGVtc0NhY2hlOiBMaXN0SXRlbUNhY2hlW10pIHtcbiAgICBjb25zdCBldmVyeXRoaW5nID0gZ2V0TW9ja0RhdGFGb3JUZXN0aW5nKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzLCBsaXN0SXRlbXNDYWNoZSk7XG4gICAgY29uc29sZS5lcnJvcihgSW5jb25zaXN0ZW50IGxpbmVzOiBTQVZFIFRIRSBPVVRQVVRcbmRhdGE6XG4ke0pTT04uc3RyaW5naWZ5KGV2ZXJ5dGhpbmcpfVxuYCk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcih0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKTtcbn1cbiIsICJpbXBvcnQgeyBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgfSBmcm9tICcuLi9saWIvU3RyaW5nSGVscGVycyc7XG5pbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vVGFzay9SZWN1cnJlbmNlJztcbmltcG9ydCB0eXBlIHsgRWRpdGFibGVUYXNrIH0gZnJvbSAnLi9FZGl0YWJsZVRhc2snO1xuXG4vKipcbiAqIFJldHVybnMgY29udGVudHMgZm9yIGEgYDxsYWJlbD5gIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIGFjY2Vzc0tleX0gaXMgZm91bmQgaW4gdGhlIGxhYmVsIHRleHQgKGNhc2UtaW5zZW5zaXRpdmUpLCBpdCB3aWxsIGJlIGdpdmVuIGBhY2Nlc3NrZXlgIGNsYXNzXG4gKiB3aXRoaW4gYSBgPHNwYW4+YCBIVE1MIGVsZW1lbnQuIEVsc2UgdGhlIGFjY2VzcyBrZXkgd2lsbCBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsYWJlbCB0ZXh0LFxuICogc3Vycm91bmRlZCB3aXRoIHJvdW5kIGJyYWNrZXRzLlxuICpcbiAqIFRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIGxhYmVsIHdpbGwgYmUgY2FwaXRhbGlzZWQuXG4gKlxuICogQHBhcmFtIGxhYmVsVGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIDxsYWJlbD4gSFRNTCBlbGVtZW50LlxuICogQHBhcmFtIGFjY2Vzc0tleSBvcHRpb25hbCBhY2Nlc3Mga2V5LiBTZXQgdG8gbnVsbCBpZiBub3QgbmVlZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxDb250ZW50V2l0aEFjY2Vzc0tleShsYWJlbFRleHQ6IHN0cmluZywgYWNjZXNzS2V5OiBzdHJpbmcgfCBudWxsKSB7XG4gICAgaWYgKGFjY2Vzc0tleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGxhYmVsVGV4dCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjZXNzS2V5SW5kZXggPSBsYWJlbFRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKGFjY2Vzc0tleS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYWNjZXNzS2V5SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBgJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIobGFiZWxUZXh0KX0gKDxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCI+JHthY2Nlc3NLZXkudG9Mb3dlckNhc2UoKX08L3NwYW4+KWA7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsQ29udGVudCA9IGxhYmVsVGV4dC5zdWJzdHJpbmcoMCwgYWNjZXNzS2V5SW5kZXgpO1xuICAgIGxhYmVsQ29udGVudCArPSAnPHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXlcIj4nO1xuXG4gICAgaWYgKGFjY2Vzc0tleUluZGV4ID09PSAwKSB7XG4gICAgICAgIGxhYmVsQ29udGVudCArPSBsYWJlbFRleHQuc3Vic3RyaW5nKGFjY2Vzc0tleUluZGV4LCBhY2Nlc3NLZXlJbmRleCArIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxDb250ZW50ICs9IGxhYmVsVGV4dC5zdWJzdHJpbmcoYWNjZXNzS2V5SW5kZXgsIGFjY2Vzc0tleUluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgbGFiZWxDb250ZW50ICs9ICc8L3NwYW4+JztcbiAgICBsYWJlbENvbnRlbnQgKz0gbGFiZWxUZXh0LnN1YnN0cmluZyhhY2Nlc3NLZXlJbmRleCArIDEpO1xuICAgIGxhYmVsQ29udGVudCA9IGNhcGl0YWxpemVGaXJzdExldHRlcihsYWJlbENvbnRlbnQpO1xuICAgIHJldHVybiBsYWJlbENvbnRlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlUmVjdXJyZW5jZShlZGl0YWJsZVRhc2s6IEVkaXRhYmxlVGFzaykge1xuICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICBpZiAoIWVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSkge1xuICAgICAgICByZXR1cm4geyBwYXJzZWRSZWN1cnJlbmNlOiAnPGk+bm90IHJlY3VycmluZzwvPicsIGlzUmVjdXJyZW5jZVZhbGlkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdXJyZW5jZUZyb21UZXh0ID0gUmVjdXJyZW5jZS5mcm9tVGV4dCh7XG4gICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlLFxuICAgICAgICAvLyBPbmx5IGZvciByZXByZXNlbnRhdGlvbiBpbiB0aGUgbW9kYWwsIG5vIGRhdGVzIHJlcXVpcmVkLlxuICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgIHJlbWluZGVyRGF0ZTogbnVsbCxcbiAgICB9KT8udG9UZXh0KCk7XG5cbiAgICBpZiAoIXJlY3VycmVuY2VGcm9tVGV4dCkge1xuICAgICAgICByZXR1cm4geyBwYXJzZWRSZWN1cnJlbmNlOiAnPGk+aW52YWxpZCByZWN1cnJlbmNlIHJ1bGU8L2k+JywgaXNSZWN1cnJlbmNlVmFsaWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgaWYgKGVkaXRhYmxlVGFzay5zdGFydERhdGUgfHwgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUgfHwgZWRpdGFibGVUYXNrLmR1ZURhdGUgfHwgZWRpdGFibGVUYXNrLnJlbWluZGVyRGF0ZSkge1xuICAgICAgICByZXR1cm4geyBwYXJzZWRSZWN1cnJlbmNlOiByZWN1cnJlbmNlRnJvbVRleHQsIGlzUmVjdXJyZW5jZVZhbGlkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGFyc2VkUmVjdXJyZW5jZTogJzxpPmR1ZSwgc2NoZWR1bGVkLCByZW1pbmRlciBvciBzdGFydCBkYXRlIHJlcXVpcmVkPC9pPicsIGlzUmVjdXJyZW5jZVZhbGlkOiBmYWxzZSB9O1xufVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgZG9BdXRvY29tcGxldGUgfSBmcm9tICcuLi9saWIvRGF0ZUFiYnJldmlhdGlvbnMnO1xuICAgIGltcG9ydCB7IHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheVVzaW5nRnV0dXJlRGF0ZSB9IGZyb20gJy4uL2xpYi9EYXRlVG9vbHMnO1xuICAgIGltcG9ydCB7IGxhYmVsQ29udGVudFdpdGhBY2Nlc3NLZXkgfSBmcm9tICcuL0VkaXRUYXNrSGVscGVycyc7XG5cbiAgICBleHBvcnQgbGV0IGlkOiAnc3RhcnQnIHwgJ3NjaGVkdWxlZCcgfCAnZHVlJyB8ICdyZW1pbmRlcicgfCAnZG9uZScgfCAnY3JlYXRlZCcgfCAnY2FuY2VsbGVkJztcbiAgICBleHBvcnQgbGV0IGRhdGVTeW1ib2w6IHN0cmluZztcbiAgICBleHBvcnQgbGV0IGRhdGU6IHN0cmluZztcbiAgICBleHBvcnQgbGV0IGlzRGF0ZVZhbGlkOiBib29sZWFuO1xuICAgIGV4cG9ydCBsZXQgZm9yd2FyZE9ubHk6IGJvb2xlYW47XG4gICAgZXhwb3J0IGxldCBhY2Nlc3NrZXk6IHN0cmluZyB8IG51bGw7XG5cbiAgICBsZXQgcGFyc2VkRGF0ZTogc3RyaW5nO1xuICAgICQ6IHtcbiAgICAgICAgZGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGRhdGUpO1xuICAgICAgICBwYXJzZWREYXRlID0gcGFyc2VUeXBlZERhdGVGb3JEaXNwbGF5VXNpbmdGdXR1cmVEYXRlKGlkLCBkYXRlLCBmb3J3YXJkT25seSk7XG4gICAgICAgIGlzRGF0ZVZhbGlkID0gIXBhcnNlZERhdGUuaW5jbHVkZXMoJ2ludmFsaWQnKTtcbiAgICB9XG5cbiAgICAvLyAnd2Vla2VuZCcgYWJicmV2aWF0aW9uIG9taXR0ZWQgZHVlIHRvIGxhY2sgb2Ygc3BhY2UuXG4gICAgY29uc3QgZGF0ZVBsYWNlaG9sZGVyID0gXCJUcnkgJ01vbicgb3IgJ3RtJyB0aGVuIHNwYWNlXCI7XG48L3NjcmlwdD5cblxuPGxhYmVsIGZvcj17aWR9PntAaHRtbCBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5KGlkLCBhY2Nlc3NrZXkpfTwvbGFiZWw+XG48IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hY2Nlc3NrZXkgLS0+XG48aW5wdXRcbiAgICBiaW5kOnZhbHVlPXtkYXRlfVxuICAgIHtpZH1cbiAgICB0eXBlPVwidGV4dFwiXG4gICAgY2xhc3M6dGFza3MtbW9kYWwtZXJyb3I9eyFpc0RhdGVWYWxpZH1cbiAgICBjbGFzcz1cInRhc2tzLW1vZGFsLWRhdGUtaW5wdXRcIlxuICAgIHBsYWNlaG9sZGVyPXtkYXRlUGxhY2Vob2xkZXJ9XG4gICAge2FjY2Vzc2tleX1cbi8+XG48Y29kZSBjbGFzcz1cInRhc2tzLW1vZGFsLXBhcnNlZC1kYXRlXCI+e2RhdGVTeW1ib2x9IHtAaHRtbCBwYXJzZWREYXRlfTwvY29kZT5cblxuPHN0eWxlPlxuPC9zdHlsZT5cbiIsICJjb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlY3QsXG4gICAgdG9wOiByZWN0LnksXG4gICAgbGVmdDogcmVjdC54LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IHsgYWxpZ25tZW50cywgY2xhbXAsIGNyZWF0ZUNvb3JkcywgZXZhbHVhdGUsIGV4cGFuZFBhZGRpbmdPYmplY3QsIGZsb29yLCBnZXRBbGlnbm1lbnQsIGdldEFsaWdubWVudEF4aXMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRBeGlzTGVuZ3RoLCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZUF4aXMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRQYWRkaW5nT2JqZWN0LCBnZXRTaWRlLCBnZXRTaWRlQXhpcywgbWF4LCBtaW4sIHBsYWNlbWVudHMsIHJlY3RUb0NsaWVudFJlY3QsIHJvdW5kLCBzaWRlcyB9O1xuIiwgImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIHBvc2l0aW9uaW5nIHN0cmF0ZWd5LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIC4uLnJlY3RzLmZsb2F0aW5nLFxuICAgIHgsXG4gICAgeVxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJykge1xuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHMucHVzaCguLi5nZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24sIHJ0bCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93cyA9IFtdO1xuICAgICAgbGV0IG92ZXJmbG93c0RhdGEgPSAoKF9taWRkbGV3YXJlRGF0YSRmbGlwID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwLm92ZXJmbG93cykgfHwgW107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlc1swXV0sIG92ZXJmbG93W3NpZGVzWzFdXSk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZy5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgIG92ZXJmbG93czogb3ZlcmZsb3dzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRtYXAkc287XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJG1hcCRzbyA9IG92ZXJmbG93c0RhdGEubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJG1hcCRzb1swXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogMCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbCxcbiAgICAuLi5yYXdWYWx1ZVxuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBcdTIwMTRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5ID0gKCkgPT4ge30sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gcmVjdHMuZmxvYXRpbmc7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3dbd2lkdGhTaWRlXTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBhbGlnbm1lbnQgfHwgbm9TaGlmdCA/IG1pbihvdmVyZmxvd0F2YWlsYWJsZVdpZHRoLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCkgOiBtYXhpbXVtQ2xpcHBpbmdXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gYWxpZ25tZW50IHx8IG5vU2hpZnQgPyBtaW4ob3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQsIG1heGltdW1DbGlwcGluZ0hlaWdodCkgOiBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iLCAiZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICAvLyBCcm93c2VycyB3aXRob3V0IGBTaGFkb3dSb290YCBzdXBwb3J0LlxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1dlYktpdCgpIHtcbiAgaWYgKHR5cGVvZiBDU1MgPT09ICd1bmRlZmluZWQnIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cygnLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXInLCAnbm9uZScpO1xufVxuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIHdpbi5mcmFtZUVsZW1lbnQgJiYgdHJhdmVyc2VJZnJhbWVzID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMod2luLmZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5cbmV4cG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGdldENvbnRhaW5pbmdCbG9jaywgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNXZWJLaXQgfTtcbiIsICJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldERvY3VtZW50RWxlbWVudCwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSB3aW4uZnJhbWVFbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IHdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSkuZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLihhd2FpdCBnZXREaW1lbnNpb25zRm4oZmxvYXRpbmcpKVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIGlvICYmIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICByZXNpemVPYnNlcnZlciAmJiByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvICYmIGNsZWFudXBJbygpO1xuICAgIHJlc2l6ZU9ic2VydmVyICYmIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIENTUyBwb3NpdGlvbmluZ1xuICogc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBwbGF0Zm9ybSB9O1xuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgY29tcHV0ZVBvc2l0aW9uLCBmbGlwLCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG4gICAgaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbiAgICBpbXBvcnQgdHlwZSB7IEVkaXRhYmxlVGFzayB9IGZyb20gJy4vRWRpdGFibGVUYXNrJztcbiAgICBpbXBvcnQgeyBkZXNjcmlwdGlvbkFkanVzdGVkRm9yRGVwZW5kZW5jeVNlYXJjaCwgc2VhcmNoRm9yQ2FuZGlkYXRlVGFza3NGb3JEZXBlbmRlbmN5IH0gZnJvbSAnLi9EZXBlbmRlbmN5SGVscGVycyc7XG4gICAgaW1wb3J0IHsgbGFiZWxDb250ZW50V2l0aEFjY2Vzc0tleSB9IGZyb20gJy4vRWRpdFRhc2tIZWxwZXJzJztcblxuICAgIGV4cG9ydCBsZXQgdGFzazogVGFzaztcbiAgICBleHBvcnQgbGV0IGVkaXRhYmxlVGFzazogRWRpdGFibGVUYXNrO1xuICAgIGV4cG9ydCBsZXQgYWxsVGFza3M6IFRhc2tbXTtcbiAgICBleHBvcnQgbGV0IF9vbkRlc2NyaXB0aW9uS2V5RG93bjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG4gICAgZXhwb3J0IGxldCB0eXBlOiAnYmxvY2tpbmcnIHwgJ2Jsb2NrZWRCeSc7XG4gICAgZXhwb3J0IGxldCBsYWJlbFRleHQ6IHN0cmluZztcbiAgICBleHBvcnQgbGV0IGFjY2Vzc2tleTogc3RyaW5nIHwgbnVsbDtcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnVHlwZSB0byBzZWFyY2guLi4nO1xuXG4gICAgbGV0IHNlYXJjaDogc3RyaW5nID0gJyc7XG4gICAgbGV0IHNlYXJjaFJlc3VsdHM6IFRhc2tbXSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBzZWFyY2hJbmRleDogbnVtYmVyIHwgbnVsbCA9IDA7XG4gICAgbGV0IGlucHV0V2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaW5wdXRGb2N1c2VkID0gZmFsc2U7XG4gICAgbGV0IHNob3dEcm9wZG93biA9IGZhbHNlO1xuXG4gICAgbGV0IGlucHV0OiBIVE1MRWxlbWVudDtcbiAgICBsZXQgZHJvcGRvd246IEhUTUxFbGVtZW50O1xuXG4gICAgZnVuY3Rpb24gYWRkVGFzayh0YXNrOiBUYXNrKSB7XG4gICAgICAgIGVkaXRhYmxlVGFza1t0eXBlXSA9IFsuLi5lZGl0YWJsZVRhc2tbdHlwZV0sIHRhc2tdO1xuICAgICAgICBzZWFyY2ggPSAnJztcbiAgICAgICAgaW5wdXRGb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVGFzayh0YXNrOiBUYXNrKSB7XG4gICAgICAgIGVkaXRhYmxlVGFza1t0eXBlXSA9IGVkaXRhYmxlVGFza1t0eXBlXS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IHRhc2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRhc2tLZXlkb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdHMgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEhc2VhcmNoSW5kZXggJiYgc2VhcmNoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaEluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoSW5kZXggPSBzZWFyY2hSZXN1bHRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEhc2VhcmNoSW5kZXggJiYgc2VhcmNoSW5kZXggPCBzZWFyY2hSZXN1bHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRhc2soc2VhcmNoUmVzdWx0c1tzZWFyY2hJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9vbkRlc2NyaXB0aW9uS2V5RG93bihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2hJbmRleCAmJiBkcm9wZG93bj8uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJylbc2VhcmNoSW5kZXhdPy5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnbmVhcmVzdCcgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTZWFyY2hSZXN1bHRzKHNlYXJjaDogc3RyaW5nKSB7XG4gICAgICAgIGlmICghc2VhcmNoICYmICFzaG93RHJvcGRvd24pIHJldHVybiBbXTtcblxuICAgICAgICBzaG93RHJvcGRvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaEZvckNhbmRpZGF0ZVRhc2tzRm9yRGVwZW5kZW5jeShcbiAgICAgICAgICAgIHNlYXJjaCxcbiAgICAgICAgICAgIGFsbFRhc2tzLFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5ibG9ja2VkQnksXG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suYmxvY2tpbmcsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Gb2N1c2VkKCkge1xuICAgICAgICBpbnB1dEZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBzaG93RHJvcGRvd24gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uRHJvcGRvd24oaW5wdXQ6IEhUTUxFbGVtZW50LCBkcm9wZG93bjogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFpbnB1dCB8fCAhZHJvcGRvd24pIHJldHVybjtcblxuICAgICAgICBjb21wdXRlUG9zaXRpb24oaW5wdXQsIGRyb3Bkb3duLCB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgICAgICAgICAgb2Zmc2V0KDYpLFxuICAgICAgICAgICAgICAgIHNoaWZ0KCksXG4gICAgICAgICAgICAgICAgZmxpcCgpLFxuICAgICAgICAgICAgICAgIHNpemUoe1xuICAgICAgICAgICAgICAgICAgICBhcHBseSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duICYmIE9iamVjdC5hc3NpZ24oZHJvcGRvd24uc3R5bGUsIHsgd2lkdGg6IGAke2lucHV0V2lkdGh9cHhgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkudGhlbigoeyB4LCB5IH0pID0+IHtcbiAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLmxlZnQgPSBgJHt4fXB4YDtcbiAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhdGggPT09IHRhc2sudGFza0xvY2F0aW9uLnBhdGggPyAnJyA6IHBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzY3JpcHRpb25Ub29sdGlwVGV4dCh0YXNrOiBUYXNrKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbkFkanVzdGVkRm9yRGVwZW5kZW5jeVNlYXJjaCh0YXNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93RGVzY3JpcHRpb25Ub29sdGlwKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCB0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGVsZW1lbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgIHRvb2x0aXAuYWRkQ2xhc3NlcyhbJ3Rvb2x0aXAnLCAncG9wLXVwJ10pO1xuICAgICAgICB0b29sdGlwLmlubmVyVGV4dCA9IHRleHQ7XG5cbiAgICAgICAgY29tcHV0ZVBvc2l0aW9uKGVsZW1lbnQsIHRvb2x0aXAsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgICBtaWRkbGV3YXJlOiBbb2Zmc2V0KC0xOCksIHNoaWZ0KCldLFxuICAgICAgICB9KS50aGVuKCh7IHgsIHkgfSkgPT4ge1xuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB0b29sdGlwLnJlbW92ZSgpKTtcbiAgICB9XG5cbiAgICAkOiB7XG4gICAgICAgIHBvc2l0aW9uRHJvcGRvd24oaW5wdXQsIGRyb3Bkb3duKTtcbiAgICB9XG5cbiAgICAkOiB7XG4gICAgICAgIHNlYXJjaFJlc3VsdHMgPSBpbnB1dEZvY3VzZWQgPyBnZW5lcmF0ZVNlYXJjaFJlc3VsdHMoc2VhcmNoKSA6IG51bGw7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxsYWJlbCBmb3I9e3R5cGV9PntAaHRtbCBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5KGxhYmVsVGV4dCwgYWNjZXNza2V5KX08L2xhYmVsPlxuPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuPHNwYW4gYmluZDpjbGllbnRXaWR0aD17aW5wdXRXaWR0aH0+XG4gICAgPGlucHV0XG4gICAgICAgIGJpbmQ6dGhpcz17aW5wdXR9XG4gICAgICAgIGJpbmQ6dmFsdWU9e3NlYXJjaH1cbiAgICAgICAgb246a2V5ZG93bj17KGUpID0+IHRhc2tLZXlkb3duKGUpfVxuICAgICAgICBvbjpmb2N1cz17b25Gb2N1c2VkfVxuICAgICAgICBvbjpibHVyPXsoKSA9PiAoaW5wdXRGb2N1c2VkID0gZmFsc2UpfVxuICAgICAgICB7YWNjZXNza2V5fVxuICAgICAgICBpZD17dHlwZX1cbiAgICAgICAgY2xhc3M9XCJ0YXNrcy1tb2RhbC1kZXBlbmRlbmN5LWlucHV0XCJcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgLz5cbjwvc3Bhbj5cbnsjaWYgc2VhcmNoUmVzdWx0cyAmJiBzZWFyY2hSZXN1bHRzLmxlbmd0aCAhPT0gMH1cbiAgICA8dWwgY2xhc3M9XCJ0YXNrLWRlcGVuZGVuY3ktZHJvcGRvd25cIiBiaW5kOnRoaXM9e2Ryb3Bkb3dufSBvbjptb3VzZWxlYXZlPXsoKSA9PiAoc2VhcmNoSW5kZXggPSBudWxsKX0+XG4gICAgICAgIHsjZWFjaCBzZWFyY2hSZXN1bHRzIGFzIHNlYXJjaFRhc2ssIGluZGV4fVxuICAgICAgICAgICAge0Bjb25zdCBmaWxlcGF0aCA9IGRpc3BsYXlQYXRoKHNlYXJjaFRhc2sudGFza0xvY2F0aW9uLnBhdGgpfVxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgIDxsaVxuICAgICAgICAgICAgICAgIG9uOm1vdXNlZG93bj17KCkgPT4gYWRkVGFzayhzZWFyY2hUYXNrKX1cbiAgICAgICAgICAgICAgICBjbGFzczpzZWxlY3RlZD17c2VhcmNoICE9PSBudWxsICYmIGluZGV4ID09PSBzZWFyY2hJbmRleH1cbiAgICAgICAgICAgICAgICBvbjptb3VzZWVudGVyPXsoKSA9PiAoc2VhcmNoSW5kZXggPSBpbmRleCl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz17ZmlsZXBhdGggPyAnZGVwZW5kZW5jeS1uYW1lLXNoYXJlZCcgOiAnZGVwZW5kZW5jeS1uYW1lJ31cbiAgICAgICAgICAgICAgICAgICAgb246bW91c2VlbnRlcj17KGUpID0+IHNob3dEZXNjcmlwdGlvblRvb2x0aXAoZS5jdXJyZW50VGFyZ2V0LCBkZXNjcmlwdGlvblRvb2x0aXBUZXh0KHNlYXJjaFRhc2spKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIFt7c2VhcmNoVGFzay5zdGF0dXMuc3ltYm9sfV0ge2Rlc2NyaXB0aW9uQWRqdXN0ZWRGb3JEZXBlbmRlbmN5U2VhcmNoKHNlYXJjaFRhc2spfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHsjaWYgZmlsZXBhdGh9XG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGVwZW5kZW5jeS1wYXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOm1vdXNlZW50ZXI9eyhlKSA9PiBzaG93RGVzY3JpcHRpb25Ub29sdGlwKGUuY3VycmVudFRhcmdldCwgZmlsZXBhdGgpfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZmlsZXBhdGh9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cbnsvaWZ9XG57I2lmIGVkaXRhYmxlVGFza1t0eXBlXS5sZW5ndGggIT09IDB9XG4gICAgPGRpdiBjbGFzcz1cInRhc2stZGVwZW5kZW5jaWVzLWNvbnRhaW5lciByZXN1bHRzLWRlcGVuZGVuY3lcIj5cbiAgICAgICAgeyNlYWNoIGVkaXRhYmxlVGFza1t0eXBlXSBhcyB0YXNrfVxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFzay1kZXBlbmRlbmN5XCJcbiAgICAgICAgICAgICAgICBvbjptb3VzZWVudGVyPXsoZSkgPT4gc2hvd0Rlc2NyaXB0aW9uVG9vbHRpcChlLmN1cnJlbnRUYXJnZXQsIGRlc2NyaXB0aW9uVG9vbHRpcFRleHQodGFzaykpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGFzay1kZXBlbmRlbmN5LW5hbWVcIlxuICAgICAgICAgICAgICAgICAgICA+W3t0YXNrLnN0YXR1cy5zeW1ib2x9XSB7ZGVzY3JpcHRpb25BZGp1c3RlZEZvckRlcGVuZGVuY3lTZWFyY2godGFzayl9PC9zcGFuXG4gICAgICAgICAgICAgICAgPlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbjpjbGljaz17KCkgPT4gcmVtb3ZlVGFzayh0YXNrKX0gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidGFzay1kZXBlbmRlbmN5LWRlbGV0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImRpc3BsYXk6IGJsb2NrOyBtYXJnaW46IGF1dG87XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIxMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XCI0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJsdWNpZGUgbHVjaWRlLXhcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE4IDYgNiAxOFwiIC8+PHBhdGggZD1cIm02IDYgMTIgMTJcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgVEFTS19GT1JNQVRTIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbiAgICBpbXBvcnQgdHlwZSB7IEVkaXRhYmxlVGFzayB9IGZyb20gJy4vRWRpdGFibGVUYXNrJztcbiAgICBpbXBvcnQgeyBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5LCBwYXJzZUFuZFZhbGlkYXRlUmVjdXJyZW5jZSB9IGZyb20gJy4vRWRpdFRhc2tIZWxwZXJzJztcblxuICAgIGV4cG9ydCBsZXQgZWRpdGFibGVUYXNrOiBFZGl0YWJsZVRhc2s7XG4gICAgZXhwb3J0IGxldCBpc1JlY3VycmVuY2VWYWxpZDogYm9vbGVhbjtcbiAgICBleHBvcnQgbGV0IGFjY2Vzc2tleTogc3RyaW5nIHwgbnVsbDtcblxuICAgIGxldCBwYXJzZWRSZWN1cnJlbmNlOiBzdHJpbmc7XG5cbiAgICAkOiAoeyBwYXJzZWRSZWN1cnJlbmNlLCBpc1JlY3VycmVuY2VWYWxpZCB9ID0gcGFyc2VBbmRWYWxpZGF0ZVJlY3VycmVuY2UoZWRpdGFibGVUYXNrKSk7XG5cbiAgICBjb25zdCB7IHJlY3VycmVuY2VTeW1ib2wgfSA9IFRBU0tfRk9STUFUUy50YXNrc1BsdWdpbkVtb2ppLnRhc2tTZXJpYWxpemVyLnN5bWJvbHM7XG48L3NjcmlwdD5cblxuPGxhYmVsIGZvcj1cInJlY3VycmVuY2VcIj57QGh0bWwgbGFiZWxDb250ZW50V2l0aEFjY2Vzc0tleSgnUmVjdXJzJywgYWNjZXNza2V5KX08L2xhYmVsPlxuPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuPGlucHV0XG4gICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlfVxuICAgIGlkPVwicmVjdXJyZW5jZVwiXG4gICAgdHlwZT1cInRleHRcIlxuICAgIGNsYXNzOnRhc2tzLW1vZGFsLWVycm9yPXshaXNSZWN1cnJlbmNlVmFsaWR9XG4gICAgY2xhc3M9XCJ0YXNrcy1tb2RhbC1kYXRlLWlucHV0XCJcbiAgICBwbGFjZWhvbGRlcj1cIlRyeSAnZXZlcnkgZGF5IHdoZW4gZG9uZSdcIlxuICAgIHthY2Nlc3NrZXl9XG4vPlxuPGNvZGUgY2xhc3M9XCJ0YXNrcy1tb2RhbC1wYXJzZWQtZGF0ZVwiPntyZWN1cnJlbmNlU3ltYm9sfSB7QGh0bWwgcGFyc2VkUmVjdXJyZW5jZX08L2NvZGU+XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgdHlwZSB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1cyc7XG4gICAgaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbiAgICBpbXBvcnQgdHlwZSB7IEVkaXRhYmxlVGFzayB9IGZyb20gJy4vRWRpdGFibGVUYXNrJztcbiAgICBpbXBvcnQgeyBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5IH0gZnJvbSAnLi9FZGl0VGFza0hlbHBlcnMnO1xuXG4gICAgZXhwb3J0IGxldCB0YXNrOiBUYXNrO1xuICAgIGV4cG9ydCBsZXQgZWRpdGFibGVUYXNrOiBFZGl0YWJsZVRhc2s7XG4gICAgZXhwb3J0IGxldCBzdGF0dXNPcHRpb25zOiBTdGF0dXNbXTtcbiAgICBleHBvcnQgbGV0IGFjY2Vzc2tleTogc3RyaW5nIHwgbnVsbDtcblxuICAgIGxldCBzdGF0dXNTeW1ib2wgPSB0YXNrLnN0YXR1cy5zeW1ib2w7XG5cbiAgICBjb25zdCBfb25TdGF0dXNDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIFVzZSBzdGF0dXNTeW1ib2wgdG8gZmluZCB0aGUgc3RhdHVzIHRvIHNhdmUgdG8gZWRpdGFibGVUYXNrLnN0YXR1c1xuICAgICAgICBjb25zdCBzZWxlY3RlZFN0YXR1czogU3RhdHVzIHwgdW5kZWZpbmVkID0gc3RhdHVzT3B0aW9ucy5maW5kKChzKSA9PiBzLnN5bWJvbCA9PT0gc3RhdHVzU3ltYm9sKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suc3RhdHVzID0gc2VsZWN0ZWRTdGF0dXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgaW4gRWRpdFRhc2s6IGNhbm5vdCBmaW5kIHN0YXR1cyB3aXRoIHN5bWJvbCAke3N0YXR1c1N5bWJvbH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9idGFpbiBhIHRlbXBvcmFyeSB0YXNrIHdpdGggdGhlIG5ldyBzdGF0dXMgYXBwbGllZCwgdG8gc2VlIHdoYXQgd291bGRcbiAgICAgICAgLy8gaGFwcGVuIHRvIHRoZSBkb25lIGRhdGU6XG4gICAgICAgIGNvbnN0IHRhc2tXaXRoRWRpdGVkU3RhdHVzQXBwbGllZCA9IHRhc2suaGFuZGxlTmV3U3RhdHVzKHNlbGVjdGVkU3RhdHVzKS5wb3AoKTtcblxuICAgICAgICBpZiAodGFza1dpdGhFZGl0ZWRTdGF0dXNBcHBsaWVkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGRvbmVEYXRlIGZpZWxkLCBpbiBjYXNlIGNoYW5naW5nIHRoZSBzdGF0dXMgY2hhbmdlZCB0aGUgdmFsdWU6XG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suZG9uZURhdGUgPSB0YXNrV2l0aEVkaXRlZFN0YXR1c0FwcGxpZWQuZG9uZS5mb3JtYXRBc0RhdGUoKTtcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5jYW5jZWxsZWREYXRlID0gdGFza1dpdGhFZGl0ZWRTdGF0dXNBcHBsaWVkLmNhbmNlbGxlZC5mb3JtYXRBc0RhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG48L3NjcmlwdD5cblxuPGxhYmVsIGZvcj1cInN0YXR1c1wiPntAaHRtbCBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5KCdTdGF0dXMnLCBhY2Nlc3NrZXkpfTwvbGFiZWw+XG48IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hY2Nlc3NrZXkgLS0+XG48c2VsZWN0XG4gICAgYmluZDp2YWx1ZT17c3RhdHVzU3ltYm9sfVxuICAgIG9uOmNoYW5nZT17X29uU3RhdHVzQ2hhbmdlfVxuICAgIGlkPVwic3RhdHVzLXR5cGVcIlxuICAgIGNsYXNzPVwic3RhdHVzLWVkaXRvci1zdGF0dXMtc2VsZWN0b3JcIlxuICAgIHthY2Nlc3NrZXl9XG4+XG4gICAgeyNlYWNoIHN0YXR1c09wdGlvbnMgYXMgc3RhdHVzfVxuICAgICAgICA8b3B0aW9uIHZhbHVlPXtzdGF0dXMuc3ltYm9sfT57c3RhdHVzLm5hbWV9IFt7c3RhdHVzLnN5bWJvbH1dPC9vcHRpb24+XG4gICAgey9lYWNofVxuPC9zZWxlY3Q+XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBwYXJzZVR5cGVkRGF0ZUZvclNhdmluZywgcGFyc2VUeXBlZERhdGVvckRhdGVUaW1lRm9yU2F2aW5nUmVtaW5kZXIgfSBmcm9tICcuLi9saWIvRGF0ZVRvb2xzJztcbiAgICBpbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vVGFzay9SZWN1cnJlbmNlJztcbiAgICBpbXBvcnQgeyBUQVNLX0ZPUk1BVFMsIGdldFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbiAgICBpbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbiAgICBpbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXMnO1xuICAgIGltcG9ydCB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuICAgIGltcG9ydCB7IFRhc2tzRGF0ZSB9IGZyb20gJy4uL1NjcmlwdGluZy9UYXNrc0RhdGUnO1xuICAgIGltcG9ydCB7IGFkZERlcGVuZGVuY3lUb1BhcmVudCwgZW5zdXJlVGFza0hhc0lkLCBnZW5lcmF0ZVVuaXF1ZUlkLCByZW1vdmVEZXBlbmRlbmN5IH0gZnJvbSAnLi4vVGFzay9UYXNrRGVwZW5kZW5jeSc7XG4gICAgaW1wb3J0IHsgcmVwbGFjZVRhc2tXaXRoVGFza3MgfSBmcm9tICcuLi9PYnNpZGlhbi9GaWxlJztcbiAgICBpbXBvcnQgeyBQcmlvcml0eSB9IGZyb20gJy4uL1Rhc2svUHJpb3JpdHknO1xuICAgIGltcG9ydCBEYXRlRWRpdG9yIGZyb20gJy4vRGF0ZUVkaXRvci5zdmVsdGUnO1xuICAgIGltcG9ydCB0eXBlIHsgRWRpdGFibGVUYXNrIH0gZnJvbSAnLi9FZGl0YWJsZVRhc2snO1xuICAgIGltcG9ydCBEZXBlbmRlbmN5IGZyb20gJy4vRGVwZW5kZW5jeS5zdmVsdGUnO1xuICAgIGltcG9ydCB7IGxhYmVsQ29udGVudFdpdGhBY2Nlc3NLZXkgfSBmcm9tICcuL0VkaXRUYXNrSGVscGVycyc7XG4gICAgaW1wb3J0IFJlY3VycmVuY2VFZGl0b3IgZnJvbSAnLi9SZWN1cnJlbmNlRWRpdG9yLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFN0YXR1c0VkaXRvciBmcm9tICcuL1N0YXR1c0VkaXRvci5zdmVsdGUnO1xuXG4gICAgLy8gVGhlc2UgZXhwb3J0ZWQgdmFyaWFibGVzIGFyZSBwYXNzZWQgaW4gYXMgcHJvcHMgYnkgVGFza01vZGFsLm9uT3BlbigpOlxuICAgIGV4cG9ydCBsZXQgdGFzazogVGFzaztcbiAgICBleHBvcnQgbGV0IG9uU3VibWl0OiAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICAgIGV4cG9ydCBsZXQgc3RhdHVzT3B0aW9uczogU3RhdHVzW107XG4gICAgZXhwb3J0IGxldCBhbGxUYXNrczogVGFza1tdO1xuXG4gICAgY29uc3Qge1xuICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgIHByaW9yaXR5U3ltYm9scyxcbiAgICAgICAgc3RhcnREYXRlU3ltYm9sLFxuICAgICAgICBzY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICBkdWVEYXRlU3ltYm9sLFxuICAgICAgICByZW1pbmRlckRhdGVTeW1ib2wsXG4gICAgICAgIGNhbmNlbGxlZERhdGVTeW1ib2wsXG4gICAgICAgIGNyZWF0ZWREYXRlU3ltYm9sLFxuICAgICAgICBkb25lRGF0ZVN5bWJvbCxcbiAgICB9ID0gVEFTS19GT1JNQVRTLnRhc2tzUGx1Z2luRW1vamkudGFza1NlcmlhbGl6ZXIuc3ltYm9scztcblxuICAgIGxldCBkZXNjcmlwdGlvbklucHV0OiBIVE1MVGV4dEFyZWFFbGVtZW50O1xuXG4gICAgbGV0IGVkaXRhYmxlVGFzazogRWRpdGFibGVUYXNrID0ge1xuICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgc3RhdHVzOiBTdGF0dXMuVE9ETyxcbiAgICAgICAgcHJpb3JpdHk6ICdub25lJyxcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6ICcnLFxuICAgICAgICBjcmVhdGVkRGF0ZTogJycsXG4gICAgICAgIHN0YXJ0RGF0ZTogJycsXG4gICAgICAgIHNjaGVkdWxlZERhdGU6ICcnLFxuICAgICAgICBkdWVEYXRlOiAnJyxcbiAgICAgICAgcmVtaW5kZXJEYXRlOiAnJyxcbiAgICAgICAgZG9uZURhdGU6ICcnLFxuICAgICAgICBjYW5jZWxsZWREYXRlOiAnJyxcbiAgICAgICAgZm9yd2FyZE9ubHk6IHRydWUsXG4gICAgICAgIGJsb2NrZWRCeTogW10sXG4gICAgICAgIGJsb2NraW5nOiBbXSxcbiAgICB9O1xuXG4gICAgbGV0IGlzRGVzY3JpcHRpb25WYWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBsZXQgaXNDYW5jZWxsZWREYXRlVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBpc0NyZWF0ZWREYXRlVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBpc0RvbmVEYXRlVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBpc0R1ZURhdGVWYWxpZDogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IGlzUmVtaW5kZXJEYXRlVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBpc1NjaGVkdWxlZERhdGVWYWxpZDogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IGlzU3RhcnREYXRlVmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgbGV0IGlzUmVjdXJyZW5jZVZhbGlkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGxldCBhZGRHbG9iYWxGaWx0ZXJPblNhdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBsZXQgd2l0aEFjY2Vzc0tleXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBmb3JtSXNWYWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBsZXQgb3JpZ2luYWxCbG9ja2luZzogVGFza1tdID0gW107XG5cbiAgICBsZXQgbW91bnRDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3QgcHJpb3JpdHlPcHRpb25zOiB7XG4gICAgICAgIHZhbHVlOiB0eXBlb2YgZWRpdGFibGVUYXNrLnByaW9yaXR5O1xuICAgICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgICBzeW1ib2w6IHN0cmluZztcbiAgICAgICAgYWNjZXNzS2V5OiBzdHJpbmc7XG4gICAgICAgIGFjY2Vzc0tleUluZGV4OiBudW1iZXI7XG4gICAgfVtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICBsYWJlbDogJ0xvd2VzdCcsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5Mb3dlc3QsXG4gICAgICAgICAgICBhY2Nlc3NLZXk6ICdvJyxcbiAgICAgICAgICAgIGFjY2Vzc0tleUluZGV4OiAxLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogJ2xvdycsXG4gICAgICAgICAgICBsYWJlbDogJ0xvdycsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5Mb3csXG4gICAgICAgICAgICBhY2Nlc3NLZXk6ICdsJyxcbiAgICAgICAgICAgIGFjY2Vzc0tleUluZGV4OiAwLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogJ25vbmUnLFxuICAgICAgICAgICAgbGFiZWw6ICdOb3JtYWwnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuTm9uZSxcbiAgICAgICAgICAgIGFjY2Vzc0tleTogJ24nLFxuICAgICAgICAgICAgYWNjZXNzS2V5SW5kZXg6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiAnbWVkaXVtJyxcbiAgICAgICAgICAgIGxhYmVsOiAnTWVkaXVtJyxcbiAgICAgICAgICAgIHN5bWJvbDogcHJpb3JpdHlTeW1ib2xzLk1lZGl1bSxcbiAgICAgICAgICAgIGFjY2Vzc0tleTogJ20nLFxuICAgICAgICAgICAgYWNjZXNzS2V5SW5kZXg6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiAnaGlnaCcsXG4gICAgICAgICAgICBsYWJlbDogJ0hpZ2gnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuSGlnaCxcbiAgICAgICAgICAgIGFjY2Vzc0tleTogJ2gnLFxuICAgICAgICAgICAgYWNjZXNzS2V5SW5kZXg6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiAnaGlnaGVzdCcsXG4gICAgICAgICAgICBsYWJlbDogJ0hpZ2hlc3QnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuSGlnaGVzdCxcbiAgICAgICAgICAgIGFjY2Vzc0tleTogJ2knLFxuICAgICAgICAgICAgYWNjZXNzS2V5SW5kZXg6IDEsXG4gICAgICAgIH0sXG4gICAgXTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlcmlhbGlzZVRhc2tJZCh0YXNrOiBUYXNrKSB7XG4gICAgICAgIGlmICh0YXNrLmlkICE9PSAnJykgcmV0dXJuIHRhc2s7XG5cbiAgICAgICAgY29uc3QgdGFza3NXaXRoSWQgPSBhbGxUYXNrcy5maWx0ZXIoKHRhc2spID0+IHRhc2suaWQgIT09ICcnKTtcblxuICAgICAgICBjb25zdCB1cGRhdGVkVGFzayA9IGVuc3VyZVRhc2tIYXNJZChcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICB0YXNrc1dpdGhJZC5tYXAoKHRhc2spID0+IHRhc2suaWQpLFxuICAgICAgICApO1xuXG4gICAgICAgIGF3YWl0IHJlcGxhY2VUYXNrV2l0aFRhc2tzKHsgb3JpZ2luYWxUYXNrOiB0YXNrLCBuZXdUYXNrczogdXBkYXRlZFRhc2sgfSk7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUYXNrO1xuICAgIH1cblxuICAgICQ6IGFjY2Vzc2tleSA9IChrZXk6IHN0cmluZykgPT4gKHdpdGhBY2Nlc3NLZXlzID8ga2V5IDogbnVsbCk7XG4gICAgJDogZm9ybUlzVmFsaWQgPVxuICAgICAgICBpc0R1ZURhdGVWYWxpZCAmJlxuICAgICAgICBpc1JlbWluZGVyRGF0ZVZhbGlkICYmXG4gICAgICAgIGlzUmVjdXJyZW5jZVZhbGlkICYmXG4gICAgICAgIGlzU2NoZWR1bGVkRGF0ZVZhbGlkICYmXG4gICAgICAgIGlzU3RhcnREYXRlVmFsaWQgJiZcbiAgICAgICAgaXNEZXNjcmlwdGlvblZhbGlkICYmXG4gICAgICAgIGlzQ2FuY2VsbGVkRGF0ZVZhbGlkICYmXG4gICAgICAgIGlzQ3JlYXRlZERhdGVWYWxpZCAmJlxuICAgICAgICBpc0RvbmVEYXRlVmFsaWQ7XG4gICAgJDogaXNEZXNjcmlwdGlvblZhbGlkID0gZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9uLnRyaW0oKSAhPT0gJyc7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBwcm92aWRlQWNjZXNzS2V5cyB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgd2l0aEFjY2Vzc0tleXMgPSBwcm92aWRlQWNjZXNzS2V5cztcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5yZW1vdmVBc1dvcmRGcm9tKHRhc2suZGVzY3JpcHRpb24pO1xuICAgICAgICAvLyBJZiB3ZSdyZSBkaXNwbGF5aW5nIHRvIHRoZSB1c2VyIHRoZSBkZXNjcmlwdGlvbiB3aXRob3V0IHRoZSBnbG9iYWwgZmlsdGVyIChpLmUuIGl0IHdhcyByZW1vdmVkIGluIHRoZSBtZXRob2RcbiAgICAgICAgLy8gYWJvdmUpLCBvciBpZiB0aGUgZGVzY3JpcHRpb24gZGlkIG5vdCBpbmNsdWRlIGEgZ2xvYmFsIGZpbHRlciBpbiB0aGUgZmlyc3QgcGxhY2UsIHdlJ2xsIGFkZCB0aGUgZ2xvYmFsIGZpbHRlclxuICAgICAgICAvLyB3aGVuIHNhdmluZyB0aGUgdGFzay5cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9IHRhc2suZGVzY3JpcHRpb24gfHwgIUdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmluY2x1ZGVkSW4odGFzay5kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGFkZEdsb2JhbEZpbHRlck9uU2F2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaW9yaXR5OiB0eXBlb2YgZWRpdGFibGVUYXNrLnByaW9yaXR5ID0gJ25vbmUnO1xuICAgICAgICBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTG93ZXN0KSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdsb3dlc3QnO1xuICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5Lkxvdykge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnbG93JztcbiAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5NZWRpdW0pIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gJ21lZGl1bSc7XG4gICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuSGlnaCkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnaGlnaCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuSGlnaGVzdCkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnaGlnaGVzdCc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBibG9ja2VkQnk6IFRhc2tbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFza0lkIG9mIHRhc2suZGVwZW5kc09uKSB7XG4gICAgICAgICAgICBjb25zdCBkZXBUYXNrID0gYWxsVGFza3MuZmluZCgoY2FjaGVUYXNrKSA9PiBjYWNoZVRhc2suaWQgPT09IHRhc2tJZCk7XG5cbiAgICAgICAgICAgIGlmICghZGVwVGFzaykgY29udGludWU7XG5cbiAgICAgICAgICAgIGJsb2NrZWRCeS5wdXNoKGRlcFRhc2spO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWxCbG9ja2luZyA9IGFsbFRhc2tzLmZpbHRlcigoY2FjaGVUYXNrKSA9PiBjYWNoZVRhc2suZGVwZW5kc09uLmluY2x1ZGVzKHRhc2suaWQpKTtcblxuICAgICAgICBlZGl0YWJsZVRhc2sgPSB7XG4gICAgICAgICAgICAvLyBORVdfVEFTS19GSUVMRF9FRElUX1JFUVVJUkVEXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHN0YXR1czogdGFzay5zdGF0dXMsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlOiB0YXNrLnJlY3VycmVuY2UgPyB0YXNrLnJlY3VycmVuY2UudG9UZXh0KCkgOiAnJyxcbiAgICAgICAgICAgIGNyZWF0ZWREYXRlOiBuZXcgVGFza3NEYXRlKHRhc2suY3JlYXRlZERhdGUpLmZvcm1hdEFzRGF0ZSgpLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBuZXcgVGFza3NEYXRlKHRhc2suc3RhcnREYXRlKS5mb3JtYXRBc0RhdGUoKSxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5zY2hlZHVsZWREYXRlKS5mb3JtYXRBc0RhdGUoKSxcbiAgICAgICAgICAgIGR1ZURhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5kdWVEYXRlKS5mb3JtYXRBc0RhdGUoKSxcbiAgICAgICAgICAgIHJlbWluZGVyRGF0ZTogbmV3IFRhc2tzRGF0ZSh0YXNrLnJlbWluZGVyRGF0ZSkuZm9ybWF0QXNEYXRlQW5kVGltZU9yRGF0ZSgpLFxuICAgICAgICAgICAgZG9uZURhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5kb25lRGF0ZSkuZm9ybWF0QXNEYXRlKCksXG4gICAgICAgICAgICBjYW5jZWxsZWREYXRlOiBuZXcgVGFza3NEYXRlKHRhc2suY2FuY2VsbGVkRGF0ZSkuZm9ybWF0QXNEYXRlKCksXG4gICAgICAgICAgICBmb3J3YXJkT25seTogdHJ1ZSxcbiAgICAgICAgICAgIGJsb2NrZWRCeTogYmxvY2tlZEJ5LFxuICAgICAgICAgICAgYmxvY2tpbmc6IG9yaWdpbmFsQmxvY2tpbmcsXG4gICAgICAgIH07XG5cbiAgICAgICAgbW91bnRDb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbklucHV0LmZvY3VzKCk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IF9vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICBvblN1Ym1pdChbXSk7XG4gICAgfTtcblxuICAgIGNvbnN0IF9vbkRlc2NyaXB0aW9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGZvcm1Jc1ZhbGlkKSBfb25TdWJtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB0aGlzIGlzIGNhbGxlZCwgd2hlbiB0ZXh0IGlzIHBhc3RlZCBvciBkcm9wcGVkIGludG9cbiAgICAvLyB0aGUgZGVzY3JpcHRpb24gZmllbGQsIHRvIHJlbW92ZSBhbnkgbGluZWJyZWFrc1xuICAgIGNvbnN0IF9yZW1vdmVMaW5lYnJlYWtzRnJvbURlc2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAvLyB3cmFwcGVkIGludG8gYSB0aW1lciB0byBydW4gYWZ0ZXIgdGhlIHBhc3RlL2Ryb3AgZXZlbnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suZGVzY3JpcHRpb24gPSBlZGl0YWJsZVRhc2suZGVzY3JpcHRpb24ucmVwbGFjZSgvW1xcclxcbl0rL2csICcgJyk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBjb25zdCBfb25TdWJtaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9uLnRyaW0oKTtcbiAgICAgICAgaWYgKGFkZEdsb2JhbEZpbHRlck9uU2F2ZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5wcmVwZW5kVG8oZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcoZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSwgZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5KTtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yU2F2aW5nKGVkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlLCBlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHkpO1xuICAgICAgICBjb25zdCBkdWVEYXRlID0gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcoZWRpdGFibGVUYXNrLmR1ZURhdGUsIGVkaXRhYmxlVGFzay5mb3J3YXJkT25seSk7XG4gICAgICAgIGNvbnN0IHJlbWluZGVyRGF0ZSA9IHBhcnNlVHlwZWREYXRlb3JEYXRlVGltZUZvclNhdmluZ1JlbWluZGVyKFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnJlbWluZGVyRGF0ZSxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5mb3J3YXJkT25seSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY2FuY2VsbGVkRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yU2F2aW5nKGVkaXRhYmxlVGFzay5jYW5jZWxsZWREYXRlLCBlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHkpO1xuICAgICAgICBjb25zdCBjcmVhdGVkRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yU2F2aW5nKGVkaXRhYmxlVGFzay5jcmVhdGVkRGF0ZSwgZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5KTtcbiAgICAgICAgY29uc3QgZG9uZURhdGUgPSBwYXJzZVR5cGVkRGF0ZUZvclNhdmluZyhlZGl0YWJsZVRhc2suZG9uZURhdGUsIGVkaXRhYmxlVGFzay5mb3J3YXJkT25seSk7XG5cbiAgICAgICAgbGV0IHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSkge1xuICAgICAgICAgICAgcmVjdXJyZW5jZSA9IFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICAgICAgcmVtaW5kZXJEYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyc2VkUHJpb3JpdHk6IFByaW9yaXR5O1xuICAgICAgICBzd2l0Y2ggKGVkaXRhYmxlVGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSAnbG93ZXN0JzpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5Lkxvd2VzdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgIHBhcnNlZFByaW9yaXR5ID0gUHJpb3JpdHkuTWVkaXVtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlnaCc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlnaGVzdCc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoZXN0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5Lk5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYmxvY2tlZEJ5V2l0aElkcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgZGVwVGFzayBvZiBlZGl0YWJsZVRhc2suYmxvY2tlZEJ5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZXAgPSBhd2FpdCBzZXJpYWxpc2VUYXNrSWQoZGVwVGFzayk7XG4gICAgICAgICAgICBibG9ja2VkQnlXaXRoSWRzLnB1c2gobmV3RGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpZCA9IHRhc2suaWQ7XG4gICAgICAgIGxldCByZW1vdmVkQmxvY2tpbmc6IFRhc2tbXSA9IFtdO1xuICAgICAgICBsZXQgYWRkZWRCbG9ja2luZzogVGFza1tdID0gW107XG5cbiAgICAgICAgaWYgKGVkaXRhYmxlVGFzay5ibG9ja2luZy50b1N0cmluZygpICE9PSBvcmlnaW5hbEJsb2NraW5nLnRvU3RyaW5nKCkgfHwgZWRpdGFibGVUYXNrLmJsb2NraW5nLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRhc2suaWQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKGFsbFRhc2tzLmZpbHRlcigodGFzaykgPT4gdGFzay5pZCAhPT0gJycpLm1hcCgodGFzaykgPT4gdGFzay5pZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW1vdmVkQmxvY2tpbmcgPSBvcmlnaW5hbEJsb2NraW5nLmZpbHRlcigodGFzaykgPT4gIWVkaXRhYmxlVGFzay5ibG9ja2luZy5pbmNsdWRlcyh0YXNrKSk7XG5cbiAgICAgICAgICAgIGFkZGVkQmxvY2tpbmcgPSBlZGl0YWJsZVRhc2suYmxvY2tpbmcuZmlsdGVyKCh0YXNrKSA9PiAhb3JpZ2luYWxCbG9ja2luZy5pbmNsdWRlcyh0YXNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCBjcmVhdGUgYW4gdXBkYXRlZCB0YXNrLCB3aXRoIGFsbCBlZGl0cyBleGNlcHQgU3RhdHVzOlxuICAgICAgICBjb25zdCB1cGRhdGVkVGFzayA9IG5ldyBUYXNrKHtcbiAgICAgICAgICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICAgICAgICAgIC4uLnRhc2ssXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHN0YXR1czogdGFzay5zdGF0dXMsXG4gICAgICAgICAgICBwcmlvcml0eTogcGFyc2VkUHJpb3JpdHksXG4gICAgICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICByZW1pbmRlckRhdGUsXG4gICAgICAgICAgICBkb25lRGF0ZSxcbiAgICAgICAgICAgIGNyZWF0ZWREYXRlLFxuICAgICAgICAgICAgY2FuY2VsbGVkRGF0ZSxcbiAgICAgICAgICAgIGRlcGVuZHNPbjogYmxvY2tlZEJ5V2l0aElkcy5tYXAoKHRhc2spID0+IHRhc2suaWQpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgYmxvY2tpbmcgb2YgcmVtb3ZlZEJsb2NraW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSByZW1vdmVEZXBlbmRlbmN5KGJsb2NraW5nLCB1cGRhdGVkVGFzayk7XG4gICAgICAgICAgICBhd2FpdCByZXBsYWNlVGFza1dpdGhUYXNrcyh7IG9yaWdpbmFsVGFzazogYmxvY2tpbmcsIG5ld1Rhc2tzOiBuZXdQYXJlbnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGJsb2NraW5nIG9mIGFkZGVkQmxvY2tpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGFkZERlcGVuZGVuY3lUb1BhcmVudChibG9ja2luZywgdXBkYXRlZFRhc2spO1xuICAgICAgICAgICAgYXdhaXQgcmVwbGFjZVRhc2tXaXRoVGFza3MoeyBvcmlnaW5hbFRhc2s6IGJsb2NraW5nLCBuZXdUYXNrczogbmV3UGFyZW50IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiBhcHBseSB0aGUgbmV3IHN0YXR1cyB0byB0aGUgdXBkYXRlZCB0YXNrLCBpbiBjYXNlIGEgbmV3IHJlY3VycmVuY2VcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgY3JlYXRlZC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSAnZG9uZScgZGF0ZSwgdXNlIHRoYXQgZm9yIHRvZGF5J3MgZGF0ZSBmb3IgcmVjdXJyZW5jZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZG9uZURhdGUgPyBkb25lRGF0ZSA6IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgY29uc3QgbmV3VGFza3MgPSB1cGRhdGVkVGFzay5oYW5kbGVOZXdTdGF0dXNXaXRoUmVjdXJyZW5jZUluVXNlcnNPcmRlcihlZGl0YWJsZVRhc2suc3RhdHVzLCB0b2RheSk7XG4gICAgICAgIG9uU3VibWl0KG5ld1Rhc2tzKTtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjwhLS1cbkF2YWlsYWJpbGl0eSBvZiBhY2Nlc3Mga2V5czpcbi0gQTogU3RhcnRcbi0gQjogQmVmb3JlIHRoaXNcbi0gQzogQ3JlYXRlZFxuLSBEOiBEdWVcbi0gRTogQWZ0ZXIgdGhpc1xuLSBGOiBPbmx5IGZ1dHVyZSBkYXRlc1xuLSBHOlxuLSBIOiBIaWdoXG4tIEk6IEhpZ2hlc3Rcbi0gSjpcbi0gSzpcbi0gTDogTG93XG4tIE06IE1lZGl1bVxuLSBOOiBOb3JtYWxcbi0gTzogTG93ZXN0XG4tIFA6XG4tIFE6XG4tIFI6IFJlY3Vyc1xuLSBTOiBTY2hlZHVsZWRcbi0gVDogRGVzY3JpcHRpb25cbi0gVTogU3RhdHVzXG4tIFY6XG4tIFc6XG4tIFg6IERvbmVcbi0gWTpcbi0gWjpcbi0gLTogQ2FuY2VsbGVkXG4tLT5cblxuPGZvcm0gY2xhc3M9XCJ0YXNrcy1tb2RhbFwiIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17X29uU3VibWl0fT5cbiAgICA8IS0tIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRUQgLS0+XG5cbiAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICA8IS0tICBEZXNjcmlwdGlvbiAgLS0+XG4gICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJ0YXNrcy1tb2RhbC1kZXNjcmlwdGlvbi1zZWN0aW9uXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJkZXNjcmlwdGlvblwiPntAaHRtbCBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5KCdEZXNjcmlwdGlvbicsIGFjY2Vzc2tleSgndCcpKX08L2xhYmVsPlxuICAgICAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hY2Nlc3NrZXkgLS0+XG4gICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgYmluZDp0aGlzPXtkZXNjcmlwdGlvbklucHV0fVxuICAgICAgICAgICAgaWQ9XCJkZXNjcmlwdGlvblwiXG4gICAgICAgICAgICBjbGFzcz1cInRhc2tzLW1vZGFsLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVGFrZSBvdXQgdGhlIHRyYXNoXCJcbiAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KCd0Jyl9XG4gICAgICAgICAgICBvbjprZXlkb3duPXtfb25EZXNjcmlwdGlvbktleURvd259XG4gICAgICAgICAgICBvbjpwYXN0ZT17X3JlbW92ZUxpbmVicmVha3NGcm9tRGVzY3JpcHRpb259XG4gICAgICAgICAgICBvbjpkcm9wPXtfcmVtb3ZlTGluZWJyZWFrc0Zyb21EZXNjcmlwdGlvbn1cbiAgICAgICAgLz5cbiAgICA8L3NlY3Rpb24+XG5cbiAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICA8IS0tICBQcmlvcml0eSAgLS0+XG4gICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJ0YXNrcy1tb2RhbC1wcmlvcml0eS1zZWN0aW9uXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJwcmlvcml0eS17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVwiPlByaW9yaXR5PC9sYWJlbD5cbiAgICAgICAgeyNlYWNoIHByaW9yaXR5T3B0aW9ucyBhcyB7IHZhbHVlLCBsYWJlbCwgc3ltYm9sLCBhY2Nlc3NLZXksIGFjY2Vzc0tleUluZGV4IH19XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFzay1tb2RhbC1wcmlvcml0eS1vcHRpb24tY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICBpZD1cInByaW9yaXR5LXt2YWx1ZX1cIlxuICAgICAgICAgICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6Z3JvdXA9e2VkaXRhYmxlVGFzay5wcmlvcml0eX1cbiAgICAgICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoYWNjZXNzS2V5KX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJwcmlvcml0eS17dmFsdWV9XCI+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gVGhlc2UgaXMgbm8gbmVlZCB0byBleHRyYWN0IHRoaXMgYmVoYXZpb3VyIHRvIHNvbWV0aGluZyBsaWtlIGxhYmVsQ29udGVudFdpdGhBY2Nlc3NLZXkoKSxcbiAgICAgICAgICAgICAgICAgICAgc2luY2UgdGhpcyB3aG9sZSBzZWN0aW9uIHdpbGwganVzdCBnbyBpbiBhIHNlcGFyYXRlIFN2ZWx0ZSBjb21wb25lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgIHdpbGwgbm90IGJlIHJldXNlZCBlbHNld2hlcmUgbGlrZSBsYWJlbENvbnRlbnRXaXRoQWNjZXNzS2V5KCkuIC0tPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIHdpdGhBY2Nlc3NLZXlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e2xhYmVsLnN1YnN0cmluZygwLCBhY2Nlc3NLZXlJbmRleCl9PC9zcGFuPjxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+e2xhYmVsLnN1YnN0cmluZyhhY2Nlc3NLZXlJbmRleCwgYWNjZXNzS2V5SW5kZXggKyAxKX08L3NwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgID48c3Bhbj57bGFiZWwuc3Vic3RyaW5nKGFjY2Vzc0tleUluZGV4ICsgMSl9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57bGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICB7I2lmIHN5bWJvbCAmJiBzeW1ib2wuY2hhckNvZGVBdCgwKSA+PSAweDEwMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntzeW1ib2x9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9lYWNofVxuICAgIDwvc2VjdGlvbj5cblxuICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgIDwhLS0gIERhdGVzICAtLT5cbiAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICA8aHIgLz5cbiAgICA8c2VjdGlvbiBjbGFzcz1cInRhc2tzLW1vZGFsLWRhdGVzLXNlY3Rpb25cIj5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDwhLS0gIFJlY3VycmVuY2UgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPFJlY3VycmVuY2VFZGl0b3Ige2VkaXRhYmxlVGFza30gYmluZDppc1JlY3VycmVuY2VWYWxpZCBhY2Nlc3NrZXk9e2FjY2Vzc2tleSgncicpfSAvPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgRHVlIERhdGUgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPERhdGVFZGl0b3JcbiAgICAgICAgICAgIGlkPVwiZHVlXCJcbiAgICAgICAgICAgIGRhdGVTeW1ib2w9e2R1ZURhdGVTeW1ib2x9XG4gICAgICAgICAgICBiaW5kOmRhdGU9e2VkaXRhYmxlVGFzay5kdWVEYXRlfVxuICAgICAgICAgICAgYmluZDppc0RhdGVWYWxpZD17aXNEdWVEYXRlVmFsaWR9XG4gICAgICAgICAgICBmb3J3YXJkT25seT17ZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5fVxuICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoJ2QnKX1cbiAgICAgICAgLz5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgUmVtaW5kZXIgRGF0ZSAgLS0+XG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8RGF0ZUVkaXRvclxuICAgICAgICAgICAgaWQ9XCJyZW1pbmRlclwiXG4gICAgICAgICAgICBkYXRlU3ltYm9sPXtyZW1pbmRlckRhdGVTeW1ib2x9XG4gICAgICAgICAgICBiaW5kOmRhdGU9e2VkaXRhYmxlVGFzay5yZW1pbmRlckRhdGV9XG4gICAgICAgICAgICBiaW5kOmlzRGF0ZVZhbGlkPXtpc1JlbWluZGVyRGF0ZVZhbGlkfVxuICAgICAgICAgICAgZm9yd2FyZE9ubHk9e2VkaXRhYmxlVGFzay5mb3J3YXJkT25seX1cbiAgICAgICAgICAgIGFjY2Vzc2tleT17bnVsbH1cbiAgICAgICAgLz5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgU2NoZWR1bGVkIERhdGUgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPERhdGVFZGl0b3JcbiAgICAgICAgICAgIGlkPVwic2NoZWR1bGVkXCJcbiAgICAgICAgICAgIGRhdGVTeW1ib2w9e3NjaGVkdWxlZERhdGVTeW1ib2x9XG4gICAgICAgICAgICBiaW5kOmRhdGU9e2VkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlfVxuICAgICAgICAgICAgYmluZDppc0RhdGVWYWxpZD17aXNTY2hlZHVsZWREYXRlVmFsaWR9XG4gICAgICAgICAgICBmb3J3YXJkT25seT17ZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5fVxuICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoJ3MnKX1cbiAgICAgICAgLz5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgU3RhcnQgRGF0ZSAgLS0+XG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8RGF0ZUVkaXRvclxuICAgICAgICAgICAgaWQ9XCJzdGFydFwiXG4gICAgICAgICAgICBkYXRlU3ltYm9sPXtzdGFydERhdGVTeW1ib2x9XG4gICAgICAgICAgICBiaW5kOmRhdGU9e2VkaXRhYmxlVGFzay5zdGFydERhdGV9XG4gICAgICAgICAgICBiaW5kOmlzRGF0ZVZhbGlkPXtpc1N0YXJ0RGF0ZVZhbGlkfVxuICAgICAgICAgICAgZm9yd2FyZE9ubHk9e2VkaXRhYmxlVGFzay5mb3J3YXJkT25seX1cbiAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KCdhJyl9XG4gICAgICAgIC8+XG5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDwhLS0gIE9ubHkgZnV0dXJlIGRhdGVzICAtLT5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmdXR1cmUtZGF0ZXMtb25seVwiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImZvcndhcmRPbmx5XCI+e0BodG1sIGxhYmVsQ29udGVudFdpdGhBY2Nlc3NLZXkoJ09ubHkgZnV0dXJlIGRhdGVzOicsIGFjY2Vzc2tleSgnZicpKX08L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDpjaGVja2VkPXtlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHl9XG4gICAgICAgICAgICAgICAgaWQ9XCJmb3J3YXJkT25seVwiXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhc2stbGlzdC1pdGVtLWNoZWNrYm94IHRhc2tzLW1vZGFsLWNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleSgnZicpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuXG4gICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgPCEtLSAgRGVwZW5kZW5jaWVzICAtLT5cbiAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICA8aHIgLz5cbiAgICA8c2VjdGlvbiBjbGFzcz1cInRhc2tzLW1vZGFsLWRlcGVuZGVuY2llcy1zZWN0aW9uXCI+XG4gICAgICAgIHsjaWYgYWxsVGFza3MubGVuZ3RoID4gMCAmJiBtb3VudENvbXBsZXRlfVxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8IS0tICBCbG9ja2VkIEJ5IFRhc2tzICAtLT5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPERlcGVuZGVuY3lcbiAgICAgICAgICAgICAgICB0eXBlPVwiYmxvY2tlZEJ5XCJcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ9XCJCZWZvcmUgdGhpc1wiXG4gICAgICAgICAgICAgICAge3Rhc2t9XG4gICAgICAgICAgICAgICAge2VkaXRhYmxlVGFza31cbiAgICAgICAgICAgICAgICB7YWxsVGFza3N9XG4gICAgICAgICAgICAgICAge19vbkRlc2NyaXB0aW9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleSgnYicpfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VhcmNoIGZvciB0YXNrcyB0aGF0IHRoZSB0YXNrIGJlaW5nIGVkaXRlZCBkZXBlbmRzIG9uLi4uXCJcbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgQmxvY2tpbmcgVGFza3MgIC0tPlxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8RGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgIHR5cGU9XCJibG9ja2luZ1wiXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0PVwiQWZ0ZXIgdGhpc1wiXG4gICAgICAgICAgICAgICAge3Rhc2t9XG4gICAgICAgICAgICAgICAge2VkaXRhYmxlVGFza31cbiAgICAgICAgICAgICAgICB7YWxsVGFza3N9XG4gICAgICAgICAgICAgICAge19vbkRlc2NyaXB0aW9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleSgnZScpfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VhcmNoIGZvciB0YXNrcyB0aGF0IGRlcGVuZCBvbiB0aGlzIHRhc2sgYmVpbmcgZG9uZS4uLlwiXG4gICAgICAgICAgICAvPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8ZGl2PjxpPkJsb2NraW5nIGFuZCBibG9ja2VkIGJ5IGZpZWxkcyBhcmUgZGlzYWJsZWQgd2hlbiB2YXVsdCB0YXNrcyBpcyBlbXB0eTwvaT48L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICA8L3NlY3Rpb24+XG5cbiAgICA8aHIgLz5cbiAgICA8c2VjdGlvbiBjbGFzcz1cInRhc2tzLW1vZGFsLWRhdGVzLXNlY3Rpb25cIj5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDwhLS0gIFN0YXR1cyAgLS0+XG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8U3RhdHVzRWRpdG9yIHt0YXNrfSBiaW5kOmVkaXRhYmxlVGFzayB7c3RhdHVzT3B0aW9uc30gYWNjZXNza2V5PXthY2Nlc3NrZXkoJ3UnKX0gLz5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgQ3JlYXRlZCBEYXRlICAtLT5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDxEYXRlRWRpdG9yXG4gICAgICAgICAgICBpZD1cImNyZWF0ZWRcIlxuICAgICAgICAgICAgZGF0ZVN5bWJvbD17Y3JlYXRlZERhdGVTeW1ib2x9XG4gICAgICAgICAgICBiaW5kOmRhdGU9e2VkaXRhYmxlVGFzay5jcmVhdGVkRGF0ZX1cbiAgICAgICAgICAgIGJpbmQ6aXNEYXRlVmFsaWQ9e2lzQ3JlYXRlZERhdGVWYWxpZH1cbiAgICAgICAgICAgIGZvcndhcmRPbmx5PXtlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHl9XG4gICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleSgnYycpfVxuICAgICAgICAvPlxuXG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8IS0tICBEb25lIERhdGUgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPERhdGVFZGl0b3JcbiAgICAgICAgICAgIGlkPVwiZG9uZVwiXG4gICAgICAgICAgICBkYXRlU3ltYm9sPXtkb25lRGF0ZVN5bWJvbH1cbiAgICAgICAgICAgIGJpbmQ6ZGF0ZT17ZWRpdGFibGVUYXNrLmRvbmVEYXRlfVxuICAgICAgICAgICAgYmluZDppc0RhdGVWYWxpZD17aXNEb25lRGF0ZVZhbGlkfVxuICAgICAgICAgICAgZm9yd2FyZE9ubHk9e2VkaXRhYmxlVGFzay5mb3J3YXJkT25seX1cbiAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KCd4Jyl9XG4gICAgICAgIC8+XG5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDwhLS0gIENhbmNlbGxlZCBEYXRlICAtLT5cbiAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgIDxEYXRlRWRpdG9yXG4gICAgICAgICAgICBpZD1cImNhbmNlbGxlZFwiXG4gICAgICAgICAgICBkYXRlU3ltYm9sPXtjYW5jZWxsZWREYXRlU3ltYm9sfVxuICAgICAgICAgICAgYmluZDpkYXRlPXtlZGl0YWJsZVRhc2suY2FuY2VsbGVkRGF0ZX1cbiAgICAgICAgICAgIGJpbmQ6aXNEYXRlVmFsaWQ9e2lzQ2FuY2VsbGVkRGF0ZVZhbGlkfVxuICAgICAgICAgICAgZm9yd2FyZE9ubHk9e2VkaXRhYmxlVGFzay5mb3J3YXJkT25seX1cbiAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KCctJyl9XG4gICAgICAgIC8+XG4gICAgPC9zZWN0aW9uPlxuXG4gICAgPHNlY3Rpb24gY2xhc3M9XCJ0YXNrcy1tb2RhbC1idXR0b24tc2VjdGlvblwiPlxuICAgICAgICA8YnV0dG9uIGRpc2FibGVkPXshZm9ybUlzVmFsaWR9IHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cIm1vZC1jdGFcIj5BcHBseSA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9e19vbkNsb3NlfT5DYW5jZWw8L2J1dHRvbj5cbiAgICA8L3NlY3Rpb24+XG48L2Zvcm0+XG4iLCAiaW1wb3J0IHsgVGFza3NGaWxlIH0gZnJvbSAnLi4vU2NyaXB0aW5nL1Rhc2tzRmlsZSc7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXMnO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEYXRlRmFsbGJhY2sgfSBmcm9tICcuLi9UYXNrL0RhdGVGYWxsYmFjayc7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2svVGFza0xvY2F0aW9uJztcbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4uL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi9UYXNrL1ByaW9yaXR5JztcbmltcG9ydCB7IFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9UYXNrL1Rhc2tSZWd1bGFyRXhwcmVzc2lvbnMnO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0Q3JlYXRlZERhdGUoKSB7XG4gICAgY29uc3QgeyBzZXRDcmVhdGVkRGF0ZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gc2V0Q3JlYXRlZERhdGUgPyB3aW5kb3cubW9tZW50KCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDcmVhdGVkRGF0ZUZvclRhc2sodGFzazogVGFzaykge1xuICAgIGNvbnN0IHsgc2V0Q3JlYXRlZERhdGUgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICBpZiAoIXNldENyZWF0ZWREYXRlKSB7XG4gICAgICAgIC8vIEF1dG8tYWRkaW5nIG9mIENyZWF0ZWQgRGF0ZSBpcyBkaXNhYmxlZCBpbiBzZXR0aW5ncy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXNrLmNyZWF0ZWREYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSB0YXNrIGFscmVhZHkgaGFkIGEgY3JlYXRlZCBkYXRlLCBzbyBkb24ndCBjaGFuZ2UgaXQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZGVzY3JpcHRpb24gd2FzIGVtcHR5LCB0cmVhdCBpdCBhcyBuZXcgYW5kIGFkZCBhIGNyZWF0aW9uIGRhdGUuXG4gICAgY29uc3QgZGVzY3JpcHRpb25Jc0VtcHR5ID0gdGFzay5kZXNjcmlwdGlvbiA9PT0gJyc7XG5cbiAgICAvLyBJZiB0aGUgZ2xvYmFsIGZpbHRlciB3aWxsIGJlIGFkZGVkIHdoZW4gdGhlIHRhc2sgaXMgc2F2ZWQsIHRyZWF0IGl0IGFzIG5ldyBhbmQgYWRkIGEgY3JlYXRpb24gZGF0ZS5cbiAgICAvLyBTZWUgaXNzdWUgIzIxMTIuXG4gICAgY29uc3QgZ2xvYmFsRmlsdGVyRW5hYmxlZCA9ICFHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5pc0VtcHR5KCk7XG4gICAgY29uc3QgdGFza0RvZXNOb3RDb250YWluR2xvYmFsRmlsdGVyID0gIUdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmluY2x1ZGVkSW4odGFzay5kZXNjcmlwdGlvbik7XG4gICAgY29uc3QgbmVlZHNHbG9iYWxGaWx0ZXJUb0JlQWRkZWQgPSBnbG9iYWxGaWx0ZXJFbmFibGVkICYmIHRhc2tEb2VzTm90Q29udGFpbkdsb2JhbEZpbHRlcjtcblxuICAgIHJldHVybiBkZXNjcmlwdGlvbklzRW1wdHkgfHwgbmVlZHNHbG9iYWxGaWx0ZXJUb0JlQWRkZWQ7XG59XG5cbi8qKlxuICogUmVhZCBhbnkgbWFya2Rvd24gbGluZSBhbmQgdHJlYXQgaXQgYXMgYSB0YXNrLCBmb3IgdGhlIHB1cnBvc2VzIG9mXG4gKiB0aGUgJ0NyZWF0ZSBvciBlZGl0IHRhc2snIG1vZGFsLlxuICpcbiAqIFVubGlrZSB7QGxpbmsgVGFzay5mcm9tTGluZX0sIHdoaWNoIG9ubHkgcHJvY2Vzc2VzIHRhc2tzXG4gKiBhbHJlYWR5IHJlY29nbmlzZWQgYnkgdGhlIFRhc2tzIHBsdWdpbiwgdGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgYW55IGxpbmUuXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgdGhhdCBjb21tYW5kLCB3aGljaCBoYXMgYmVlbiBzZXBhcmF0ZWRcbiAqIG91dCB0byBhIGRpZmZlcmVudCBzb3VyY2UgZmlsZSBpbiBvcmRlciB0byBhbGxvdyBpdHMgbG9naWMgdG8gYmUgdGVzdGVkLlxuICpcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGxpbmUgdGhlIHVzZXIgaGFkIGNsaWNrZWQgb24gd2hlbiBydW5uaW5nICdDcmVhdGUgb3IgZWRpdCB0YXNrJyBjb21tYW5kXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIGxpbmVcbiAqL1xuZXhwb3J0IGNvbnN0IHRhc2tGcm9tTGluZSA9ICh7IGxpbmUsIHBhdGggfTogeyBsaW5lOiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KTogVGFzayA9PiB7XG4gICAgLy8gV2UgZ2V0IGFsbCBzaWduaWZpZXJzIGZyb20gdGhlIGxpbmUsIGV2ZW4gaWYgdGhlIEdsb2JhbCBGaWx0ZXIgaXMgbWlzc2luZy5cbiAgICAvLyBUaGlzIGhlbHBzIHVzZXJzIHdobywgZm9yIHNvbWUgcmVhc29uLCBoYXZlIGRhdGEgaW4gYSB0YXNrIGxpbmUgd2l0aG91dCB0aGUgR2xvYmFsIEZpbHRlci5cbiAgICBjb25zdCB0YXNrID0gVGFzay5wYXJzZVRhc2tTaWduaWZpZXJzKFxuICAgICAgICBsaW5lLFxuICAgICAgICBUYXNrTG9jYXRpb24uZnJvbVVua25vd25Qb3NpdGlvbihuZXcgVGFza3NGaWxlKHBhdGgpKSwgLy8gV2UgZG9uJ3QgbmVlZCBwcmVjaXNlIGxvY2F0aW9uIHRvIHRvZ2dsZSBpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgIERhdGVGYWxsYmFjay5mcm9tUGF0aChwYXRoKSwgLy8gc2V0IHRoZSBzY2hlZHVsZWQgZGF0ZSBmcm9tIHRoZSBmaWxlbmFtZSwgc28gaXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUgZGlhbG9nXG4gICAgKTtcblxuICAgIGNvbnN0IGNyZWF0ZWREYXRlID0gZ2V0RGVmYXVsdENyZWF0ZWREYXRlKCk7XG5cbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ3JlYXRlZERhdGVGb3JUYXNrKHRhc2spKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhc2soeyAuLi50YXNrLCBjcmVhdGVkRGF0ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgbm90IG9uIGEgbGluZSBvZiBhIHRhc2ssIHdlIHRha2Ugd2hhdCB3ZSBoYXZlLlxuICAgIGNvbnN0IG5vblRhc2tNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5ub25UYXNrUmVnZXgpO1xuICAgIGlmIChub25UYXNrTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnl0aGluZyBpbiB0aGUgcmVnZXggaXMgb3B0aW9uYWwuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tzOiBDYW5ub3QgY3JlYXRlIHRhc2sgb24gbGluZTonLCBsaW5lKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICAgICAgc3RhdHVzOiBTdGF0dXMuVE9ETyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGxvY2F0aW9uIGZpZWxkcyBleGNlcHQgZmlsZSB0byBlZGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24obmV3IFRhc2tzRmlsZShwYXRoKSksXG4gICAgICAgICAgICBpbmRlbnRhdGlvbjogJycsXG4gICAgICAgICAgICBsaXN0TWFya2VyOiAnLScsXG4gICAgICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuTm9uZSxcbiAgICAgICAgICAgIGNyZWF0ZWREYXRlLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgICAgICByZW1pbmRlckRhdGU6IG51bGwsXG4gICAgICAgICAgICBkb25lRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGNhbmNlbGxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICByZWN1cnJlbmNlOiBudWxsLFxuICAgICAgICAgICAgZGVwZW5kc09uOiBbXSxcbiAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgIGJsb2NrTGluazogJycsXG4gICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgIG9yaWdpbmFsTWFya2Rvd246ICcnLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRlbnRhdGlvbjogc3RyaW5nID0gbm9uVGFza01hdGNoWzFdO1xuICAgIGNvbnN0IGxpc3RNYXJrZXIgPSBub25UYXNrTWF0Y2hbMl0gPz8gJy0nO1xuICAgIGNvbnN0IHN0YXR1c1N0cmluZzogc3RyaW5nID0gbm9uVGFza01hdGNoWzRdID8/ICcgJztcbiAgICBjb25zdCBzdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLmJ5U3ltYm9sT3JDcmVhdGUoc3RhdHVzU3RyaW5nKTtcblxuICAgIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nID0gbm9uVGFza01hdGNoWzVdO1xuXG4gICAgY29uc3QgYmxvY2tMaW5rTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYmxvY2tMaW5rUmVnZXgpO1xuICAgIGNvbnN0IGJsb2NrTGluayA9IGJsb2NrTGlua01hdGNoICE9PSBudWxsID8gYmxvY2tMaW5rTWF0Y2hbMF0gOiAnJztcblxuICAgIGlmIChibG9ja0xpbmsgIT09ICcnKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmJsb2NrTGlua1JlZ2V4LCAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUYXNrKHtcbiAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBsb2NhdGlvbiBmaWVsZHMgZXhjZXB0IGZpbGUgdG8gZWRpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24obmV3IFRhc2tzRmlsZShwYXRoKSksXG4gICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICBsaXN0TWFya2VyLFxuICAgICAgICBibG9ja0xpbmssXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5Ob25lLFxuICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICBzY2hlZHVsZWREYXRlOiBudWxsLFxuICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICByZW1pbmRlckRhdGU6IG51bGwsXG4gICAgICAgIGRvbmVEYXRlOiBudWxsLFxuICAgICAgICBjYW5jZWxsZWREYXRlOiBudWxsLFxuICAgICAgICByZWN1cnJlbmNlOiBudWxsLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgb3JpZ2luYWxNYXJrZG93bjogJycsXG4gICAgICAgIC8vIE5vdCBuZWVkZWQgc2luY2UgdGhlIGluZmVycmVkIHN0YXR1cyBpcyBhbHdheXMgcmUtY29tcHV0ZWQgYWZ0ZXIgc3VibWl0dGluZy5cbiAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQ6IGZhbHNlLFxuICAgICAgICBpZDogJycsXG4gICAgICAgIGRlcGVuZHNPbjogW10sXG4gICAgfSk7XG59O1xuIiwgImltcG9ydCB7IEVkaXRvciwgdHlwZSBFZGl0b3JQb3NpdGlvbiwgdHlwZSBNYXJrZG93bkZpbGVJbmZvLCBNYXJrZG93blZpZXcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUYXNrc0ZpbGUgfSBmcm9tICcuLi9TY3JpcHRpbmcvVGFza3NGaWxlJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzUmVnaXN0cnknO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2svVGFza0xvY2F0aW9uJztcbmltcG9ydCB7IFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9UYXNrL1Rhc2tSZWd1bGFyRXhwcmVzc2lvbnMnO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlRG9uZSA9IChjaGVja2luZzogYm9vbGVhbiwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8pID0+IHtcbiAgICBpZiAoY2hlY2tpbmcpIHtcbiAgICAgICAgaWYgKCEodmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBtYXJrZG93biB2aWV3LCB0aGUgY29tbWFuZCBzaG91bGRuJ3QgYmUgc2hvd24uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgY29tbWFuZCBzaG91bGQgYWx3YXlzIHRyaWdnZXIgaW4gYSBtYXJrZG93biB2aWV3OlxuICAgICAgICAvLyAtIENvbnZlcnQgbGluZXMgdG8gbGlzdCBpdGVtcy5cbiAgICAgICAgLy8gLSBDb252ZXJ0IGxpc3QgaXRlbXMgdG8gdGFza3MuXG4gICAgICAgIC8vIC0gVG9nZ2xlIHRhc2tzJyBzdGF0dXMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghKHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpKSB7XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gZHVlIHRvIGNoZWNrIGFib3ZlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgYXJlIGNlcnRhaW4gd2UgYXJlIGluIHRoZSBlZGl0b3IgZHVlIHRvIHRoZSBjaGVjayBhYm92ZS5cbiAgICBjb25zdCBwYXRoID0gdmlldy5maWxlPy5wYXRoO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdDdXJzb3JQb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgY29uc3QgbGluZU51bWJlciA9IG9yaWdDdXJzb3JQb3MubGluZTtcbiAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cbiAgICBjb25zdCBpbnNlcnRpb24gPSB0b2dnbGVMaW5lKGxpbmUsIHBhdGgpO1xuICAgIGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIGluc2VydGlvbi50ZXh0KTtcblxuICAgIC8qIEN1cnNvciBwb3NpdGlvbnMgYXJlIDAtYmFzZWQgZm9yIGJvdGggXCJsaW5lXCIgYW5kIFwiY2hcIiBvZmZzZXRzLlxuICAgICAqIElmIFwiY2hcIiBvZmZzZXQgYmlnZ2VyIHRoYW4gdGhlIGxpbmUgbGVuZ3RoLCB3aWxsIGp1c3QgY29udGludWUgdG8gbmV4dCBsaW5lKHMpLlxuICAgICAqIEJ5IGRlZmF1bHQgXCJlZGl0b3Iuc2V0TGluZSgpXCIgYXBwZWFycyB0byBlaXRoZXIga2VlcCB0aGUgY3Vyc29yIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgaWYgaXQgaXMgYWxyZWFkeSB0aGVyZSxcbiAgICAgKiAuLi5vciBtb3ZlIGl0IHRvIHRoZSBiZWdpbm5pbmcgaWYgaXQgaXMgYW55d2hlcmUgZWxzZS4gTGljYXQgZXhwbGFpbmVkIHRoaXMgb24gRGlzY29yZCBhcyBcInN0aWNraW5nXCIgdG8gb25lIHNpZGUgb3IgYW5vdGhlci5cbiAgICAgKi9cbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKGdldE5ld0N1cnNvclBvc2l0aW9uKG9yaWdDdXJzb3JQb3MsIGluc2VydGlvbikpO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZWRpdG9yXG4gKlxuICogQHByb3BlcnR5IHRleHQgVGhlIHRleHQgdG8gaW5zZXJ0LiBNYXkgc3BhbiBvdmVyIG11bHRpcGxlIGxpbmVzLlxuICogQHByb3BlcnR5IFttb3ZlVG9dIEFuIHtAbGluayBFZGl0b3JQb3NpdGlvbn0gdGhhdCByZXByZXNlbnRzIGFuIGFic29sdXRlIHBvc2l0aW9uIHdpdGhpbiB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLnRleHR9IHRoYXQgaXNcbiAqICAgIHJlY29tbWVuZGVkIHRvIG1vdmUgdGhlIGN1cnNvciB0by5cbiAqXG4gKiBBbnkgY29tYmluYXRpb24gb2Ygc3ViZmllbGRzIChvciB0aGUgd2hvbGUge0BsaW5rIEVkaXRvclBvc2l0aW9ufSkgbWF5IGJlIG9taXR0ZWQuXG4gKiBNaXNzaW5nIGZpZWxkcyBzaG91bGQgcHJlc2VydmUgdGhlIGNvcnJlc3BvbmRpbmcgY3Vyc29yIHBvc2l0aW9uLiBUaGF0IGlzOlxuICogICAgICogQSB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLm1vdmVUb30gdGhhdCBpcyBgdW5kZWZpbmVkYCBkaXJlY3RzIHRoZSBjYWxsZXIgdG8ga2VlcCB0aGUgY3Vyc29yIHdoZXJlIGl0IGlzLlxuICogICAgICogQSB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLm1vdmVUb30gdGhhdCBpcyBge2xpbmU6IDF9YCBkaXJlY3RzIHRoZSBjYWxsZXIgb2YgdG8ganVtcCB0byB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLnRleHR9J3NcbiAqICAgICAgIHNlY29uZCBsaW5lIGJ1dCBzdGF5IGluIHRoZSBzYW1lIGNvbHVtbi5cbiAqXG4gKiBAaW50ZXJmYWNlIEVkaXRvckluc2VydGlvblxuICovXG5pbnRlcmZhY2UgRWRpdG9ySW5zZXJ0aW9uIHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgbW92ZVRvPzogUGFydGlhbDxFZGl0b3JQb3NpdGlvbj47XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVMaW5lID0gKGxpbmU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogRWRpdG9ySW5zZXJ0aW9uID0+IHtcbiAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgIC8vIFdoeSBhcmUgd2UgdXNpbmcgVGFzay5mcm9tTGluZSBpbnN0ZWFkIG9mIHRoZSBDYWNoZSBoZXJlP1xuICAgICAgICBsaW5lLFxuICAgICAgICB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbi5mcm9tVW5rbm93blBvc2l0aW9uKG5ldyBUYXNrc0ZpbGUocGF0aCkpLCAvLyBXZSBkb24ndCBuZWVkIHByZWNpc2UgbG9jYXRpb24gdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICB9KTtcbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRhc2sudG9nZ2xlV2l0aFJlY3VycmVuY2VJblVzZXJzT3JkZXIoKS5tYXAoKHQpID0+IHQudG9GaWxlTGluZVN0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZXMuam9pbignXFxuJyksIG1vdmVUbzogeyBsaW5lOiBsaW5lcy5sZW5ndGggLSAxIH0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgdGFzayBpcyBudWxsIHRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBvZjpcbiAgICAgICAgLy8gMS4gYSByZWd1bGFyIGNoZWNrbGlzdCBpdGVtXG4gICAgICAgIC8vIDIuIGEgbGlzdCBpdGVtXG4gICAgICAgIC8vIDMuIGEgc2ltcGxlIHRleHQgbGluZVxuICAgICAgICAvLyA0LiBhIHN0YW5kYXJkIHRhc2ssIGJ1dCB3aGljaCBkb2VzIG5vdCBjb250YWluIHRoZSBnbG9iYWwgZmlsdGVyLCB0byBiZSB0b2dnbGVkLCBidXQgbm8gZG9uZSBkYXRlIGFkZGVkLlxuXG4gICAgICAgIC8vIFRoZSB0YXNrIHJlZ2V4IHdpbGwgbWF0Y2ggY2hlY2tsaXN0IGl0ZW1zLlxuICAgICAgICBjb25zdCByZWdleE1hdGNoID0gbGluZS5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLnRhc2tSZWdleCk7XG4gICAgICAgIGlmIChyZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIHN0YXR1cyBvZiB0aGUgY2hlY2tsaXN0IGl0ZW0uXG4gICAgICAgICAgICBjb25zdCBzdGF0dXNTdHJpbmcgPSByZWdleE1hdGNoWzNdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5ieVN5bWJvbChzdGF0dXNTdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzU3RyaW5nID0gc3RhdHVzLm5leHRTdGF0dXNTeW1ib2w7XG4gICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgsIGAkMS0gWyR7bmV3U3RhdHVzU3RyaW5nfV0gJDRgKSB9O1xuICAgICAgICB9IGVsc2UgaWYgKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMubGlzdEl0ZW1SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBsaXN0IGl0ZW0gdG8gYSBjaGVja2xpc3QgaXRlbS5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0SXRlbVJlZ2V4LCAnJDEkMiBbIF0nKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRleHQsIG1vdmVUbzogeyBjaDogdGV4dC5sZW5ndGggfSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbGluZSB0byBhIGxpc3QgaXRlbS5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5pbmRlbnRhdGlvblJlZ2V4LCAnJDEtICcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGV4dCwgbW92ZVRvOiB7IGNoOiB0ZXh0Lmxlbmd0aCB9IH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBuZXcgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvciBzbyB0aGF0IGl0IGlzIHBvc2l0aW9uZWQgd2l0aGluIHRoZSBpbnNlcnRlZCB0ZXh0IGFzIHNwZWNpZmllZFxuICogYnkge0BsaW5rIGluc2VydGlvbn0ubW92ZVRvLlxuICpcbiAqIEBub3RlIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRleHQgd2FzIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUsIHdoaWNoIGlzXG4gKiAgICAgICB0aGUgY2FzZSB3aGVuIHVzZWQgdG9nZXRoZXIgd2l0aCB7QGxpbmsgRWRpdG9yLnNldExpbmV9LiBUaGlzIGlzIGEgc2ltcGxpZnlpbmcgYXNzdW1wdGlvbixcbiAqICAgICAgIGJ1dCBtYXkgcmVzdWx0IGluIGluY29ycmVjdCBiZWhhdmlvciBpZiB1c2VkIG91dHNpZGUgdGhlIGludGVuZGVkIGNvbnRleHQgKGkuZS4gbm90IGJ5IHtAbGluayB0b2dnbGVEb25lfSkuXG4gKlxuICogICAgICAgRXhhbXBsZTogQXNzdW1lIHtAbGluayBpbnNlcnRpb259PWB7dGV4dDogXCJIZWxsbyBXb3JsZFwiLCBtb3ZlVG86IHtsaW5lOiAwLCBjaDogNn19YCwgd2hlcmUge0BsaW5rIGluc2VydGlvbn0udGV4dFxuICogICAgICAgICAgICAgICAgaGFkIGJlZW4gYXBwZW5kZWQgdG8gYSBsaW5lIHdpdGggY29udGVudCBcIi0tLS0tLVwiOiAgYC0tLS0tLUhlbGxvIFdvcmxkYC5cbiAqICAgICAgICAgICAgICAgIFRoZSBjdXJzb3Igd2lsbCBiZSBvZmZzZXQgdG8gdGhlIGxlZnQgYnkgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBhbHJlYWR5IG9uIHRoZSBsaW5lLlxuICogICAgICAgICAgICAgICAgUmVzdWx0aW5nIGluIHRoZSBpbmNvcnJlY3QgcmVzdWx0IGAtLS0tLS18SGVsbG8gV29ybGRgIGluc3RlYWQgb2YgdGhlIGludGVuZGVkIGAtLS0tLS1IZWxsbyB8V29ybGRgLlxuICpcbiAqIEBwYXJhbSBzdGFydFBvcyBUaGUgc3RhcnRpbmcgY3Vyc29yIHBvc2l0aW9uXG4gKiBAcGFyYW0gaW5zZXJ0aW9uIFRoZSBpbnNlcnRlZCB0ZXh0IGFuZCBzdWdnZXN0ZWQgY3Vyc29yIHBvc2l0aW9uIHdpdGhpbiB0aGF0IHRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5ld0N1cnNvclBvc2l0aW9uID0gKHN0YXJ0UG9zOiBFZGl0b3JQb3NpdGlvbiwgaW5zZXJ0aW9uOiBFZGl0b3JJbnNlcnRpb24pOiBFZGl0b3JQb3NpdGlvbiA9PiB7XG4gICAgY29uc3QgZGVmYXVsdE1vdmVUbyA9IHsgbGluZTogMCwgY2g6IHN0YXJ0UG9zLmNoIH07XG4gICAgLy8gRmlsbCBpbiBhbnkgbWlzc2luZyBtb3ZlVG8gdmFsdWVzIHVzaW5nIHRoZSBkZWZhdWx0XG4gICAgY29uc3QgbW92ZVRvID0geyAuLi5kZWZhdWx0TW92ZVRvLCAuLi4oaW5zZXJ0aW9uLm1vdmVUbyA/PyB7fSkgfTtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgd2UncmUgbW92aW5nIHRoZSBjdXJzb3IgdG8sIHNvIHRoYXQgY3Vyc29yIGlzbid0IG1vdmVkIG91dCBvZiBib3VuZHNcbiAgICBjb25zdCBkZXN0aW5hdGlvbkxpbmVMZW5ndGggPSBpbnNlcnRpb24udGV4dC5zcGxpdCgnXFxuJylbbW92ZVRvLmxpbmVdLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHN0YXJ0UG9zLmxpbmUgKyBtb3ZlVG8ubGluZSxcbiAgICAgICAgY2g6IE1hdGgubWluKG1vdmVUby5jaCwgZGVzdGluYXRpb25MaW5lTGVuZ3RoKSxcbiAgICB9O1xufTtcbiIsICJpbXBvcnQgdHlwZSB7IEFwcCwgRWRpdG9yLCBNYXJrZG93bkZpbGVJbmZvLCBNYXJrZG93blZpZXcsIFZpZXcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSBUYXNrc1BsdWdpbiBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IGNyZWF0ZU9yRWRpdCB9IGZyb20gJy4vQ3JlYXRlT3JFZGl0JztcblxuaW1wb3J0IHsgdG9nZ2xlRG9uZSB9IGZyb20gJy4vVG9nZ2xlRG9uZSc7XG5cbmV4cG9ydCBjbGFzcyBDb21tYW5kcyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IFRhc2tzUGx1Z2luO1xuXG4gICAgcHJpdmF0ZSBnZXQgYXBwKCk6IEFwcCB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5hcHA7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoeyBwbHVnaW4gfTogeyBwbHVnaW46IFRhc2tzUGx1Z2luIH0pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cbiAgICAgICAgcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdlZGl0LXRhc2snLFxuICAgICAgICAgICAgbmFtZTogJ0NyZWF0ZSBvciBlZGl0IHRhc2snLFxuICAgICAgICAgICAgaWNvbjogJ3BlbmNpbCcsXG4gICAgICAgICAgICBlZGl0b3JDaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4sIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcgfCBNYXJrZG93bkZpbGVJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBOZWVkIHRvIGV4cGxvcmUgd2hhdCBoYXBwZW5zIGlmIGEgdGFza3MgY29kZSBibG9jayBpcyByZW5kZXJlZCBiZWZvcmUgdGhlIENhY2hlIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9yRWRpdChjaGVja2luZywgZWRpdG9yLCB2aWV3IGFzIFZpZXcsIHRoaXMuYXBwLCB0aGlzLnBsdWdpbi5nZXRUYXNrcygpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAndG9nZ2xlLWRvbmUnLFxuICAgICAgICAgICAgbmFtZTogJ1RvZ2dsZSB0YXNrIGRvbmUnLFxuICAgICAgICAgICAgaWNvbjogJ2NoZWNrLWluLWNpcmNsZScsXG4gICAgICAgICAgICBlZGl0b3JDaGVja0NhbGxiYWNrOiB0b2dnbGVEb25lLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBPcHRpb25zIHRvIGNvbnRyb2wge0BsaW5rIFF1ZXJ5UmVuZGVyZXJ9IGJlaGF2aW91ci5cbiAqXG4gKiBAc2VlIExheW91dE9wdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXJ5TGF5b3V0T3B0aW9ucyB7XG4gICAgaGlkZVBvc3Rwb25lQnV0dG9uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZVRhc2tDb3VudDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVCYWNrbGlua3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlRWRpdEJ1dHRvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVVcmdlbmN5OiBib29sZWFuID0gdHJ1ZTtcbiAgICBzaG9ydE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBleHBsYWluUXVlcnk6IGJvb2xlYW4gPSBmYWxzZTtcbn1cbiIsICIvKipcbiAqIEdldCB0aGUgdGV4dCB0byByZXBvcnQgYWZ0ZXIgYW4gZXhjZXB0aW9uIGlzIGNhdWdodC5cbiAqIEBwYXJhbSB3aGF0V2FzSGFwcGVuaW5nIC0gYSBkZXNjcmlwdGlvbiBvZiB3aGF0IHdhcyBoYXBwZW5pbmcgYXQgdGhlIHRpbWUsIHByZWZlcmFibHkgaW5jbHVkaW5nIGFueSB1c2VyIGlucHV0cy5cbiAqIEBwYXJhbSBleGNlcHRpb24gLSBvYmplY3QgdGhhdCB3YXMgY2F1Z2h0IGluIGEgdHJ5L2NhdGNoIGJsb2NrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JNZXNzYWdlRm9yRXhjZXB0aW9uKHdoYXRXYXNIYXBwZW5pbmc6IHN0cmluZywgZXhjZXB0aW9uOiBhbnkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBFcnJvcjogJHt3aGF0V2FzSGFwcGVuaW5nfS5cblRoZSBlcnJvciBtZXNzYWdlIHdhczpcbiAgICBgO1xuICAgIGxldCBkZXRhaWw6IHN0cmluZyA9ICcnO1xuICAgIGlmIChleGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBkZXRhaWwgKz0gZXhjZXB0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRldGFpbCArPSAnVW5rbm93biBlcnJvcic7XG4gICAgfVxuICAgIHJldHVybiBgJHtlcnJvck1lc3NhZ2V9XCIke2RldGFpbH1cImA7XG59XG4iLCAiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogTW9yZSBjb3JyZWN0IHR5cGVvZiBzdHJpbmcgaGFuZGxpbmcgYXJyYXlcbiAqIHdoaWNoIG5vcm1hbGx5IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG4gKi9cbmZ1bmN0aW9uIHR5cGVTdHIgKG9iaikge1xuICByZXR1cm4gaXNBcnJheShvYmopID8gJ2FycmF5JyA6IHR5cGVvZiBvYmo7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbn1cblxuLyoqXG4gKiBOdWxsIHNhZmUgd2F5IG9mIGNoZWNraW5nIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCxcbiAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eSAob2JqLCBwcm9wTmFtZSkge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG59XG5cbi8qKlxuICogU2FmZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0aGluZyBpcyBhIHByaW1pdGl2ZSBhbmRcbiAqIHdoZXRoZXIgaXQgaGFzIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eSAocHJpbWl0aXZlLCBwcm9wTmFtZSkge1xuICByZXR1cm4gKFxuICAgIHByaW1pdGl2ZSAhPSBudWxsXG4gICAgJiYgdHlwZW9mIHByaW1pdGl2ZSAhPT0gJ29iamVjdCdcbiAgICAmJiBwcmltaXRpdmUuaGFzT3duUHJvcGVydHlcbiAgICAmJiBwcmltaXRpdmUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICk7XG59XG5cbi8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01Nzdcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG52YXIgcmVnRXhwVGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbmZ1bmN0aW9uIHRlc3RSZWdFeHAgKHJlLCBzdHJpbmcpIHtcbiAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbn1cblxudmFyIG5vblNwYWNlUmUgPSAvXFxTLztcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gIHJldHVybiAhdGVzdFJlZ0V4cChub25TcGFjZVJlLCBzdHJpbmcpO1xufVxuXG52YXIgZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidgPVxcL10vZywgZnVuY3Rpb24gZnJvbUVudGl0eU1hcCAocykge1xuICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gIH0pO1xufVxuXG52YXIgd2hpdGVSZSA9IC9cXHMqLztcbnZhciBzcGFjZVJlID0gL1xccysvO1xudmFyIGVxdWFsc1JlID0gL1xccyo9LztcbnZhciBjdXJseVJlID0gL1xccypcXH0vO1xudmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbi8qKlxuICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAqIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLiBbIFwiPCVcIiwgXCIlPlwiIF0pLiBPZlxuICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICpcbiAqIEEgdG9rZW4gaXMgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCA0IGVsZW1lbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gKiBhbGwgdGV4dCB0aGF0IGFwcGVhcnMgb3V0c2lkZSBhIHN5bWJvbCB0aGlzIGVsZW1lbnQgaXMgXCJ0ZXh0XCIuXG4gKlxuICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICogd2hhdGV2ZXIgZWxzZSB3YXMgaW5zaWRlIHRoZSB0YWcgYmVzaWRlcyB0aGUgb3BlbmluZyBzeW1ib2wuIEZvciB0ZXh0IHRva2Vuc1xuICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gKlxuICogVGhlIHRoaXJkIGFuZCBmb3VydGggZWxlbWVudHMgb2YgdGhlIHRva2VuIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzLFxuICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICpcbiAqIFRva2VucyB0aGF0IGFyZSB0aGUgcm9vdCBub2RlIG9mIGEgc3VidHJlZSBjb250YWluIHR3byBtb3JlIGVsZW1lbnRzOiAxKSBhblxuICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gKlxuICogVG9rZW5zIGZvciBwYXJ0aWFscyBhbHNvIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGEgc3RyaW5nIHZhbHVlIG9mXG4gKiBpbmRlbmRhdGlvbiBwcmlvciB0byB0aGF0IHRhZyBhbmQgMikgdGhlIGluZGV4IG9mIHRoYXQgdGFnIG9uIHRoYXQgbGluZSAtXG4gKiBlZyBhIHZhbHVlIG9mIDIgaW5kaWNhdGVzIHRoZSBwYXJ0aWFsIGlzIHRoZSB0aGlyZCB0YWcgb24gdGhpcyBsaW5lLlxuICovXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlICh0ZW1wbGF0ZSwgdGFncykge1xuICBpZiAoIXRlbXBsYXRlKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIGxpbmVIYXNOb25TcGFjZSA9IGZhbHNlO1xuICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuICB2YXIgaW5kZW50YXRpb24gPSAnJzsgIC8vIFRyYWNrcyBpbmRlbnRhdGlvbiBmb3IgdGFncyB0aGF0IHVzZSBpdFxuICB2YXIgdGFnSW5kZXggPSAwOyAgICAgIC8vIFN0b3JlcyBhIGNvdW50IG9mIG51bWJlciBvZiB0YWdzIGVuY291bnRlcmVkIG9uIGEgbGluZVxuXG4gIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICBmdW5jdGlvbiBzdHJpcFNwYWNlICgpIHtcbiAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgd2hpbGUgKHNwYWNlcy5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BhY2VzID0gW107XG4gICAgfVxuXG4gICAgaGFzVGFnID0gZmFsc2U7XG4gICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gIGZ1bmN0aW9uIGNvbXBpbGVUYWdzICh0YWdzVG9Db21waWxlKSB7XG4gICAgaWYgKHR5cGVvZiB0YWdzVG9Db21waWxlID09PSAnc3RyaW5nJylcbiAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgaWYgKCFpc0FycmF5KHRhZ3NUb0NvbXBpbGUpIHx8IHRhZ3NUb0NvbXBpbGUubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzVG9Db21waWxlKTtcblxuICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgIGNsb3NpbmdUYWdSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIGNsb3NpbmdDdXJseVJlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCgnfScgKyB0YWdzVG9Db21waWxlWzFdKSk7XG4gIH1cblxuICBjb21waWxlVGFncyh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpO1xuXG4gIHZhciBzY2FubmVyID0gbmV3IFNjYW5uZXIodGVtcGxhdGUpO1xuXG4gIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICBzdGFydCA9IHNjYW5uZXIucG9zO1xuXG4gICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwob3BlbmluZ1RhZ1JlKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaHIpKSB7XG4gICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gY2hyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBsaW5lSGFzTm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2Vucy5wdXNoKFsgJ3RleHQnLCBjaHIsIHN0YXJ0LCBzdGFydCArIDEgXSk7XG4gICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBzdHJpcFNwYWNlKCk7XG4gICAgICAgICAgaW5kZW50YXRpb24gPSAnJztcbiAgICAgICAgICB0YWdJbmRleCA9IDA7XG4gICAgICAgICAgbGluZUhhc05vblNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgaWYgKCFzY2FubmVyLnNjYW4ob3BlbmluZ1RhZ1JlKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgIC8vIEdldCB0aGUgdGFnIHR5cGUuXG4gICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgIC8vIEdldCB0aGUgdGFnIHZhbHVlLlxuICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgc2Nhbm5lci5zY2FuKGVxdWFsc1JlKTtcbiAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ0N1cmx5UmUpO1xuICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIHR5cGUgPSAnJic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICB9XG5cbiAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICBpZiAodHlwZSA9PSAnPicpIHtcbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zLCBpbmRlbnRhdGlvbiwgdGFnSW5kZXgsIGxpbmVIYXNOb25TcGFjZSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgIH1cbiAgICB0YWdJbmRleCsrO1xuICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcvJykge1xuICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgaWYgKCFvcGVuU2VjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzdHJpcFNwYWNlKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBvcGVuIHNlY3Rpb25zIHdoZW4gd2UncmUgZG9uZS5cbiAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICBpZiAob3BlblNlY3Rpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgdmFyIHRva2VuLCBsYXN0VG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgbGFzdFRva2VuWzNdID0gdG9rZW5bM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gKiBhbGwgdG9rZW5zIHRoYXQgYXBwZWFyIGluIHRoYXQgc2VjdGlvbiBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbFxuICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICovXG5mdW5jdGlvbiBuZXN0VG9rZW5zICh0b2tlbnMpIHtcbiAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbGxlY3RvciA9IHRva2VuWzRdID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcbiAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICBjb2xsZWN0b3IgPSBzZWN0aW9ucy5sZW5ndGggPiAwID8gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV1bNF0gOiBuZXN0ZWRUb2tlbnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXN0ZWRUb2tlbnM7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgc3RyaW5nIHNjYW5uZXIgdGhhdCBpcyB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBwYXJzZXIgdG8gZmluZFxuICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIFNjYW5uZXIgKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgdGhpcy50YWlsID0gc3RyaW5nO1xuICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhaWwgaXMgZW1wdHkgKGVuZCBvZiBzdHJpbmcpLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICByZXR1cm4gdGhpcy50YWlsID09PSAnJztcbn07XG5cbi8qKlxuICogVHJpZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5zY2FuID0gZnVuY3Rpb24gc2NhbiAocmUpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgIHJldHVybiAnJztcblxuICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblxuICByZXR1cm4gc3RyaW5nO1xufTtcblxuLyoqXG4gKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAqL1xuU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgc3dpdGNoIChpbmRleCkge1xuICAgIGNhc2UgLTE6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgIHRoaXMudGFpbCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOlxuICAgICAgbWF0Y2ggPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhpbmRleCk7XG4gIH1cblxuICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVuZGVyaW5nIGNvbnRleHQgYnkgd3JhcHBpbmcgYSB2aWV3IG9iamVjdCBhbmRcbiAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gQ29udGV4dCAodmlldywgcGFyZW50Q29udGV4dCkge1xuICB0aGlzLnZpZXcgPSB2aWV3O1xuICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICB0aGlzLnBhcmVudCA9IHBhcmVudENvbnRleHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb250ZXh0IHVzaW5nIHRoZSBnaXZlbiB2aWV3IHdpdGggdGhpcyBjb250ZXh0XG4gKiBhcyB0aGUgcGFyZW50LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmlldykge1xuICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgdmFyIHZhbHVlO1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGRvdCBub3Rpb24gcGF0aCBpbiBgbmFtZWAsIHdlIGRlc2NlbmQgdGhyb3VnaCB0aGVcbiAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGJlIGNlcnRhaW4gdGhhdCB0aGUgbG9va3VwIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsIHdlIGhhdmUgdG9cbiAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgZG90IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGNvbnNpZGVyIHRoZSBsb29rdXBcbiAgICAgICAgICogdG8gYmUgc3VjY2Vzc2Z1bCBldmVuIGlmIHRoZSBsYXN0IFwib2JqZWN0XCIgaW4gdGhlIHBhdGggaXNcbiAgICAgICAgICogbm90IGFjdHVhbGx5IGFuIG9iamVjdCBidXQgYSBwcmltaXRpdmUgKGUuZy4sIGEgc3RyaW5nLCBvciBhblxuICAgICAgICAgKiBpbnRlZ2VyKSwgYmVjYXVzZSBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGFjY2VzcyBhIHByb3BlcnR5XG4gICAgICAgICAqIG9mIGFuIGF1dG9ib3hlZCBwcmltaXRpdmUsIHN1Y2ggYXMgdGhlIGxlbmd0aCBvZiBhIHN0cmluZy5cbiAgICAgICAgICoqL1xuICAgICAgICB3aGlsZSAoaW50ZXJtZWRpYXRlVmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIGxvb2t1cEhpdCA9IChcbiAgICAgICAgICAgICAgaGFzUHJvcGVydHkoaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzW2luZGV4XSlcbiAgICAgICAgICAgICAgfHwgcHJpbWl0aXZlSGFzT3duUHJvcGVydHkoaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzW2luZGV4XSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGludGVybWVkaWF0ZVZhbHVlW25hbWVzW2luZGV4KytdXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBjb250ZXh0LnZpZXdbbmFtZV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgY2hlY2tpbmcgYWdhaW5zdCBgaGFzUHJvcGVydHlgLCB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgIGlmXG4gICAgICAgICAqIGBjb250ZXh0LnZpZXdgIGlzIG5vdCBhbiBvYmplY3QuIERlbGliZXJhdGVseSBvbWl0dGluZyB0aGUgY2hlY2tcbiAgICAgICAgICogYWdhaW5zdCBgcHJpbWl0aXZlSGFzT3duUHJvcGVydHlgIGlmIGRvdCBub3RhdGlvbiBpcyBub3QgdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2lkZXIgdGhpcyBleGFtcGxlOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogTXVzdGFjaGUucmVuZGVyKFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIHt7I2xlbmd0aH19e3tsZW5ndGh9fXt7L2xlbmd0aH19LlwiLCB7bGVuZ3RoOiBcIjEwMCB5YXJkc1wifSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHdlIHdlcmUgdG8gY2hlY2sgYWxzbyBhZ2FpbnN0IGBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eWAsIGFzIHdlIGRvXG4gICAgICAgICAqIGluIHRoZSBkb3Qgbm90YXRpb24gY2FzZSwgdGhlbiByZW5kZXIgY2FsbCB3b3VsZCByZXR1cm46XG4gICAgICAgICAqXG4gICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDkuXCJcbiAgICAgICAgICpcbiAgICAgICAgICogcmF0aGVyIHRoYW4gdGhlIGV4cGVjdGVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiBcIlRoZSBsZW5ndGggb2YgYSBmb290YmFsbCBmaWVsZCBpcyAxMDAgeWFyZHMuXCJcbiAgICAgICAgICoqL1xuICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9va3VwSGl0KSB7XG4gICAgICAgIHZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICogc3RyaW5nLCBnaXZlbiBhIGNvbnRleHQuIEl0IGFsc28gbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGVtcGxhdGVzIHRvXG4gKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAqL1xuZnVuY3Rpb24gV3JpdGVyICgpIHtcbiAgdGhpcy50ZW1wbGF0ZUNhY2hlID0ge1xuICAgIF9jYWNoZToge30sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX2NhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0IChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy50ZW1wbGF0ZUNhY2hlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMudGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYHRhZ3NgIG9yXG4gKiBgbXVzdGFjaGUudGFnc2AgaWYgYHRhZ3NgIGlzIG9taXR0ZWQsICBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgdG9rZW5zXG4gKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICB2YXIgY2FjaGUgPSB0aGlzLnRlbXBsYXRlQ2FjaGU7XG4gIHZhciBjYWNoZUtleSA9IHRlbXBsYXRlICsgJzonICsgKHRhZ3MgfHwgbXVzdGFjaGUudGFncykuam9pbignOicpO1xuICB2YXIgaXNDYWNoZUVuYWJsZWQgPSB0eXBlb2YgY2FjaGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgdG9rZW5zID0gaXNDYWNoZUVuYWJsZWQgPyBjYWNoZS5nZXQoY2FjaGVLZXkpIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0b2tlbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgdG9rZW5zID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG4gICAgaXNDYWNoZUVuYWJsZWQgJiYgY2FjaGUuc2V0KGNhY2hlS2V5LCB0b2tlbnMpO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG4vKipcbiAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICogdGhlIGdpdmVuIGB2aWV3YC5cbiAqXG4gKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAqIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbG9hZCBwYXJ0aWFsIHRlbXBsYXRlcyBvbiB0aGUgZmx5XG4gKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAqXG4gKiBJZiB0aGUgb3B0aW9uYWwgYGNvbmZpZ2AgYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSwgdGhlbiBpdCBzaG91bGQgYmUgYW5cbiAqIG9iamVjdCB3aXRoIGEgYHRhZ3NgIGF0dHJpYnV0ZSBvciBhbiBgZXNjYXBlYCBhdHRyaWJ1dGUgb3IgYm90aC5cbiAqIElmIGFuIGFycmF5IGlzIHBhc3NlZCwgdGhlbiBpdCB3aWxsIGJlIGludGVycHJldGVkIHRoZSBzYW1lIHdheSBhc1xuICogYSBgdGFnc2AgYXR0cmlidXRlIG9uIGEgYGNvbmZpZ2Agb2JqZWN0LlxuICpcbiAqIFRoZSBgdGFnc2AgYXR0cmlidXRlIG9mIGEgYGNvbmZpZ2Agb2JqZWN0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d29cbiAqIHN0cmluZyB2YWx1ZXM6IHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy5cbiAqIFsgXCI8JVwiLCBcIiU+XCIgXSkuIFRoZSBkZWZhdWx0IGlzIHRvIG11c3RhY2hlLnRhZ3MuXG4gKlxuICogVGhlIGBlc2NhcGVgIGF0dHJpYnV0ZSBvZiBhIGBjb25maWdgIG9iamVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gd2hpY2hcbiAqIGFjY2VwdHMgYSBzdHJpbmcgYXMgaW5wdXQgYW5kIG91dHB1dHMgYSBzYWZlbHkgZXNjYXBlZCBzdHJpbmcuXG4gKiBJZiBhbiBgZXNjYXBlYCBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gYW4gSFRNTC1zYWZlIHN0cmluZ1xuICogZXNjYXBpbmcgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgZGVmYXVsdC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIHZhciB0YWdzID0gdGhpcy5nZXRDb25maWdUYWdzKGNvbmZpZyk7XG4gIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbiAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcsIHVuZGVmaW5lZCk7XG4gIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSwgY29uZmlnKTtcbn07XG5cbi8qKlxuICogTG93LWxldmVsIG1ldGhvZCB0aGF0IHJlbmRlcnMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIHVzaW5nXG4gKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICpcbiAqIE5vdGU6IFRoZSBgb3JpZ2luYWxUZW1wbGF0ZWAgaXMgb25seSBldmVyIHVzZWQgdG8gZXh0cmFjdCB0aGUgcG9ydGlvblxuICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAqIGJlIG9taXR0ZWQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gIHZhciB0b2tlbiwgc3ltYm9sLCB2YWx1ZTtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICduYW1lJykgdmFsdWUgPSB0aGlzLmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICd0ZXh0JykgdmFsdWUgPSB0aGlzLnJhd1ZhbHVlKHRva2VuKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24gKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1ZmZlciA9ICcnO1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlbmRlciBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXIodGVtcGxhdGUsIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGogPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaiA8IHZhbHVlTGVuZ3RoOyArK2opIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWUpLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gIC8vIFVzZSBKYXZhU2NyaXB0J3MgZGVmaW5pdGlvbiBvZiBmYWxzeS4gSW5jbHVkZSBlbXB0eSBhcnJheXMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuaW5kZW50UGFydGlhbCA9IGZ1bmN0aW9uIGluZGVudFBhcnRpYWwgKHBhcnRpYWwsIGluZGVudGF0aW9uLCBsaW5lSGFzTm9uU3BhY2UpIHtcbiAgdmFyIGZpbHRlcmVkSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbi5yZXBsYWNlKC9bXiBcXHRdL2csICcnKTtcbiAgdmFyIHBhcnRpYWxCeU5sID0gcGFydGlhbC5zcGxpdCgnXFxuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGlhbEJ5TmwubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydGlhbEJ5TmxbaV0ubGVuZ3RoICYmIChpID4gMCB8fCAhbGluZUhhc05vblNwYWNlKSkge1xuICAgICAgcGFydGlhbEJ5TmxbaV0gPSBmaWx0ZXJlZEluZGVudGF0aW9uICsgcGFydGlhbEJ5TmxbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0aWFsQnlObC5qb2luKCdcXG4nKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIGlmICghcGFydGlhbHMpIHJldHVybjtcbiAgdmFyIHRhZ3MgPSB0aGlzLmdldENvbmZpZ1RhZ3MoY29uZmlnKTtcblxuICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB2YXIgbGluZUhhc05vblNwYWNlID0gdG9rZW5bNl07XG4gICAgdmFyIHRhZ0luZGV4ID0gdG9rZW5bNV07XG4gICAgdmFyIGluZGVudGF0aW9uID0gdG9rZW5bNF07XG4gICAgdmFyIGluZGVudGVkVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGFnSW5kZXggPT0gMCAmJiBpbmRlbnRhdGlvbikge1xuICAgICAgaW5kZW50ZWRWYWx1ZSA9IHRoaXMuaW5kZW50UGFydGlhbCh2YWx1ZSwgaW5kZW50YXRpb24sIGxpbmVIYXNOb25TcGFjZSk7XG4gICAgfVxuICAgIHZhciB0b2tlbnMgPSB0aGlzLnBhcnNlKGluZGVudGVkVmFsdWUsIHRhZ3MpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnRlZFZhbHVlLCBjb25maWcpO1xuICB9XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0LCBjb25maWcpIHtcbiAgdmFyIGVzY2FwZSA9IHRoaXMuZ2V0Q29uZmlnRXNjYXBlKGNvbmZpZykgfHwgbXVzdGFjaGUuZXNjYXBlO1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBlc2NhcGUgPT09IG11c3RhY2hlLmVzY2FwZSkgPyBTdHJpbmcodmFsdWUpIDogZXNjYXBlKHZhbHVlKTtcbn07XG5cbldyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5nZXRDb25maWdUYWdzID0gZnVuY3Rpb24gZ2V0Q29uZmlnVGFncyAoY29uZmlnKSB7XG4gIGlmIChpc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIGVsc2UgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBjb25maWcudGFncztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmdldENvbmZpZ0VzY2FwZSA9IGZ1bmN0aW9uIGdldENvbmZpZ0VzY2FwZSAoY29uZmlnKSB7XG4gIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoY29uZmlnKSkge1xuICAgIHJldHVybiBjb25maWcuZXNjYXBlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbnZhciBtdXN0YWNoZSA9IHtcbiAgbmFtZTogJ211c3RhY2hlLmpzJyxcbiAgdmVyc2lvbjogJzQuMi4wJyxcbiAgdGFnczogWyAne3snLCAnfX0nIF0sXG4gIGNsZWFyQ2FjaGU6IHVuZGVmaW5lZCxcbiAgZXNjYXBlOiB1bmRlZmluZWQsXG4gIHBhcnNlOiB1bmRlZmluZWQsXG4gIHJlbmRlcjogdW5kZWZpbmVkLFxuICBTY2FubmVyOiB1bmRlZmluZWQsXG4gIENvbnRleHQ6IHVuZGVmaW5lZCxcbiAgV3JpdGVyOiB1bmRlZmluZWQsXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGNhY2hpbmcgc3RyYXRlZ3ksIGJ5IHByb3ZpZGluZyBhblxuICAgKiBvYmplY3Qgd2l0aCBzZXQsIGdldCBhbmQgY2xlYXIgbWV0aG9kcy4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGRpc2FibGVcbiAgICogdGhlIGNhY2hlIGJ5IHNldHRpbmcgaXQgdG8gdGhlIGxpdGVyYWwgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBzZXQgdGVtcGxhdGVDYWNoZSAoY2FjaGUpIHtcbiAgICBkZWZhdWx0V3JpdGVyLnRlbXBsYXRlQ2FjaGUgPSBjYWNoZTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIGRlZmF1bHQgb3Igb3ZlcnJpZGRlbiBjYWNoaW5nIG9iamVjdCBmcm9tIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIGdldCB0ZW1wbGF0ZUNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci50ZW1wbGF0ZUNhY2hlO1xuICB9XG59O1xuXG4vLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG52YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICovXG5tdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICogcGFyc2UgdGVtcGxhdGVzIG9uIHRoZSBmbHkgYXMgdGhleSBhcmUgcmVuZGVyZWQuXG4gKi9cbm11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYHRlbXBsYXRlYCB3aXRoIHRoZSBnaXZlbiBgdmlld2AsIGBwYXJ0aWFsc2AsIGFuZCBgY29uZmlnYFxuICogdXNpbmcgdGhlIGRlZmF1bHQgd3JpdGVyLlxuICovXG5tdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKSB7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSEgVGVtcGxhdGUgc2hvdWxkIGJlIGEgXCJzdHJpbmdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIGNvbmZpZyk7XG59O1xuXG4vLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbm11c3RhY2hlLmVzY2FwZSA9IGVzY2FwZUh0bWw7XG5cbi8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbm11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xubXVzdGFjaGUuQ29udGV4dCA9IENvbnRleHQ7XG5tdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbmV4cG9ydCBkZWZhdWx0IG11c3RhY2hlO1xuIiwgImltcG9ydCBNdXN0YWNoZSBmcm9tICdtdXN0YWNoZSc7XG5pbXBvcnQgcHJveHlEYXRhIGZyb20gJ211c3RhY2hlLXZhbGlkYXRvcic7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG5cbi8qKlxuICogRXhwYW5kIGFueSBwbGFjZWhvbGRlciBzdHJpbmdzIC0ge3suLi4ufX0gLSBpbiB0aGUgZ2l2ZW4gdGVtcGxhdGUsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgaW1wbGVtZW50YXRpb24gaXMgY3VycmVudGx5IHByb3ZpZGVkIGJ5OiBbbXVzdGFjaGUuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzKS5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGUgLSBBIHRlbXBsYXRlIHN0cmluZywgdHlwaWNhbGx5IHdpdGggcGxhY2Vob2xkZXJzIHN1Y2ggYXMge3txdWVyeS50YXNrLmZvbGRlcn19XG4gKiBAcGFyYW0gdmlldyAtIFRoZSBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAdGhyb3dzIEVycm9yXG4gKlxuICogICAgICBCeSB1c2luZyBtdXN0YWNoZS12YWxpZGF0b3IncyBwcm94eURhdGEsIHdlIGVuc3VyZSB0aGF0IGFueSBhY2Nlc3NlcyBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGFyZVxuICogICAgICBub3QgaW4gdGhlIHZpZXcsIHdlIGVuc3VyZSB0aGF0IGVycm9ycyBhcmUgZGV0ZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiAgICAgIFRoZSBmaXJzdCB1bmtub3duIHBsYWNlaG9sZGVyIGlzIGluY2x1ZGVkIGluIEVycm9yLm1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRQbGFjZWhvbGRlcnModGVtcGxhdGU6IHN0cmluZywgdmlldzogYW55KTogc3RyaW5nIHtcbiAgICAvLyBUdXJuIG9mZiBIVE1MIGVzY2FwaW5nIG9mIHRoaW5ncyBsaWtlICcvJyBpbiBmaWxlIHBhdGhzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzI3ZhcmlhYmxlc1xuICAgIE11c3RhY2hlLmVzY2FwZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gTXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCBwcm94eURhdGEodmlldykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZXJlIHdhcyBhbiBlcnJvciBleHBhbmRpbmcgb25lIG9yIG1vcmUgcGxhY2Vob2xkZXJzLlxuXG5UaGUgZXJyb3IgbWVzc2FnZSB3YXM6XG4gICAgJHtlcnJvci5tZXNzYWdlLnJlcGxhY2UoLyA+IC9nLCAnLicpLnJlcGxhY2UoJ01pc3NpbmcgTXVzdGFjaGUgZGF0YSBwcm9wZXJ0eScsICdVbmtub3duIHByb3BlcnR5Jyl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnVW5rbm93biBlcnJvciBleHBhbmRpbmcgcGxhY2Vob2xkZXJzLic7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSBgXG5cblRoZSBwcm9ibGVtIGlzIGluOlxuICAgICR7dGVtcGxhdGV9YDtcbiAgICAgICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBUYXNrc0ZpbGUgfSBmcm9tICcuL1Rhc2tzRmlsZSc7XG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgcGFydCBvZiB0aGUgaW1wbGVtZW50YXRpb24gb2YgcGxhY2Vob2xkZXJzIGFuZCBzY3JpcHRpbmcuXG4gKlxuICogLSBVc2Uge0BsaW5rIG1ha2VRdWVyeUNvbnRleHR9IHRvIG1ha2UgYSB7QGxpbmsgUXVlcnlDb250ZXh0fS5cbiAqIC0gT3IgbW9yZSBjb21tb25seSwgaWYgeW91IGhhdmUgYSB7QGxpbmsgU2VhcmNoSW5mb30sIHVzZSB7QGxpbmsgU2VhcmNoSW5mby5xdWVyeUNvbnRleHR9XG4gKlxuICogUXVlcnlDb250ZXh0IGlzIGEgJ3ZpZXcnIHRvIHBhc3MgaW4gdG8ge0BsaW5rIGV4cGFuZFBsYWNlaG9sZGVyc30gYW5kXG4gKiB0byB2YXJpb3VzIG1ldGhvZHMgb2Yge0BsaW5rIFRhc2tFeHByZXNzaW9ufS5cbiAqXG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nOlxuICogLSBgcXVlcnlDb250ZXh0LnF1ZXJ5LmZpbGVgIC0gd2hlcmUgYHF1ZXJ5LmZpbGVgIGlzIGEge0BsaW5rIFRhc2tzRmlsZX0gb2JqZWN0LlxuICogICAgU28gaXQgc3VwcGxpZXMgYHF1ZXJ5LmZpbGUucGF0aGAsIGBxdWVyeS5maWxlLmZvbGRlcmAuXG4gKlxuICogQHNlZSBTZWFyY2hJbmZvXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlDb250ZXh0IHtcbiAgICBxdWVyeToge1xuICAgICAgICBmaWxlOiBUYXNrc0ZpbGU7XG4gICAgICAgIGFsbFRhc2tzOiBSZWFkb25seTxUYXNrW10+O1xuICAgIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIFF1ZXJ5Q29udGV4dH0gdG8gcmVwcmVzZW50IGEgcXVlcnkgaW4gbm90ZSBhdCB0aGUgZ2l2ZSBwYXRoLlxuICogQHBhcmFtIHBhdGhcbiAqXG4gKiBAc2VlIFNlYXJjaEluZm8ucXVlcnlDb250ZXh0XG4gKiBAc2VlIG1ha2VRdWVyeUNvbnRleHRXaXRoVGFza3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VRdWVyeUNvbnRleHQocGF0aDogc3RyaW5nKTogUXVlcnlDb250ZXh0IHtcbiAgICByZXR1cm4gbWFrZVF1ZXJ5Q29udGV4dFdpdGhUYXNrcyhwYXRoLCBbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUXVlcnlDb250ZXh0V2l0aFRhc2tzKHBhdGg6IHN0cmluZywgYWxsVGFza3M6IFJlYWRvbmx5PFRhc2tbXT4pOiBRdWVyeUNvbnRleHQge1xuICAgIGNvbnN0IHRhc2tzRmlsZSA9IG5ldyBUYXNrc0ZpbGUocGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGZpbGU6IHRhc2tzRmlsZSxcbiAgICAgICAgICAgIGFsbFRhc2tzOiBhbGxUYXNrcyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwgImltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB0eXBlIHsgUXVlcnkgfSBmcm9tICcuLi9RdWVyeSc7XG5cbmV4cG9ydCBjbGFzcyBFeHBsYWluZXIge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5kZW50YXRpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBpbmRlbnRhdGlvbiAtIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UgZm9yIHRoZSBvdXRwdXQuIERlZmF1bHRzIHRvICdub3QgaW5kZW50ZWQnLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGVudGF0aW9uOiBzdHJpbmcgPSAnJykge1xuICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb250ZW50cyBvZiBhIHF1ZXJ5LlxuICAgICAqXG4gICAgICogVGhpcyBkb2VzIG5vdCBzaG93IGFueSBnbG9iYWwgZmlsdGVyIGFuZCBnbG9iYWwgcXVlcnkuXG4gICAgICogVXNlIHtAbGluayBleHBsYWluUmVzdWx0c30gaWYgeW91IHdhbnQgdG8gc2VlIGFueSBnbG9iYWwgcXVlcnkgYW5kIGdsb2JhbCBmaWx0ZXIgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwbGFpblF1ZXJ5KHF1ZXJ5OiBRdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGFpbkVycm9yKHF1ZXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFYWNoIGZ1bmN0aW9uIHJlc3VsdCBzaG91bGQ6XG4gICAgICAgICAqIC0gZWl0aGVyOlxuICAgICAgICAgKiAgICAgLSBiZSBlbXB0eSwgaWYgdGhlcmUgaXMgbm8gaW5mb3JtYXRpb24sXG4gICAgICAgICAqIC0gb3I6XG4gICAgICAgICAqICAgICAtIGJlZ2luIHdpdGggYSBub24tbmV3bGluZSxcbiAgICAgICAgICogICAgIC0gZW5kIHdpdGggYSBzaW5nbGUgbmV3bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmV4cGxhaW5GaWx0ZXJzKHF1ZXJ5KSk7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmV4cGxhaW5Hcm91cHMocXVlcnkpKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZXhwbGFpblNvcnRlcnMocXVlcnkpKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZXhwbGFpblF1ZXJ5TGltaXRzKHF1ZXJ5KSk7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmV4cGxhaW5EZWJ1Z1NldHRpbmdzKCkpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcigoZXhwbGFuYXRpb24pID0+IGV4cGxhbmF0aW9uICE9PSAnJykuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBsYWluRXJyb3IocXVlcnk6IFF1ZXJ5KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgcmVzdWx0ICs9ICdRdWVyeSBoYXMgYW4gZXJyb3I6XFxuJztcbiAgICAgICAgcmVzdWx0ICs9IHF1ZXJ5LmVycm9yICsgJ1xcbic7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGV4cGxhaW5GaWx0ZXJzKHF1ZXJ5OiBRdWVyeSkge1xuICAgICAgICBjb25zdCBudW1iZXJPZkZpbHRlcnMgPSBxdWVyeS5maWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bWJlck9mRmlsdGVycyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZW50KCdObyBmaWx0ZXJzIHN1cHBsaWVkLiBBbGwgdGFza3Mgd2lsbCBtYXRjaCB0aGUgcXVlcnkuXFxuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVlcnkuZmlsdGVyc1xuICAgICAgICAgICAgLm1hcCgoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5leHBsYWluRmlsdGVySW5kZW50ZWQodGhpcy5pbmRlbnRhdGlvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYWluR3JvdXBzKHF1ZXJ5OiBRdWVyeSkge1xuICAgICAgICBjb25zdCBudW1iZXJPZkdyb3VwcyA9IHF1ZXJ5Lmdyb3VwaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bWJlck9mR3JvdXBzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRlbnQoJ05vIGdyb3VwaW5nIGluc3RydWN0aW9ucyBzdXBwbGllZC5cXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkdyb3VwczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbmRlbnRhdGlvbiArIHF1ZXJ5Lmdyb3VwaW5nW2ldLmluc3RydWN0aW9uICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXhwbGFpblNvcnRlcnMocXVlcnk6IFF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IG51bWJlck9mU29ydGVycyA9IHF1ZXJ5LnNvcnRpbmcubGVuZ3RoO1xuICAgICAgICBpZiAobnVtYmVyT2ZTb3J0ZXJzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRlbnQoJ05vIHNvcnRpbmcgaW5zdHJ1Y3Rpb25zIHN1cHBsaWVkLlxcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU29ydGVyczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbmRlbnRhdGlvbiArIHF1ZXJ5LnNvcnRpbmdbaV0uaW5zdHJ1Y3Rpb24gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYWluUXVlcnlMaW1pdHMocXVlcnk6IFF1ZXJ5KSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldFBsdXJhbGlzZWRUZXh0KGxpbWl0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gYEF0IG1vc3QgJHtsaW1pdH0gdGFza2A7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9ICdzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0czogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBpZiAocXVlcnkubGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0UGx1cmFsaXNlZFRleHQocXVlcnkubGltaXQpICsgJy5cXG4nO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuaW5kZW50KHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1ZXJ5LnRhc2tHcm91cExpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgZ2V0UGx1cmFsaXNlZFRleHQocXVlcnkudGFza0dyb3VwTGltaXQpICsgJyBwZXIgZ3JvdXAgKGlmIGFueSBcImdyb3VwIGJ5XCIgb3B0aW9ucyBhcmUgc3VwcGxpZWQpLlxcbic7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5pbmRlbnQocmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBsYWluRGVidWdTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBjb25zdCB7IGRlYnVnU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChkZWJ1Z1NldHRpbmdzLmlnbm9yZVNvcnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmluZGVudChcbiAgICAgICAgICAgICAgICBcIk5PVEU6IEFsbCBzb3J0IGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGRlZmF1bHQgc29ydCBvcmRlciwgYXJlIGRpc2FibGVkLCBkdWUgdG8gJ2lnbm9yZVNvcnRJbnN0cnVjdGlvbnMnIHNldHRpbmcuXFxuXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbmRlbnQoZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGlvbiArIGRlc2NyaXB0aW9uO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEFuIEV4cGxhbmF0aW9uIG9iamVjdCBzdG9yZXMgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIGEgUXVlcnkgaW5zdHJ1Y3Rpb24sIG9yIGEgY29tcG9uZW50IG9mIG9uZS5cbiAqXG4gKiBJdCBzdXBwb3J0cyBCb29sZWFuIGNvbWJpbmF0aW9ucyB2aWEgdGhlIHtAbGluayBjaGlsZHJlbn0gZmllbGQuXG4gKlxuICogSW5pdGlhbGx5LCB0aGUge0BsaW5rIGRlc2NyaXB0aW9ufSB3aWxsIHNpbXBseSByZXN0YXRlIHRoZSBpbnN0cnVjdGlvbiBmaWx0ZXIuXG4gKiBMYXRlciwgbW9yZSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBsYW5hdGlvbiB7XG4gICAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IHN5bWJvbDogc3RyaW5nOyAvLyBBTkQsIE9SLCBOT1QsIFhPUlxuICAgIHB1YmxpYyByZWFkb25seSBjaGlsZHJlbjogRXhwbGFuYXRpb25bXTtcblxuICAgIGNvbnN0cnVjdG9yKGRlc2NyaXB0aW9uOiBzdHJpbmcsIGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdID0gW10sIHN5bWJvbDogc3RyaW5nID0gJycpIHtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gQU5EXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuQW5kKGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJpbmVPckNyZWF0ZUV4cGxhbmF0aW9uKCdBbGwgb2YnLCBjaGlsZHJlbiwgJ0FORCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gT1JcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJvb2xlYW5PcihjaGlsZHJlbjogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lT3JDcmVhdGVFeHBsYW5hdGlvbignQXQgbGVhc3Qgb25lIG9mJywgY2hpbGRyZW4sICdPUicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gTk9UXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuTm90KGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oJ05vbmUgb2YnLCBjaGlsZHJlbiwgJ05PVCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gWE9SXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuWG9yKGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oJ0V4YWN0bHkgb25lIG9mJywgY2hpbGRyZW4sICdYT1InKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEV4cGxhbmF0aW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGl0IHdpbGwgbm90IGhhdmUgYSBmaW5hbCBlbmQtb2YtbGluZSBjaGFyYWN0ZXIgYXQgdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJyZW50SW5kZW50YXRpb24gLSBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gVXNlcnMgY2FuIGlnbm9yZSBpdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXNTdHJpbmcoY3VycmVudEluZGVudGF0aW9uOiBzdHJpbmcgPSAnJykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRlbnRhdGlvbiArIHRoaXMuZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudEluZGVudGF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgd2FzIG5vdCBzZXQsIGFkZCB0aGUgZGVzY3JpcHRpb24gYW5kIGp1c3QgaW5kZW50XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGRldGFpbGVkIGV4cGxhbmF0aW9uIHdpdGggbG9naWNcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnN5bWJvbDtcblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBjaGlsZHJlbiwgc28gY29uY2F0ZW5hdGUgdGhlbSB0b2dldGhlclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkZXNjcmlwdGlvbnMgbGlrZSAnQWxsIG9mJywgJ05vbmUgb2YnIGFyZSBvbmUgcmVhbGx5IG1lYW5pbmdmdWxcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGZpbHRlci4gT3RoZXJ3aXNlLCB0aGV5IGFyZSBqdXN0IGNvbmZ1c2luZy5cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYCAoJHt0aGlzLmRlc2NyaXB0aW9ufSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc6JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld0luZGVudGF0aW9uID0gY3VycmVudEluZGVudGF0aW9uICsgJyAgJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFxcbiR7dGhpcy5jaGlsZHJlbltpXS5hc1N0cmluZyhuZXdJbmRlbnRhdGlvbil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNvbWJpbmVPckNyZWF0ZUV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcsIGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdLCBzeW1ib2w6IHN0cmluZykge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDAgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkMSA9IGNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgaWYgKGNoaWxkMC5zeW1ib2wgPT09IHN5bWJvbCAmJiBjaGlsZDEuc3ltYm9sID09PSAnJykge1xuICAgICAgICAgICAgICAgIGNoaWxkMC5jaGlsZHJlbi5wdXNoKGNoaWxkMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uLCBjaGlsZHJlbiwgc3ltYm9sKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGEgcGFydGljdWxhciBjb25kaXRpb24uXG4gKlxuICogVGhpcyBpcyB1c2VkIHRvIGhpZGUgYXdheSB0aGUgZGV0YWlscyBvZiB2YXJpb3VzIHRleHQgc2VhcmNoZXMsIHN1Y2ggYXMgdGhlXG4gKiBzaW1wbGUgaW5jbHVzaW9uIG9mIGEgc3ViLXN0cmluZywgb3IgdGhlIG1vcmUgY29tcGxleCByZWd1bGFyIGV4cHJlc3Npb24gc2VhcmNoZXMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJU3RyaW5nTWF0Y2hlciB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBtYXRjaGVzIHRoaXMgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSBzdHJpbmdUb1NlYXJjaFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBtYXRjaGVzKHN0cmluZ1RvU2VhcmNoOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgYW55IG9mIHRoZSBnaXZlbiBzdHJpbmdzIG1hdGNoZXMgdGhpcyBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZ3NUb1NlYXJjaFxuICAgICAqL1xuICAgIHB1YmxpYyBtYXRjaGVzQW55T2Yoc3RyaW5nc1RvU2VhcmNoOiBzdHJpbmdbXSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nc1RvU2VhcmNoLnNvbWUoKHMpID0+IHRoaXMubWF0Y2hlcyhzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIHtAbGluayBFeHBsYW5hdGlvbn0gb2JqZWN0LCB3aXRoIGFueSBleHRyYSBkZXRhaWxcbiAgICAgKiBhYm91dCB0aGUgYmVoYXZpb3VyIG9mIHRoaXMgbWF0Y2hlci5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4dHJhIGRldGFpbCwganVzdCBwYXNzIHtAbGluayBpbnN0cnVjdGlvbn0gaW4gdG9cbiAgICAgKiB0aGUge0BsaW5rIEV4cGxhbmF0aW9ufSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZXhwbGFuYXRpb24oaW5zdHJ1Y3Rpb246IHN0cmluZyk6IEV4cGxhbmF0aW9uO1xufVxuIiwgImltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4vSVN0cmluZ01hdGNoZXInO1xuXG4vKipcbiAqIFN1YnN0cmluZy1iYXNlZCBpbXBsZW1lbnRhdGlvbiBvZiBJU3RyaW5nTWF0Y2hlci5cbiAqXG4gKiBUaGlzIGRvZXMgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBmb3IgdGhlIGdpdmVuIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnN0cmluZ01hdGNoZXIgZXh0ZW5kcyBJU3RyaW5nTWF0Y2hlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzdHJpbmdUb0ZpbmQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFN1YnN0cmluZ01hdGNoZXIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nVG9GaW5kIC0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2hlcyB3aWxsIGJlIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHN0cmluZ1RvRmluZDogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RyaW5nVG9GaW5kID0gc3RyaW5nVG9GaW5kO1xuICAgIH1cblxuICAgIHB1YmxpYyBtYXRjaGVzKHN0cmluZ1RvU2VhcmNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIFN1YnN0cmluZ01hdGNoZXIuc3RyaW5nSW5jbHVkZXNDYXNlSW5zZW5zaXRpdmUoc3RyaW5nVG9TZWFyY2gsIHRoaXMuc3RyaW5nVG9GaW5kKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHN0cmluZ0luY2x1ZGVzQ2FzZUluc2Vuc2l0aXZlKGhheXN0YWNrOiBzdHJpbmcsIG5lZWRsZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKG5lZWRsZS50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbihpbnN0cnVjdGlvbjogc3RyaW5nKTogRXhwbGFuYXRpb24ge1xuICAgICAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgaGF2ZSBhbnkgc3BlY2lmaWMgZXhwbGFuYXRpb24gb2Ygc3Vic3RyaW5nLXNlYXJjaGluZyxcbiAgICAgICAgLy8gc28ganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsIGluc3RydWN0aW9uIGxpbmUuXG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oaW5zdHJ1Y3Rpb24pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuaW1wb3J0IHsgSVN0cmluZ01hdGNoZXIgfSBmcm9tICcuL0lTdHJpbmdNYXRjaGVyJztcblxuLyoqXG4gKiBSZWd1bGFyLWV4cHJlc3Npb24tYmFzZWQgaW1wbGVtZW50YXRpb24gb2YgSVN0cmluZ01hdGNoZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdleE1hdGNoZXIgZXh0ZW5kcyBJU3RyaW5nTWF0Y2hlciB7XG4gICAgcHVibGljIHJlYWRvbmx5IHJlZ2V4OiBSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBSZWdleE1hdGNoZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2V4IHtSZWdFeHB9IC0gQSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocmVnZXg6IFJlZ0V4cCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZ2V4ID0gcmVnZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgUmVnZXhNYXRjaGVyIG9iamVjdCBpZiB0aGUgc3VwcGxpZWQgc3RyaW5nIGlzIGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqIGFuZCBudWxsIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWdleElucHV0IC0gQSBzdHJpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgbXVzdCBiZWdpbiB3aXRoIGEgLywgYW5kIGVuZCBlaXRoZXIgd2l0aCAvIGFuZCBvcHRpb25hbGx5IGFueVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZmxhZ3MuXG4gICAgICogQHRocm93cyB7U3ludGF4RXJyb3J9IFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIHtAbGluayByZWdleElucHV0fS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHZhbGlkYXRlQW5kQ29uc3RydWN0KHJlZ2V4SW5wdXQ6IHN0cmluZyk6IFJlZ2V4TWF0Y2hlciB8IG51bGwge1xuICAgICAgICAvLyBUaGlzIGV4cHJlc3Npb24gaGFzIHR3byBwYXJ0cy5cbiAgICAgICAgLy8gMS4gVGhlIHJlZ2V4IHNvdXJjZTogIE1hdGNoIGV2ZXJ5IGNoYXJhY3RlciBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGluZSB0b1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAganVzdCBiZWZvcmUgdGhlIGZpbmFsIGZvcndhcmQgc2xhc2ggKCcvJykuXG4gICAgICAgIC8vIDIuIFRoZSBmbGFncywgaWYgYW55OiBNYXRjaCBldmVyeSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2gsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICBjb25zdCByZWdleFBhdHRlcm4gPSAvXlxcLyguKylcXC8oW14vXSopJC87XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcmVnZXhJbnB1dC5tYXRjaChyZWdleFBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChxdWVyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChxdWVyeVsxXSwgcXVlcnlbMl0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdleE1hdGNoZXIocmVnRXhwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG1hdGNoZXMoc3RyaW5nVG9TZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9TZWFyY2gubWF0Y2godGhpcy5yZWdleCkgIT09IG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBoZWxwTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gU3RyaW5nLnJhd2BTZWUgaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL1F1ZXJpZXMvUmVndWxhcitFeHByZXNzaW9uc1xuXG5SZWd1bGFyIGV4cHJlc3Npb25zIG11c3QgbG9vayBsaWtlIHRoaXM6XG4gICAgL3BhdHRlcm4vXG5vciB0aGlzOlxuICAgIC9wYXR0ZXJuL2ZsYWdzXG5cbldoZXJlOlxuLSBwYXR0ZXJuOiBUaGUgJ3JlZ3VsYXIgZXhwcmVzc2lvbicgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuLSBmbGFnczogICBPcHRpb25hbCBjaGFyYWN0ZXJzIHRoYXQgbW9kaWZ5IHRoZSBzZWFyY2guXG4gICAgICAgICAgIGkgPT4gbWFrZSB0aGUgc2VhcmNoIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgdSA9PiBhZGQgVW5pY29kZSBzdXBwb3J0XG5cbkV4YW1wbGVzOiAgL15Mb2cvXG4gICAgICAgICAgIC9eTG9nL2lcbiAgICAgICAgICAgL0ZpbGUgTmFtZVxcLm1kL1xuICAgICAgICAgICAvd2FpdGluZ3x3YWl0c3x3YWl0ZWQvaVxuICAgICAgICAgICAvXFxkXFxkOlxcZFxcZC9cblxuVGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzIGhhdmUgc3BlY2lhbCBtZWFuaW5nIGluIHRoZSBwYXR0ZXJuOlxudG8gZmluZCB0aGVtIGxpdGVyYWxseSwgeW91IG11c3QgYWRkIGEgXFwgYmVmb3JlIHRoZW06XG4gICAgW1xcXiQufD8qKygpXG5cbkNBVVRJT04hIFJlZ3VsYXIgZXhwcmVzc2lvbiAob3IgJ3JlZ2V4Jykgc2VhcmNoaW5nIGlzIGEgcG93ZXJmdWxcbmJ1dCBhZHZhbmNlZCBmZWF0dXJlIHRoYXQgcmVxdWlyZXMgdGhvcm91Z2gga25vd2xlZGdlIGluIG9yZGVyIHRvXG51c2Ugc3VjY2Vzc2Z1bGx5LCBhbmQgbm90IG1pc3MgaW50ZW5kZWQgc2VhcmNoIHJlc3VsdHMuXG5gO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYW5hdGlvbihpbnN0cnVjdGlvbjogc3RyaW5nKTogRXhwbGFuYXRpb24ge1xuICAgICAgICBjb25zdCBpbnRybyA9ICd1c2luZyByZWdleDogJztcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25UZXh0ID0gYWxpZ25SZWdleFdpdGhPcmlnaW5hbEluc3RydWN0aW9uKGluc3RydWN0aW9uLCBpbnRybywgdGhpcy5yZWdleEFzU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKGV4cGxhbmF0aW9uVGV4dCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWdleEFzU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYCcke3RoaXMucmVnZXguc291cmNlfScgd2l0aCBgO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5yZWdleC5mbGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ25vIGZsYWdzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYGZsYWcgJyR7dGhpcy5yZWdleC5mbGFnc30nYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGBmbGFncyAnJHt0aGlzLnJlZ2V4LmZsYWdzfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQWxpZ24gdGhlIHJlZ2V4IHdlIGFyZSBhY3R1YWxseSB1c2luZyB3aXRoIHRoZSByZWdleCBpbiB0aGUgb3JpZ2luYWwgcXVlcnkuXG4gKiBGb3IgZXhhbXBsZSwgdGhpcyBjcmVhdGVzIHRoZSBzZWNvbmQgbGluZSBpbiB0aGlzIGluc3RydWN0aW9uL2V4cGxhbmF0aW9uIHBhaXI6XG4gKlxuICogYGBgdGV4dFxuICogZGVzY3JpcHRpb24gcmVnZXggbWF0Y2hlcyAvd2FpdGluZ3x3YWl0c3x3YXJ0ZXQvID0+XG4gKiAgIHVzaW5nIHJlZ2V4OiAgICAgICAgICAgICd3YWl0aW5nfHdhaXRzfHdhcnRldCcgd2l0aCBubyBmbGFnc1xuICogYGBgXG4gKlxuICogQHBhcmFtIGluc3RydWN0aW9uXG4gKiBAcGFyYW0gaW50cm9cbiAqIEBwYXJhbSByZWdleEFzU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGFsaWduUmVnZXhXaXRoT3JpZ2luYWxJbnN0cnVjdGlvbihpbnN0cnVjdGlvbjogc3RyaW5nLCBpbnRybzogc3RyaW5nLCByZWdleEFzU3RyaW5nOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaCA9IGluc3RydWN0aW9uLm1hdGNoKC9cXC8vKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiAnRXJyb3IgZXhwbGFpbmluZyBpbnN0cnVjdGlvbi4gQ291bGQgbm90IGZpbmQgYSBzbGFzaCBjaGFyYWN0ZXInO1xuICAgIH1cblxuICAgIC8vIFRoZSBleHBsYW5hdGlvbiB3aWxsIGJlIGluZGVudGVkIDIgY2hhcmFjdGVycyBmcm9tIHRoZSBwYXJlbnQgaW5zdHJ1Y3Rpb24sXG4gICAgLy8gc28gcGFkIHRoZSBleHBsYW5hdGlvbiBzbyB0aGF0IHRoZSBzdGFydCBvZiB0aGUgZXhwbGFpbmVkIHJlZ2V4XG4gICAgLy8gYWxpZ25zIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSByZWdleCBpbiB0aGUgb3JpZ2luYWwgaW5zdHJ1Y3Rpb24uXG4gICAgLy8gVGhpcyBtYWtlcyBhbnkgZGlmZmVyZW5jZXMgaW4gdGhlIHJlZ2V4IG11Y2ggZWFzaWVyIHRvIHNwb3QuXG4gICAgY29uc3QgaW5kZW50YXRpb24gPSAyO1xuICAgIGNvbnN0IHN0YXJ0T2ZSZWdleCA9IChtYXRjaC5pbmRleCA/PyBpbmRlbnRhdGlvbikgLSBpbmRlbnRhdGlvbjtcbiAgICBjb25zdCBwcmVmaXhQYWRkZWQgPSBpbnRyby5wYWRFbmQoc3RhcnRPZlJlZ2V4KTtcbiAgICByZXR1cm4gYCR7cHJlZml4UGFkZGVkfSR7cmVnZXhBc1N0cmluZ31gO1xufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IFNlYXJjaEluZm8gfSBmcm9tICcuLi9TZWFyY2hJbmZvJztcblxuLyoqXG4gKiBBIHNvcnRpbmcgZnVuY3Rpb24sIHRoYXQgdGFrZXMgdHdvIFRhc2sgb2JqZWN0cyBhbmQgcmV0dXJuc1xuICogYW5kIHJldHVybnMgb25lIG9mOlxuICogLSBgLTFgIG9yIHNvbWUgb3RoZXIgbmVnYXRpdmUgbnVtYmVyLCBpZiBhIGlzIGxlc3MgdGhhbiBiIGJ5IHNvbWUgb3JkZXJpbmcgY3JpdGVyaW9uLlxuICogLSBgKzFgIG9yIHNvbWUgb3RoZXIgcG9zaXRpdmUgbnVtYmVyLCBpZiBhIGlzIGdyZWF0ZXIgdGhhbiBiIGJ5IHRoZSBvcmRlcmluZyBjcml0ZXJpb24uXG4gKiAtIGAwYCBvciBzb21ldGltZXMgYC0wYCwgaWYgYSBlcXVhbHMgYiBieSB0aGUgb3JkZXJpbmcgY3JpdGVyaW9uLlxuICpcbiAqIFR5cGljYWxseSBDb21wYXJhdG9yIGZ1bmN0aW9ucyBhcmUgc3RvcmVkIGluIGEge0BsaW5rIFNvcnRlcn0gb2JqZWN0LlxuICpcbiAqIFRoZSB7QGxpbmsgU2VhcmNoSW5mb30gcGFyYW1ldGVyIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gaW5zcGVjdCBzZWxlY3RlZCBpbmZvcm1hdGlvblxuICogYWJvdXQgdGhlIHtAbGluayBRdWVyeX0gY29udGFpbmluZyB0aGUgc2VhcmNoIGJlaW5nIHJ1bi5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGFyYXRvciA9IChhOiBUYXNrLCBiOiBUYXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiBudW1iZXI7XG5cbi8qKlxuICogU29ydGVyIHJlcHJlc2VudHMgYSBzaW5nbGUgJ3NvcnQgYnknIGluc3RydWN0aW9uLlxuICogSXQgc3RvcmVzIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIGFzIGEge0BsaW5rIENvbXBhcmF0b3J9LlxuICovXG5leHBvcnQgY2xhc3MgU29ydGVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgaW5zdHJ1Y3Rpb246IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29tcGFyYXRvcjogQ29tcGFyYXRvcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluc3RydWN0aW9uIC0gdGhlIHF1ZXJ5IGluc3RydWN0aW9uIHRoYXQgY3JlYXRlZCB0aGlzIG9iamVjdFxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIHtAbGluayBDb21wYXJhdG9yfSBmdW5jdGlvbiwgZm9yIHNvcnRpbmcgaW4gdGhlIHN0YW5kYXJkIGRpcmVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIElmIGByZXZlcnNlYCBpcyB0cnVlLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY29udmVydGVkIHRvIHJldmVyc2UgdGhlIHNvcnQgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSByZXZlcnNlIC0gd2hldGhlciB0aGUgc29ydCBvcmRlciBzaG91bGQgYmUgcmV2ZXJzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgcHJvcGVydHk6IHN0cmluZywgY29tcGFyYXRvcjogQ29tcGFyYXRvciwgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gU29ydGVyLm1heWJlUmV2ZXJzZShyZXZlcnNlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYXliZVJldmVyc2UocmV2ZXJzZTogYm9vbGVhbiwgY29tcGFyYXRvcjogQ29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSA/IFNvcnRlci5tYWtlUmV2ZXJzZWRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIDogY29tcGFyYXRvcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYWtlUmV2ZXJzZWRDb21wYXJhdG9yKGNvbXBhcmF0b3I6IENvbXBhcmF0b3IpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBjYW4gcmV0dXJuIC0wLlxuICAgICAgICByZXR1cm4gKGEsIGIsIHNlYXJjaEluZm8pID0+IChjb21wYXJhdG9yKGEsIGIsIHNlYXJjaEluZm8pICogLTEpIGFzIC0xIHwgMCB8IDE7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IFNlYXJjaEluZm8gfSBmcm9tICcuLi9TZWFyY2hJbmZvJztcblxuLyoqXG4gKiBBIGdyb3VwLW5hbWluZyBmdW5jdGlvbiwgdGhhdCB0YWtlcyBhIFRhc2sgb2JqZWN0IGFuZCByZXR1cm5zIHplcm8gb3IgbW9yZVxuICogY29ycmVzcG9uZGluZyBncm91cCBwcm9wZXJ0eSBuYW1lcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYSB7QGxpbmsgR3JvdXBlckZ1bmN0aW9ufSBpbXBsZW1lbnRlZCBncm91cGluZyBieSB0YWcsXG4gKiBwYXNzaW5nIGluIGEgdGFzayB0aGF0IGhhcyB0d28gdGFncywgI3RhZzEgYW5kICN0YWcyIHRvIHRoaXMgdGFnLWdyb3VwZXIgZnVuY3Rpb25cbiAqIHdvdWxkIHJldHVybiBbJ3RhZzEnLCAndGFnMiddXG4gKlxuICogVGhlIHtAbGluayBTZWFyY2hJbmZvfSBwYXJhbWV0ZXIgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byBpbnNwZWN0IHNlbGVjdGVkIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUge0BsaW5rIFF1ZXJ5fSBjb250YWluaW5nIHRoZSBzZWFyY2ggYmVpbmcgcnVuLlxuICovXG5leHBvcnQgdHlwZSBHcm91cGVyRnVuY3Rpb24gPSAodGFzazogVGFzaywgc2VhcmNoSW5mbzogU2VhcmNoSW5mbykgPT4gc3RyaW5nW107XG5cbi8qKlxuICogQSBuYW1lZCBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBncm91cCBoZWFkaW5nIG5hbWUocykgdG8gdXNlIGZvciBhIHtAbGluayBUYXNrfSBvYmplY3QuXG4gKlxuICogVGhlIG5hbWUgaXMgcmVwcmVzZW50ZWQgaW4ge0BsaW5rIHByb3BlcnR5fS5cbiAqXG4gKiBOb3RlOiB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0cyBhcmUgdHlwaWNhbGx5IGNyZWF0ZWQgYnkge0BsaW5rIEZpZWxkLmdyb3VwZXJ9IHVzaW5nIHRoZSBtYW55XG4gKiBjbGFzc2VzIGRlcml2ZWQgZnJvbSB7QGxpbmsgRmllbGR9LlxuICpcbiAqIEBzZWUge0BsaW5rIFRhc2tHcm91cHN9IGZvciBob3cgdG8gdXNlIHtAbGluayBHcm91cGVyfSBvYmplY3RzIHRvIGdyb3VwIHRhc2tzIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBlciB7XG4gICAgcHVibGljIGluc3RydWN0aW9uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBncm91cGVyLCBmb3IgZXhhbXBsZSAndGFncycgb3IgJ2R1ZScuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSAnZ3JvdXAgYnkgdGFncycgbGluZSB3b3VsZCBiZSBleHBlY3RlZCB0byBnZW5lcmF0ZSBhXG4gICAgICoge0BsaW5rIEdyb3VwZXIucHJvcGVydHl9IGNhbGxlZCAndGFncycuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIEdyb3VwZXJGdW5jdGlvbn0gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ3JvdXAgdGFza3MgdG9nZXRoZXIuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGdyb3VwZXI6IEdyb3VwZXJGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGhlYWRpbmdzIGZvciB0aGlzIGdyb3VwIHNob3VsZCBiZSByZXZlcnNlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGluc3RydWN0aW9uOiBzdHJpbmcsIHByb3BlcnR5OiBzdHJpbmcsIGdyb3VwZXI6IEdyb3VwZXJGdW5jdGlvbiwgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5ncm91cGVyID0gZ3JvdXBlcjtcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU29ydGVyIH0gZnJvbSAnLi4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0ICogYXMgUmVnRXhwVG9vbHMgZnJvbSAnLi4vLi4vbGliL1JlZ0V4cFRvb2xzJztcbmltcG9ydCB7IEdyb3VwZXIgfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZWFjaCB0eXBlIG9mIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZGVyaXZlZCBjbGFzcyBTdGFydERhdGVGaWVsZCBpbXBsZW1lbnRzIHRoZSBwYXJzaW5nXG4gKiBvZiAnc3RhcnRzJyBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGhlIG5hbWUgJ0ZpZWxkJyBtYXkgc2VlbSBjb25mdXNpbmcsIGFzIGl0IG1pZ2h0IGN1cnJlbnRseSBiZVxuICogZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgd29yZCAnRmlsdGVyJyBpbiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBDdXJyZW50IHRoaW5raW5nIGlzIHRoYXQgaXQgbWF5IHdlbGwgZXZvbHZlIGxhdGVyIHRvIGFsc28gaW1wbGVtZW50XG4gKiB0aGUgcHJlc2VuY2UgYW5kIGFic2VuY2Ugc2VhcmNoZXMgYXMgd2VsbFxuICogKHN1Y2ggJ25vIHN0YXJ0IGRhdGUnIGFuZCAnaGFzIHN0YXJ0IGRhdGUnKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZpZWxkIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNsYXNzIGNhbiBwYXJzZSB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNoZWNrcyB3aGV0aGVyIHRoZSBsaW5lIG1hdGNoZXNcbiAgICAgKiB0aGlzLmZpbHRlclJlZ0V4cCgpLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSBgYGB0YXNrc2BgYCBibG9jay5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIEZpbHRlciBmdW5jdGlvbiBvciBhbiBlcnJvciBzdHJpbmcsXG4gICAgICogd2hpY2ggYXJlIGJvdGggd3JhcHBlZCBpbiBhIEZpbHRlck9yRXJyb3JNZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlO1xuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgZ2l2ZW4gbGluZSBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyP1xuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBBIFJlZ0V4cCByZWd1bGFyIGV4cHJlc3Npb24sIHRoYXQgc3BlY2lmaWVzIG9uZSBxdWVyeSBpbnN0cnVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgT3IgbnVsbCwgaWYgdGhlIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgcmVnZXhwLWJhc2VkIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgdGFza3MgY29kZSBibG9jayBxdWVyeS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBsaW5lTWF0Y2hlc0ZpbHRlcihmaWx0ZXI6IFJlZ0V4cCB8IG51bGwsIGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLnRlc3QobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1hdGNoIGZvciB0aGUgZ2l2ZW4gZmlsdGVyLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IG1hdGNoXG4gICAgICogQHBhcmFtIGZpbHRlclJlZ0V4cCAtIEEgUmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhhdCBzcGVjaWZpZXMgb25lIHF1ZXJ5IGluc3RydWN0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBPciBudWxsLCBpZiB0aGUgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCByZWdleHAtYmFzZWQgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrIHF1ZXJ5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldE1hdGNoKGZpbHRlclJlZ0V4cDogUmVnRXhwIHwgbnVsbCwgbGluZTogc3RyaW5nKTogUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwge1xuICAgICAgICBpZiAoZmlsdGVyUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5tYXRjaChmaWx0ZXJSZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGZpbHRlcmluZyBUYXNrcyBieSBpbnNwZWN0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLlxuICAgICAqIE9yIG51bGwsIGlmIHRoaXMgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHJlZ2V4LWJhc2VkIGluc3RydWN0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhpcyBmaWVsZCwgdG8gYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBUaGlzIHVzdWFsbHkgbWF0Y2hlcyB0aGUgaW5zdHJ1Y3Rpb24gbmFtZSwgYnV0IGRvZXMgbm90IGFsd2F5c1xuICAgICAqIChzZWUgc3RhcnQgYW5kIHN0YXJ0cykuXG4gICAgICpcbiAgICAgKiBBbHNvLCBzb21lIGZpZWxkcyBoYXZlIG1vcmUgdGhhbiBvbmUgbmFtZSwgc2VwYXJhdGVkIGJ5ICcvJy5cbiAgICAgKiBTZWUge0BsaW5rIFRhZ3NGaWVsZH0sIGZvciBleGFtcGxlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBmaWVsZE5hbWUoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lXG4gICAgICogQHNlZSBmaWVsZE5hbWVTaW5ndWxhckVzY2FwZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLCBlc2NhcGVkIGZvciB1c2UgaW4gcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGZvciBmaWVsZCBuYW1lcyB0aGF0IGNvbnRhaW4gYC5gIGluLCBmb3IgZXhhbXBsZS5cbiAgICAgKiBAcHVibGljXG4gICAgICpcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwVG9vbHMuZXNjYXBlUmVnRXhwKHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBjb2RlIGZvciB0aGlzIGZpZWxkIGltcGxlbWVudHMgc29ydGluZyBvZiB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIG92ZXJyaWRpbmcgdGhpcyB0byByZXR1cm4gdHJ1ZSwgaW4gb3JkZXIgdG8gZW5hYmxlIHNvcnRpbmcsXG4gICAgICogdGhlIG1ldGhvZCB7QGxpbmsgY29tcGFyYXRvcn0gbXVzdCBhbHNvIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBvciBudWxsLlxuICAgICAqXG4gICAgICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdvcmtzIGZvciBhbGwgZmllbGRzIHRoYXQgc3VwcG9ydFxuICAgICAqIHRoZSBkZWZhdWx0IHNvcnRpbmcgcGF0dGVybiBvZiBgc29ydCBieSA8ZmllbGROYW1lPiAocmV2ZXJzZSk/YC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ3NvcnQgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgJ3NvcnQgYnknIGxpbmUgZnJvbSBhIGBgYHRhc2tzYGBgIGJsb2NrLlxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVTb3J0ZXJGcm9tTGluZShsaW5lOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzU29ydGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5zb3J0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ydGVyKHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgbWF0Y2ggYSBjb3JyZWN0bHktZm9ybWVkXG4gICAgICogaW5zdHJ1Y3Rpb24gbGluZSBmb3Igc29ydGluZyBUYXNrcyBieSB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogVGhyb3dzIGlmIHRoaXMgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCBzb3J0aW5nLlxuICAgICAqXG4gICAgICogYG1hdGNoWzFdYCB3aWxsIGJlIGVpdGhlciBgcmV2ZXJzZWAgb3IgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogRmllbGRzIHRoYXQgb2ZmZXIgbW9yZSBjb21wbGljYXRlZCAnc29ydCBieScgb3B0aW9ucyBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc29ydGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1NvcnRpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYHNvcnRlclJlZ0V4cCgpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5zb3J0IGJ5ICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0oIHJldmVyc2UpP2AsICdpJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjb25zdHJ1Y3QgYSAnc29ydGVyIGJ5JyBpbnN0cnVjdGlvbiB0byB1c2UgZm9yIHNvcnRpbmcgb2YgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBzaW1wbGlmeSB0aGUgY29uc3RydWN0aW9uIG9mIHtAbGluayBTb3J0ZXJ9IG9iamVjdHMuXG4gICAgICogQHBhcmFtIHJldmVyc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNvcnRlckluc3RydWN0aW9uKHJldmVyc2U6IGJvb2xlYW4pIHtcbiAgICAgICAgbGV0IGluc3RydWN0aW9uID0gYHNvcnQgYnkgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YDtcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uICs9ICcgcmV2ZXJzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdHdvIFRhc2sgb2JqZWN0cywgZm9yIHVzZSBpbiBzb3J0aW5nIGJ5IHRoaXMgZmllbGQncyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgc3VwcG9ydHNTb3J0aW5nfSBmb3Igd2hhdCB0byBkbywgdG8gZW5hYmxlIHN1cHBvcnQgb2Ygc29ydGluZyBpbiBhXG4gICAgICogcGFydGljdWxhciB7QGxpbmsgRmllbGR9IGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICB0aHJvdyBFcnJvcihgY29tcGFyYXRvcigpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBmb3Igc29ydGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUuXG4gICAgICogQHBhcmFtIHJldmVyc2UgLSBmYWxzZSBmb3Igbm9ybWFsIHNvcnQgb3JkZXIsIHRydWUgZm9yIHJldmVyc2Ugc29ydCBvcmRlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlU29ydGVyKHJldmVyc2U6IGJvb2xlYW4pOiBTb3J0ZXIge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlcih0aGlzLnNvcnRlckluc3RydWN0aW9uKHJldmVyc2UpLCB0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCksIHRoaXMuY29tcGFyYXRvcigpLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgU29ydGVyfSBvYmplY3QgZm9yIHNvcnRpbmcgdGFza3MgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLFxuICAgICAqIGluIHRoZSBzdGFuZGFyZC9ub3JtYWwgc29ydCBvcmRlciBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZVJldmVyc2VTb3J0ZXJ9XG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZU5vcm1hbFNvcnRlcigpOiBTb3J0ZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb3J0ZXIoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBmb3Igc29ydGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUsXG4gICAgICogaW4gdGhlIHJldmVyc2Ugb2YgdGhlIHN0YW5kYXJkL25vcm1hbCBzb3J0IG9yZGVyIGZvciB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlTm9ybWFsU29ydGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVSZXZlcnNlU29ydGVyKCk6IFNvcnRlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvcnRlcih0cnVlKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBjb2RlIGZvciB0aGlzIGZpZWxkIGltcGxlbWVudHMgZ3JvdXBpbmcgb2YgdGFza3MuXG4gICAgICpcbiAgICAgKiBJZiBvdmVycmlkaW5nIHRoaXMgdG8gcmV0dXJuIHRydWUsIGluIG9yZGVyIHRvIGVuYWJsZSBncm91cGluZyxcbiAgICAgKiB0aGUgbWV0aG9kIHtAbGluayBncm91cGVyfSBtdXN0IGFsc28gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIHtAbGluayBHcm91cGVyfSBvYmplY3Qgb3IgbnVsbC5cbiAgICAgKlxuICAgICAqIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3b3JrcyBmb3IgYWxsIGZpZWxkcyB0aGF0IHN1cHBvcnRcbiAgICAgKiB0aGUgZGVmYXVsdCBncm91cGluZyBwYXR0ZXJuIG9mIGBncm91cCBieSA8ZmllbGROYW1lPiAocmV2ZXJzZSk/YC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ2dyb3VwIGJ5JyBvcHRpb25zIGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmUgLSBBICdncm91cCBieScgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXJGcm9tTGluZShsaW5lOiBzdHJpbmcpOiBHcm91cGVyIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0dyb3VwaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmdyb3VwZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlR3JvdXBlcihyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGdyb3VwaW5nIFRhc2tzIGJ5IHRoaXMgZmllbGQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgdGhpcyBmaWVsZCBkb2VzIG5vdCBzdXBwb3J0IGdyb3VwaW5nLlxuICAgICAqXG4gICAgICogYG1hdGNoWzFdYCB3aWxsIGJlIGVpdGhlciBgcmV2ZXJzZWAgb3IgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogRmllbGRzIHRoYXQgb2ZmZXIgbW9yZSBjb21wbGljYXRlZCAnZ3JvdXAgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdyb3VwZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzR3JvdXBpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGdyb3VwZXJSZWdFeHAoKSB1bmltcGxlbWVudGVkIGZvciAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSAkIGF0IGVuZCBpcyByZXF1aXJlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGdyb3VwIGJ5IHN0YXR1cyBhbmQgc3RhdHVzLm5hbWVcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5ncm91cCBieSAke3RoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCl9KCByZXZlcnNlKT8kYCwgJ2knKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvbnN0cnVjdCBhICdncm91cCBieScgaW5zdHJ1Y3Rpb24gdG8gdXNlIGZvciBncm91cGluZyBvZiB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBjb25zdHJ1Y3Rpb24gb2YgR3JvdXBlciBvYmplY3RzLlxuICAgICAqIEBwYXJhbSByZXZlcnNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBncm91cGVySW5zdHJ1Y3Rpb24ocmV2ZXJzZTogYm9vbGVhbikge1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBgZ3JvdXAgYnkgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YDtcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uICs9ICcgcmV2ZXJzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGdldCBhIGxpc3Qgb2YgYSB0YXNrJ3MgZ3JvdXAgbmFtZXMsIGZvciB1c2UgaW4gZ3JvdXBpbmcgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBzdXBwb3J0c0dyb3VwaW5nfSBmb3Igd2hhdCB0byBkbywgdG8gZW5hYmxlIHN1cHBvcnQgb2YgZ3JvdXBpbmcgaW4gYVxuICAgICAqIHBhcnRpY3VsYXIge0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICB0aHJvdyBFcnJvcihgZ3JvdXBlcigpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBHcm91cGVyfSBvYmplY3QgZm9yIGdyb3VwaW5nIHRhc2tzIGJ5IHRoaXMgZmllbGQncyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSAtIGZhbHNlIGZvciBub3JtYWwgZ3JvdXAgb3JkZXIsIHRydWUgZm9yIHJldmVyc2UgZ3JvdXAgb3JkZXIuXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXIocmV2ZXJzZTogYm9vbGVhbik6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIodGhpcy5ncm91cGVySW5zdHJ1Y3Rpb24ocmV2ZXJzZSksIHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSwgdGhpcy5ncm91cGVyKCksIHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBHcm91cGVyfSBvYmplY3QgZm9yIGdyb3VwaW5nIHRhc2tzIGJ5IHRoaXMgZmllbGQncyB2YWx1ZSxcbiAgICAgKiBpbiB0aGUgc3RhbmRhcmQvbm9ybWFsIGdyb3VwIG9yZGVyIGZvciB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlUmV2ZXJzZUdyb3VwZXJ9XG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZU5vcm1hbEdyb3VwZXIoKTogR3JvdXBlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUdyb3VwZXIoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBHcm91cGVyfSBvYmplY3QgZm9yIGdyb3VwaW5nIHRhc2tzIGJ5IHRoaXMgZmllbGQncyB2YWx1ZSxcbiAgICAgKiBpbiB0aGUgcmV2ZXJzZSBvZiB0aGUgc3RhbmRhcmQvbm9ybWFsIGdyb3VwIG9yZGVyIGZvciB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlTm9ybWFsR3JvdXBlcn1cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlUmV2ZXJzZUdyb3VwZXIoKTogR3JvdXBlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUdyb3VwZXIodHJ1ZSk7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQSBzaW5nbGUgbG9naWNhbCBpbnB1dCBzdGF0ZW1lbnQgaW4gYSBUYXNrcyBRdWVyeSBibG9jay5cbiAqXG4gKiBUaGlzIG1heSByZXByZXNlbnQgbXVsdGlwbGUgbGluZXMgd2l0aCBjb250aW51YXRpb24gY2hhcmFjdGVycy5cbiAqXG4gKiAtIHtAbGluayBhbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWR9IGlzIHRoZSBzdGF0ZW1lbnQgYWZ0ZXIgY29udGludWF0aW9uIGxpbmVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBtYXkgY29udGFpbiBwbGFjZWhvbGRlcnMsIGhvd2V2ZXIuXG4gKiAtIElmIGNvbnRpbnVhdGlvbiBsaW5lcyB3ZXJlIHVzZWQsIHtAbGluayByYXdJbnN0cnVjdGlvbn0gcmVwcmVzZW50cyB0aGUgbXVsdGktbGluZSBpbnB1dC5cbiAqIC0ge0BsaW5rIGFueVBsYWNlaG9sZGVyc0V4cGFuZGVkfSB3aWxsIGRpZmZlciBmcm9tIHtAbGluayBhbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWR9IGlmIHRoZXJlIHdlcmUgYW55IHBsYWNlaG9sZGVycy5cbiAqXG4gKiBJbiB0ZXN0cywgZ2VuZXJhbGx5IGFsbCAzIGZpZWxkcyBhcmUgaWRlbnRpY2FsLCBhcyB0aGUgY29udGludWF0aW9uIGNoYXJhY3RlcnMgYW5kIHBsYWNlaG9sZGVyc1xuICogYXJlIG9ubHkgYXBwbGllZCBpbiB7QGxpbmsgUXVlcnl9LlxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVtZW50IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9yYXdJbnN0cnVjdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2FueUNvbnRpbnVhdGlvbkxpbmVzUmVtb3ZlZDogc3RyaW5nO1xuICAgIHByaXZhdGUgX2FueVBsYWNlaG9sZGVyc0V4cGFuZGVkOiBzdHJpbmc7IC8vIE1heSBiZSB1cGRhdGVkIGluIHJlY29yZEV4cGFuZGVkUGxhY2Vob2xkZXJzKCkgYWZ0ZXIgY29uc3RydWN0aW9uXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSByYXdJbnN0cnVjdGlvbiAtIElmIHRoZSBxdWVyeSB1c2VkIGNvbnRpbnVhdGlvbiBsaW5lcyBmb3IgdGhpcyBzdGF0ZW1lbnQsIHJhd0luc3RydWN0aW9uIHJlcHJlc2VudHMgdGhlIG11bHRpLWxpbmUgaW5wdXQuXG4gICAgICogQHBhcmFtIGluc3RydWN0aW9uIC0gd2hpdGVzcGFjZSBpcyB0cmltbWVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmF3SW5zdHJ1Y3Rpb246IHN0cmluZywgaW5zdHJ1Y3Rpb246IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yYXdJbnN0cnVjdGlvbiA9IHJhd0luc3RydWN0aW9uO1xuICAgICAgICB0aGlzLl9hbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWQgPSBpbnN0cnVjdGlvbi50cmltKCk7XG4gICAgICAgIHRoaXMuX2FueVBsYWNlaG9sZGVyc0V4cGFuZGVkID0gdGhpcy5fYW55Q29udGludWF0aW9uTGluZXNSZW1vdmVkO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWNvcmRFeHBhbmRlZFBsYWNlaG9sZGVycyhsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fYW55UGxhY2Vob2xkZXJzRXhwYW5kZWQgPSBsaW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IG9mIHRoaXMgc3RhdGVtZW50LCB3aXRoIGFsbCBvcmlnaW5hbCB3aGl0ZXNwYWNlLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgd2VyZSBjb250aW51YXRpb24gbGluZXMgaW4gdGhlIHF1ZXJ5LCB0aGlzIHdpbGwgY29udGFpbiBuZXdsaW5lIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgcHVibGljIGdldCByYXdJbnN0cnVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF3SW5zdHJ1Y3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgb2YgdGhpcyBzdGF0ZW1lbnQgYWZ0ZXIgYW55IGNvbnRpbnVhdGlvbiBsaW5lcyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhlIGxpbmUgaXMgdHJpbW1lZCwgYWx0aG91Z2ggdGhhdCBtYXkgY2hhbmdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYW55Q29udGludWF0aW9uTGluZXNSZW1vdmVkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBhbnlQbGFjZWhvbGRlcnNFeHBhbmRlZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55UGxhY2Vob2xkZXJzRXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGV4cGxhaW5TdGF0ZW1lbnQoaW5kZW50OiBzdHJpbmcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kTGluZUlmRGlmZmVyZW50KHByZXZpb3VzTGluZTogc3RyaW5nLCBuZXh0TGluZTogc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAobmV4dExpbmUgIT09IHByZXZpb3VzTGluZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgID0+XG4ke2luZGVudH0ke25leHRMaW5lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmF3IGluc3RydWN0aW9uIGlzIHN0b3JlZCB3aXRoIGFueSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIHF1ZXJ5IGxpbmUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgbG9va3MgbWVzc3kgaW4gZXhwbGFuYXRpb25zLCBhbmQgbGVhZHMgdG8gY29tcGxpY2F0aW9ucyB3aGVuIGNvbXBhcmluZ1xuICAgICAgICAvLyB3aGV0aGVyIHRoZSBkaWZmZXJlbnQgZmllbGRzIGluIHRoaXMgY2xhc3MgYXJlIGlkZW50aWNhbC5cbiAgICAgICAgLy8gU28gZm9yIHNpbXBsaWNpdHksIHdlIHRyaW0gdGhlIHJhdyBpbnN0cnVjdGlvbiBpbiAnZXhwbGFpbicgb3V0cHV0LlxuICAgICAgICBjb25zdCByYXdJbnN0cnVjdGlvblRyaW1tZWQgPSB0aGlzLl9yYXdJbnN0cnVjdGlvbi50cmltKCk7XG5cbiAgICAgICAgY29uc3QgcmF3ID0gcmF3SW5zdHJ1Y3Rpb25UcmltbWVkLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgaW5kZW50KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGAke2luZGVudH0ke3Jhd31gO1xuXG4gICAgICAgIC8vIElmIHRoZSByYXcgaW5zdHJ1Y3Rpb24gaGFzIG1vcmUgdGhhbiBvbmUgbGluZSwgYXBwZW5kIHRleHQgc28gdGhhdCB0aGVcbiAgICAgICAgLy8gc3Vic2VxdWVudCAnPT4nIHN0cmluZyB3aWxsIGFwcGVhciBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgbGluZSwgZm9yIGNsYXJpdHk6XG4gICAgICAgIGlmICh0aGlzLl9yYXdJbnN0cnVjdGlvbi5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJyArIGluZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZExpbmVJZkRpZmZlcmVudChyYXdJbnN0cnVjdGlvblRyaW1tZWQsIHRoaXMuX2FueUNvbnRpbnVhdGlvbkxpbmVzUmVtb3ZlZCk7XG4gICAgICAgIGFwcGVuZExpbmVJZkRpZmZlcmVudCh0aGlzLl9hbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWQsIHRoaXMuX2FueVBsYWNlaG9sZGVyc0V4cGFuZGVkKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBhbGxMaW5lc0lkZW50aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX3Jhd0luc3RydWN0aW9uID09PSB0aGlzLl9hbnlDb250aW51YXRpb25MaW5lc1JlbW92ZWQgJiZcbiAgICAgICAgICAgIHRoaXMuX3Jhd0luc3RydWN0aW9uID09PSB0aGlzLl9hbnlQbGFjZWhvbGRlcnNFeHBhbmRlZFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB0eXBlIHsgU2VhcmNoSW5mbyB9IGZyb20gJy4uL1NlYXJjaEluZm8nO1xuaW1wb3J0IHsgU3RhdGVtZW50IH0gZnJvbSAnLi4vU3RhdGVtZW50JztcblxuLyoqXG4gKiBBIGZpbHRlcmluZyBmdW5jdGlvbiwgdGhhdCB0YWtlcyBhIFRhc2sgb2JqZWN0IGFuZCByZXR1cm5zXG4gKiB3aGV0aGVyIGl0IG1hdGNoZXMgYSBwYXJ0aWN1bGFyIGZpbHRlcmluZyBpbnN0cnVjdGlvbi5cbiAqXG4gKiBTZWFyY2hJbmZvIGlzIGJlaW5nIGludHJvZHVjZWQgYXMgYSBQYXJhbWV0ZXIgT2JqZWN0LCBpbiBvcmRlciB0byBsYXRlciBhbGxvd1xuICogbW9yZSBkYXRhIHRvIGJlIHBhc3NlZCBmcm9tIHRoZSBRdWVyeSBkb3duIGluIHRvIHRoZSBpbmRpdmlkdWFsIGZpbHRlcnMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2ssIHNlYXJjaEluZm86IFNlYXJjaEluZm8pID0+IGJvb2xlYW47XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwYXJzZWQgZmlsdGVyaW5nIGluc3RydWN0aW9uIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrLlxuICpcbiAqIEl0IHByb3ZpZGVzIGFjY2VzcyB0bzpcbiAqXG4gKiAtIFRoZSBvcmlnaW5hbCB7QGxpbmsgaW5zdHJ1Y3Rpb259LCBhZnRlciBwcm9jZXNzaW5nIG9mIGNvbnRpbnVhdGlvbiBsaW5lcyBhbmQgcGxhY2Vob2xkZXJzLlxuICogLSBBbiB7QGxpbmsgZXhwbGFuYXRpb259LCBzaG93aW5nIGhvdyB0aGUgaW5zdHJ1Y3Rpb24gd2FzIGludGVycHJldGVkLlxuICogLSBBIHtAbGluayBzdGF0ZW1lbnR9LCB3aGljaCBpcyBhIHtAbGluayBTdGF0ZW1lbnR9IG9iamVjdCB0aGF0IGdpdmVzIGFjY2VzcyB0byB0aGUgb3JpZ2luYWwgdGV4dCxcbiAqICAgZm9yIGZpbHRlcnMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnkgYSB7QGxpbmsgUXVlcnl9LlxuICogLSBUaGUge0BsaW5rIGZpbHRlckZ1bmN0aW9ufSAtIGEge0BsaW5rIEZpbHRlckZ1bmN0aW9ufSB3aGljaCB0ZXN0cyB3aGV0aGVyIGEgdGFzayBtYXRjaGVzIHRoZSBmaWx0ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlciB7XG4gICAgLyoqIF9zdGF0ZW1lbnQgbWF5IGJlIHVwZGF0ZWQgbGF0ZXIgd2l0aCB7QGxpbmsgc2V0U3RhdGVtZW50fSAqL1xuICAgIHByaXZhdGUgX3N0YXRlbWVudDogU3RhdGVtZW50O1xuXG4gICAgcmVhZG9ubHkgZXhwbGFuYXRpb246IEV4cGxhbmF0aW9uO1xuICAgIHB1YmxpYyBmaWx0ZXJGdW5jdGlvbjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgZmlsdGVyRnVuY3Rpb246IEZpbHRlckZ1bmN0aW9uLCBleHBsYW5hdGlvbjogRXhwbGFuYXRpb24pIHtcbiAgICAgICAgdGhpcy5fc3RhdGVtZW50ID0gbmV3IFN0YXRlbWVudChpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gICAgICAgIHRoaXMuZmlsdGVyRnVuY3Rpb24gPSBmaWx0ZXJGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN0YXRlbWVudCgpOiBTdGF0ZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsbHkgcmVjb3JkIG1vcmUgZGV0YWlsIGFib3V0IHRoZSBzb3VyY2Ugc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogSW4gdGVzdHMsIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgYWN0dWFsIGluc3RydWN0aW9uIGJlaW5nIHBhcnNlZCBhbmQgZXhlY3V0ZWQuXG4gICAgICogSG93ZXZlciwgaW4ge0BsaW5rIFF1ZXJ5fSwgd2Ugd2FudCB0aGUgYWJpbGl0eSB0byBzaG93IHVzZXIgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0U3RhdGVtZW50KHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3N0YXRlbWVudCA9IHN0YXRlbWVudDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGluc3RydWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZW1lbnQuYW55UGxhY2Vob2xkZXJzRXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGV4cGxhaW5GaWx0ZXJJbmRlbnRlZChpbmRlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBleHBsYWluZWRTdGF0ZW1lbnQgPSB0aGlzLl9zdGF0ZW1lbnQuZXhwbGFpblN0YXRlbWVudChpbmRlbnQpO1xuICAgICAgICBpZiAodGhpcy5vbmx5TmVlZHNPbmVMaW5lRXhwbGFuYXRpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2V4cGxhaW5lZFN0YXRlbWVudH1cXG5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2V4cGxhaW5lZFN0YXRlbWVudH0gPT5cXG4ke3RoaXMuZXhwbGFuYXRpb24uYXNTdHJpbmcoaW5kZW50ICsgJyAgJyl9XFxuYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzaW11bGF0ZUV4cGxhaW5GaWx0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ubHlOZWVkc09uZUxpbmVFeHBsYW5hdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBsYW5hdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24odGhpcy5pbnN0cnVjdGlvbiArICcgPT4nLCBbdGhpcy5leHBsYW5hdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbmx5TmVlZHNPbmVMaW5lRXhwbGFuYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxhbmF0aW9uLmFzU3RyaW5nKCcnKSA9PT0gdGhpcy5pbnN0cnVjdGlvbjtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBzdG9yaW5nOlxuICogLSBhIHRleHQgaW5zdHJ1Y3Rpb24uXG4gKiAtIGFuIG9iamVjdCBvZiB0eXBlIFF1ZXJ5Q29tcG9uZW50IGNvbnN0cnVjdGVkIGZyb20gdGhlIGluc3RydWN0aW9uLCBpZiB0aGUgaW5zdHJ1Y3Rpb24gaXMgdmFsaWQuXG4gKiAtIG90aGVyd2lzZSwgYW4gZXJyb3IgbWVzc2FnZSBleHBsYWluaW5nIGluIHdoYXQgd2F0IHRoZSBpbnN0cnVjdGlvbiBpcyBpbnZhbGlkLlxuICpcbiAqIEFuIGV4YW1wbGUgdHlwZSBvZiBRdWVyeUNvbXBvbmVudCBpcyB7QGxpbmsgRmlsdGVyfS4gU2VlIHtAbGluayBGaWx0ZXJPckVycm9yTWVzc2FnZX0uXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWVyeUNvbXBvbmVudE9yRXJyb3I8UXVlcnlDb21wb25lbnQ+IHtcbiAgICByZWFkb25seSBpbnN0cnVjdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgX3F1ZXJ5Q29tcG9uZW50OiBRdWVyeUNvbXBvbmVudCB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9lcnJvcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGluc3RydWN0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcXVlcnlDb21wb25lbnQoKTogUXVlcnlDb21wb25lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXQgcXVlcnlDb21wb25lbnQodmFsdWU6IFF1ZXJ5Q29tcG9uZW50IHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5Q29tcG9uZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlcnJvcigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXQgZXJyb3IodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9lcnJvciA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIHZhbGlkIGlmIHtAbGluayBxdWVyeUNvbXBvbmVudH0gaXNuJ3QgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlDb21wb25lbnQgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gT2JqZWN0T3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gUXVlcnlDb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gYSB7QGxpbmsgRmlsdGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbU9iamVjdDxRdWVyeUNvbXBvbmVudD4oXG4gICAgICAgIGluc3RydWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIG9iamVjdDogUXVlcnlDb21wb25lbnQsXG4gICAgKTogUXVlcnlDb21wb25lbnRPckVycm9yPFF1ZXJ5Q29tcG9uZW50PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWVyeUNvbXBvbmVudE9yRXJyb3I8UXVlcnlDb21wb25lbnQ+KGluc3RydWN0aW9uKTtcbiAgICAgICAgcmVzdWx0Ll9xdWVyeUNvbXBvbmVudCA9IG9iamVjdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBPYmplY3RPckVycm9yTWVzc2FnZSB3aXRoIHRoZSBnaXZlbiBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21FcnJvcjxRdWVyeUNvbXBvbmVudD4oXG4gICAgICAgIGluc3RydWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIGVycm9yTWVzc2FnZTogc3RyaW5nLFxuICAgICk6IFF1ZXJ5Q29tcG9uZW50T3JFcnJvcjxRdWVyeUNvbXBvbmVudD4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVlcnlDb21wb25lbnRPckVycm9yPFF1ZXJ5Q29tcG9uZW50PihpbnN0cnVjdGlvbik7XG4gICAgICAgIHJlc3VsdC5fZXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFF1ZXJ5Q29tcG9uZW50T3JFcnJvciB9IGZyb20gJy4uL1F1ZXJ5Q29tcG9uZW50T3JFcnJvcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlciwgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogQSBjbGFzcyB3aGljaCBzdG9yZXMgb25lIG9mOlxuICogLSBUaGUgb3JpZ2luYWwgaW5zdHJ1Y3Rpb24gc3RyaW5nIC0gYSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrXG4gKiAtIEFuIG9wdGlvbmFsIHtAbGluayBGaWx0ZXJ9XG4gKiAtIEFuIG9wdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAqXG4gKiBUaGlzIGlzIHJlYWxseSBjdXJyZW50bHkgYSBjb252ZW5pZW5jZSBmb3IgcmV0dXJuaW5nIGRhdGEgZnJvbVxuICoge0BsaW5rIEZpZWxkLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKCl9IGFuZCBkZXJpdmVkIGNsYXNzZXMuXG4gKlxuICogQnkgdGhlIHRpbWUgdGhlIGNvZGUgaGFzIGZpbmlzaGVkIHdpdGggcGFyc2luZyB0aGUgbGluZSwgdHlwaWNhbGx5IHRoZVxuICogY29udGFpbmVkIHtAbGluayBGaWx0ZXJ9IHdpbGwgYmUgc2F2ZWQsIGZvciBsYXRlciB1c2UgaW4gc2VhcmNoaW5nIGZvciBUYXNrc1xuICogdGhhdCBtYXRjaCB0aGUgdXNlcidzIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICBwdWJsaWMgb2JqZWN0OiBRdWVyeUNvbXBvbmVudE9yRXJyb3I8RmlsdGVyPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3Iob2JqZWN0OiBRdWVyeUNvbXBvbmVudE9yRXJyb3I8RmlsdGVyPikge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGluc3RydWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5pbnN0cnVjdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpbHRlcigpOiBGaWx0ZXIgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QucXVlcnlDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5pc1ZhbGlkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlcnJvcigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuZXJyb3I7XG4gICAgfVxuXG4gICAgZ2V0IGZpbHRlckZ1bmN0aW9uKCk6IEZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZmlsdGVyRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgYSBtZWFuaW5nZnVsIHtAbGluayBFeHBsYW5hdGlvbn0gdG8gYmUgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gYSB7QGxpbmsgRmlsdGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUZpbHRlcihmaWx0ZXI6IEZpbHRlcik6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZShRdWVyeUNvbXBvbmVudE9yRXJyb3IuZnJvbU9iamVjdDxGaWx0ZXI+KGZpbHRlci5pbnN0cnVjdGlvbiwgZmlsdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tRXJyb3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgZXJyb3JNZXNzYWdlOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoUXVlcnlDb21wb25lbnRPckVycm9yLmZyb21FcnJvcjxGaWx0ZXI+KGluc3RydWN0aW9uLCBlcnJvck1lc3NhZ2UpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFN1YnN0cmluZ01hdGNoZXIgfSBmcm9tICcuLi9NYXRjaGVycy9TdWJzdHJpbmdNYXRjaGVyJztcbmltcG9ydCB7IFJlZ2V4TWF0Y2hlciB9IGZyb20gJy4uL01hdGNoZXJzL1JlZ2V4TWF0Y2hlcic7XG5pbXBvcnQgdHlwZSB7IElTdHJpbmdNYXRjaGVyIH0gZnJvbSAnLi4vTWF0Y2hlcnMvSVN0cmluZ01hdGNoZXInO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbiB9IGZyb20gJy4uLy4uL2xpYi9FeGNlcHRpb25Ub29scyc7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogVGV4dEZpZWxkIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdG8gaGVscCBpbXBsZW1lbnRcbiAqIGFsbCB0aGUgZmlsdGVyIGluc3RydWN0aW9ucyB0aGF0IGFjdCBvbiBhIHNpbmdsZSB0eXBlIG9mIHN0cmluZ1xuICogdmFsdWUsIHN1Y2ggYXMgdGhlIGRlc2NyaXB0aW9uIG9yIGZpbGUgcGF0aC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRleHRGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIEZpZWxkLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUoKSBoYXMgYmVlbiBjaGVja2VkLCB3ZSBzaG91bGQgbmV2ZXIgZ2V0XG4gICAgICAgICAgICAvLyBpbiB0byB0aGlzIGJsb2NrLlxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCBgZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZmlsdGVyICgke3RoaXMuZmllbGROYW1lKCl9KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGFuIElTdHJpbmdNYXRjaGVyIGZvciB0aGlzIGZpbHRlciwgb3IgcmV0dXJuXG4gICAgICAgIC8vIGlmIHRoZSBpbnB1dHMgYXJlIGludmFsaWQuXG4gICAgICAgIGNvbnN0IGZpbHRlck9wZXJhdG9yID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZmlsdGVyVmFsdWUgPSBtYXRjaFsyXTtcblxuICAgICAgICBsZXQgbWF0Y2hlcjogSVN0cmluZ01hdGNoZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGZpbHRlck9wZXJhdG9yLmluY2x1ZGVzKCdpbmNsdWRlJykpIHtcbiAgICAgICAgICAgIG1hdGNoZXIgPSBuZXcgU3Vic3RyaW5nTWF0Y2hlcihmaWx0ZXJWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyT3BlcmF0b3IuaW5jbHVkZXMoJ3JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IFJlZ2V4TWF0Y2hlci52YWxpZGF0ZUFuZENvbnN0cnVjdChmaWx0ZXJWYWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbignUGFyc2luZyByZWd1bGFyIGV4cHJlc3Npb24nLCBlKSArIGBcXG5cXG4ke1JlZ2V4TWF0Y2hlci5oZWxwTWVzc2FnZSgpfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgYEludmFsaWQgaW5zdHJ1Y3Rpb246ICcke2xpbmV9J1xcblxcbiR7UmVnZXhNYXRjaGVyLmhlbHBNZXNzYWdlKCl9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgbGlrZWx5IHRoaXMgY2FuIG5vdyBuZXZlciBiZSByZWFjaGVkLlxuICAgICAgICAgICAgLy8gUmV0YWluZWQgZm9yIHNhZmV0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgYGRvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAoJHt0aGlzLmZpZWxkTmFtZSgpfSlgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGNhbiBjcmVhdGUgdGhlIEZpbHRlciwgdGhhdCB0YWtlcyBhIHRhc2tcbiAgICAgICAgLy8gYW5kIHRlc3RzIGlmIGl0IG1hdGNoZXMgdGhlIHN0cmluZyBmaWx0ZXJpbmcgcnVsZVxuICAgICAgICAvLyByZXByZXNlbnRlZCBieSB0aGlzIG9iamVjdC5cbiAgICAgICAgY29uc3QgbmVnYXRlID0gZmlsdGVyT3BlcmF0b3IubWF0Y2goL25vdC8pICE9PSBudWxsO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBuZXcgRmlsdGVyKGxpbmUsIHRoaXMuZ2V0RmlsdGVyKG1hdGNoZXIsIG5lZ2F0ZSksIG1hdGNoZXIuZXhwbGFuYXRpb24obGluZSkpO1xuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWdleHAgcGF0dGVybiBtYXRjaGluZyB0aGUgZmllbGQncyBuYW1lIGFuZCBwb3NzaWJsZSBhbGlhc2VzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpZWxkUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVnZXhwIHBhdHRlcm4gbWF0Y2hpbmcgYWxsIHBvc3NpYmxlIGZpbHRlciBvcGVyYXRvcnMgZm9yIHRoaXMgZmllbGQsXG4gICAgICogc3VjaCBhcyBcImluY2x1ZGVzXCIgb3IgXCJkb2VzIG5vdCBpbmNsdWRlXCIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpbHRlck9wZXJhdG9yUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2luY2x1ZGVzfGRvZXMgbm90IGluY2x1ZGV8cmVnZXggbWF0Y2hlc3xyZWdleCBkb2VzIG5vdCBtYXRjaCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OiR7dGhpcy5maWVsZFBhdHRlcm4oKX0pICgke3RoaXMuZmlsdGVyT3BlcmF0b3JQYXR0ZXJuKCl9KSAoLiopYCwgJ2knKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgZmllbGROYW1lKCk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpZWxkJ3MgdmFsdWUsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgdmFsdWUgaXMgbnVsbFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nO1xuXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlcihtYXRjaGVyOiBJU3RyaW5nTWF0Y2hlciwgbmVnYXRlOiBib29sZWFuKTogRmlsdGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlciEubWF0Y2hlcyh0aGlzLnZhbHVlKHRhc2spKTtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGUgPyAhbWF0Y2ggOiBtYXRjaDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Ygc29ydGluZywgZm9yIHRleHQgZmllbGRzIHdoZXJlIHNpbXBsZSBsb2NhbGUtYXdhcmUgc29ydGluZyBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIGJlaGF2aW91ci5cbiAgICAgKlxuICAgICAqIEVhY2ggY2xhc3MgdGhhdCB3YW50cyB0byB1c2UgdGhpcyB3aWxsIG5lZWQgdG8gb3ZlcnJpZGUgc3VwcG9ydHNTb3J0aW5nKCkgdG8gcmV0dXJuIHRydWUsXG4gICAgICogdG8gdHVybiBvbiBzb3J0aW5nLlxuICAgICAqL1xuICAgIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoYSkubG9jYWxlQ29tcGFyZSh0aGlzLnZhbHVlKGIpLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgZ3JvdXBpbmcsIGZvciB0ZXh0IGZpZWxkcyB3aGVyZSBzaW1wbGUgZ3JvdXBpbmcgYnkgZmllbGQgdmFsdWUgaXMgdGhlXG4gICAgICogZGVzaXJlZCBiZWhhdmlvdXIuXG4gICAgICpcbiAgICAgKiBFYWNoIGNsYXNzIHRoYXQgd2FudHMgdG8gdXNlIHRoaXMgd2lsbCBuZWVkIHRvIG92ZXJyaWRlIHN1cHBvcnRzR3JvdXBpbmcoKSB0byByZXR1cm4gdHJ1ZSxcbiAgICAgKiB0byB0dXJuIG9uIGdyb3VwaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnZhbHVlKHRhc2spXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyhmaWxlbmFtZTogc3RyaW5nKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd2lsc29ubWFyLmdpdGh1Yi5pby9tYXJrZG93bi10ZXh0LWZvci1naXRodWItZnJvbS1odG1sLyNzcGVjaWFsLWNoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXy9nLCAnXFxcXF8nKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi4vLi4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdkZXNjcmlwdGlvbicgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBEZXNjcmlwdGlvbkZpZWxkLnZhbHVlKCkgcmV0dXJucyB0aGUgZGVzY3JpcHRpb25cbiAqIHdpdGggdGhlIGdsb2JhbCBmaWx0ZXIgKGlmIGFueSkgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlc2NyaXB0aW9uRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdkZXNjcmlwdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrJ3MgZGVzY3JpcHRpb24sIHdpdGggYW55IGdsb2JhbCB0YWcgcmVtb3ZlZFxuICAgICAqXG4gICAgICogUHJvbW90ZWQgdG8gcHVibGljLCB0byBlbmFibGUgdGVzdGluZy5cbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIC8vIFJlbW92ZSBnbG9iYWwgZmlsdGVyIGZyb20gZGVzY3JpcHRpb24gbWF0Y2ggaWYgcHJlc2VudC5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWF0Y2ggb25seSBvbiB0aGUgY29udGVudCBvZiB0aGUgdGFzaywgbm90XG4gICAgICAgIC8vIHRoZSBnbG9iYWwgZmlsdGVyLlxuICAgICAgICByZXR1cm4gR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkucmVtb3ZlQXNTdWJzdHJpbmdGcm9tKHRhc2suZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdGhlIGRlc2NyaXB0aW9uIGJ5IGhvdyBpdCBpcyByZW5kZXJlZCBpbiBtYXJrZG93bi5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHVzZSB0aGUgTWFya2Rvd25SZW5kZXJlciwgYnV0IHRyaWVzIHRvIG1hdGNoIHJlZ2V4ZXMgaW5zdGVhZFxuICAgICAqIGluIG9yZGVyIHRvIGJlIHNpbXBsZXIsIGZhc3RlciwgYW5kIG5vdCBhc3luYy5cbiAgICAgKlxuICAgICAqIE9ubHkgc2VhcmNoZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkZXNjcmlwdGlvbi4gTWFya2Rvd24gbGF0ZXIgaW4gdGhlIHRhayBpcyB1bmNoYW5nZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25BID0gRGVzY3JpcHRpb25GaWVsZC5jbGVhbkRlc2NyaXB0aW9uKGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25CID0gRGVzY3JpcHRpb25GaWVsZC5jbGVhbkRlc2NyaXB0aW9uKGIuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uQS5sb2NhbGVDb21wYXJlKGRlc2NyaXB0aW9uQiwgdW5kZWZpbmVkLCB7IG51bWVyaWM6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBgKmAsIGA9YCwgYW5kIGBbYCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV2lsbCByZW1vdmUgdGhlbSBvbmx5IGlmIHRoZXkgYXJlIGNsb3NpbmcuXG4gICAgICogUHJvcGVybHkgcmVhZHMgbGlua3MgW1tsaWtlIHRoaXN8b25lXV0gKG5vdGUgcGlwZSkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjbGVhbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBkZXNjcmlwdGlvbiA9IEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnJlbW92ZUFzU3Vic3RyaW5nRnJvbShkZXNjcmlwdGlvbik7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRzV2l0aExpbmtSZWdleCA9IC9eXFxbXFxbPyhbXlxcXV0qKV1dPy87XG4gICAgICAgIGNvbnN0IGxpbmtSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2goc3RhcnRzV2l0aExpbmtSZWdleCk7XG4gICAgICAgIGlmIChsaW5rUmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXJMaW5rVGV4dCA9IGxpbmtSZWdleE1hdGNoWzFdO1xuICAgICAgICAgICAgLy8gRm9yIGEgbGluaywgd2UgaGF2ZSB0byBjaGVjayB3aGV0aGVyIGl0IGhhcyBhbm90aGVyIHZpc2libGUgbmFtZSBzZXQuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSBgW1t0aGlzIGlzIHRoZSBsaW5rfGJ1dCB0aGlzIGlzIGFjdHVhbGx5IHNob3duXV1gLlxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIGlubmVyTGlua1RleHQuc3Vic3RyaW5nKGlubmVyTGlua1RleHQuaW5kZXhPZignfCcpICsgMSkgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHN0YXJ0c1dpdGhMaW5rUmVnZXgsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCpcXCooW14qXSspXFwqXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCooW14qXSspXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL149PShbXj1dKyk9PS8pO1xuICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMucmVwbGFjZUZvcm1hdHRpbmcoZGVzY3JpcHRpb24sIC9eX18oW15fXSspX18vKTtcbiAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLnJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uLCAvXl8oW15fXSspXy8pO1xuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc29tZSBmb3JtYXR0aW5nIGZyb20gdGV4dFxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSByZWdFeHAgQSByZWd1bGFyIGV4cHJlc3Npb24gLSBhbGwgbWF0Y2hpbmcgdGV4dCBpcyBkaXNjYXJkZWQgZXhjZXB0IHRoZSBmaXJzdCBncm91cFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHJlZ0V4cDogUmVnRXhwKSB7XG4gICAgICAgIGNvbnN0IGl0YWxpY0JvbGRSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgaWYgKGl0YWxpY0JvbGRSZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckl0YWxpY0JvbGRUZXh0ID0gaXRhbGljQm9sZFJlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGlubmVySXRhbGljQm9sZFRleHQgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHJlZ0V4cCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byBoZWxwIFRhc2tzIHF1ZXJpZXMgdmFsaWRhdGUgc2VhcmNoIGluc3RydWN0aW9uc1xuICogZm9yIGFueSB1bndhbnRlZCB0ZW1wbGF0ZSB0ZXh0LlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGluZ1BsdWdpblRvb2xzIHtcbiAgICBwdWJsaWMgZmluZFVuZXhwYW5kZWREYXRlVGV4dChsaW5lOiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVUZXh0cyA9IFsnPCUnLCAnWVlZWS1NTS1ERCddO1xuICAgICAgICBmb3IgKGNvbnN0IHRlbXBsYXRlVGV4dCBvZiB0ZW1wbGF0ZVRleHRzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcyh0ZW1wbGF0ZVRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5leHBhbmRlZERhdGVUZXh0TWVzc2FnZSh0ZW1wbGF0ZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5leHBhbmRlZERhdGVUZXh0TWVzc2FnZSh0ZW1wbGF0ZVRleHQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gYEluc3RydWN0aW9uIGNvbnRhaW5zIHVuZXhwYW5kZWQgdGVtcGxhdGUgdGV4dDogXCIke3RlbXBsYXRlVGV4dH1cIiAtIGFuZCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQuXG5cblBvc3NpYmxlIGNhdXNlczpcbi0gVGhlIHF1ZXJ5IGlzIGFuIGEgdGVtcGxhdGUgZmlsZSwgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBzZWFyY2hlZC5cbi0gQSBjb21tYW5kIHN1Y2ggYXMgXCJSZXBsYWNlIHRlbXBsYXRlcyBpbiB0aGUgYWN0aXZlIGZpbGVcIiBuZWVkcyB0byBiZSBydW4uXG4tIFRoZSBjb3JlIFwiRGFpbHkgbm90ZXNcIiBwbHVnaW4gaXMgaW4gdXNlLCBhbmQgdGhlIHRlbXBsYXRlIGNvbnRhaW5lZFxuICBkYXRlIGNhbGN1bGF0aW9ucyB0aGF0IGl0IGRvZXMgbm90IHN1cHBvcnQuXG4tIFNvbWUgc2FtcGxlIHRlbXBsYXRlIHRleHQgd2FzIGFjY2lkZW50YWxseSBwYXN0ZWQgaW4gdG8gYSB0YXNrcyBxdWVyeSxcbiAgaW5zdGVhZCBvZiBpbiB0byBhIHRlbXBsYXRlIGZpbGUuXG5cblNlZTogaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL0FkdmFuY2VkL0luc3RydWN0aW9uK2NvbnRhaW5zK3VuZXhwYW5kZWQrdGVtcGxhdGUrdGV4dFxuYDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgc2luZ2xlIGluc3RydWN0aW9uIGZvciBmaWx0ZXJpbmcgdGFza3MsIGFuZCBpdHMgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUuXG4gKlxuICogVGhpcyBpcyByZWFsbHkgYSBoZWxwZXIgdG8gc2ltcGxpZnkgdGhlIGltcGxlbWVudGF0aW9uIG9mIGluZGl2aWR1YWwgZmlsdGVyXG4gKiBpbnN0cnVjdGlvbnMsIGhpZGluZyBhd2F5IHRoZSBkZXRhaWxzIG9mIHBhcnNpbmcgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbiBsaW5lcy5cbiAqXG4gKiBUaGlzIHdpbGwgdXN1YWxseSBiZSBhY2Nlc3NlZCB2aWEge0BsaW5rIEZpbHRlckluc3RydWN0aW9ucy5hZGR9XG4gKlxuICogQHNlZSBGaWx0ZXJJbnN0cnVjdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlckluc3RydWN0aW9uIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnN0cnVjdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpbHRlcjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvcjpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gLSBGdWxsIHRleHQgb2YgdGhlIGluc3RydWN0aW9uIGZvciB0aGUgZmlsdGVyOiBtdXN0IGJlIG1hdGNoZWQgZXhhY3RseSwgaWdub3JpbmcgY2FwaXRhbGlzYXRpb24uXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluc3RydWN0aW9uOiBzdHJpbmcsIGZpbHRlcjogRmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5faW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gbGluZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0aGlzLl9pbnN0cnVjdGlvbi50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRmlsdGVyKG5ldyBGaWx0ZXIobGluZSwgdGhpcy5fZmlsdGVyLCBuZXcgRXhwbGFuYXRpb24obGluZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgYGRvIG5vdCB1bmRlcnN0YW5kIGZpbHRlcjogJHtsaW5lfWApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbiB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb24nO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBjb2xsZWN0aW9uIG9mIGluc3RydWN0aW9ucyBmb3IgZmlsdGVyaW5nIHRhc2tzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgcHJpdmF0ZSByZWFkb25seSBfZmlsdGVycyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcbiAqICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCk7XG4gKlxuICogQHNlZSBGaWx0ZXJJbnN0cnVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySW5zdHJ1Y3Rpb25zIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9maWx0ZXJzOiBGaWx0ZXJJbnN0cnVjdGlvbltdID0gW107XG5cbiAgICBwdWJsaWMgYWRkKGluc3RydWN0aW9uOiBzdHJpbmcsIGZpbHRlcjogRmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5wdXNoKG5ldyBGaWx0ZXJJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZmlsdGVyKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuX2ZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gZmlsdGVyLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHguZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCBgZG8gbm90IHVuZGVyc3RhbmQgZmlsdGVyOiAke2xpbmV9YCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL0RhdGVSYW5nZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnQvU29ydGVyJztcbmltcG9ydCB7IGNvbXBhcmVCeURhdGUgfSBmcm9tICcuLi8uLi9saWIvRGF0ZVRvb2xzJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBUZW1wbGF0aW5nUGx1Z2luVG9vbHMgfSBmcm9tICcuLi8uLi9saWIvVGVtcGxhdGluZ1BsdWdpblRvb2xzJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXIsIHR5cGUgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnMgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG5leHBvcnQgdHlwZSBEYXRlRmlsdGVyRnVuY3Rpb24gPSAoZGF0ZTogTW9tZW50IHwgbnVsbCkgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBEYXRlRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0byBoZWxwIGltcGxlbWVudFxuICogYWxsIHRoZSBmaWx0ZXIgaW5zdHJ1Y3Rpb25zIHRoYXQgYWN0IG9uIGEgc2luZ2xlIHR5cGUgb2YgZGF0ZVxuICogdmFsdWUsIHN1Y2ggYXMgdGhlIGRvbmUgZGF0ZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGVGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZmlsdGVySW5zdHJ1Y3Rpb25zOiBGaWx0ZXJJbnN0cnVjdGlvbnM7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJJbnN0cnVjdGlvbnM6IEZpbHRlckluc3RydWN0aW9ucyB8IG51bGwgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChmaWx0ZXJJbnN0cnVjdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zID0gZmlsdGVySW5zdHJ1Y3Rpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYGhhcyAke3RoaXMuZmllbGROYW1lKCl9IGRhdGVgLCAodGFzazogVGFzaykgPT4gdGhpcy5kYXRlKHRhc2spICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZChgbm8gJHt0aGlzLmZpZWxkTmFtZSgpfSBkYXRlYCwgKHRhc2s6IFRhc2spID0+IHRoaXMuZGF0ZSh0YXNrKSA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYCR7dGhpcy5maWVsZE5hbWUoKX0gZGF0ZSBpcyBpbnZhbGlkYCwgKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlKHRhc2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlICE9PSBudWxsICYmICFkYXRlLmlzVmFsaWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckluc3RydWN0aW9ucy5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIC8vIFRoZXJlIGhhdmUgYmVlbiBtdWx0aXBsZSBcImJ1ZyByZXBvcnRzXCIsIHdoZXJlIHRoZSBxdWVyeSBoYWQgdW4tZXhwYW5kZWRcbiAgICAgICAgLy8gdGVtcGxhdGUgdGV4dCB0byBzaWduaWZ5IHRoZSBzZWFyY2ggZGF0ZS5cbiAgICAgICAgLy8gRW5vdWdoIHRvIGV4cGxpY2l0bHkgdHJhcCBhbnkgc3VjaCB0ZXh0IGZvciBkYXRlIHNlYXJjaGVzOlxuICAgICAgICBjb25zdCBlcnJvclRleHQgPSB0aGlzLmNoZWNrRm9yVW5leHBhbmRlZFRlbXBsYXRlVGV4dChsaW5lKTtcbiAgICAgICAgaWYgKGVycm9yVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCBlcnJvclRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyUmVzdWx0ID0gdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGROYW1lS2V5d29yZERhdGUgPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmZpbHRlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKGZpZWxkTmFtZUtleXdvcmREYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKFxuICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAoJyArIHRoaXMuZmllbGROYW1lKCkgKyAnIGRhdGUpJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXl3b3JkQW5kRGF0ZVN0cmluZyA9IGZpZWxkTmFtZUtleXdvcmREYXRlWzFdOyAvLyBUaGUgd2hvbGUgbGluZSBleGNlcHQgdGhlIGZpZWxkIG5hbWVcbiAgICAgICAgY29uc3QgZmllbGRLZXl3b3JkID0gZmllbGROYW1lS2V5d29yZERhdGVbMl0/LnRvTG93ZXJDYXNlKCk7IC8vICdvbicsICdpbicsICdiZWZvcmUnLCAnYWZ0ZXInLCAnb258aW4gb3IgYmVmb3JlfGFmdGVyJyBvciB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgZmllbGREYXRlU3RyaW5nID0gZmllbGROYW1lS2V5d29yZERhdGVbM107IC8vIFRoZSByZW1haW5kZXIgb2YgdGhlIGluc3RydWN0aW9uXG5cbiAgICAgICAgLy8gVHJ5IGludGVycHJldGluZyBldmVyeXRoaW5nIGFmdGVyIHRoZSBrZXl3b3JkIGFzIGEgZGF0ZSByYW5nZTpcbiAgICAgICAgbGV0IGZpZWxkRGF0ZXMgPSBEYXRlUGFyc2VyLnBhcnNlRGF0ZVJhbmdlKGZpZWxkRGF0ZVN0cmluZyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGRhdGUgcmFuZ2UgcGFyc2luZyBmYWlsZWQsIHRyeSBhZ2FpbiB0byBwYXJzZSB0aGUgd2hvbGUgbGluZSBleGNlcHQgdGhlIGZpZWxkIG5hbWVcbiAgICAgICAgLy8gYXMgYSBzaW5nbGUgZGF0ZSwgdXNpbmcgdGhlIHByZS1kYXRlLXJhbmdlcyBwYXJzaW5nIG1lY2hhbmlzbS5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8ga2VlcCAnZHVlIGluIHR3byB3ZWVrcycgd29ya2luZywgYXMgJ3R3byB3ZWVrcycgaXMgbm90IGFjdHVhbGx5IGEgdmFsaWQgZGF0ZSByYW5nZVxuICAgICAgICAvLyBpZiB0aGUgZnV0dXJlRGF0ZXMgdmFsdWUgcGFzc2VkIGluIHRvIGNocm9ubydzIHBhcnNpbmcgZnVuY3Rpb25zIGlzIGZhbHNlLlxuICAgICAgICBpZiAoIWZpZWxkRGF0ZXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gRGF0ZVBhcnNlci5wYXJzZURhdGUoa2V5d29yZEFuZERhdGVTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKGRhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgZmllbGREYXRlcyA9IG5ldyBEYXRlUmFuZ2UoZGF0ZSwgZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpZWxkRGF0ZXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsICdkbyBub3QgdW5kZXJzdGFuZCAnICsgdGhpcy5maWVsZE5hbWUoKSArICcgZGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyRnVuY3Rpb24gPSB0aGlzLmJ1aWxkRmlsdGVyRnVuY3Rpb24oZmllbGRLZXl3b3JkLCBmaWVsZERhdGVzKTtcblxuICAgICAgICBjb25zdCBleHBsYW5hdGlvbiA9IERhdGVGaWVsZC5idWlsZEV4cGxhbmF0aW9uKFxuICAgICAgICAgICAgdGhpcy5maWVsZE5hbWVGb3JFeHBsYW5hdGlvbigpLFxuICAgICAgICAgICAgZmllbGRLZXl3b3JkLFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpLFxuICAgICAgICAgICAgZmllbGREYXRlcyxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21GaWx0ZXIobmV3IEZpbHRlcihsaW5lLCBmaWx0ZXJGdW5jdGlvbiwgZXhwbGFuYXRpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgZnVuY3Rpb24gdGhhdCBhY3R1YWxseSBmaWx0ZXJzIHRoZSB0YXNrcyBkZXBlbmRpbmcgb24gdGhlIGRhdGVcbiAgICAgKiBAcGFyYW0gZmllbGRLZXl3b3JkIHJlbGF0aW9uc2hpcCB0byBiZSBoZWxkIHdpdGggdGhlIGRhdGUgJ2JlZm9yZScsICdhZnRlcidcbiAgICAgKiBAcGFyYW0gZmllbGREYXRlcyB0aGUgZGF0ZSByYW5nZSB0byBiZSB1c2VkIGJ5IHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCBmaWx0ZXJzIHRoZSB0YXNrc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBidWlsZEZpbHRlckZ1bmN0aW9uKGZpZWxkS2V5d29yZDogc3RyaW5nLCBmaWVsZERhdGVzOiBEYXRlUmFuZ2UpOiBGaWx0ZXJGdW5jdGlvbiB7XG4gICAgICAgIGxldCBkYXRlRmlsdGVyOiBEYXRlRmlsdGVyRnVuY3Rpb247XG4gICAgICAgIHN3aXRjaCAoZmllbGRLZXl3b3JkKSB7XG4gICAgICAgICAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgICAgICAgICAgIGRhdGVGaWx0ZXIgPSAoZGF0ZSkgPT4gKGRhdGUgPyBkYXRlLmlzQmVmb3JlKGZpZWxkRGF0ZXMuc3RhcnQpIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICAgICAgICBkYXRlRmlsdGVyID0gKGRhdGUpID0+IChkYXRlID8gZGF0ZS5pc0FmdGVyKGZpZWxkRGF0ZXMuZW5kKSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvbiBvciBiZWZvcmUnOlxuICAgICAgICAgICAgY2FzZSAnaW4gb3IgYmVmb3JlJzpcbiAgICAgICAgICAgICAgICAvLyAnb24gb3IgYmVmb3JlJy8naW4gb3IgYmVmb3JlJyBhIGRhdGUgcmFuZ2UgdXNlcyB0aGUgZW5kIG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBzZWFyY2ggbGltaXQsIHNvIHRoYXQgaXQgbWF0Y2hlcyBldmVyeSBkYXRlIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGluY2x1c2l2ZSBkYXRlIHJhbmdlLCBhbmQgYWxsIGRhdGVzIGJlZm9yZSB0aGUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgZGF0ZUZpbHRlciA9IChkYXRlKSA9PiAoZGF0ZSA/IGRhdGUuaXNTYW1lT3JCZWZvcmUoZmllbGREYXRlcy5lbmQpIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29uIG9yIGFmdGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2luIG9yIGFmdGVyJzpcbiAgICAgICAgICAgICAgICAvLyAnb24gb3IgYWZ0ZXInLydpbiBvciBhZnRlcicgYSBkYXRlIHJhbmdlIHVzZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgc2VhcmNoIGxpbWl0LCBzbyB0aGF0IGl0IG1hdGNoZXMgZXZlcnkgZGF0ZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbmNsdXNpdmUgZGF0ZSByYW5nZSwgYW5kIGFsbCBkYXRlcyBhZnRlciB0aGUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgZGF0ZUZpbHRlciA9IChkYXRlKSA9PlxuICAgICAgICAgICAgICAgICAgICBkYXRlID8gZGF0ZS5pc1NhbWVPckFmdGVyKGZpZWxkRGF0ZXMuc3RhcnQpIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkYXRlRmlsdGVyID0gKGRhdGUpID0+XG4gICAgICAgICAgICAgICAgICAgIGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0ZS5pc1NhbWVPckFmdGVyKGZpZWxkRGF0ZXMuc3RhcnQpICYmIGRhdGUuaXNTYW1lT3JCZWZvcmUoZmllbGREYXRlcy5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXIoZGF0ZUZpbHRlcik7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlcihkYXRlRmlsdGVyRnVuY3Rpb246IERhdGVGaWx0ZXJGdW5jdGlvbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlckZ1bmN0aW9uKHRoaXMuZGF0ZSh0YXNrKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgIGBeJHt0aGlzLmZpZWxkTmFtZUZvckZpbHRlckluc3RydWN0aW9uKCl9ICgoKD86b258aW4pIG9yIGJlZm9yZXxiZWZvcmV8KD86b258aW4pIG9yIGFmdGVyfGFmdGVyfG9ufGluKT8gPyguKikpYCxcbiAgICAgICAgICAgICdpJyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgc3VwcG9ydCBmb3IgJ3N0YXJ0cyAuLi4nIGFzIGZpbHRlciB3aGVyZSB0aGUgZmllbGQgbmFtZSBpcyBkaWZmZXJlbnQgKCdzdGFydCcpLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaWVsZE5hbWVGb3JGaWx0ZXJJbnN0cnVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE5hbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRhc2sncyB2YWx1ZSBmb3IgdGhpcyBkYXRlIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHRhc2sgLSBhIFRhc2sgb2JqZWN0XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBFeHBsYW5hdGlvbiBmb3IgYSBkYXRlLWJhc2VkIGZpbHRlclxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWUgLSBmb3IgZXhhbXBsZSwgJ2R1ZSdcbiAgICAgKiBAcGFyYW0gZmllbGRLZXl3b3JkIC0gb25lIG9mIHRoZSBrZXl3b3JkcyBsaWtlICdiZWZvcmUnIG9yICdhZnRlcidcbiAgICAgKiBAcGFyYW0gZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcgLSB3aGV0aGVyIHRoZSBzZWFyY2ggbWF0Y2hlcyB0YXNrcyB3aXRob3V0IHRoZSByZXF1ZXN0ZWQgZGF0ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBmaWx0ZXJEYXRlcyAtIHRoZSBkYXRlIHJhbmdlIHVzZWQgaW4gdGhlIGZpbHRlclxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYnVpbGRFeHBsYW5hdGlvbihcbiAgICAgICAgZmllbGROYW1lOiBzdHJpbmcsXG4gICAgICAgIGZpZWxkS2V5d29yZDogc3RyaW5nLFxuICAgICAgICBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZzogYm9vbGVhbixcbiAgICAgICAgZmlsdGVyRGF0ZXM6IERhdGVSYW5nZSxcbiAgICApOiBFeHBsYW5hdGlvbiB7XG4gICAgICAgIGxldCByZWxhdGlvbnNoaXAgPSBmaWVsZEtleXdvcmQ7XG4gICAgICAgIC8vIEV4YW1wbGUgb2YgZm9ybWF0dGVkIGRhdGU6ICcyMDI0LTAxLTAyIChUdWVzZGF5IDJuZCBKYW51YXJ5IDIwMjQpJ1xuICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gJ1lZWVktTU0tREQgKGRkZGQgRG8gTU1NTSBZWVlZKSc7XG4gICAgICAgIGxldCBleHBsYW5hdGlvbkRhdGVzO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkS2V5d29yZCkge1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgIGNhc2UgJ29uIG9yIGFmdGVyJzpcbiAgICAgICAgICAgICAgICAvLyAnYmVmb3JlIDxkYXRlIHJhbmdlPicgYW5kICdvbiBvciBhZnRlciA8ZGF0ZSByYW5nZT4nIHJlZmVyZW5jZSB0aGUgU3RhcnQgb2YgdGhlIHJhbmdlOlxuICAgICAgICAgICAgICAgIC8vICAtICdiZWZvcmUgdGhpcyB3ZWVrJyBpcyBiZWZvcmUgdGhlIE1vbmRheVxuICAgICAgICAgICAgICAgIC8vICAtICdvbiBvciBhZnRlciB0aGlzIHdlZWsnIGlzIHN0YXJ0aW5nIGZyb20gTW9uZGF5IGluY2x1c2l2ZS5cbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbkRhdGVzID0gZmlsdGVyRGF0ZXMuc3RhcnQuZm9ybWF0KGRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgY2FzZSAnb24gb3IgYmVmb3JlJzpcbiAgICAgICAgICAgICAgICAvLyAnYWZ0ZXIgPGRhdGUgcmFuZ2U+JyBhbmQgJ29uIG9yIGJlZm9yZSA8ZGF0ZSByYW5nZT4nIHJlZmVyZW5jZSB0aGUgRW5kIG9mIHRoZSByYW5nZTpcbiAgICAgICAgICAgICAgICAvLyAgLSAnYWZ0ZXIgdGhpcyBtb250aCcgaXMgYWZ0ZXIgdGhlIGxhc3QgZGF5IG9mIHRoaXMgbW9udGhcbiAgICAgICAgICAgICAgICAvLyAgLSAnb24gb3IgYmVmb3JlIHRoaXMgbW9udGgnIGlzIGJlZm9yZSB0aGUgbGFzdCBkYXkgb2YgdGhpcyBtb250aCBpbmNsdXNpdmUuXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb25EYXRlcyA9IGZpbHRlckRhdGVzLmVuZC5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbiBvciBiZWZvcmUnOlxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcCA9ICdvbiBvciBiZWZvcmUnO1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uRGF0ZXMgPSBmaWx0ZXJEYXRlcy5lbmQuZm9ybWF0KGRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW4gb3IgYWZ0ZXInOlxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcCA9ICdvbiBvciBhZnRlcic7XG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb25EYXRlcyA9IGZpbHRlckRhdGVzLnN0YXJ0LmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJEYXRlcy5zdGFydC5pc1NhbWUoZmlsdGVyRGF0ZXMuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIGEgbXVsdGktbGluZSBleHBsYW5hdGlvbiBoYXMgdG8gYmUgYnVpbHRcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG90aGVyIGNhc2VzIG5lZWQgb25seSBvbmUgbGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBgJHtmaWVsZE5hbWV9IGRhdGUgaXMgYmV0d2VlbjpgO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNlY3V0aXZlIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YkV4cGxhbmF0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFeHBsYW5hdGlvbihgJHtmaWx0ZXJEYXRlcy5zdGFydC5mb3JtYXQoZGF0ZUZvcm1hdCl9IGFuZGApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEV4cGxhbmF0aW9uKGAke2ZpbHRlckRhdGVzLmVuZC5mb3JtYXQoZGF0ZUZvcm1hdCl9IGluY2x1c2l2ZWApLFxuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIGxpbmUgZm9yIFN0YXJ0RGF0ZUZpZWxkIChzbyBmYXIpXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViRXhwbGFuYXRpb25zLnB1c2gobmV3IEV4cGxhbmF0aW9uKGBPUiBubyAke2ZpZWxkTmFtZX0gZGF0ZWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oZmlyc3RMaW5lLCBzdWJFeHBsYW5hdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcCA9ICdvbic7XG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb25EYXRlcyA9IGZpbHRlckRhdGVzLnN0YXJ0LmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvbmVMaW5lRXhwbGFuYXRpb24gPSBgJHtmaWVsZE5hbWV9IGRhdGUgaXMgJHtyZWxhdGlvbnNoaXB9ICR7ZXhwbGFuYXRpb25EYXRlc31gO1xuICAgICAgICBpZiAoZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcpIHtcbiAgICAgICAgICAgIG9uZUxpbmVFeHBsYW5hdGlvbiArPSBgIE9SIG5vICR7ZmllbGROYW1lfSBkYXRlYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKG9uZUxpbmVFeHBsYW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZUZvckV4cGxhbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE5hbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIHRhc2sgdGhhdCBkb2VzIG5vdCBoYXZlIHRoZSBwYXJ0aWN1bGFyIGRhdGUgdmFsdWVcbiAgICAgKiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIG1hdGNoLiBGb3IgZXhhbXBsZSwgJ3N0YXJ0cycgc2VhcmNoZXMgbWF0Y2ggYWxsIHRhc2tzXG4gICAgICogdGhhdCBoYXZlIG5vIHN0YXJ0IGRhdGUsIHdoaWNoIGJlaGF2ZXMgZGlmZmVyZW50bHkgZnJvbSAnZHVlJywgJ2RvbmUnIGFuZFxuICAgICAqICdzY2hlZHVsZWQnIHNlYXJjaGVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTogYm9vbGVhbjtcblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQnlEYXRlKHRoaXMuZGF0ZShhKSwgdGhpcy5kYXRlKGIpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlKHRhc2spO1xuICAgICAgICAgICAgaWYgKGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydObyAnICsgdGhpcy5maWVsZE5hbWUoKSArICcgZGF0ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjb21tZW50LW91dCB0ZXh0IHRvIGZvcmNlIEludmFsaWQgZGF0ZXMgdG8gYmUgc29ydGVkIGJlZm9yZSB0aGUgb3RoZXIgaGVhZGluZ3MuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgaGVhZGluZyBpcyByZW5kZXJlZCBieSBPYnNpZGlhbiwgdGhlIGNvbW1lbnQgd2lsbCBiZSBpbnZpc2libGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnJSUwJSUgSW52YWxpZCAnICsgdGhpcy5maWVsZE5hbWUoKSArICcgZGF0ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCBkZGRkJyldO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tGb3JVbmV4cGFuZGVkVGVtcGxhdGVUZXh0KGxpbmU6IHN0cmluZyk6IG51bGwgfCBzdHJpbmcge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRpbmdQbHVnaW5Ub29scygpLmZpbmRVbmV4cGFuZGVkRGF0ZVRleHQobGluZSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2NyZWF0ZWQnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENyZWF0ZWREYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdjcmVhdGVkJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5jcmVhdGVkRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2RvbmUnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIERvbmVEYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdkb25lJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5kb25lRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2R1ZScgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRHVlRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZHVlJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5kdWVEYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAncmVtaW5kZXInIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbWluZGVyRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAncmVtaW5kZXInO1xuICAgIH1cbiAgICBwdWJsaWMgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0YXNrLnJlbWluZGVyRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnMgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgaW1wbGVtZW50cyBvZiB7QGxpbmsgRmllbGR9XG4gKlxuICogVGhlIG5hbWVkIG9mIHRoZSBjbGFzcyBpcyB3ZWFrLiBJdCBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGZhY3QgdGhhdCB0aGVcbiAqIGNsYXNzIGlzIGVudGlyZWx5IGltcGxlbWVudGVkIHZpYSB0aGUge0BsaW5rIEZpbHRlckluc3RydWN0aW9uc30gY2xhc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfZmlsdGVycyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycy5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzICdleGNsdWRlIHN1Yi1pdGVtcycgZmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBFeGNsdWRlU3ViSXRlbXNGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdleGNsdWRlIHN1Yi1pdGVtcycsICh0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5pbmRlbnRhdGlvbiA9PT0gJycpIHJldHVybiB0cnVlOyAvLyBubyBpbmRlbnRhdGlvbiwgbm90IGEgc3ViaXRlbVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0QmxvY2txdW90ZU1hcmsgPSB0YXNrLmluZGVudGF0aW9uLmxhc3RJbmRleE9mKCc+Jyk7XG4gICAgICAgICAgICBpZiAobGFzdEJsb2NrcXVvdGVNYXJrID09PSAtMSkgcmV0dXJuIGZhbHNlOyAvLyBpbmRlbnRhdGlvbiBwcmVzZW50LCBub3QgaW4gYSBibG9ja3F1b3RlLCBzdWJpdGVtXG5cbiAgICAgICAgICAgIC8vIFVwIHRvIG9uZSBzcGFjZSBhbGxvd2VkIGFmdGVyIGxhc3QgPiBpbiBibG9ja3F1b3RlL2NhbGxvdXQsIG90aGVyd2lzZSBzdWJpdGVtXG4gICAgICAgICAgICByZXR1cm4gL14gPyQvLnRlc3QodGFzay5pbmRlbnRhdGlvbi5zbGljZShsYXN0QmxvY2txdW90ZU1hcmsgKyAxKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdleGNsdWRlJztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUXVlcnlDb21wb25lbnRPckVycm9yIH0gZnJvbSAnLi4vUXVlcnkvUXVlcnlDb21wb25lbnRPckVycm9yJztcbmltcG9ydCB7IGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbiB9IGZyb20gJy4uL2xpYi9FeGNlcHRpb25Ub29scyc7XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbk9yRXJyb3IgZXh0ZW5kcyBRdWVyeUNvbXBvbmVudE9yRXJyb3I8RnVuY3Rpb24+IHt9XG5cbi8qKlxuICogUGFyc2UgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24sIGFuZCByZXR1cm4gZWl0aGVyIGEgRnVuY3Rpb24gb3IgYW4gZXJyb3IgbWVzc2FnZSBpbiBhIHN0cmluZy5cbiAqIEBwYXJhbSBwYXJhbXNBcmdzXG4gKiBAcGFyYW0gYXJnXG4gKlxuICogQHNlZSBldmFsdWF0ZUV4cHJlc3Npb25cbiAqIEBzZWUgZXZhbHVhdGVFeHByZXNzaW9uT3JDYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKHBhcmFtc0FyZ3M6IFtzdHJpbmcsIGFueV1bXSwgYXJnOiBzdHJpbmcpOiBGdW5jdGlvbk9yRXJyb3Ige1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtc0FyZ3MubWFwKChbcF0pID0+IHApO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJnLmluY2x1ZGVzKCdyZXR1cm4nKSA/IGFyZyA6IGByZXR1cm4gJHthcmd9YDtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbjogJycgfCBudWxsIHwgRnVuY3Rpb24gPSBhcmcgJiYgbmV3IEZ1bmN0aW9uKC4uLnBhcmFtcywgaW5wdXQpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25PckVycm9yLmZyb21PYmplY3QoYXJnLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJIGhhdmUgbm90IG1hbmFnZWQgdG8gd3JpdGUgYSB0ZXN0IHRoYXQgcmVhY2hlcyBoZXJlOlxuICAgICAgICByZXR1cm4gRnVuY3Rpb25PckVycm9yLmZyb21FcnJvcihhcmcsICdFcnJvciBwYXJzaW5nIGdyb3VwIGZ1bmN0aW9uJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25PckVycm9yLmZyb21FcnJvcihhcmcsIGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbihgRmFpbGVkIHBhcnNpbmcgZXhwcmVzc2lvbiBcIiR7YXJnfVwiYCwgZSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSBhbiBhcmJpdHJhcnkgSmF2YVNjcmlwdCBleHByZXNzaW9uLCB0aHJvd2luZyBhbiBleGNlcHRpb24gaWYgdGhlIGNhbGN1bGF0aW9uIGZhaWxlZC5cbiAqIEBwYXJhbSBleHByZXNzaW9uXG4gKiBAcGFyYW0gcGFyYW1zQXJnc1xuICpcbiAqIEBzZWUgcGFyc2VFeHByZXNzaW9uXG4gKiBAc2VlIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uOiBGdW5jdGlvbiwgcGFyYW1zQXJnczogW3N0cmluZywgYW55XVtdKSB7XG4gICAgY29uc3QgYXJncyA9IHBhcmFtc0FyZ3MubWFwKChbXywgYV0pID0+IGEpO1xuICAgIHJldHVybiBleHByZXNzaW9uKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIGFuIGFyYml0cmFyeSBKYXZhU2NyaXB0IGV4cHJlc3Npb24sIHJldHVybmluZyBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSBjYWxjdWxhdGlvbiBmYWlsZWQuXG4gKiBAcGFyYW0gZXhwcmVzc2lvblxuICogQHBhcmFtIHBhcmFtc0FyZ3NcbiAqIEBwYXJhbSBhcmdcbiAqXG4gKiBAc2VlIHBhcnNlRXhwcmVzc2lvblxuICogQHNlZSBldmFsdWF0ZUV4cHJlc3Npb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2goZXhwcmVzc2lvbjogRnVuY3Rpb24sIHBhcmFtc0FyZ3M6IFtzdHJpbmcsIGFueV1bXSwgYXJnOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHBhcmFtc0FyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbihgRmFpbGVkIGNhbGN1bGF0aW5nIGV4cHJlc3Npb24gXCIke2FyZ31cImAsIGUpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRnVuY3Rpb25PckVycm9yLCBldmFsdWF0ZUV4cHJlc3Npb24sIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2gsIHBhcnNlRXhwcmVzc2lvbiB9IGZyb20gJy4vRXhwcmVzc2lvbic7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5Q29udGV4dCB9IGZyb20gJy4vUXVlcnlDb250ZXh0JztcblxuLyoqXG4gKiAgRnJvbTogaHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Fuc3dlcnMvcGFyYW1ldGVyLXZzLWFyZ3VtZW50XG4gKiAgICAgIEEgcGFyYW1ldGVyIGlzIGEgdmFyaWFibGUgaW4gYSBmdW5jdGlvbiBkZWZpbml0aW9uLiBJdCBpcyBhIHBsYWNlaG9sZGVyIGFuZCBoZW5jZSBkb2VzIG5vdCBoYXZlIGEgY29uY3JldGUgdmFsdWUuXG4gKiAgICAgIEFuIGFyZ3VtZW50IGlzIGEgdmFsdWUgcGFzc2VkIGR1cmluZyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuICogQHBhcmFtIHRhc2sgLSBkdXJpbmcgcGFyc2luZywgdGhpcyBjYW4gYmUgbnVsbC4gRHVyaW5nIGV2YWx1YXRpb24sIGl0IG11c3QgYmUgYSBUYXNrXG4gKiBAcGFyYW0gcXVlcnlDb250ZXh0IC0gZHVyaW5nIHBhcnNpbmcsIHRoaXMgY2FuIGJlIG51bGwuIER1cmluZyBldmFsdWF0aW9uLCBpdCBtdXN0IGJlIGEgUXVlcnlDb250ZXh0IG9yIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEFyZ3VtZW50cyh0YXNrOiBUYXNrIHwgbnVsbCwgcXVlcnlDb250ZXh0OiBRdWVyeUNvbnRleHQgfCBudWxsKSB7XG4gICAgY29uc3QgcGFyYW1zQXJnczogW3N0cmluZywgYW55XVtdID0gW1xuICAgICAgICBbJ3Rhc2snLCB0YXNrXSxcbiAgICAgICAgWydxdWVyeScsIHF1ZXJ5Q29udGV4dCA/IHF1ZXJ5Q29udGV4dC5xdWVyeSA6IG51bGxdLFxuICAgIF07XG4gICAgcmV0dXJuIHBhcmFtc0FyZ3M7XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYW4gYXJiaXRyYXJ5IEphdmFTY3JpcHQgZXhwcmVzc2lvbiBvbiBhIFRhc2sgb2JqZWN0XG4gKiBAcGFyYW0gdGFzayAtIGEge0BsaW5rIFRhc2t9IG9iamVjdFxuICogQHBhcmFtIGFyZyAtIGEgc3RyaW5nLCBzdWNoIGFzIGB0YXNrLnBhdGguc3RhcnRzV2l0aChcImpvdXJuYWwvXCIpID8gXCJqb3VybmFsL1wiIDogdGFzay5wYXRoYFxuICogQHBhcmFtIHF1ZXJ5Q29udGV4dCAtIGFuIG9wdGlvbmFsIHtAbGluayBRdWVyeUNvbnRleHR9IG9iamVjdFxuICpcbiAqIEN1cnJlbnRseSBhbnkgZXJyb3JzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmcgZXJyb3IgbWVzc2FnZXMsIHN0YXJ0aW5nIHdpdGggdGhlIHdvcmQgJ0Vycm9yJy5cbiAqXG4gKiBAdG9kbyBJbXBsZW1lbnQgYSB0eXBlLXNhZmUgbWVjaGFuaXNtIHRvIHJlcG9ydCBlcnJvciBtZXNzYWdlcyBkaXN0aW5jdCBmcm9tIGV4cHJlc3Npb24gcmVzdWx0cy5cbiAqXG4gKiBTZWUgYWxzbyB7QGxpbmsgRnVuY3Rpb25GaWVsZH0gd2hpY2ggZXhwb3NlcyB0aGlzIGZhY2lsaXR5IHRvIHVzZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbmRFdmFsdWF0ZUV4cHJlc3Npb24odGFzazogVGFzaywgYXJnOiBzdHJpbmcsIHF1ZXJ5Q29udGV4dD86IFF1ZXJ5Q29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtc0FyZ3MgPSBjb25zdHJ1Y3RBcmd1bWVudHModGFzaywgcXVlcnlDb250ZXh0ID8gcXVlcnlDb250ZXh0IDogbnVsbCk7XG5cbiAgICBjb25zdCBmdW5jdGlvbk9yRXJyb3IgPSBwYXJzZUV4cHJlc3Npb24ocGFyYW1zQXJncywgYXJnKTtcbiAgICBpZiAoZnVuY3Rpb25PckVycm9yLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk9yRXJyb3IuZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2goZnVuY3Rpb25PckVycm9yLnF1ZXJ5Q29tcG9uZW50ISwgcGFyYW1zQXJncywgYXJnKTtcbn1cblxuLyoqXG4gKiBFbmNhcHN1bGF0ZSBhbiBleHByZXNzaW9uIHRoYXQgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSBhIHtAbGluayBUYXNrfSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tFeHByZXNzaW9uIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbGluZTogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZnVuY3Rpb25PckVycm9yOiBGdW5jdGlvbk9yRXJyb3I7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IobGluZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25PckVycm9yID0gcGFyc2VFeHByZXNzaW9uKGNvbnN0cnVjdEFyZ3VtZW50cyhudWxsLCBudWxsKSwgbGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uT3JFcnJvci5pc1ZhbGlkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwYXJzZUVycm9yKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uT3JFcnJvci5lcnJvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBvbiB0aGlzIHRhc2ssIG9yIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgY2FsY3VsYXRpb24gZmFpbGVkXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcGFyYW0gcXVlcnlDb250ZXh0IC0gb3B0aW9uYWwuIElmIG5vdCBzdXBwbGllZCwgcXVlcnkgcHJvcGVydGllcyB3aWxsIGJlIHVuYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHNlZSBldmFsdWF0ZU9yQ2F0Y2hcbiAgICAgKi9cbiAgICBwdWJsaWMgZXZhbHVhdGUodGFzazogVGFzaywgcXVlcnlDb250ZXh0PzogUXVlcnlDb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIGBFcnJvcjogQ2Fubm90IGV2YWx1YXRlIGFuIGV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHZhbGlkOiBcIiR7dGhpcy5saW5lfVwiIGdhdmUgZXJyb3I6IFwiJHt0aGlzLnBhcnNlRXJyb3J9XCJgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZhbHVhdGVFeHByZXNzaW9uKFxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbk9yRXJyb3IucXVlcnlDb21wb25lbnQhLFxuICAgICAgICAgICAgY29uc3RydWN0QXJndW1lbnRzKHRhc2ssIHF1ZXJ5Q29udGV4dCA/IHF1ZXJ5Q29udGV4dCA6IG51bGwpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHRoZSBleHByZXNzaW9uIG9uIHRoaXMgdGFzaywgb3IgcmV0dXJuIGVycm9yIHRleHQgaWYgdGhlIGNhbGN1bGF0aW9uIGZhaWxlZFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHBhcmFtIHF1ZXJ5Q29udGV4dFxuICAgICAqXG4gICAgICogQHNlZSBldmFsdWF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBldmFsdWF0ZU9yQ2F0Y2godGFzazogVGFzaywgcXVlcnlDb250ZXh0OiBRdWVyeUNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvcjogQ2Fubm90IGV2YWx1YXRlIGFuIGV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHZhbGlkOiBcIiR7dGhpcy5saW5lfVwiIGdhdmUgZXJyb3I6IFwiJHt0aGlzLnBhcnNlRXJyb3J9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsdWF0ZUV4cHJlc3Npb25PckNhdGNoKFxuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbk9yRXJyb3IucXVlcnlDb21wb25lbnQhLFxuICAgICAgICAgICAgY29uc3RydWN0QXJndW1lbnRzKHRhc2ssIHF1ZXJ5Q29udGV4dCksXG4gICAgICAgICAgICB0aGlzLmxpbmUsXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwgIi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgdmFsdWV9J3MgdHlwZSwgZm9yIHNob3dpbmcgdG8gdXNlcnMsIHN1Y2ggYXMgaW4gZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlVHlwZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IEdyb3VwZXIgfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBUYXNrRXhwcmVzc2lvbiwgcGFyc2VBbmRFdmFsdWF0ZUV4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9TY3JpcHRpbmcvVGFza0V4cHJlc3Npb24nO1xuaW1wb3J0IHR5cGUgeyBRdWVyeUNvbnRleHQgfSBmcm9tICcuLi8uLi9TY3JpcHRpbmcvUXVlcnlDb250ZXh0JztcbmltcG9ydCB0eXBlIHsgU2VhcmNoSW5mbyB9IGZyb20gJy4uL1NlYXJjaEluZm8nO1xuaW1wb3J0IHsgU29ydGVyIH0gZnJvbSAnLi4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0IHsgY29tcGFyZUJ5RGF0ZSB9IGZyb20gJy4uLy4uL2xpYi9EYXRlVG9vbHMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVUeXBlIH0gZnJvbSAnLi4vLi4vbGliL1R5cGVEZXRlY3Rpb24nO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlciwgdHlwZSBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogQSB7QGxpbmsgRmllbGR9IGltcGxlbWVudCB0aGF0IGFjY2VwdHMgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gdG8gZmlsdGVyIG9yIGdyb3VwIHRhc2tzLlxuICpcbiAqIFNlZSBhbHNvIHtAbGluayBwYXJzZUFuZEV2YWx1YXRlRXhwcmVzc2lvbn1cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBGaWx0ZXJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgJ1VuYWJsZSB0byBwYXJzZSBsaW5lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gbWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IHRhc2tFeHByZXNzaW9uID0gbmV3IFRhc2tFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXRhc2tFeHByZXNzaW9uLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCB0YXNrRXhwcmVzc2lvbi5wYXJzZUVycm9yISk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihcbiAgICAgICAgICAgIG5ldyBGaWx0ZXIobGluZSwgY3JlYXRlRmlsdGVyRnVuY3Rpb25Gcm9tTGluZSh0YXNrRXhwcmVzc2lvbiksIG5ldyBFeHBsYW5hdGlvbihsaW5lKSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeZmlsdGVyIGJ5ICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0gKC4qKWAsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzb3J0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5zb3J0IGJ5ICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0oIHJldmVyc2UpPyAoLiopYCwgJ2knKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlU29ydGVyRnJvbUxpbmUobGluZTogc3RyaW5nKTogU29ydGVyIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5zb3J0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IG1hdGNoWzJdO1xuICAgICAgICBjb25zdCB0YXNrRXhwcmVzc2lvbiA9IG5ldyBUYXNrRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCF0YXNrRXhwcmVzc2lvbi5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgbmVlZCB0byByZXBvcnQgdGhlIGxpbmUsIGFuZCB0aGF0IGl0IHdhcyBwYXJzaW5nLCBhcyBjYWxsaW5nIGNvZGVcbiAgICAgICAgICAgIC8vIHdpbGwgYWRkIHRoYXQgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFza0V4cHJlc3Npb24ucGFyc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IChhOiBUYXNrLCBiOiBUYXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5Q29udGV4dCA9IHNlYXJjaEluZm8ucXVlcnlDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVBID0gdGhpcy52YWxpZGF0ZVRhc2tTb3J0S2V5KHRhc2tFeHByZXNzaW9uLmV2YWx1YXRlKGEsIHF1ZXJ5Q29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQiA9IHRoaXMudmFsaWRhdGVUYXNrU29ydEtleSh0YXNrRXhwcmVzc2lvbi5ldmFsdWF0ZShiLCBxdWVyeUNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVGFza1NvcnRLZXlzKHZhbHVlQSwgdmFsdWVCKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24ubWVzc2FnZSArPSBgOiB3aGlsZSBldmFsdWF0aW5nIGluc3RydWN0aW9uICcke2xpbmV9J2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZXIobGluZSwgdGhpcy5maWVsZE5hbWVTaW5ndWxhcigpLCBjb21wYXJhdG9yLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsaWRhdGVUYXNrU29ydEtleShzb3J0S2V5OiBhbnkpIHtcbiAgICAgICAgZnVuY3Rpb24gdGhyb3dTb3J0S2V5VHlwZUVycm9yKHNvcnRLZXlUeXBlOiBzdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3NvcnRLZXlUeXBlfVwiIGlzIG5vdCBhIHZhbGlkIHNvcnQga2V5YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc29ydEtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvd1NvcnRLZXlUeXBlRXJyb3IoJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oc29ydEtleSkpIHtcbiAgICAgICAgICAgIHRocm93U29ydEtleVR5cGVFcnJvcignTmFOIChOb3QgYSBOdW1iZXIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc29ydEtleSkpIHtcbiAgICAgICAgICAgIHRocm93U29ydEtleVR5cGVFcnJvcignYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydEtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgdHdvIHZhbHVlc1xuICAgICAqXG4gICAgICogKipJTVBPUlRBTlQqKjogQm90aCB2YWx1ZXMgbXVzdCBhbHJlYWR5IGhhdmUgYmVlbiBjaGVja2VkIGJ5IHtAbGluayB2YWxpZGF0ZVRhc2tTb3J0S2V5fS5cbiAgICAgKlxuICAgICAqIC0gSWYgdGhlIHJlc3VsdCBpcyBuZWdhdGl2ZSwgYSBpcyBzb3J0ZWQgYmVmb3JlIGIuXG4gICAgICogLSBJZiB0aGUgcmVzdWx0IGlzIHBvc2l0aXZlLCBiIGlzIHNvcnRlZCBiZWZvcmUgYS5cbiAgICAgKiAtIElmIHRoZSByZXN1bHQgaXMgMCwgbm8gY2hhbmdlcyBhcmUgZG9uZSB3aXRoIHRoZSBzb3J0IG9yZGVyIG9mIHRoZSB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlQSAtIGEgdmFsdWUgdGhhdCBzYXRpc2ZpZXMge0BsaW5rIHZhbGlkYXRlVGFza1NvcnRLZXl9LlxuICAgICAqIEBwYXJhbSB2YWx1ZUIgLSBhIHZhbHVlIHRoYXQgc2F0aXNmaWVzIHtAbGluayB2YWxpZGF0ZVRhc2tTb3J0S2V5fS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcGFyZVRhc2tTb3J0S2V5cyh2YWx1ZUE6IGFueSwgdmFsdWVCOiBhbnkpIHtcbiAgICAgICAgLy8gUHJlY29uZGl0aW9uOiBCb3RoIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBzYXRpc2ZpZWQgY29uc3RyYWludHMgaW4gdmFsaWRhdGVUYXNrU29ydEtleSgpLlxuXG4gICAgICAgIGNvbnN0IHZhbHVlQVR5cGUgPSBnZXRWYWx1ZVR5cGUodmFsdWVBKTtcbiAgICAgICAgY29uc3QgdmFsdWVCVHlwZSA9IGdldFZhbHVlVHlwZSh2YWx1ZUIpO1xuXG4gICAgICAgIC8vIFNvcnQgVGFzay5kdWVEYXRlIGFuZCBzaW1pbGFyIGluIHNhbWUgb3JkZXIgYXMgJ3NvcnQgYnkgZHVlJyBldGM6IG51bGwgdmFsdWVzIGNvbWUgYWZ0ZXIgTW9tZW50IHZhbHVlczpcbiAgICAgICAgY29uc3QgcmVzdWx0SWZNb21lbnQgPSB0aGlzLmNvbXBhcmVUYXNrU29ydEtleXNJZk9wdGlvbmFsTW9tZW50KHZhbHVlQSwgdmFsdWVCLCB2YWx1ZUFUeXBlLCB2YWx1ZUJUeXBlKTtcbiAgICAgICAgaWYgKHJlc3VsdElmTW9tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRJZk1vbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYW55IG51bGwgdmFsdWVzIGNvbWUgYWZ0ZXIgbm9uLW51bGwgdmFsdWVzXG4gICAgICAgIGNvbnN0IHJlc3VsdElmTnVsbCA9IHRoaXMuY29tcGFyZVRhc2tTb3J0S2V5c0lmRWl0aGVySXNOdWxsKHZhbHVlQSwgdmFsdWVCKTtcbiAgICAgICAgaWYgKHJlc3VsdElmTnVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SWZOdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlQVR5cGUgIT09IHZhbHVlQlR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbXBhcmUgdHdvIGRpZmZlcmVudCBzb3J0IGtleSB0eXBlcyAnJHt2YWx1ZUFUeXBlfScgYW5kICcke3ZhbHVlQlR5cGV9JyBvcmRlcmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlQVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVBLmxvY2FsZUNvbXBhcmUodmFsdWVCLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZUFUeXBlID09PSAnVGFza3NEYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCeURhdGUodmFsdWVBLm1vbWVudCwgdmFsdWVCLm1vbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVBVHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRydWUgdG8gY29tZSBiZWZvcmUgZmFsc2UsIGFzIGl0J3MgYmVlbiBmb3VuZCB0byBnaXZlIG1vcmUgaW50dWl0aXZlIGJlaGF2aW91ci5cbiAgICAgICAgICAgIC8vIFNvIHRoaXMgaXMgdGhlIG9wcG9zaXRlIHdheSByb3VuZCB0byB0aGUgY2FsY3VsYXRpb24gYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlQikgLSBOdW1iZXIodmFsdWVBKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHVzZSBOdW1iZXIoKSB0byBwcmV2ZW50IGltcGxpY2l0IHR5cGUgY29udmVyc2lvbiwgYnkgbWFraW5nIHRoZSBjb252ZXJzaW9uIGV4cGxpY2l0OlxuICAgICAgICBjb25zdCByZXN1bHQgPSBOdW1iZXIodmFsdWVBKSAtIE51bWJlcih2YWx1ZUIpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIHNvcnQgb3JkZXIgZm9yIHNvcnQga2V5IHR5cGVzICcke3ZhbHVlQVR5cGV9JyBhbmQgJyR7dmFsdWVCVHlwZX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbXBhcmVUYXNrU29ydEtleXNJZk9wdGlvbmFsTW9tZW50KHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSwgdmFsdWVBVHlwZTogc3RyaW5nLCB2YWx1ZUJUeXBlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYUlzTW9tZW50ID0gdmFsdWVBVHlwZSA9PT0gJ01vbWVudCc7XG4gICAgICAgIGNvbnN0IGJJc01vbWVudCA9IHZhbHVlQlR5cGUgPT09ICdNb21lbnQnO1xuXG4gICAgICAgIGNvbnN0IGJvdGhBcmVNb21lbnQgPSBhSXNNb21lbnQgJiYgYklzTW9tZW50O1xuICAgICAgICBjb25zdCBhSXNNb21lbnRCSXNOdWxsID0gYUlzTW9tZW50ICYmIHZhbHVlQiA9PT0gbnVsbDtcbiAgICAgICAgY29uc3QgYklzTW9tZW50QUlzTnVsbCA9IGJJc01vbWVudCAmJiB2YWx1ZUEgPT09IG51bGw7XG5cbiAgICAgICAgaWYgKGJvdGhBcmVNb21lbnQgfHwgYUlzTW9tZW50QklzTnVsbCB8fCBiSXNNb21lbnRBSXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJ5RGF0ZSh2YWx1ZUEsIHZhbHVlQik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29tcGFyZVRhc2tTb3J0S2V5c0lmRWl0aGVySXNOdWxsKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSkge1xuICAgICAgICBpZiAodmFsdWVBID09PSBudWxsICYmIHZhbHVlQiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOdWxsIHNvcnRzIGJlZm9yZSBhbnl0aGluZyBlbHNlLlxuICAgICAgICAvLyBUaGlzIGlzIGNvbnNpc3RlbnQgd2l0aCBob3cgbnVsbCBoZWFkaW5ncyBhcmUgaGFuZGxlZC5cbiAgICAgICAgLy8gSG93ZXZlciwgaXQgZGlmZmVycyBmcm9tIGhvdyBjb21wYXJlQnlEYXRlKCkgd29ya3MsIHNvIHNwZWNpYWwtY2FzZSBjb2RlIHdpbGwgYmUgbmVlZGVkXG4gICAgICAgIC8vIGZvciB0aGF0LCBsYXRlci5cbiAgICAgICAgaWYgKHZhbHVlQSA9PT0gbnVsbCAmJiB2YWx1ZUIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVBICE9PSBudWxsICYmIHZhbHVlQiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR3JvdXBpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVHcm91cGVyRnJvbUxpbmUobGluZTogc3RyaW5nKTogR3JvdXBlciB8IG51bGwge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZ3JvdXBlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoWzJdO1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIobGluZSwgJ2Z1bmN0aW9uJywgY3JlYXRlR3JvdXBlckZ1bmN0aW9uRnJvbUxpbmUoYXJncyksIHJldmVyc2UpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBncm91cGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeZ3JvdXAgYnkgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZCgpfSggcmV2ZXJzZSk/ICguKilgLCAnaScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgZm9yICdncm91cCBieSBmdW5jdGlvbicgYXMgdGhlIHVzZXIncyBpbnN0cnVjdGlvbiBsaW5lXG4gICAgICogaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSB7QGxpbmsgR3JvdXBlckZ1bmN0aW9ufS5cbiAgICAgKlxuICAgICAqIFNvIHRoaXMgY2xhc3Mgb3ZlcnJpZGVzIHtAbGluayBjcmVhdGVHcm91cGVyRnJvbUxpbmV9IGluc3RlYWQuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHRocm93IEVycm9yKCdncm91cGVyKCkgZnVuY3Rpb24gbm90IHZhbGlkIGZvciBGdW5jdGlvbkZpZWxkLiBVc2UgY3JlYXRlR3JvdXBlckZyb21MaW5lKCkgaW5zdGVhZC4nKTtcbiAgICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGaWx0ZXJpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlckZ1bmN0aW9uRnJvbUxpbmUoZXhwcmVzc2lvbjogVGFza0V4cHJlc3Npb24pOiBGaWx0ZXJGdW5jdGlvbiB7XG4gICAgcmV0dXJuICh0YXNrOiBUYXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5Q29udGV4dCA9IHNlYXJjaEluZm8ucXVlcnlDb250ZXh0KCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJCeUZ1bmN0aW9uKGV4cHJlc3Npb24sIHRhc2ssIHF1ZXJ5Q29udGV4dCk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckJ5RnVuY3Rpb24oZXhwcmVzc2lvbjogVGFza0V4cHJlc3Npb24sIHRhc2s6IFRhc2ssIHF1ZXJ5Q29udGV4dD86IFF1ZXJ5Q29udGV4dCk6IGJvb2xlYW4ge1xuICAgIC8vIEFsbG93IGV4Y2VwdGlvbnMgdG8gcHJvcGFnYXRlIHRvIGNhbGxlciwgc2luY2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgLy8gSW4gc2VhcmNoZXMsIGl0IHdpbGwgYmUgY2F1Z2h0IGJ5IFF1ZXJ5LmFwcGx5UXVlcnlUb1Rhc2tzKCkuXG4gICAgY29uc3QgcmVzdWx0ID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSh0YXNrLCBxdWVyeUNvbnRleHQpO1xuXG4gICAgLy8gV2UgaW5zaXN0IHRoYXQgJ2ZpbHRlciBieSBmdW5jdGlvbicgcmV0dXJucyBib29sZWFucyxcbiAgICAvLyB0byBhdm9pZCB1c2VycyBoYXZpbmcgdG8gdW5kZXJzdGFuZCB0cnV0aHkgYW5kIGZhbHNleSB2YWx1ZXMuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHRocm93IEVycm9yKGBmaWx0ZXJpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gdHJ1ZSBvciBmYWxzZS4gVGhpcyByZXR1cm5lZCBcIiR7cmVzdWx0fVwiLmApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR3JvdXBpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnR5cGUgR3JvdXBpbmdBcmcgPSBzdHJpbmc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwZXJGdW5jdGlvbkZyb21MaW5lKGxpbmU6IHN0cmluZyk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgcmV0dXJuICh0YXNrOiBUYXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5Q29udGV4dCA9IHNlYXJjaEluZm8ucXVlcnlDb250ZXh0KCk7XG4gICAgICAgIHJldHVybiBncm91cEJ5RnVuY3Rpb24odGFzaywgbGluZSwgcXVlcnlDb250ZXh0KTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBCeUZ1bmN0aW9uKHRhc2s6IFRhc2ssIGFyZzogR3JvdXBpbmdBcmcsIHF1ZXJ5Q29udGV4dD86IFF1ZXJ5Q29udGV4dCk6IHN0cmluZ1tdIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUFuZEV2YWx1YXRlRXhwcmVzc2lvbih0YXNrLCBhcmcsIHF1ZXJ5Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGgpID0+IGgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYXNrIHVzZXMgbnVsbCB0byByZXByZXNlbnQgbWlzc2luZyBpbmZvcm1hdGlvbi5cbiAgICAgICAgLy8gU28gd2UgdHJlYXQgbnVsbCBhcyBhbiBlbXB0eSBncm91cCBvciAnbm90IGluIGEgaGVhZGluZycsIGZvciBzaW1wbGljaXR5IGZvciB1c2Vycy5cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoICdudWxsIHx8IFwiTm8gdmFsdWVcIlxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IgaW4gdGhlIGV4cHJlc3Npb24sIGxpa2UgaXQgcmVmZXJyZWQgdG9cbiAgICAgICAgLy8gYW4gdW5rbm93biB0YXNrIGZpZWxkLCByZXN1bHQgd2lsbCBiZSB1bmRlZmluZWQsIGFuZCB0aGUgY2FsbFxuICAgICAgICAvLyBvbiB1bmRlZmluZWQudG9TdHJpbmcoKSB3aWxsIGdpdmUgYW4gZXhjZXB0aW9uIGFuZCBhIHVzZWZ1bCBlcnJvclxuICAgICAgICAvLyBtZXNzYWdlIGJlbG93LiBUaGlzIGlzIGEgZmVhdHVyZTogaXQgZ2l2ZXMgdXNlcnMgZmVlZGJhY2sgb24gdGhlIHByb2JsZW1cbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIFtncm91cF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgRXJyb3I6IEZhaWxlZCBjYWxjdWxhdGluZyBleHByZXNzaW9uIFwiJHthcmd9XCIuIFRoZSBlcnJvciBtZXNzYWdlIHdhczogYDtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvck1lc3NhZ2UgKyBlLm1lc3NhZ2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvck1lc3NhZ2UgKyAnVW5rbm93biBlcnJvciddO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKiogU3VwcG9ydCB0aGUgJ2hlYWRpbmcnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWFkaW5nRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdoZWFkaW5nJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmVjZWRpbmcgaGVhZGluZywgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBoZWFkaW5nIGlzIG51bGxcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0YXNrLnByZWNlZGluZ0hlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJlY2VkaW5nSGVhZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5wcmVjZWRpbmdIZWFkZXIgPT09IG51bGwgfHwgdGFzay5wcmVjZWRpbmdIZWFkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKE5vIGhlYWRpbmcpJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3Rhc2sucHJlY2VkaW5nSGVhZGVyXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKiBTdXBwb3J0IHRoZSAncGF0aCcgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbHNvIHNlYXJjaGVzIHRoZSBmaWxlIGV4dGVuc2lvbixcbiAqIHNvICdwYXRoIGluY2x1ZGVzIC5tZCcgd2lsbCB0eXBpY2FsbHkgbWF0Y2ggYWxsIHRhc2tzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3BhdGgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgcGF0aCBpbmNsdWRpbmcgZmlsZSBleHRlbnNpb24sIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgcGF0aCBpcyBudWxsXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHVibGljIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5wYXRoO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIG1hZGUgc3RyaWN0ZXI/XG4gICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgb2YgZ2V0dGluZyB0aGUgZmlsZSBuYW1lP1xuICAgICAgICAgICAgcmV0dXJuIFtUZXh0RmllbGQuZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKHRhc2sucGF0aC5yZXBsYWNlKCcubWQnLCAnJykpXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0L1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwL0dyb3VwZXInO1xuaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi8uLi9UYXNrL1ByaW9yaXR5JztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG5leHBvcnQgY2xhc3MgUHJpb3JpdHlGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICAvLyBUaGUgdHJpY2sgaW4gdGhlIGZvbGxvd2luZyB0byBtYW5hZ2Ugd2hpdGVzcGFjZSB3aXRoIG9wdGlvbmFsIHZhbHVlc1xuICAgIC8vIGlzIHRvIGNhcHR1cmUgdGhlbSBpbiBOZXN0ZWQgQ2FwdHVyZSBHcm91cHMsIGxpa2UgdGhpczpcbiAgICAvLyAgKGxlYWRpbmctd2hpdGUtc3BhY2UtaW4tb3V0ZXItY2FwdHVyZS1ncm91cCh2YWx1ZXMtdG8tdXNlLWFyZS1pbi1pbm5lci1jYXB0dXJlLWdyb3VwKSlcbiAgICAvLyBUaGUgY2FwdHVyZSBncm91cHMgYXJlIG51bWJlcmVkIGluIHRoZSBvcmRlciBvZiB0aGVpciBvcGVuaW5nIGJyYWNrZXRzLCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcHJpb3JpdHlSZWdleHAgPVxuICAgICAgICAvXnByaW9yaXR5KFxccytpcyk/KFxccysoYWJvdmV8YmVsb3d8bm90KSk/KFxccysobG93ZXN0fGxvd3xub25lfG1lZGl1bXxoaWdofGhpZ2hlc3QpKSQvaTtcblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlNYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAocHJpb3JpdHlNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyUHJpb3JpdHlTdHJpbmcgPSBwcmlvcml0eU1hdGNoWzVdO1xuICAgICAgICAgICAgbGV0IGZpbHRlclByaW9yaXR5OiBQcmlvcml0eSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpbHRlclByaW9yaXR5U3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsb3dlc3QnOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQcmlvcml0eSA9IFByaW9yaXR5Lkxvd2VzdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQcmlvcml0eSA9IFByaW9yaXR5Lk5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuTWVkaXVtO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoZXN0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbHRlclByaW9yaXR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnZG8gbm90IHVuZGVyc3RhbmQgcHJpb3JpdHknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGV4cGxhbmF0aW9uID0gbGluZTtcbiAgICAgICAgICAgIGxldCBmaWx0ZXI7XG4gICAgICAgICAgICBzd2l0Y2ggKHByaW9yaXR5TWF0Y2hbM10/LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB0YXNrLnByaW9yaXR5LmxvY2FsZUNvbXBhcmUoZmlsdGVyUHJpb3JpdHkhKSA8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JlbG93JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRhc2sucHJpb3JpdHkubG9jYWxlQ29tcGFyZShmaWx0ZXJQcmlvcml0eSEpID4gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm90JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRhc2sucHJpb3JpdHkgIT09IGZpbHRlclByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAodGFzazogVGFzaykgPT4gdGFzay5wcmlvcml0eSA9PT0gZmlsdGVyUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gYCR7dGhpcy5maWVsZE5hbWUoKX0gaXMgJHtmaWx0ZXJQcmlvcml0eVN0cmluZ31gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihuZXcgRmlsdGVyKGxpbmUsIGZpbHRlciwgbmV3IEV4cGxhbmF0aW9uKGV4cGxhbmF0aW9uKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZmlsdGVyIChwcmlvcml0eSknKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdwcmlvcml0eSc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlGaWVsZC5wcmlvcml0eVJlZ2V4cDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eS5sb2NhbGVDb21wYXJlKGIucHJpb3JpdHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbdGFzay5wcmlvcml0eU5hbWVHcm91cFRleHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdzY2hlZHVsZWQnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlZERhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3NjaGVkdWxlZCc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc2NoZWR1bGVkRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ3N0YXJ0cycgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3RhcnREYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWVGb3JGaWx0ZXJJbnN0cnVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0cyc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc3RhcnREYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIC8vIHJlZmVyZW5jZTogaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL1F1ZXJpZXMvRmlsdGVycyNTdGFydCtEYXRlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9ucyB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zJztcbmltcG9ydCB0eXBlIHsgRGF0ZUZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdoYXBwZW5zJyBzZWFyY2ggaW5zdHJ1Y3Rpb24sIHdoaWNoIHNlYXJjaGVzIGFsbCBvZlxuICogc3RhcnQsIHNjaGVkdWxlZCBhbmQgZHVlIGRhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgSGFwcGVuc0RhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckluc3RydWN0aW9ucyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnaGFzIGhhcHBlbnMgZGF0ZScsICh0YXNrOiBUYXNrKSA9PiB0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpKTtcbiAgICAgICAgZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnbm8gaGFwcGVucyBkYXRlJywgKHRhc2s6IFRhc2spID0+ICF0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpKTtcbiAgICAgICAgc3VwZXIoZmlsdGVySW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnaGFwcGVucyc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZUZvckV4cGxhbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ2R1ZSwgc3RhcnQgb3Igc2NoZWR1bGVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBlYXJsaWVzdERhdGV9XG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhcmxpZXN0RGF0ZSh0YXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRhc2sncyBzdGFydCwgc2NoZWR1bGVkIGFuZCBkdWUgZGF0ZXMsIGFueSBvciBhbGwgb2Ygd2hpY2ggbWF5IGJlIG51bGwuXG4gICAgICovXG4gICAgcHVibGljIGRhdGVzKHRhc2s6IFRhc2spOiAoTW9tZW50IHwgbnVsbClbXSB7XG4gICAgICAgIHJldHVybiB0YXNrLmhhcHBlbnNEYXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVhcmxpZXN0IG9mIHRoZSBkYXRlcyB1c2VkIGJ5ICdoYXBwZW5zJyBpbiB0aGUgZ2l2ZW4gdGFzaywgb3IgbnVsbCBpZiBub25lIHNldC5cbiAgICAgKlxuICAgICAqIEdlbmVyYWxseSBzcGVha2luZywgdGhlIGVhcmxpZXN0IGRhdGUgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgaGlnaGVzdCBwcmlvcml0eSxcbiAgICAgKiBhcyBpdCBpcyB0aGUgZmlyc3QgcG9pbnQgYXQgd2hpY2ggdGhlIHVzZXIgbWlnaHQgd2lzaCB0byBhY3Qgb24gdGhlIHRhc2suXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZWFybGllc3REYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suaGFwcGVucy5tb21lbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlcihkYXRlRmlsdGVyRnVuY3Rpb246IERhdGVGaWx0ZXJGdW5jdGlvbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlcyh0YXNrKS5zb21lKChkYXRlKSA9PiBkYXRlRmlsdGVyRnVuY3Rpb24oZGF0ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnQvU29ydGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQnO1xuXG5leHBvcnQgY2xhc3MgUmVjdXJyaW5nRmllbGQgZXh0ZW5kcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5hZGQoJ2lzIHJlY3VycmluZycsICh0YXNrKSA9PiB0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpO1xuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgbm90IHJlY3VycmluZycsICh0YXNrKSA9PiB0YXNrLnJlY3VycmVuY2UgPT09IG51bGwpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdyZWN1cnJpbmcnO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU29ydGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICAvLyBSZWN1cnJpbmcgdGFza3Mgc29ydCBiZWZvcmUgbm9uLXJlY3VycmluZyBvbmVzXG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgaWYgKGEucmVjdXJyZW5jZSAhPT0gbnVsbCAmJiBiLnJlY3VycmVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEucmVjdXJyZW5jZSA9PT0gbnVsbCAmJiBiLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHcm91cGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnUmVjdXJyaW5nJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ05vdCBSZWN1cnJpbmcnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnQvU29ydGVyJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkJztcblxuZXhwb3J0IGNsYXNzIFN0YXR1c0ZpZWxkIGV4dGVuZHMgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgY2hhbmdlOiBJbiBUYXNrcyAxLjIyLjAgYW5kIGVhcmxpZXIsIGFsbCB0YXNrc1xuICAgICAgICAvLyB3aXRoIGFueSBzdGF0dXMgY2hhcmFjdGVyIGV4Y2VwdCBzcGFjZSB3ZXJlIGNvbnNpZGVyZWQgYnkgdGhlIHN0YXR1cyBmaWx0ZXJcbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zIHRvIGJlIGRvbmUuXG4gICAgICAgIC8vIEluIGxhdGVyIHZlcnNpb25zOlxuICAgICAgICAvLyAgIFN0YXR1c1R5cGUuRE9ORSBjb3VudHMgYXMgZG9uZVxuICAgICAgICAvLyAgIFN0YXR1c1R5cGUuQ0FOQ0VMTEVEIGNvdW50cyBhcyBkb25lXG4gICAgICAgIC8vICAgU3RhdHVzVHlwZS5UT0RPIGNvdW50cyBhcyBub3QgZG9uZVxuICAgICAgICAvLyAgIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1MgY291bnRzIGFzIG5vdCBkb25lXG4gICAgICAgIC8vICAgU3RhdHVzVHlwZS5OT05fVEFTSyBjb3VudHMgYXMgZG9uZVxuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnZG9uZScsICh0YXNrOiBUYXNrKSA9PiB0YXNrLmlzRG9uZSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdub3QgZG9uZScsICh0YXNrOiBUYXNrKSA9PiAhdGFzay5pc0RvbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGF0dXMnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdHdvIFRhc2sgb2JqZWN0cywgZm9yIHVzZSBpbiBzb3J0aW5nIGJ5IHN0YXR1cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgbm90ZTogSW4gVGFza3MgMS4yMi4wIGFuZCBlYXJsaWVyLCB0aGVcbiAgICAgICAgLy8gb25seSBhdmFpbGFibGUgc3RhdHVzIG5hbWVzIHdlcmUgJ1RvZG8nIGFuZCAnRG9uZScuXG4gICAgICAgIC8vIEFuZCAnVG9kbycgc29ydGVkIGJlZm9yZSAnRG9uZScuXG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkU3RhdHVzTmFtZUEgPSBTdGF0dXNGaWVsZC5vbGRTdGF0dXNOYW1lKGEpO1xuICAgICAgICAgICAgY29uc3Qgb2xkU3RhdHVzTmFtZUIgPSBTdGF0dXNGaWVsZC5vbGRTdGF0dXNOYW1lKGIpO1xuICAgICAgICAgICAgaWYgKG9sZFN0YXR1c05hbWVBIDwgb2xkU3RhdHVzTmFtZUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkU3RhdHVzTmFtZUEgPiBvbGRTdGF0dXNOYW1lQikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2xkU3RhdHVzTmFtZShhOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGEuc3RhdHVzLnN5bWJvbCA9PT0gJyAnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1RvZG8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdEb25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG5vdGU6IEluIFRhc2tzIDEuMjIuMCBhbmQgZWFybGllciwgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIG5hbWVzIHVzZWQgYnkgJ2dyb3VwIGJ5IHN0YXR1cycgd2VyZSAnVG9kbycgYW5kICdEb25lJyAtIGFuZFxuICAgICAgICAgICAgLy8gYW55IGNoYXJhY3RlciBvdGhlciB0aGFuIGEgc3BhY2Ugd2FzIGNvbnNpZGVyZWQgdG8gYmUgJ0RvbmUnLlxuICAgICAgICAgICAgcmV0dXJuIFtTdGF0dXNGaWVsZC5vbGRTdGF0dXNOYW1lKHRhc2spXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgSVN0cmluZ01hdGNoZXIgfSBmcm9tICcuLi9NYXRjaGVycy9JU3RyaW5nTWF0Y2hlcic7XG5pbXBvcnQgeyBHcm91cGVyIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIE11bHRpVGV4dEZpZWxkIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdG8gaGVscCBpbXBsZW1lbnRcbiAqIGFsbCB0aGUgZmlsdGVyIGluc3RydWN0aW9ucyB0aGF0IGFjdCBvbiBtdWx0aXBsZSBzdHJpbmcgdmFsdWVzXG4gKiBzdWNoIGFzIHRoZSB0YWdzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTXVsdGlUZXh0RmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpbmd1bGFyIGZvcm0gb2YgdGhlIGZpZWxkJ3MgbmFtZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGZvcm0gb2YgdGhlIGZpZWxkJ3MgbmFtZS5cbiAgICAgKiBJZiBub3Qgb3ZlcnJpZGRlbiwgcmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBhcHBlbmRlZCB3aXRoIGFuIFwic1wiLlxuICAgICAqL1xuICAgIHB1YmxpYyBmaWVsZE5hbWVQbHVyYWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSArICdzJztcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9LyR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX1gO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZFBhdHRlcm4oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX18JHt0aGlzLmZpZWxkTmFtZVBsdXJhbCgpfWA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlck9wZXJhdG9yUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIuZmlsdGVyT3BlcmF0b3JQYXR0ZXJuKCl9fGluY2x1ZGV8ZG8gbm90IGluY2x1ZGVgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIG5vdCBvdmVycmlkZGVuLCByZXR1cm5zIGEgY29tbWEtc2VwYXJhdGVkIGNvbmNhdGVuYXRpb24gb2YgYWxsXG4gICAgICogdGhlIHZhbHVlcyBvZiB0aGlzIGZpZWxkIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBhcmUgbm90IHZhbHVlc1xuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKHRhc2spLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgdmFsdWVzIG9mIHRoaXMgZmllbGQsIG9yIGFuIGVtcHR5IGFycmF5XG4gICAgICogaWYgdGhlIGZpZWxkIGhhcyBubyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgdmFsdWVzKHRhc2s6IFRhc2spOiBzdHJpbmdbXTtcblxuICAgIHByb3RlY3RlZCBnZXRGaWx0ZXIobWF0Y2hlcjogSVN0cmluZ01hdGNoZXIsIG5lZ2F0ZTogYm9vbGVhbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXIhLm1hdGNoZXNBbnlPZih0aGlzLnZhbHVlcyh0YXNrKSk7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRlID8gIW1hdGNoIDogbWF0Y2g7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvdmVybG9hZHMge0BsaW5rIEZpZWxkLmNyZWF0ZUdyb3VwZXJ9IHRvIHB1dCBhIHBsdXJhbCBmaWVsZCBuYW1lIGluIHRoZSB7QGxpbmsgR3JvdXBlci5wcm9wZXJ0eX0uXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXIocmV2ZXJzZTogYm9vbGVhbik6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIodGhpcy5ncm91cGVySW5zdHJ1Y3Rpb24ocmV2ZXJzZSksIHRoaXMuZmllbGROYW1lUGx1cmFsKCksIHRoaXMuZ3JvdXBlcigpLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ3JvdXBlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNHcm91cGluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgZ3JvdXBlclJlZ0V4cCgpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5ncm91cCBieSAke3RoaXMuZmllbGROYW1lUGx1cmFsKCl9KCByZXZlcnNlKT8kYCwgJ2knKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ3JvdXBlckluc3RydWN0aW9uKHJldmVyc2U6IGJvb2xlYW4pIHtcbiAgICAgICAgbGV0IGluc3RydWN0aW9uID0gYGdyb3VwIGJ5ICR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX1gO1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gKz0gJyByZXZlcnNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0L1NvcnRlcic7XG5pbXBvcnQgeyBTb3J0ZXIgfSBmcm9tICcuLi9Tb3J0L1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwL0dyb3VwZXInO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnMnO1xuaW1wb3J0IHsgTXVsdGlUZXh0RmllbGQgfSBmcm9tICcuL011bHRpVGV4dEZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAndGFnJyBhbmQgJ3RhZ3MnIHNlYXJjaCBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGFncyBjYW4gYmUgc2VhcmNoZWQgZm9yIHdpdGggYW5kIHdpdGhvdXQgdGhlIGhhc2ggdGFnIGF0IHRoZSBzdGFydC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhZ3NGaWVsZCBleHRlbmRzIE11bHRpVGV4dEZpZWxkIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJpdmF0ZSByZWFkb25seSBmaWx0ZXJJbnN0cnVjdGlvbnM6IEZpbHRlckluc3RydWN0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuYWRkKGBoYXMgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YCwgKHRhc2s6IFRhc2spID0+IHRoaXMudmFsdWVzKHRhc2spLmxlbmd0aCA+IDApO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYGhhcyAke3RoaXMuZmllbGROYW1lUGx1cmFsKCl9YCwgKHRhc2s6IFRhc2spID0+IHRoaXMudmFsdWVzKHRhc2spLmxlbmd0aCA+IDApO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYG5vICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWAsICh0YXNrOiBUYXNrKSA9PiB0aGlzLnZhbHVlcyh0YXNrKS5sZW5ndGggPT09IDApO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYG5vICR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX1gLCAodGFzazogVGFzaykgPT4gdGhpcy52YWx1ZXModGFzaykubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBmaWx0ZXJSZXN1bHQgPSB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgaWYgKGZpbHRlclJlc3VsdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckluc3RydWN0aW9ucy5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWVTaW5ndWxhcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3RhZyc7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbHVlcyh0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGFzay50YWdzO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU29ydGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogT3ZlcnJpZGRlbiB0byBhZGQgc3VwcG9ydCBmb3IgdGFnIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5lXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZVNvcnRlckZyb21MaW5lKGxpbmU6IHN0cmluZyk6IFNvcnRlciB8IG51bGwge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2godGhpcy5zb3J0ZXJSZWdFeHAoKSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlJbnN0YW5jZSA9IGlzTmFOKCttYXRjaFsyXSkgPyAxIDogK21hdGNoWzJdO1xuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gVGFnc0ZpZWxkLm1ha2VDb21wYXJlQnlUYWdDb21wYXJhdG9yKHByb3BlcnR5SW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlcihsaW5lLCB0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCksIGNvbXBhcmF0b3IsIHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgbWF0Y2ggYSBjb3JyZWN0bHktZm9ybWVkXG4gICAgICogaW5zdHJ1Y3Rpb24gbGluZSBmb3Igc29ydGluZyBUYXNrcyBieSB0YWcuXG4gICAgICpcbiAgICAgKiBgbWF0Y2hbMV1gIHdpbGwgYmUgZWl0aGVyIGByZXZlcnNlYCBvciB1bmRlZmluZWQuXG4gICAgICogYG1hdGNoWzJdYCB3aWxsIGJlIGVpdGhlciB0aGUgdGFnIG51bWJlciBvciB1bmRlZmluZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNvcnRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gL15zb3J0IGJ5IHRhZyggcmV2ZXJzZSk/W1xcc10qKFxcZCspPy9pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhICR7QGxpbmsgQ29tcGFyYXRvcn0gdGhhdCBzb3J0cyBieSB0aGUgZmlyc3QgdGFnLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gVGFnc0ZpZWxkLm1ha2VDb21wYXJlQnlUYWdDb21wYXJhdG9yKDEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG1ha2VDb21wYXJlQnlUYWdDb21wYXJhdG9yKHByb3BlcnR5SW5zdGFuY2U6IG51bWJlcik6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIElmIG5vIHRhZ3MgdGhlbiBhc3N1bWUgdGhleSBhcmUgZXF1YWwuXG4gICAgICAgICAgICBpZiAoYS50YWdzLmxlbmd0aCA9PT0gMCAmJiBiLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBhIGlzIGxlc3MgdGhhbiBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBiIGlzIGxlc3MgdGhhbiBhXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcnJheXMgc3RhcnQgYXQgMCBidXQgdGhlIHVzZXJzIHNwZWNpZnkgYSB0YWcgc3RhcnRpbmcgYXQgMS5cbiAgICAgICAgICAgIGNvbnN0IHRhZ0luc3RhbmNlVG9Tb3J0QnkgPSBwcm9wZXJ0eUluc3RhbmNlIC0gMTtcblxuICAgICAgICAgICAgaWYgKGEudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlICYmIGIudGFncy5sZW5ndGggPj0gcHJvcGVydHlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLnRhZ3MubGVuZ3RoIDwgcHJvcGVydHlJbnN0YW5jZSAmJiBhLnRhZ3MubGVuZ3RoID49IHByb3BlcnR5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlICYmIGIudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ0EgPSBhLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV07XG4gICAgICAgICAgICBjb25zdCB0YWdCID0gYi50YWdzW3RhZ0luc3RhbmNlVG9Tb3J0QnldO1xuICAgICAgICAgICAgcmV0dXJuIHRhZ0EubG9jYWxlQ29tcGFyZSh0YWdCLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLnRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoTm8gdGFncyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXNrLnRhZ3M7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUG9zdGZpeEV4cHJlc3Npb24gfSBmcm9tICdib29uLWpzJztcbmltcG9ydCB7IHBhcnNlIGFzIGJvb25QYXJzZSB9IGZyb20gJ2Jvb24tanMnO1xuaW1wb3J0IHR5cGUgeyBUb2tlbiB9IGZyb20gJ2Jvb24tanMvbGliL3R5cGVzJztcblxuaW1wb3J0IHsgcGFyc2VGaWx0ZXIgfSBmcm9tICcuLi9GaWx0ZXJQYXJzZXInO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgdHlwZSB7IFNlYXJjaEluZm8gfSBmcm9tICcuLi9TZWFyY2hJbmZvJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgQm9vbGVhbkRlbGltaXRlcnMgfSBmcm9tICcuL0Jvb2xlYW5EZWxpbWl0ZXJzJztcbmltcG9ydCB7IEJvb2xlYW5QcmVwcm9jZXNzb3IsIHR5cGUgQm9vbGVhblByZXByb2Nlc3NvclJlc3VsdCB9IGZyb20gJy4vQm9vbGVhblByZXByb2Nlc3Nvcic7XG5cbi8qKlxuICogQm9vbGVhbkZpZWxkIGlzIGEgJ2NvbnRhaW5lcicgZmllbGQgdHlwZSB0aGF0IHBhcnNlcyBhIGhpZ2gtbGV2ZWwgZmlsdGVyaW5nIHF1ZXJ5IG9mXG4gKiB0aGUgZm9ybWF0IC0tXG4gKiAgICAoZmlsdGVyMSkgQU5EICgoZmlsdGVyMikgT1IgKGZpbHRlcjMpKVxuICogVGhlIGZpbHRlcnMgY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIHdpdGggYW55IGJvb2xlYW4gb3BlcmF0b3JzIGFzIGxvbmcgYXMgdGhlIGluZGl2aWR1YWwgZmlsdGVycyBhcmVcbiAqIHdyYXBwZWQgaW4gZWl0aGVyIHBhcmVudGhlc2lzIG9yIHF1b3RlcyAtLSAoZmlsdGVyMSkgb3IgXCJmaWx0ZXIxXCIuXG4gKiBXaGF0IGhhcHBlbnMgaW50ZXJuYWxseSBpcyB0aGF0IHdoZW4gdGhlIGJvb2xlYW4gZmllbGQgaXMgYXNrZWQgdG8gY3JlYXRlIGEgZmlsdGVyLCBpdCBwYXJzZXMgdGhlIGJvb2xlYW5cbiAqIHF1ZXJ5IGludG8gYSBsb2dpY2FsIHBvc3RmaXggZXhwcmVzc2lvbiAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmV2ZXJzZV9Qb2xpc2hfbm90YXRpb24pLFxuICogd2l0aCB0aGUgaW5kaXZpZHVhbCBmaWx0ZXIgY29tcG9uZW50cyBhcyBcImlkZW50aWZpZXJcIiB0b2tlbnMuXG4gKiBUaGVzZSBpZGVudGlmaWVycyBoYXZlIGFuIGFzc29jaWF0ZWQgYWN0dWFsIEZpbHRlciAod2hpY2ggaXMgY2FjaGVkIGR1cmluZyB0aGUgcXVlcnkgcGFyc2luZykuXG4gKiBUaGUgcmV0dXJuZWQgRmlsdGVyIG9mIHRoZSB3aG9sZSBib29sZWFuIHF1ZXJ5IGlzIGV2ZW50dWFsbHkgYSBmdW5jdGlvbiB0aGF0IGZvciBlYWNoIFRhc2sgb2JqZWN0LFxuICogZXZhbHVhdGVzIHRoZSBjb21wbGV0ZSBwb3N0Zml4IGV4cHJlc3Npb24gYnkgZ29pbmcgdGhyb3VnaCB0aGUgaW5kaXZpZHVhbCBmaWx0ZXJzIGFuZCB0aGVuIHJlc29sdmluZ1xuICogdGhlIGV4cHJlc3Npb24gaW50byBhIHNpbmdsZSBib29sZWFuIGVudGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5GaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhc2ljQm9vbGVhblJlZ2V4cDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1cHBvcnRlZE9wZXJhdG9ycyA9IFsnQU5EJywgJ09SJywgJ1hPUicsICdOT1QnXTtcbiAgICBwcml2YXRlIHN1YkZpZWxkczogUmVjb3JkPHN0cmluZywgRmlsdGVyPiA9IHt9O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIEZpcnN0IHBhdHRlcm4gaW4gdGhpcyBtYXRjaGVzIGNvbnZlbnRpb25hbCAoZmlsdGVyMSkgT1IgKGZpbHRlcjIpIGFuZCBzaW1pbGFyXG4gICAgICAgIC8vIFNlY29uZCBwYXR0ZXJuIG1hdGNoZXMgKGZpbHRlcjEpIC0gdGhhdCBpcywgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGZpbHRlciBpcyB0cmVhdGVkIGFzIHZhbGlkXG5cbiAgICAgICAgY29uc3QgZGVsaW1pdGVycyA9IEJvb2xlYW5EZWxpbWl0ZXJzLmFsbFN1cHBvcnRlZERlbGltaXRlcnMoKTtcbiAgICAgICAgdGhpcy5iYXNpY0Jvb2xlYW5SZWdleHAgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJyguKihBTkR8T1J8WE9SfE5PVClcXFxccyonICtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzLm9wZW5GaWx0ZXIgK1xuICAgICAgICAgICAgICAgICcuKnwnICtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzLm9wZW5GaWx0ZXIgK1xuICAgICAgICAgICAgICAgICcuKycgK1xuICAgICAgICAgICAgICAgIGRlbGltaXRlcnMuY2xvc2VGaWx0ZXIgK1xuICAgICAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICdnJyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2ljQm9vbGVhblJlZ2V4cDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpbmUobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4gcXVlcnknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYnVpbGRzIGEgRmlsdGVyIGZvciBhIGNvbXBsZXRlIGJvb2xlYW4gcXVlcnkgYnk6XG4gICAgICogMS4gUHJlcHJvY2Vzc2luZyB0aGUgZXhwcmVzc2lvbiBpbnRvIHNvbWV0aGluZyBvdXIgaGVscGVyIHBhY2thZ2UsIGJvb24tanMsIGtub3dzIGhvdyB0byBidWlsZCBhbiBleHByZXNzaW9uIGZvci5cbiAgICAgKiAyLiBDcmVhdGluZyBhIHBvc3RmaXggbG9naWNhbCBleHByZXNzaW9uIHVzaW5nIGJvb24tanMsIHdoaWNoIGhhcyAtXG4gICAgICogICAgYS4gSWRlbnRpZmllcnMgKGxlYXZlcyksIHdoaWNoIGFyZSByZWd1bGFyIEZpZWxkIGZpbHRlcnMgcmVwcmVzZW50ZWQgYXMgdGhlaXIgc3RyaW5nLlxuICAgICAqICAgIGIuIE9wZXJhdG9ycywgd2hpY2ggYXJlIGxvZ2ljYWwgb3BlcmF0b3JzIGJldHdlZW4gaWRlbnRpZmllcnMgb3IgYmV0d2VlbiBwYXJlbnRoZXNpcy5cbiAgICAgKiAzLiBDcmVhdGluZyB0aGUgZmlsdGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHRoZSBJZGVudGlmaWVycyBpbiB0aGUgZXhwcmVzc2lvbiBhbmQgY2FjaGluZyB0aGVtIGluIHRoaXMuc3ViRmllbGRzLlxuICAgICAqIDQuIFJldHVybmluZyBhIGZpbmFsIGZ1bmN0aW9uIGZpbHRlciwgd2hpY2ggZm9yIGVhY2ggVGFzayBjYW4gcnVuIHRoZSBjb21wbGV0ZSBxdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlTGluZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnZW1wdHkgbGluZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlbGltaXRlcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxpbWl0ZXJzID0gQm9vbGVhbkRlbGltaXRlcnMuZnJvbUluc3RydWN0aW9uTGluZShsaW5lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duIGVycm9yIHR5cGUnO1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCB0aGlzLmhlbHBNZXNzYWdlRnJvbVNpbXBsZUVycm9yKGxpbmUsIG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gQm9vbGVhblByZXByb2Nlc3Nvci5wcmVwcm9jZXNzRXhwcmVzc2lvbihsaW5lLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZExpbmUgPSBwYXJzZVJlc3VsdC5zaW1wbGlmaWVkTGluZTtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IHBhcnNlUmVzdWx0LmZpbHRlcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSAocHJlcHJvY2Vzc2VkKSBsaW5lIGludG8gYSBwb3N0Zml4IGxvZ2ljYWwgZXhwcmVzc2lvblxuICAgICAgICAgICAgY29uc3QgcG9zdGZpeEV4cHJlc3Npb246IFRva2VuW10gPSBib29uUGFyc2Uoc2ltcGxpZmllZExpbmUpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHN1Yi1maWVsZCBtYXAsIGkuZS4gaGF2ZSBzdWJGaWVsZHMgaW5jbHVkZSBhIGZpbHRlciBmdW5jdGlvbiBmb3IgZXZlcnlcbiAgICAgICAgICAgIC8vIGZpbmFsIHRva2VuIGluIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09ICdJREVOVElGSUVSJyAmJiB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRva2VuLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1twbGFjZWhvbGRlcl07XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWx0ZXIgaW4gdGhpcy5zdWJGaWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRGaWVsZCA9IHBhcnNlRmlsdGVyKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShsaW5lLCBgY291bGRuJ3QgcGFyc2Ugc3ViLWV4cHJlc3Npb24gJyR7ZmlsdGVyfSdgLCBwYXJzZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGNvdWxkbid0IHBhcnNlIHN1Yi1leHByZXNzaW9uICcke2ZpbHRlcn0nOiAke3BhcnNlZEZpZWxkLmVycm9yfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZEZpZWxkLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViRmllbGRzW2ZpbHRlcl0gPSBwYXJzZWRGaWVsZC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdPUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UncmUgYWxyZWFkeSBpdGVyYXRpbmcgb3ZlciB0aGUgZXhwcmVzc2lvbiwgYWx0aG91Z2ggd2UgZG9uJ3QgbmVlZCB0aGUgb3BlcmF0b3JzIGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc3RhZ2UgYnV0IG9ubHkgaW4gZmlsdGVyVGFza1dpdGhQYXJzZWRRdWVyeSBiZWxvdywgd2UncmUgdXNpbmcgdGhlIG9wcG9ydHVuaXR5IHRvIHZlcmlmeVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSB2YWxpZC4gSWYgd2Ugd29uJ3QsIHRoZW4gYW4gaW52YWxpZCBvcGVyYXRvciB3aWxsIG9ubHkgYmUgZGV0ZWN0ZWQgd2hlbiB0aGUgcXVlcnkgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIG9uIGEgdGFza1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShsaW5lLCAnZW1wdHkgb3BlcmF0b3IgaW4gYm9vbGVhbiBxdWVyeScsIHBhcnNlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkT3BlcmF0b3JzLmluY2x1ZGVzKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVscE1lc3NhZ2UobGluZSwgYHVua25vd24gYm9vbGVhbiBvcGVyYXRvciAnJHt0b2tlbi52YWx1ZX0nYCwgcGFyc2VSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaWx0ZXIgd2l0aCBmaWx0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gcnVuIHRoZSBjb21wbGV0ZSBxdWVyeVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyRnVuY3Rpb24gPSAodGFzazogVGFzaywgc2VhcmNoSW5mbzogU2VhcmNoSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkodGFzaywgcG9zdGZpeEV4cHJlc3Npb24sIHNlYXJjaEluZm8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gdGhpcy5jb25zdHJ1Y3RFeHBsYW5hdGlvbihwb3N0Zml4RXhwcmVzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihuZXcgRmlsdGVyKGxpbmUsIGZpbHRlckZ1bmN0aW9uLCBleHBsYW5hdGlvbikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3IgdHlwZSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIGBtYWxmb3JtZWQgYm9vbGVhbiBxdWVyeSAtLSAke21lc3NhZ2V9IChjaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZ3VpZGVsaW5lcylgLFxuICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhpcyBydW4gYSBUYXNrIG9iamVjdCB0aHJvdWdoIGEgY29tcGxldGUgYm9vbGVhbiBleHByZXNzaW9uLlxuICAgICAqIEl0IGJhc2ljYWxseSByZXNvbHZlcyB0aGUgcG9zdGZpeCBleHByZXNzaW9uIHVudGlsIGl0IGlzIHJlZHVjZWQgaW50byBhIHNpbmdsZSBib29sZWFuIHZhbHVlLFxuICAgICAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXBsZXRlIGV4cHJlc3Npb24uXG4gICAgICogU2VlIGhlcmUgaG93IGl0IHdvcmtzOiBodHRwOi8vd3d3LmJ0ZWNoc21hcnRjbGFzcy5jb20vZGF0YV9zdHJ1Y3R1cmVzL3Bvc3RmaXgtZXZhbHVhdGlvbi5odG1sXG4gICAgICogQW5vdGhlciByZWZlcmVuY2U6IGh0dHBzOi8vd3d3LnR1dG9yaWFsc3BvaW50LmNvbS9FdmFsdWF0ZS1Qb3N0Zml4LUV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkoXG4gICAgICAgIHRhc2s6IFRhc2ssXG4gICAgICAgIHBvc3RmaXhFeHByZXNzaW9uOiBQb3N0Zml4RXhwcmVzc2lvbixcbiAgICAgICAgc2VhcmNoSW5mbzogU2VhcmNoSW5mbyxcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdG9Cb29sID0gKHM6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHMgPT09ICd0cnVlJztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9TdHJpbmcgPSAoYjogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGIgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib29sZWFuU3RhY2s6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgcG9zdGZpeEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnSURFTlRJRklFUicpIHtcbiAgICAgICAgICAgICAgICAvLyBJZGVudGlmaWVycyBhcmUgdGhlIHN1Yi1maWVsZHMgb2YgdGhlIGV4cHJlc3Npb24sIHRoZSBhY3R1YWwgZmlsdGVycywgZS5nLiAnZGVzY3JpcHRpb24gaW5jbHVkZXMgZm9vJy5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBpZGVudGlmaWVyIHdlIGNyZWF0ZWQgZWFybGllciB0aGUgY29ycmVzcG9uZGluZyBGaWx0ZXIsIHNvIG5vdyB3ZSBjYW4ganVzdCBldmFsdWF0ZSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyB0YXNrIGZvciBlYWNoIGlkZW50aWZpZXIgdGhhdCB3ZSBmaW5kIGluIHRoZSBwb3N0Zml4IGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHRocm93IEVycm9yKCdudWxsIHRva2VuIHZhbHVlJyk7IC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnN1YkZpZWxkc1t0b2tlbi52YWx1ZS50cmltKCldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbHRlci5maWx0ZXJGdW5jdGlvbih0YXNrLCBzZWFyY2hJbmZvKTtcbiAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaCh0b1N0cmluZyhyZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4ubmFtZSA9PT0gJ09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIC8vIFRvIGV2YWx1YXRlIGFuIG9wZXJhdG9yIHdlIG5lZWQgdG8gcG9wIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlbXMgZnJvbSB0aGUgYm9vbGVhbiBzdGFjayxcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGUgbG9naWNhbCBldmFsdWF0aW9uIGFuZCBwdXNoIGJhY2sgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ05PVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMSA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaCh0b1N0cmluZyghYXJnMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMSA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcyID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKGFyZzEgfHwgYXJnMikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdBTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaCh0b1N0cmluZyhhcmcxICYmIGFyZzIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnWE9SJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoKGFyZzEgJiYgIWFyZzIpIHx8ICghYXJnMSAmJiBhcmcyKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJyArIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCB0b2tlbiB0eXBlOiAnICsgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW50dWFsbHkgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbiBmb3IgdGhpcyBUYXNrIGlzIHRoZSBvbmx5IGl0ZW0gbGVmdCBpbiB0aGUgYm9vbGVhbiBzdGFja1xuICAgICAgICByZXR1cm4gdG9Cb29sKGJvb2xlYW5TdGFja1swXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBFeHBsYW5hdGlvbn0gcmVwcmVzZW50aW5nIHRoZSBjb21wbGV0ZSBCb29sZWFuIGluc3RydWN0aW9uIGN1cnJlbnRseSBiZWluZyBhbmFseXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3N0Zml4RXhwcmVzc2lvblxuICAgICAqL1xuICAgIHByaXZhdGUgY29uc3RydWN0RXhwbGFuYXRpb24ocG9zdGZpeEV4cHJlc3Npb246IFBvc3RmaXhFeHByZXNzaW9uKTogRXhwbGFuYXRpb24ge1xuICAgICAgICAvLyBGb3IgYW4gZXhwbGFuYXRpb24gb2YgdGhlIGNvZGUsIHNlZSB0aGUgSlNkb2MgYW5kIGNvbW1lbnRzIG9mIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkoKVxuICAgICAgICBjb25zdCBleHBsYW5hdGlvblN0YWNrOiBFeHBsYW5hdGlvbltdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgcG9zdGZpeEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnSURFTlRJRklFUicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGxhaW5FeHByZXNzaW9uKHRva2VuLCBleHBsYW5hdGlvblN0YWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4ubmFtZSA9PT0gJ09QRVJBVE9SJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwbGFpbk9wZXJhdG9yKHRva2VuLCBleHBsYW5hdGlvblN0YWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRva2VuIHR5cGU6ICcgKyB0b2tlbi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVudHVhbGx5IHRoZSBFeHBsYW5hdGlvbiBpcyB0aGUgb25seSBpdGVtIGxlZnQgaW4gdGhlIGJvb2xlYW4gc3RhY2tcbiAgICAgICAgcmV0dXJuIGV4cGxhbmF0aW9uU3RhY2tbMF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBsYWluRXhwcmVzc2lvbih0b2tlbjogVG9rZW4sIGV4cGxhbmF0aW9uU3RhY2s6IEV4cGxhbmF0aW9uW10pIHtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdudWxsIHRva2VuIHZhbHVlJyk7IC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnN1YkZpZWxkc1t0b2tlbi52YWx1ZS50cmltKCldO1xuICAgICAgICBjb25zdCBleHBsYW5hdGlvbiA9IHRoaXMuc2ltdWxhdGVFeHBsYWluRmlsdGVyKGZpbHRlcik7XG4gICAgICAgIGV4cGxhbmF0aW9uU3RhY2sucHVzaChleHBsYW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaW11bGF0ZUV4cGxhaW5GaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpIHtcbiAgICAgICAgLy8gSW4gb3VyIGNhbGxlciwgdGhlIGV4cGxhbmF0aW9uU3RhY2sga2VlcHMgdGhlIGV4cGxhbmF0aW9ucyBidXQgbm90IHRoZSBpbnN0cnVjdGlvbiBsaW5lcy5cbiAgICAgICAgLy8gU28gdG8gcmVwbGljYXRlIHRoZSBsb2dpYyBpbiBGaWx0ZXIuZXhwbGFpbkZpbHRlckluZGVudGVkKCksIHdlIG1heSBuZWVkIHRvIGFkZCB0aGVcbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb24gdG8gdGhlIGV4cGxhbmF0aW9uLlxuICAgICAgICByZXR1cm4gZmlsdGVyLnNpbXVsYXRlRXhwbGFpbkZpbHRlcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXhwbGFpbk9wZXJhdG9yKHRva2VuOiBUb2tlbiwgZXhwbGFuYXRpb25TdGFjazogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICAvLyBUbyBldmFsdWF0ZSBhbiBvcGVyYXRvciB3ZSBuZWVkIHRvIHBvcCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJvb2xlYW4gc3RhY2ssXG4gICAgICAgIC8vIGRvIHRoZSBsb2dpY2FsIGV2YWx1YXRpb24gYW5kIHB1c2ggYmFjayB0aGUgcmVzdWx0XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ05PVCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Ob3QoW2FyZzEhXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnT1InKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcyID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5PcihbYXJnMSEsIGFyZzIhXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnQU5EJykge1xuICAgICAgICAgICAgY29uc3QgYXJnMiA9IGV4cGxhbmF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBhcmcxID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uU3RhY2sucHVzaChFeHBsYW5hdGlvbi5ib29sZWFuQW5kKFthcmcxISwgYXJnMiFdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdYT1InKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcyID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Yb3IoW2FyZzEhLCBhcmcyIV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJyArIHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBwcm92aWRlIHVzZWZ1bCBpbmZvcm1hdGlvbiB0byB1c2Vycywgd2hlbiB3ZSBmYWlsIHRvIGludGVycHJldCBhIEJvb2xlYW4gZmlsdGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaGVscE1lc3NhZ2UobGluZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U6IHN0cmluZywgcGFyc2VSZXN1bHQ6IEJvb2xlYW5QcmVwcm9jZXNzb3JSZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHBhcnNlUmVzdWx0LmZpbHRlcnM7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gdGhpcy5zdHJpbmdpZnlTdWJFeHByZXNzaW9uc0ZvckVycm9yTWVzc2FnZShmaWx0ZXJzKTtcblxuICAgICAgICBjb25zdCBzaW1wbGVNZXNzYWdlID0gdGhpcy5oZWxwTWVzc2FnZUZyb21TaW1wbGVFcnJvcihsaW5lLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3NpbXBsZU1lc3NhZ2V9XG5cblRoZSBpbnN0cnVjdGlvbiB3YXMgY29udmVydGVkIHRvIHRoZSBmb2xsb3dpbmcgc2ltcGxpZmllZCBsaW5lOlxuICAgICR7cGFyc2VSZXN1bHQuc2ltcGxpZmllZExpbmV9XG5cbldoZXJlIHRoZSBzdWItZXhwcmVzc2lvbnMgaW4gdGhlIHNpbXBsaWZpZWQgbGluZSBhcmU6XG4ke2V4cHJlc3Npb25zfVxuXG5Gb3IgaGVscCwgc2VlOlxuICAgIGh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9RdWVyaWVzL0NvbWJpbmluZytGaWx0ZXJzXG5gO1xuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGZ1bGxNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0cmluZ2lmeVN1YkV4cHJlc3Npb25zRm9yRXJyb3JNZXNzYWdlKGZpbHRlcnM6IHsgW3A6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhmaWx0ZXJzKVxuICAgICAgICAgICAgLm1hcCgoW3BsYWNlaG9sZGVyLCBsaW5lXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIHVzZXIgd2hldGhlciB0aGUgc3ViLWV4cHJlc3Npb24gaXMgdmFsaWQsIHRvIHdvcmsgb3V0IHdoaWNoIG9uZXMgbmVlZCBmaXhpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgICAgJyR7cGxhY2Vob2xkZXJ9JzogJyR7bGluZX0nXG4gICAgICAgID0+ICR7dGhpcy5zdHJpbmdpZnlTdWJFeHByZXNzaW9uU3RhdHVzKGxpbmUpfWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RyaW5naWZ5U3ViRXhwcmVzc2lvblN0YXR1cyhsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRmllbGQgPSBwYXJzZUZpbHRlcihsaW5lKTtcbiAgICAgICAgaWYgKCFwYXJzZWRGaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuICdFUlJPUjpcXG4gICAgICAgICAgIGRvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkRmllbGQuZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIGVycm9yIG1lc3NhZ2UgaGFzIG1vcmUgdGhhbiBvbmUgbGluZSwgd2Ugc3BsaXQgaXQgaW4gdG8gc2VwYXJhdGUgbGluZXMsXG4gICAgICAgICAgICAvLyBhcHBseSBzb21lIHN0YW5kYXJkL3RpZHkgaW5kZW50YXRpb24sIGFuZCBqb2luIHRoZSBsaW5lcyBhZ2FpbjpcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEZpbHRlclN0YXR1cyA9IHBhcnNlZEZpZWxkLmVycm9yXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4gICAgICAgICAgICcpO1xuICAgICAgICAgICAgcmV0dXJuIGBFUlJPUjpcXG4gICAgICAgICAgICR7Zm9ybWF0dGVkRmlsdGVyU3RhdHVzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdPSyc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoZWxwTWVzc2FnZUZyb21TaW1wbGVFcnJvcihsaW5lOiBzdHJpbmcsIGVycm9yTWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBgQ291bGQgbm90IGludGVycHJldCB0aGUgZm9sbG93aW5nIGluc3RydWN0aW9uIGFzIGEgQm9vbGVhbiBjb21iaW5hdGlvbjpcbiAgICAke2xpbmV9XG5cblRoZSBlcnJvciBtZXNzYWdlIGlzOlxuICAgICR7ZXJyb3JNZXNzYWdlfWA7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGVzY2FwZVJlZ0V4cCB9IGZyb20gJy4uLy4uL2xpYi9SZWdFeHBUb29scyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhbnlPZlRoZXNlQ2hhcnMoYWxsb3dlZENoYXJzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdbJyArIGVzY2FwZVJlZ0V4cChhbGxvd2VkQ2hhcnMpICsgJ10nKS5zb3VyY2U7XG59XG5cbmNvbnN0IGRlbGltaXRlclBhaXJzID0gW1xuICAgIFsnKCcsICcpJ10sXG4gICAgWydbJywgJ10nXSxcbiAgICBbJ3snLCAnfSddLFxuICAgIFsnXCInLCAnXCInXSxcbl07XG5cbi8qKlxuICogQSBjbGFzcyB0byB0cnkgdG8gaWRlbnRpZnkgdGhlIHR5cGUgb2YgZGVsaW1pdGVyIHVzZWQgYmV0d2VlbiBCb29sZWFuIG9wZXJhdG9ycy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvbmx5IGNoZWNrcyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9uLW9wZXJhdG9yIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUsXG4gKiBzbyB3aGVyZSB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGJpbmFyeSBvcGVyYXRvciwgaXQgaXMgc3RpbGwgcG9zc2libGUgZm9yIHRoZSB1c2VyXG4gKiB0byBtaXggZGVsaW1pdGVycywgYW5kIGZvciB0aGUgZXJyb3IgdG8gbm90IGJlIGRldGVjdGVkIHVudGlsIGxhdGVyIGluIHRoZSBwYXJzaW5nIHByb2Nlc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuRGVsaW1pdGVycyB7XG4gICAgcHVibGljIHJlYWRvbmx5IG9wZW5GaWx0ZXJDaGFycztcbiAgICBwdWJsaWMgcmVhZG9ubHkgb3BlbkZpbHRlcjtcblxuICAgIHB1YmxpYyByZWFkb25seSBjbG9zZUZpbHRlckNoYXJzO1xuICAgIHB1YmxpYyByZWFkb25seSBjbG9zZUZpbHRlcjtcblxuICAgIHB1YmxpYyByZWFkb25seSBvcGVuQW5kQ2xvc2VGaWx0ZXJDaGFycztcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3Iob3BlbkZpbHRlckNoYXJzOiBzdHJpbmcsIGNsb3NlRmlsdGVyQ2hhcnM6IHN0cmluZywgb3BlbkFuZENsb3NlRmlsdGVyQ2hhcnM6IHN0cmluZykge1xuICAgICAgICB0aGlzLm9wZW5GaWx0ZXJDaGFycyA9IG9wZW5GaWx0ZXJDaGFycztcbiAgICAgICAgdGhpcy5jbG9zZUZpbHRlckNoYXJzID0gY2xvc2VGaWx0ZXJDaGFycztcbiAgICAgICAgdGhpcy5vcGVuQW5kQ2xvc2VGaWx0ZXJDaGFycyA9IG9wZW5BbmRDbG9zZUZpbHRlckNoYXJzO1xuXG4gICAgICAgIHRoaXMub3BlbkZpbHRlciA9IGFueU9mVGhlc2VDaGFycyh0aGlzLm9wZW5GaWx0ZXJDaGFycyk7XG4gICAgICAgIHRoaXMuY2xvc2VGaWx0ZXIgPSBhbnlPZlRoZXNlQ2hhcnModGhpcy5jbG9zZUZpbHRlckNoYXJzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFsbFN1cHBvcnRlZERlbGltaXRlcnMoKTogQm9vbGVhbkRlbGltaXRlcnMge1xuICAgICAgICBsZXQgb3BlbmluZyA9ICcnO1xuICAgICAgICBsZXQgY2xvc2luZyA9ICcnO1xuICAgICAgICBsZXQgb3BlbmluZ0FuZENsb3NpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBbb3BlbmluZ0RlbGltaXRlciwgY2xvc2luZ0RlbGltaXRlcl0gb2YgZGVsaW1pdGVyUGFpcnMpIHtcbiAgICAgICAgICAgIG9wZW5pbmcgKz0gb3BlbmluZ0RlbGltaXRlcjtcbiAgICAgICAgICAgIGNsb3NpbmcgKz0gY2xvc2luZ0RlbGltaXRlcjtcbiAgICAgICAgICAgIG9wZW5pbmdBbmRDbG9zaW5nICs9IEJvb2xlYW5EZWxpbWl0ZXJzLm9wZW5BbmRDbG9zaW5nKG9wZW5pbmdEZWxpbWl0ZXIsIGNsb3NpbmdEZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkRlbGltaXRlcnMob3BlbmluZywgY2xvc2luZywgb3BlbmluZ0FuZENsb3NpbmcpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUluc3RydWN0aW9uTGluZShpbnN0cnVjdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWRJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLnRyaW0oKTtcblxuICAgICAgICAvLyBXZSB1c2UgYSBzZXQgb2YgY2FwaXRhbHMgYW5kIHNwYWNlcyBhcyBhIHNob3J0LWN1dCB0byBtYXRjaCBBTkQsIE9SLCBOT1QsIEFORCBOT1QgZXRjLlxuICAgICAgICAvLyBUaGUgb25seSB2YWxpZCBpbml0aWFsIG9wZXJhdG9yIGlzIE5PVCwgc28gdGhpcyBtYXkgYmUgd29ydGggdGlnaHRlbmluZyB1cCwgaWZcbiAgICAgICAgLy8gZnVydGhlciB0ZXN0cyBzaG93IHRoYXQgaXQgd291bGQgYmUgd29ydGh3aGlsZS5cbiAgICAgICAgY29uc3QgZmluZEFueUluaXRpYWxVbmFyeU9wZXJhdG9yID0gL15bQS1aIF0qXFxzKiguKikvO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZmluZEFueUluaXRpYWxVbmFyeU9wZXJhdG9yLmV4ZWModHJpbW1lZEluc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uV2l0aG91dEFueUxlYWRpbmdPcGVyYXRvcnMgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDaGFyID0gaW5zdHJ1Y3Rpb25XaXRob3V0QW55TGVhZGluZ09wZXJhdG9yc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaW5zdHJ1Y3Rpb25XaXRob3V0QW55TGVhZGluZ09wZXJhdG9ycy5zbGljZSgtMSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW29wZW5pbmdEZWxpbWl0ZXIsIGNsb3NpbmdEZWxpbWl0ZXJdIG9mIGRlbGltaXRlclBhaXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gb3BlbmluZ0RlbGltaXRlciAmJiBsYXN0Q2hhciA9PT0gY2xvc2luZ0RlbGltaXRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVuaW5nQW5kQ2xvc2luZ0RlbGltaXRlcnMgPSB0aGlzLm9wZW5BbmRDbG9zaW5nKG9wZW5pbmdEZWxpbWl0ZXIsIGNsb3NpbmdEZWxpbWl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5EZWxpbWl0ZXJzKG9wZW5pbmdEZWxpbWl0ZXIsIGNsb3NpbmdEZWxpbWl0ZXIsIG9wZW5pbmdBbmRDbG9zaW5nRGVsaW1pdGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAnQWxsIGZpbHRlcnMgaW4gYSBCb29sZWFuIGluc3RydWN0aW9uIG11c3QgYmUgaW5zaWRlIG9uZSBvZiB0aGVzZSBwYWlycyBvZiBkZWxpbWl0ZXIgY2hhcmFjdGVyczogJyArXG4gICAgICAgICAgICBkZWxpbWl0ZXJQYWlyc1xuICAgICAgICAgICAgICAgIC5tYXAoKFtvcGVuLCBjbG9zZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW4gKyAnLi4uJyArIGNsb3NlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJyBvciAnKSArXG4gICAgICAgICAgICAnLiBDb21iaW5hdGlvbnMgb2YgdGhvc2UgZGVsaW1pdGVycyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgb3BlbkFuZENsb3Npbmcob3BlbmluZ0RlbGltaXRlcjogc3RyaW5nLCBjbG9zaW5nRGVsaW1pdGVyOiBzdHJpbmcpIHtcbiAgICAgICAgbGV0IG9wZW5pbmdBbmRDbG9zaW5nRGVsaW1pdGVycyA9IG9wZW5pbmdEZWxpbWl0ZXI7XG4gICAgICAgIGlmIChjbG9zaW5nRGVsaW1pdGVyICE9IG9wZW5pbmdEZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgIG9wZW5pbmdBbmRDbG9zaW5nRGVsaW1pdGVycyArPSBjbG9zaW5nRGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVuaW5nQW5kQ2xvc2luZ0RlbGltaXRlcnM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEJvb2xlYW5EZWxpbWl0ZXJzLCBhbnlPZlRoZXNlQ2hhcnMgfSBmcm9tICcuL0Jvb2xlYW5EZWxpbWl0ZXJzJztcblxuZXhwb3J0IHR5cGUgQm9vbGVhblByZXByb2Nlc3NvclJlc3VsdCA9IHtcbiAgICBzaW1wbGlmaWVkTGluZTogc3RyaW5nO1xuICAgIGZpbHRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59O1xuXG5leHBvcnQgY2xhc3MgQm9vbGVhblByZXByb2Nlc3NvciB7XG4gICAgcHVibGljIHN0YXRpYyBwcmVwcm9jZXNzRXhwcmVzc2lvbihsaW5lOiBzdHJpbmcsIGRlbGltaXRlcnM6IEJvb2xlYW5EZWxpbWl0ZXJzKTogQm9vbGVhblByZXByb2Nlc3NvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gQm9vbGVhblByZXByb2Nlc3Nvci5zcGxpdExpbmUobGluZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIHJldHVybiBCb29sZWFuUHJlcHJvY2Vzc29yLmdldEZpbHRlcnNBbmRTaW1wbGlmaWVkTGluZShwYXJ0cywgZGVsaW1pdGVycyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGxpdExpbmUobGluZTogc3RyaW5nLCBkZWxpbWl0ZXJzOiBCb29sZWFuRGVsaW1pdGVycykge1xuICAgICAgICAvLyBIZXJlLCB3ZSBzcGxpdCB0aGUgaW5wdXQgbGluZSBpbiB0byBzZXBhcmF0ZSBvcGVyYXRvcnMtcGx1cy1hZGphY2VudC1kZWxpbWl0ZXJzXG4gICAgICAgIC8vIGFuZCB0aGUgcmVtYWluaW5nIGZpbHRlciB0ZXh0LlxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBub3cgY29ycmVjdGx5IHNwbGl0IHVwIGFsbW9zdCBhbGwgdmFsaWQgQm9vbGVhbiBpbnN0cnVjdGlvbnMgLSBtYW55IG1vcmUgY2FzZXMgdGhhbiB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgcHJlcHJvY2Vzc0V4cHJlc3Npb24oKSBtZXRob2QuXG4gICAgICAgIC8vIFRoZSBvbmUgY3VycmVudCBleGNlcHRpb24gaXMgdGhhdCBhbnkgU3BhY2VzIGFuZCApIGF0IHRoZSBlbmQgb2Ygc3ViLWV4cHJlc3Npb25zL2ZpbHRlcnMgYXJlIGludGVycHJldGVkXG4gICAgICAgIC8vIGFzIHBhcnQgb2YgdGhlIEJvb2xlYW4gY29uZGl0aW9uLCBub3QgdGhlIGZpbHRlci5cblxuICAgICAgICAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyYWN0ZXJzIGZvciBCaW5hcnkgYm9vbGVhbiBvcGVyYXRvcnMgYW5kIGNyZWF0ZSBhIHJlZ2V4IHBhdHRlcm4gdG8gbWF0Y2hcbiAgICAgICAgLy8gb3BlcmF0b3JzIGFuZCBjYXB0dXJlIHN1cnJvdW5kaW5nIGRlbGltaXRlcnMuXG4gICAgICAgIC8vIFRvIHJldGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2UgbWF0Y2ggZXhwcmVzc2lvbnMgdGhhdCBoYXZlIG1pc3Npbmcgc3BhY2VzIGFyb3VuZCBBTkQsIE9SIGV0Yy5cbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRleHQgc3VjaCBhczpcbiAgICAgICAgLy8gICAnKUFORCgnXG4gICAgICAgIC8vICAgJykgQU5EICgnXG4gICAgICAgIC8vICAgJylBTkQgIE5PVCgnXG4gICAgICAgIC8vICAgJykgIEFORCAgTk9UICAoJ1xuICAgICAgICBjb25zdCBiaW5hcnlPcGVyYXRvcnNSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnKCcgKyBkZWxpbWl0ZXJzLmNsb3NlRmlsdGVyICsgJ1xcXFxzKig/OkFORHxPUnxBTkQgK05PVHxPUiArTk9UfFhPUilcXFxccyonICsgZGVsaW1pdGVycy5vcGVuRmlsdGVyICsgJyknLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIERpdmlkZSB1cCBsaW5lLCBzcGxpdCBhdCBiaW5hcnkgb3BlcmF0b3IgYm91bmRhcmllc1xuICAgICAgICBjb25zdCBzdWJzdHJpbmdzID0gbGluZS5zcGxpdChiaW5hcnlPcGVyYXRvcnNSZWdleCk7XG5cbiAgICAgICAgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcmFjdGVycyBmb3IgVW5hcnkgYm9vbGVhbiBvcGVyYXRvcnMgYW5kIGNyZWF0ZSBhIHJlZ2V4IHBhdHRlcm4gdG8gbWF0Y2hcbiAgICAgICAgLy8gb3BlcmF0b3JzIGFuZCBjYXB0dXJlIHN1cnJvdW5kaW5nIGRlbGltaXRlcnMuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0ZXh0IHN1Y2ggYXM6XG4gICAgICAgIC8vICAgJ05PVCgnXG4gICAgICAgIC8vICAgJ05PVCAoJ1xuICAgICAgICAvLyAgICdOT1QgICgnXG4gICAgICAgIGNvbnN0IHVuYXJ5T3BlcmF0b3JzUmVnZXggPSBuZXcgUmVnRXhwKCcoTk9UXFxcXHMqJyArIGRlbGltaXRlcnMub3BlbkZpbHRlciArICcpJyk7XG5cbiAgICAgICAgLy8gRGl2aWRlIHVwIHRoZSBkaXZpZGVkIGNvbXBvbmVudHMsIHRoaXMgdGltZSBzcGxpdHRpbmcgYXQgdW5hcnkgb3BlcmF0b3IgYm91bmRhcmllcy5cbiAgICAgICAgLy8gZmxhdE1hcCgpIGRpdmlkZXMgYW5kIHRoZW4gZmxhdHRlbnMgdGhlIHJlc3VsdC5cbiAgICAgICAgLy8gVGhlbiB3ZSBmaWx0ZXIgb3V0IGVtcHR5IHZhbHVlcy5cbiAgICAgICAgY29uc3Qgc3Vic3RyaW5nc1NwbGl0QXRPcGVyYXRvckJvdW5kYXJpZXMgPSBzdWJzdHJpbmdzXG4gICAgICAgICAgICAuZmxhdE1hcCgoc3Vic3RyaW5nKSA9PiBzdWJzdHJpbmcuc3BsaXQodW5hcnlPcGVyYXRvcnNSZWdleCkpXG4gICAgICAgICAgICAuZmlsdGVyKChzdWJzdHJpbmcpID0+IHN1YnN0cmluZyAhPT0gJycpO1xuXG4gICAgICAgIC8vIEFsbCB0aGF0IHJlbWFpbnMgbm93IGlzIHRvIHNlcGFyYXRlOlxuICAgICAgICAvLyAtIGFueSBzcGFjZXMgYW5kIG9wZW5pbmcgZGVsaW1pdGVycyBhdCB0aGUgc3RhcnQgb2YgZmlsdGVyc1xuICAgICAgICAvLyAtIGFueSBzcGFjZXMgYW5kIGNsb3NlICAgZGVsaW1pdGVycyBhdCB0aGUgZW5kIG9mIGZpbHRlcnNcbiAgICAgICAgY29uc3Qgb3BlbmluZ0RlbGltaXRlcnNBbmRTcGFjZXNBdFN0YXJ0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJyheJyArIGFueU9mVGhlc2VDaGFycyhkZWxpbWl0ZXJzLm9wZW5GaWx0ZXJDaGFycyArICcgJykgKyAnKiknLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNsb3NpbmdEZWxpbWl0ZXJzQW5kU3BhY2VzQXRFbmRSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnKCcgKyBhbnlPZlRoZXNlQ2hhcnMoZGVsaW1pdGVycy5jbG9zZUZpbHRlckNoYXJzICsgJyAnKSArICcqJCknLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBzdWJzdHJpbmdzU3BsaXRBdE9wZXJhdG9yQm91bmRhcmllc1xuICAgICAgICAgICAgLmZsYXRNYXAoKHN1YnN0cmluZykgPT4gc3Vic3RyaW5nLnNwbGl0KG9wZW5pbmdEZWxpbWl0ZXJzQW5kU3BhY2VzQXRTdGFydFJlZ2V4KSlcbiAgICAgICAgICAgIC5mbGF0TWFwKChzdWJzdHJpbmcpID0+IHN1YnN0cmluZy5zcGxpdChjbG9zaW5nRGVsaW1pdGVyc0FuZFNwYWNlc0F0RW5kUmVnZXgpKVxuICAgICAgICAgICAgLmZpbHRlcigoc3Vic3RyaW5nKSA9PiBzdWJzdHJpbmcgIT09ICcnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRGaWx0ZXJzQW5kU2ltcGxpZmllZExpbmUocGFydHM6IHN0cmluZ1tdLCBkZWxpbWl0ZXJzOiBCb29sZWFuRGVsaW1pdGVycykge1xuICAgICAgICAvLyBIb2xkcyB0aGUgcmVjb25zdHJ1Y3RlZCBleHByZXNzaW9uIHdpdGggcGxhY2Vob2xkZXJzXG4gICAgICAgIGxldCBzaW1wbGlmaWVkTGluZSA9ICcnO1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gMTsgLy8gUGxhY2Vob2xkZXIgaW5kZXggc3RhcnRzIGF0IDFcbiAgICAgICAgY29uc3QgZmlsdGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9OyAvLyBUbyBzdG9yZSBmaWx0ZXIgcGxhY2Vob2xkZXJzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHRcblxuICAgICAgICAvLyBMb29wIHRvIGFkZCBwbGFjZWhvbGRlcnMtZm9yLWZpbHRlcnMgb3Igb3BlcmF0b3JzIHRvIHRoZSBzaW1wbGlmaWVkTGluZVxuICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGFydCBpcyBhbiBvcGVyYXRvciBieSBtYXRjaGluZyBhZ2FpbnN0IHRoZSByZWdleCB3aXRob3V0IHN1cnJvdW5kaW5nIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBpZiAoIUJvb2xlYW5QcmVwcm9jZXNzb3IuaXNBRmlsdGVyKHBhcnQsIGRlbGltaXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhbiBvcGVyYXRvciwgc3BhY2Ugb3IgcGFyZW50aGVzaXMsIHNvIGFkZCBpdCBkaXJlY3RseSB0byB0aGUgc2ltcGxpZmllZExpbmVcbiAgICAgICAgICAgICAgICBzaW1wbGlmaWVkTGluZSArPSBgJHtwYXJ0fWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBmaWx0ZXIsIHJlcGxhY2UgaXQgd2l0aCBhIHBsYWNlaG9sZGVyLCBhbmQgc2F2ZSBpdDpcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBmJHtjdXJyZW50SW5kZXh9YDtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzW3BsYWNlaG9sZGVyXSA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgc2ltcGxpZmllZExpbmUgKz0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGJvb24tanMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHNwYWNlIGFyb3VuZCBlYWNoIG9wZXJhdG9yLlxuICAgICAgICAvLyBCZSBuaWNlIHRvIHRoZSB1c2VyIGFuZCBhZGQgYW55IG1pc3Npbmcgc3BhY2VzIGFyb3VuZCBvcGVyYXRvcnM6XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yTWlzc2luZ1ByZWNlZGluZ1NwYWNlID0gbmV3IFJlZ0V4cChgKCR7ZGVsaW1pdGVycy5jbG9zZUZpbHRlcn0pKFtBLVpdKWAsICdnJyk7XG4gICAgICAgIHNpbXBsaWZpZWRMaW5lID0gc2ltcGxpZmllZExpbmUucmVwbGFjZShvcGVyYXRvck1pc3NpbmdQcmVjZWRpbmdTcGFjZSwgJyQxICQyJyk7XG5cbiAgICAgICAgY29uc3Qgb3BlcmF0b3JNaXNzaW5nRm9sbG93aW5nU3BhY2UgPSBuZXcgUmVnRXhwKGAoW0EtWl0pKCR7ZGVsaW1pdGVycy5vcGVuRmlsdGVyfSlgLCAnZycpO1xuICAgICAgICBzaW1wbGlmaWVkTGluZSA9IHNpbXBsaWZpZWRMaW5lLnJlcGxhY2Uob3BlcmF0b3JNaXNzaW5nRm9sbG93aW5nU3BhY2UsICckMSAkMicpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgYW55IG5vbi1zdGFuZGFyZCBkZWxpbWl0ZXJzIHRvIHN0YW5kYXJkIG9uZXM6XG4gICAgICAgIGNvbnN0IG9wZW5DaGFycyA9IGRlbGltaXRlcnMub3BlbkZpbHRlckNoYXJzO1xuICAgICAgICBpZiAob3BlbkNoYXJzICE9ICdcIicgJiYgb3BlbkNoYXJzICE9ICcoJykge1xuICAgICAgICAgICAgY29uc3Qgb3BlbkRlbGltaXRlciA9IG5ldyBSZWdFeHAoYW55T2ZUaGVzZUNoYXJzKG9wZW5DaGFycyksICdnJyk7XG4gICAgICAgICAgICBzaW1wbGlmaWVkTGluZSA9IHNpbXBsaWZpZWRMaW5lLnJlcGxhY2Uob3BlbkRlbGltaXRlciwgJygnKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VDaGFycyA9IGRlbGltaXRlcnMuY2xvc2VGaWx0ZXJDaGFycztcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlRGVsaW1pdGVyID0gbmV3IFJlZ0V4cChhbnlPZlRoZXNlQ2hhcnMoY2xvc2VDaGFycyksICdnJyk7XG4gICAgICAgICAgICBzaW1wbGlmaWVkTGluZSA9IHNpbXBsaWZpZWRMaW5lLnJlcGxhY2UoY2xvc2VEZWxpbWl0ZXIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2ltcGxpZmllZExpbmUsIGZpbHRlcnMgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBpc0FGaWx0ZXIocGFydDogc3RyaW5nLCBkZWxpbWl0ZXJzOiBCb29sZWFuRGVsaW1pdGVycykge1xuICAgICAgICAvLyBUaGlzIHNldCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIHdhcyBidWlsdCB1cCBlbXBpcmljYWxseSB0aHJvdWdoIGEgbG90IG9mIGl0ZXJhdGlvbixcbiAgICAgICAgLy8gb3ZlciBhIHZlcnkgdGhvcm91Z2ggc2V0IG9mIHNhbXBsZSBCb29sZWFuIGZpbHRlcnMsIGluIG9yZGVyIHRvIGRldGVjdCBhbGwgdGhlIG91dHB1dHNcbiAgICAgICAgLy8gZnJvbSBzcGxpdExpbmUoKSB0aGF0IHdlcmUgbm90IGFjdHVhbGx5IFRhc2tzIGZpbHRlcnMuXG4gICAgICAgIGNvbnN0IG9ubHlTcGFjZXNBbmRQYXJlbnRoZXNlcyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXicgKyBhbnlPZlRoZXNlQ2hhcnMoJyAnICsgZGVsaW1pdGVycy5vcGVuQW5kQ2xvc2VGaWx0ZXJDaGFycykgKyAnKyQnLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGJpbmFyeU9wZXJhdG9yQW5kUGFyZW50aGVzZXMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14gKicgKyBkZWxpbWl0ZXJzLmNsb3NlRmlsdGVyICsgJyAqKEFORHxPUnxYT1IpIConICsgZGVsaW1pdGVycy5vcGVuRmlsdGVyICsgJyAqJCcsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdW5hcnlPcGVyYXRvckFuZFBhcmVudGhlc2VzID0gbmV3IFJlZ0V4cCgnXihBTkR8T1J8WE9SfE5PVCkgKicgKyBkZWxpbWl0ZXJzLm9wZW5GaWx0ZXIgKyAnJCcpO1xuXG4gICAgICAgIGNvbnN0IHJlbW5hbnRzT2ZOb3QgPSBuZXcgUmVnRXhwKCdeJyArIGRlbGltaXRlcnMuY2xvc2VGaWx0ZXIgKyAnICooQU5EfE9SfFhPUikkJyk7XG5cbiAgICAgICAgY29uc3QganVzdE9wZXJhdG9ycyA9IC9eKEFORHxPUnxYT1J8Tk9UKSQvO1xuXG4gICAgICAgIHJldHVybiAhW1xuICAgICAgICAgICAgb25seVNwYWNlc0FuZFBhcmVudGhlc2VzLFxuICAgICAgICAgICAgYmluYXJ5T3BlcmF0b3JBbmRQYXJlbnRoZXNlcyxcbiAgICAgICAgICAgIHVuYXJ5T3BlcmF0b3JBbmRQYXJlbnRoZXNlcyxcbiAgICAgICAgICAgIHJlbW5hbnRzT2ZOb3QsXG4gICAgICAgICAgICBqdXN0T3BlcmF0b3JzLFxuICAgICAgICBdLnNvbWUoKHJlZ2V4KSA9PiBSZWdFeHAocmVnZXgpLmV4ZWMocGFydCkpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcblxuLyoqIFN1cHBvcnQgdGhlICdmaWxlbmFtZScgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbHNvIHNlYXJjaGVzIHRoZSBmaWxlIGV4dGVuc2lvbixcbiAqIHNvICdmaWxlbmFtZSBpbmNsdWRlcyAubWQnIHdpbGwgdHlwaWNhbGx5IG1hdGNoIGFsbCB0YXNrcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlbmFtZUZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZmlsZW5hbWUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgbmFtZSBpbmNsdWRpbmcgZmlsZSBleHRlbnNpb24sIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgdGFzayBkb2VzIG5vdCBoYXZlIGEgZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGFzay5maWxlbmFtZTtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lICsgJy5tZCc7XG4gICAgfVxuXG4gICAgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlIGN1cnJlbnQgbGltaXRhdGlvbjogVGFza3MgZnJvbSBkaWZmZXJlbnQgbm90ZXMgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgbmFtZSB3aWxsIGJlIGdyb3VwZWQgdG9nZXRoZXIsIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGluXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgZmlsZXMgYW5kIHRoZWlyIGxpbmtzIHdpbGwgbG9vayBkaWZmZXJlbnQuXG4gICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHRhc2suZmlsZW5hbWU7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydVbmtub3duIExvY2F0aW9uJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWydbWycgKyBmaWxlbmFtZSArICddXSddO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0L1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyLCBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG4vKipcbiAqIFN1cHBvcnQgJ3VyZ2VuY3knIHNvcnRpbmcuXG4gKlxuICogTm90ZTogU2VhcmNoaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBpbXBsZW1lbnRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVyZ2VuY3lGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKF9saW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnRmlsdGVyaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICd1cmdlbmN5JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICB0aHJvdyBFcnJvcihgZmlsdGVyUmVnRXhwKCkgdW5pbXBsZW1lbnRlZCBmb3IgJHt0aGlzLmZpZWxkTmFtZSgpfWApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU29ydGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIEhpZ2hlciB1cmdlbmN5IHNob3VsZCBiZSBzb3J0ZWQgZWFybGllci5cbiAgICAgICAgICAgIHJldHVybiBiLnVyZ2VuY3kgLSBhLnVyZ2VuY3k7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHcm91cGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgLy8gTm90ZTogR3JvdXBzIGFyZSBzb3J0ZWQgZnJvbSBsb3cgcHJpb3JpdHkgdG8gaGlnaC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGltcHJvdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIGJ5IGFsbG93aW5nXG4gICAgICAgIC8vIHRoZSBncm91cGluZyBjb2RlIHRvIHRha2UgYWR2YW50YWdlIG9mIHRoZSBjb21wYXJhdG9yKClcbiAgICAgICAgLy8gbWV0aG9kIGFib3ZlLlxuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbYCR7dGFzay51cmdlbmN5LnRvRml4ZWQoMil9YF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBGaWVsZC5jcmVhdGVHcm91cGVyfSBjcmVhdGVzIGEgZ3JvdXBlciB0aGF0IHNvcnRzIGJ5IGluY3JlYXNpbmcgdmFsdWVzLlxuICAgICAqIEZvciB7QGxpbmsgVXJnZW5jeUZpZWxkfSB0aGUgZ3JvdXAgc29ydGluZyBzaGFsbCBiZSBkb25lIGJ5IGRlY3JlYXNpbmcgdmFsdWVzLCBzb1xuICAgICAqIHRoZSBub3JtYWwgb3JkZXIgaGVyZSBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgcmVndWxhciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSAtIGZhbHNlIGZvciBub3JtYWwgZ3JvdXAgb3JkZXIgKGZyb20gbW9zdCB1cmdlbnQgdG8gbGVzcyB1cmdlbnQpLFxuICAgICAqIHRydWUgZm9yIHJldmVyc2UgZ3JvdXAgb3JkZXIuXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXIocmV2ZXJzZTogYm9vbGVhbik6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlR3JvdXBlcighcmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdyb3VwZXJJbnN0cnVjdGlvbihyZXZlcnNlOiBib29sZWFuKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5ncm91cGVySW5zdHJ1Y3Rpb24oIXJldmVyc2UpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKipcbiAqIEEge0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbiBmb3Igc2VhcmNoaW5nIHN0YXR1cy5uYW1lXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNOYW1lRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGF0dXMubmFtZSc7XG4gICAgfVxuXG4gICAgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0YXNrLnN0YXR1cy5uYW1lO1xuICAgIH1cblxuICAgIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IFN0YXR1c1R5cGUgfSBmcm9tICcuLi8uLi9TdGF0dXNlcy9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnQvU29ydGVyJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogQSAke0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbiBmb3Igc2VhcmNoaW5nIHN0YXR1cy50eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNUeXBlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBGaWx0ZXJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBVc2UgYSByZWxheGVkIHJlZ2V4cCwganVzdCBjaGVja2luZyBmaWVsZCBuYW1lIGFuZCBub3QgdGhlIGNvbnRlbnRzLFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGUgbGluZSBsYXRlciBhbmQgZ2l2ZSBtZWFuaW5nZnVsIGVycm9ycyBpZiB1c2VyIHVzZXMgaW52YWxpZCB2YWx1ZXMuXG4gICAgICAgIGNvbnN0IHJlbGF4ZWRSZWdFeHAgPSBuZXcgUmVnRXhwKGBeKD86JHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZCgpfSlgLCAnaScpO1xuICAgICAgICByZXR1cm4gRmllbGQubGluZU1hdGNoZXNGaWx0ZXIocmVsYXhlZFJlZ0V4cCwgbGluZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgT0sgdG8gZ2V0IGhlcmUsIGJlY2F1c2UgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZSgpIHVzZXMgYSBtb3JlIHJlbGF4ZWQgcmVnZXhwLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVscE1lc3NhZ2UobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWx0ZXJPcGVyYXRvciA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN0YXR1c1R5cGVBc1N0cmluZyA9IG1hdGNoWzJdO1xuXG4gICAgICAgIGNvbnN0IHN0YXR1c1R5cGVFbGVtZW50ID0gU3RhdHVzVHlwZVtzdGF0dXNUeXBlQXNTdHJpbmcudG9VcHBlckNhc2UoKSBhcyBrZXlvZiB0eXBlb2YgU3RhdHVzVHlwZV07XG4gICAgICAgIGlmICghc3RhdHVzVHlwZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlbHBNZXNzYWdlKGxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbHRlckZ1bmN0aW9uOiBGaWx0ZXJGdW5jdGlvbjtcblxuICAgICAgICBzd2l0Y2ggKGZpbHRlck9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICdpcyc6XG4gICAgICAgICAgICAgICAgZmlsdGVyRnVuY3Rpb24gPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5zdGF0dXMudHlwZSA9PT0gc3RhdHVzVHlwZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzIG5vdCc6XG4gICAgICAgICAgICAgICAgZmlsdGVyRnVuY3Rpb24gPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5zdGF0dXMudHlwZSAhPT0gc3RhdHVzVHlwZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVscE1lc3NhZ2UobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihuZXcgRmlsdGVyKGxpbmUsIGZpbHRlckZ1bmN0aW9uLCBuZXcgRXhwbGFuYXRpb24obGluZSkpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OiR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0pIChpc3xpcyBub3QpIChbXiBdKykkYCwgJ2knKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhlbHBNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZFR5cGVzID0gT2JqZWN0LnZhbHVlcyhTdGF0dXNUeXBlKVxuICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gdCAhPT0gU3RhdHVzVHlwZS5FTVBUWSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBJbnZhbGlkICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfSBpbnN0cnVjdGlvbjogJyR7bGluZX0nLlxuICAgIEFsbG93ZWQgb3B0aW9uczogJ2lzJyBhbmQgJ2lzIG5vdCcgKHdpdGhvdXQgcXVvdGVzKS5cbiAgICBBbGxvd2VkIHZhbHVlczogICR7YWxsb3dlZFR5cGVzfVxuICAgICAgICAgICAgICAgICAgICAgTm90ZTogdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc28gJ2luX3Byb2dyZXNzJyB3b3JrcyB0b28sIGZvciBleGFtcGxlLlxuICAgIEV4YW1wbGU6ICAgICAgICAgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9IGlzIG5vdCBOT05fVEFTS2A7XG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXR1cy50eXBlJztcbiAgICB9XG5cbiAgICB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc3RhdHVzLnR5cGU7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlBID0gU3RhdHVzVHlwZUZpZWxkLmdyb3VwTmFtZShhKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUIgPSBTdGF0dXNUeXBlRmllbGQuZ3JvdXBOYW1lKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGtleUEubG9jYWxlQ29tcGFyZShrZXlCLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbU3RhdHVzVHlwZUZpZWxkLmdyb3VwTmFtZSh0YXNrKV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBOYW1lKHRhc2s6IFRhc2spIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc3RhdHVzLnR5cGVHcm91cFRleHQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwL0dyb3VwZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgUmVjdXJyZW5jZUZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdyZWN1cnJlbmNlJztcbiAgICB9XG5cbiAgICB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucmVjdXJyZW5jZSEudG9UZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0YXNrLnJlY3VycmVuY2UhLnRvVGV4dCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTm9uZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cC9Hcm91cGVyJztcbmltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcblxuZXhwb3J0IGNsYXNzIEZvbGRlckZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZm9sZGVyJztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0YXNrLmZpbGUuZm9sZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbVGV4dEZpZWxkLmVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyh0aGlzLnZhbHVlKHRhc2spKV07XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwL0dyb3VwZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgUm9vdEZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAncm9vdCc7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5maWxlLnJvb3Q7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtUZXh0RmllbGQuZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKHRoaXMudmFsdWUodGFzaykpXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgQmFja2xpbmtGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2JhY2tsaW5rJztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGxpbmtUZXh0ID0gdGFzay5nZXRMaW5rVGV4dCh7IGlzRmlsZW5hbWVVbmlxdWU6IHRydWUgfSk7XG4gICAgICAgIGlmIChsaW5rVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIExvY2F0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlua1RleHQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsICdiYWNrbGluayBmaWVsZCBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcmluZycpO1xuICAgIH1cblxuICAgIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUoX2xpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0YXNrLmZpbGVuYW1lO1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnVW5rbm93biBMb2NhdGlvbiddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0YXNrLnByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydbWycgKyBmaWxlbmFtZSArICddXSddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgYXBwZW5kIHRoZSBoZWFkZXIsIHRvIGVuc3VyZSB3ZSBuYXZpZ2F0ZSB0byB0aGUgY29ycmVjdCBzZWN0aW9uIG9mIHRoZSBmaWxlOlxuICAgICAgICAgICAgcmV0dXJuIFtgW1ske2ZpbGVuYW1lfSMke2hlYWRlcn18JHtmaWxlbmFtZX0gPiAke2hlYWRlcn1dXWBdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdjYW5jZWxsZWQnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbmNlbGxlZERhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbGxlZCc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suY2FuY2VsbGVkRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2VhcmNoSW5mbyB9IGZyb20gJy4uL1NlYXJjaEluZm8nO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja2luZ0ZpZWxkIGV4dGVuZHMgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdpcyBibG9ja2luZycsICh0YXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5pc0Jsb2NraW5nKHNlYXJjaEluZm8uYWxsVGFza3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgbm90IGJsb2NraW5nJywgKHRhc2ssIHNlYXJjaEluZm86IFNlYXJjaEluZm8pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdGFzay5pc0Jsb2NraW5nKHNlYXJjaEluZm8uYWxsVGFza3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgYmxvY2tlZCcsICh0YXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5pc0Jsb2NrZWQoc2VhcmNoSW5mby5hbGxUYXNrcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdpcyBub3QgYmxvY2tlZCcsICh0YXNrLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRhc2suaXNCbG9ja2VkKHNlYXJjaEluZm8uYWxsVGFza3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdibG9ja2luZyc7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnMgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBJZEZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbHRlckluc3RydWN0aW9uczogRmlsdGVySW5zdHJ1Y3Rpb25zID0gbmV3IEZpbHRlckluc3RydWN0aW9ucygpO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnaGFzIGlkJywgKHRhc2s6IFRhc2spID0+IHRhc2suaWQubGVuZ3RoID4gMCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnbm8gaWQnLCAodGFzazogVGFzaykgPT4gdGFzay5pZC5sZW5ndGggPT09IDApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRmlsdGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBmaWx0ZXJSZXN1bHQgPSB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgaWYgKGZpbHRlclJlc3VsdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2lkJztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0YXNrLmlkO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU29ydGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgRGVwZW5kc09uRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBmaWx0ZXJJbnN0cnVjdGlvbnM6IEZpbHRlckluc3RydWN0aW9ucyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoJ2hhcyBkZXBlbmRzIG9uJywgKHRhc2s6IFRhc2spID0+IHRhc2suZGVwZW5kc09uLmxlbmd0aCA+IDApO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoJ25vIGRlcGVuZHMgb24nLCAodGFzazogVGFzaykgPT4gdGFzay5kZXBlbmRzT24ubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgZmlsdGVyUmVzdWx0ID0gdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnVW5rbm93biBpbnN0cnVjdGlvbicpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdibG9ja2VkIGJ5JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0ZpZWxkJztcbmltcG9ydCB7IERlc2NyaXB0aW9uRmllbGQgfSBmcm9tICcuL0ZpbHRlci9EZXNjcmlwdGlvbkZpZWxkJztcbmltcG9ydCB7IENyZWF0ZWREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9DcmVhdGVkRGF0ZUZpZWxkJztcbmltcG9ydCB7IERvbmVEYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9Eb25lRGF0ZUZpZWxkJztcbmltcG9ydCB7IER1ZURhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0R1ZURhdGVGaWVsZCc7XG5pbXBvcnQgeyBSZW1pbmRlckRhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1JlbWluZGVyRGF0ZUZpZWxkJztcbmltcG9ydCB7IEV4Y2x1ZGVTdWJJdGVtc0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRXhjbHVkZVN1Ykl0ZW1zRmllbGQnO1xuaW1wb3J0IHsgRnVuY3Rpb25GaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Z1bmN0aW9uRmllbGQnO1xuaW1wb3J0IHsgSGVhZGluZ0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvSGVhZGluZ0ZpZWxkJztcbmltcG9ydCB7IFBhdGhGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1BhdGhGaWVsZCc7XG5pbXBvcnQgeyBQcmlvcml0eUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUHJpb3JpdHlGaWVsZCc7XG5pbXBvcnQgeyBTY2hlZHVsZWREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TY2hlZHVsZWREYXRlRmllbGQnO1xuaW1wb3J0IHsgU3RhcnREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TdGFydERhdGVGaWVsZCc7XG5pbXBvcnQgeyBIYXBwZW5zRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvSGFwcGVuc0RhdGVGaWVsZCc7XG5pbXBvcnQgeyBSZWN1cnJpbmdGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1JlY3VycmluZ0ZpZWxkJztcbmltcG9ydCB7IFN0YXR1c0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzRmllbGQnO1xuaW1wb3J0IHsgVGFnc0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvVGFnc0ZpZWxkJztcbmltcG9ydCB7IEJvb2xlYW5GaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Jvb2xlYW5GaWVsZCc7XG5pbXBvcnQgeyBGaWxlbmFtZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRmlsZW5hbWVGaWVsZCc7XG5pbXBvcnQgeyBVcmdlbmN5RmllbGQgfSBmcm9tICcuL0ZpbHRlci9VcmdlbmN5RmllbGQnO1xuaW1wb3J0IHsgU3RhdHVzTmFtZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzTmFtZUZpZWxkJztcbmltcG9ydCB7IFN0YXR1c1R5cGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1N0YXR1c1R5cGVGaWVsZCc7XG5cbmltcG9ydCB7IFJlY3VycmVuY2VGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1JlY3VycmVuY2VGaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXIvRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHR5cGUgeyBTb3J0ZXIgfSBmcm9tICcuL1NvcnQvU29ydGVyJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXAvR3JvdXBlcic7XG5pbXBvcnQgeyBGb2xkZXJGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0ZvbGRlckZpZWxkJztcbmltcG9ydCB7IFJvb3RGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1Jvb3RGaWVsZCc7XG5pbXBvcnQgeyBCYWNrbGlua0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvQmFja2xpbmtGaWVsZCc7XG5pbXBvcnQgeyBDYW5jZWxsZWREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9DYW5jZWxsZWREYXRlRmllbGQnO1xuaW1wb3J0IHsgQmxvY2tpbmdGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Jsb2NraW5nRmllbGQnO1xuaW1wb3J0IHsgSWRGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0lkRmllbGQnO1xuaW1wb3J0IHsgRGVwZW5kc09uRmllbGQgfSBmcm9tICcuL0ZpbHRlci9EZXBlbmRzT25GaWVsZCc7XG5cbi8vIFdoZW4gcGFyc2luZyBhIHF1ZXJ5IHRoZSBmaWVsZHMgYXJlIHRlc3RlZCBvbmUgYnkgb25lIGFjY29yZGluZyB0byB0aGlzIG9yZGVyLlxuLy8gU2luY2UgQm9vbGVhbkZpZWxkIGlzIGEgbWV0YS1maWVsZCwgd2hpY2ggbmVlZHMgdG8gYWdncmVnYXRlIGEgZmV3IGZpZWxkcyB0b2dldGhlciwgaXQgaXMgaW50ZW5kZWQgdG9cbi8vIGJlIGtlcHQgbGFzdC5cbi8vIFdoZW4gYWRkaW5nIG5ldyBmaWVsZHMga2VlcCB0aGlzIG9yZGVyIGluIG1pbmQsIHB1dHRpbmcgZmllbGRzIHRoYXQgYXJlIG1vcmUgc3BlY2lmaWMgYmVmb3JlIGZpZWxkcyB0aGF0XG4vLyBtYXkgY29udGFpbiB0aGVtLCBhbmQga2VlcCBCb29sZWFuRmllbGQgbGFzdC5cbmV4cG9ydCBjb25zdCBmaWVsZENyZWF0b3JzOiBFbmRzV2l0aDxCb29sZWFuRmllbGQ+ID0gW1xuICAgIC8vIE5FV19RVUVSWV9JTlNUUlVDVElPTl9FRElUX1JFUVVJUkVEXG4gICAgKCkgPT4gbmV3IFN0YXR1c05hbWVGaWVsZCgpLCAvLyBzdGF0dXMubmFtZSBpcyBiZWZvcmUgc3RhdHVzLCB0byBhdm9pZCBhbWJpZ3VpdHlcbiAgICAoKSA9PiBuZXcgU3RhdHVzVHlwZUZpZWxkKCksIC8vIHN0YXR1cy50eXBlIGlzIGJlZm9yZSBzdGF0dXMsIHRvIGF2b2lkIGFtYmlndWl0eVxuICAgICgpID0+IG5ldyBTdGF0dXNGaWVsZCgpLFxuICAgICgpID0+IG5ldyBSZWN1cnJpbmdGaWVsZCgpLFxuICAgICgpID0+IG5ldyBQcmlvcml0eUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEhhcHBlbnNEYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgQ2FuY2VsbGVkRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IENyZWF0ZWREYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgU3RhcnREYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgU2NoZWR1bGVkRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IER1ZURhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBSZW1pbmRlckRhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEb25lRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFBhdGhGaWVsZCgpLFxuICAgICgpID0+IG5ldyBGb2xkZXJGaWVsZCgpLFxuICAgICgpID0+IG5ldyBSb290RmllbGQoKSxcbiAgICAoKSA9PiBuZXcgQmFja2xpbmtGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEZXNjcmlwdGlvbkZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFRhZ3NGaWVsZCgpLFxuICAgICgpID0+IG5ldyBIZWFkaW5nRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRXhjbHVkZVN1Ykl0ZW1zRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRmlsZW5hbWVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBVcmdlbmN5RmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUmVjdXJyZW5jZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEZ1bmN0aW9uRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgSWRGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEZXBlbmRzT25GaWVsZCgpLFxuICAgICgpID0+IG5ldyBCbG9ja2luZ0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEJvb2xlYW5GaWVsZCgpLCAvLyAtLS0gUGxlYXNlIG1ha2Ugc3VyZSB0byBrZWVwIEJvb2xlYW5GaWVsZCBsYXN0IChzZWUgY29tbWVudCBhYm92ZSkgLS0tXG5dO1xuXG4vLyBUaGlzIHR5cGUgaGVscHMgdmVyaWZ5IHRoYXQgQm9vbGVhbkZpZWxkIGlzIGtlcHQgbGFzdFxudHlwZSBFbmRzV2l0aDxFbmQsIFQgZXh0ZW5kcyBGaWVsZCA9IEZpZWxkPiA9IFsuLi5BcnJheTwoKSA9PiBUPiwgKCkgPT4gRW5kXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmlsdGVyKGZpbHRlclN0cmluZzogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2UgfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IGNyZWF0b3Igb2YgZmllbGRDcmVhdG9ycykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNyZWF0b3IoKTtcbiAgICAgICAgaWYgKGZpZWxkLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUoZmlsdGVyU3RyaW5nKSkgcmV0dXJuIGZpZWxkLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGZpbHRlclN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTb3J0ZXIoc29ydGVyU3RyaW5nOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAvLyBOZXcgc3R5bGUgcGFyc2luZywgdXNpbmcgc29ydGluZyB3aGljaCBpcyBkb25lIGJ5IHRoZSBGaWVsZCBjbGFzc2VzLlxuXG4gICAgLy8gT3B0aW1pc2F0aW9uOiBDaGVjayB3aGV0aGVyIGxpbmUgYmVnaW5zIHdpdGggJ3NvcnQgYnknXG4gICAgY29uc3Qgc29ydEJ5UmVnZXhwID0gL15zb3J0IGJ5IC9pO1xuICAgIGlmIChzb3J0ZXJTdHJpbmcubWF0Y2goc29ydEJ5UmVnZXhwKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgaWYgYW55IG9mIHRoZSBmaWVsZHMgY2FuIHBhcnNlIHRoZSBsaW5lLlxuICAgIGZvciAoY29uc3QgY3JlYXRvciBvZiBmaWVsZENyZWF0b3JzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gY3JlYXRvcigpO1xuICAgICAgICBjb25zdCBzb3J0ZXIgPSBmaWVsZC5jcmVhdGVTb3J0ZXJGcm9tTGluZShzb3J0ZXJTdHJpbmcpO1xuICAgICAgICBpZiAoc29ydGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHcm91cGVyKGxpbmU6IHN0cmluZyk6IEdyb3VwZXIgfCBudWxsIHtcbiAgICAvLyBOZXcgc3R5bGUgcGFyc2luZywgdXNpbmcgZ3JvdXBpbmcgd2hpY2ggaXMgZG9uZSBieSB0aGUgRmllbGQgY2xhc3Nlcy5cblxuICAgIC8vIE9wdGltaXNhdGlvbjogQ2hlY2sgd2hldGhlciBsaW5lIGJlZ2lucyB3aXRoICdncm91cCBieSdcbiAgICBjb25zdCBncm91cEJ5UmVnZXhwID0gL15ncm91cCBieSAvaTtcbiAgICBpZiAobGluZS5tYXRjaChncm91cEJ5UmVnZXhwKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgaWYgYW55IG9mIHRoZSBmaWVsZHMgY2FuIHBhcnNlIHRoZSBsaW5lLlxuICAgIGZvciAoY29uc3QgY3JlYXRvciBvZiBmaWVsZENyZWF0b3JzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gY3JlYXRvcigpO1xuICAgICAgICBjb25zdCBncm91cGVyID0gZmllbGQuY3JlYXRlR3JvdXBlckZyb21MaW5lKGxpbmUpO1xuICAgICAgICBpZiAoZ3JvdXBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4iLCAiLyoqXG4gKiBTdG9yZSB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIG9uZSBoZWFkaW5nIGZvciBhIGdyb3VwIG9mIHRhc2tzLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBEaXNwbGF5SGVhZGluZyB7XG4gICAgLyoqXG4gICAgICogSG93IG5lc3RlZCB0aGUgaGVhZGluZyBpcy5cbiAgICAgKlxuICAgICAqIDAgaXMgdGhlIGZpcnN0IGdyb3VwLCBtZWFuaW5nIHRoaXMgaGVhZGluZyB3YXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogdGhlIGZpcnN0ICdncm91cCBieScgaW5zdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiAtIExldmVsIDAgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYW4gSDQgaGVhZGluZyAtIGFzIHRob3VnaCBpdCB3ZXJlIHR5cGVkIGluIG1hcmtkb3duIGFzICcjIyMjJy5cbiAgICAgKiAtIExldmVsIDEgd2lsbCBiZSBhbiBINVxuICAgICAqIC0gTGV2ZWwgMiBhbmQgYWJvdmUgd2lsbCBhbGwgYmUgSDZcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmVzdGluZ0xldmVsOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBncm91cCdzIGhlYWRpbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtYXkgY29udGFpbiBtYXJrZG93biBjaGFyYWN0ZXJzIGFuZCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcGVydHksIG9yIGZpZWxkIG5hbWUsIGluIHRoZSAnZ3JvdXAgYnknIGxpbmUgdGhhdCBnZW5lcmF0ZWQgdGhpcyBoZWFkaW5nLlxuICAgICAqIEZvciBleGFtcGxlLCAnc3RhcnRzJywgJ3N0YXR1cy50eXBlJywgb3IgJ3ByaW9yaXR5Jy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBHcm91cERpc3BsYXlIZWFkaW5nfSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZ0xldmVsIC0gU2VlIHtAbGluayBuZXN0aW5nTGV2ZWx9IGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpc3BsYXlOYW1lIC0gVGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIGZvciB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgbmFtZSwgdXN1YWxseSBmaWVsZCBuYW1lLCBpbiB0aGUgJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnZHVlJyBvciAncHJpb3JpdHknLiBUaGlzIG1heSBiZSB1c2VmdWwgaW4gc3R5bGluZyB0aGUgZ3JvdXAgaGVhZGluZ3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmVzdGluZ0xldmVsOiBudW1iZXIsIGRpc3BsYXlOYW1lOiBzdHJpbmcsIHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBHcm91cERpc3BsYXlIZWFkaW5nIH0gZnJvbSAnLi9Hcm91cERpc3BsYXlIZWFkaW5nJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlIH0gZnJvbSAnLi9UYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSc7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvZiBHcm91cC50c1xuICovXG5cbi8qKlxuICogRXhwbGFuYXRpb24gb2YgdGhlIGFsZ29yaXRobXMgdXNlZCBoZXJlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdGV4dCBpcyB0YWtlbiBmcm9tXG4gKiBodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY4NjA1MzcwODI2MTIyODU3Ny84NDAyODYyNjQ5NjQwMjIzMDIvOTU1MjQwODEyOTczODA5Njc0XG4gKlxuICogVGhlIFByb2JsZW1cbiAqID09PT09PT09PT09XG4gKlxuICogSW1hZ2luZSB0aGF0IHRoZSB1c2VyIGhhcyBzdXBwbGllZCAzICdncm91cCBieScgaW5zdHJ1Y3Rpb25zLCBhbmQgaW4gb3JkZXJcbiAqIHRvIHByZXNlbnQgdGhlIHJlc3VsdHMsIHdlIHNpbXBseSBjb25jYXRlbmF0ZSB0aGUgZ3JvdXAgbmFtZXMgdG9nZXRoZXJcbiAqIHdpdGggJz4nLlxuICpcbiAqIFNvIHRoZSBkaXNwbGF5IG1pZ2h0IGxvb2sgc29tZXRoaW5nIGxpa2U6XG4gKiAgICAgICMjIyMgMTAuMCA+IDIwMjItMDMtMjAgPiBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIDEwLjAgPiAyMDIyLTAzLTIyID4gU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDdcbiAqICAgICAgLSB0YXNrIDlcbiAqXG4gKiBUaGUgaGVhZGluZ3MgZ2V0IHZlcnkgaGFyZCB0byByZWFkLCB2ZXJ5IHF1aWNrbHkuXG4gKlxuICogV2hhdCB3ZSB3YW50IGluc3RlYWQgaXM6XG4gKiAgICAgICMjIyMgMTAuMFxuICogICAgICAjIyMjIyAyMDIyLTAzLTIwXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIyAyMDIyLTAzLTIyXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgN1xuICogICAgICAtIHRhc2sgOVxuICpcbiAqIEknbSBzdHJ1Z2dsaW5nIHRvIGdldCBteSBoZWFkIGFyb3VuZCBob3csIGluIFRTLCBJIGNhbiBzdG9yZSBzb21ldGhpbmcgbGlrZSBhIHRyZWUgc3RydWN0dXJlLFxuICogb2YgYXJiaXRyYXJ5IGRlcHRoIC0gdG8gcmVwcmVzZW50IHRoZSBncm91cGVkIHRhc2tzLlxuICpcbiAqIHBqZWJ5J3MgYW5zd2VyXG4gKiA9PT09PT09PT09PT09PVxuICpcbiAqIFVzZXIgcGplYnkgcmVwbGllZDpcbiAqIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvNjg2MDUzNzA4MjYxMjI4NTc3Lzg0MDI4NjI2NDk2NDAyMjMwMi85NTU1Nzk1NjAwMzQ5ODM5NDZcbiAqXG4gKiBJZiBhbGwgeW91J3JlIGRvaW5nIGlzIGdlbmVyYXRpbmcgaGVhZGluZ3MsIHRoZSBzaW1wbGUgYWxnb3JpdGhtIHdvdWxkIGJlIHRvIHNvcnQgZXZlcnl0aGluZyBieSBhIG11bHRpLXZhbHVlIGtleSAtXG4gKiBpLmUuLCBbbGV2ZWwgMSwgbGV2ZWwgMiwgLi4uLCBpdGVtIHNvcnQga2V5XSAtLSB0aGVuIGl0ZXJhdGUgdGhlIHdob2xlIGxpc3QgYW5kIG91dHB1dCBhIGhlYWRpbmcgZm9yIGVhY2ggbGV2ZWxcbiAqIHdoZXJlIHRoZSB2YWx1ZSBjaGFuZ2VkLlxuICpcbiAqIGkuZS4sIHlvdSBzdGFydCB3aXRoIGEgW251bGwsIG51bGwsIG51bGwsIG51bGwuLi4uXSBcImxhc3Qgc2VlblwiIGFycmF5IGFuZCBjb21wYXJlIGl0IGl0ZW0gYnkgaXRlbSB0byB0aGUgY3VycmVudFxuICogaXRlbSdzIGRhdGEsIGFuZCBvdXRwdXQgYSBoZWFkaW5nIG9mIHRoZSBjb3JyZWN0IGxldmVsIGlmIHRoZXJlJ3MgYSBjaGFuZ2UsIHVwZGF0aW5nIHRoZSBpdGVtIGluIHlvdXJcbiAqIFwibGFzdCBzZWVuXCIgYXJyYXkuXG4gKlxuICogaS5lLiBpZiB0aGUgZmlyc3QgaXRlbSBpcyBkaWZmZXJlbnQsIG91dHB1dCBhbiBIMSBmb3IgdGhlIG5ldyB2YWx1ZSBhbmQgc2V0IHRoZSByZXN0IG9mIHRoZSBhcnJheSB0byBudWxsLlxuICogSWYgdGhlIHNlY29uZCBpdGVtIGlzIGFsc28gZGlmZmVyZW50LCBvdXRwdXQgYW4gSDIsIHNhdmUgdGhlIHZhbHVlLCBzZXQgdGhlIHJlc3QgdG8gbnVsbCwgYW5kIHNvIG9uLlxuICogQWZ0ZXIgYWxsIHRoZSBsZXZlbHMgYXJlIGNoZWNrZWQsIG91dHB1dCB0aGUgYWN0dWFsIGl0ZW0uXG4gKiBJZiB0aGVyZSBhcmUgbm8gY2hhbmdlcywgdGhlbiBiYXNpY2FsbHkgeW91J2xsIGp1c3QgYmUgb3V0cHV0dGluZyB0aGUgaXRlbS5cbiAqIE5vIHRyZWVzIG9yIGdyYXBocyBvciB3aGF0bm90IG5lZWRlZC5cbiAqXG4gKiBZb3UgY291bGQgYWxzbyBqdXN0IGtlZXAgdGhlIGxhc3QgaXRlbSBhbmQgc2V0IGEgZmxhZyBhcyBzb29uIGFzIHNvbWV0aGluZyBkb2Vzbid0IG1hdGNoLCBhbmQga2VlcCBvdXRwdXR0aW5nXG4gKiBoZWFkaW5ncyBhcyBzb29uIGFzIHRoZSBmbGFnIGlzIHNldC5cbiAqXG4gKiBXaGF0IHRoZSBjb2RlIGRvZXNcbiAqID09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoZSBUYXNrR3JvdXBpbmdUcmVlIGNsYXNzIGJlbG93IGRvZXMgdGhlIGluaXRpYWwgZ3JvdXBpbmcgYW5kIHNvcnRpbmcuXG4gKlxuICogVGhlIEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3RvciBjbGFzcyBiZWxvdyBpbXBsZW1lbnRzIHBqZWJ5J3MgaGVhZGluZyBkZXRlY3Rpb24gYWxnb3JpdGhtLCBidXQgaW5zdGVhZCBvZiBkb2luZyB0aGUgcHJpbnRpbmcgZGlyZWN0bHksXG4gKiBpdCByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlYWRpbmcgbGV2ZWxzIGluIGFuIGFycmF5IG9mIEdyb3VwRGlzcGxheUhlYWRpbmcgb2JqZWN0cywgZm9yIGxhdGVyIHVzZSBpbiBRdWVyeVJlbmRlcmVyLnRzLlxuICovXG5cbi8qKlxuICogR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yIGNhbGN1bGF0ZXMgd2hpY2ggaGVhZGluZ3MgbmVlZCB0byBiZSBkaXNwbGF5ZWQsIGZvclxuICogYSBnaXZlbiBncm91cCBvZiB0YXNrcy5cbiAqXG4gKiBJdCBzZWxlY3RzIHdoaWNoIHtAbGluayBHcm91cERpc3BsYXlIZWFkaW5nfSBvYmplY3RzIHRvIGNyZWF0ZS5cbiAqXG4gKiBTZWUgdGhlIGV4cGxhbmF0aW9uIGluIEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3Rvci50cyBmb3IgaG93IGl0IHdvcmtzLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yIHtcbiAgICBwcml2YXRlIGxhc3RIZWFkaW5nQXRMZXZlbCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgcHJpdmF0ZSBncm91cGVyczogR3JvdXBlcltdO1xuXG4gICAgY29uc3RydWN0b3IodGFza0dyb3VwaW5nVHJlZVN0b3JhZ2U6IFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlLCBncm91cGVyczogR3JvdXBlcltdKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBlcnMgPSBncm91cGVycztcbiAgICAgICAgY29uc3QgZmlyc3RHcm91cCA9IHRhc2tHcm91cGluZ1RyZWVTdG9yYWdlLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IGdyb3VwQ291bnQgPSBmaXJzdEdyb3VwLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNldCBvZiBoZWFkaW5ncyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAgKiBiZWZvcmUgdGhlIHRhc2tzIHdpdGggdGhlIGdpdmVuIGdyb3VwIG5hbWVzLlxuICAgICAqXG4gICAgICogRGF0YSBmb3IgZWFjaCByZXF1aXJlZCBoZWFkaW5nIGlzIHN0b3JlZCBpbiBhIEdyb3VwRGlzcGxheUhlYWRpbmcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBncm91cE5hbWVzIDAgb3IgbW9yZSBncm91cCBuYW1lcywgb25lIHBlciAnZ3JvdXAgYnknIGxpbmVcbiAgICAgKi9cbiAgICBnZXRIZWFkaW5nc0ZvclRhc2tHcm91cChncm91cE5hbWVzOiBzdHJpbmdbXSk6IEdyb3VwRGlzcGxheUhlYWRpbmdbXSB7XG4gICAgICAgIC8vIFNlZSAncGplYnkncyBhbnN3ZXInIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgaGVhZGluZ3NGb3JHcm91cCA9IG5ldyBBcnJheTxHcm91cERpc3BsYXlIZWFkaW5nPigpO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZ3JvdXBOYW1lcy5sZW5ndGg7IGxldmVsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBOYW1lc1tsZXZlbF07XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gdGhpcy5sYXN0SGVhZGluZ0F0TGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZ3NGb3JHcm91cC5wdXNoKG5ldyBHcm91cERpc3BsYXlIZWFkaW5nKGxldmVsLCBncm91cCwgdGhpcy5ncm91cGVyc1tsZXZlbF0ucHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgdGhlIGxvd2VyIGhlYWRpbmcgbGV2ZWxzIHRvIHVuLXNlZW5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbGV2ZWw7IGogPCBncm91cE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2xldmVsXSA9IGdyb3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkaW5nc0Zvckdyb3VwO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEEgbm9kZSBpbiB0aGUgZ3JvdXBpbmcgdHJlZS4gVGhlIG5vZGUgY29udGFpbnMgdGhlXG4gKiBsaXN0IG9mIHZhbHVlcyBtYXRjaGluZyB0aGUgcGF0aCBmcm9tIHRoZSByb290IHNvIGZhciwgYW5kIGl0cyBjaGlsZHJlblxuICogYXJlIHRoZSBmdXJ0aGVyIGdyb3VwaW5nIG9mIHRob3NlIHZhbHVlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cGluZ1RyZWVOb2RlPFQ+IHtcbiAgICBjaGlsZHJlbjogTWFwPHN0cmluZywgR3JvdXBpbmdUcmVlTm9kZTxUPj4gPSBuZXcgTWFwKCk7XG4gICAgdmFsdWVzOiBUW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBHcm91cGluZ1RyZWVOb2RlIGlzIGNyZWF0ZWQsIHRoZSBjYWxsZXIgbXVzdCBwb3B1bGF0ZSB0aGUgdHJlZSBieSBhZGRpbmcgdmFsdWVzIHRvIHtAbGluayBjaGlsZHJlbn0uXG4gICAgICogU2VlIEdyb3VwaW5nVHJlZU5vZGUudGVzdC50cyBmb3IgYW4gZXhwbGFuYXRpb24gb2YgdGhlIGNvbnRlbnRzIG9mIHtAbGluayBjaGlsZHJlbn0uXG4gICAgICogQHBhcmFtIHZhbHVlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlczogVFtdKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSB0cmVlIHRvIGdlbmVyYXRlIGFsbCB0aGUgcGF0aHMgdG8gdGhlIGxlYXZlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBtYXAgZnJvbSBldmVyeSBsZWFmIHBhdGgsIHRvIHRoZSBsaXN0IG9mIHZhbHVlc1xuICAgICAqIG1hdGNoaW5nIHRoaXMgcGF0aC5cbiAgICAgKiBOT1RFOiBUaGUgbm9kZSBpdHNlbGYgZG9lc24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBwYXRocy5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFsbFBhdGhzKHBhdGhTb0Zhcjogc3RyaW5nW10gPSBbXSk6IE1hcDxzdHJpbmdbXSwgVFtdPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IExlYWYgbm9kZS4gUG9wdWxhdGUgdGhlIHJlc3VsdHMgbWFwIHdpdGggdGhlIHBhdGggdG9cbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSwgYW5kIHRoZSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGlzIHBhdGguXG4gICAgICAgICAgICByZXN1bHRNYXAuc2V0KFsuLi5wYXRoU29GYXJdLCB0aGlzLnZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwYXRoU29GYXIucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFJlc3VsdCA9IGNoaWxkLmdlbmVyYXRlQWxsUGF0aHMocGF0aFNvRmFyKTtcbiAgICAgICAgICAgIGNoaWxkUmVzdWx0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHJlc3VsdE1hcC5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgcGF0aFNvRmFyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNYXA7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IFNlYXJjaEluZm8gfSBmcm9tICcuLi9TZWFyY2hJbmZvJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgeyBHcm91cGluZ1RyZWVOb2RlIH0gZnJvbSAnLi9Hcm91cGluZ1RyZWVOb2RlJztcbmltcG9ydCB0eXBlIHsgVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UgfSBmcm9tICcuL1Rhc2tHcm91cGluZ1RyZWVTdG9yYWdlJztcblxuLypcbiAqIEEgdHJlZSBvZiB0YXNrcyB3aGVyZSBldmVyeSBsZXZlbCBpbiB0aGUgdHJlZSBjb3JyZXNwb25kcyB0byBhIGdyb3VwaW5nIHByb3BlcnR5LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlOlxuICogIyBIZWFkaW5nIDFcbiAqIC0gWyBdIFRhc2sgMVxuICogIyBIZWFkaW5nIDJcbiAqIC0gWyBdIFRhc2sgMlxuICogLSBbWF0gVGFzayAzXG4gKlxuICogQW5kIHdlIGdyb3VwIGJ5IGhlYWRpbmcgdGhlbiBzdGF0dXMsIHRoZSB0cmVlIHdpbGwgbG9vayBsaWtlOlxuICpcbiAqICAgICAgICAgICAgICAgICAgIFJvb3QgW1QxLCBUMiwgVDNdXG4gKiAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgIFxcXG4gKiAgICAgICAgICAgICAgSGVhZGluZyAxIFtUMV0gICAgIEhlYWRpbmcgW1QyLCBUM11cbiAqICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAvICAgICAgICBcXFxuICogICAgICAgICAgICAgICBUT0RPIFtUMV0gICAgIFRPRE8gW1QyXSAgICBEb25lIFtUM11cbiAqXG4gKiBUaGUgbmljZSBwcm9wZXJ0eSBvZiB0aGlzIHRyZWUgaXMgdGhhdCBldmVyeSBwYXRoIGZyb20gdGhlIHJvb3QgdG8gYSBsZWFmLCBtYXBzXG4gKiB0byBob3cgdGhlIHRhc2tzIHdpbGwgYmUgcmVuZGVyZWQuXG4gKlxuICogTk9URTogVGhlIHNhbWUgdGFzayBjYW4gYXBwZWFyIGluIG11bHRpcGxlIGxlYWYgbm9kZXMsIGlmIGl0IG1hdGNoZXMgbXVsdGlwbGUgcGF0aHMuXG4gKi9cbmNsYXNzIFRhc2tHcm91cGluZ1RyZWVOb2RlIGV4dGVuZHMgR3JvdXBpbmdUcmVlTm9kZTxUYXNrPiB7fVxuXG4vKipcbiAqIFRhc2tHcm91cGluZ1RyZWUgZG9lcyB0aGUgaW5pdGlhbCBncm91cGluZyB0b2dldGhlciBvZiB0YXNrcyxcbiAqIGluIGFyYml0cmFyeSBvcmRlci4gQ2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBzb3J0aW5nIGdyb3VwcyBpbiB0byBkZXNpcmVkIG9yZGVyLlxuICpcbiAqIEl0IGlzIGVzc2VudGlhbGx5IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBNYXAgLSBzZWUge0BsaW5rIFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlfS5cbiAqXG4gKiBJdCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgdGhlIHRhc2stZ3JvdXBpbmcgY29kZSwgYW5kIGRvZXMgbm90IG5lZWQgdG9cbiAqIGJlIHVuZGVyc3Rvb2QgaW4gb3JkZXIgdG8gZ3JvdXAgdGFza3MuXG4gKlxuICogSWRlYWxseSwgdGhpcyBjb2RlIHdvdWxkIGJlIHNpbXBsaWZpZWQgYW5kIG1vdmVkIGluIHRvIFRhc2tHcm91cHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrR3JvdXBpbmdUcmVlIHtcbiAgICBwcml2YXRlIHJvb3Q6IFRhc2tHcm91cGluZ1RyZWVOb2RlO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYSBsaXN0IG9mIHRhc2tzLCBhY2NvcmRpbmcgdG8gb25lIG9yIG1vcmUgdGFzayBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBncm91cGVycyAwIG9yIG1vcmUgR3JvdXBpbmcgdmFsdWVzLCBvbmUgcGVyICdncm91cCBieScgbGluZVxuICAgICAqIEBwYXJhbSB0YXNrcyBUaGUgdGFza3MgdGhhdCBtYXRjaCB0aGUgdGFzayBibG9jaydzIFF1ZXJ5XG4gICAgICogQHBhcmFtIHNlYXJjaEluZm9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihncm91cGVyczogR3JvdXBlcltdLCB0YXNrczogVGFza1tdLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSB7XG4gICAgICAgIC8vIFRoZSByb290IG9mIHRoZSB0cmVlIGNvbnRhaW5zIGFsbCB0aGUgdGFza3MuXG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlTm9kZSh0YXNrcyk7XG5cbiAgICAgICAgdGhpcy5idWlsZEdyb3VwaW5nVHJlZShncm91cGVycywgc2VhcmNoSW5mbyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBidWlsZEdyb3VwaW5nVHJlZShncm91cGVyczogR3JvdXBlcltdLCBzZWFyY2hJbmZvOiBTZWFyY2hJbmZvKSB7XG4gICAgICAgIC8vIFRoZSB0cmVlIGlzIGJ1aWxkIGxheWVyIGJ5IGxheWVyLCBzdGFydGluZyBmcm9tIHRoZSByb290LlxuICAgICAgICAvLyBBdCBldmVyeSBsZXZlbCwgd2UgaXRlcmF0ZSBvbiB0aGUgbm9kZXMgb2YgdGhhdCBsZXZlbCB0byBnZW5lcmF0ZVxuICAgICAgICAvLyB0aGUgbmV4dCBvbmUgdXNpbmcgdGhlIG5leHQgZ3JvdXBpbmcuXG5cbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlTGV2ZWwgPSBbdGhpcy5yb290XTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cGVyIG9mIGdyb3VwZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJlZUxldmVsID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRUcmVlTm9kZSBvZiBjdXJyZW50VHJlZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIGN1cnJlbnRUcmVlTm9kZS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHByb3BlcnRpZXMgb2YgYSB0YXNrIGZvciB0aGUgZ3JvdXBlclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmV0dXJuZWQgc3RyaW5nIGlzIHJlbmRlcmVkLCBzbyBzcGVjaWFsIE1hcmtkb3duIGNoYXJhY3RlcnMgd2lsbCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZXMgPSBncm91cGVyLmdyb3VwZXIodGFzaywgc2VhcmNoSW5mbyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmYWtlIGVtcHR5IGdyb3VwLW5hbWUgc28gdGhhdCB3ZSBjYW4gYWRkIHRoZXNlIHRhc2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgdHJlZS4gVGhpcyBncm91cCB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIG5vIGhlYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMsIHRoZXkgd291bGQgYmUgbG9zdCBhbmQgbm90IGRpc3BsYXllZCBhdCBhbGwgdGhlIHF1ZXJ5IHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cE5hbWVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBncm91cE5hbWUgb2YgZ3JvdXBOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLmdldChncm91cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlTm9kZShbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLnNldChncm91cE5hbWUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VHJlZUxldmVsLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudmFsdWVzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VHJlZUxldmVsID0gbmV4dFRyZWVMZXZlbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBHZW5lcmF0ZXMgYW4gaW50ZXJtZWRpYXRlIHN0b3JhZ2UgZm9yIHRoZSBpbml0aWFsIGdyb3VwaW5nIHRvZ2V0aGVyIG9mIHRhc2tzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBtYXAgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgZ3JvdXBzXG4gICAgICogYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSB0YXNrcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2VuZXJhdGVUYXNrVHJlZVN0b3JhZ2UoKTogVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdlbmVyYXRlQWxsUGF0aHMoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBEaXNwbGF5SGVhZGluZyB9IGZyb20gJy4vR3JvdXBEaXNwbGF5SGVhZGluZyc7XG5cbi8qKlxuICogU3RvcmUgYSBzaW5nbGUgZ3JvdXAgb2YgdGFza3MsIHRoYXQgYWxsIHNoYXJlIHRoZSBzYW1lIGdyb3VwIG5hbWVzLlxuICoge0BsaW5rIFRhc2tHcm91cH0gb2JqZWN0cyBhcmUgc3RvcmVkIGluIGEge0BsaW5rIFRhc2tHcm91cHN9IG9iamVjdC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHVzZXIgc3VwcGxpZWQgdGhlc2UgJ2dyb3VwIGJ5JyBsaW5lczpcbiAqICAgZ3JvdXAgYnkgZm9sZGVyXG4gKiAgIGdyb3VwIGJ5IGZpbGVuYW1lXG4gKiAgIGdyb3VwIGJ5IGhlYWRpbmdcbiAqIFRoZW4gdGhlIG5hbWVzIG9mIG9uZSB7QGxpbmsgVGFza0dyb3VwfSBtaWdodCBiZSB0aGlzOlxuICogICBTb21lL0ZvbGRlci9Jbi9UaGUvVmF1bHRcbiAqICAgQSBQYXJ0aWN1bGFyIEZpbGUgTmFtZVxuICogICBNeSBsb3ZlbHkgaGVhZGluZ1xuICogQW5kIHRoZSB7QGxpbmsgVGFza0dyb3VwfSB3b3VsZCBzdG9yZSBhbGwgdGhlIHRhc2tzIGZyb20gdGhhdCBsb2NhdGlvblxuICogdGhhdCBtYXRjaCB0aGUgdGFzayBibG9jaydzIGZpbHRlcnMsIGluIHRoZSB0YXNrIGJsb2NrJ3Mgc29ydCBvcmRlclxuICovXG5leHBvcnQgY2xhc3MgVGFza0dyb3VwIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCBsaXN0IG9mIG5hbWVzIG9mIHRoZSBncm91cCBwcm9wZXJ0aWVzIGZvciB0aGlzIHNldCBvZiB0YXNrcyxcbiAgICAgKiBpbiB0aGUgb3JkZXIgb2YgdGhlICdncm91cCBieScgbGluZXMgdGhlIHVzZXIgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgd2VyZSBubyAnZ3JvdXAgYnknIGluc3RydWN0aW9ucyBpbiB0aGUgdGFza3MgY29kZSBibG9jayxcbiAgICAgKiB0aGlzIHdpbGwgYmUgZW1wdHkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHN0cmluZ3MgcmV0dXJuZWQgY29udGFpbiBtYXJrZG93biBmb3IgcmVuZGVyaW5nLFxuICAgICAqIGlmIHJlcXVpcmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBncm91cHM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlYWRpbmdzIHRvIGJlIGRpc3BsYXllZCBpbiBmcm9udCBvZiB0aGlzIHNldCBvZiB0YXNrcyxcbiAgICAgKiB3aGVuIHJlbmRlcmluZyB0aGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEl0IG9ubHkgY29udGFpbnMgdGhlIG1pbmltYWwgc2V0IG9mIGhlYWRpbmdzIHJlcXVpcmVkIHRvIHNlcGFyYXRlXG4gICAgICogdGhpcyBncm91cCBvZiB0YXNrcyBmcm9tIHRoZSBwcmV2aW91cyBncm91cCBvZiB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgZ3JvdXAgb2YgdGFza3MgaGFzIHRoZSBzYW1lIGZpcnN0LWxldmVsIGhlYWRpbmcgYXMgdGhlIHByZXZpb3VzXG4gICAgICogZ3JvdXAgb2YgdGFza3MsIHRoZXJlIGlzIG5vIG5lZWQgdG8gZGlzcGxheSB0aGF0IGZpcnN0LWxldmVsIGhlYWRpbmdcbiAgICAgKiB0byBzZXBhcmF0ZSB0aGVzZSB0YXNrcyBmcm9tIHRoZSBwcmV2aW91cyBncm91cC5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIHdlcmUgbm8gJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbnMgaW4gdGhlIHRhc2tzIGNvZGUgYmxvY2ssXG4gICAgICogdGhpcyB3aWxsIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBncm91cEhlYWRpbmdzOiBHcm91cERpc3BsYXlIZWFkaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgdGhlIHRhc2tzIHRoYXQgbWF0Y2ggdGhlIHVzZXIncyBmaWx0ZXJzIGFuZCB0aGF0IGhhdmUgdGhlXG4gICAgICogZ3JvdXAgbmFtZXMgZXhhY3RseSBtYXRjaGluZyBncm91cHMoKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgdGFza3M6IFRhc2tbXTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZ3JvdXBzIC0gU2VlIHtAbGluayBncm91cHN9IGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHRhc2tzIHtUYXNrW119IC0gU2VlIHtAbGluayB0YXNrc30gZm9yIGRldGFpbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihncm91cHM6IHN0cmluZ1tdLCB0YXNrczogVGFza1tdKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICB0aGlzLmdyb3VwSGVhZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy50YXNrcyA9IHRhc2tzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRHcm91cEhlYWRpbmdzKGhlYWRpbmdzRm9yVGFza0dyb3VwOiBHcm91cERpc3BsYXlIZWFkaW5nW10pIHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cERpc3BsYXlIZWFkaW5nIG9mIGhlYWRpbmdzRm9yVGFza0dyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGluZ3MucHVzaChncm91cERpc3BsYXlIZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbWl0cyB7QGxpbmsgdGFza3N9IGFycmF5IHRvIGEgY2VydGFpbiBudW1iZXIuIFRhc2tzIGV4Y2VlZGluZ1xuICAgICAqIHRoZSBsaW1pdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZW5kLCBzaGFsbCBiZSBjYWxsZWQgb24gc29ydGVkIHRhc2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiB0YXNrcyBmb3IgdGhlIGdyb3VwIHRvIGhhdmUuIElmIGdyZWF0ZXJcbiAgICAgKiB0aGFuIHRoZSB0YXNrIGNvdW50LCBubyBhY3Rpb24gd2lsbCBiZSB0YWtlbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBhcHBseVRhc2tMaW1pdChsaW1pdDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMudGFza3MgPSB0aGlzLnRhc2tzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcmtkb3duLWZvcm1hdCByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIHRhc2tzIGluIHRoaXMgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgZm9yIHRlc3RpbmcuXG4gICAgICovXG4gICAgcHVibGljIHRhc2tzQXNTdHJpbmdPZkxpbmVzKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRoaXMudGFza3MpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRhc2sgZ3JvdXAsIGluY2x1ZGluZyBuYW1lc1xuICAgICAqIGFuZCBoZWFkaW5ncyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyB1c2VkIGluIHNuYXBzaG90IHRlc3RpbmcsIHNvIGlmIHRoZSBmb3JtYXQgaXNcbiAgICAgKiBjaGFuZ2VkLCB0aGUgc25hcHNob3RzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJ1xcbic7XG4gICAgICAgIG91dHB1dCArPSBgR3JvdXAgbmFtZXM6IFske3RoaXMuZ3JvdXBzfV1cXG5gO1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiB0aGlzLmdyb3VwSGVhZGluZ3MpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIGhlYWRpbmdzIG1pbWljIHRoZSBiZWhhdmlvdXIgb2YgUXVlcnlSZW5kZXJlcixcbiAgICAgICAgICAgIC8vIHdoaWNoIHVzZXMgJ2g0JywgJ2g1JyBhbmQgJ2g2JyBmb3IgbmVzdGVkIGdyb3Vwcy5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdQcmVmaXggPSAnIycucmVwZWF0KDQgKyBoZWFkaW5nLm5lc3RpbmdMZXZlbCk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYCR7aGVhZGluZ1ByZWZpeH0gWyR7aGVhZGluZy5wcm9wZXJ0eX1dICR7aGVhZGluZy5kaXNwbGF5TmFtZX1cXG5gO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IHRoaXMudGFza3NBc1N0cmluZ09mTGluZXMoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB0eXBlIHsgU2VhcmNoSW5mbyB9IGZyb20gJy4uL1NlYXJjaEluZm8nO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyIH0gZnJvbSAnLi9Hcm91cGVyJztcbmltcG9ydCB7IEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3RvciB9IGZyb20gJy4vR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yJztcbmltcG9ydCB7IFRhc2tHcm91cGluZ1RyZWUgfSBmcm9tICcuL1Rhc2tHcm91cGluZ1RyZWUnO1xuaW1wb3J0IHsgVGFza0dyb3VwIH0gZnJvbSAnLi9UYXNrR3JvdXAnO1xuaW1wb3J0IHR5cGUgeyBUYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSB9IGZyb20gJy4vVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UnO1xuXG4vKipcbiAqIFN0b3JlIGFsbCB0aGUgZ3JvdXBzIG9mIHRhc2tzIGdlbmVyYXRlZCBieSBhbnkgJ2dyb3VwIGJ5J1xuICogaW5zdHJ1Y3Rpb25zIGluIHRoZSB0YXNrIGJsb2NrLlxuICpcbiAqIFRoZSBncm91cHMgYXJlIHN0b3JlZCBpbiBhcnJheSBvZiB7QGxpbmsgVGFza0dyb3VwfSBvYmplY3RzLlxuICogQHNlZSB7QGxpbmsgR3JvdXBlcn1cbiAqIEBzZWUge0BsaW5rIFF1ZXJ5Lmdyb3VwaW5nfVxuICovXG5leHBvcnQgY2xhc3MgVGFza0dyb3VwcyB7XG4gICAgcHJpdmF0ZSBfZ3JvdXBlcnM6IEdyb3VwZXJbXTtcbiAgICBwcml2YXRlIF9ncm91cHM6IFRhc2tHcm91cFtdID0gbmV3IEFycmF5PFRhc2tHcm91cD4oKTtcbiAgICBwcml2YXRlIF90b3RhbFRhc2tDb3VudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3Ige0BsaW5rIFRhc2tHcm91cHN9XG4gICAgICogQHBhcmFtIHtHcm91cGVyW119IGdyb3VwcyAtIDAgb3IgbW9yZSB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0cyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgcGVyICdncm91cCBieScgbGluZSBpbiB0aGUgdGFzayBxdWVyeSBibG9ja1xuICAgICAqIEBwYXJhbSB7VGFza1tdfSB0YXNrcyAtIGFsbCB0aGUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBhbHJlYWR5IHNvcnRlZFxuICAgICAqIEBwYXJhbSBzZWFyY2hJbmZvXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3JvdXBzOiBHcm91cGVyW10sIHRhc2tzOiBUYXNrW10sIHNlYXJjaEluZm86IFNlYXJjaEluZm8pIHtcbiAgICAgICAgLy8gR3JvdXBpbmcgZG9lc24ndCBjaGFuZ2UgdGhlIG51bWJlciBvZiB0YXNrcywgYW5kIGFsbCB0aGUgdGFza3NcbiAgICAgICAgLy8gd2lsbCBiZSBzaG93biBpbiBhdCBsZWFzdCBvbmUgZ3JvdXAuXG4gICAgICAgIHRoaXMuX3RvdGFsVGFza0NvdW50ID0gdGFza3MubGVuZ3RoO1xuICAgICAgICB0aGlzLl9ncm91cGVycyA9IGdyb3VwcztcblxuICAgICAgICBjb25zdCB0YXNrR3JvdXBpbmdUcmVlID0gbmV3IFRhc2tHcm91cGluZ1RyZWUoZ3JvdXBzLCB0YXNrcywgc2VhcmNoSW5mbyk7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nVHJlZVN0b3JhZ2UgPSB0YXNrR3JvdXBpbmdUcmVlLmdlbmVyYXRlVGFza1RyZWVTdG9yYWdlKCk7XG5cbiAgICAgICAgdGhpcy5hZGRUYXNrR3JvdXBzKGdyb3VwaW5nVHJlZVN0b3JhZ2UpO1xuXG4gICAgICAgIHRoaXMuc29ydFRhc2tHcm91cHMoKTtcblxuICAgICAgICB0aGlzLnNldEdyb3Vwc0hlYWRpbmdzKGdyb3VwaW5nVHJlZVN0b3JhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUge0BsaW5rIEdyb3VwZXJ9IG9iamVjdHMsIDEgcGVyICdncm91cCBieScgbGluZSBpbiB0aGUgdGFza3MgcXVlcnkgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cGVycygpOiBHcm91cGVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSB0YXNrcyBtYXRjaGluZyB0aGUgcXVlcnksIGdyb3VwZWQgdG9nZXRoZXIsIGFuZCBpbiB0aGUgb3JkZXJcbiAgICAgKiB0aGF0IHRoZXkgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXNrcyBhcmUgdW5ncm91cGVkLCBhIHNpbmdsZSB7QGxpbmsgVGFza0dyb3VwfSB3aWxsIGJlIHJldHVybmVkLFxuICAgICAqIHdpdGggbm8gaGVhZGluZyBuYW1lcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGdyb3VwcygpOiBUYXNrR3JvdXBbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB1bmlxdWUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRhc2tzIG1heSBiZSBkaXNwbGF5ZWQgbW9yZSB0aGFuIG9uY2UuIEZvciBleGFtcGxlIGFueSB0YXNrcyB3aXRoIG1vcmUgdGhhbiBvbmVcbiAgICAgKiB0YWcgd2lsbCBiZSBkaXNwbGF5ZWQgbXVsdGlwbGUgdGltZXMgaWYgZ3JvdXBlZCBieSBUYWcuXG4gICAgICogU28gc3VtbWluZyB0aGUgbnVtYmVyIG9mIHRhc2tzIGluIGFsbCB0aGUge0BsaW5rIGdyb3Vwc30gY2FuIGdpdmUgYSBsYXJnZXIgbnVtYmVyIHRoYW5cbiAgICAgKiB0aGlzLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b3RhbFRhc2tzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRhc2tDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgdGFzayBncm91cHMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyB1c2VkIGluIHNuYXBzaG90IHRlc3RpbmcsIHNvIGlmIHRoZSBmb3JtYXQgaXNcbiAgICAgKiBjaGFuZ2VkLCB0aGUgc25hcHNob3RzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIG91dHB1dCArPSAnR3JvdXBlcnMgKGlmIGFueSk6XFxuJztcbiAgICAgICAgZm9yIChjb25zdCBncm91cGVyIG9mIHRoaXMuX2dyb3VwZXJzKSB7XG4gICAgICAgICAgICBjb25zdCByZXZlcnNlVGV4dCA9IGdyb3VwZXIucmV2ZXJzZSA/ICcgcmV2ZXJzZScgOiAnJztcbiAgICAgICAgICAgIG91dHB1dCArPSBgLSAke2dyb3VwZXIucHJvcGVydHl9JHtyZXZlcnNlVGV4dH1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFza0dyb3VwIG9mIHRoaXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gdGFza0dyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbi0tLVxcbic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxUYXNrc0NvdW50ID0gdGhpcy50b3RhbFRhc2tzQ291bnQoKTtcbiAgICAgICAgb3V0cHV0ICs9IGBcXG4ke3RvdGFsVGFza3NDb3VudH0gdGFza3NcXG5gO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVGFza0dyb3Vwcyhncm91cGluZ1RyZWVTdG9yYWdlOiBUYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtncm91cHMsIHRhc2tzXSBvZiBncm91cGluZ1RyZWVTdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrR3JvdXAgPSBuZXcgVGFza0dyb3VwKGdyb3VwcywgdGFza3MpO1xuICAgICAgICAgICAgdGhpcy5hZGRUYXNrR3JvdXAodGFza0dyb3VwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVGFza0dyb3VwKHRhc2tHcm91cDogVGFza0dyb3VwKSB7XG4gICAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKHRhc2tHcm91cCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzb3J0VGFza0dyb3VwcygpIHtcbiAgICAgICAgY29uc3QgY29tcGFyZUZuID0gKGdyb3VwMTogVGFza0dyb3VwLCBncm91cDI6IFRhc2tHcm91cCkgPT4ge1xuICAgICAgICAgICAgLy8gQ29tcGFyZSB0d28gVGFza0dyb3VwIG9iamVjdHMsIHNvcnRpbmcgdGhlbSBieSB0aGUgZ3JvdXAgbmFtZXMgYXQgZWFjaCBncm91cGluZyBsZXZlbC5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZXMxID0gZ3JvdXAxLmdyb3VwcztcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZXMyID0gZ3JvdXAyLmdyb3VwcztcbiAgICAgICAgICAgIC8vIFRoZSBjb250YWluZXJzIGFyZSBndWFyYW50ZWVkIHRvIGJlIGlkZW50aWNhbCBzaXplcyxcbiAgICAgICAgICAgIC8vIHRoZXkgaGF2ZSBvbmUgdmFsdWUgZm9yIGVhY2ggJ2dyb3VwIGJ5JyBsaW5lIGluIHRoZSBxdWVyeS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBOYW1lczEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBvbmx5IGhhdmUgb25lIHNvcnQgb3B0aW9uOiBzb3J0IGJ5IHRoZSBuYW1lcyBvZiB0aGUgZ3JvdXBzLlxuICAgICAgICAgICAgICAgIC8vIEluIGZ1dHVyZSwgd2Ugd2lsbCBhZGQgY29udHJvbCBvdmVyIHRoZSBzb3J0aW5nIG9mIGdyb3VwIGhlYWRpbmdzLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbGlrZWx5IGludm9sdmUgYWRqdXN0aW5nIHRoaXMgY29kZSB0byBzb3J0IGJ5IGFwcGx5aW5nIGEgQ29tcGFyYXRvclxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBmaXJzdCBUYXNrIGluIGVhY2ggZ3JvdXAuXG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBlciA9IHRoaXMuX2dyb3VwZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdyb3VwTmFtZXMxW2ldLmxvY2FsZUNvbXBhcmUoZ3JvdXBOYW1lczJbaV0sIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwZXIucmV2ZXJzZSA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWRlbnRpY2FsIGlmIHdlIHJlYWNoIGhlcmVcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9ncm91cHMuc29ydChjb21wYXJlRm4pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0R3JvdXBzSGVhZGluZ3MoZ3JvdXBpbmdUcmVlU3RvcmFnZTogVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgZGlzcGxheUhlYWRpbmdTZWxlY3RvciA9IG5ldyBHcm91cERpc3BsYXlIZWFkaW5nU2VsZWN0b3IoZ3JvdXBpbmdUcmVlU3RvcmFnZSwgdGhpcy5fZ3JvdXBlcnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuX2dyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXAuc2V0R3JvdXBIZWFkaW5ncyhkaXNwbGF5SGVhZGluZ1NlbGVjdG9yLmdldEhlYWRpbmdzRm9yVGFza0dyb3VwKGdyb3VwLmdyb3VwcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGltaXRzIGFsbCB7QGxpbmsgZ3JvdXBzfSB0byBoYXZlIGEgY2VydGFpbiBudW1iZXIgb2YgdGFza3MgYW5kXG4gICAgICogcmVjYWxjdWxhdGVzIHRoZSB7QGxpbmsgX3RvdGFsVGFza0NvdW50fSBmb3IgY29uc2lzdGVuY3kuXG4gICAgICpcbiAgICAgKiBJZiBubyBgZ3JvdXAgYnkgLi4uYCBpbnN0cnVjdGlvbnMgd2VyZSBwcm92aWRlZCB0aGUgbGltaXQgaXMgaWdub3JlZCxcbiAgICAgKiBob3dldmVyIHRoZXJlIHdpbGwgYmUgb25lIHRhc2sgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGltaXQgbnVtYmVyIG9mIHRhc2tzIGZvciBlYWNoIGdyb3VwIHRvIGhhdmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgYXBwbHlUYXNrTGltaXQobGltaXQ6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fZ3JvdXBlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgIGdyb3VwLmFwcGx5VGFza0xpbWl0KGxpbWl0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVRvdGFsVGFza0NvdW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdG9yZWQgdGFzayBjb3VudCB0byByZXByZXNlbnQgdGhlIG51bWJlciBvZiB1bmlxdWUgdGFza3NcbiAgICAgKiBhY3Jvc3MgYWxsIHRoZSBncm91cHMuXG4gICAgICpcbiAgICAgKiBJbiBub3JtYWwgb3BlcmF0aW9uIHRoaXMgaXMgb25seSB1c2VmdWwgYWZ0ZXIgYSBsaW1pdCB0byBncm91cCBzaXplXG4gICAgICogaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGl0IGlzIGFsc28gdXNlZnVsIGZvciB0ZXN0IGNvZGUgdG8gYmUgYWJsZSB0byBlbnN1cmUgY29uc2lzdGVuY3lcbiAgICAgKiBvZiB0YXNrIGNvdW50IGFmdGVyIHRoZSBvYmplY3QgaGFzIGJlZW4gaW5pdGlhbGx5IGNvbnN0cnVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWNhbGN1bGF0ZVRvdGFsVGFza0NvdW50KCkge1xuICAgICAgICBsZXQgY29uY2F0ZW5hdGVkVGFza3M6IFRhc2tbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgICAgICAgY29uY2F0ZW5hdGVkVGFza3MgPSBbLi4uY29uY2F0ZW5hdGVkVGFza3MsIC4uLmdyb3VwLnRhc2tzXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdW5pcXVlVGFza3MgPSBbLi4ubmV3IFNldChjb25jYXRlbmF0ZWRUYXNrcyldO1xuICAgICAgICB0aGlzLl90b3RhbFRhc2tDb3VudCA9IHVuaXF1ZVRhc2tzLmxlbmd0aDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IHR5cGUgUXVlcnlDb250ZXh0LCBtYWtlUXVlcnlDb250ZXh0V2l0aFRhc2tzIH0gZnJvbSAnLi4vU2NyaXB0aW5nL1F1ZXJ5Q29udGV4dCc7XG5cbi8qKlxuICogU2VhcmNoSW5mbyBjb250YWlucyBzZWxlY3RlZCBkYXRhIHBhc3NlZCBpbiBmcm9tIHRoZSB7QGxpbmsgUXVlcnl9IGJlaW5nIGV4ZWN1dGVkLlxuICpcbiAqIFRoaXMgaXMgdGhlIFBhcmFtZXRlciBPYmplY3QgcGF0dGVybjogaXQgaXMgYSBjb250YWluZXIgZm9yIGluZm9ybWF0aW9uIHRoYXQgbmVlZHNcbiAqIHRvIGJlIHBhc3NlZCBkb3duIHRocm91Z2ggbXVsdGlwbGUgbGV2ZWxzIG9mIGNvZGUsIHdpdGhvdXQgaGF2aW5nIHRvIHVwZGF0ZVxuICogdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZXMgb2YgYWxsIHRoZSBsYXllcnMgaW4gYmV0d2Vlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlYXJjaEluZm8ge1xuICAgIC8qKiBUaGUgbGlzdCBvZiB0YXNrcyBiZWluZyBzZWFyY2hlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYWxsVGFza3M6IFJlYWRvbmx5PFRhc2tbXT47XG4gICAgcHVibGljIHJlYWRvbmx5IHF1ZXJ5UGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHF1ZXJ5UGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLCBhbGxUYXNrczogVGFza1tdKSB7XG4gICAgICAgIHRoaXMucXVlcnlQYXRoID0gcXVlcnlQYXRoO1xuICAgICAgICB0aGlzLmFsbFRhc2tzID0gWy4uLmFsbFRhc2tzXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZyb21BbGxUYXNrcyh0YXNrczogVGFza1tdKTogU2VhcmNoSW5mbyB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoSW5mbyh1bmRlZmluZWQsIHRhc2tzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUXVlcnlDb250ZXh0fSBmcm9tIHRoaXMsIGZvciB1c2UgaW4gdGhlIHBsYWNlaG9sZGVyXG4gICAgICogZmFjaWxpdHkgYW5kIHNjcmlwdGluZyBjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiBBIFF1ZXJ5Q29udGV4dCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBwYXRoIHRvIHRoZSBxdWVyeSBmaWxlIGlzIHVua25vd24uXG4gICAgICovXG4gICAgcHVibGljIHF1ZXJ5Q29udGV4dCgpOiBRdWVyeUNvbnRleHQgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVBhdGggPyBtYWtlUXVlcnlDb250ZXh0V2l0aFRhc2tzKHRoaXMucXVlcnlQYXRoLCB0aGlzLmFsbFRhc2tzKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgVGFza0dyb3VwcyB9IGZyb20gJy4vR3JvdXAvVGFza0dyb3Vwcyc7XG5pbXBvcnQgdHlwZSB7IFRhc2tHcm91cCB9IGZyb20gJy4vR3JvdXAvVGFza0dyb3VwJztcbmltcG9ydCB7IFNlYXJjaEluZm8gfSBmcm9tICcuL1NlYXJjaEluZm8nO1xuXG5mdW5jdGlvbiB0YXNrQ291bnRQbHVyYWxpc2VkKHRhc2tzQ291bnQ6IG51bWJlcikge1xuICAgIHJldHVybiBgdGFzayR7dGFza3NDb3VudCAhPT0gMSA/ICdzJyA6ICcnfWA7XG59XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVJlc3VsdCB7XG4gICAgcHVibGljIHJlYWRvbmx5IHRhc2tHcm91cHM6IFRhc2tHcm91cHM7XG4gICAgcHVibGljIHJlYWRvbmx5IHRvdGFsVGFza3NDb3VudEJlZm9yZUxpbWl0OiBudW1iZXIgPSAwO1xuXG4gICAgcHJpdmF0ZSBfc2VhcmNoRXJyb3JNZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihncm91cHM6IFRhc2tHcm91cHMsIHRvdGFsVGFza3NDb3VudEJlZm9yZUxpbWl0OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy50YXNrR3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICB0aGlzLnRvdGFsVGFza3NDb3VudEJlZm9yZUxpbWl0ID0gdG90YWxUYXNrc0NvdW50QmVmb3JlTGltaXQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzZWFyY2hFcnJvck1lc3NhZ2UoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaEVycm9yTWVzc2FnZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldCBzZWFyY2hFcnJvck1lc3NhZ2UodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zZWFyY2hFcnJvck1lc3NhZ2UgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHRvdGFsVGFza3NDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrR3JvdXBzLnRvdGFsVGFza3NDb3VudCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b3RhbFRhc2tzQ291bnREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgY29uc3QgdGFza3NDb3VudCA9IHRoaXMudG90YWxUYXNrc0NvdW50O1xuICAgICAgICBjb25zdCB0YXNrc0NvdW50QmVmb3JlTGltaXQgPSB0aGlzLnRvdGFsVGFza3NDb3VudEJlZm9yZUxpbWl0O1xuICAgICAgICBpZiAodGFza3NDb3VudCA9PT0gdGFza3NDb3VudEJlZm9yZUxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGFza3NDb3VudH0gJHt0YXNrQ291bnRQbHVyYWxpc2VkKHRhc2tzQ291bnQpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGFza3NDb3VudH0gb2YgJHt0YXNrc0NvdW50QmVmb3JlTGltaXR9ICR7dGFza0NvdW50UGx1cmFsaXNlZCh0YXNrc0NvdW50QmVmb3JlTGltaXQpfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGdyb3VwcygpOiBUYXNrR3JvdXBbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tHcm91cHMuZ3JvdXBzO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tRXJyb3IobWVzc2FnZTogc3RyaW5nKTogUXVlcnlSZXN1bHQge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVlcnlSZXN1bHQobmV3IFRhc2tHcm91cHMoW10sIFtdLCBTZWFyY2hJbmZvLmZyb21BbGxUYXNrcyhbXSkpLCAwKTtcbiAgICAgICAgcmVzdWx0Ll9zZWFyY2hFcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0ZW1lbnQgfSBmcm9tICcuL1N0YXRlbWVudCc7XG5cbmZ1bmN0aW9uIGVuZHNXaXRoMVNsYXNoKGlucHV0TGluZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGlucHV0TGluZS5lbmRzV2l0aCgnXFxcXCcpO1xufVxuXG5mdW5jdGlvbiBlbmRzV2l0aDJTbGFzaGVzKGlucHV0TGluZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGlucHV0TGluZS5lbmRzV2l0aCgnXFxcXFxcXFwnKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nV2hpdGVzcGFjZShhZGp1c3RlZElucHV0TGluZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkSW5wdXRMaW5lLnJlcGxhY2UoL15bIFxcdF0qLywgJycpO1xufVxuXG5mdW5jdGlvbiBzdHJpcEVuZGluZ1NsYXNoQW5kUHJlY2VkaW5nV2hpdGVzcGFjZShhZGp1c3RlZElucHV0TGluZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkSW5wdXRMaW5lLnJlcGxhY2UoL1sgXFx0XSpcXFxcJC8sICcnKTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0TGluZShpbnB1dExpbmU6IHN0cmluZywgY29udGludWVQcmV2aW91c0xpbmU6IGJvb2xlYW4pIHtcbiAgICBsZXQgYWRqdXN0ZWRMaW5lID0gaW5wdXRMaW5lO1xuICAgIGlmIChjb250aW51ZVByZXZpb3VzTGluZSkge1xuICAgICAgICAvLyBUaGUgbmV3IGxpbmUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBzbyBkaXNjYXJkIGFueSBsZWFkaW5nIHdoaXRlIHNwYWNlOlxuICAgICAgICBhZGp1c3RlZExpbmUgPSBzdHJpcExlYWRpbmdXaGl0ZXNwYWNlKGlucHV0TGluZSk7XG4gICAgfVxuXG4gICAgaWYgKGVuZHNXaXRoMlNsYXNoZXMoYWRqdXN0ZWRMaW5lKSkge1xuICAgICAgICAvLyBUaGlzIGhhcyBhdCBsZWFzdCAyIGJhY2tzbGFzaGVzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUsXG4gICAgICAgIC8vIHNvIGNvbnZlcnQgJ1xcXFwnIHRvICdcXCc6XG4gICAgICAgIGFkanVzdGVkTGluZSA9IGFkanVzdGVkTGluZS5zbGljZSgwLCAtMSk7XG4gICAgfSBlbHNlIGlmIChlbmRzV2l0aDFTbGFzaChpbnB1dExpbmUpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb250aW51YXRpb24gbGluZSwgc28gcmVtb3ZlIGl0cyB0cmFpbGluZyBiYWNrc2xhc2hcbiAgICAgICAgLy8gYW5kIGFueSBzcGFyZSB3aGl0ZSBzcGFjZSBiZWZvcmVoYW5kLlxuICAgICAgICBhZGp1c3RlZExpbmUgPSBzdHJpcEVuZGluZ1NsYXNoQW5kUHJlY2VkaW5nV2hpdGVzcGFjZShhZGp1c3RlZExpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gYWRqdXN0ZWRMaW5lO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgbmV3bGluZXMgZXNjYXBlZCBieSBhIGJhY2tzbGFzaC5cbiAqIEEgdHJhaWxpbmcgYmFja3NsYXNoIGF0IHRoZSBlbmQgb2YgYSBsaW5lIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIG1vZGlmaWVkIGlucHV0LCBhcyBhIHN0cmluZ1xuICpcbiAqIEBzZWUgY29udGludWVMaW5lc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGludWVMaW5lc0ZsYXR0ZW5lZChpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29udGludWVMaW5lcyhpbnB1dClcbiAgICAgICAgLm1hcCgoaW5zdHJ1Y3Rpb24pID0+IGluc3RydWN0aW9uLmFueUNvbnRpbnVhdGlvbkxpbmVzUmVtb3ZlZClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgbmV3bGluZXMgZXNjYXBlZCBieSBhIGJhY2tzbGFzaC5cbiAqIEEgdHJhaWxpbmcgYmFja3NsYXNoIGF0IHRoZSBlbmQgb2YgYSBsaW5lIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIGl0LlxuICpcbiAqIEluc3RydWN0aW9uIGxpbmVzIGFyZSBub3QgdHJpbW1lZC5cbiAqIEJ1dCBpbnN0cnVjdGlvbnMgdGhhdCBhcmUgZW1wdHkgb3Igb25seSBjb250YWluIHdoaXRlc3BhY2UgYXJlIGRpc2NhcmRlZC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJucyBtb2RpZmllZCBpbnB1dCwgYXMgYSBsaXN0IG9mIHN0cmluZ3NcbiAqXG4gKiBAc2VlIGNvbnRpbnVlTGluZXNGbGF0dGVuZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRpbnVlTGluZXMoaW5wdXQ6IHN0cmluZyk6IFN0YXRlbWVudFtdIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnM6IFN0YXRlbWVudFtdID0gW107XG4gICAgbGV0IGNvbnRpbnVlUHJldmlvdXNMaW5lID0gZmFsc2U7XG5cbiAgICBsZXQgY3VycmVudFN0YXRlbWVudFJhdyA9ICcnO1xuICAgIGxldCBjdXJyZW50U3RhdGVtZW50UHJvY2Vzc2VkID0gJyc7XG4gICAgZm9yIChjb25zdCBpbnB1dExpbmUgb2YgaW5wdXQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkTGluZSA9IGFkanVzdExpbmUoaW5wdXRMaW5lLCBjb250aW51ZVByZXZpb3VzTGluZSk7XG4gICAgICAgIGlmIChjb250aW51ZVByZXZpb3VzTGluZSkge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlbWVudFJhdyArPSAnXFxuJyArIGlucHV0TGluZTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZW1lbnRQcm9jZXNzZWQgKz0gJyAnICsgYWRqdXN0ZWRMaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlbWVudFJhdyA9IGlucHV0TGluZTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZW1lbnRQcm9jZXNzZWQgPSBhZGp1c3RlZExpbmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSBuZXh0IGxpbmU6XG4gICAgICAgIGlmIChlbmRzV2l0aDJTbGFzaGVzKGlucHV0TGluZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlUHJldmlvdXNMaW5lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZVByZXZpb3VzTGluZSA9IGVuZHNXaXRoMVNsYXNoKGlucHV0TGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250aW51ZVByZXZpb3VzTGluZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZW1lbnRQcm9jZXNzZWQudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBTdGF0ZW1lbnQoY3VycmVudFN0YXRlbWVudFJhdywgY3VycmVudFN0YXRlbWVudFByb2Nlc3NlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFN0YXRlbWVudFJhdyA9ICcnO1xuICAgICAgICAgICAgY3VycmVudFN0YXRlbWVudFByb2Nlc3NlZCA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG59XG5cbi8qKlxuICogVGFrZSBhbiBpbnB1dCBzdHJpbmcgYW5kIHNwbGl0IGl0IGludG8gYSBsaXN0IG9mIHN0YXRlbWVudHMuXG4gKlxuICogR2VuZXJhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBzcGxpdHRpbmcgdGhlIHN0cmluZyBpbnRvIGxpbmVzLCBidXQgaGFuZGxlcyBsaW5lXG4gKiBjb250aW51YXRpb25zIGFuZCBlc2NhcGUgc2VxdWVuY2VzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBJbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIExpc3Qgb2Ygc3RhdGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbihpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBjb250aW51ZUxpbmVzKGlucHV0KS5tYXAoKGluc3RydWN0aW9uOiBTdGF0ZW1lbnQpID0+IGluc3RydWN0aW9uLmFueUNvbnRpbnVhdGlvbkxpbmVzUmVtb3ZlZCk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFN0YXR1c1R5cGVGaWVsZCB9IGZyb20gJy4uL0ZpbHRlci9TdGF0dXNUeXBlRmllbGQnO1xuaW1wb3J0IHsgRHVlRGF0ZUZpZWxkIH0gZnJvbSAnLi4vRmlsdGVyL0R1ZURhdGVGaWVsZCc7XG5pbXBvcnQgeyBSZW1pbmRlckRhdGVGaWVsZCB9IGZyb20gJy4uL0ZpbHRlci9SZW1pbmRlckRhdGVGaWVsZCc7XG5pbXBvcnQgeyBQcmlvcml0eUZpZWxkIH0gZnJvbSAnLi4vRmlsdGVyL1ByaW9yaXR5RmllbGQnO1xuaW1wb3J0IHsgUGF0aEZpZWxkIH0gZnJvbSAnLi4vRmlsdGVyL1BhdGhGaWVsZCc7XG5pbXBvcnQgeyBVcmdlbmN5RmllbGQgfSBmcm9tICcuLi9GaWx0ZXIvVXJnZW5jeUZpZWxkJztcbmltcG9ydCB0eXBlIHsgU2VhcmNoSW5mbyB9IGZyb20gJy4uL1NlYXJjaEluZm8nO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yLCBTb3J0ZXIgfSBmcm9tICcuL1NvcnRlcic7XG5cbnR5cGUgUGxhaW5Db21wYXJhdG9yID0gKGE6IFRhc2ssIGI6IFRhc2spID0+IG51bWJlcjtcblxuZXhwb3J0IGNsYXNzIFNvcnQge1xuICAgIHB1YmxpYyBzdGF0aWMgYnkoc29ydGVyczogU29ydGVyW10sIHRhc2tzOiBUYXNrW10sIHNlYXJjaEluZm86IFNlYXJjaEluZm8pIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbXBhcmF0b3JzOiBDb21wYXJhdG9yW10gPSB0aGlzLmRlZmF1bHRTb3J0ZXJzKCkubWFwKChzb3J0ZXIpID0+IHNvcnRlci5jb21wYXJhdG9yKTtcblxuICAgICAgICBjb25zdCB1c2VyQ29tcGFyYXRvcnM6IENvbXBhcmF0b3JbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc29ydGVyIG9mIHNvcnRlcnMpIHtcbiAgICAgICAgICAgIHVzZXJDb21wYXJhdG9ycy5wdXNoKHNvcnRlci5jb21wYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXNrcy5zb3J0KFNvcnQubWFrZUNvbXBvc2l0ZUNvbXBhcmF0b3IoWy4uLnVzZXJDb21wYXJhdG9ycywgLi4uZGVmYXVsdENvbXBhcmF0b3JzXSwgc2VhcmNoSW5mbykpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFNvcnRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgU3RhdHVzVHlwZUZpZWxkKCkuY3JlYXRlTm9ybWFsU29ydGVyKCksXG4gICAgICAgICAgICBuZXcgVXJnZW5jeUZpZWxkKCkuY3JlYXRlTm9ybWFsU29ydGVyKCksXG4gICAgICAgICAgICBuZXcgRHVlRGF0ZUZpZWxkKCkuY3JlYXRlTm9ybWFsU29ydGVyKCksXG4gICAgICAgICAgICBuZXcgUmVtaW5kZXJEYXRlRmllbGQoKS5jcmVhdGVOb3JtYWxTb3J0ZXIoKSxcbiAgICAgICAgICAgIG5ldyBQcmlvcml0eUZpZWxkKCkuY3JlYXRlTm9ybWFsU29ydGVyKCksXG4gICAgICAgICAgICBuZXcgUGF0aEZpZWxkKCkuY3JlYXRlTm9ybWFsU29ydGVyKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFrZUNvbXBvc2l0ZUNvbXBhcmF0b3IoY29tcGFyYXRvcnM6IENvbXBhcmF0b3JbXSwgc2VhcmNoSW5mbzogU2VhcmNoSW5mbyk6IFBsYWluQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb21wYXJhdG9yIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyYXRvcihhLCBiLCBzZWFyY2hJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB0eXBlIHsgSVF1ZXJ5IH0gZnJvbSAnLi4vSVF1ZXJ5JztcbmltcG9ydCB7IFF1ZXJ5TGF5b3V0T3B0aW9ucyB9IGZyb20gJy4uL0xheW91dC9RdWVyeUxheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgVGFza0xheW91dENvbXBvbmVudCwgVGFza0xheW91dE9wdGlvbnMgfSBmcm9tICcuLi9MYXlvdXQvVGFza0xheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlRm9yRXhjZXB0aW9uIH0gZnJvbSAnLi4vbGliL0V4Y2VwdGlvblRvb2xzJztcbmltcG9ydCB7IGxvZ2dpbmcgfSBmcm9tICcuLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQgeyBleHBhbmRQbGFjZWhvbGRlcnMgfSBmcm9tICcuLi9TY3JpcHRpbmcvRXhwYW5kUGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IG1ha2VRdWVyeUNvbnRleHQgfSBmcm9tICcuLi9TY3JpcHRpbmcvUXVlcnlDb250ZXh0JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBFeHBsYWluZXIgfSBmcm9tICcuL0V4cGxhaW4vRXhwbGFpbmVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXIvRmlsdGVyJztcbmltcG9ydCAqIGFzIEZpbHRlclBhcnNlciBmcm9tICcuL0ZpbHRlclBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXIgfSBmcm9tICcuL0dyb3VwL0dyb3VwZXInO1xuaW1wb3J0IHsgVGFza0dyb3VwcyB9IGZyb20gJy4vR3JvdXAvVGFza0dyb3Vwcyc7XG5pbXBvcnQgeyBRdWVyeVJlc3VsdCB9IGZyb20gJy4vUXVlcnlSZXN1bHQnO1xuaW1wb3J0IHsgY29udGludWVMaW5lcyB9IGZyb20gJy4vU2Nhbm5lcic7XG5pbXBvcnQgeyBTZWFyY2hJbmZvIH0gZnJvbSAnLi9TZWFyY2hJbmZvJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL1NvcnQvU29ydCc7XG5pbXBvcnQgdHlwZSB7IFNvcnRlciB9IGZyb20gJy4vU29ydC9Tb3J0ZXInO1xuaW1wb3J0IHsgU3RhdGVtZW50IH0gZnJvbSAnLi9TdGF0ZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgUXVlcnkgaW1wbGVtZW50cyBJUXVlcnkge1xuICAgIC8qKiBOb3RlOiBzb3VyY2UgaXMgdGhlIHJhdyBzb3VyY2UsIGJlZm9yZSBleHBhbmRpbmcgYW55IHBsYWNlaG9sZGVycyAqL1xuICAgIHB1YmxpYyByZWFkb25seSBzb3VyY2U6IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZmlsZVBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIHByaXZhdGUgX2xpbWl0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfdGFza0dyb3VwTGltaXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF90YXNrTGF5b3V0T3B0aW9uczogVGFza0xheW91dE9wdGlvbnMgPSBuZXcgVGFza0xheW91dE9wdGlvbnMoKTtcbiAgICBwcml2YXRlIF9xdWVyeUxheW91dE9wdGlvbnM6IFF1ZXJ5TGF5b3V0T3B0aW9ucyA9IG5ldyBRdWVyeUxheW91dE9wdGlvbnMoKTtcbiAgICBwcml2YXRlIF9maWx0ZXJzOiBGaWx0ZXJbXSA9IFtdO1xuICAgIHByaXZhdGUgX2Vycm9yOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfc29ydGluZzogU29ydGVyW10gPSBbXTtcbiAgICBwcml2YXRlIF9ncm91cGluZzogR3JvdXBlcltdID0gW107XG4gICAgcHJpdmF0ZSBfaWdub3JlR2xvYmFsUXVlcnk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgaGlkZU9wdGlvbnNSZWdleHAgPVxuICAgICAgICAvXihoaWRlfHNob3cpICh0YXNrIGNvdW50fGJhY2tsaW5rfHByaW9yaXR5fGNhbmNlbGxlZCBkYXRlfGNyZWF0ZWQgZGF0ZXxzdGFydCBkYXRlfHNjaGVkdWxlZCBkYXRlfGRvbmUgZGF0ZXxkdWUgZGF0ZXxyZW1pbmRlciBkYXRlfHJlY3VycmVuY2UgcnVsZXxlZGl0IGJ1dHRvbnxwb3N0cG9uZSBidXR0b258dXJnZW5jeXx0YWdzfGRlcGVuZHMgb258aWQpL2k7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzaG9ydE1vZGVSZWdleHAgPSAvXnNob3J0L2k7XG4gICAgcHJpdmF0ZSByZWFkb25seSBmdWxsTW9kZVJlZ2V4cCA9IC9eZnVsbC9pO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhwbGFpblF1ZXJ5UmVnZXhwID0gL15leHBsYWluL2k7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZ25vcmVHbG9iYWxRdWVyeVJlZ2V4cCA9IC9eaWdub3JlIGdsb2JhbCBxdWVyeS9pO1xuXG4gICAgbG9nZ2VyID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzLlF1ZXJ5Jyk7XG4gICAgLy8gVXNlZCBpbnRlcm5hbGx5IHRvIHVuaXF1ZWx5IGxvZyBlYWNoIHF1ZXJ5IGV4ZWN1dGlvbiBpbiB0aGUgY29uc29sZS5cbiAgICBwcml2YXRlIF9xdWVyeUlkOiBzdHJpbmcgPSAnJztcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGltaXRSZWdleHAgPSAvXmxpbWl0IChncm91cHMgKT8odG8gKT8oXFxkKykoIHRhc2tzPyk/L2k7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbW1lbnRSZWdleHAgPSAvXiMuKi87XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZywgcGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5SWQgPSB0aGlzLmdlbmVyYXRlUXVlcnlJZCgxMCk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBwYXRoO1xuXG4gICAgICAgIHRoaXMuZGVidWcoYENyZWF0aW5nIHF1ZXJ5OiAke3RoaXMuZm9ybWF0UXVlcnlGb3JMb2dnaW5nKCl9YCk7XG5cbiAgICAgICAgY29udGludWVMaW5lcyhzb3VyY2UpLmZvckVhY2goKHN0YXRlbWVudDogU3RhdGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5leHBhbmRQbGFjZWhvbGRlcnMoc3RhdGVtZW50LCBwYXRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZXhwYW5kaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUobGluZSwgc3RhdGVtZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKG1lc3NhZ2UsIHN0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHF1ZXJ5SWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5SWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUxpbmUobGluZTogc3RyaW5nLCBzdGF0ZW1lbnQ6IFN0YXRlbWVudCkge1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zaG9ydE1vZGVSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeUxheW91dE9wdGlvbnMuc2hvcnRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5mdWxsTW9kZVJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5TGF5b3V0T3B0aW9ucy5zaG9ydE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5leHBsYWluUXVlcnlSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeUxheW91dE9wdGlvbnMuZXhwbGFpblF1ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pZ25vcmVHbG9iYWxRdWVyeVJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgIHRoaXMuX2lnbm9yZUdsb2JhbFF1ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5saW1pdFJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaW1pdChsaW5lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZVNvcnRCeShsaW5lKTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZUdyb3VwQnkobGluZSk6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaGlkZU9wdGlvbnNSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSGlkZU9wdGlvbnMobGluZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuY29tbWVudFJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgbGluZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZUZpbHRlcihsaW5lLCBzdGF0ZW1lbnQpOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKCdkbyBub3QgdW5kZXJzdGFuZCBxdWVyeScsIHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGZvcm1hdFF1ZXJ5Rm9yTG9nZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnNvdXJjZS5zcGxpdCgnXFxuJykuam9pbignIDsgJyl9XWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRQbGFjZWhvbGRlcnMoc3RhdGVtZW50OiBTdGF0ZW1lbnQsIHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdGF0ZW1lbnQuYW55Q29udGludWF0aW9uTGluZXNSZW1vdmVkO1xuICAgICAgICBpZiAoc291cmNlLmluY2x1ZGVzKCd7eycpICYmIHNvdXJjZS5pbmNsdWRlcygnfX0nKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZVBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gYFRoZSBxdWVyeSBsb29rcyBsaWtlIGl0IGNvbnRhaW5zIGEgcGxhY2Vob2xkZXIsIHdpdGggXCJ7e1wiIGFuZCBcIn19XCJcbmJ1dCBubyBmaWxlIHBhdGggaGFzIGJlZW4gc3VwcGxpZWQsIHNvIGNhbm5vdCBleHBhbmQgcGxhY2Vob2xkZXIgdmFsdWVzLlxuVGhlIHF1ZXJ5IGlzOlxuJHtzb3VyY2V9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBEbyBub3QgY29tcGxhaW4gYWJvdXQgYW55IHBsYWNlaG9sZGVyIGVycm9ycyBpbiBjb21tZW50IGxpbmVzXG4gICAgICAgIC8vIFRPRE8gU2hvdyB0aGUgb3JpZ2luYWwgYW5kIGV4cGFuZGVkIHRleHQgaW4gZXhwbGFuYXRpb25zXG4gICAgICAgIC8vIFRPRE8gR2l2ZSB1c2VyIGVycm9yIGluZm8gaWYgdGhleSB0cnkgYW5kIHB1dCBhIHN0cmluZyBpbiBhIHJlZ2V4IHNlYXJjaFxuICAgICAgICBsZXQgZXhwYW5kZWRTb3VyY2U6IHN0cmluZyA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5Q29udGV4dCA9IG1ha2VRdWVyeUNvbnRleHQocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkU291cmNlID0gZXhwYW5kUGxhY2Vob2xkZXJzKHNvdXJjZSwgcXVlcnlDb250ZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gJ0ludGVybmFsIGVycm9yLiBleHBhbmRQbGFjZWhvbGRlcnMoKSB0aHJldyBzb21ldGhpbmcgb3RoZXIgdGhhbiBFcnJvci4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgZXhwYW5kZWQgdGV4dCBiYWNrIGluIHRvIHRoZSBzdGF0ZW1lbnQ6XG4gICAgICAgIHN0YXRlbWVudC5yZWNvcmRFeHBhbmRlZFBsYWNlaG9sZGVycyhleHBhbmRlZFNvdXJjZSk7XG4gICAgICAgIHJldHVybiBleHBhbmRlZFNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFwcGVuZHMge0BsaW5rIHEyfSB0byB0aGlzIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQG5vdGUgQXQgdGltZSBvZiB3cml0aW5nLCB0aGlzIHF1ZXJ5IGxhbmd1YWdlIGFwcGVhcnMgdG8gcGxheSBuaWNlbHkgd2l0aCBjb21iaW5pbmcgcXVlcmllcy5cbiAgICAgKlxuICAgICAqIE1vcmUgZm9ybWFsbHksIHRoZSBjb25jYXRlbmF0aW9uIG9wZXJhdGlvbiBvbiB0aGUgcXVlcnkgbGFuZ3VhZ2U6XG4gICAgICogICAgICogSXMgY2xvc2VkIChjb25jYXRlbmF0aW5nIHR3byBxdWVyaWVzIGlzIGFub3RoZXIgdmFsaWQgcXVlcnkpXG4gICAgICogICAgICogSXMgbm90IGNvbW11dGF0aXZlIChxMS5hcHBlbmQocTIpICE9PSBxMi5hcHBlbmQocTEpKVxuICAgICAqXG4gICAgICogQW5kIHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGNvbWJpbmF0aW9uIGFyZSBzdHJhaWdodCBmb3J3YXJkOlxuICAgICAqICAgICAqIENvbWJpbmluZyB0d28gcXVlcmllcyBhcHBlbmRzIHRoZWlyIGZpbHRlcnNcbiAgICAgKiAgICAgICAgICAgKGFzc3VtaW5nIHRoYXQgdGhlIGZpbHRlcnMgYXJlIHB1cmUgZnVuY3Rpb25zLCBmaWx0ZXIgY29uY2F0ZW5hdGlvbiBpcyBjb21tdXRhdGl2ZSlcbiAgICAgKiAgICAgKiBDb21iaW5pbmcgdHdvIHF1ZXJpZXMgYXBwZW5kcyB0aGVpciBzb3J0aW5nIGluc3RydWN0aW9ucy4gKHRoaXMgaXMgbm90IGNvbW11dGF0aXZlKVxuICAgICAqICAgICAqIENvbWJpbmluZyB0d28gcXVlcmllcyBhcHBlbmRzIHRoZWlyIGdyb3VwaW5nIGluc3RydWN0aW9ucy4gKHRoaXMgaXMgbm90IGNvbW11dGF0aXZlKVxuICAgICAqICAgICAqIFN1Y2Nlc3NpdmUgbGltaXQgaW5zdHJ1Y3Rpb25zIG92ZXJ3cml0ZSBwcmV2aW91cyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtRdWVyeX0gcTJcbiAgICAgKiBAcmV0dXJuIHtRdWVyeX0gVGhlIGNvbWJpbmVkIHF1ZXJ5XG4gICAgICovXG4gICAgcHVibGljIGFwcGVuZChxMjogUXVlcnkpOiBRdWVyeSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gJycpIHJldHVybiBxMjtcbiAgICAgICAgaWYgKHEyLnNvdXJjZSA9PT0gJycpIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KGAke3RoaXMuc291cmNlfVxcbiR7cTIuc291cmNlfWAsIHRoaXMuZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29udGVudHMgb2YgdGhpcyBxdWVyeS5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3Qgc2hvdyBhbnkgZ2xvYmFsIGZpbHRlciBhbmQgZ2xvYmFsIHF1ZXJ5LlxuICAgICAqIFVzZSB7QGxpbmsgZXhwbGFpblJlc3VsdHN9IGlmIHlvdSB3YW50IHRvIHNlZSBhbnkgZ2xvYmFsIHF1ZXJ5IGFuZCBnbG9iYWwgZmlsdGVyIGFzIHdlbGwuXG4gICAgICovXG4gICAgcHVibGljIGV4cGxhaW5RdWVyeSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBleHBsYWluZXIgPSBuZXcgRXhwbGFpbmVyKCk7XG4gICAgICAgIHJldHVybiBleHBsYWluZXIuZXhwbGFpblF1ZXJ5KHRoaXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbGltaXQoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdGFza0dyb3VwTGltaXQoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rhc2tHcm91cExpbWl0O1xuICAgIH1cblxuICAgIGdldCB0YXNrTGF5b3V0T3B0aW9ucygpOiBUYXNrTGF5b3V0T3B0aW9ucyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHF1ZXJ5TGF5b3V0T3B0aW9ucygpOiBRdWVyeUxheW91dE9wdGlvbnMge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlMYXlvdXRPcHRpb25zO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiBGaWx0ZXJbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBmaWx0ZXIgdG8gdGhpcyBRdWVyeS5cbiAgICAgKlxuICAgICAqIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcsIGl0IGlzIGludGVuZGVkIHRvIGFsbG93IHRlc3RzIHRvIGNyZWF0ZSBmaWx0ZXJzXG4gICAgICogcHJvZ3JhbWF0aWNhbGx5LCBmb3IgdGhpbmdzIHRoYXQgY2FuIG5vdCB5ZXQgYmUgZG9uZSB2aWEgJ2ZpbHRlciBieSBmdW5jdGlvbicuXG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzb3J0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHtAbGluayBHcm91cGVyfSBvYmplY3RzIHRoYXQgcmVwcmVzZW50IGFueSBgZ3JvdXAgYnlgIGluc3RydWN0aW9ucyBpbiB0aGUgdGFza3MgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cGluZygpOiBHcm91cGVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmc7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlcnJvcigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRFcnJvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgICAgIGlmIChzdGF0ZW1lbnQuYWxsTGluZXNJZGVudGljYWwoKSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBgJHttZXNzYWdlfVxuUHJvYmxlbSBsaW5lOiBcIiR7c3RhdGVtZW50LnJhd0luc3RydWN0aW9ufVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gYCR7bWVzc2FnZX1cblByb2JsZW0gc3RhdGVtZW50OlxuJHtzdGF0ZW1lbnQuZXhwbGFpblN0YXRlbWVudCgnICAgICcpfVxuYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaWdub3JlR2xvYmFsUXVlcnkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZ25vcmVHbG9iYWxRdWVyeTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXBwbHlRdWVyeVRvVGFza3ModGFza3M6IFRhc2tbXSk6IFF1ZXJ5UmVzdWx0IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRXhlY3V0aW5nIHF1ZXJ5OiAke3RoaXMuZm9ybWF0UXVlcnlGb3JMb2dnaW5nKCl9YCk7XG5cbiAgICAgICAgY29uc3Qgc2VhcmNoSW5mbyA9IG5ldyBTZWFyY2hJbmZvKHRoaXMuZmlsZVBhdGgsIHRhc2tzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0YXNrcyA9IHRhc2tzLmZpbHRlcigodGFzaykgPT4gZmlsdGVyLmZpbHRlckZ1bmN0aW9uKHRhc2ssIHNlYXJjaEluZm8pKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlYnVnU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCB0YXNrc1NvcnRlZCA9IGRlYnVnU2V0dGluZ3MuaWdub3JlU29ydEluc3RydWN0aW9ucyA/IHRhc2tzIDogU29ydC5ieSh0aGlzLnNvcnRpbmcsIHRhc2tzLCBzZWFyY2hJbmZvKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzU29ydGVkTGltaXRlZCA9IHRhc2tzU29ydGVkLnNsaWNlKDAsIHRoaXMubGltaXQpO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrR3JvdXBzID0gbmV3IFRhc2tHcm91cHModGhpcy5ncm91cGluZywgdGFza3NTb3J0ZWRMaW1pdGVkLCBzZWFyY2hJbmZvKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rhc2tHcm91cExpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXNrR3JvdXBzLmFwcGx5VGFza0xpbWl0KHRoaXMuX3Rhc2tHcm91cExpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVJlc3VsdCh0YXNrR3JvdXBzLCB0YXNrc1NvcnRlZC5sZW5ndGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9ICdTZWFyY2ggZmFpbGVkJztcbiAgICAgICAgICAgIHJldHVybiBRdWVyeVJlc3VsdC5mcm9tRXJyb3IoZXJyb3JNZXNzYWdlRm9yRXhjZXB0aW9uKGRlc2NyaXB0aW9uLCBlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlSGlkZU9wdGlvbnMobGluZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGhpZGVPcHRpb25zTWF0Y2ggPSBsaW5lLm1hdGNoKHRoaXMuaGlkZU9wdGlvbnNSZWdleHApO1xuICAgICAgICBpZiAoaGlkZU9wdGlvbnNNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaGlkZSA9IGhpZGVPcHRpb25zTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2hpZGUnO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gaGlkZU9wdGlvbnNNYXRjaFsyXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Rhc2sgY291bnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeUxheW91dE9wdGlvbnMuaGlkZVRhc2tDb3VudCA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JhY2tsaW5rJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlMYXlvdXRPcHRpb25zLmhpZGVCYWNrbGlua3MgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwb3N0cG9uZSBidXR0b24nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeUxheW91dE9wdGlvbnMuaGlkZVBvc3Rwb25lQnV0dG9uID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJpb3JpdHknOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuUHJpb3JpdHksICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuY2VsbGVkIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuQ2FuY2VsbGVkRGF0ZSwgIWhpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGVkIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuQ3JlYXRlZERhdGUsICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tMYXlvdXRPcHRpb25zLnNldFZpc2liaWxpdHkoVGFza0xheW91dENvbXBvbmVudC5TdGFydERhdGUsICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NoZWR1bGVkIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuU2NoZWR1bGVkRGF0ZSwgIWhpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkdWUgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tMYXlvdXRPcHRpb25zLnNldFZpc2liaWxpdHkoVGFza0xheW91dENvbXBvbmVudC5EdWVEYXRlLCAhaGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbWluZGVyIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuUmVtaW5kZXJEYXRlLCAhaGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvbmUgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tMYXlvdXRPcHRpb25zLnNldFZpc2liaWxpdHkoVGFza0xheW91dENvbXBvbmVudC5Eb25lRGF0ZSwgIWhpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlIHJ1bGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuUmVjdXJyZW5jZVJ1bGUsICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdCBidXR0b24nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeUxheW91dE9wdGlvbnMuaGlkZUVkaXRCdXR0b24gPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1cmdlbmN5JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlMYXlvdXRPcHRpb25zLmhpZGVVcmdlbmN5ID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFncyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tMYXlvdXRPcHRpb25zLnNldFRhZ3NWaXNpYmlsaXR5KCFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXNrTGF5b3V0T3B0aW9ucy5zZXRWaXNpYmlsaXR5KFRhc2tMYXlvdXRDb21wb25lbnQuSWQsICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVwZW5kcyBvbic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tMYXlvdXRPcHRpb25zLnNldFZpc2liaWxpdHkoVGFza0xheW91dENvbXBvbmVudC5EZXBlbmRzT24sICFoaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcignZG8gbm90IHVuZGVyc3RhbmQgaGlkZS9zaG93IG9wdGlvbicsIG5ldyBTdGF0ZW1lbnQobGluZSwgbGluZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUZpbHRlcihsaW5lOiBzdHJpbmcsIHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGZpbHRlck9yRXJyb3IgPSBGaWx0ZXJQYXJzZXIucGFyc2VGaWx0ZXIobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJPckVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJPckVycm9yLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZmlsdGVyJ3Mgc3RhdGVtZW50LCB0byBwcmVzZXJ2ZSBkZXRhaWxzIG9mIGFueVxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVhdGlvbiBsaW5lcyBhbmQgcGxhY2Vob2xkZXIgZXhwYW5zaW9ucy5cbiAgICAgICAgICAgICAgICBmaWx0ZXJPckVycm9yLmZpbHRlci5zZXRTdGF0ZW1lbnQoc3RhdGVtZW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaChmaWx0ZXJPckVycm9yLmZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoZmlsdGVyT3JFcnJvci5lcnJvciA/PyAnVW5rbm93biBlcnJvcicsIHN0YXRlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUxpbWl0KGxpbmU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBsaW1pdE1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmxpbWl0UmVnZXhwKTtcbiAgICAgICAgaWYgKGxpbWl0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGxpbWl0JywgbmV3IFN0YXRlbWVudChsaW5lLCBsaW5lKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdE1hdGNoWzNdIGlzIHBlciByZWdleCBhbHdheXMgZGlnaXRzIGFuZCB0aGVyZWZvcmUgcGFyc2FibGUuXG4gICAgICAgIGNvbnN0IGxpbWl0RnJvbUxpbmUgPSBOdW1iZXIucGFyc2VJbnQobGltaXRNYXRjaFszXSwgMTApO1xuXG4gICAgICAgIGlmIChsaW1pdE1hdGNoWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tHcm91cExpbWl0ID0gbGltaXRGcm9tTGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXRGcm9tTGluZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VTb3J0QnkobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHNvcnRpbmdNYXliZSA9IEZpbHRlclBhcnNlci5wYXJzZVNvcnRlcihsaW5lKTtcbiAgICAgICAgaWYgKHNvcnRpbmdNYXliZSkge1xuICAgICAgICAgICAgdGhpcy5fc29ydGluZy5wdXNoKHNvcnRpbmdNYXliZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBvZiBgZ3JvdXAgYnlgIGxpbmVzLCBmb3IgZ3JvdXBpbmcgdGhhdCBpcyBpbXBsZW1lbnRlZCBpbiB0aGUge0BsaW5rIEZpZWxkfVxuICAgICAqIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYXJzZUdyb3VwQnkobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nTWF5YmUgPSBGaWx0ZXJQYXJzZXIucGFyc2VHcm91cGVyKGxpbmUpO1xuICAgICAgICBpZiAoZ3JvdXBpbmdNYXliZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBpbmcucHVzaChncm91cGluZ01heWJlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5pcXVlIElEIGZvciBjb3JyZWxhdGlvbiBvZiBjb25zb2xlIGxvZ2dpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiBAcmV0dXJuIHsqfSAge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgUXVlcnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlUXVlcnlJZChsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNoYXJzID0gJ0FhQmJDY0RkRWVGZkdnSGhJaUpqS2tMbE1tTm5Pb1BwUXFSclNzVHRVdVZ2V3dYeFl5WnoxMjM0NTY3ODkwJztcbiAgICAgICAgY29uc3QgcmFuZG9tQXJyYXkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IGNoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCldKTtcblxuICAgICAgICBjb25zdCByYW5kb21TdHJpbmcgPSByYW5kb21BcnJheS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbVN0cmluZztcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVidWcobWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnV2l0aElkKHRoaXMuX3F1ZXJ5SWQsIGBcIiR7dGhpcy5maWxlUGF0aH1cIjogJHttZXNzYWdlfWAsIG9iamVjdHMpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4uL1F1ZXJ5L1F1ZXJ5JztcblxuLyoqXG4gKiBHbG9iYWwgUXVlcnkgc2V0IGluIHRoZSB7QGxpbmsgU2V0dGluZ3NUYWJ9IGFuZCBhc3NvY2lhdGVkIHNlcnZpY2VzLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyBvZiB1c2luZyB0aGlzIGNsYXNzLlxuICogLSBJbiAncHJvZHVjdGlvbicgY29kZSwgdGhhdCBpcyBpbiB0aGUgYWN0dWFsIHBsdWdpbiBjb2RlIHRoYXQgaXMgcmVsZWFzZWQsXG4gKiAgIGNhbGwge0BsaW5rIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCl9IHRvIG9idGFpbiB0aGUgc2luZ2xlIGdsb2JhbCBpbnN0YW5jZS5cbiAqIC0gVGVzdHMgb2YgR2xvYmFsIFF1ZXJ5IGNhcGFiaWxpdGllcyBkbyBub3QgbmVlZCB0byBtb2RpZnkgdGhlIGdsb2JhbCBpbnN0YW5jZTpcbiAqICAgVGhleSBzaG91bGQgdXNlIGBuZXcgR2xvYmFsUXVlcnkoKWAsIHdoaWNoIG1ha2VzIHNpbXBsZXIsIG1vcmUgcmVhZGFibGVcbiAqICAgdGVzdHMgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBHbG9iYWxRdWVyeVxuICovXG5leHBvcnQgY2xhc3MgR2xvYmFsUXVlcnkge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBHbG9iYWxRdWVyeTtcblxuICAgIHN0YXRpYyBlbXB0eSA9ICcnO1xuICAgIHByaXZhdGUgX3NvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR2xvYmFsIFF1ZXJ5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIENvZGUgaW4gdGhlIHBsdWdpbiBzaG91bGQgdXNlIHtAbGluayBnZXRJbnN0YW5jZX0gdG8gYWNjZXNzIHRoZSBHbG9iYWwgUXVlcnkgc2VydmljZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlOiBzdHJpbmcgPSBHbG9iYWxRdWVyeS5lbXB0eSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBzaW5nbGUgZ2xvYmFsIGluc3RhbmNlIG9mIHRoZSBHbG9iYWwgUXVlcnkuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgcGx1Z2luIGNvZGUuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBHbG9iYWxRdWVyeSB7XG4gICAgICAgIGlmICghR2xvYmFsUXVlcnkuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIEdsb2JhbFF1ZXJ5Lmluc3RhbmNlID0gbmV3IEdsb2JhbFF1ZXJ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gR2xvYmFsUXVlcnkuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIHNldChzb3VyY2U6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgUXVlcnl9IG9iamVjdCB3aXRoIHRoZSBHbG9iYWwgUXVlcnlcbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIHB1YmxpYyBxdWVyeShwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpOiBRdWVyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5fc291cmNlLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIEdsb2JhbCBRdWVyeSBjb250YWlucyBjaGFyYWN0ZXJzIGV4Y2VwdCBsaW5lIGJyZWFrcyBhbmQgc3BhY2VzLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGhhc0luc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS50cmltKCkgIT09IEdsb2JhbFF1ZXJ5LmVtcHR5O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEV2ZW50UmVmLCBFdmVudHMgYXMgT2JzaWRpYW5FdmVudHMgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBsb2dnaW5nIH0gZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSB9IGZyb20gJy4vQ2FjaGUnO1xuXG5lbnVtIEV2ZW50IHtcbiAgICBDYWNoZVVwZGF0ZSA9ICdvYnNpZGlhbi10YXNrcy1wbHVnaW46Y2FjaGUtdXBkYXRlJyxcbiAgICBSZXF1ZXN0Q2FjaGVVcGRhdGUgPSAnb2JzaWRpYW4tdGFza3MtcGx1Z2luOnJlcXVlc3QtY2FjaGUtdXBkYXRlJyxcbn1cblxuaW50ZXJmYWNlIENhY2hlVXBkYXRlRGF0YSB7XG4gICAgdGFza3M6IFRhc2tbXTtcbiAgICBzdGF0ZTogU3RhdGU7XG59XG5cbmV4cG9ydCBjbGFzcyBUYXNrc0V2ZW50cyB7XG4gICAgcHJpdmF0ZSBvYnNpZGlhbkV2ZW50czogT2JzaWRpYW5FdmVudHM7XG4gICAgbG9nZ2VyID0gbG9nZ2luZy5nZXRMb2dnZXIoJ3Rhc2tzLkV2ZW50cycpO1xuXG4gICAgY29uc3RydWN0b3IoeyBvYnNpZGlhbkV2ZW50cyB9OiB7IG9ic2lkaWFuRXZlbnRzOiBPYnNpZGlhbkV2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMgPSBvYnNpZGlhbkV2ZW50cztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DYWNoZVVwZGF0ZShoYW5kbGVyOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdUYXNrc0V2ZW50cy5vbkNhY2hlVXBkYXRlKCknKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzaWRpYW5FdmVudHMub24oRXZlbnQuQ2FjaGVVcGRhdGUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyQ2FjaGVVcGRhdGUoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1Rhc2tzRXZlbnRzLnRyaWdnZXJDYWNoZVVwZGF0ZSgpJyk7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMudHJpZ2dlcihFdmVudC5DYWNoZVVwZGF0ZSwgY2FjaGVEYXRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25SZXF1ZXN0Q2FjaGVVcGRhdGUoaGFuZGxlcjogKGZuOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdUYXNrc0V2ZW50cy5vblJlcXVlc3RDYWNoZVVwZGF0ZSgpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2lkaWFuRXZlbnRzLm9uKEV2ZW50LlJlcXVlc3RDYWNoZVVwZGF0ZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcHVibGljIHRyaWdnZXJSZXF1ZXN0Q2FjaGVVcGRhdGUoZm46IChjYWNoZURhdGE6IENhY2hlVXBkYXRlRGF0YSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVGFza3NFdmVudHMudHJpZ2dlclJlcXVlc3RDYWNoZVVwZGF0ZSgpJyk7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMudHJpZ2dlcihFdmVudC5SZXF1ZXN0Q2FjaGVVcGRhdGUsIGZuKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb2ZmKGV2ZW50UmVmOiBFdmVudFJlZik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVGFza3NFdmVudHMub2ZmKCknKTtcbiAgICAgICAgdGhpcy5vYnNpZGlhbkV2ZW50cy5vZmZyZWYoZXZlbnRSZWYpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IE1hcmtkb3duUmVuZGVyQ2hpbGQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB7IFRhc2tMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi4vTGF5b3V0L1Rhc2tMYXlvdXRPcHRpb25zJztcbmltcG9ydCB7IFF1ZXJ5TGF5b3V0T3B0aW9ucyB9IGZyb20gJy4uL0xheW91dC9RdWVyeUxheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgVGFza3NGaWxlIH0gZnJvbSAnLi4vU2NyaXB0aW5nL1Rhc2tzRmlsZSc7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFRhc2tMaW5lUmVuZGVyZXIgfSBmcm9tICcuLi9SZW5kZXJlci9UYXNrTGluZVJlbmRlcmVyJztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2svVGFza0xvY2F0aW9uJztcblxuZXhwb3J0IGNsYXNzIElubGluZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiB9OiB7IHBsdWdpbjogUGx1Z2luIH0pIHtcbiAgICAgICAgcGx1Z2luLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKHRoaXMuX21hcmtkb3duUG9zdFByb2Nlc3Nvci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFya2Rvd25Qb3N0UHJvY2Vzc29yID0gdGhpcy5fbWFya2Rvd25Qb3N0UHJvY2Vzc29yLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlbmRlcnMgYSBmaWxlJ3MgdGFzayBsaXN0IHdoZW4gcmVuZGVyZWQgaW4gUmVhZGluZyBWaWV3LCB1c2luZyByb3VnaGx5IHRoZSBzYW1lIHBpcGVsaW5lXG4gICAgICogb2YgUXVlcnlSZW5kZXJlciAoZS5nLiBpdCByZW1vdmVzIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBoYW5kbGVzIG90aGVyIGZvcm1hdHRpbmcpLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX21hcmtkb3duUG9zdFByb2Nlc3NvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGV4dDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBBcyBvZiBPYnNpZGlhbiAxLjMuMCwgaXQgaXMgcmVxdWlyZWQgYnkgT2JzaWRpYW4gdG8gY3JlYXRlIGFuZC9vciBwYXNzIGEgQ29tcG9uZW50IG9iamVjdFxuICAgICAgICAvLyB3aGVuIHVzaW5nIGl0cyBNYXJrZG93biByZW5kZXJpbmcgbWV0aG9kc1xuICAgICAgICBjb25zdCBjaGlsZENvbXBvbmVudCA9IG5ldyBNYXJrZG93blJlbmRlckNoaWxkKGVsZW1lbnQpO1xuICAgICAgICBjb250ZXh0LmFkZENoaWxkKGNoaWxkQ29tcG9uZW50KTtcblxuICAgICAgICBjb25zdCByZW5kZXJlZEVsZW1lbnRzID0gZWxlbWVudC5maW5kQWxsKCcudGFzay1saXN0LWl0ZW0nKS5maWx0ZXIoKHRhc2tJdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lc1RleHQgPSB0YXNrSXRlbS50ZXh0Q29udGVudD8uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBsaW5lLiBDYW4gYmUgbXVsdGlwbGUgbGluZXMgaWYgYW4gTEkgZWxlbWVudCBjb250YWlucyBhbiBVTC5cbiAgICAgICAgICAgIC8vIFdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBsZXZlbCBMSSBpbmRlcGVuZGVudGx5IGZyb20gaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgZmFsc2UgcG9zaXRpdmUsIHdoZW4gdGhlIExJIHdhc24ndCBhIHRhc2sgaXRzZWxmLCBidXQgY29udGFpbmVkIHRoZVxuICAgICAgICAgICAgLy8gZ2xvYmFsIGZpbHRlciBpbiBjaGlsZCBMSXMuXG4gICAgICAgICAgICBsZXQgZmlyc3RMaW5lVGV4dDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBsaW5lIGlzIHRoZSBmaXJzdCBsaW5lIHRoYXQgaXMgbm90IGVtcHR5LiBFbXB0eSBsaW5lcyBjYW4gZXhpc3Qgd2hlblxuICAgICAgICAgICAgLy8gdGhlIGNoZWNrbGlzdCBpbiBtYXJrZG93biBpbmNsdWRlcyBibGFuayBsaW5lcyAoc2VlICMzMTMpLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc1RleHQubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZXNUZXh0W2ldICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmVUZXh0ID0gbGluZXNUZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdExpbmVUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuaW5jbHVkZWRJbihmaXJzdExpbmVUZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gdGFza3MgbWVhbnMgbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhdGggPSBjb250ZXh0LnNvdXJjZVBhdGg7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBjb250ZXh0LmdldFNlY3Rpb25JbmZvKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW5ub3QgcHJvY2VzcyB0aGUgcmVuZGVyIHdpdGhvdXQgdGhlIHNlY3Rpb24gaW5mby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVMaW5lcyA9IHNlY3Rpb24udGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgbGV0IHNlY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGZpbGVUYXNrczogVGFza1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBzZWN0aW9uLmxpbmVTdGFydDsgbGluZU51bWJlciA8PSBzZWN0aW9uLmxpbmVFbmQ7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGZpbGVMaW5lc1tsaW5lTnVtYmVyXTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlbmQgdXAgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgdGhlIGZpbGUsXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHByb2Nlc3MgdGhpcyB0YXNrLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcmVjZWRpbmdIZWFkZXIgPSBudWxsOyAvLyBXZSBkb24ndCBuZWVkIHRoZSBwcmVjZWRpbmcgaGVhZGVyIGZvciBpbi1saW5lIHJlbmRlcmluZy5cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBUYXNrLmZyb21MaW5lKHtcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogbmV3IFRhc2tMb2NhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRhc2tzRmlsZShwYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5saW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoZSBmYWxsYmFjayBkYXRlIGZvciBpbi1saW5lIHJlbmRlcmluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpbGVUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFza0xpbmVSZW5kZXJlciA9IG5ldyBUYXNrTGluZVJlbmRlcmVyKHtcbiAgICAgICAgICAgIG9ic2lkaWFuQ29tcG9uZW50OiBjaGlsZENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFVsRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIHRhc2tMYXlvdXRPcHRpb25zOiBuZXcgVGFza0xheW91dE9wdGlvbnMoKSxcbiAgICAgICAgICAgIHF1ZXJ5TGF5b3V0T3B0aW9uczogbmV3IFF1ZXJ5TGF5b3V0T3B0aW9ucygpLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgc2VjdGlvbiBpbmRleCBpcyB0aGUgbnRoIHRhc2sgd2l0aGluIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbkluZGV4ID0gMDsgc2VjdGlvbkluZGV4IDwgcmVuZGVyZWRFbGVtZW50cy5sZW5ndGg7IHNlY3Rpb25JbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gZmlsZVRhc2tzW3NlY3Rpb25JbmRleF07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkRWxlbWVudCA9IHJlbmRlcmVkRWxlbWVudHNbc2VjdGlvbkluZGV4XTtcbiAgICAgICAgICAgIGlmICh0YXNrID09PSB1bmRlZmluZWQgfHwgcmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWluZyBtYXRjaCBvZiB0YXNrcyBpbiBmaWxlIGFuZCByZW5kZXIgcHJldmlldy5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG1pcy1tYXRjaCBpbiB0aGUgbnVtYmVycywgd2Ugc3RpbGwgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIHdoYXQgd2UgY2FuLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUxpbmU6IHN0cmluZyA9IHJlbmRlcmVkRWxlbWVudC5nZXRBdHRyKCdkYXRhLWxpbmUnKSA/PyAnMCc7XG4gICAgICAgICAgICBjb25zdCB0YXNrSW5kZXg6IG51bWJlciA9IE51bWJlci5wYXJzZUludChkYXRhTGluZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgdGFza0VsZW1lbnQgPSBhd2FpdCB0YXNrTGluZVJlbmRlcmVyLnJlbmRlclRhc2tMaW5lKHRhc2ssIHRhc2tJbmRleCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGEgc3ViLWxpc3Qgb3Igc3ViLWRpdiAoZS5nLiB0aGVcbiAgICAgICAgICAgIC8vIGZvbGRpbmcgYXJyb3cpLCB3ZSBuZWVkIHRvIGtlZXAgaXQuXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkcmVuID0gcmVuZGVyZWRFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrRWxlbWVudC5wcmVwZW5kKHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVuZGVyZWRDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tFbGVtZW50LmFwcGVuZChyZW5kZXJlZENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLXNldCB0aGUgb3JpZ2luYWwgZm9vdG5vdGVzLlxuICAgICAgICAgICAgLy8gVGhlIG5ld2x5IHJlbmRlcmVkIEhUTUwgd29uJ3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleGVzIGFuZCBsaW5rc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvb3Rub3RlcyA9IHJlbmRlcmVkRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mb290bm90ZS1pZF0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Zvb3Rub3RlcyA9IHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvb3Rub3RlLWlkXScpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRm9vdG5vdGVzLmxlbmd0aCA9PT0gbmV3Rm9vdG5vdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxGb290bm90ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Rm9vdG5vdGVzW2ldLnJlcGxhY2VXaXRoKG9yaWdpbmFsRm9vdG5vdGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5yZXBsYWNlV2l0aCh0YXNrRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgeyBUQVNLX0ZPUk1BVFMsIGdldFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB0eXBlIHsgUXVlcnlMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi4vTGF5b3V0L1F1ZXJ5TGF5b3V0T3B0aW9ucyc7XG5pbXBvcnQgeyBUYXNrTGF5b3V0Q29tcG9uZW50LCB0eXBlIFRhc2tMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi4vTGF5b3V0L1Rhc2tMYXlvdXRPcHRpb25zJztcbmltcG9ydCB7IHJlcGxhY2VUYXNrV2l0aFRhc2tzIH0gZnJvbSAnLi4vT2JzaWRpYW4vRmlsZSc7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzay9UYXNrUmVndWxhckV4cHJlc3Npb25zJztcbmltcG9ydCB7IFN0YXR1c01lbnUgfSBmcm9tICcuLi91aS9NZW51cy9TdGF0dXNNZW51JztcbmltcG9ydCB7IGlzRGF0ZVRpbWUgfSBmcm9tICcuLi9saWIvRGF0ZVRvb2xzJztcbmltcG9ydCB7IFRhc2tGaWVsZFJlbmRlcmVyIH0gZnJvbSAnLi9UYXNrRmllbGRSZW5kZXJlcic7XG5cbi8qKlxuICogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gcmVuZGVyIGEgTWFya2Rvd24gdGFzayBsaW5lIGludG8gYW4gZXhpc3RpbmcgSFRNTCBlbGVtZW50LlxuICovXG5leHBvcnQgdHlwZSBUZXh0UmVuZGVyZXIgPSAoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIGVsZW1lbnQ6IEhUTUxTcGFuRWxlbWVudCxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb2JzaWRpYW5Db21wb25lbnQ6IENvbXBvbmVudCB8IG51bGwsIC8vIG51bGwgaXMgYWxsb3dlZCBoZXJlIG9ubHkgZm9yIHRlc3RzXG4pID0+IFByb21pc2U8dm9pZD47XG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZWxlbWVudCwgYW5kIGFwcGVuZCBpdCB0byBhIHBhcmVudCBlbGVtZW50LlxuICpcbiAqIFVubGlrZSB0aGUgZXF1aXZhbGVudCBPYnNpZGlhbiBjb252ZW5pZW5jZSBmdW5jdGlvbiBsaS5jcmVhdGVFbCgpLFxuICogdGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gb3VyIGF1dG9tYXRlZCB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0gdGFnTmFtZSAtIHRoZSB0eXBlIG9mIGVsZW1lbnQgdG8gYmUgY3JlYXRlZCwgZm9yIGV4YW1wbGUgJ3VsJywgJ2RpdicsICdzcGFuJywgJ2xpJy5cbiAqIEBwYXJhbSBwYXJlbnRFbGVtZW50IC0gdGhlIHBhcmVudCBlbGVtZW50LCB0byB3aGljaCB0aGUgY3JlYXRlZCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSBjYWxsOjwvY2FwdGlvbj5cbiAqIGNvbnN0IGxpID0gY3JlYXRlQW5kQXBwZW5kRWxlbWVudCgnbGknLCBwYXJlbnRFbGVtZW50KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQ8SyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcD4oXG4gICAgdGFnTmFtZTogSyxcbiAgICBwYXJlbnRFbGVtZW50OiBIVE1MRWxlbWVudCxcbik6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSB7XG4gICAgLy8gTWFpbnRlbmFuY2Ugbm90ZTpcbiAgICAvLyAgV2UgZG9uJ3QgdXNlIHRoZSBPYnNpZGlhbiBjb252ZW5pZW5jZSBmdW5jdGlvbiBsaS5jcmVhdGVFbCgpIGhlcmUsIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBpdCBhdmFpbGFibGVcbiAgICAvLyAgd2hlbiBydW5uaW5nIHRlc3RzLCBhbmQgd2Ugd2FudCB0aGUgdGVzdHMgdG8gYmUgYWJsZSB0byBjcmVhdGUgdGhlIGZ1bGwgZGl2IGFuZCBzcGFuIHN0cnVjdHVyZSxcbiAgICAvLyAgc28gaGFkIHRvIGNvbnZlcnQgYWxsIG9mIHRoZXNlIHRvIHRoZSBlcXVpdmFsZW50IGJ1dCBtb3JlIGVsYWJvcmF0ZSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCkgYW5kXG4gICAgLy8gIGFwcGVuZENoaWxkKCkgY2FsbHMuXG5cbiAgICBjb25zdCBlbDogSFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydCBjbGFzcyBUYXNrTGluZVJlbmRlcmVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRleHRSZW5kZXJlcjogVGV4dFJlbmRlcmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb2JzaWRpYW5Db21wb25lbnQ6IENvbXBvbmVudCB8IG51bGw7XG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJlbnRVbEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdGFza0xheW91dE9wdGlvbnM6IFRhc2tMYXlvdXRPcHRpb25zO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcXVlcnlMYXlvdXRPcHRpb25zOiBRdWVyeUxheW91dE9wdGlvbnM7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBvYnNpZGlhbk1hcmtkb3duUmVuZGVyZXIoXG4gICAgICAgIHRleHQ6IHN0cmluZyxcbiAgICAgICAgZWxlbWVudDogSFRNTFNwYW5FbGVtZW50LFxuICAgICAgICBwYXRoOiBzdHJpbmcsXG4gICAgICAgIG9ic2lkaWFuQ29tcG9uZW50OiBDb21wb25lbnQgfCBudWxsLFxuICAgICkge1xuICAgICAgICBpZiAoIW9ic2lkaWFuQ29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoJ011c3QgY2FsbCB0aGUgT2JzaWRpYW4gcmVuZGVyZXIgd2l0aCBhbiBPYnNpZGlhbiBDb21wb25lbnQgb2JqZWN0Jyk7XG4gICAgICAgIGF3YWl0IE1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24odGV4dCwgZWxlbWVudCwgcGF0aCwgb2JzaWRpYW5Db21wb25lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIHJlbmRlcmVyIGZvciB0YXNrcyB3aXRoIHZhcmlvdXMgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0UmVuZGVyZXIgVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHRvIGJlIHVzZWQuIFNraXAgdGhpcyBwYXJhbWV0ZXIgZm9yIE9ic2lkaWFuIHJlbmRlcmluZy5cbiAgICAgKiBGb3IgdGVzdCBwdXJwb3NlcyBtb2NrIHJlbmRlcmVycyBzaGFsbCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9ic2lkaWFuQ29tcG9uZW50IE9uZSBvZiB0aGUgcGFyYW1ldGVycyBuZWVkZWQgYnkgYE1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24oKWAgT2JzaWRpYW4gQVBJLFxuICAgICAqIHRoYXQgaXMgY2FsbGVkIGJ5IHRoZSBPYnNpZGlhbiByZW5kZXJlci4gU2V0IHRoaXMgdG8gbnVsbCBpbiB0ZXN0IGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50VWxFbGVtZW50IEhUTUwgZWxlbWVudCB3aGVyZSB0aGUgdGFzayBzaGFsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXNrTGF5b3V0T3B0aW9ucyBTZWUge0BsaW5rIFRhc2tMYXlvdXRPcHRpb25zfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeUxheW91dE9wdGlvbnMgU2VlIHtAbGluayBRdWVyeUxheW91dE9wdGlvbnN9LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGV4dFJlbmRlcmVyID0gVGFza0xpbmVSZW5kZXJlci5vYnNpZGlhbk1hcmtkb3duUmVuZGVyZXIsXG4gICAgICAgIG9ic2lkaWFuQ29tcG9uZW50LFxuICAgICAgICBwYXJlbnRVbEVsZW1lbnQsXG4gICAgICAgIHRhc2tMYXlvdXRPcHRpb25zLFxuICAgICAgICBxdWVyeUxheW91dE9wdGlvbnMsXG4gICAgfToge1xuICAgICAgICB0ZXh0UmVuZGVyZXI/OiBUZXh0UmVuZGVyZXI7XG4gICAgICAgIG9ic2lkaWFuQ29tcG9uZW50OiBDb21wb25lbnQgfCBudWxsO1xuICAgICAgICBwYXJlbnRVbEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgICAgICB0YXNrTGF5b3V0T3B0aW9uczogVGFza0xheW91dE9wdGlvbnM7XG4gICAgICAgIHF1ZXJ5TGF5b3V0T3B0aW9uczogUXVlcnlMYXlvdXRPcHRpb25zO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSB0ZXh0UmVuZGVyZXI7XG4gICAgICAgIHRoaXMub2JzaWRpYW5Db21wb25lbnQgPSBvYnNpZGlhbkNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRVbEVsZW1lbnQgPSBwYXJlbnRVbEVsZW1lbnQ7XG4gICAgICAgIHRoaXMudGFza0xheW91dE9wdGlvbnMgPSB0YXNrTGF5b3V0T3B0aW9ucztcbiAgICAgICAgdGhpcy5xdWVyeUxheW91dE9wdGlvbnMgPSBxdWVyeUxheW91dE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdpdmVuIFRhc2sgb2JqZWN0IGludG8gYW4gSFRNTCBMaXN0IEl0ZW0gKExJKSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIGVsZW1lbnQgaW5jbHVkZXMgdGhlIHRhc2sgYW5kIGl0cyB2YXJpb3VzIGNvbXBvbmVudHMgKGRlc2NyaXB0aW9uLCBwcmlvcml0eSwgYmxvY2sgbGluayBldGMuKSwgdGhlXG4gICAgICogY2hlY2tib3ggb24gdGhlIGxlZnQgd2l0aCBpdHMgZXZlbnQgaGFuZGxpbmcgb2YgY29tcGxldGluZyB0aGUgdGFzaywgYW5kIHRoZSBidXR0b24gZm9yIGVkaXRpbmcgdGhlIHRhc2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBIVE1MIHJlbmRlcmVkIExpc3QgSXRlbSBlbGVtZW50IChMSSkgZm9yIGEgdGFzay5cbiAgICAgKiBAbm90ZSBPdXRwdXQgaXMgYmFzZWQgb24gdGhlIHtAbGluayBEZWZhdWx0VGFza1NlcmlhbGl6ZXJ9J3MgZm9ybWF0LCB3aXRoIGRlZmF1bHQgKGVtb2ppKSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHRhc2sgVGhlIHRhc2sgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHRhc2tJbmRleCBUYXNrJ3MgaW5kZXggaW4gdGhlIGxpc3QuIFRoaXMgYWZmZWN0cyBgZGF0YS1saW5lYCBkYXRhIGF0dHJpYnV0ZXMgb2YgdGhlIGxpc3QgaXRlbS5cbiAgICAgKiBAcGFyYW0gaXNGaWxlbmFtZVVuaXF1ZSBXaGV0aGVyIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgaXMgdW5pcXVlIGluIHRoZSB2YXVsdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBpdCBpcyB1bmRlZmluZWQsIHRoZSBvdXRjb21lIHdpbGwgYmUgdGhlIHNhbWUgYXMgd2l0aCBhIHVuaXF1ZSBmaWxlIG5hbWU6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpbGUgbmFtZSBvbmx5LiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgZnVsbCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHJlbmRlclRhc2tMaW5lKHRhc2s6IFRhc2ssIHRhc2tJbmRleDogbnVtYmVyLCBpc0ZpbGVuYW1lVW5pcXVlPzogYm9vbGVhbik6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgICAgICBjb25zdCBsaSA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ2xpJywgdGhpcy5wYXJlbnRVbEVsZW1lbnQpO1xuXG4gICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ3Rhc2stbGlzdC1pdGVtJywgJ3BsdWdpbi10YXNrcy1saXN0LWl0ZW0nKTtcblxuICAgICAgICBjb25zdCB0ZXh0U3BhbiA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ3NwYW4nLCBsaSk7XG4gICAgICAgIHRleHRTcGFuLmNsYXNzTGlzdC5hZGQoJ3Rhc2tzLWxpc3QtdGV4dCcpO1xuICAgICAgICBhd2FpdCB0aGlzLnRhc2tUb0h0bWwodGFzaywgdGV4dFNwYW4sIGxpKTtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIGFyZWEgaXMgbWVudGlvbmVkIGluIGBDT05UUklCVVRJTkcubWRgIHVuZGVyIFwiSG93IGRvZXMgVGFza3MgaGFuZGxlIHN0YXR1cyBjaGFuZ2VzXCIuIFdoZW5cbiAgICAgICAgLy8gbW92aW5nIHRoZSBjb2RlLCByZW1lbWJlciB0byB1cGRhdGUgdGhhdCByZWZlcmVuY2UgdG9vLlxuICAgICAgICBjb25zdCBjaGVja2JveCA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ2lucHV0JywgbGkpO1xuICAgICAgICBjaGVja2JveC5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbS1jaGVja2JveCcpO1xuICAgICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgaWYgKHRhc2suc3RhdHVzLnN5bWJvbCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2lzLWNoZWNrZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXRoLCB0aGUgdGFzayBpcyBsaWtlbHkgdG8gYmUgaW4gYSBjYXJkIG9uIGEgY2FudmFzIGZpbGUsXG4gICAgICAgIC8vIGFuZCB3ZSBjYW5ub3Qgc2F2ZSBhbnkgZWRpdHMsIHNvIHRoZXJlIGlzIG5vIHBvaW50IGxpc3RlbmluZyBmb3IgYW55IGV2ZW50cyBvbiB0aGUgdGFzay5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbi10YXNrcy1ncm91cC9vYnNpZGlhbi10YXNrcy9pc3N1ZXMvMjEzMFxuICAgICAgICBjb25zdCBhZGRFdmVudExpc3RlbmVycyA9IHRhc2sudGFza0xvY2F0aW9uLmhhc0tub3duUGF0aDtcbiAgICAgICAgaWYgKGFkZEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgcmVxdWlyZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBzbyB0aGF0IG9ic2lkaWFuIHdvbid0IHdyaXRlIHRoZSBmaWxlIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tib3ggKHVuKWNoZWNrZWQuIE9ic2lkaWFuIHdvdWxkIHdyaXRlIGFmdGVyIHVzIGFuZCBvdmVyd3JpdGUgb3VyIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZS1yZW5kZXJlZCBhcyBlbmFibGVkIGFmdGVyIHVwZGF0ZSBpbiBmaWxlLlxuICAgICAgICAgICAgICAgIGNoZWNrYm94LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2dnbGVkVGFza3MgPSB0YXNrLnRvZ2dsZVdpdGhSZWN1cnJlbmNlSW5Vc2Vyc09yZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVRhc2tXaXRoVGFza3Moe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRhc2s6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIG5ld1Rhc2tzOiB0b2dnbGVkVGFza3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCAoZXY6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW51ID0gbmV3IFN0YXR1c01lbnUoU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKSwgdGFzayk7XG4gICAgICAgICAgICAgICAgbWVudS5zaG93QXRQb3NpdGlvbih7IHg6IGV2LmNsaWVudFgsIHk6IGV2LmNsaWVudFkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoZWNrYm94LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnUmlnaHQtY2xpY2sgZm9yIG9wdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpLnByZXBlbmQoY2hlY2tib3gpO1xuXG4gICAgICAgIC8vIFNldCB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGggc3RvY2sgb2JzaWRpYW4gbGlzdHM6XG4gICAgICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS10YXNrJywgdGFzay5zdGF0dXMuc3ltYm9sLnRyaW0oKSk7IC8vIFRyaW0gdG8gZW5zdXJlIGVtcHR5IGF0dHJpYnV0ZSBmb3Igc3BhY2UuIFNhbWUgd2F5IGFzIG9ic2lkaWFuLlxuICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZScsIHRhc2tJbmRleC50b1N0cmluZygpKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhLXRhc2stc3RhdHVzLW5hbWUnLCB0YXNrLnN0YXR1cy5uYW1lKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhLXRhc2stc3RhdHVzLXR5cGUnLCB0YXNrLnN0YXR1cy50eXBlKTtcbiAgICAgICAgY2hlY2tib3guc2V0QXR0cmlidXRlKCdkYXRhLWxpbmUnLCB0YXNrSW5kZXgudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVlcnlMYXlvdXRPcHRpb25zLnNob3J0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUb29sdGlwKHRhc2ssIHRleHRTcGFuLCBpc0ZpbGVuYW1lVW5pcXVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHRhc2tUb0h0bWwodGFzazogVGFzaywgcGFyZW50RWxlbWVudDogSFRNTEVsZW1lbnQsIGxpOiBIVE1MTElFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGZpZWxkUmVuZGVyZXIgPSBuZXcgVGFza0ZpZWxkUmVuZGVyZXIoKTtcbiAgICAgICAgY29uc3QgZW1vamlTZXJpYWxpemVyID0gVEFTS19GT1JNQVRTLnRhc2tzUGx1Z2luRW1vamkudGFza1NlcmlhbGl6ZXI7XG4gICAgICAgIC8vIFJlbmRlciBhbmQgYnVpbGQgY2xhc3NlcyBmb3IgYWxsIHRoZSB0YXNrJ3MgdmlzaWJsZSBjb21wb25lbnRzXG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIHRoaXMudGFza0xheW91dE9wdGlvbnMuc2hvd25Db21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRTdHJpbmcgPSBlbW9qaVNlcmlhbGl6ZXIuY29tcG9uZW50VG9TdHJpbmcoXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5TGF5b3V0T3B0aW9ucy5zaG9ydE1vZGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgc3BhbiB0aGF0IHdpbGwgaG9sZCB0aGUgcmVuZGVyZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ3NwYW4nLCBwYXJlbnRFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIEluc2lkZSB0aGF0IHRleHQgc3Bhbiwgd2UgYXJlIGNyZWF0aW5nIGFub3RoZXIgaW50ZXJuYWwgc3BhbiwgdGhhdCB3aWxsIGhvbGQgdGhlIHRleHQgaXRzZWxmLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IHNlZW0gcmVkdW5kYW50LCBhbmQgYnkgZGVmYXVsdCBpdCBpbmRlZWQgZG9lcyBub3RoaW5nLCBidXQgd2UgZG8gaXQgdG8gYWxsb3cgdGhlIENTU1xuICAgICAgICAgICAgICAgIC8vIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgY29udGFpbmVyIG9mIHRoZSB0ZXh0IGFuZCB0aGUgdGV4dCBpdHNlbGYsIHNvIGl0IHdpbGwgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyB0byBkbyB0aGluZ3MgbGlrZSBzdXJyb3VuZGluZyBvbmx5IHRoZSB0ZXh0IChyYXRoZXIgdGhhbiBpdHMgd2hvbGUgcGxhY2Vob2xkZXIpIHdpdGggYSBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbFNwYW4gPSBjcmVhdGVBbmRBcHBlbmRFbGVtZW50KCdzcGFuJywgc3Bhbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJDb21wb25lbnRUZXh0KGludGVybmFsU3BhbiwgY29tcG9uZW50U3RyaW5nLCBjb21wb25lbnQsIHRhc2spO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW50ZXJuYWxDbGFzc2VzKGNvbXBvbmVudCwgaW50ZXJuYWxTcGFuKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29tcG9uZW50J3MgQ1NTIGNsYXNzIGRlc2NyaWJpbmcgd2hhdCB0aGlzIGNvbXBvbmVudCBpcyAocHJpb3JpdHksIGR1ZSBkYXRlIGV0Yy4pXG4gICAgICAgICAgICAgICAgZmllbGRSZW5kZXJlci5hZGRDbGFzc05hbWUoc3BhbiwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29tcG9uZW50J3MgYXR0cmlidXRlICgncHJpb3JpdHktbWVkaXVtJywgJ2R1ZS1wYXN0LTFkJyBldGMuKVxuICAgICAgICAgICAgICAgIGZpZWxkUmVuZGVyZXIuYWRkRGF0YUF0dHJpYnV0ZShzcGFuLCB0YXNrLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGZpZWxkUmVuZGVyZXIuYWRkRGF0YUF0dHJpYnV0ZShsaSwgdGFzaywgY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBidWlsZCBjbGFzc2VzIGZvciB0aGUgaGlkZGVuIHRhc2sgY29tcG9uZW50cyB3aXRob3V0IHJlbmRlcmluZyB0aGVtXG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIHRoaXMudGFza0xheW91dE9wdGlvbnMuaGlkZGVuQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmllbGRSZW5kZXJlci5hZGREYXRhQXR0cmlidXRlKGxpLCB0YXNrLCBjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSB0YXNrIGhhcyBubyBwcmlvcml0eSBmaWVsZCBzZXQsIGl0cyBwcmlvcml0eSB3aWxsIG5vdCBiZSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBsb29wIGFib3ZlLCBhbmRcbiAgICAgICAgLy8gaXQgd2lsbCBub3QgYmUgc2V0IGEgcHJpb3JpdHkgZGF0YSBhdHRyaWJ1dGUuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlIHdlIHdhbnQgdGhlIHVwcGVyIHRhc2sgTEkgZWxlbWVudCB0byBtYXJrIHRoZSB0YXNrIGhhcyBhICdub3JtYWwnIHByaW9yaXR5LlxuICAgICAgICAvLyBTbyBpZiB0aGUgcHJpb3JpdHkgd2FzIG5vdCByZW5kZXJlZCwgZm9yY2UgaXQgdGhyb3VnaCB0aGUgcGlwZSBvZiBnZXR0aW5nIHRoZSBjb21wb25lbnQgZGF0YSBmb3IgdGhlXG4gICAgICAgIC8vIHByaW9yaXR5IGZpZWxkLlxuICAgICAgICBpZiAobGkuZGF0YXNldC50YXNrUHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmllbGRSZW5kZXJlci5hZGREYXRhQXR0cmlidXRlKGxpLCB0YXNrLCBUYXNrTGF5b3V0Q29tcG9uZW50LlByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVuZGVycyB0aGUgZ2l2ZW4gY29tcG9uZW50IGludG8gdGhlIGdpdmVuIEhUTUwgc3BhbiBlbGVtZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyQ29tcG9uZW50VGV4dChcbiAgICAgICAgc3BhbjogSFRNTFNwYW5FbGVtZW50LFxuICAgICAgICBjb21wb25lbnRTdHJpbmc6IHN0cmluZyxcbiAgICAgICAgY29tcG9uZW50OiBUYXNrTGF5b3V0Q29tcG9uZW50LFxuICAgICAgICB0YXNrOiBUYXNrLFxuICAgICkge1xuICAgICAgICBpZiAoY29tcG9uZW50ID09PSBUYXNrTGF5b3V0Q29tcG9uZW50LkRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdHJpbmcgPSBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5yZW1vdmVBc1dvcmRGcm9tRGVwZW5kaW5nT25TZXR0aW5ncyhjb21wb25lbnRTdHJpbmcpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlYnVnU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBpZiAoZGVidWdTZXR0aW5ncy5zaG93VGFza0hpZGRlbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgc29tZSBkZWJ1ZyBvdXRwdXQgdG8gZW5hYmxlIGhpZGRlbiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFzayB0byBiZSBpbnNwZWN0ZWQuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RyaW5nICs9IGA8YnI+XHVEODNEXHVEQzFCIDxiPiR7dGFzay5saW5lTnVtYmVyfTwvYj4gLiAke3Rhc2suc2VjdGlvblN0YXJ0fSAuICR7dGFzay5zZWN0aW9uSW5kZXh9IC4gJzxjb2RlPiR7dGFzay5vcmlnaW5hbE1hcmtkb3dufTwvY29kZT4nPGJyPic8Y29kZT4ke3Rhc2sucGF0aH08L2NvZGU+JyA+ICc8Y29kZT4ke3Rhc2sucHJlY2VkaW5nSGVhZGVyfTwvY29kZT4nPGJyPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRleHRSZW5kZXJlcihjb21wb25lbnRTdHJpbmcsIHNwYW4sIHRhc2sucGF0aCwgdGhpcy5vYnNpZGlhbkNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0YXNrIGlzIGEgYmxvY2sgcXVvdGUsIHRoZSBibG9jayBxdW90ZSB3cmFwcyB0aGUgcC10YWcgdGhhdCBjb250YWlucyB0aGUgY29udGVudC5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB1bndyYXAgdGhlIHAtdGFnICppbnNpZGUqIHRoZSBzdXJyb3VuZGluZyBibG9jayBxdW90ZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdW53cmFwIHRoZSBwLXRhZyBhcyBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZSBzcGFuLlxuICAgICAgICAgICAgY29uc3QgYmxvY2tRdW90ZSA9IHNwYW4ucXVlcnlTZWxlY3RvcignYmxvY2txdW90ZScpO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0UGFyZW50T2ZQVGFnID0gYmxvY2tRdW90ZSA/PyBzcGFuO1xuXG4gICAgICAgICAgICAvLyBVbndyYXAgdGhlIHAtdGFnIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIE1hcmtkb3duUmVuZGVyZXI6XG4gICAgICAgICAgICBjb25zdCBwRWxlbWVudCA9IGRpcmVjdFBhcmVudE9mUFRhZy5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICBpZiAocEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocEVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RQYXJlbnRPZlBUYWcuaW5zZXJ0QmVmb3JlKHBFbGVtZW50LmZpcnN0Q2hpbGQsIHBFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbiBlbXB0eSB0cmFpbGluZyBwLXRhZyB0aGF0IHRoZSBNYXJrZG93blJlbmRlcmVyIGFwcGVuZHMgd2hlbiB0aGVyZSBpcyBhIGJsb2NrIGxpbms6XG4gICAgICAgICAgICBzcGFuLnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKS5mb3JFYWNoKChwRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcEVsZW1lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZvb3Rub3RlIHRoYXQgdGhlIE1hcmtkb3duUmVuZGVyZXIgYXBwZW5kcyB3aGVuIHRoZXJlIGlzIGEgZm9vdG5vdGUgaW4gdGhlIHRhc2s6XG4gICAgICAgICAgICBzcGFuLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb290bm90ZXMnKS5mb3JFYWNoKChmb290bm90ZUVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBmb290bm90ZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gY29tcG9uZW50U3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQWRkcyBpbnRlcm5hbCBjbGFzc2VzIGZvciB2YXJpb3VzIGNvbXBvbmVudHMgKHJpZ2h0IG5vdyBqdXN0IHRhZ3MgYWN0dWFsbHkpLCBtZWFuaW5nIHRoYXQgd2UgbW9kaWZ5IHRoZSBleGlzdGluZ1xuICAgICAqIHJlbmRlcmVkIGVsZW1lbnQgdG8gYWRkIGNsYXNzZXMgaW5zaWRlIGl0LlxuICAgICAqIEluIHRoZSBjYXNlIG9mIHRhZ3MsIE9ic2lkaWFuIHJlbmRlcnMgYSBNYXJrZG93biBkZXNjcmlwdGlvbiB3aXRoIDxhIGNsYXNzPVwidGFnXCI+IGVsZW1lbnRzIGZvciB0YWdzLiBXZSB3YW50IHRvXG4gICAgICogZW5hYmxlIHVzZXJzIHRvIHN0eWxlIHRoZXNlLCBzbyB3ZSBtb2RpZnkgdGhlIHJlbmRlcmVkIE1hcmtkb3duIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWMgdGFnIGNsYXNzZXMgZm9yIHRoZXNlIDxhPlxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgYWRkSW50ZXJuYWxDbGFzc2VzKGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCwgaW50ZXJuYWxTcGFuOiBIVE1MU3BhbkVsZW1lbnQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogU2FuaXRpemUgdGFnIG5hbWVzLCBzbyB0aGV5IHdpbGwgYmUgdmFsaWQgYXR0cmlidXRlIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIEhUTUwgc3BlYzpcbiAgICAgICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2F0dHJpYnV0ZS12YWx1ZS0oZG91YmxlLXF1b3RlZCktc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRhZ1RvQXR0cmlidXRlVmFsdWUodGFnOiBzdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgICAgICBjb25zdCBpbGxlZ2FsQ2hhcnMgPSAvW1wiJlxceDAwXFxyXFxuXS9nO1xuICAgICAgICAgICAgbGV0IHNhbml0aXplZFRhZyA9IHRhZy5yZXBsYWNlKGlsbGVnYWxDaGFycywgJy0nKTtcbiAgICAgICAgICAgIC8vIEFuZCBpZiBhZnRlciBzYW5pdGl6YXRpb24gdGhlIG5hbWUgc3RhcnRzIHdpdGggZGFzaGVzIG9yIHVuZGVyc2NvcmVzLCByZW1vdmUgdGhlbS5cbiAgICAgICAgICAgIHNhbml0aXplZFRhZyA9IHNhbml0aXplZFRhZy5yZXBsYWNlKC9eWy1fXSsvLCAnJyk7XG4gICAgICAgICAgICBpZiAoc2FuaXRpemVkVGFnLmxlbmd0aCA+IDApIHJldHVybiBzYW5pdGl6ZWRUYWc7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gVGFza0xheW91dENvbXBvbmVudC5EZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IGludGVybmFsU3Bhbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0YWcnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0YWdzW2ldLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRhZ1RvQXR0cmlidXRlVmFsdWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YWdzW2ldIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSBlbGVtZW50LmRhdGFzZXQudGFnTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRvb2x0aXAodGFzazogVGFzaywgZWxlbWVudDogSFRNTFNwYW5FbGVtZW50LCBpc0ZpbGVuYW1lVW5pcXVlOiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5FV19UQVNLX0ZJRUxEX0VESVRfUkVRVUlSRURcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVjdXJyZW5jZVN5bWJvbCxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZVN5bWJvbCxcbiAgICAgICAgICAgIGNyZWF0ZWREYXRlU3ltYm9sLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgIGR1ZURhdGVTeW1ib2wsXG4gICAgICAgICAgICByZW1pbmRlckRhdGVTeW1ib2wsXG4gICAgICAgICAgICBjYW5jZWxsZWREYXRlU3ltYm9sLFxuICAgICAgICAgICAgZG9uZURhdGVTeW1ib2wsXG4gICAgICAgIH0gPSBUQVNLX0ZPUk1BVFMudGFza3NQbHVnaW5FbW9qaS50YXNrU2VyaWFsaXplci5zeW1ib2xzO1xuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZERhdGVUb1Rvb2x0aXAodG9vbHRpcDogSFRNTERpdkVsZW1lbnQsIGRhdGU6IE1vbWVudCB8IG51bGwsIHNpZ25pZmllcjogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlZERhdGVEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9Ub29sdGlwRGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWVyOiBzaWduaWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdG9Ub29sdGlwRGF0ZSh7IHNpZ25pZmllciwgZGF0ZSB9OiB7IHNpZ25pZmllcjogc3RyaW5nOyBkYXRlOiBNb21lbnQgfSk6IHN0cmluZyB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gaXNEYXRlVGltZShkYXRlKVxuICAgICAgICAgICAgICAgICAgICA/IFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZVRpbWVGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgOiBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NpZ25pZmllcn0gJHtkYXRlLmZvcm1hdChmb3JtYXQpfSAoJHtkYXRlLmZyb20od2luZG93Lm1vbWVudCgpLnN0YXJ0T2YoJ2RheScpKX0pYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbHRpcCA9IGVsZW1lbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICB0b29sdGlwLmFkZENsYXNzZXMoWyd0b29sdGlwJywgJ3BvcC11cCddKTtcblxuICAgICAgICAgICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgICAgICAgICAgaWYgKHRhc2sucmVjdXJyZW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3VycmVuY2VEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VEaXYuc2V0VGV4dChgJHtyZWN1cnJlbmNlU3ltYm9sfSAke3Rhc2sucmVjdXJyZW5jZS50b1RleHQoKX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkRGF0ZVRvVG9vbHRpcCh0b29sdGlwLCB0YXNrLmNyZWF0ZWREYXRlLCBjcmVhdGVkRGF0ZVN5bWJvbCk7XG4gICAgICAgICAgICBhZGREYXRlVG9Ub29sdGlwKHRvb2x0aXAsIHRhc2suc3RhcnREYXRlLCBzdGFydERhdGVTeW1ib2wpO1xuICAgICAgICAgICAgYWRkRGF0ZVRvVG9vbHRpcCh0b29sdGlwLCB0YXNrLnNjaGVkdWxlZERhdGUsIHNjaGVkdWxlZERhdGVTeW1ib2wpO1xuICAgICAgICAgICAgYWRkRGF0ZVRvVG9vbHRpcCh0b29sdGlwLCB0YXNrLmR1ZURhdGUsIGR1ZURhdGVTeW1ib2wpO1xuICAgICAgICAgICAgYWRkRGF0ZVRvVG9vbHRpcCh0b29sdGlwLCB0YXNrLnJlbWluZGVyRGF0ZSwgcmVtaW5kZXJEYXRlU3ltYm9sKTtcbiAgICAgICAgICAgIGFkZERhdGVUb1Rvb2x0aXAodG9vbHRpcCwgdGFzay5jYW5jZWxsZWREYXRlLCBjYW5jZWxsZWREYXRlU3ltYm9sKTtcbiAgICAgICAgICAgIGFkZERhdGVUb1Rvb2x0aXAodG9vbHRpcCwgdGFzay5kb25lRGF0ZSwgZG9uZURhdGVTeW1ib2wpO1xuXG4gICAgICAgICAgICBjb25zdCBsaW5rVGV4dCA9IHRhc2suZ2V0TGlua1RleHQoeyBpc0ZpbGVuYW1lVW5pcXVlIH0pO1xuICAgICAgICAgICAgaWYgKGxpbmtUZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja2xpbmtEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIGJhY2tsaW5rRGl2LnNldFRleHQoYFx1RDgzRFx1REQxNyAke2xpbmtUZXh0fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdHVzU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9Db25maWcvU3RhdHVzU2V0dGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBUYXNrRWRpdGluZ0luc3RydWN0aW9uIH0gZnJvbSAnLi9UYXNrRWRpdGluZ0luc3RydWN0aW9uJztcblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiBjbGFzcywgZm9yIGVkaXRpbmcgYSB7QGxpbmsgVGFza30gb2JqZWN0J3Mge0BsaW5rIFN0YXR1c30uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXRTdGF0dXMgaW1wbGVtZW50cyBUYXNrRWRpdGluZ0luc3RydWN0aW9uIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmV3U3RhdHVzOiBTdGF0dXM7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXM6IFN0YXR1cykge1xuICAgICAgICB0aGlzLm5ld1N0YXR1cyA9IHN0YXR1cztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXBwbHkodGFzazogVGFzayk6IFRhc2tbXSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2tlZEZvclRhc2sodGFzaykpIHtcbiAgICAgICAgICAgIC8vIFVuY2hhbmdlZDogcmV0dXJuIHRoZSBpbnB1dCB0YXNrOlxuICAgICAgICAgICAgcmV0dXJuIFt0YXNrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLmhhbmRsZU5ld1N0YXR1c1dpdGhSZWN1cnJlbmNlSW5Vc2Vyc09yZGVyKHRoaXMubmV3U3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpbnN0cnVjdGlvbkRpc3BsYXlOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNvbW1vblRpdGxlID0gJ0NoYW5nZSBzdGF0dXMgdG86JztcbiAgICAgICAgcmV0dXJuIGAke2NvbW1vblRpdGxlfSBbJHt0aGlzLm5ld1N0YXR1cy5zeW1ib2x9XSAke3RoaXMubmV3U3RhdHVzLm5hbWV9YDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNDaGVja2VkRm9yVGFzayh0YXNrOiBUYXNrKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld1N0YXR1cy5zeW1ib2wgPT09IHRhc2suc3RhdHVzLnN5bWJvbDtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGFsbCB0aGUgYXZhaWxhYmxlIGluc3RydWN0aW9ucyBmb3IgZWRpdGluZyB0YXNrIHN0YXR1c2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsU3RhdHVzSW5zdHJ1Y3Rpb25zKHN0YXR1c1JlZ2lzdHJ5OiBTdGF0dXNSZWdpc3RyeSkge1xuICAgIGNvbnN0IGluc3RydWN0aW9uczogU2V0U3RhdHVzW10gPSBbXTtcbiAgICBjb25zdCBjb3JlU3RhdHVzZXMgPSBuZXcgU3RhdHVzU2V0dGluZ3MoKS5jb3JlU3RhdHVzZXMubWFwKChzZXR0aW5nKSA9PiBzZXR0aW5nLnN5bWJvbCk7XG4gICAgLy8gUHV0IHRoZSBjb3JlIHN0YXR1c2VzIGF0IHRoZSB0b3Agb2YgdGhlIG1lbnU6XG4gICAgZm9yIChjb25zdCBtYXRjaENvcmVUYXNrIG9mIFt0cnVlLCBmYWxzZV0pIHtcbiAgICAgICAgZm9yIChjb25zdCBzdGF0dXMgb2Ygc3RhdHVzUmVnaXN0cnkucmVnaXN0ZXJlZFN0YXR1c2VzKSB7XG4gICAgICAgICAgICBpZiAoY29yZVN0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cy5zeW1ib2wpID09PSBtYXRjaENvcmVUYXNrKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFNldFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xufVxuIiwgImltcG9ydCB7IE1lbnUsIHR5cGUgTWVudUl0ZW0gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgcmVwbGFjZVRhc2tXaXRoVGFza3MgfSBmcm9tICcuLi8uLi9PYnNpZGlhbi9GaWxlJztcbmltcG9ydCB0eXBlIHsgVGFza0VkaXRpbmdJbnN0cnVjdGlvbiB9IGZyb20gJy4uL0VkaXRJbnN0cnVjdGlvbnMvVGFza0VkaXRpbmdJbnN0cnVjdGlvbic7XG5cbi8qKlxuICogQSBmdW5jdGlvbiBmb3IgcmVwbGFjaW5nIG9uZSB0YXNrIHdpdGggemVybyBvciBtb3JlIG5ldyB0YXNrcy5cbiAqIEBzZWUge0BsaW5rIGRlZmF1bHRUYXNrU2F2ZXJ9XG4gKi9cbmV4cG9ydCB0eXBlIFRhc2tTYXZlciA9IChvcmlnaW5hbFRhc2s6IFRhc2ssIG5ld1Rhc2tzOiBUYXNrIHwgVGFza1tdKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4vKipcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgVGFza1NhdmVyfSB0aGF0IGNhbGxzIHtAbGluayByZXBsYWNlVGFza1dpdGhUYXNrc31cbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBuZXdUYXNrc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVmYXVsdFRhc2tTYXZlcihvcmlnaW5hbFRhc2s6IFRhc2ssIG5ld1Rhc2tzOiBUYXNrIHwgVGFza1tdKSB7XG4gICAgYXdhaXQgcmVwbGFjZVRhc2tXaXRoVGFza3Moe1xuICAgICAgICBvcmlnaW5hbFRhc2ssXG4gICAgICAgIG5ld1Rhc2tzLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIE1lbnVzIHRoYXQgb2ZmZXIgZWRpdGluZyBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIG9mIGEgVGFzayBvYmplY3QuXG4gKlxuICogQSB7QGxpbmsgVGFza1NhdmVyfSBmdW5jdGlvbiBtdXN0IGJlIHN1cHBsaWVkLCBpbiBvcmRlciBmb3IgYW55IGVkaXRzIHRvIGJlIHNhdmVkLlxuICogRGVyaXZlZCBjbGFzc2VzIHNob3VsZCBkZWZhdWx0IHRvIHVzaW5nIHtAbGluayBkZWZhdWx0VGFza1NhdmVyfSwgYnV0IGFsbG93XG4gKiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgdG8gYmUgdXNlZCBpbiB0ZXN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tFZGl0aW5nTWVudSBleHRlbmRzIE1lbnUge1xuICAgIHByb3RlY3RlZCByZWFkb25seSB0YXNrU2F2ZXI6IFRhc2tTYXZlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLCB3aGljaCBzZXRzIHVwIHRoZSBtZW51IGl0ZW1zLlxuICAgICAqIEBwYXJhbSB0YXNrU2F2ZXIgLSBhIHtAbGluayBUYXNrU2F2ZXJ9IGZ1bmN0aW9uLCBmb3Igc2F2aW5nIGFueSBlZGl0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrU2F2ZXI6IFRhc2tTYXZlcikge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudGFza1NhdmVyID0gdGFza1NhdmVyO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRJdGVtc0Zvckluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnM6IFRhc2tFZGl0aW5nSW5zdHJ1Y3Rpb25bXSwgdGFzazogVGFzaykge1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtRm9ySW5zdHJ1Y3Rpb24odGFzaywgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRJdGVtRm9ySW5zdHJ1Y3Rpb24odGFzazogVGFzaywgaW5zdHJ1Y3Rpb246IFRhc2tFZGl0aW5nSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGhpcy5hZGRJdGVtKChpdGVtKSA9PiB0aGlzLmdldE1lbnVJdGVtQ2FsbGJhY2sodGFzaywgaXRlbSwgaW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1lbnVJdGVtQ2FsbGJhY2sodGFzazogVGFzaywgaXRlbTogTWVudUl0ZW0sIGluc3RydWN0aW9uOiBUYXNrRWRpdGluZ0luc3RydWN0aW9uKSB7XG4gICAgICAgIGl0ZW0uc2V0VGl0bGUoaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb25EaXNwbGF5TmFtZSgpKVxuICAgICAgICAgICAgLnNldENoZWNrZWQoaW5zdHJ1Y3Rpb24uaXNDaGVja2VkRm9yVGFzayh0YXNrKSlcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUYXNrID0gaW5zdHJ1Y3Rpb24uYXBwbHkodGFzayk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRWRpdHMgPSBuZXdUYXNrLmxlbmd0aCAhPT0gMSB8fCAhT2JqZWN0LmlzKG5ld1Rhc2tbMF0sIHRhc2spO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFZGl0cykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRhc2tTYXZlcih0YXNrLCBuZXdUYXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uLy4uL1N0YXR1c2VzL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBhbGxTdGF0dXNJbnN0cnVjdGlvbnMgfSBmcm9tICcuLi9FZGl0SW5zdHJ1Y3Rpb25zL1N0YXR1c0luc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBUYXNrRWRpdGluZ01lbnUsIHR5cGUgVGFza1NhdmVyLCBkZWZhdWx0VGFza1NhdmVyIH0gZnJvbSAnLi9UYXNrRWRpdGluZ01lbnUnO1xuXG4vKipcbiAqIEEgTWVudSBvZiBvcHRpb25zIGZvciBlZGl0aW5nIHRoZSBzdGF0dXMgb2YgYSBUYXNrIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gKiAgICAgICAgIGNvbnN0IG1lbnUgPSBuZXcgU3RhdHVzTWVudShTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLCB0YXNrKTtcbiAqICAgICAgICAgbWVudS5zaG93QXRQb3NpdGlvbih7IHg6IGV2LmNsaWVudFgsIHk6IGV2LmNsaWVudFkgfSk7XG4gKiAgICAgfSk7XG4gKiAgICAgY2hlY2tib3guc2V0QXR0cmlidXRlKCd0aXRsZScsICdSaWdodC1jbGljayBmb3Igb3B0aW9ucycpO1xuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzTWVudSBleHRlbmRzIFRhc2tFZGl0aW5nTWVudSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IsIHdoaWNoIHNldHMgdXAgdGhlIG1lbnUgaXRlbXMuXG4gICAgICogQHBhcmFtIHN0YXR1c1JlZ2lzdHJ5IC0gdGhlIHN0YXR1c2VzIHRvIGJlIHNob3duIGluIHRoZSBtZW51LlxuICAgICAqIEBwYXJhbSB0YXNrIC0gdGhlIFRhc2sgdG8gYmUgZWRpdGVkLlxuICAgICAqIEBwYXJhbSB0YXNrU2F2ZXIgLSBhbiBvcHRpb25hbCB7QGxpbmsgVGFza1NhdmVyfSBmdW5jdGlvbi4gRm9yIGRldGFpbHMsIHNlZSB7QGxpbmsgVGFza0VkaXRpbmdNZW51fS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNSZWdpc3RyeTogU3RhdHVzUmVnaXN0cnksIHRhc2s6IFRhc2ssIHRhc2tTYXZlcjogVGFza1NhdmVyID0gZGVmYXVsdFRhc2tTYXZlcikge1xuICAgICAgICBzdXBlcih0YXNrU2F2ZXIpO1xuXG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGFsbFN0YXR1c0luc3RydWN0aW9ucyhzdGF0dXNSZWdpc3RyeSk7XG4gICAgICAgIHRoaXMuYWRkSXRlbXNGb3JJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zLCB0YXNrKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuXG5pbXBvcnQgdHlwZSB7IFRhc2tMYXlvdXRDb21wb25lbnQgfSBmcm9tICcuLi9MYXlvdXQvVGFza0xheW91dE9wdGlvbnMnO1xuaW1wb3J0IHsgUHJpb3JpdHlUb29scyB9IGZyb20gJy4uL2xpYi9Qcmlvcml0eVRvb2xzJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5cbmV4cG9ydCBjbGFzcyBUYXNrRmllbGRSZW5kZXJlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhID0gdGFza0ZpZWxkSFRNTERhdGE7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGRhdGEgYXR0cmlidXRlIHRvIGFuIHtAbGluayBlbGVtZW50fSBmb3IgYSBjb21wb25lbnQuIEZvciBleGFtcGxlLFxuICAgICAqIGEgYDxzcGFuPmAgZGVzY3JpYmluZyBhIHRhc2sgd2l0aCBtZWRpdW0gcHJpb3JpdHkgYW5kIGRvbmUgeWVzdGVyZGF5IHdpbGwgaGF2ZVxuICAgICAqIGBkYXRhLXRhc2stcHJpb3JpdHk9XCJtZWRpdW1cIiBkYXRhLXRhc2stZHVlPVwicGFzdC0xZFwiYCBpbiBpdHMgZGF0YSBhdHRyaWJ1dGVzIChPbmUgZGF0YSBhdHRyaWJ1dGUgcGVyIGNvbXBvbmVudCkuXG4gICAgICpcbiAgICAgKiBJZiBubyBkYXRhIGF0dHJpYnV0ZSB3YXMgZm91bmQgZm9yIGEgY29tcG9uZW50IG9yIGRhdGEgYXR0cmlidXRlJ3MgdmFsdWUgaXMgZW1wdHksIGRhdGEgYXR0cmlidXRlIHdvbid0IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogRm9yIGRldGFpbGVkIGNhbGN1bGF0aW9uIHNlZSB7QGxpbmsgVGFza0ZpZWxkSFRNTERhdGEuYWRkRGF0YUF0dHJpYnV0ZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgSFRNTCBlbGVtZW50IHRvIGFkZCB0aGUgZGF0YSBhdHRyaWJ1dGUgdG8uXG4gICAgICogQHBhcmFtIHRhc2sgdGhlIHRhc2sgZnJvbSB3aGljaCB0aGUgZm9yIHRoZSBkYXRhIGF0dHJpYnV0ZSBzaGFsbCBiZSB0YWtlbi5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IHRoZSBjb21wb25lbnQgb2YgdGhlIHRhc2sgZm9yIHdoaWNoIHRoZSBkYXRhIGF0dHJpYnV0ZSBoYXMgdG8gYmUgYWRkZWQuXG4gICAgICovXG4gICAgcHVibGljIGFkZERhdGFBdHRyaWJ1dGUoZWxlbWVudDogSFRNTEVsZW1lbnQsIHRhc2s6IFRhc2ssIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmRhdGFbY29tcG9uZW50XS5hZGREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHRhc2ssIGNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY29tcG9uZW50J3MgQ1NTIGNsYXNzIGRlc2NyaWJpbmcgd2hhdCB0aGlzIGNvbXBvbmVudCBpcyAocHJpb3JpdHksIGR1ZSBkYXRlIGV0Yy4pIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IHdoZXJlIHRoZSBjbGFzcyBzaGFsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgb2YgdGhlIHRhc2suXG4gICAgICovXG4gICAgcHVibGljIGFkZENsYXNzTmFtZShlbGVtZW50OiBIVE1MRWxlbWVudCwgY29tcG9uZW50OiBUYXNrTGF5b3V0Q29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudENsYXNzID0gdGhpcy5kYXRhW2NvbXBvbmVudF0uY2xhc3NOYW1lO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uW2NvbXBvbmVudENsYXNzXSk7XG4gICAgfVxufVxuXG50eXBlIEF0dHJpYnV0ZVZhbHVlQ2FsY3VsYXRvciA9IChjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQsIHRhc2s6IFRhc2spID0+IHN0cmluZztcblxuZXhwb3J0IGNsYXNzIFRhc2tGaWVsZEhUTUxEYXRhIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBhdHRyaWJ1dGVOYW1lOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBhdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3I6IEF0dHJpYnV0ZVZhbHVlQ2FsY3VsYXRvcjtcblxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbm9BdHRyaWJ1dGVOYW1lID0gJyc7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBub0F0dHJpYnV0ZVZhbHVlQ2FsY3VsYXRvcjogQXR0cmlidXRlVmFsdWVDYWxjdWxhdG9yID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRhdGVBdHRyaWJ1dGVDYWxjdWxhdG9yID0gKGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCwgdGFzazogVGFzaykgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNsYXRlIGEgcmVsYXRpdmUgZGF0ZSB0byBhIENTUyBjbGFzczogJ3RvZGF5JywgJ2Z1dHVyZS0xZCcgKGZvciB0b21vcnJvdyksICdwYXN0LTFkJyAoZm9yIHllc3RlcmRheSlcbiAgICAgICAgICogZXRjLlxuICAgICAgICAgKiBBIGN1dG9mZiAoaW4gZGF5cykgaXMgZGVmaW5lZCBpbiBNQVhfREFZX1ZBTFVFX1JBTkdFLCBmcm9tIGJleW9uZCB0aGF0IGEgZ2VuZXJpYyAnZmFyJyBwb3N0Zml4IHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAqICh0aGUgY3V0b2ZmIGV4aXN0cyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gZmxvb2QgdGhlIERPTSB3aXRoIHBvdGVudGlhbGx5IGh1bmRyZWRzIG9mIHVuaXF1ZSBjbGFzc2VzLilcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IE1BWF9EQVlfVkFMVUVfUkFOR0UgPSA3O1xuICAgICAgICBjb25zdCBEQVlfVkFMVUVfT1ZFUl9SQU5HRV9QT1NURklYID0gJ2Zhcic7XG5cbiAgICAgICAgZnVuY3Rpb24gZGF0ZVRvQXR0cmlidXRlKGRhdGU6IE1vbWVudCkge1xuICAgICAgICAgICAgY29uc3QgdG9kYXkgPSB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICBjb25zdCBkaWZmRGF5cyA9IHRvZGF5LmRpZmYoZGF0ZSwgJ2RheXMnKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGRpZmZEYXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZEYXlzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2RheSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGlmIChkaWZmRGF5cyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3Bhc3QtJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZkRheXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdmdXR1cmUtJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZEYXlzKSA8PSBNQVhfREFZX1ZBTFVFX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGguYWJzKGRpZmZEYXlzKS50b1N0cmluZygpICsgJ2QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gREFZX1ZBTFVFX09WRVJfUkFOR0VfUE9TVEZJWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRlID0gdGFza1tjb21wb25lbnRdO1xuXG4gICAgICAgIC8vIFRTMjM0NTogQXJndW1lbnQgb2YgdHlwZSAnc3RyaW5nW10gfCBNb21lbnQnIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHBhcmFtZXRlciBvZiB0eXBlICdNb21lbnQnLlxuICAgICAgICAvLyBUeXBlICdzdHJpbmdbXScgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgZnJvbSB0eXBlICdNb21lbnQnOiBmb3JtYXQsIHN0YXJ0T2YsIGVuZE9mLCBhZGQsIGFuZCA3OCBtb3JlLlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0ZSkgJiYgZGF0ZSBpbnN0YW5jZW9mIHdpbmRvdy5tb21lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gZGF0ZVRvQXR0cmlidXRlKGRhdGUpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZSBDU1MgY2xhc3MgdGhhdCBkZXNjcmliZXMgd2hhdCB0aGUgY29tcG9uZW50IGlzLCBlLmcuIGEgZHVlIGRhdGUgb3IgYSBwcmlvcml0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lIGlmIHRoZSBjb21wb25lbnQgbmVlZHMgZGF0YSBhdHRyaWJ1dGUgKGBkYXRhLWtleT1cInZhbHVlXCJgKSB0aGlzIGlzIHRoZSBrZXkuXG4gICAgICogT3RoZXJ3aXNlLCBzZXQgdGhpcyB0byB7QGxpbmsgVGFza0ZpZWxkSFRNTERhdGEubm9BdHRyaWJ1dGVOYW1lfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3IgQW5kIHRoaXMgaXMgdGhlIHZhbHVlIGNhbGN1bGF0b3IuXG4gICAgICogU2V0IHRvIHtAbGluayBUYXNrRmllbGRIVE1MRGF0YS5ub0F0dHJpYnV0ZVZhbHVlQ2FsY3VsYXRvcn0gaWYgdGhlIGNvbXBvbmVudCBoYXMgbm8gZGF0YSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBhIHJlbGF0aW9uIGJldHdlZW4ge0BsaW5rIGF0dHJpYnV0ZU5hbWV9IGFuZCB7QGxpbmsgYXR0cmlidXRlVmFsdWVDYWxjdWxhdG9yfS5cbiAgICAgKiBGb3IgYSBjb21wb25lbnQgdG8gaGF2ZSB0aGUgZGF0YSBhdHRyaWJ1dGUsIGJvdGggbmVlZCB0byBiZSBzZXQgdG8gdmFsdWVzIG90aGVyIHRoYW5cbiAgICAgKiB7QGxpbmsgVGFza0ZpZWxkSFRNTERhdGEubm9BdHRyaWJ1dGVOYW1lfSBhbmQge0BsaW5rIFRhc2tGaWVsZEhUTUxEYXRhLm5vQXR0cmlidXRlVmFsdWVDYWxjdWxhdG9yfSByZXNwZWN0aXZlbHkuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGhhdmluZyBhbiBlbXB0eSBkYXRhIGF0dHJpYnV0ZSAoYGRhdGEta2V5PVwiXCJgKSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZVZhbHVlQ2FsY3VsYXRvcjogQXR0cmlidXRlVmFsdWVDYWxjdWxhdG9yKSB7XG4gICAgICAgIC8vIElmIGNsYXNzTmFtZSBpcyBlbXB0eSwgYHNwYW4uY2xhc3NMaXN0LmFkZCguLi5jb21wb25lbnRDbGFzcyk7YCB3aWxsIGZhaWwgaW4gcnVudGltZS5cbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdEZXZlbG9wZXIgbm90ZTogQ1NTIGNsYXNzIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcsIHBsZWFzZSBzcGVjaWZ5IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3IgPSBhdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hhbGwgYmUgY2FsbGVkIG9ubHkgYnkge0BsaW5rIFRhc2tGaWVsZFJlbmRlcmVyfS4gVXNlIHRoYXQgY2xhc3MgaWYgeW91IG5lZWQgdG8gYWRkIGEgZGF0YSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBBZGRzIHRoZSBkYXRhIGF0dHJpYnV0ZSwgYXNzb2NpYXRlZCB0byB3aXRoIGEgdGFzaydzIGNvbXBvbmVudCB0byBhbiBIVE1MIGVsZW1lbnQuXG4gICAgICogRm9yIGV4YW1wbGUsIGEgdGFzayB3aXRoIG1lZGl1bSBwcmlvcml0eSBhbmQgZG9uZSB5ZXN0ZXJkYXkgd2lsbCBoYXZlXG4gICAgICogYGRhdGEtdGFzay1wcmlvcml0eT1cIm1lZGl1bVwiIGRhdGEtdGFzay1kdWU9XCJwYXN0LTFkXCIgYCBpbiBpdHMgZGF0YSBhdHRyaWJ1dGVzIChPbmUgZGF0YSBhdHRyaWJ1dGUgcGVyIGNvbXBvbmVudCkuXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGlvbiBvZiB0aGUgdmFsdWUgaXMgZG9uZSB3aXRoIHtAbGluayBUYXNrRmllbGRIVE1MRGF0YS5hdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3J9LlxuICAgICAqXG4gICAgICogSWYgdGhlIGRhdGEgYXR0cmlidXRlJ3Mga2V5IG9yIGl0cyB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIG5vIGRhdGEgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgSFRNTCBlbGVtZW50IHRvIGFkZCB0aGUgZGF0YSBhdHRyaWJ1dGUgdG8uXG4gICAgICogQHBhcmFtIHRhc2sgdGhlIHRhc2sgZnJvbSB3aGljaCB0aGUgZGF0YSBzaGFsbCBiZSB0YWtlbi5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IHRoZSBjb21wb25lbnQgb2YgdGhlIHRhc2sgZm9yIHdoaWNoIHRoZSBkYXRhIGF0dHJpYnV0ZSBoYXMgdG8gYmUgYWRkZWQuXG4gICAgICovXG4gICAgcHVibGljIGFkZERhdGFBdHRyaWJ1dGUoZWxlbWVudDogSFRNTEVsZW1lbnQsIHRhc2s6IFRhc2ssIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVOYW1lID09PSBUYXNrRmllbGRIVE1MRGF0YS5ub0F0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gdGhpcy5hdHRyaWJ1dGVWYWx1ZUNhbGN1bGF0b3IoY29tcG9uZW50LCB0YXNrKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kYXRhc2V0W3RoaXMuYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkV2l0aG91dERhdGFBdHRyaWJ1dGVzKGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBUYXNrRmllbGRIVE1MRGF0YShcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBUYXNrRmllbGRIVE1MRGF0YS5ub0F0dHJpYnV0ZU5hbWUsXG4gICAgICAgIFRhc2tGaWVsZEhUTUxEYXRhLm5vQXR0cmlidXRlVmFsdWVDYWxjdWxhdG9yLFxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGVGaWVsZChjbGFzc05hbWU6IHN0cmluZywgYXR0cmlidXRlTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBUYXNrRmllbGRIVE1MRGF0YShjbGFzc05hbWUsIGF0dHJpYnV0ZU5hbWUsIFRhc2tGaWVsZEhUTUxEYXRhLmRhdGVBdHRyaWJ1dGVDYWxjdWxhdG9yKTtcbn1cblxuY29uc3QgdGFza0ZpZWxkSFRNTERhdGE6IHsgW2MgaW4gVGFza0xheW91dENvbXBvbmVudF06IFRhc2tGaWVsZEhUTUxEYXRhIH0gPSB7XG4gICAgLy8gTkVXX1RBU0tfRklFTERfRURJVF9SRVFVSVJFRFxuICAgIGNyZWF0ZWREYXRlOiBjcmVhdGVEYXRlRmllbGQoJ3Rhc2stY3JlYXRlZCcsICd0YXNrQ3JlYXRlZCcpLFxuICAgIGR1ZURhdGU6IGNyZWF0ZURhdGVGaWVsZCgndGFzay1kdWUnLCAndGFza0R1ZScpLFxuICAgIHJlbWluZGVyRGF0ZTogY3JlYXRlRGF0ZUZpZWxkKCd0YXNrLXJlbWluZGVyJywgJ3Rhc2tSZW1pbmRlcicpLFxuICAgIHN0YXJ0RGF0ZTogY3JlYXRlRGF0ZUZpZWxkKCd0YXNrLXN0YXJ0JywgJ3Rhc2tTdGFydCcpLFxuICAgIHNjaGVkdWxlZERhdGU6IGNyZWF0ZURhdGVGaWVsZCgndGFzay1zY2hlZHVsZWQnLCAndGFza1NjaGVkdWxlZCcpLFxuICAgIGRvbmVEYXRlOiBjcmVhdGVEYXRlRmllbGQoJ3Rhc2stZG9uZScsICd0YXNrRG9uZScpLFxuICAgIGNhbmNlbGxlZERhdGU6IGNyZWF0ZURhdGVGaWVsZCgndGFzay1jYW5jZWxsZWQnLCAndGFza0NhbmNlbGxlZCcpLFxuXG4gICAgcHJpb3JpdHk6IG5ldyBUYXNrRmllbGRIVE1MRGF0YSgndGFzay1wcmlvcml0eScsICd0YXNrUHJpb3JpdHknLCAoX2NvbXBvbmVudCwgdGFzaykgPT4ge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlUb29scy5wcmlvcml0eU5hbWVVc2luZ05vcm1hbCh0YXNrLnByaW9yaXR5KS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIH0pLFxuXG4gICAgZGVzY3JpcHRpb246IGNyZWF0ZUZpZWxkV2l0aG91dERhdGFBdHRyaWJ1dGVzKCd0YXNrLWRlc2NyaXB0aW9uJyksXG4gICAgcmVjdXJyZW5jZVJ1bGU6IGNyZWF0ZUZpZWxkV2l0aG91dERhdGFBdHRyaWJ1dGVzKCd0YXNrLXJlY3VycmluZycpLFxuICAgIGRlcGVuZHNPbjogY3JlYXRlRmllbGRXaXRob3V0RGF0YUF0dHJpYnV0ZXMoJ3Rhc2stZGVwZW5kc09uJyksXG4gICAgaWQ6IGNyZWF0ZUZpZWxkV2l0aG91dERhdGFBdHRyaWJ1dGVzKCd0YXNrLWlkJyksXG4gICAgYmxvY2tMaW5rOiBjcmVhdGVGaWVsZFdpdGhvdXREYXRhQXR0cmlidXRlcygndGFzay1ibG9jay1saW5rJyksXG59O1xuIiwgImltcG9ydCB7IEVkaXRvclZpZXcsIFZpZXdQbHVnaW4gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB0eXBlIHsgUGx1Z2luVmFsdWUgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRhc2tzRmlsZSB9IGZyb20gJy4uL1NjcmlwdGluZy9UYXNrc0ZpbGUnO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2svVGFza0xvY2F0aW9uJztcblxuZXhwb3J0IGNvbnN0IG5ld0xpdmVQcmV2aWV3RXh0ZW5zaW9uID0gKCkgPT4ge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhMaXZlUHJldmlld0V4dGVuc2lvbik7XG59O1xuXG5jbGFzcyBMaXZlUHJldmlld0V4dGVuc2lvbiBpbXBsZW1lbnRzIFBsdWdpblZhbHVlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXc6IEVkaXRvclZpZXc7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVDbGlja0V2ZW50ID0gdGhpcy5oYW5kbGVDbGlja0V2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNsaWNrRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50O1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94IGNsaWNrcy5cbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB8fCB0YXJnZXQudHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmlnaHQgbm93IE9ic2lkaWFuIEFQSSBkb2VzIG5vdCBnaXZlIHVzIGEgd2F5IHRvIGhhbmRsZSBjaGVja2JveCBjbGlja3MgaW5zaWRlIHJlbmRlcmVkLXdpZGdldHMtaW4tTFAgc3VjaCBhc1xuICAgICAgICAgKiBjYWxsb3V0cywgdGFibGVzLCBhbmQgdHJhbnNjbHVzaW9ucyBiZWNhdXNlIGB0aGlzLnZpZXcucG9zQXRET01gIHdpbGwgcmV0dXJuIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHdpZGdldFxuICAgICAgICAgKiBhcyB0aGUgcG9zaXRpb24gZm9yIGFueSBjbGljayBpbnNpZGUgdGhlIHdpZGdldC5cbiAgICAgICAgICogRm9yIGNhbGxvdXRzLCB0aGlzIG1lYW5zIHRoYXQgdGhlIHRhc2sgd2lsbCBuZXZlciBiZSBmb3VuZCwgc2luY2UgdGhlIGBsaW5lQXRgIHdpbGwgYmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgY2FsbG91dC5cbiAgICAgICAgICogVGhlcmVmb3JlLCBwcm9kdWNlIGFuIGVycm9yIG1lc3NhZ2UgcG9wLXVwIHVzaW5nIE9ic2lkaWFuJ3MgXCJOb3RpY2VcIiBmZWF0dXJlLCBsb2cgYSBjb25zb2xlIHdhcm5pbmcsIHRoZW4gcmV0dXJuLlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBUYXNrcyBmcm9tIFwidGFza1wiIHF1ZXJ5IGNvZGVibG9ja3MgaGFuZGxlIHRoZW1zZWx2ZXMgdGhhbmtzIHRvIGB0b0xpYCwgc28gYmUgc3BlY2lmaWMgYWJvdXQgZXJyb3IgbWVzc2FnaW5nLCBidXQgc3RpbGwgcmV0dXJuLlxuICAgICAgICBjb25zdCBhbmNlc3RvciA9IHRhcmdldC5jbG9zZXN0KCd1bC5wbHVnaW4tdGFza3MtcXVlcnktcmVzdWx0LCBkaXYuY2FsbG91dC1jb250ZW50Jyk7XG4gICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLm1hdGNoZXMoJ2Rpdi5jYWxsb3V0LWNvbnRlbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICAgICAgICAgICAnb2JzaWRpYW4tdGFza3MtcGx1Z2luIHdhcm5pbmc6IFRhc2tzIGNhbm5vdCBhZGQgb3IgcmVtb3ZlIGNvbXBsZXRpb24gZGF0ZXMgb3IgbWFrZSB0aGUgbmV4dCBjb3B5IG9mIGEgcmVjdXJyaW5nIHRhc2sgZm9yIHRhc2tzIHdyaXR0ZW4gaW5zaWRlIGEgY2FsbG91dCB3aGVuIHlvdSBjbGljayB0aGVpciBjaGVja2JveGVzIGluIExpdmUgUHJldmlldy4gXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdJZiB5b3Ugd2FudGVkIFRhc2tzIHRvIGRvIHRoZXNlIHRoaW5ncywgcGxlYXNlIHVuZG8geW91ciBjaGFuZ2UsIHRoZW4gZWl0aGVyIGNsaWNrIHRoZSBsaW5lIG9mIHRoZSB0YXNrIGFuZCB1c2UgdGhlIFwiVG9nZ2xlIFRhc2sgRG9uZVwiIGNvbW1hbmQsIG9yIHN3aXRjaCB0byBSZWFkaW5nIFZpZXcgdG8gY2xpY2sgdGhlIGNoZWNrYm94Lic7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShtc2csIDQ1MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMudmlldztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnZpZXcucG9zQXRET00odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLnRleHQsXG4gICAgICAgICAgICAvLyBOb25lIG9mIHRoaXMgZGF0YSBpcyByZWxldmFudCBoZXJlLlxuICAgICAgICAgICAgLy8gVGhlIHRhc2sgaXMgY3JlYXRlZCwgdG9nZ2xlZCwgYW5kIHdyaXR0ZW4gYmFjayB0byB0aGUgQ002IGRvY3VtZW50LFxuICAgICAgICAgICAgLy8gcmVwbGFjaW5nIHRoZSBvbGQgdGFzayBpbi1wbGFjZS5cbiAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24obmV3IFRhc2tzRmlsZSgnJykpLFxuICAgICAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUZW1wb3JhcnkgZWRpdCAtIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzIxNjBcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgTGl2ZSBQcmV2aWV3IEV4dGVuc2lvbjogdG9nZ2xlIGNhbGxlZC4gUG9zaXRpb246ICR7cG9zaXRpb259IExpbmU6ICR7bGluZS50ZXh0fWApO1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94ZXMgb2YgdGFza3MuXG4gICAgICAgIGlmICh0YXNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXZlbnQgZGVmYXVsdCBzbyB0aGF0IHRoZSBjaGVja2JveCBpcyBvbmx5IGhhbmRsZWQgYnkgdXMgYW5kIG5vdCBvYnNpZGlhbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBDbGlja2VkIG9uIGEgdGFzaydzIGNoZWNrYm94LiBUb2dnbGUgdGhlIHRhc2sgYW5kIHNldCBpdC5cbiAgICAgICAgY29uc3QgdG9nZ2xlZCA9IHRhc2sudG9nZ2xlV2l0aFJlY3VycmVuY2VJblVzZXJzT3JkZXIoKTtcbiAgICAgICAgY29uc3QgdG9nZ2xlZFN0cmluZyA9IHRvZ2dsZWQubWFwKCh0KSA9PiB0LnRvRmlsZUxpbmVTdHJpbmcoKSkuam9pbihzdGF0ZS5saW5lQnJlYWspO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBDb2RlTWlycm9yIHRyYW5zYWN0aW9uIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGxpbmUudG8sXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiB0b2dnbGVkU3RyaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG5cbiAgICAgICAgLy8gRGlydHkgd29ya2Fyb3VuZC5cbiAgICAgICAgLy8gV2hpbGUgdGhlIGNvZGUgaW4gdGhpcyBtZXRob2QgcHJvcGVybHkgdXBkYXRlcyB0aGUgYGNoZWNrZWRgIHN0YXRlXG4gICAgICAgIC8vIG9mIHRoZSB0YXJnZXQgY2hlY2tib3gsIHNvbWUgT2JzaWRpYW4gaW50ZXJuYWxzIHJldmVydCB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgY2hlY2tib3ggd291bGQgcmVtYWluIGluIGl0cyBvcmlnaW5hbCBgY2hlY2tlZGBcbiAgICAgICAgLy8gc3RhdGUgKGB0cnVlYCBvciBgZmFsc2VgKSwgZXZlbiB0aG91Z2ggdGhlIHVuZGVybHlpbmcgZG9jdW1lbnRcbiAgICAgICAgLy8gdXBkYXRlcyBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEFzIGEgXCJmaXhcIiwgd2Ugc2V0IHRoZSBjaGVja2JveCdzIGBjaGVja2VkYCBzdGF0ZSAqYWdhaW4qIGFmdGVyIGFcbiAgICAgICAgLy8gdGltZW91dCB0byByZXZlcnQgT2JzaWRpYW4ncyB3cm9uZ2Z1bCByZXZlcnNhbC5cbiAgICAgICAgY29uc3QgZGVzaXJlZENoZWNrZWRTdGF0dXMgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQuY2hlY2tlZCA9IGRlc2lyZWRDaGVja2VkU3RhdHVzO1xuICAgICAgICB9LCAxKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFdmVudFJlZiwgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFwcCwgS2V5bWFwLCBNYXJrZG93blJlbmRlckNoaWxkLCBNYXJrZG93blJlbmRlcmVyLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4uL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgR2xvYmFsUXVlcnkgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsUXVlcnknO1xuaW1wb3J0IHsgUXVlcnlMYXlvdXQgfSBmcm9tICcuLi9MYXlvdXQvUXVlcnlMYXlvdXQnO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi4vVGFzay9EYXRlRmFsbGJhY2snO1xuXG5pbXBvcnQgdHlwZSB7IElRdWVyeSB9IGZyb20gJy4uL0lRdWVyeSc7XG5pbXBvcnQgeyBleHBsYWluUmVzdWx0cywgZ2V0UXVlcnlGb3JRdWVyeVJlbmRlcmVyIH0gZnJvbSAnLi4vbGliL1F1ZXJ5UmVuZGVyZXJIZWxwZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cERpc3BsYXlIZWFkaW5nIH0gZnJvbSAnLi4vUXVlcnkvR3JvdXAvR3JvdXBEaXNwbGF5SGVhZGluZyc7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5UmVzdWx0IH0gZnJvbSAnLi4vUXVlcnkvUXVlcnlSZXN1bHQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrR3JvdXBzIH0gZnJvbSAnLi4vUXVlcnkvR3JvdXAvVGFza0dyb3Vwcyc7XG5pbXBvcnQgeyBwb3N0cG9uZUJ1dHRvblRpdGxlLCBzaG91bGRTaG93UG9zdHBvbmVCdXR0b24gfSBmcm9tICcuLi9TY3JpcHRpbmcvUG9zdHBvbmVyJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBUYXNrTGF5b3V0IH0gZnJvbSAnLi4vTGF5b3V0L1Rhc2tMYXlvdXQnO1xuaW1wb3J0IHsgUG9zdHBvbmVNZW51IH0gZnJvbSAnLi4vdWkvTWVudXMvUG9zdHBvbmVNZW51JztcbmltcG9ydCB0eXBlIFRhc2tzUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgVGFza01vZGFsIH0gZnJvbSAnLi4vT2JzaWRpYW4vVGFza01vZGFsJztcbmltcG9ydCB0eXBlIHsgVGFza3NFdmVudHMgfSBmcm9tICcuLi9PYnNpZGlhbi9UYXNrc0V2ZW50cyc7XG5pbXBvcnQgeyBnZXRUYXNrTGluZUFuZEZpbGUsIHJlcGxhY2VUYXNrV2l0aFRhc2tzIH0gZnJvbSAnLi4vT2JzaWRpYW4vRmlsZSc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uL09ic2lkaWFuL0NhY2hlJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlVHJhY2tlciB9IGZyb20gJy4uL2xpYi9QZXJmb3JtYW5jZVRyYWNrZXInO1xuaW1wb3J0IHsgVGFza0xpbmVSZW5kZXJlciwgY3JlYXRlQW5kQXBwZW5kRWxlbWVudCB9IGZyb20gJy4vVGFza0xpbmVSZW5kZXJlcic7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVJlbmRlcmVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwO1xuICAgIHByaXZhdGUgcGx1Z2luOiBUYXNrc1BsdWdpbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogVGFza3NFdmVudHM7XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiwgZXZlbnRzIH06IHsgcGx1Z2luOiBUYXNrc1BsdWdpbjsgZXZlbnRzOiBUYXNrc0V2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuXG4gICAgICAgIHBsdWdpbi5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKCd0YXNrcycsIHRoaXMuX2FkZFF1ZXJ5UmVuZGVyQ2hpbGQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFF1ZXJ5UmVuZGVyQ2hpbGQgPSB0aGlzLl9hZGRRdWVyeVJlbmRlckNoaWxkLmJpbmQodGhpcyk7XG5cbiAgICBwcml2YXRlIGFzeW5jIF9hZGRRdWVyeVJlbmRlckNoaWxkKHNvdXJjZTogc3RyaW5nLCBlbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGV4dDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmFkZENoaWxkKFxuICAgICAgICAgICAgbmV3IFF1ZXJ5UmVuZGVyQ2hpbGQoe1xuICAgICAgICAgICAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGNvbnRleHQuc291cmNlUGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgIH1cbn1cblxuY2xhc3MgUXVlcnlSZW5kZXJDaGlsZCBleHRlbmRzIE1hcmtkb3duUmVuZGVyQ2hpbGQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwOiBBcHA7XG4gICAgcHJpdmF0ZSBwbHVnaW46IFRhc2tzUGx1Z2luO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBUYXNrc0V2ZW50cztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZSB0ZXh0IGluIHRoZSBpbnN0cnVjdGlvbiBibG9jaywgc3VjaCBhczpcbiAgICAgKiBgYGBcbiAgICAgKiAgIG5vdCBkb25lXG4gICAgICogICBzaG9ydCBtb2RlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgbm90IGNvbnRhaW4gdGhlIEdsb2JhbCBRdWVyeSBmcm9tIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAgICogVXNlIHtAbGluayBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXJ9IHRvIGdldCB0aGlzIHZhbHVlIHByZWZpeGVkIHdpdGggdGhlIEdsb2JhbCBRdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nO1xuXG4gICAgLy8vIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIGluc3RydWN0aW9uIGJsb2NrLlxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsZVBhdGg6IHN0cmluZztcblxuICAgIHByaXZhdGUgcXVlcnk6IElRdWVyeTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUUzYxMzM6ICdxdWVyeVR5cGUnIGlzIGRlY2xhcmVkIGJ1dCBpdHMgdmFsdWUgaXMgbmV2ZXIgcmVhZFxuICAgIHByaXZhdGUgcXVlcnlUeXBlOiBzdHJpbmc7IC8vIHdoaWxzdCB0aGVyZSBpcyBvbmx5IG9uZSBxdWVyeSB0eXBlLCB0aGVyZSBpcyBubyBwb2ludCBsb2dnaW5nIHRoaXMgdmFsdWVcblxuICAgIHByaXZhdGUgcmVuZGVyRXZlbnRSZWY6IEV2ZW50UmVmIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgcXVlcnlSZWxvYWRUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgYXBwLFxuICAgICAgICBwbHVnaW4sXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGZpbGVQYXRoLFxuICAgIH06IHtcbiAgICAgICAgYXBwOiBBcHA7XG4gICAgICAgIHBsdWdpbjogVGFza3NQbHVnaW47XG4gICAgICAgIGV2ZW50czogVGFza3NFdmVudHM7XG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgICAgIHNvdXJjZTogc3RyaW5nO1xuICAgICAgICBmaWxlUGF0aDogc3RyaW5nO1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuXG4gICAgICAgIC8vIFRoZSBlbmdpbmUgaXMgY2hvc2VuIG9uIHRoZSBiYXNpcyBvZiB0aGUgY29kZSBibG9jayBsYW5ndWFnZS4gQ3VycmVudGx5LFxuICAgICAgICAvLyB0aGVyZSBpcyBvbmx5IHRoZSBtYWluIGVuZ2luZSBmb3IgdGhlIHBsdWdpbiwgdGhpcyBhbGxvd3Mgb3RoZXJzIHRvIGJlXG4gICAgICAgIC8vIGFkZGVkIGxhdGVyLlxuICAgICAgICBzd2l0Y2ggKHRoaXMuY29udGFpbmVyRWwuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdibG9jay1sYW5ndWFnZS10YXNrcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IGdldFF1ZXJ5Rm9yUXVlcnlSZW5kZXJlcih0aGlzLnNvdXJjZSwgR2xvYmFsUXVlcnkuZ2V0SW5zdGFuY2UoKSwgdGhpcy5maWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAndGFza3MnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXIodGhpcy5zb3VyY2UsIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCksIHRoaXMuZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ3Rhc2tzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9ubG9hZCgpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY3VycmVudCBjYWNoZSBzdGF0ZTpcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlclJlcXVlc3RDYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTGlzdGVuIHRvIGZ1dHVyZSBjYWNoZSBjaGFuZ2VzOlxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50UmVmID0gdGhpcy5ldmVudHMub25DYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnJlbG9hZFF1ZXJ5QXRNaWRuaWdodCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJFdmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vZmYodGhpcy5yZW5kZXJFdmVudFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5xdWVyeVJlbG9hZFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucXVlcnlSZWxvYWRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIHF1ZXJ5IGFmdGVyIG1pZG5pZ2h0IHRvIHVwZGF0ZSByZXN1bHRzIGZyb20gcmVsYXRpdmUgZGF0ZSBxdWVyaWVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBxdWVyeSBgZHVlIHRvZGF5YCBjaGFuZ2VzIGV2ZXJ5IGRheS4gVGhpcyBtYWtlcyBzdXJlIHRoYXQgYWxsIHF1ZXJ5IHJlc3VsdHNcbiAgICAgKiBhcmUgcmUtcmVuZGVyZWQgYWZ0ZXIgbWlkbmlnaHQgZXZlcnkgZGF5IHRvIGVuc3VyZSB1cC10by1kYXRlIHJlc3VsdHMgd2l0aG91dCBoYXZpbmcgdG9cbiAgICAgKiByZWxvYWQgb2JzaWRpYW4uIENyZWF0aW5nIGEgbmV3IHF1ZXJ5IG9iamVjdCBmcm9tIHRoZSBzb3VyY2UgcmUtYXBwbGllcyB0aGUgcmVsYXRpdmUgZGF0ZXNcbiAgICAgKiB0byBcIm5vd1wiLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVsb2FkUXVlcnlBdE1pZG5pZ2h0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtaWRuaWdodCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIG1pZG5pZ2h0LnNldEhvdXJzKDI0LCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcblxuICAgICAgICBjb25zdCBtaWxsaXNlY29uZHNUb01pZG5pZ2h0ID0gbWlkbmlnaHQuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKTtcblxuICAgICAgICB0aGlzLnF1ZXJ5UmVsb2FkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IGdldFF1ZXJ5Rm9yUXVlcnlSZW5kZXJlcih0aGlzLnNvdXJjZSwgR2xvYmFsUXVlcnkuZ2V0SW5zdGFuY2UoKSwgdGhpcy5maWxlUGF0aCk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBjdXJyZW50IGNhY2hlIHN0YXRlOlxuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlclJlcXVlc3RDYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkUXVlcnlBdE1pZG5pZ2h0KCk7XG4gICAgICAgIH0sIG1pbGxpc2Vjb25kc1RvTWlkbmlnaHQgKyAxMDAwKTsgLy8gQWRkIGJ1ZmZlciB0byBiZSBzdXJlIHRvIHJ1biBhZnRlciBtaWRuaWdodC5cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlcih7IHRhc2tzLCBzdGF0ZSB9OiB7IHRhc2tzOiBUYXNrW107IHN0YXRlOiBTdGF0ZSB9KSB7XG4gICAgICAgIC8vIERvbid0IGxvZyBhbnl0aGluZyBoZXJlLCBmb3IgYW55IHN0YXRlLCBhcyBpdCBnZW5lcmF0ZXMgaHVnZSBhbW91bnRzIG9mXG4gICAgICAgIC8vIGNvbnNvbGUgbWVzc2FnZXMgaW4gbGFyZ2UgdmF1bHRzLCBpZiBPYnNpZGlhbiB3YXMgb3BlbmVkIHdpdGggYW55XG4gICAgICAgIC8vIG5vdGVzIHdpdGggdGFza3MgY29kZSBibG9ja3MgaW4gUmVhZGluZyBvciBMaXZlIFByZXZpZXcgbW9kZS5cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlQW5kQXBwZW5kRWxlbWVudCgnZGl2JywgdGhpcy5jb250YWluZXJFbCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuV2FybSAmJiB0aGlzLnF1ZXJ5LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUXVlcnlTZWFyY2hSZXN1bHRzKHRhc2tzLCBzdGF0ZSwgY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5xdWVyeS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckVycm9yTWVzc2FnZShjb250ZW50LCB0aGlzLnF1ZXJ5LmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTG9hZGluZ01lc3NhZ2UoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmZpcnN0Q2hpbGQ/LnJlcGxhY2VXaXRoKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyUXVlcnlTZWFyY2hSZXN1bHRzKHRhc2tzOiBUYXNrW10sIHN0YXRlOiBTdGF0ZS5XYXJtLCBjb250ZW50OiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHRoaXMuZXhwbGFpbkFuZFBlcmZvcm1TZWFyY2goc3RhdGUsIHRhc2tzLCBjb250ZW50KTtcblxuICAgICAgICBpZiAocXVlcnlSZXN1bHQuc2VhcmNoRXJyb3JNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBpbiB0aGUgc2VhcmNoLCBmb3IgZXhhbXBsZSBkdWUgdG8gYSBwcm9ibGVtIGN1c3RvbSBmdW5jdGlvbi5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXJyb3JNZXNzYWdlKGNvbnRlbnQsIHF1ZXJ5UmVzdWx0LnNlYXJjaEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclNlYXJjaFJlc3VsdHMocXVlcnlSZXN1bHQsIGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXhwbGFpbkFuZFBlcmZvcm1TZWFyY2goc3RhdGU6IFN0YXRlLldhcm0sIHRhc2tzOiBUYXNrW10sIGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVTZWFyY2ggPSBuZXcgUGVyZm9ybWFuY2VUcmFja2VyKGBTZWFyY2g6ICR7dGhpcy5xdWVyeS5xdWVyeUlkfSAtICR7dGhpcy5maWxlUGF0aH1gKTtcbiAgICAgICAgbWVhc3VyZVNlYXJjaC5zdGFydCgpO1xuXG4gICAgICAgIHRoaXMucXVlcnkuZGVidWcoYFtyZW5kZXJdIFJlbmRlciBjYWxsZWQ6IHBsdWdpbiBzdGF0ZTogJHtzdGF0ZX07IHNlYXJjaGluZyAke3Rhc2tzLmxlbmd0aH0gdGFza3NgKTtcblxuICAgICAgICBpZiAodGhpcy5xdWVyeS5xdWVyeUxheW91dE9wdGlvbnMuZXhwbGFpblF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUV4cGxhbmF0aW9uKGNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSB0aGlzLnF1ZXJ5LmFwcGx5UXVlcnlUb1Rhc2tzKHRhc2tzKTtcblxuICAgICAgICBtZWFzdXJlU2VhcmNoLmZpbmlzaCgpO1xuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZW5kZXJTZWFyY2hSZXN1bHRzKHF1ZXJ5UmVzdWx0OiBRdWVyeVJlc3VsdCwgY29udGVudDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZVJlbmRlciA9IG5ldyBQZXJmb3JtYW5jZVRyYWNrZXIoYFJlbmRlcjogJHt0aGlzLnF1ZXJ5LnF1ZXJ5SWR9IC0gJHt0aGlzLmZpbGVQYXRofWApO1xuICAgICAgICBtZWFzdXJlUmVuZGVyLnN0YXJ0KCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5hZGRBbGxUYXNrR3JvdXBzKHF1ZXJ5UmVzdWx0LnRhc2tHcm91cHMsIGNvbnRlbnQpO1xuXG4gICAgICAgIGNvbnN0IHRvdGFsVGFza3NDb3VudCA9IHF1ZXJ5UmVzdWx0LnRvdGFsVGFza3NDb3VudDtcbiAgICAgICAgdGhpcy5hZGRUYXNrQ291bnQoY29udGVudCwgcXVlcnlSZXN1bHQpO1xuXG4gICAgICAgIHRoaXMucXVlcnkuZGVidWcoYFtyZW5kZXJdICR7dG90YWxUYXNrc0NvdW50fSB0YXNrcyBkaXNwbGF5ZWRgKTtcblxuICAgICAgICBtZWFzdXJlUmVuZGVyLmZpbmlzaCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyRXJyb3JNZXNzYWdlKGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LCBlcnJvck1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgICBjb250ZW50LmNyZWF0ZURpdigpLmlubmVySFRNTCA9ICc8cHJlPicgKyBgVGFza3MgcXVlcnk6ICR7ZXJyb3JNZXNzYWdlLnJlcGxhY2UoL1xcbi9nLCAnPGJyPicpfWAgKyAnPC9wcmU+JztcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckxvYWRpbmdNZXNzYWdlKGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50KSB7XG4gICAgICAgIGNvbnRlbnQuc2V0VGV4dCgnTG9hZGluZyBUYXNrcyAuLi4nKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlICdleHBsYWluJyBpbnN0cnVjdGlvbiB0byBlbmFibGUgdGhpc1xuICAgIHByaXZhdGUgY3JlYXRlRXhwbGFuYXRpb24oY29udGVudDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25Bc1N0cmluZyA9IGV4cGxhaW5SZXN1bHRzKFxuICAgICAgICAgICAgdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCksXG4gICAgICAgICAgICB0aGlzLmZpbGVQYXRoLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uc0Jsb2NrID0gY3JlYXRlQW5kQXBwZW5kRWxlbWVudCgncHJlJywgY29udGVudCk7XG4gICAgICAgIGV4cGxhbmF0aW9uc0Jsb2NrLmFkZENsYXNzZXMoWydwbHVnaW4tdGFza3MtcXVlcnktZXhwbGFuYXRpb24nXSk7XG4gICAgICAgIGV4cGxhbmF0aW9uc0Jsb2NrLnNldFRleHQoZXhwbGFuYXRpb25Bc1N0cmluZyk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZXhwbGFuYXRpb25zQmxvY2spO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlVGFza0xpc3QodGFza3M6IFRhc2tbXSwgY29udGVudDogSFRNTERpdkVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGFza0xpc3QgPSBjcmVhdGVBbmRBcHBlbmRFbGVtZW50KCd1bCcsIGNvbnRlbnQpO1xuXG4gICAgICAgIHRhc2tMaXN0LmFkZENsYXNzZXMoWydjb250YWlucy10YXNrLWxpc3QnLCAncGx1Z2luLXRhc2tzLXF1ZXJ5LXJlc3VsdCddKTtcbiAgICAgICAgY29uc3QgdGFza0xheW91dCA9IG5ldyBUYXNrTGF5b3V0KHRoaXMucXVlcnkudGFza0xheW91dE9wdGlvbnMpO1xuICAgICAgICB0YXNrTGlzdC5hZGRDbGFzc2VzKHRhc2tMYXlvdXQuZ2VuZXJhdGVIaWRkZW5DbGFzc2VzKCkpO1xuICAgICAgICBjb25zdCBxdWVyeUxheW91dCA9IG5ldyBRdWVyeUxheW91dCh0aGlzLnF1ZXJ5LnF1ZXJ5TGF5b3V0T3B0aW9ucyk7XG4gICAgICAgIHRhc2tMaXN0LmFkZENsYXNzZXMocXVlcnlMYXlvdXQuZ2V0SGlkZGVuQ2xhc3NlcygpKTtcblxuICAgICAgICBjb25zdCBncm91cGluZ0F0dHJpYnV0ZSA9IHRoaXMuZ2V0R3JvdXBpbmdBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYgKGdyb3VwaW5nQXR0cmlidXRlICYmIGdyb3VwaW5nQXR0cmlidXRlLmxlbmd0aCA+IDApIHRhc2tMaXN0LmRhdGFzZXQudGFza0dyb3VwQnkgPSBncm91cGluZ0F0dHJpYnV0ZTtcblxuICAgICAgICBjb25zdCB0YXNrTGluZVJlbmRlcmVyID0gbmV3IFRhc2tMaW5lUmVuZGVyZXIoe1xuICAgICAgICAgICAgb2JzaWRpYW5Db21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRVbEVsZW1lbnQ6IHRhc2tMaXN0LFxuICAgICAgICAgICAgdGFza0xheW91dE9wdGlvbnM6IHRoaXMucXVlcnkudGFza0xheW91dE9wdGlvbnMsXG4gICAgICAgICAgICBxdWVyeUxheW91dE9wdGlvbnM6IHRoaXMucXVlcnkucXVlcnlMYXlvdXRPcHRpb25zLFxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGNvbnN0IFt0YXNrSW5kZXgsIHRhc2tdIG9mIHRhc2tzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRUYXNrKHRhc2tMaXN0LCB0YXNrTGluZVJlbmRlcmVyLCB0YXNrLCB0YXNrSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0YXNrTGlzdCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBhZGRUYXNrKFxuICAgICAgICB0YXNrTGlzdDogSFRNTFVMaXN0RWxlbWVudCxcbiAgICAgICAgdGFza0xpbmVSZW5kZXJlcjogVGFza0xpbmVSZW5kZXJlcixcbiAgICAgICAgdGFzazogVGFzayxcbiAgICAgICAgdGFza0luZGV4OiBudW1iZXIsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGlzRmlsZW5hbWVVbmlxdWUgPSB0aGlzLmlzRmlsZW5hbWVVbmlxdWUoeyB0YXNrIH0pO1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGF3YWl0IHRhc2tMaW5lUmVuZGVyZXIucmVuZGVyVGFza0xpbmUodGFzaywgdGFza0luZGV4LCBpc0ZpbGVuYW1lVW5pcXVlKTtcblxuICAgICAgICAvLyBSZW1vdmUgYWxsIGZvb3Rub3Rlcy4gVGhleSBkb24ndCByZS1hcHBlYXIgaW4gYW5vdGhlciBkb2N1bWVudC5cbiAgICAgICAgY29uc3QgZm9vdG5vdGVzID0gbGlzdEl0ZW0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZm9vdG5vdGUtaWRdJyk7XG4gICAgICAgIGZvb3Rub3Rlcy5mb3JFYWNoKChmb290bm90ZSkgPT4gZm9vdG5vdGUucmVtb3ZlKCkpO1xuXG4gICAgICAgIGNvbnN0IGV4dHJhc1NwYW4gPSBsaXN0SXRlbS5jcmVhdGVTcGFuKCd0YXNrLWV4dHJhcycpO1xuXG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5xdWVyeUxheW91dE9wdGlvbnMuaGlkZVVyZ2VuY3kpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVXJnZW5jeShleHRyYXNTcGFuLCB0YXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNob3J0TW9kZSA9IHRoaXMucXVlcnkucXVlcnlMYXlvdXRPcHRpb25zLnNob3J0TW9kZTtcblxuICAgICAgICBpZiAoIXRoaXMucXVlcnkucXVlcnlMYXlvdXRPcHRpb25zLmhpZGVCYWNrbGlua3MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQmFja2xpbmtzKGV4dHJhc1NwYW4sIHRhc2ssIHNob3J0TW9kZSwgaXNGaWxlbmFtZVVuaXF1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucXVlcnkucXVlcnlMYXlvdXRPcHRpb25zLmhpZGVFZGl0QnV0dG9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPIE5lZWQgdG8gZXhwbG9yZSB3aGF0IGhhcHBlbnMgaWYgYSB0YXNrcyBjb2RlIGJsb2NrIGlzIHJlbmRlcmVkIGJlZm9yZSB0aGUgQ2FjaGUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgIHRoaXMuYWRkRWRpdEJ1dHRvbihleHRyYXNTcGFuLCB0YXNrLCB0aGlzLnBsdWdpbi5nZXRUYXNrcygpISk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucXVlcnkucXVlcnlMYXlvdXRPcHRpb25zLmhpZGVQb3N0cG9uZUJ1dHRvbiAmJiBzaG91bGRTaG93UG9zdHBvbmVCdXR0b24odGFzaykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zdHBvbmVCdXR0b24oZXh0cmFzU3BhbiwgdGFzaywgc2hvcnRNb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZEVkaXRCdXR0b24obGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrLCBhbGxUYXNrczogVGFza1tdKSB7XG4gICAgICAgIGNvbnN0IGVkaXRUYXNrUGVuY2lsID0gY3JlYXRlQW5kQXBwZW5kRWxlbWVudCgnYScsIGxpc3RJdGVtKTtcbiAgICAgICAgZWRpdFRhc2tQZW5jaWwuYWRkQ2xhc3MoJ3Rhc2tzLWVkaXQnKTtcbiAgICAgICAgZWRpdFRhc2tQZW5jaWwudGl0bGUgPSAnRWRpdCB0YXNrJztcbiAgICAgICAgZWRpdFRhc2tQZW5jaWwuaHJlZiA9ICcjJztcblxuICAgICAgICBlZGl0VGFza1BlbmNpbC5vbkNsaWNrRXZlbnQoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBjb25zdCBvblN1Ym1pdCA9IGFzeW5jICh1cGRhdGVkVGFza3M6IFRhc2tbXSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlcGxhY2VUYXNrV2l0aFRhc2tzKHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUYXNrOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICBuZXdUYXNrczogRGF0ZUZhbGxiYWNrLnJlbW92ZUluZmVycmVkU3RhdHVzSWZOZWVkZWQodGFzaywgdXBkYXRlZFRhc2tzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUsIGFzIGN1cnNvci90YXNrIGNhbiBjaGFuZ2UuXG4gICAgICAgICAgICBjb25zdCB0YXNrTW9kYWwgPSBuZXcgVGFza01vZGFsKHtcbiAgICAgICAgICAgICAgICBhcHA6IHRoaXMuYXBwLFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgb25TdWJtaXQsXG4gICAgICAgICAgICAgICAgYWxsVGFza3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhc2tNb2RhbC5vcGVuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVXJnZW5jeShsaXN0SXRlbTogSFRNTEVsZW1lbnQsIHRhc2s6IFRhc2spIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpLmZvcm1hdCh0YXNrLnVyZ2VuY3kpO1xuICAgICAgICBsaXN0SXRlbS5jcmVhdGVTcGFuKHsgdGV4dCwgY2xzOiAndGFza3MtdXJnZW5jeScgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBhZGRBbGxUYXNrR3JvdXBzKHRhc2tzU29ydGVkTGltaXRlZEdyb3VwZWQ6IFRhc2tHcm91cHMsIGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGFza3NTb3J0ZWRMaW1pdGVkR3JvdXBlZC5ncm91cHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbnMsIGdyb3VwLmdyb3VwSGVhZGluZ3NcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgZW1wdHksIGFuZCBubyBoZWFkaW5ncyB3aWxsIGJlIGFkZGVkLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRHcm91cEhlYWRpbmdzKGNvbnRlbnQsIGdyb3VwLmdyb3VwSGVhZGluZ3MpO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVRhc2tMaXN0KGdyb3VwLnRhc2tzLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgaGVhZGluZ3MgZm9yIGEgZ3JvdXAgb2YgdGFza3MuXG4gICAgICogQHBhcmFtIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gZ3JvdXBIZWFkaW5ncyAtIFRoZSBoZWFkaW5ncyB0byBkaXNwbGF5LiBUaGlzIGNhbiBiZSBhbiBlbXB0eSBhcnJheSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGluIHdoaWNoIGNhc2Ugbm8gaGVhZGluZ3Mgd2lsbCBiZSBhZGRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgYWRkR3JvdXBIZWFkaW5ncyhjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgZ3JvdXBIZWFkaW5nczogR3JvdXBEaXNwbGF5SGVhZGluZ1tdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiBncm91cEhlYWRpbmdzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZEdyb3VwSGVhZGluZyhjb250ZW50LCBoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgYWRkR3JvdXBIZWFkaW5nKGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LCBncm91cDogR3JvdXBEaXNwbGF5SGVhZGluZykge1xuICAgICAgICAvLyBIZWFkaW5ncyBuZXN0ZWQgdG8gMiBvciBtb3JlIGxldmVscyBhcmUgYWxsIGRpc3BsYXllZCB3aXRoICdoNjpcbiAgICAgICAgbGV0IGhlYWRlcjoga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwID0gJ2g2JztcbiAgICAgICAgaWYgKGdyb3VwLm5lc3RpbmdMZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgaGVhZGVyID0gJ2g0JztcbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5uZXN0aW5nTGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIGhlYWRlciA9ICdoNSc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoZWFkZXJFbCA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoaGVhZGVyLCBjb250ZW50KTtcbiAgICAgICAgaGVhZGVyRWwuYWRkQ2xhc3MoJ3Rhc2tzLWdyb3VwLWhlYWRpbmcnKTtcbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXJNYXJrZG93bihncm91cC5kaXNwbGF5TmFtZSwgaGVhZGVyRWwsIHRoaXMuZmlsZVBhdGgsIHRoaXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQmFja2xpbmtzKGxpc3RJdGVtOiBIVE1MRWxlbWVudCwgdGFzazogVGFzaywgc2hvcnRNb2RlOiBib29sZWFuLCBpc0ZpbGVuYW1lVW5pcXVlOiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJhY2tMaW5rID0gbGlzdEl0ZW0uY3JlYXRlU3Bhbih7IGNsczogJ3Rhc2tzLWJhY2tsaW5rJyB9KTtcblxuICAgICAgICBpZiAoIXNob3J0TW9kZSkge1xuICAgICAgICAgICAgYmFja0xpbmsuYXBwZW5kKCcgKCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGluayA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ2EnLCBiYWNrTGluayk7XG5cbiAgICAgICAgbGluay5yZWwgPSAnbm9vcGVuZXInO1xuICAgICAgICBsaW5rLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICBsaW5rLmFkZENsYXNzKCdpbnRlcm5hbC1saW5rJyk7XG4gICAgICAgIGlmIChzaG9ydE1vZGUpIHtcbiAgICAgICAgICAgIGxpbmsuYWRkQ2xhc3MoJ2ludGVybmFsLWxpbmstc2hvcnQtbW9kZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmtUZXh0OiBzdHJpbmc7XG4gICAgICAgIGlmIChzaG9ydE1vZGUpIHtcbiAgICAgICAgICAgIGxpbmtUZXh0ID0gJyBcdUQ4M0RcdUREMTcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlua1RleHQgPSB0YXNrLmdldExpbmtUZXh0KHsgaXNGaWxlbmFtZVVuaXF1ZSB9KSA/PyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmsuc2V0VGV4dChsaW5rVGV4dCk7XG5cbiAgICAgICAgLy8gR28gdG8gdGhlIGxpbmUgdGhlIHRhc2sgaXMgZGVmaW5lZCBhdFxuICAgICAgICBjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRUYXNrTGluZUFuZEZpbGUodGFzaywgdmF1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtsaW5lLCBmaWxlXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoS2V5bWFwLmlzTW9kRXZlbnQoZXYpKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBjb3JyZXNwb25kaW5nIHRhc2sgaGFzIGJlZW4gZm91bmQsXG4gICAgICAgICAgICAgICAgLy8gc3VwcHJlc3MgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIG1vdXNlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gKHdoaWNoIHdvdWxkIGludGVyZmVyZSBlLmcuIGlmIHRoZSBxdWVyeSBpcyByZW5kZXJlZCBpbnNpZGUgYSBjYWxsb3V0KS5cbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIG9wZW4gdGhlIGZpbGUgd2l0aCB0aGUgcmVxdWlyZWQgbGluZSBoaWdobGlnaHRlZC5cbiAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUsIHsgZVN0YXRlOiB7IGxpbmU6IGxpbmUgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBhc3luYyAoZXY6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIE9wZW4gaW4gYSBuZXcgdGFiIG9uIG1pZGRsZS1jbGljay5cbiAgICAgICAgICAgIC8vIFRoaXMgZGlzdGluY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgJ2NsaWNrJyBldmVudCwgc28gd2UgaGFuZGxlIHRoZSAnbW91c2Vkb3duJyBldmVudFxuICAgICAgICAgICAgLy8gc29sZWx5IGZvciB0aGlzLlxuICAgICAgICAgICAgLy8gKGZvciByZWd1bGFyIGxlZnQtY2xpY2sgd2UgcHJlZmVyIHRoZSAnY2xpY2snIGV2ZW50LCBhbmQgbm90IHRvIGp1c3QgZG8gZXZlcnl0aGluZyBoZXJlLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgJ2NsaWNrJyBldmVudCBpcyBtb3JlIGdlbmVyaWMgZm9yIHRvdWNoIGRldmljZXMgZXRjLilcbiAgICAgICAgICAgIGlmIChldi5idXR0b24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRUYXNrTGluZUFuZEZpbGUodGFzaywgdmF1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2xpbmUsIGZpbGVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoJ3RhYicpO1xuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUsIHsgZVN0YXRlOiB7IGxpbmU6IGxpbmUgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc2hvcnRNb2RlKSB7XG4gICAgICAgICAgICBiYWNrTGluay5hcHBlbmQoJyknKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkUG9zdHBvbmVCdXR0b24obGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrLCBzaG9ydE1vZGU6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gMTtcbiAgICAgICAgY29uc3QgdGltZVVuaXQgPSAnZGF5JztcbiAgICAgICAgY29uc3QgYnV0dG9uVG9vbHRpcFRleHQgPSBwb3N0cG9uZUJ1dHRvblRpdGxlKHRhc2ssIGFtb3VudCwgdGltZVVuaXQpO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQoJ2EnLCBsaXN0SXRlbSk7XG4gICAgICAgIGJ1dHRvbi5hZGRDbGFzcygndGFza3MtcG9zdHBvbmUnKTtcbiAgICAgICAgaWYgKHNob3J0TW9kZSkge1xuICAgICAgICAgICAgYnV0dG9uLmFkZENsYXNzKCd0YXNrcy1wb3N0cG9uZS1zaG9ydC1tb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uLnRpdGxlID0gYnV0dG9uVG9vbHRpcFRleHQ7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBzdXBwcmVzcyB0aGUgZGVmYXVsdCBjbGljayBiZWhhdmlvclxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN1cHByZXNzIGZ1cnRoZXIgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgIFBvc3Rwb25lTWVudS5wb3N0cG9uZU9uQ2xpY2tDYWxsYmFjayhidXR0b24sIHRhc2ssIGFtb3VudCwgdGltZVVuaXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiogT3BlbiBhIGNvbnRleHQgbWVudSBvbiByaWdodC1jbGljay5cbiAgICAgICAgICovXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGFzeW5jIChldjogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgLy8gc3VwcHJlc3MgdGhlIGRlZmF1bHQgY29udGV4dCBtZW51XG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3VwcHJlc3MgZnVydGhlciBldmVudCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgY29uc3QgbWVudSA9IG5ldyBQb3N0cG9uZU1lbnUoYnV0dG9uLCB0YXNrKTtcbiAgICAgICAgICAgIG1lbnUuc2hvd0F0UG9zaXRpb24oeyB4OiBldi5jbGllbnRYLCB5OiBldi5jbGllbnRZIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRhc2tDb3VudChjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgcXVlcnlSZXN1bHQ6IFF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5xdWVyeUxheW91dE9wdGlvbnMuaGlkZVRhc2tDb3VudCkge1xuICAgICAgICAgICAgY29udGVudC5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHF1ZXJ5UmVzdWx0LnRvdGFsVGFza3NDb3VudERpc3BsYXlUZXh0KCksXG4gICAgICAgICAgICAgICAgY2xzOiAndGFza3MtY291bnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzRmlsZW5hbWVVbmlxdWUoeyB0YXNrIH06IHsgdGFzazogVGFzayB9KTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIC8vIFdpbGwgbWF0Y2ggdGhlIGZpbGVuYW1lIHdpdGhvdXQgZXh0ZW5zaW9uICh0aGUgZmlsZSdzIFwiYmFzZW5hbWVcIikuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lTWF0Y2ggPSB0YXNrLnBhdGgubWF0Y2goLyhbXi9dKilcXC4uKyQvaSk7XG4gICAgICAgIGlmIChmaWxlbmFtZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBmaWxlbmFtZU1hdGNoWzFdO1xuICAgICAgICBjb25zdCBhbGxGaWxlc1dpdGhTYW1lTmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZS5iYXNlbmFtZSA9PT0gZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIGZpbGUgd2l0aCB0aGUgc2FtZSBuYW1lIChpdCBtaWdodCBhY3R1YWxseSBiZSB0aGUgc2FtZSBmaWxlLCBidXQgd2UnbGwgdGFrZSB0aGF0IGludG8gYWNjb3VudCBsYXRlci4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhbGxGaWxlc1dpdGhTYW1lTmFtZS5sZW5ndGggPCAyO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0R3JvdXBpbmdBdHRyaWJ1dGUoKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nUnVsZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy5xdWVyeS5ncm91cGluZykge1xuICAgICAgICAgICAgZ3JvdXBpbmdSdWxlcy5wdXNoKGdyb3VwLnByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBpbmdSdWxlcy5qb2luKCcsJyk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QoaGlkZGVuQ2xhc3Nlczogc3RyaW5nW10sIGhpZGU6IGJvb2xlYW4sIGNvbXBvbmVudDogc3RyaW5nKSB7XG4gICAgaWYgKGhpZGUpIHtcbiAgICAgICAgaGlkZGVuQ2xhc3Nlcy5wdXNoKGhpZGRlbkNvbXBvbmVudENsYXNzTmFtZShjb21wb25lbnQpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhpZGRlbkNvbXBvbmVudENsYXNzTmFtZShjb21wb25lbnQ6IHN0cmluZykge1xuICAgIHJldHVybiBgdGFza3MtbGF5b3V0LWhpZGUtJHtjb21wb25lbnR9YDtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QgfSBmcm9tICcuL0xheW91dEhlbHBlcnMnO1xuaW1wb3J0IHsgUXVlcnlMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi9RdWVyeUxheW91dE9wdGlvbnMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIGEgbGlzdCBvZiBoaWRkZW4gcXVlcnkgY29tcG9uZW50cycgY2xhc3Nlcy5cbiAqIFRoZSBvdXRwdXQgZGVwZW5kcyBvbiB7QGxpbmsgUXVlcnlMYXlvdXRPcHRpb25zfSBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgUXVlcnlMYXlvdXQge1xuICAgIHByb3RlY3RlZCBxdWVyeUxheW91dE9wdGlvbnM6IFF1ZXJ5TGF5b3V0T3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5TGF5b3V0T3B0aW9ucz86IFF1ZXJ5TGF5b3V0T3B0aW9ucykge1xuICAgICAgICBpZiAocXVlcnlMYXlvdXRPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5TGF5b3V0T3B0aW9ucyA9IHF1ZXJ5TGF5b3V0T3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlMYXlvdXRPcHRpb25zID0gbmV3IFF1ZXJ5TGF5b3V0T3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEhpZGRlbkNsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IGhpZGRlbkNsYXNzZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHNUb0dlbmVyYXRlQ2xhc3Nlc09ubHk6IFtib29sZWFuLCBzdHJpbmddW10gPSBbXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbXBvbmVudHMgYXJlIGhhbmRsZWQgaW4gUXVlcnlSZW5kZXJlci50cyBhbmQgdGh1cyBhcmUgbm90IHBhcnQgb2YgdGhlIHNhbWUgZmxvdyB0aGF0XG4gICAgICAgICAgICAvLyBoaWRlcyBUYXNrTGF5b3V0Q29tcG9uZW50IGl0ZW1zLiBIb3dldmVyLCB3ZSBzdGlsbCB3YW50IHRvIGhhdmUgJ3Rhc2tzLWxheW91dC1oaWRlJyBpdGVtcyBmb3IgdGhlbVxuICAgICAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzE4NjYpLlxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gYmVuZWZpdCBmcm9tIHNvbWUgcmVmYWN0b3JpbmcsIGkuZS4gcmVuZGVyIHRoZXNlIGNvbXBvbmVudHMgaW4gYSBzaW1pbGFyIGZsb3cgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgIC8vIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICBbdGhpcy5xdWVyeUxheW91dE9wdGlvbnMuaGlkZVVyZ2VuY3ksICd1cmdlbmN5J10sXG4gICAgICAgICAgICBbdGhpcy5xdWVyeUxheW91dE9wdGlvbnMuaGlkZUJhY2tsaW5rcywgJ2JhY2tsaW5rcyddLFxuICAgICAgICAgICAgW3RoaXMucXVlcnlMYXlvdXRPcHRpb25zLmhpZGVFZGl0QnV0dG9uLCAnZWRpdC1idXR0b24nXSxcbiAgICAgICAgICAgIFt0aGlzLnF1ZXJ5TGF5b3V0T3B0aW9ucy5oaWRlUG9zdHBvbmVCdXR0b24sICdwb3N0cG9uZS1idXR0b24nXSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGlkZSwgY29tcG9uZW50XSBvZiBjb21wb25lbnRzVG9HZW5lcmF0ZUNsYXNzZXNPbmx5KSB7XG4gICAgICAgICAgICBnZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QoaGlkZGVuQ2xhc3NlcywgaGlkZSwgY29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5TGF5b3V0T3B0aW9ucy5zaG9ydE1vZGUpIGhpZGRlbkNsYXNzZXMucHVzaCgndGFza3MtbGF5b3V0LXNob3J0LW1vZGUnKTtcblxuICAgICAgICByZXR1cm4gaGlkZGVuQ2xhc3NlcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgR2xvYmFsUXVlcnkgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsUXVlcnknO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi9RdWVyeS9RdWVyeSc7XG5pbXBvcnQgeyBFeHBsYWluZXIgfSBmcm9tICcuLi9RdWVyeS9FeHBsYWluL0V4cGxhaW5lcic7XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgdXNlZCBieSB7QGxpbmsgUXVlcnlSZW5kZXJlcn0gdGhhdCBzaG91bGQgYWN0dWFsbHlcbiAqIGJlIGluIHRoYXQgZmlsZS4gQnV0IHRoZSBmaWxlIHtAbGluayBRdWVyeVJlbmRlcmVyfSBpcyBpbiBkZXBlbmRzIG9uIGRlcGVuZGVuY2llc1xuICogdGhhdCBhcmVuJ3QgYXZhaWxhYmxlIGR1cmluZyBhdXRvbWF0ZWQgdGVzdGluZywgYW5kIHdvdWxkIG1ha2UgaXQgaW1wb3NzaWJsZSB0byBydW5cbiAqIHRob3NlIHRlc3RzIG9uIHRoZSBjb2RlIHRoYXQgaXMgaW5zdGVhZCBob3VzZWQgaGVyZS5cbiAqL1xuXG4vKipcbiAqIEV4cGxhaW5zIGEgcXVlcnkgcmVuZGVyZWQgYnkge0BsaW5rIFF1ZXJ5UmVuZGVyZXJ9XG4gKlxuICogU3BlY2lmaWNhbGx5LCByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZzpcbiAqICAgICAqIEV4cGxhaW5zIHdoZXRoZXIgYSBnbG9iYWwgZmlsdGVyIGlzIGluIHVzZVxuICogICAgICogRXhwbGFpbnMgd2hldGhlciB0aGUgZ2xvYmFsIHF1ZXJ5IGlmIGl0J3MgaW4gdXNlXG4gKiAgICAgKiBFeHBsYWlucyB0aGUgcXVlcnkgZGVzY3JpYmVkIGJ5IHtAbGluayBzb3VyY2V9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIG9mIHRoZSB0YXNrIGJsb2NrIHRvIGV4cGxhaW5cbiAqIEBwYXJhbSB7R2xvYmFsRmlsdGVyfSBnbG9iYWxGaWx0ZXIgVGhlIGdsb2JhbCBmaWx0ZXIuIEluIGBzcmMvYCwgZ2VuZXJhbGx5IHBhc3MgaW4ge0BsaW5rIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZX1cbiAqIEBwYXJhbSB7R2xvYmFsUXVlcnl9IGdsb2JhbFF1ZXJ5IFRoZSBnbG9iYWwgcXVlcnkuIEluIGBzcmMvYCwgZ2VuZXJhbGx5IHBhc3MgaW4ge0BsaW5rIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlfVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSB0YXNrIGJsb2NrLCBpZiBrbm93blxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5SZXN1bHRzKFxuICAgIHNvdXJjZTogc3RyaW5nLFxuICAgIGdsb2JhbEZpbHRlcjogR2xvYmFsRmlsdGVyLFxuICAgIGdsb2JhbFF1ZXJ5OiBHbG9iYWxRdWVyeSxcbiAgICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIGlmICghZ2xvYmFsRmlsdGVyLmlzRW1wdHkoKSkge1xuICAgICAgICByZXN1bHQgKz0gYE9ubHkgdGFza3MgY29udGFpbmluZyB0aGUgZ2xvYmFsIGZpbHRlciAnJHtnbG9iYWxGaWx0ZXIuZ2V0KCl9Jy5cXG5cXG5gO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGxhaW5lciA9IG5ldyBFeHBsYWluZXIoJyAgJyk7XG4gICAgY29uc3QgdGFza3NCbG9ja1F1ZXJ5ID0gbmV3IFF1ZXJ5KHNvdXJjZSwgcGF0aCk7XG5cbiAgICBpZiAoIXRhc2tzQmxvY2tRdWVyeS5pZ25vcmVHbG9iYWxRdWVyeSkge1xuICAgICAgICBpZiAoZ2xvYmFsUXVlcnkuaGFzSW5zdHJ1Y3Rpb25zKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFF1ZXJ5UXVlcnkgPSBnbG9iYWxRdWVyeS5xdWVyeShwYXRoKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgRXhwbGFuYXRpb24gb2YgdGhlIGdsb2JhbCBxdWVyeTpcXG5cXG4ke2V4cGxhaW5lci5leHBsYWluUXVlcnkoZ2xvYmFsUXVlcnlRdWVyeSl9XFxuYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCArPSBgRXhwbGFuYXRpb24gb2YgdGhpcyBUYXNrcyBjb2RlIGJsb2NrIHF1ZXJ5OlxcblxcbiR7ZXhwbGFpbmVyLmV4cGxhaW5RdWVyeSh0YXNrc0Jsb2NrUXVlcnkpfWA7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGFjdHVhbCBxdWVyeSB0aGF0IHtAbGluayBRdWVyeVJlbmRlckNoaWxkfSB3aWxsIGFjdHVhbGx5IGV4ZWN1dGUgYWdhaW5zdCB0aGUgdGFzayBsaXN0LlxuICpcbiAqIFRoaXMgcXVlcnkgaXMgdGhlIHJlc3VsdCBvZiBqb2luaW5nIHRoZSBnbG9iYWwgcXVlcnkgd2l0aCB0aGUgcXVlcnkgaW4gdGhlIHRhc2sgYmxvY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBxdWVyeSBzb3VyY2UgZnJvbSB0aGUgdGFzayBibG9ja1xuICogQHBhcmFtIGdsb2JhbFF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZSBjb250YWluaW5nIHRoZSBxdWVyeSwgaWYgYXZhaWxhYmxlLlxuICogQHJldHVybnMge1F1ZXJ5fSBUaGUgcXVlcnkgdG8gZXhlY3V0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlGb3JRdWVyeVJlbmRlcmVyKHNvdXJjZTogc3RyaW5nLCBnbG9iYWxRdWVyeTogR2xvYmFsUXVlcnksIHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFF1ZXJ5IHtcbiAgICBjb25zdCB0YXNrc0Jsb2NrUXVlcnkgPSBuZXcgUXVlcnkoc291cmNlLCBwYXRoKTtcblxuICAgIGlmICh0YXNrc0Jsb2NrUXVlcnkuaWdub3JlR2xvYmFsUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRhc2tzQmxvY2tRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsUXVlcnkucXVlcnkocGF0aCkuYXBwZW5kKHRhc2tzQmxvY2tRdWVyeSk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQsIHVuaXRPZlRpbWUgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIH0gZnJvbSAnLi4vbGliL1N0cmluZ0hlbHBlcnMnO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi4vVGFzay9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gJy4uL1Rhc2svVGFzayc7XG5pbXBvcnQgeyBUYXNrc0RhdGUgfSBmcm9tICcuL1Rhc2tzRGF0ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRTaG93UG9zdHBvbmVCdXR0b24odGFzazogVGFzaykge1xuICAgIC8vIGRvbid0IHBvc3Rwb25lIGlmIGFueSBpbnZhbGlkIGRhdGVzXG4gICAgZm9yIChjb25zdCBkYXRlRmllbGQgb2YgVGFzay5hbGxEYXRlRmllbGRzKCkpIHtcbiAgICAgICAgY29uc3QgdGFza0VsZW1lbnQgPSB0YXNrW2RhdGVGaWVsZF0gYXMgTW9tZW50O1xuICAgICAgICBpZiAodGFza0VsZW1lbnQgJiYgIXRhc2tFbGVtZW50LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVxdWlyZSBhIHZhbGlkIGhhcHBlbnMgZGF0ZSB0byBwb3N0cG9uZVxuICAgIGNvbnN0IGhhc0FWYWxpZEhhcHBlbnNEYXRlID0gdGFzay5oYXBwZW5zRGF0ZXMuc29tZSgoZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gISFkYXRlPy5pc1ZhbGlkKCk7XG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHBvc3Rwb25lIG5vdCBkb25lIHRhc2tzXG4gICAgcmV0dXJuICF0YXNrLmlzRG9uZSAmJiBoYXNBVmFsaWRIYXBwZW5zRGF0ZTtcbn1cblxuZXhwb3J0IHR5cGUgSGFwcGVuc0RhdGUgPSBrZXlvZiBQaWNrPFRhc2ssICdzdGFydERhdGUnIHwgJ3NjaGVkdWxlZERhdGUnIHwgJ2R1ZURhdGUnPjtcblxuLyoqXG4gKiBHZXRzIGEge0BsaW5rIEhhcHBlbnNEYXRlfSBmaWVsZCBmcm9tIGEge0BsaW5rIFRhc2t9IHdpdGggdGhlIGZvbGxvd2luZyBwcmlvcml0eTogZHVlID4gc2NoZWR1bGVkID4gc3RhcnQuXG4gKiBJZiB0aGUgdGFzayBoYXMgbm8gaGFwcGVucyBmaWVsZCB7QGxpbmsgSGFwcGVuc0RhdGV9LCBudWxsIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB0YXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRlRmllbGRUb1Bvc3Rwb25lKHRhc2s6IFRhc2spOiBIYXBwZW5zRGF0ZSB8IG51bGwge1xuICAgIGlmICh0YXNrLmR1ZURhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkdWVEYXRlJztcbiAgICB9XG5cbiAgICBpZiAodGFzay5zY2hlZHVsZWREYXRlKSB7XG4gICAgICAgIHJldHVybiAnc2NoZWR1bGVkRGF0ZSc7XG4gICAgfVxuXG4gICAgaWYgKHRhc2suc3RhcnREYXRlKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnREYXRlJztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQb3N0cG9uZSBhIGRhdGUgdmFsdWUgaW4gYSB0YXNrIGEgY2VydGFpbiBudW1iZXIgb2YgaW5jcmVtZW50cyBmcm9tIHRoZSBmaWVsZCdzIGN1cnJlbnQgZGF0ZS5cbiAqIEBwYXJhbSB0YXNrXG4gKiBAcGFyYW0gZGF0ZUZpZWxkVG9Qb3N0cG9uZSAtIFRoZSBmaWVsZCB3aG9zZSB2YWx1ZSBpcyB0byBiZSBwb3N0cG9uZWRcbiAqIEBwYXJhbSB0aW1lVW5pdCAtIHRoZSBpbmNyZW1lbnQgdG8gcG9zdHBvbmUgYnkgKGRheSwgd2VlaywgbW9udGguLi4uKVxuICogQHBhcmFtIGFtb3VudCAtIHRoZSBudW1iZXIgb2YgdGltZVVuaXRzIHRvIGluY3JlbWVudCBieS5cbiAqXG4gKiBAc2VlIGNyZWF0ZUZpeGVkRGF0ZVRhc2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZFRhc2soXG4gICAgdGFzazogVGFzayxcbiAgICBkYXRlRmllbGRUb1Bvc3Rwb25lOiBIYXBwZW5zRGF0ZSxcbiAgICB0aW1lVW5pdDogdW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yLFxuICAgIGFtb3VudDogbnVtYmVyLFxuKSB7XG4gICAgY29uc3QgZGF0ZVRvUG9zdHBvbmUgPSB0YXNrW2RhdGVGaWVsZFRvUG9zdHBvbmVdO1xuICAgIHJldHVybiBjcmVhdGVQb3N0cG9uZWRUYXNrRnJvbURhdGUoZGF0ZVRvUG9zdHBvbmUsIHRhc2ssIGRhdGVGaWVsZFRvUG9zdHBvbmUsIHRpbWVVbml0LCBhbW91bnQpO1xufVxuXG4vKipcbiAqIFNldCBhIGRhdGUgdmFsdWUgaW4gYSB0YXNrIGEgY2VydGFpbiBudW1iZXIgb2YgaW5jcmVtZW50cyBmcm9tIHRvZGF5J3MgZGF0ZS5cbiAqIEBwYXJhbSB0YXNrXG4gKiBAcGFyYW0gZGF0ZUZpZWxkVG9Qb3N0cG9uZSAtIFRoZSBmaWVsZCB3aG9zZSB2YWx1ZSBpcyB0byBiZSBwb3N0cG9uZWRcbiAqIEBwYXJhbSB0aW1lVW5pdCAtIHRoZSBpbmNyZW1lbnQgdG8gcG9zdHBvbmUgYnkgKGRheSwgd2VlaywgbW9udGguLi4uKVxuICogQHBhcmFtIGFtb3VudCAtIHRoZSBudW1iZXIgb2YgdGltZVVuaXRzIHRvIGluY3JlbWVudCBieS5cbiAqXG4gKiBAc2VlIGNyZWF0ZVBvc3Rwb25lZFRhc2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpeGVkRGF0ZVRhc2soXG4gICAgdGFzazogVGFzayxcbiAgICBkYXRlRmllbGRUb1Bvc3Rwb25lOiBIYXBwZW5zRGF0ZSxcbiAgICB0aW1lVW5pdDogdW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yLFxuICAgIGFtb3VudDogbnVtYmVyLFxuKSB7XG4gICAgY29uc3QgZGF0ZVRvUG9zdHBvbmUgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBvc3Rwb25lZFRhc2tGcm9tRGF0ZShkYXRlVG9Qb3N0cG9uZSwgdGFzaywgZGF0ZUZpZWxkVG9Qb3N0cG9uZSwgdGltZVVuaXQsIGFtb3VudCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZFRhc2tGcm9tRGF0ZShcbiAgICBkYXRlVG9Qb3N0cG9uZTogbW9tZW50Lk1vbWVudCB8IG51bGwsXG4gICAgdGFzazogVGFzayxcbiAgICBkYXRlRmllbGRUb1Bvc3Rwb25lOiBIYXBwZW5zRGF0ZSxcbiAgICB0aW1lVW5pdDogdW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yLFxuICAgIGFtb3VudDogbnVtYmVyLFxuKSB7XG4gICAgY29uc3QgcG9zdHBvbmVkRGF0ZSA9IG5ldyBUYXNrc0RhdGUoZGF0ZVRvUG9zdHBvbmUpLnBvc3Rwb25lKHRpbWVVbml0LCBhbW91bnQpO1xuICAgIGNvbnN0IHBvc3Rwb25lZFRhc2sgPSBEYXRlRmFsbGJhY2sucmVtb3ZlSW5mZXJyZWRTdGF0dXNJZk5lZWRlZCh0YXNrLCBbXG4gICAgICAgIG5ldyBUYXNrKHtcbiAgICAgICAgICAgIC4uLnRhc2ssXG4gICAgICAgICAgICBbZGF0ZUZpZWxkVG9Qb3N0cG9uZV06IHBvc3Rwb25lZERhdGUsXG4gICAgICAgIH0pLFxuICAgIF0pWzBdO1xuICAgIHJldHVybiB7IHBvc3Rwb25lZERhdGUsIHBvc3Rwb25lZFRhc2sgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc3Rwb25lbWVudFN1Y2Nlc3NNZXNzYWdlKHBvc3Rwb25lZERhdGU6IE1vbWVudCwgZGF0ZUZpZWxkVG9Qb3N0cG9uZTogSGFwcGVuc0RhdGUpIHtcbiAgICAvLyBUT0RPIGFsbCBsb2dpYyBmb3IgaW52YWxpZCBkYXRlc1xuICAgIGNvbnN0IHBvc3Rwb25lZERhdGVTdHJpbmcgPSBwb3N0cG9uZWREYXRlPy5mb3JtYXQoJ0REIE1NTSBZWVlZJyk7XG4gICAgcmV0dXJuIGBUYXNrJ3MgJHtkYXRlRmllbGRUb1Bvc3Rwb25lfSBjaGFuZ2VkIHRvICR7cG9zdHBvbmVkRGF0ZVN0cmluZ31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHBvbmVCdXR0b25UaXRsZSh0YXNrOiBUYXNrLCBhbW91bnQ6IG51bWJlciwgdGltZVVuaXQ6IHVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGJ1dHRvblRleHQgPSBwb3N0cG9uZU1lbnVJdGVtVGl0bGUodGFzaywgYW1vdW50LCB0aW1lVW5pdCk7XG4gICAgcmV0dXJuIGBcdTIxMzlcdUZFMEYgJHtidXR0b25UZXh0fSAocmlnaHQtY2xpY2sgZm9yIG1vcmUgb3B0aW9ucylgO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWVudSB0ZXh0IHRvIHVzZSB3aGVuIGNoYW5naW5nIGEgdGFzayBkYXRlIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IHZhbHVlLlxuICogQHBhcmFtIHRhc2tcbiAqIEBwYXJhbSBhbW91bnQgLSB0aGUgbnVtYmVyIG9mIHRpbWVVbml0cyB0byBpbmNyZW1lbnQgYnkuXG4gKiBAcGFyYW0gdGltZVVuaXQgLSB0aGUgaW5jcmVtZW50IHRvIHBvc3Rwb25lIGJ5IChkYXksIHdlZWssIG1vbnRoLi4uLilcbiAqXG4gKiBAc2VlIGZpeGVkRGF0ZU1lbnVJdGVtVGl0bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3Rwb25lTWVudUl0ZW1UaXRsZSh0YXNrOiBUYXNrLCBhbW91bnQ6IG51bWJlciwgdGltZVVuaXQ6IHVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHVwZGF0ZWREYXRlVHlwZSA9IGdldERhdGVGaWVsZFRvUG9zdHBvbmUodGFzaykhO1xuICAgIGNvbnN0IGRhdGVUb1VwZGF0ZSA9IHRhc2tbdXBkYXRlZERhdGVUeXBlXSBhcyBNb21lbnQ7XG4gICAgcmV0dXJuIHBvc3Rwb25lTWVudUl0ZW1UaXRsZUZyb21EYXRlKHVwZGF0ZWREYXRlVHlwZSwgZGF0ZVRvVXBkYXRlLCBhbW91bnQsIHRpbWVVbml0KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1lbnUgdGV4dCB0byB1c2Ugd2hlbiBjaGFuZ2luZyBhIHRhc2sgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSdzIGRhdGUuXG4gKiBAcGFyYW0gdGFza1xuICogQHBhcmFtIGFtb3VudCAtIHRoZSBudW1iZXIgb2YgdGltZVVuaXRzIHRvIGluY3JlbWVudCBieS5cbiAqIEBwYXJhbSB0aW1lVW5pdCAtIHRoZSBpbmNyZW1lbnQgdG8gcG9zdHBvbmUgYnkgKGRheSwgd2VlaywgbW9udGguLi4uKVxuICpcbiAqIEBzZWUgcG9zdHBvbmVNZW51SXRlbVRpdGxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhlZERhdGVNZW51SXRlbVRpdGxlKHRhc2s6IFRhc2ssIGFtb3VudDogbnVtYmVyLCB0aW1lVW5pdDogdW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgdXBkYXRlZERhdGVUeXBlID0gZ2V0RGF0ZUZpZWxkVG9Qb3N0cG9uZSh0YXNrKSE7XG4gICAgY29uc3QgZGF0ZVRvVXBkYXRlID0gd2luZG93Lm1vbWVudCgpLnN0YXJ0T2YoJ2RheScpO1xuICAgIHJldHVybiBwb3N0cG9uZU1lbnVJdGVtVGl0bGVGcm9tRGF0ZSh1cGRhdGVkRGF0ZVR5cGUsIGRhdGVUb1VwZGF0ZSwgYW1vdW50LCB0aW1lVW5pdCk7XG59XG5cbmZ1bmN0aW9uIHBvc3Rwb25lTWVudUl0ZW1UaXRsZUZyb21EYXRlKFxuICAgIHVwZGF0ZWREYXRlVHlwZTogSGFwcGVuc0RhdGUsXG4gICAgZGF0ZVRvVXBkYXRlOiBtb21lbnQuTW9tZW50LFxuICAgIGFtb3VudDogbnVtYmVyLFxuICAgIHRpbWVVbml0OiB1bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IsXG4pIHtcbiAgICBjb25zdCBwb3N0cG9uZWREYXRlID0gbmV3IFRhc2tzRGF0ZShkYXRlVG9VcGRhdGUpLnBvc3Rwb25lKHRpbWVVbml0LCBhbW91bnQpO1xuICAgIGNvbnN0IGZvcm1hdHRlZE5ld0RhdGUgPSBwb3N0cG9uZWREYXRlLmZvcm1hdCgnZGRkIERvIE1NTScpO1xuXG4gICAgY29uc3QgYW1vdW50T3JBcnRpY2xlID0gYW1vdW50ICE9IDEgPyBhbW91bnQgOiAnYSc7XG4gICAgaWYgKGRhdGVUb1VwZGF0ZS5pc1NhbWVPckJlZm9yZSh3aW5kb3cubW9tZW50KCksICdkYXknKSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkRGF0ZURpc3BsYXlUZXh0ID0gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHVwZGF0ZWREYXRlVHlwZS5yZXBsYWNlKCdEYXRlJywgJycpKTtcbiAgICAgICAgcmV0dXJuIGAke3VwZGF0ZWREYXRlRGlzcGxheVRleHR9IGluICR7YW1vdW50T3JBcnRpY2xlfSAke3RpbWVVbml0fSwgb24gJHtmb3JtYXR0ZWROZXdEYXRlfWBcbiAgICAgICAgICAgIC5yZXBsYWNlKCcgaW4gMCBkYXlzJywgJyB0b2RheScpXG4gICAgICAgICAgICAucmVwbGFjZSgnaW4gYSBkYXknLCAndG9tb3Jyb3cnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB1cGRhdGVkRGF0ZURpc3BsYXlUZXh0ID0gdXBkYXRlZERhdGVUeXBlLnJlcGxhY2UoJ0RhdGUnLCAnIGRhdGUnKTtcbiAgICAgICAgcmV0dXJuIGBQb3N0cG9uZSAke3VwZGF0ZWREYXRlRGlzcGxheVRleHR9IGJ5ICR7YW1vdW50T3JBcnRpY2xlfSAke3RpbWVVbml0fSwgdG8gJHtmb3JtYXR0ZWROZXdEYXRlfWA7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGdlbmVyYXRlSGlkZGVuQ2xhc3NGb3JUYXNrTGlzdCB9IGZyb20gJy4vTGF5b3V0SGVscGVycyc7XG5pbXBvcnQgeyBUYXNrTGF5b3V0T3B0aW9ucyB9IGZyb20gJy4vVGFza0xheW91dE9wdGlvbnMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIGEgbGlzdCBvZiBoaWRkZW4gdGFzayBjb21wb25lbnRzJyBjbGFzc2VzLlxuICogVGhlIG91dHB1dCBkZXBlbmRzIG9uIHtAbGluayBUYXNrTGF5b3V0T3B0aW9uc30gb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tMYXlvdXQge1xuICAgIHByaXZhdGUgdGFza0xheW91dE9wdGlvbnM6IFRhc2tMYXlvdXRPcHRpb25zO1xuXG4gICAgY29uc3RydWN0b3IodGFza0xheW91dE9wdGlvbnM/OiBUYXNrTGF5b3V0T3B0aW9ucykge1xuICAgICAgICBpZiAodGFza0xheW91dE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudGFza0xheW91dE9wdGlvbnMgPSB0YXNrTGF5b3V0T3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFza0xheW91dE9wdGlvbnMgPSBuZXcgVGFza0xheW91dE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgZ2VuZXJhdGVIaWRkZW5DbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBoaWRkZW5DbGFzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICB0aGlzLnRhc2tMYXlvdXRPcHRpb25zLnRvZ2dsZWFibGVDb21wb25lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgZ2VuZXJhdGVIaWRkZW5DbGFzc0ZvclRhc2tMaXN0KGhpZGRlbkNsYXNzZXMsICF0aGlzLnRhc2tMYXlvdXRPcHRpb25zLmlzU2hvd24oY29tcG9uZW50KSwgY29tcG9uZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGFncyBhcmUgaGlkZGVuLCByYXRoZXIgdGhhbiByZW1vdmVkLiBTZWUgdGFza3MtbGF5b3V0LWhpZGUtdGFncyBpbiBzdHlsZXMuY3NzLlxuICAgICAgICBnZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QoaGlkZGVuQ2xhc3NlcywgIXRoaXMudGFza0xheW91dE9wdGlvbnMuYXJlVGFnc1Nob3duKCksICd0YWdzJyk7XG5cbiAgICAgICAgcmV0dXJuIGhpZGRlbkNsYXNzZXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IE1lbnVJdGVtLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IE1vbWVudCwgdW5pdE9mVGltZSB9IGZyb20gJ21vbWVudC9tb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzay9UYXNrJztcbmltcG9ydCB7XG4gICAgdHlwZSBIYXBwZW5zRGF0ZSxcbiAgICBjcmVhdGVGaXhlZERhdGVUYXNrLFxuICAgIGNyZWF0ZVBvc3Rwb25lZFRhc2ssXG4gICAgZml4ZWREYXRlTWVudUl0ZW1UaXRsZSxcbiAgICBnZXREYXRlRmllbGRUb1Bvc3Rwb25lLFxuICAgIHBvc3Rwb25lTWVudUl0ZW1UaXRsZSxcbiAgICBwb3N0cG9uZW1lbnRTdWNjZXNzTWVzc2FnZSxcbn0gZnJvbSAnLi4vLi4vU2NyaXB0aW5nL1Bvc3Rwb25lcic7XG5pbXBvcnQgeyBUYXNrRWRpdGluZ01lbnUsIHR5cGUgVGFza1NhdmVyLCBkZWZhdWx0VGFza1NhdmVyIH0gZnJvbSAnLi9UYXNrRWRpdGluZ01lbnUnO1xuXG50eXBlIE5hbWluZ0Z1bmN0aW9uID0gKHRhc2s6IFRhc2ssIGFtb3VudDogbnVtYmVyLCB0aW1lVW5pdDogdW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yKSA9PiBzdHJpbmc7XG5cbnR5cGUgUG9zdHBvbmluZ0Z1bmN0aW9uID0gKFxuICAgIHRhc2s6IFRhc2ssXG4gICAgZGF0ZUZpZWxkVG9Qb3N0cG9uZTogSGFwcGVuc0RhdGUsXG4gICAgdGltZVVuaXQ6IHVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3RvcixcbiAgICBhbW91bnQ6IG51bWJlcixcbikgPT4ge1xuICAgIHBvc3Rwb25lZERhdGU6IG1vbWVudC5Nb21lbnQ7XG4gICAgcG9zdHBvbmVkVGFzazogVGFzaztcbn07XG5cbmV4cG9ydCBjbGFzcyBQb3N0cG9uZU1lbnUgZXh0ZW5kcyBUYXNrRWRpdGluZ01lbnUge1xuICAgIGNvbnN0cnVjdG9yKGJ1dHRvbjogSFRNTEFuY2hvckVsZW1lbnQsIHRhc2s6IFRhc2ssIHRhc2tTYXZlcjogVGFza1NhdmVyID0gZGVmYXVsdFRhc2tTYXZlcikge1xuICAgICAgICBzdXBlcih0YXNrU2F2ZXIpO1xuXG4gICAgICAgIGNvbnN0IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayA9IChcbiAgICAgICAgICAgIGJ1dHRvbjogSFRNTEFuY2hvckVsZW1lbnQsXG4gICAgICAgICAgICBpdGVtOiBNZW51SXRlbSxcbiAgICAgICAgICAgIHRpbWVVbml0OiB1bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IsXG4gICAgICAgICAgICBhbW91bnQ6IG51bWJlcixcbiAgICAgICAgICAgIGl0ZW1OYW1pbmdGdW5jdGlvbjogTmFtaW5nRnVuY3Rpb24sXG4gICAgICAgICAgICBwb3N0cG9uaW5nRnVuY3Rpb246IFBvc3Rwb25pbmdGdW5jdGlvbixcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGl0ZW1OYW1pbmdGdW5jdGlvbih0YXNrLCBhbW91bnQsIHRpbWVVbml0KTtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2FsbCBzZXRDaGVja2VkKCkgdG8gcHV0IGEgY2hlY2ttYXJrIGFnYWluc3QgdGhlIGl0ZW0sIGlmIGl0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGFzayBmaWVsZCB2YWx1ZS5cbiAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUodGl0bGUpLm9uQ2xpY2soKCkgPT5cbiAgICAgICAgICAgICAgICBQb3N0cG9uZU1lbnUucG9zdHBvbmVPbkNsaWNrQ2FsbGJhY2soYnV0dG9uLCB0YXNrLCBhbW91bnQsIHRpbWVVbml0LCBwb3N0cG9uaW5nRnVuY3Rpb24sIHRhc2tTYXZlciksXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZpeGVkVGl0bGUgPSBmaXhlZERhdGVNZW51SXRlbVRpdGxlO1xuICAgICAgICBjb25zdCBmaXhlZERhdGVGdW5jdGlvbiA9IGNyZWF0ZUZpeGVkRGF0ZVRhc2s7XG4gICAgICAgIHRoaXMuYWRkSXRlbSgoaXRlbSkgPT4gcG9zdHBvbmVNZW51SXRlbUNhbGxiYWNrKGJ1dHRvbiwgaXRlbSwgJ2RheXMnLCAwLCBmaXhlZFRpdGxlLCBmaXhlZERhdGVGdW5jdGlvbikpO1xuICAgICAgICB0aGlzLmFkZEl0ZW0oKGl0ZW0pID0+IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayhidXR0b24sIGl0ZW0sICdkYXknLCAxLCBmaXhlZFRpdGxlLCBmaXhlZERhdGVGdW5jdGlvbikpO1xuXG4gICAgICAgIHRoaXMuYWRkU2VwYXJhdG9yKCk7XG5cbiAgICAgICAgY29uc3QgdGl0bGluZ0Z1bmN0aW9uID0gcG9zdHBvbmVNZW51SXRlbVRpdGxlO1xuICAgICAgICBjb25zdCBwb3N0cG9uaW5nRnVuY3Rpb24gPSBjcmVhdGVQb3N0cG9uZWRUYXNrO1xuICAgICAgICB0aGlzLmFkZEl0ZW0oKGl0ZW0pID0+IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayhidXR0b24sIGl0ZW0sICdkYXlzJywgMiwgdGl0bGluZ0Z1bmN0aW9uLCBwb3N0cG9uaW5nRnVuY3Rpb24pKTtcbiAgICAgICAgdGhpcy5hZGRJdGVtKChpdGVtKSA9PiBwb3N0cG9uZU1lbnVJdGVtQ2FsbGJhY2soYnV0dG9uLCBpdGVtLCAnZGF5cycsIDMsIHRpdGxpbmdGdW5jdGlvbiwgcG9zdHBvbmluZ0Z1bmN0aW9uKSk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSgoaXRlbSkgPT4gcG9zdHBvbmVNZW51SXRlbUNhbGxiYWNrKGJ1dHRvbiwgaXRlbSwgJ2RheXMnLCA0LCB0aXRsaW5nRnVuY3Rpb24sIHBvc3Rwb25pbmdGdW5jdGlvbikpO1xuICAgICAgICB0aGlzLmFkZEl0ZW0oKGl0ZW0pID0+IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayhidXR0b24sIGl0ZW0sICdkYXlzJywgNSwgdGl0bGluZ0Z1bmN0aW9uLCBwb3N0cG9uaW5nRnVuY3Rpb24pKTtcbiAgICAgICAgdGhpcy5hZGRJdGVtKChpdGVtKSA9PiBwb3N0cG9uZU1lbnVJdGVtQ2FsbGJhY2soYnV0dG9uLCBpdGVtLCAnZGF5cycsIDYsIHRpdGxpbmdGdW5jdGlvbiwgcG9zdHBvbmluZ0Z1bmN0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXBhcmF0b3IoKTtcblxuICAgICAgICB0aGlzLmFkZEl0ZW0oKGl0ZW0pID0+IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayhidXR0b24sIGl0ZW0sICd3ZWVrJywgMSwgdGl0bGluZ0Z1bmN0aW9uLCBwb3N0cG9uaW5nRnVuY3Rpb24pKTtcbiAgICAgICAgdGhpcy5hZGRJdGVtKChpdGVtKSA9PiBwb3N0cG9uZU1lbnVJdGVtQ2FsbGJhY2soYnV0dG9uLCBpdGVtLCAnd2Vla3MnLCAyLCB0aXRsaW5nRnVuY3Rpb24sIHBvc3Rwb25pbmdGdW5jdGlvbikpO1xuICAgICAgICB0aGlzLmFkZEl0ZW0oKGl0ZW0pID0+IHBvc3Rwb25lTWVudUl0ZW1DYWxsYmFjayhidXR0b24sIGl0ZW0sICd3ZWVrcycsIDMsIHRpdGxpbmdGdW5jdGlvbiwgcG9zdHBvbmluZ0Z1bmN0aW9uKSk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSgoaXRlbSkgPT4gcG9zdHBvbmVNZW51SXRlbUNhbGxiYWNrKGJ1dHRvbiwgaXRlbSwgJ21vbnRoJywgMSwgdGl0bGluZ0Z1bmN0aW9uLCBwb3N0cG9uaW5nRnVuY3Rpb24pKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHBvc3Rwb25lT25DbGlja0NhbGxiYWNrKFxuICAgICAgICBidXR0b246IEhUTUxBbmNob3JFbGVtZW50LFxuICAgICAgICB0YXNrOiBUYXNrLFxuICAgICAgICBhbW91bnQ6IG51bWJlcixcbiAgICAgICAgdGltZVVuaXQ6IHVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3RvcixcbiAgICAgICAgcG9zdHBvbmluZ0Z1bmN0aW9uOiBQb3N0cG9uaW5nRnVuY3Rpb24gPSBjcmVhdGVQb3N0cG9uZWRUYXNrLFxuICAgICAgICB0YXNrU2F2ZXI6IFRhc2tTYXZlciA9IGRlZmF1bHRUYXNrU2F2ZXIsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGRhdGVGaWVsZFRvUG9zdHBvbmUgPSBnZXREYXRlRmllbGRUb1Bvc3Rwb25lKHRhc2spO1xuICAgICAgICBpZiAoZGF0ZUZpZWxkVG9Qb3N0cG9uZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ1x1MjZBMFx1RkUwRiBQb3N0cG9uZW1lbnQgcmVxdWlyZXMgYSBkYXRlOiBkdWUsIHNjaGVkdWxlZCBvciBzdGFydC4nO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RpY2UoZXJyb3JNZXNzYWdlLCAxMDAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHBvc3Rwb25lZERhdGUsIHBvc3Rwb25lZFRhc2sgfSA9IHBvc3Rwb25pbmdGdW5jdGlvbih0YXNrLCBkYXRlRmllbGRUb1Bvc3Rwb25lLCB0aW1lVW5pdCwgYW1vdW50KTtcblxuICAgICAgICBhd2FpdCB0YXNrU2F2ZXIodGFzaywgcG9zdHBvbmVkVGFzayk7XG4gICAgICAgIFBvc3Rwb25lTWVudS5wb3N0cG9uZVN1Y2Nlc3NDYWxsYmFjayhidXR0b24sIGRhdGVGaWVsZFRvUG9zdHBvbmUsIHBvc3Rwb25lZERhdGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHBvc3Rwb25lU3VjY2Vzc0NhbGxiYWNrKFxuICAgICAgICBidXR0b246IEhUTUxBbmNob3JFbGVtZW50LFxuICAgICAgICB1cGRhdGVkRGF0ZVR5cGU6IEhhcHBlbnNEYXRlLFxuICAgICAgICBwb3N0cG9uZWREYXRlOiBNb21lbnQsXG4gICAgKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJ1dHRvbiB0byBwcmV2ZW50IHVwZGF0ZSBlcnJvciBkdWUgdG8gdGhlIHRhc2sgbm90IGJlaW5nIHJlbG9hZGVkIHlldC5cbiAgICAgICAgYnV0dG9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgY29uc3Qgc3VjY2Vzc01lc3NhZ2UgPSBwb3N0cG9uZW1lbnRTdWNjZXNzTWVzc2FnZShwb3N0cG9uZWREYXRlLCB1cGRhdGVkRGF0ZVR5cGUpO1xuICAgICAgICBuZXcgTm90aWNlKHN1Y2Nlc3NNZXNzYWdlLCAyMDAwKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgbWVhc3VyaW5nIHBlcmZvcm1hbmNlIG9mIGNvZGUsIGFuZCBhZGRpbmcgbGFiZWxzIGZvciBwcm9maWxpbmcuXG4gKlxuICogQHN1bW1hcnlcbiAqIFdoZW4gdGhlIHVzZXIgaGFzICoqZWRpdGVkIHRoZWlyIFRhc2tzIHBsdWdpbiBzZXR0aW5ncyB0byBzZXQgJ3JlY29yZFRpbWluZ3MnIHRvIHRydWUqKixcbiAqIHRoaXMgY2xhc3Mgd2lsbDpcbiAqICAtIG1lYXN1cmUgdGhlIGVsYXBzZWQgdGltZSB0YWtlbiBpbiBzZWN0aW9ucyBvZiBwZXJmb3JtYW5jZSBjcml0aWNhbCBjb2RlLFxuICogIC0gd3JpdGUgdGhlIGVsYXBzZWQgdGltZSB0byB0aGUgY29uc29sZSwgc2ltaWxhciB0byBgY29uc29sZS50aW1lKClgIGFuZCBgY29uc29sZS50aW1lRW5kKClgLFxuICogIC0gYWRkIG1hcmtpbmdzIHRvIHRoZSBUaW1pbmcgc2VjdGlvbiBvZiBwZXJmb3JtYW5jZSBmbGFtZSBjaGFydHMuXG4gKiBAZXhhbXBsZVxuICogIC8vIEhvdyB0byB1c2UgUGVyZm9ybWFuY2VUcmFja2VyOlxuICogIGNvbnN0IHRyYWNrZXIgPSBuZXcgUGVyZm9ybWFuY2VUcmFja2VyKCdzb21lIGRlc2NyaXB0aXZlIHRleHQnKTtcbiAqICB0cmFja2VyLnN0YXJ0KCk7XG4gKiAgLy8gLi4uIHNvbWUgc2xvdyBjb2RlXG4gKiAgdHJhY2tlci5maW5pc2goKTtcbiAqL1xuZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlVHJhY2tlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBsYWJlbDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IobGFiZWxGb3JQZXJmb3JtYW5jZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbEZvclBlcmZvcm1hbmNlO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVjb3JkVGltaW5ncygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKHRoaXMubGFiZWxGb3JTdGFydCgpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmluaXNoKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVjb3JkVGltaW5ncygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKHRoaXMubGFiZWxGb3JFbmQoKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZSB0aGUgdGltZSBiZXR3ZWVuIHRoZSBtYXJrc1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKHRoaXMubGFiZWwsIHRoaXMubGFiZWxGb3JTdGFydCgpLCB0aGlzLmxhYmVsRm9yRW5kKCkpO1xuICAgICAgICB0aGlzLnByaW50RHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByaW50RHVyYXRpb24oKSB7XG4gICAgICAgIC8vIEdldCBhbGwgZW50cmllcyBtYXRjaGluZyB0aGUgbmFtZSB0aGlzLmxhYmVsXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHRoaXMubGFiZWwpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBlbnRyeSwgaW4gY2FzZSB0aGUgb3BlcmF0aW9uIHdpdGggdGhpcyBsYWJlbCBoYXMgYmVlbiBydW4gbW9yZSB0aGFuIG9uY2UgdGhpcyBzZXNzaW9uLlxuICAgICAgICBjb25zdCBsYXN0RW50cnkgPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gTG9nIHRoZSBkdXJhdGlvbiB0byB0aGUgY29uc29sZVxuICAgICAgICBpZiAobGFzdEVudHJ5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmxhYmVsICsgJzonLCBsYXN0RW50cnkuZHVyYXRpb24sICdtaWxsaXNlY29uZHMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNZWFzdXJlbWVudCBmb3IgJHt0aGlzLmxhYmVsfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbGFiZWxGb3JTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9IC0gc3RhcnRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgbGFiZWxGb3JFbmQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfSAtIGVuZGA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWNvcmRUaW1pbmdzKCkge1xuICAgICAgICBjb25zdCB7IGRlYnVnU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBkZWJ1Z1NldHRpbmdzLnJlY29yZFRpbWluZ3M7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgZGVib3VuY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSBUYXNrc1BsdWdpbiBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzJztcbmltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbiB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c0NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgY3JlYXRlU3RhdHVzUmVnaXN0cnlSZXBvcnQgfSBmcm9tICcuLi9TdGF0dXNlcy9TdGF0dXNSZWdpc3RyeVJlcG9ydCc7XG5pbXBvcnQgKiBhcyBUaGVtZXMgZnJvbSAnLi9UaGVtZXMnO1xuaW1wb3J0IHsgdHlwZSBIZWFkaW5nU3RhdGUsIFRBU0tfRk9STUFUUyB9IGZyb20gJy4vU2V0dGluZ3MnO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIGlzRmVhdHVyZUVuYWJsZWQsIHVwZGF0ZUdlbmVyYWxTZXR0aW5nLCB1cGRhdGVTZXR0aW5ncyB9IGZyb20gJy4vU2V0dGluZ3MnO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgU3RhdHVzU2V0dGluZ3MgfSBmcm9tICcuL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCBzZXR0aW5nc0pzb24gZnJvbSAnLi9zZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbic7XG5cbmltcG9ydCB7IEN1c3RvbVN0YXR1c01vZGFsIH0gZnJvbSAnLi9DdXN0b21TdGF0dXNNb2RhbCc7XG5pbXBvcnQgeyBHbG9iYWxRdWVyeSB9IGZyb20gJy4vR2xvYmFsUXVlcnknO1xuXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICAvLyBJZiB0aGUgVUkgbmVlZHMgYSBtb3JlIGNvbXBsZXggc2V0dGluZyB5b3UgY2FuIGNyZWF0ZSBhXG4gICAgLy8gY3VzdG9tIGZ1bmN0aW9uIGFuZCBzcGVjaWZ5IGl0IGZyb20gdGhlIGpzb24gZmlsZS4gSXQgd2lsbFxuICAgIC8vIHRoZW4gYmUgcmVuZGVyZWQgaW5zdGVhZCBvZiBhIG5vcm1hbCBjaGVja2JveCBvciB0ZXh0IGJveC5cbiAgICBjdXN0b21GdW5jdGlvbnM6IHsgW0s6IHN0cmluZ106IEZ1bmN0aW9uIH0gPSB7XG4gICAgICAgIGluc2VydFRhc2tDb3JlU3RhdHVzU2V0dGluZ3M6IHRoaXMuaW5zZXJ0VGFza0NvcmVTdGF0dXNTZXR0aW5ncy5iaW5kKHRoaXMpLFxuICAgICAgICBpbnNlcnRDdXN0b21UYXNrU3RhdHVzU2V0dGluZ3M6IHRoaXMuaW5zZXJ0Q3VzdG9tVGFza1N0YXR1c1NldHRpbmdzLmJpbmQodGhpcyksXG4gICAgfTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGx1Z2luOiBUYXNrc1BsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKHsgcGx1Z2luIH06IHsgcGx1Z2luOiBUYXNrc1BsdWdpbiB9KSB7XG4gICAgICAgIHN1cGVyKHBsdWdpbi5hcHAsIHBsdWdpbik7XG5cbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlRnJhZ21lbnRXaXRoSFRNTCA9IChodG1sOiBzdHJpbmcpID0+XG4gICAgICAgIGNyZWF0ZUZyYWdtZW50KChkb2N1bWVudEZyYWdtZW50KSA9PiAoZG9jdW1lbnRGcmFnbWVudC5jcmVhdGVEaXYoKS5pbm5lckhUTUwgPSBodG1sKSk7XG5cbiAgICBwdWJsaWMgYXN5bmMgc2F2ZVNldHRpbmdzKHVwZGF0ZT86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmFkZENsYXNzKCd0YXNrcy1zZXR0aW5ncycpO1xuXG4gICAgICAgIC8vIEZvciByZWFzb25zIEkgZG9uJ3QgdW5kZXJzdGFuZCwgJ2gyJyBpcyB0aW55IGluIFNldHRpbmdzLFxuICAgICAgICAvLyBzbyBJIGhhdmUgdXNlZCAnaDMnIGFzIHRoZSBsYXJnZXN0IGhlYWRpbmcuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1Rhc2tzIFNldHRpbmdzJyB9KTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICBjbHM6ICd0YXNrcy1zZXR0aW5nLWltcG9ydGFudCcsXG4gICAgICAgICAgICB0ZXh0OiAnQ2hhbmdpbmcgYW55IHNldHRpbmdzIHJlcXVpcmVzIGEgcmVzdGFydCBvZiBvYnNpZGlhbi4nLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnVGFzayBGb3JtYXQgU2V0dGluZ3MnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXNrIEZvcm1hdCcpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnPHA+VGhlIGZvcm1hdCB0aGF0IFRhc2tzIHVzZXMgdG8gcmVhZCBhbmQgd3JpdGUgdGFza3MuPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPjxiPkltcG9ydGFudDo8L2I+IFRhc2tzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIG9uZSBmb3JtYXQgYXQgYSB0aW1lLiBTZWxlY3RpbmcgRGF0YXZpZXcgd2lsbCBjdXJyZW50bHkgPGI+c3RvcCBUYXNrcyByZWFkaW5nIGl0cyBvd24gZW1vamkgc2lnbmlmaWVyczwvYj4uPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9SZWZlcmVuY2UvVGFzaytGb3JtYXRzL0Fib3V0K1Rhc2srRm9ybWF0c1wiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoVEFTS19GT1JNQVRTKSBhcyAoa2V5b2YgVEFTS19GT1JNQVRTKVtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbihrZXksIFRBU0tfRk9STUFUU1trZXldLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZShnZXRTZXR0aW5ncygpLnRhc2tGb3JtYXQpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IHRhc2tGb3JtYXQ6IHZhbHVlIGFzIGtleW9mIFRBU0tfRk9STUFUUyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnR2xvYmFsIGZpbHRlciBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0dsb2JhbCB0YXNrIGZpbHRlcicpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnPHA+PGI+UmVjb21tZW5kZWQ6IExlYXZlIGVtcHR5IGlmIHlvdSB3YW50IGFsbCBjaGVja2xpc3QgaXRlbXMgaW4geW91ciB2YXVsdCB0byBiZSB0YXNrcyBtYW5hZ2VkIGJ5IHRoaXMgcGx1Z2luLjwvYj48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+VXNlIGEgZ2xvYmFsIGZpbHRlciBpZiB5b3Ugd2FudCBUYXNrcyB0byBvbmx5IGFjdCBvbiBhIHN1YnNldCBvZiB5b3VyIFwiPGNvZGU+LSBbIF08L2NvZGU+XCIgY2hlY2tsaXN0IGl0ZW1zLCBzbyB0aGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2EgY2hlY2tsaXN0IGl0ZW0gbXVzdCBpbmNsdWRlIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGluIGl0cyBkZXNjcmlwdGlvbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGEgdGFzay48cD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5Gb3IgZXhhbXBsZSwgaWYgeW91IHNldCB0aGUgZ2xvYmFsIGZpbHRlciB0byA8Y29kZT4jdGFzazwvY29kZT4sIHRoZSBUYXNrcyBwbHVnaW4gd2lsbCBvbmx5IGhhbmRsZSBjaGVja2xpc3QgaXRlbXMgdGFnZ2VkIHdpdGggPGNvZGU+I3Rhc2s8L2NvZGU+LjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3RoZXIgY2hlY2tsaXN0IGl0ZW1zIHdpbGwgcmVtYWluIG5vcm1hbCBjaGVja2xpc3QgaXRlbXMgYW5kIG5vdCBhcHBlYXIgaW4gcXVlcmllcyBvciBnZXQgYSBkb25lIGRhdGUgc2V0LjwvcD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0dsb2JhbCtGaWx0ZXJcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJIHdhbnRlZCB0byBtYWtlIHRoaXMgc2F5ICdmb3IgZXhhbXBsZSwgI3Rhc2sgb3IgVE9ETydcbiAgICAgICAgICAgICAgICAvLyBidXQgd2Fzbid0IGFibGUgdG8gZmlndXJlIG91dCBob3cgdG8gbWFrZSB0aGUgdGV4dCBib3hcbiAgICAgICAgICAgICAgICAvLyB3aWRlIGVub3VnaCBmb3IgdGhlIHdob2xlIHN0cmluZyB0byBiZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ2UuZy4gI3Rhc2sgb3IgVE9ETycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5nZXQoKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBnbG9iYWxGaWx0ZXI6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JlbW92ZSBnbG9iYWwgZmlsdGVyIGZyb20gZGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0VuYWJsaW5nIHRoaXMgcmVtb3ZlcyB0aGUgc3RyaW5nIHRoYXQgeW91IHNldCBhcyBnbG9iYWwgZmlsdGVyIGZyb20gdGhlIHRhc2sgZGVzY3JpcHRpb24gd2hlbiBkaXNwbGF5aW5nIGEgdGFzay4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnJlbW92ZUdsb2JhbEZpbHRlcikub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgcmVtb3ZlR2xvYmFsRmlsdGVyOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuc2V0UmVtb3ZlR2xvYmFsRmlsdGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnR2xvYmFsIFF1ZXJ5JyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbWFrZU11bHRpbGluZVRleHRTZXR0aW5nKFxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+QSBxdWVyeSB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgaW5jbHVkZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IFRhc2tzIGJsb2NrIGluIHRoZSB2YXVsdC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFVzZWZ1bCBmb3IgYWRkaW5nIGRlZmF1bHQgZmlsdGVycywgb3IgbGF5b3V0IG9wdGlvbnMuPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvUXVlcmllcy9HbG9iYWwrUXVlcnlcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwucm93cyA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJyMgRm9yIGV4YW1wbGUuLi5cXG5wYXRoIGRvZXMgbm90IGluY2x1ZGUgX3RlbXBsYXRlcy9cXG5saW1pdCAzMDBcXG5zaG93IHVyZ2VuY3knKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmdsb2JhbFF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgZ2xvYmFsUXVlcnk6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCkuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdUYXNrIFN0YXR1c2VzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBoZWFkaW5nT3BlbmVkIH0gPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgIHNldHRpbmdzSnNvbi5mb3JFYWNoKChoZWFkaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9uZVNldHRpbmdzQmxvY2soY29udGFpbmVyRWwsIGhlYWRpbmcsIGhlYWRpbmdPcGVuZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnRGF0ZSBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NldCBjcmVhdGVkIGRhdGUgb24gZXZlcnkgYWRkZWQgdGFzaycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICBcIkVuYWJsaW5nIHRoaXMgd2lsbCBhZGQgYSB0aW1lc3RhbXAgXHUyNzk1IFlZWVktTU0tREQgYmVmb3JlIG90aGVyIGRhdGUgdmFsdWVzLCB3aGVuIGEgdGFzayBpcyBjcmVhdGVkIHdpdGggJ0NyZWF0ZSBvciBlZGl0IHRhc2snLCBvciBieSBjb21wbGV0aW5nIGEgcmVjdXJyaW5nIHRhc2suPC9icj5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL0dldHRpbmcrU3RhcnRlZC9EYXRlcyNDcmVhdGVkK2RhdGVcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5zZXRDcmVhdGVkRGF0ZSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgc2V0Q3JlYXRlZERhdGU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NldCBkb25lIGRhdGUgb24gZXZlcnkgY29tcGxldGVkIHRhc2snKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgJ0VuYWJsaW5nIHRoaXMgd2lsbCBhZGQgYSB0aW1lc3RhbXAgXHUyNzA1IFlZWVktTU0tREQgYXQgdGhlIGVuZCB3aGVuIGEgdGFzayBpcyB0b2dnbGVkIHRvIGRvbmUuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0RhdGVzI0RvbmUrZGF0ZVwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnNldERvbmVEYXRlKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBzZXREb25lRGF0ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU2V0IGNhbmNlbGxlZCBkYXRlIG9uIGV2ZXJ5IGNhbmNlbGxlZCB0YXNrJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICdFbmFibGluZyB0aGlzIHdpbGwgYWRkIGEgdGltZXN0YW1wIFx1Mjc0QyBZWVlZLU1NLUREIGF0IHRoZSBlbmQgd2hlbiBhIHRhc2sgaXMgdG9nZ2xlZCB0byBjYW5jZWxsZWQuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0RhdGVzI0NhbmNlbGxlZCtkYXRlXCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3Muc2V0Q2FuY2VsbGVkRGF0ZSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgc2V0Q2FuY2VsbGVkRGF0ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlIGZpbGVuYW1lIGFzIFNjaGVkdWxlZCBkYXRlIGZvciB1bmRhdGVkIHRhc2tzJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICdTYXZlIHRpbWUgZW50ZXJpbmcgU2NoZWR1bGVkIChcdTIzRjMpIGRhdGVzLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnSWYgdGhpcyBvcHRpb24gaXMgZW5hYmxlZCwgYW55IHVuZGF0ZWQgdGFza3Mgd2lsbCBiZSBnaXZlbiBhIGRlZmF1bHQgU2NoZWR1bGVkIGRhdGUgZXh0cmFjdGVkIGZyb20gdGhlaXIgZmlsZSBuYW1lLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGRhdGUgaW4gdGhlIGZpbGUgbmFtZSBtdXN0IGJlIGluIG9uZSBvZiA8Y29kZT5ZWVlZLU1NLUREPC9jb2RlPiBvciA8Y29kZT5ZWVlZTU1ERDwvY29kZT4gZm9ybWF0cy48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZGF0ZWQgdGFza3MgaGF2ZSBub25lIG9mIER1ZSAoXHVEODNEXHVEQ0M1ICksIFNjaGVkdWxlZCAoXHUyM0YzKSBhbmQgU3RhcnQgKFx1RDgzRFx1REVFQikgZGF0ZXMuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL1VzZStGaWxlbmFtZSthcytEZWZhdWx0K0RhdGVcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy51c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgdXNlRmlsZW5hbWVBc1NjaGVkdWxlZERhdGU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ZvbGRlcnMgd2l0aCBkZWZhdWx0IFNjaGVkdWxlZCBkYXRlcycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnTGVhdmUgZW1wdHkgaWYgeW91IHdhbnQgdG8gdXNlIGRlZmF1bHQgU2NoZWR1bGVkIGRhdGVzIGV2ZXJ5d2hlcmUsIG9yIGVudGVyIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZm9sZGVycy4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRleHQoYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTZXR0aW5nc1RhYi5yZW5kZXJGb2xkZXJBcnJheShzZXR0aW5ncy5maWxlbmFtZUFzRGF0ZUZvbGRlcnMpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2xkZXJzID0gU2V0dGluZ3NUYWIucGFyc2VDb21tYVNlcGFyYXRlZEZvbGRlcnModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBmaWxlbmFtZUFzRGF0ZUZvbGRlcnM6IGZvbGRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnUmVjdXJyaW5nIHRhc2sgU2V0dGluZ3MnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdOZXh0IHJlY3VycmVuY2UgYXBwZWFycyBvbiB0aGUgbGluZSBiZWxvdycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnRW5hYmxpbmcgdGhpcyB3aWxsIG1ha2UgdGhlIG5leHQgcmVjdXJyZW5jZSBvZiBhIHRhc2sgYXBwZWFyIG9uIHRoZSBsaW5lIGJlbG93IHRoZSBjb21wbGV0ZWQgdGFzay4gT3RoZXJ3aXNlIHRoZSBuZXh0IHJlY3VycmVuY2Ugd2lsbCBhcHBlYXIgYmVmb3JlIHRoZSBjb21wbGV0ZWQgb25lLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL0dldHRpbmcrU3RhcnRlZC9SZWN1cnJpbmcrVGFza3NcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWN1cnJlbmNlT25OZXh0TGluZTogcmVjdXJyZW5jZU9uTmV4dExpbmUgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHJlY3VycmVuY2VPbk5leHRMaW5lKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyByZWN1cnJlbmNlT25OZXh0TGluZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0F1dG8tc3VnZ2VzdCBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tc3VnZ2VzdCB0YXNrIGNvbnRlbnQnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgJ0VuYWJsaW5nIHRoaXMgd2lsbCBvcGVuIGFuIGludGVsbGlnZW50IHN1Z2dlc3QgbWVudSB3aGlsZSB0eXBpbmcgaW5zaWRlIGEgcmVjb2duaXplZCB0YXNrIGxpbmUuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0F1dG8tU3VnZ2VzdFwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLmF1dG9TdWdnZXN0SW5FZGl0b3IpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGF1dG9TdWdnZXN0SW5FZGl0b3I6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ01pbmltdW0gbWF0Y2ggbGVuZ3RoIGZvciBhdXRvLXN1Z2dlc3QnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0lmIGhpZ2hlciB0aGFuIDAsIGF1dG8tc3VnZ2VzdCB3aWxsIGJlIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIGJlZ2lubmluZyBvZiBhbnkgc3VwcG9ydGVkIGtleXdvcmRzIGlzIHJlY29nbml6ZWQuJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoKHNsaWRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldExpbWl0cygwLCAzLCAxKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaClcbiAgICAgICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBhdXRvU3VnZ2VzdE1pbk1hdGNoOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ01heGltdW0gbnVtYmVyIG9mIGF1dG8tc3VnZ2VzdGlvbnMgdG8gc2hvdycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnSG93IG1hbnkgc3VnZ2VzdGlvbnMgc2hvdWxkIGJlIHNob3duIHdoZW4gYW4gYXV0by1zdWdnZXN0IG1lbnUgcG9wcyB1cCAoaW5jbHVkaW5nIHRoZSBcIlx1MjNDRVwiIG9wdGlvbikuJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoKHNsaWRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldExpbWl0cygzLCAxMiwgMSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgYXV0b1N1Z2dlc3RNYXhJdGVtczogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnRGlhbG9nIFNldHRpbmdzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvdmlkZSBhY2Nlc3Mga2V5cyBpbiBkaWFsb2dzJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICdJZiB0aGUgYWNjZXNzIGtleXMgKGtleWJvYXJkIHNob3J0Y3V0cykgZm9yIHZhcmlvdXMgY29udHJvbHMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgaW4gZGlhbG9nIGJveGVzIGNvbmZsaWN0IHdpdGggc3lzdGVtIGtleWJvYXJkIHNob3J0Y3V0cycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBvciBhc3Npc3RpdmUgdGVjaG5vbG9neSBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgaW1wb3J0YW50IGZvciB5b3UsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHlvdSBtYXkgd2FudCB0byBkZWFjdGl2YXRlIHRoZW0gaGVyZS48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvQ3JlYXRlK29yK2VkaXQrVGFzayNLZXlib2FyZCtzaG9ydGN1dHNcIj5kb2N1bWVudGF0aW9uPC9hPi48L3A+JyxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5wcm92aWRlQWNjZXNzS2V5cykub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgcHJvdmlkZUFjY2Vzc0tleXM6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkT25lU2V0dGluZ3NCbG9jayhjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIGhlYWRpbmc6IGFueSwgaGVhZGluZ09wZW5lZDogSGVhZGluZ1N0YXRlKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGV0YWlscycsIHtcbiAgICAgICAgICAgIGNsczogJ3Rhc2tzLW5lc3RlZC1zZXR0aW5ncycsXG4gICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgLi4uKGhlYWRpbmcub3BlbiB8fCBoZWFkaW5nT3BlbmVkW2hlYWRpbmcudGV4dF0gPyB7IG9wZW46IHRydWUgfSA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBkZXRhaWxzQ29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgIGRldGFpbHNDb250YWluZXIub250b2dnbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBoZWFkaW5nT3BlbmVkW2hlYWRpbmcudGV4dF0gPSBkZXRhaWxzQ29udGFpbmVyLm9wZW47XG4gICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGhlYWRpbmdPcGVuZWQ6IGhlYWRpbmdPcGVuZWQgfSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VtbWFyeSA9IGRldGFpbHNDb250YWluZXIuY3JlYXRlRWwoJ3N1bW1hcnknKTtcbiAgICAgICAgbmV3IFNldHRpbmcoc3VtbWFyeSkuc2V0SGVhZGluZygpLnNldE5hbWUoaGVhZGluZy50ZXh0KTtcbiAgICAgICAgc3VtbWFyeS5jcmVhdGVEaXYoJ2NvbGxhcHNlcicpLmNyZWF0ZURpdignaGFuZGxlJyk7XG5cbiAgICAgICAgLy8gZGV0YWlsc0NvbnRhaW5lci5jcmVhdGVFbChoZWFkaW5nLmxldmVsIGFzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcCwgeyB0ZXh0OiBoZWFkaW5nLnRleHQgfSk7XG5cbiAgICAgICAgaWYgKGhlYWRpbmcubm90aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBub3RpY2UgPSBkZXRhaWxzQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBoZWFkaW5nLm5vdGljZS5jbGFzcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBoZWFkaW5nLm5vdGljZS50ZXh0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGVhZGluZy5ub3RpY2UuaHRtbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vdGljZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGhlYWRpbmcubm90aWNlLmh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHRoZSBzZXR0aW5ncyBmcm9tIHNldHRpbmdzQ29uZmlndXJhdGlvbi5qc29uIGFuZCByZW5kZXJcbiAgICAgICAgLy8gdGhlbSBvdXQgcmVkdWNpbmcgdGhlIGR1cGxpY2F0aW9uIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZS4gVGhpcyB3aWxsIGJlY29tZVxuICAgICAgICAvLyBtb3JlIGltcG9ydGFudCBhcyBmZWF0dXJlcyBhcmUgYmVpbmcgYWRkZWQgb3ZlciB0aW1lLlxuICAgICAgICBoZWFkaW5nLnNldHRpbmdzLmZvckVhY2goKHNldHRpbmc6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmcuZmVhdHVyZUZsYWcgIT09ICcnICYmICFpc0ZlYXR1cmVFbmFibGVkKHNldHRpbmcuZmVhdHVyZUZsYWcpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIGNvbmZpZ3VyYXRpb24gaGFzIGEgZmVhdHVyZUZsYWcgc2V0IGFuZCB0aGUgdXNlciBoYXMgbm90XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlZCBpdC4gU2tpcCBhZGRpbmcgdGhlIHNldHRpbmdzIG9wdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZy50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZGV0YWlsc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoc2V0dGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYyhzZXR0aW5nLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNldHRpbmcoc2V0dGluZy5zZXR0aW5nTmFtZSwgc2V0dGluZy5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKDxib29sZWFuPnNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1tzZXR0aW5nLnNldHRpbmdOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdlbmVyYWxTZXR0aW5nKHNldHRpbmcuc2V0dGluZ05hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5nLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGRldGFpbHNDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKHNldHRpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2Moc2V0dGluZy5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNldHRpbmcoc2V0dGluZy5zZXR0aW5nTmFtZSwgc2V0dGluZy5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNldHRpbmcoc2V0dGluZy5zZXR0aW5nTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcihzZXR0aW5nLnBsYWNlaG9sZGVyLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1tzZXR0aW5nLnNldHRpbmdOYW1lXS50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShkZWJvdW5jZShvbkNoYW5nZSwgNTAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5nLnR5cGUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhkZXRhaWxzQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZShzZXR0aW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKHNldHRpbmcuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCBzZXR0aW5nLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKHNldHRpbmcucGxhY2Vob2xkZXIudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGRlYm91bmNlKG9uQ2hhbmdlLCA1MDAsIHRydWUpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnJvd3MgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLmNvbHMgPSA0MDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRnVuY3Rpb25zW3NldHRpbmcuc2V0dGluZ05hbWVdKGRldGFpbHNDb250YWluZXIsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZy5ub3RpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RpY2UgPSBkZXRhaWxzQ29udGFpbmVyLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IHNldHRpbmcubm90aWNlLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzZXR0aW5nLm5vdGljZS50ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm5vdGljZS5odG1sICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGljZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHNldHRpbmcubm90aWNlLmh0bWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VDb21tYVNlcGFyYXRlZEZvbGRlcnMoaW5wdXQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgLy8gYSBsaW1pdGF0aW9uIGlzIHRoYXQgZm9sZGVyIG5hbWVzIG1heSBub3QgY29udGFpbiBjb21tYXNcbiAgICAgICAgICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAgICAgICAgIC5tYXAoKGZvbGRlcikgPT4gZm9sZGVyLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICAgICAgICAgIC5tYXAoKGZvbGRlcikgPT4gZm9sZGVyLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZm9sZGVyKSA9PiBmb2xkZXIgIT09ICcnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHJlbmRlckZvbGRlckFycmF5KGZvbGRlcnM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGZvbGRlcnMuam9pbignLCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHRpbmdzIGZvciBDb3JlIFRhc2sgU3RhdHVzXG4gICAgICogVGhlc2UgYXJlIGJ1aWx0LWluIHN0YXR1c2VzIHRoYXQgY2FuIGhhdmUgbWluaW1hbCBlZGl0cyBtYWRlLFxuICAgICAqIGJ1dCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZGVsZXRlZCBvciBhZGRlZCB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lckVsXG4gICAgICogQHBhcmFtIHtTZXR0aW5nc1RhYn0gc2V0dGluZ3NcbiAgICAgKiBAbWVtYmVyb2YgU2V0dGluZ3NUYWJcbiAgICAgKi9cbiAgICBpbnNlcnRUYXNrQ29yZVN0YXR1c1NldHRpbmdzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc2V0dGluZ3M6IFNldHRpbmdzVGFiKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gT25lIHJvdyBwZXIgY29yZSBzdGF0dXMgaW4gdGhlIHNldHRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIHN0YXR1c1NldHRpbmdzLmNvcmVTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXNfdHlwZSkgPT4ge1xuICAgICAgICAgICAgY3JlYXRlUm93Rm9yVGFza1N0YXR1cyhcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbCxcbiAgICAgICAgICAgICAgICBzdGF0dXNfdHlwZSxcbiAgICAgICAgICAgICAgICBzdGF0dXNTZXR0aW5ncy5jb3JlU3RhdHVzZXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luLFxuICAgICAgICAgICAgICAgIHRydWUsIC8vIGlzQ29yZVN0YXR1c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gJ1JldmlldyBhbmQgY2hlY2sgeW91ciBTdGF0dXNlcycgYnV0dG9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IGNyZWF0ZU1lcm1haWREaWFncmFtID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidXR0b25OYW1lID0gJ1JldmlldyBhbmQgY2hlY2sgeW91ciBTdGF0dXNlcyc7XG4gICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChidXR0b25OYW1lKVxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZmlsZSB1bmlxdWUgZmlsZSBuYW1lLCBpbiB0aGUgcm9vdCBvZiB0aGUgdmF1bHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gd2luZG93Lm1vbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlVGltZSA9IG5vdy5mb3JtYXQoJ1lZWVktTU0tREQgSEgtbW0tc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBgVGFza3MgUGx1Z2luIC0gJHtidXR0b25OYW1lfSAke2Zvcm1hdHRlZERhdGVUaW1lfS5tZGA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c1JlZ2lzdHJ5ID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBjcmVhdGVTdGF0dXNSZWdpc3RyeVJlcG9ydChzdGF0dXNTZXR0aW5ncywgc3RhdHVzUmVnaXN0cnksIGJ1dHRvbk5hbWUsIHZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGFwcC52YXVsdC5jcmVhdGUoZmlsZW5hbWUsIGZpbGVDb250ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgb3BlbiB0aGUgbmV3IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnV0dG9uLnNldFRvb2x0aXAoXG4gICAgICAgICAgICAgICAgJ0NyZWF0ZSBhIG5ldyBmaWxlIGluIHRoZSByb290IG9mIHRoZSB2YXVsdCwgY29udGFpbmluZyBhIE1lcm1haWQgZGlhZ3JhbSBvZiB0aGUgY3VycmVudCBzdGF0dXMgc2V0dGluZ3MuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVNZXJtYWlkRGlhZ3JhbS5pbmZvRWwucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGluZ3MgZm9yIEN1c3RvbSBUYXNrIFN0YXR1c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyRWxcbiAgICAgKiBAcGFyYW0ge1NldHRpbmdzVGFifSBzZXR0aW5nc1xuICAgICAqIEBtZW1iZXJvZiBTZXR0aW5nc1RhYlxuICAgICAqL1xuICAgIGluc2VydEN1c3RvbVRhc2tTdGF0dXNTZXR0aW5ncyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHNldHRpbmdzOiBTZXR0aW5nc1RhYikge1xuICAgICAgICBjb25zdCB7IHN0YXR1c1NldHRpbmdzIH0gPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIE9uZSByb3cgcGVyIGN1c3RvbSBzdGF0dXMgaW4gdGhlIHNldHRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLmZvckVhY2goKHN0YXR1c190eXBlKSA9PiB7XG4gICAgICAgICAgICBjcmVhdGVSb3dGb3JUYXNrU3RhdHVzKFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLFxuICAgICAgICAgICAgICAgIHN0YXR1c190eXBlLFxuICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbixcbiAgICAgICAgICAgICAgICBmYWxzZSwgLy8gaXNDb3JlU3RhdHVzXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2Jyk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gJ0FkZCBOZXcgVGFzayBTdGF0dXMnIGJ1dHRvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQWRkIE5ldyBUYXNrIFN0YXR1cycpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBTdGF0dXNTZXR0aW5ncy5hZGRTdGF0dXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCcnLCAnJywgJycsIGZhbHNlLCBTdGF0dXNUeXBlLlRPRE8pLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldHRpbmcuaW5mb0VsLnJlbW92ZSgpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEFkZCBhbGwgU3RhdHVzIHR5cGVzIHN1cHBvcnRlZCBieSAuLi4gYnV0dG9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICB0eXBlIE5hbWVkVGhlbWUgPSBbc3RyaW5nLCBTdGF0dXNDb2xsZWN0aW9uXTtcbiAgICAgICAgY29uc3QgdGhlbWVzOiBOYW1lZFRoZW1lW10gPSBbXG4gICAgICAgICAgICAvLyBMaWdodCBhbmQgRGFyayB0aGVtZXMgLSBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgICAgICAgIFsnQW51UHB1Y2NpbiBUaGVtZScsIFRoZW1lcy5hbnVwcHVjY2luU3VwcG9ydGVkU3RhdHVzZXMoKV0sXG4gICAgICAgICAgICBbJ0F1cmEgVGhlbWUnLCBUaGVtZXMuYXVyYVN1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICAgICAgWydFYnVsbGllbnR3b3JrcyBUaGVtZScsIFRoZW1lcy5lYnVsbGllbnR3b3Jrc1N1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICAgICAgWydJVFMgVGhlbWUgJiBTbFJ2YiBDaGVja2JveGVzJywgVGhlbWVzLml0c1N1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICAgICAgWydNaW5pbWFsIFRoZW1lJywgVGhlbWVzLm1pbmltYWxTdXBwb3J0ZWRTdGF0dXNlcygpXSxcbiAgICAgICAgICAgIFsnVGhpbmdzIFRoZW1lJywgVGhlbWVzLnRoaW5nc1N1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICAgICAgLy8gRGFyayBvbmx5IHRoZW1lcyAtIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICAgICAgWydMWVQgTW9kZSBUaGVtZSAoRGFyayBtb2RlIG9ubHkpJywgVGhlbWVzLmx5dE1vZGVTdXBwb3J0ZWRTdGF0dXNlcygpXSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgY29sbGVjdGlvbl0gb2YgdGhlbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRTdGF0dXNlc1N1cHBvcnRlZEJ5VGhpc1RoZW1lID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBgJHtuYW1lfTogQWRkICR7Y29sbGVjdGlvbi5sZW5ndGh9IHN1cHBvcnRlZCBTdGF0dXNlc2A7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQobGFiZWwpLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRDdXN0b21TdGF0ZXNUb1NldHRpbmdzKGNvbGxlY3Rpb24sIHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZFN0YXR1c2VzU3VwcG9ydGVkQnlUaGlzVGhlbWUuaW5mb0VsLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gJ0FkZCBBbGwgVW5rbm93biBTdGF0dXMgVHlwZXMnIGJ1dHRvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICBjb25zdCBhZGRBbGxVbmtub3duU3RhdHVzZXMgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgQWxsIFVua25vd24gU3RhdHVzIFR5cGVzJylcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gdGhpcy5wbHVnaW4uZ2V0VGFza3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsU3RhdHVzZXMgPSB0YXNrcyEubWFwKCh0YXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmtub3duU3RhdHVzZXMgPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLmZpbmRVbmtub3duU3RhdHVzZXMoYWxsU3RhdHVzZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5rbm93blN0YXR1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25TdGF0dXNlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0dXNTZXR0aW5ncy5hZGRTdGF0dXMoc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMsIHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRBbGxVbmtub3duU3RhdHVzZXMuaW5mb0VsLnJlbW92ZSgpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tICdSZXNldCBDdXN0b20gU3RhdHVzIFR5cGVzIHRvIERlZmF1bHRzJyBidXR0b24gLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgY29uc3QgY2xlYXJDdXN0b21TdGF0dXNlcyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Jlc2V0IEN1c3RvbSBTdGF0dXMgVHlwZXMgdG8gRGVmYXVsdHMnKVxuICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLnJlc2V0QWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQ3VzdG9tU3RhdHVzZXMuaW5mb0VsLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHJvdyB0byBzZWUgYW5kIG1vZGlmeSBzZXR0aW5ncyBmb3IgYSBzaW5nbGUgdGFzayBzdGF0dXMgdHlwZS5cbiAqIEBwYXJhbSBjb250YWluZXJFbFxuICogQHBhcmFtIHN0YXR1c1R5cGUgLSBUaGUgc3RhdHVzIHR5cGUgdG8gYmUgZWRpdGVkLlxuICogQHBhcmFtIHN0YXR1c2VzIC0gVGhlIGxpc3Qgb2Ygc3RhdHVzZXMgdGhhdCBzdGF0dXNUeXBlIGlzIHN0b3JlZCBpbi5cbiAqIEBwYXJhbSBzdGF0dXNTZXR0aW5ncyAtIEFsbCB0aGUgc3RhdHVzIHR5cGVzIGFscmVhZHkgaW4gdGhlIHVzZXIncyBzZXR0aW5ncywgRVhDRVBUIHRoZSBzdGFuZGFyZCBvbmVzLlxuICogQHBhcmFtIHNldHRpbmdzXG4gKiBAcGFyYW0gcGx1Z2luXG4gKiBAcGFyYW0gaXNDb3JlU3RhdHVzIC0gd2hldGhlciB0aGUgc3RhdHVzIGlzIGEgY29yZSBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm93Rm9yVGFza1N0YXR1cyhcbiAgICBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG4gICAgc3RhdHVzVHlwZTogU3RhdHVzQ29uZmlndXJhdGlvbixcbiAgICBzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdLFxuICAgIHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncyxcbiAgICBzZXR0aW5nczogU2V0dGluZ3NUYWIsXG4gICAgcGx1Z2luOiBUYXNrc1BsdWdpbixcbiAgICBpc0NvcmVTdGF0dXM6IGJvb2xlYW4sXG4pIHtcbiAgICAvL2NvbnN0IHRhc2tTdGF0dXNEaXYgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2Jyk7XG5cbiAgICBjb25zdCB0YXNrU3RhdHVzUHJldmlldyA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwcmUnKTtcbiAgICB0YXNrU3RhdHVzUHJldmlldy5hZGRDbGFzcygncm93LWZvci1zdGF0dXMnKTtcbiAgICB0YXNrU3RhdHVzUHJldmlldy50ZXh0Q29udGVudCA9IG5ldyBTdGF0dXMoc3RhdHVzVHlwZSkucHJldmlld1RleHQoKTtcblxuICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCk7XG5cbiAgICBzZXR0aW5nLmluZm9FbC5yZXBsYWNlV2l0aCh0YXNrU3RhdHVzUHJldmlldyk7XG5cbiAgICBpZiAoIWlzQ29yZVN0YXR1cykge1xuICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKChleHRyYSkgPT4ge1xuICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignY3Jvc3MnKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdEZWxldGUnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFN0YXR1c1NldHRpbmdzLmRlbGV0ZVN0YXR1cyhzdGF0dXNlcywgc3RhdHVzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oKGV4dHJhKSA9PiB7XG4gICAgICAgIGV4dHJhXG4gICAgICAgICAgICAuc2V0SWNvbigncGVuY2lsJylcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKCdFZGl0JylcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBDdXN0b21TdGF0dXNNb2RhbChwbHVnaW4sIHN0YXR1c1R5cGUsIGlzQ29yZVN0YXR1cyk7XG5cbiAgICAgICAgICAgICAgICBtb2RhbC5vbkNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWwuc2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTdGF0dXNTZXR0aW5ncy5yZXBsYWNlU3RhdHVzKHN0YXR1c2VzLCBzdGF0dXNUeXBlLCBtb2RhbC5zdGF0dXNDb25maWd1cmF0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXR0aW5nLmluZm9FbC5yZW1vdmUoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkQ3VzdG9tU3RhdGVzVG9TZXR0aW5ncyhcbiAgICBzdXBwb3J0ZWRTdGF0dXNlczogU3RhdHVzQ29sbGVjdGlvbixcbiAgICBzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MsXG4gICAgc2V0dGluZ3M6IFNldHRpbmdzVGFiLFxuKSB7XG4gICAgY29uc3Qgbm90aWNlcyA9IFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9uKHN0YXR1c1NldHRpbmdzLCBzdXBwb3J0ZWRTdGF0dXNlcyk7XG5cbiAgICBub3RpY2VzLmZvckVhY2goKG5vdGljZSkgPT4ge1xuICAgICAgICBuZXcgTm90aWNlKG5vdGljZSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1R5cGVzOiBTdGF0dXNTZXR0aW5ncywgc2V0dGluZ3M6IFNldHRpbmdzVGFiKSB7XG4gICAgdXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICBzdGF0dXNTZXR0aW5nczogc3RhdHVzVHlwZXMsXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGFjdGl2ZSBzdGF0dXNlcy5cbiAgICAvLyBUaGlzIHNhdmVzIHRoZSB1c2VyIGZyb20gaGF2aW5nIHRvIHJlc3RhcnQgT2JzaWRpYW4gaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGNoYW5nZWQgc3RhdHVzKGVzKS5cbiAgICBTdGF0dXNTZXR0aW5ncy5hcHBseVRvU3RhdHVzUmVnaXN0cnkoc3RhdHVzVHlwZXMsIFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkpO1xuXG4gICAgYXdhaXQgc2V0dGluZ3Muc2F2ZVNldHRpbmdzKHRydWUpO1xufVxuXG5mdW5jdGlvbiBtYWtlTXVsdGlsaW5lVGV4dFNldHRpbmcoc2V0dGluZzogU2V0dGluZykge1xuICAgIGNvbnN0IHsgc2V0dGluZ0VsLCBpbmZvRWwsIGNvbnRyb2xFbCB9ID0gc2V0dGluZztcbiAgICBjb25zdCB0ZXh0RWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IGNvbnRyb2xFbC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuXG4gICAgLy8gTm90IGEgc2V0dGluZyB3aXRoIGEgdGV4dCBmaWVsZFxuICAgIGlmICh0ZXh0RWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldHRpbmdFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBpbmZvRWwuc3R5bGUubWFyZ2luUmlnaHQgPSAnMHB4JztcbiAgICB0ZXh0RWwuc3R5bGUubWluV2lkdGggPSAnLXdlYmtpdC1maWxsLWF2YWlsYWJsZSc7XG59XG4iLCAiZXhwb3J0IGNsYXNzIE1hcmtkb3duVGFibGUge1xuICAgIHByaXZhdGUgY29sdW1uTmFtZXM6IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgX21hcmtkb3duID0gJyc7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5OYW1lczogc3RyaW5nW10pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5OYW1lcyA9IGNvbHVtbk5hbWVzO1xuICAgICAgICB0aGlzLmFkZFRpdGxlUm93KCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmtkb3duKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZG93bjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRpdGxlUm93KCkge1xuICAgICAgICBsZXQgdGl0bGVzID0gJ3wnO1xuICAgICAgICBsZXQgZGl2aWRlciA9ICd8JztcbiAgICAgICAgdGhpcy5jb2x1bW5OYW1lcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aXRsZXMgKz0gYCAke3N9IHxgO1xuICAgICAgICAgICAgZGl2aWRlciArPSAnIC0tLS0tIHwnO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9tYXJrZG93biArPSBgJHt0aXRsZXN9XFxuYDtcbiAgICAgICAgdGhpcy5fbWFya2Rvd24gKz0gYCR7ZGl2aWRlcn1cXG5gO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRSb3coY2VsbHM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMubWFrZVJvd1RleHQoY2VsbHMpO1xuICAgICAgICB0aGlzLl9tYXJrZG93biArPSBgJHtyb3d9XFxuYDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUm93SWZOZXcoY2VsbHM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMubWFrZVJvd1RleHQoY2VsbHMpO1xuICAgICAgICBpZiAoIXRoaXMuX21hcmtkb3duLmluY2x1ZGVzKHJvdykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtkb3duICs9IGAke3Jvd31cXG5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYWtlUm93VGV4dChjZWxsczogc3RyaW5nW10pIHtcbiAgICAgICAgbGV0IHJvdyA9ICd8JztcbiAgICAgICAgY2VsbHMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgcm93ICs9IGAgJHtzfSB8YDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c1NldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCB7IE1hcmtkb3duVGFibGUgfSBmcm9tICcuLi9saWIvTWFya2Rvd25UYWJsZSc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbmZpZ3VyYXRpb24gfSBmcm9tICcuL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuL1N0YXR1cyc7XG5cbmZ1bmN0aW9uIGdldEZpcnN0SW5kZXgoc3RhdHVzQ29uZmlndXJhdGlvbnM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSwgd2FudGVkU3ltYm9sOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RhdHVzQ29uZmlndXJhdGlvbnMuZmluZEluZGV4KChzKSA9PiBzLnN5bWJvbCA9PT0gd2FudGVkU3ltYm9sKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByaW50YWJsZVN5bWJvbChzeW1ib2w6IHN0cmluZykge1xuICAgIC8vIERvIG5vdCBwdXQgYmFja3RpY2tzIGFyb3VuZCBhbiBlbXB0eSBzeW1ib2wsIGFzIHRoZSB0d28gYmFja3RpY2tzIGFyZSByZW5kZXJlZFxuICAgIC8vIGJ5IE9ic2lkaWFuIGFzIG9yZGluYXJ5IGNoYXJhY3RlcnMgYW5kIHRoZSBtZWFuaW5nIGlzIHVuY2xlYXIuXG4gICAgLy8gQmV0dGVyIHRvIGp1c3QgZGlzcGxheSBub3RoaW5nIGluIHRoaXMgc2l0dWF0aW9uLlxuICAgIGlmIChzeW1ib2wgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHN5bWJvbCAhPT0gJyAnID8gc3ltYm9sIDogJ3NwYWNlJztcbiAgICByZXR1cm4gJ2AnICsgcmVzdWx0ICsgJ2AnO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmQ29udmVudGlvbmFsVHlwZShzdGF0dXM6IFN0YXR1c0NvbmZpZ3VyYXRpb24sIHByb2JsZW1zOiBzdHJpbmdbXSkge1xuICAgIC8vIENoZWNrIGlmIGNvbnZlbnRpb25hbCB0eXBlIGlzIGJlaW5nIHVzZWQ6XG4gICAgY29uc3QgY29udmVudGlvbmFsVHlwZSA9IFN0YXR1cy5nZXRUeXBlRm9yVW5rbm93blN5bWJvbChzdGF0dXMuc3ltYm9sKTtcbiAgICBpZiAoc3RhdHVzLnR5cGUgPT09IGNvbnZlbnRpb25hbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb252ZW50aW9uYWxUeXBlID09PSBTdGF0dXNUeXBlLlRPRE8gJiYgc3RhdHVzLnN5bWJvbCAhPT0gJyAnKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGxpa2VseSBhIGRlZmF1bHQgVE9ETyAtIGlnbm9yZSBpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb2JsZW1zLnB1c2goXG4gICAgICAgIGBGb3IgaW5mb3JtYXRpb24sIHRoZSBjb252ZW50aW9uYWwgdHlwZSBmb3Igc3RhdHVzIHN5bWJvbCAke2dldFByaW50YWJsZVN5bWJvbChcbiAgICAgICAgICAgIHN0YXR1cy5zeW1ib2wsXG4gICAgICAgICl9IGlzICR7Z2V0UHJpbnRhYmxlU3ltYm9sKGNvbnZlbnRpb25hbFR5cGUpfTogeW91IG1heSB3aXNoIHRvIHJldmlldyB0aGlzIHR5cGUuYCxcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjaGVja05leHRTdGF0dXNTeW1ib2woc3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSwgc3RhdHVzOiBTdGF0dXNDb25maWd1cmF0aW9uLCBwcm9ibGVtczogc3RyaW5nW10pIHtcbiAgICAvLyBDaGVjayBpZiBuZXh0IHN5bWJvbCBpcyBrbm93blxuICAgIGNvbnN0IGluZGV4T2ZOZXh0U3ltYm9sID0gZ2V0Rmlyc3RJbmRleChzdGF0dXNlcywgc3RhdHVzLm5leHRTdGF0dXNTeW1ib2wpO1xuICAgIGlmIChpbmRleE9mTmV4dFN5bWJvbCA9PT0gLTEpIHtcbiAgICAgICAgcHJvYmxlbXMucHVzaChcbiAgICAgICAgICAgIGBOZXh0IHN5bWJvbCAke2dldFByaW50YWJsZVN5bWJvbChcbiAgICAgICAgICAgICAgICBzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCxcbiAgICAgICAgICAgICl9IGlzIHVua25vd246IGNyZWF0ZSBhIHN0YXR1cyB3aXRoIHN5bWJvbCAke2dldFByaW50YWJsZVN5bWJvbChzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCl9LmAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzLnR5cGUgIT09IFN0YXR1c1R5cGUuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyB0eXBlIGlzIERPTkU6IGNoZWNrIHRoYXQgbmV4dCBzdGF0dXMgdHlwZSBpcyBUT0RPIG9yIElOX1BST0dSRVNTLlxuICAgIC8vIFNlZSBpc3N1ZXMgIzIwODkgYW5kICMyMzA0LlxuICAgIGNvbnN0IG5leHRTdGF0dXMgPSBzdGF0dXNlc1tpbmRleE9mTmV4dFN5bWJvbF07XG4gICAgaWYgKG5leHRTdGF0dXMpIHtcbiAgICAgICAgaWYgKG5leHRTdGF0dXMudHlwZSAhPT0gJ1RPRE8nICYmIG5leHRTdGF0dXMudHlwZSAhPT0gJ0lOX1BST0dSRVNTJykge1xuICAgICAgICAgICAgY29uc3QgaGVscFVSTCA9XG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvU3RhdHVzZXMvUmVjdXJyaW5nK1Rhc2tzK2FuZCtDdXN0b20rU3RhdHVzZXMnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgICAgICBgVGhpcyBcXGBET05FXFxgIHN0YXR1cyBpcyBmb2xsb3dlZCBieSAke2dldFByaW50YWJsZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXR1cy50eXBlLFxuICAgICAgICAgICAgICAgICl9LCBub3QgXFxgVE9ET1xcYCBvciBcXGBJTl9QUk9HUkVTU1xcYC5gLFxuICAgICAgICAgICAgICAgICdJZiB1c2VkIHRvIGNvbXBsZXRlIGEgcmVjdXJyaW5nIHRhc2ssIGl0IHdpbGwgaW5zdGVhZCBiZSBmb2xsb3dlZCBieSBgVE9ET2Agb3IgYElOX1BST0dSRVNTYCwgdG8gZW5zdXJlIHRoZSBuZXh0IHRhc2sgbWF0Y2hlcyB0aGUgYG5vdCBkb25lYCBmaWx0ZXIuJyxcbiAgICAgICAgICAgICAgICBgU2VlIFtSZWN1cnJpbmcgVGFza3MgYW5kIEN1c3RvbSBTdGF0dXNlc10oJHtoZWxwVVJMfSkuYCxcbiAgICAgICAgICAgIF0uam9pbignPGJyPicpO1xuICAgICAgICAgICAgcHJvYmxlbXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2JsZW1zLnB1c2goJ1VuZXhwZWN0ZWQgZmFpbHVyZSB0byBmaW5kIHRoZSBuZXh0IHN0YXR1cy4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb2JsZW1zRm9yU3RhdHVzKHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10sIHN0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbiwgaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHByb2JsZW1zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChzdGF0dXMuc3ltYm9sID09PSBTdGF0dXMuRU1QVFkuc3ltYm9sKSB7XG4gICAgICAgIHByb2JsZW1zLnB1c2goJ0VtcHR5IHN5bWJvbDogdGhpcyBzdGF0dXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICAgICAgICByZXR1cm4gcHJvYmxlbXM7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJbmRleCA9IGdldEZpcnN0SW5kZXgoc3RhdHVzZXMsIHN0YXR1cy5zeW1ib2wpO1xuICAgIGlmIChmaXJzdEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgIHByb2JsZW1zLnB1c2goYER1cGxpY2F0ZSBzeW1ib2wgJyR7Z2V0UHJpbnRhYmxlU3ltYm9sKHN0YXR1cy5zeW1ib2wpfSc6IHRoaXMgc3RhdHVzIHdpbGwgYmUgaWdub3JlZC5gKTtcbiAgICAgICAgcmV0dXJuIHByb2JsZW1zO1xuICAgIH1cblxuICAgIGNoZWNrSWZDb252ZW50aW9uYWxUeXBlKHN0YXR1cywgcHJvYmxlbXMpO1xuICAgIGNoZWNrTmV4dFN0YXR1c1N5bWJvbChzdGF0dXNlcywgc3RhdHVzLCBwcm9ibGVtcyk7XG4gICAgcmV0dXJuIHByb2JsZW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFidWxhdGVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MpIHtcbiAgICAvLyBOb3RlOiBUaGVyZSBpcyB2ZXJ5IHNpbWlsYXIgY29kZSBpbiB2ZXJpZnlTdGF0dXNlc0FzTWFya2Rvd25UYWJsZSgpIGluIERvY3NTYW1wbGVzRm9yU3RhdHVzZXMudGVzdC50cy5cbiAgICAvLyAgICAgICBNYXliZSB0cnkgdW5pZnlpbmcgdGhlIGNvbW1vbiBjb2RlIG9uZSBkYXk/XG5cbiAgICBjb25zdCB0YWJsZSA9IG5ldyBNYXJrZG93blRhYmxlKFtcbiAgICAgICAgJ1N0YXR1cyBTeW1ib2wnLFxuICAgICAgICAnTmV4dCBTdGF0dXMgU3ltYm9sJyxcbiAgICAgICAgJ1N0YXR1cyBOYW1lJyxcbiAgICAgICAgJ1N0YXR1cyBUeXBlJyxcbiAgICAgICAgJ1Byb2JsZW1zIChpZiBhbnkpJyxcbiAgICBdKTtcblxuICAgIGNvbnN0IHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10gPSBTdGF0dXNTZXR0aW5ncy5hbGxTdGF0dXNlcyhzdGF0dXNTZXR0aW5ncyk7XG4gICAgc3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzLCBpbmRleCkgPT4ge1xuICAgICAgICB0YWJsZS5hZGRSb3coW1xuICAgICAgICAgICAgZ2V0UHJpbnRhYmxlU3ltYm9sKHN0YXR1cy5zeW1ib2wpLFxuICAgICAgICAgICAgZ2V0UHJpbnRhYmxlU3ltYm9sKHN0YXR1cy5uZXh0U3RhdHVzU3ltYm9sKSxcbiAgICAgICAgICAgIHN0YXR1cy5uYW1lLFxuICAgICAgICAgICAgZ2V0UHJpbnRhYmxlU3ltYm9sKHN0YXR1cy50eXBlKSxcbiAgICAgICAgICAgIGdldFByb2JsZW1zRm9yU3RhdHVzKHN0YXR1c2VzLCBzdGF0dXMsIGluZGV4KS5qb2luKCc8YnI+JyksXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0YWJsZS5tYXJrZG93bjtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c1NldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCB0eXBlIHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IHRhYnVsYXRlU3RhdHVzU2V0dGluZ3MgfSBmcm9tICcuL1N0YXR1c1NldHRpbmdzUmVwb3J0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXR1c1JlZ2lzdHJ5UmVwb3J0KFxuICAgIHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncyxcbiAgICBzdGF0dXNSZWdpc3RyeTogU3RhdHVzUmVnaXN0cnksXG4gICAgYnV0dG9uTmFtZTogc3RyaW5nLFxuICAgIHZlcnNpb25TdHJpbmc6IHN0cmluZyxcbikge1xuICAgIC8vIElkZWFzIGZvciBmdXJ0aGVyIGltcHJvdmVtZW50XG4gICAgLy8gLSBBY3R1YWxseSBtYWtlIGl0IGFuIGluZm9ybWF0aXZlIHJlcG9ydCwgdGhhdCBzaG93cyBhbnkgaXNzdWVzIGluIHNldHRpbmdzIHdpdGggZHVwbGljYXRlIHN5bWJvbHMuXG4gICAgLy8gLSBTaG93IGFueSAnbmV4dCBzdGF0dXMgc3ltYm9scycgdGhhdCBhcmUgbm90IGtub3duIHRvIHRoZSBwbHVnaW4uXG4gICAgLy8gLSBTaG93IGFueSBzdGF0dXMgdHJhbnNpdGlvbnMgdGhhdCB3b24ndCB3b3JrIHdpdGggcmVjdXJyaW5nIHRhc2tzIGN1cnJlbnRseSwgYXMgRE9ORSBub3QgZm9sbG93ZWQgYnkgVE9ETy5cblxuICAgIGNvbnN0IGRldGFpbGVkID0gdHJ1ZTtcbiAgICBjb25zdCBzZXR0aW5nc1RhYmxlID0gdGFidWxhdGVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncyk7XG4gICAgY29uc3QgbWVybWFpZFRleHQgPSBzdGF0dXNSZWdpc3RyeS5tZXJtYWlkRGlhZ3JhbShkZXRhaWxlZCk7XG4gICAgcmV0dXJuIGAjICR7YnV0dG9uTmFtZX1cblxuIyMgQWJvdXQgdGhpcyBmaWxlXG5cblRoaXMgZmlsZSB3YXMgY3JlYXRlZCBieSB0aGUgT2JzaWRpYW4gVGFza3MgcGx1Z2luICh2ZXJzaW9uICR7dmVyc2lvblN0cmluZ30pIHRvIGhlbHAgdmlzdWFsaXNlIHRoZSB0YXNrIHN0YXR1c2VzIGluIHRoaXMgdmF1bHQuXG5cbklmIHlvdSBjaGFuZ2UgdGhlIFRhc2tzIHN0YXR1cyBzZXR0aW5ncywgeW91IGNhbiBnZXQgYW4gdXBkYXRlZCByZXBvcnQgYnk6XG5cbi0gR29pbmcgdG8gXFxgU2V0dGluZ3NcXGAgLT4gXFxgVGFza3NcXGAuXG4tIENsaWNraW5nIG9uIFxcYFJldmlldyBhbmQgY2hlY2sgeW91ciBTdGF0dXNlc1xcYC5cblxuWW91IGNhbiBkZWxldGUgdGhpcyBmaWxlIGFueSB0aW1lLlxuXG4jIyBTdGF0dXMgU2V0dGluZ3NcblxuPCEtLVxuU3dpdGNoIHRvIExpdmUgUHJldmlldyBvciBSZWFkaW5nIE1vZGUgdG8gc2VlIHRoZSB0YWJsZS5cbklmIHRoZXJlIGFyZSBhbnkgTWFya2Rvd24gZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGluIHN0YXR1cyBuYW1lcywgc3VjaCBhcyAnKicgb3IgJ18nLFxuT2JzaWRpYW4gbWF5IG9ubHkgcmVuZGVyIHRoZSB0YWJsZSBjb3JyZWN0bHkgaW4gUmVhZGluZyBNb2RlLlxuLS0+XG5cblRoZXNlIGFyZSB0aGUgc3RhdHVzIHZhbHVlcyBpbiB0aGUgQ29yZSBhbmQgQ3VzdG9tIHN0YXR1c2VzIHNlY3Rpb25zLlxuXG4ke3NldHRpbmdzVGFibGV9XG4jIyBMb2FkZWQgU2V0dGluZ3NcblxuPCEtLSBTd2l0Y2ggdG8gTGl2ZSBQcmV2aWV3IG9yIFJlYWRpbmcgTW9kZSB0byBzZWUgdGhlIGRpYWdyYW0uIC0tPlxuXG5UaGVzZSBhcmUgdGhlIHNldHRpbmdzIGFjdHVhbGx5IHVzZWQgYnkgVGFza3MuXG4ke21lcm1haWRUZXh0fWA7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgQW51UHB1Y2NpbiB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9BbnViaXNOZWtoZXQvQW51UHB1Y2Npbn1cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYW51cHB1Y2NpblN1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ1VuY2hlY2tlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd4JywgJ0NoZWNrZWQnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnPicsICdSZXNjaGVkdWxlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc8JywgJ1NjaGVkdWxlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ0ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyctJywgJ0NhbmNlbGxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJy8nLCAnSW4gUHJvZ3Jlc3MnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJz8nLCAnUXVlc3Rpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnKicsICdTdGFyJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ24nLCAnTm90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydsJywgJ0xvY2F0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnSW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSScsICdJZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1MnLCAnQW1vdW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3AnLCAnUHJvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2MnLCAnQ29uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnQm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnXCInLCAnUXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnMCcsICdTcGVlY2ggYnViYmxlIDAnLCAnMCcsICdOT05fVEFTSyddLFxuICAgICAgICBbJzEnLCAnU3BlZWNoIGJ1YmJsZSAxJywgJzEnLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWycyJywgJ1NwZWVjaCBidWJibGUgMicsICcyJywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnMycsICdTcGVlY2ggYnViYmxlIDMnLCAnMycsICdOT05fVEFTSyddLFxuICAgICAgICBbJzQnLCAnU3BlZWNoIGJ1YmJsZSA0JywgJzQnLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWyc1JywgJ1NwZWVjaCBidWJibGUgNScsICc1JywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnNicsICdTcGVlY2ggYnViYmxlIDYnLCAnNicsICdOT05fVEFTSyddLFxuICAgICAgICBbJzcnLCAnU3BlZWNoIGJ1YmJsZSA3JywgJzcnLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWyc4JywgJ1NwZWVjaCBidWJibGUgOCcsICc4JywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnOScsICdTcGVlY2ggYnViYmxlIDknLCAnOScsICdOT05fVEFTSyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNlcy9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBBdXJhIHRoZW1lLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FzaHdpbmphZGhhdjgxOC9vYnNpZGlhbi1hdXJhfVxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXJhU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICBbJyAnLCAnaW5jb21wbGV0ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd4JywgJ2NvbXBsZXRlIC8gZG9uZScsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWyctJywgJ2NhbmNlbGxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJz4nLCAnZGVmZXJyZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnLycsICdpbiBwcm9ncmVzcywgb3IgaGFsZi1kb25lJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWychJywgJ0ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc/JywgJ3F1ZXN0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1InLCAncmV2aWV3JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJysnLCAnSW5ib3ggLyB0YXNrIHRoYXQgc2hvdWxkIGJlIHByb2Nlc3NlZCBsYXRlcicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ2Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0InLCAnYnJhaW5zdG9ybScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydEJywgJ2RlZmVycmVkIG9yIHNjaGVkdWxlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydJJywgJ0luZm8nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnaScsICdpZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ04nLCAnbm90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydRJywgJ3F1b3RlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1cnLCAnd2luIC8gc3VjY2VzcyAvIHJld2FyZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydQJywgJ3BybycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydDJywgJ2NvbicsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgRWJ1bGxpZW50d29ya3MgdGhlbWUuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZWJ1bGxpZW50L29ic2lkaWFuLXRoZW1lLWVidWxsaWVudHdvcmtzfVxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYnVsbGllbnR3b3Jrc1N1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ1VuY2hlY2tlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd4JywgJ0NoZWNrZWQnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnLScsICdDYW5jZWxsZWQnLCAnICcsICdDQU5DRUxMRUQnXSxcbiAgICAgICAgWycvJywgJ0luIFByb2dyZXNzJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWyc+JywgJ0RlZmVycmVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyEnLCAnSW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJz8nLCAnUXVlc3Rpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsncicsICdSZXZpZXcnLCAneCcsICdUT0RPJ10sXG4gICAgXTtcbiAgICByZXR1cm4genp6O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbiB9IGZyb20gJy4uLy4uL1N0YXR1c2VzL1N0YXR1c0NvbGxlY3Rpb24nO1xuXG4vKipcbiAqIFN0YXR1cyBzdXBwb3J0ZWQgYnkgdGhlIElUUyB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9TbFJ2Yi9PYnNpZGlhbi0tSVRTLVRoZW1lfVxuICogVmFsdWVzIHJlY29nbmlzZWQgYnkgVGFza3MgYXJlIGV4Y2x1ZGVkLlxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpdHNTdXBwb3J0ZWRTdGF0dXNlcygpIHtcbiAgICBjb25zdCB6eno6IFN0YXR1c0NvbGxlY3Rpb24gPSBbXG4gICAgICAgIFsnICcsICdVbmNoZWNrZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsneCcsICdSZWd1bGFyJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJ1gnLCAnQ2hlY2tlZCcsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWyctJywgJ0Ryb3BwZWQnLCAnICcsICdDQU5DRUxMRUQnXSxcbiAgICAgICAgWyc+JywgJ0ZvcndhcmQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnRCcsICdEYXRlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJz8nLCAnUXVlc3Rpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnLycsICdIYWxmIERvbmUnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJysnLCAnQWRkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1InLCAnUmVzZWFyY2gnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnIScsICdJbXBvcnRhbnQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnaScsICdJZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0InLCAnQnJhaW5zdG9ybScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydQJywgJ1BybycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydDJywgJ0NvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydRJywgJ1F1b3RlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ04nLCAnTm90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ0Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnSW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsncCcsICdQYXJhcGhyYXNlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0wnLCAnTG9jYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnRScsICdFeGFtcGxlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0EnLCAnQW5zd2VyJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3InLCAnUmV3YXJkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2MnLCAnQ2hvaWNlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2QnLCAnRG9pbmcnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJ1QnLCAnVGltZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydAJywgJ0NoYXJhY3RlciAvIFBlcnNvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd0JywgJ1RhbGsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnTycsICdPdXRsaW5lIC8gUGxvdCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd+JywgJ0NvbmZsaWN0JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1cnLCAnV29ybGQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZicsICdDbHVlIC8gRmluZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydGJywgJ0ZvcmVzaGFkb3cnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSCcsICdGYXZvcml0ZSAvIEhlYWx0aCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycmJywgJ1N5bWJvbGlzbScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydzJywgJ1NlY3JldCcsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgTFlUIE1vZGUgdGhlbWUuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmlja21pbG8vTFlULU1vZGV9XG4gKiBAc2VlIHtAbGluayBTdGF0dXNTZXR0aW5ncy5idWxrQWRkU3RhdHVzQ29sbGVjdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGx5dE1vZGVTdXBwb3J0ZWRTdGF0dXNlcygpIHtcbiAgICBjb25zdCB6eno6IFN0YXR1c0NvbGxlY3Rpb24gPSBbXG4gICAgICAgIFsnICcsICdVbmNoZWNrZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsneCcsICdDaGVja2VkJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJz4nLCAnUmVzY2hlZHVsZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPCcsICdTY2hlZHVsZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnIScsICdJbXBvcnRhbnQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnLScsICdDYW5jZWxsZWQnLCAnICcsICdDQU5DRUxMRUQnXSxcbiAgICAgICAgWycvJywgJ0luIFByb2dyZXNzJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWyc/JywgJ1F1ZXN0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyonLCAnU3RhcicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyduJywgJ05vdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnbCcsICdMb2NhdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydpJywgJ0luZm9ybWF0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnSWRlYScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydTJywgJ0Ftb3VudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydwJywgJ1BybycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydjJywgJ0NvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ0Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2YnLCAnRmlyZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydrJywgJ0tleScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd3JywgJ1dpbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd1JywgJ1VwJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2QnLCAnRG93bicsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgTWluaW1hbCB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXBhbm8vb2JzaWRpYW4tbWluaW1hbH1cbiAqIFZhbHVlcyByZWNvZ25pc2VkIGJ5IFRhc2tzIGFyZSBleGNsdWRlZC5cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluaW1hbFN1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ3RvLWRvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJy8nLCAnaW5jb21wbGV0ZScsICd4JywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICAgIFsneCcsICdkb25lJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJy0nLCAnY2FuY2VsZWQnLCAnICcsICdDQU5DRUxMRUQnXSxcbiAgICAgICAgWyc+JywgJ2ZvcndhcmRlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc8JywgJ3NjaGVkdWxpbmcnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPycsICdxdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ2ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycqJywgJ3N0YXInLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnXCInLCAncXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnbCcsICdsb2NhdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ2Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnaW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUycsICdzYXZpbmdzJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnaWRlYScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydwJywgJ3Byb3MnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYycsICdjb25zJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2YnLCAnZmlyZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydrJywgJ2tleScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd3JywgJ3dpbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd1JywgJ3VwJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2QnLCAnZG93bicsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzZXMvU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgVGhpbmdzIHRoZW1lLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvbGluZWNrZXJ0L29ic2lkaWFuLXRoaW5nc31cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhpbmdzU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICAvLyBCYXNpY1xuICAgICAgICBbJyAnLCAndG8tZG8nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnLycsICdpbmNvbXBsZXRlJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWyd4JywgJ2RvbmUnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnLScsICdjYW5jZWxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJz4nLCAnZm9yd2FyZGVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJzwnLCAnc2NoZWR1bGluZycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgLy8gRXh0cmFzXG4gICAgICAgIFsnPycsICdxdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ2ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycqJywgJ3N0YXInLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnXCInLCAncXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnbCcsICdsb2NhdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ2Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnaW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUycsICdzYXZpbmdzJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnaWRlYScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydwJywgJ3Byb3MnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYycsICdjb25zJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2YnLCAnZmlyZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydrJywgJ2tleScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd3JywgJ3dpbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd1JywgJ3VwJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2QnLCAnZG93bicsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHsgTW9kYWwsIE5vdGljZSwgU2V0dGluZywgVGV4dENvbXBvbmVudCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3RhdHVzQ29uZmlndXJhdGlvbiwgU3RhdHVzVHlwZSB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgU3RhdHVzVmFsaWRhdG9yIH0gZnJvbSAnLi4vU3RhdHVzZXMvU3RhdHVzVmFsaWRhdG9yJztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1c2VzL1N0YXR1cyc7XG5cbmNvbnN0IHZhbGlkYXRvciA9IG5ldyBTdGF0dXNWYWxpZGF0b3IoKTtcblxuZXhwb3J0IGNsYXNzIEN1c3RvbVN0YXR1c01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHN0YXR1c1N5bWJvbDogc3RyaW5nO1xuICAgIHN0YXR1c05hbWU6IHN0cmluZztcbiAgICBzdGF0dXNOZXh0U3ltYm9sOiBzdHJpbmc7XG4gICAgc3RhdHVzQXZhaWxhYmxlQXNDb21tYW5kOiBib29sZWFuO1xuICAgIHR5cGU6IFN0YXR1c1R5cGU7XG5cbiAgICBzYXZlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGVycm9yOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBpc0NvcmVTdGF0dXM6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IocHVibGljIHBsdWdpbjogUGx1Z2luLCBzdGF0dXNUeXBlOiBTdGF0dXNDb25maWd1cmF0aW9uLCBpc0NvcmVTdGF0dXM6IGJvb2xlYW4pIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCk7XG4gICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sID0gc3RhdHVzVHlwZS5zeW1ib2w7XG4gICAgICAgIHRoaXMuc3RhdHVzTmFtZSA9IHN0YXR1c1R5cGUubmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXNOZXh0U3ltYm9sID0gc3RhdHVzVHlwZS5uZXh0U3RhdHVzU3ltYm9sO1xuICAgICAgICB0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCA9IHN0YXR1c1R5cGUuYXZhaWxhYmxlQXNDb21tYW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSBzdGF0dXNUeXBlLnR5cGU7XG4gICAgICAgIHRoaXMuaXNDb3JlU3RhdHVzID0gaXNDb3JlU3RhdHVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHtAbGluayBTdGF0dXNDb25maWd1cmF0aW9ufSBmcm9tIHRoZSBtb2RhbCdzIGNvbnRlbnRzXG4gICAgICovXG4gICAgcHVibGljIHN0YXR1c0NvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzQ29uZmlndXJhdGlvbihcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNOYW1lLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNOZXh0U3ltYm9sLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNBdmFpbGFibGVBc0NvbW1hbmQsXG4gICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcGxheSgpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ0RpdiA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoKTtcbiAgICAgICAgLy9jb25zdCB0aXRsZSA9IHRoaXMudGl0bGUgPz8gJy4uLic7XG5cbiAgICAgICAgbGV0IHN0YXR1c1N5bWJvbFRleHQ6IFRleHRDb21wb25lbnQ7XG4gICAgICAgIG5ldyBTZXR0aW5nKHNldHRpbmdEaXYpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVGFzayBTdGF0dXMgU3ltYm9sJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdUaGlzIGlzIHRoZSBjaGFyYWN0ZXIgYmV0d2VlbiB0aGUgc3F1YXJlIGJyYWNlcy4gKEl0IGNhbiBvbmx5IGJlIGVkaXRlZCBmb3IgQ3VzdG9tIHN0YXR1c2VzLCBhbmQgbm90IENvcmUgc3RhdHVzZXMuKScsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N5bWJvbFRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5zdGF0dXNTeW1ib2wpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sID0gdjtcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tU3RhdHVzTW9kYWwuc2V0VmFsaWQodGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlU3ltYm9sKHRoaXMuc3RhdHVzQ29uZmlndXJhdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNldERpc2FibGVkKHRoaXMuaXNDb3JlU3RhdHVzKVxuICAgICAgICAgICAgLnRoZW4oKF9zZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhbnkgZXJyb3IgaWYgdGhlIGluaXRpYWwgdmFsdWUgbG9hZGVkIGlzIGluY29ycmVjdC5cbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChzdGF0dXNTeW1ib2xUZXh0LCB2YWxpZGF0b3IudmFsaWRhdGVTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBzdGF0dXNOYW1lVGV4dDogVGV4dENvbXBvbmVudDtcbiAgICAgICAgbmV3IFNldHRpbmcoc2V0dGluZ0RpdilcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXNrIFN0YXR1cyBOYW1lJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGlzIGlzIHRoZSBmcmllbmRseSBuYW1lIG9mIHRoZSB0YXNrIHN0YXR1cy4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNOYW1lVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnN0YXR1c05hbWUpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTmFtZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHRleHQsIHZhbGlkYXRvci52YWxpZGF0ZU5hbWUodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoX3NldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChzdGF0dXNOYW1lVGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlTmFtZSh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHN0YXR1c05leHRTeW1ib2xUZXh0OiBUZXh0Q29tcG9uZW50O1xuICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgTmV4dCBTdGF0dXMgU3ltYm9sJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVuIGNsaWNrZWQgb24gdGhpcyBpcyB0aGUgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHVzZWQgbmV4dC4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNOZXh0U3ltYm9sVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnN0YXR1c05leHRTeW1ib2wpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTmV4dFN5bWJvbCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHRleHQsIHZhbGlkYXRvci52YWxpZGF0ZU5leHRTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoX3NldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzTmV4dFN5bWJvbFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci52YWxpZGF0ZU5leHRTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgU3RhdHVzIFR5cGUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0NvbnRyb2wgaG93IHRoZSBzdGF0dXMgYmVoYXZlcyBmb3Igc2VhcmNoaW5nIGFuZCB0b2dnbGluZy4nKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICAgICBTdGF0dXNUeXBlLlRPRE8sXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1MsXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuRE9ORSxcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzVHlwZS5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuTk9OX1RBU0ssXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0eXBlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbihzLCBzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLnR5cGUpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFN0YXR1cy5nZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcodik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU3RhdHVzLnRhc2tzUGx1Z2luQ2FuQ3JlYXRlQ29tbWFuZHNGb3JTdGF0dXNlcygpKSB7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBdmFpbGFibGUgYXMgY29tbWFuZCcpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgICAgICdJZiBlbmFibGVkIHRoaXMgc3RhdHVzIHdpbGwgYmUgYXZhaWxhYmxlIGFzIGEgY29tbWFuZCBzbyB5b3UgY2FuIGFzc2lnbiBhIGhvdGtleSBhbmQgdG9nZ2xlIHRoZSBzdGF0dXMgdXNpbmcgaXQuJyxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvb3RlckVsID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xuICAgICAgICBjb25zdCBmb290ZXJCdXR0b25zID0gbmV3IFNldHRpbmcoZm9vdGVyRWwpO1xuICAgICAgICBmb290ZXJCdXR0b25zLmFkZEJ1dHRvbigoYikgPT4ge1xuICAgICAgICAgICAgYi5zZXRUb29sdGlwKCdTYXZlJylcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignY2hlY2ttYXJrJylcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRvci52YWxpZGF0ZSh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9ycy5qb2luKCdcXG4nKSArICdcXG5cXG4nICsgJ0ZpeCBlcnJvcnMgYmVmb3JlIHNhdmluZy4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9vdGVyQnV0dG9ucy5hZGRFeHRyYUJ1dHRvbigoYikgPT4ge1xuICAgICAgICAgICAgYi5zZXRJY29uKCdjcm9zcycpXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0NhbmNlbCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGVUaXRsZShhZG1vbml0aW9uUHJldmlldzogSFRNTEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcpIHtcbiAgICAvLyAgICAgbGV0IHRpdGxlU3BhbiA9IGFkbW9uaXRpb25QcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoJy5hZG1vbml0aW9uLXRpdGxlLWNvbnRlbnQnKTtcbiAgICAvLyAgICAgbGV0IGljb25FbCA9IGFkbW9uaXRpb25QcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoJy5hZG1vbml0aW9uLXRpdGxlLWljb24nKTtcbiAgICAvLyAgICAgdGl0bGVTcGFuLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgLy8gICAgIHRpdGxlU3Bhbi5wcmVwZW5kKGljb25FbCk7XG4gICAgLy8gfVxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFZhbGlkYXRpb25FcnJvcih0ZXh0SW5wdXQ6IFRleHRDb21wb25lbnQpIHtcbiAgICAgICAgdGV4dElucHV0LmlucHV0RWwuYWRkQ2xhc3MoJ3Rhc2tzLXNldHRpbmdzLWlzLWludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlVmFsaWRhdGlvbkVycm9yKHRleHRJbnB1dDogVGV4dENvbXBvbmVudCkge1xuICAgICAgICB0ZXh0SW5wdXQuaW5wdXRFbC5yZW1vdmVDbGFzcygndGFza3Mtc2V0dGluZ3MtaXMtaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHNldFZhbGlkKHRleHQ6IFRleHRDb21wb25lbnQsIG1lc3NhZ2VzOiBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5yZW1vdmVWYWxpZGF0aW9uRXJyb3IodGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZGF0aW9uRXJyb3IodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFN0YXR1c1R5cGUgfSBmcm9tICcuL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uRW50cnkgfSBmcm9tICcuL1N0YXR1c0NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi9TdGF0dXMnO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuL1N0YXR1c1JlZ2lzdHJ5JztcblxuZXhwb3J0IGNsYXNzIFN0YXR1c1ZhbGlkYXRvciB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGRhdGUgaW4gdGhpcyBvYmplY3QgaXMgdmFsaWQsIGFuZCByZXR1cm4gZXJyb3IgbWVzc2FnZShzKSBmb3IgZGlzcGxheSBpZiBub3QuXG4gICAgICovXG4gICAgcHVibGljIHZhbGlkYXRlKHN0YXR1c0NvbmZpZ3VyYXRpb246IFN0YXR1c0NvbmZpZ3VyYXRpb24pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBNZXNzYWdlcyBhcmUgYWRkZWQgaW4gdGhlIG9yZGVyIGZpZWxkcyBhcmUgc2hvd24gd2hlbiBlZGl0aW5nIHN0YXR1c2VzLlxuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlU3ltYm9sKHN0YXR1c0NvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udGhpcy52YWxpZGF0ZU5hbWUoc3RhdHVzQ29uZmlndXJhdGlvbikpO1xuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlTmV4dFN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uKSk7XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBkYXRhIGluIFN0YXR1c0NvbGxlY3Rpb24gbGlzdHMuIFRoZXNlIGFyZSB0aGUgZGVzY3JpcHRpb25zIG9mIHN0YXR1c2VzIGluIHZhcmlvdXMgdGhlbWVzLFxuICAgICAqIHRoYXQgYXJlIGltcG9ydGVkIHZpYSBvbmUtY2xpY2sgYnV0dG9ucyBpbiB0aGUgQ3VzdG9tIFN0YXR1cyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBhIGZldyBjaGVja3MgdG8gZ3VhcmQgYWdhaW5zdCBodW1hbiBlcnJvciB3aGVuIGNyZWF0aW5nIHRoZSBsaXN0cywgYW5kIHRoZW5cbiAgICAgKiBhbHNvIGNhbGxzIHtAbGluayB2YWxpZGF0ZX0gdG9vLlxuICAgICAqIEBwYXJhbSBlbnRyeVxuICAgICAqL1xuICAgIHB1YmxpYyB2YWxpZGF0ZVN0YXR1c0NvbGxlY3Rpb25FbnRyeShlbnRyeTogU3RhdHVzQ29sbGVjdGlvbkVudHJ5KSB7XG4gICAgICAgIGNvbnN0IFtzeW1ib2wsIF9uYW1lLCBuZXh0U3RhdHVzU3ltYm9sLCB0eXBlQXNTdHJpbmddID0gZW50cnk7XG5cbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrcyB0aGF0IGNhbiBvbmx5IGJlIGRvbmUgb24gdGhlIHJhdyBkYXRhLlxuICAgICAgICAvLyBTdGF0dXMuY3JlYXRlRnJvbUltcG9ydGVkVmFsdWUoKSBmYWxscyBiYWNrIHRvIFN0YXR1c1R5cGUuVE9ETyBpZiB0aGVcbiAgICAgICAgLy8gdHlwZSBzdHJpbmcgaXMgbm90IHJlY29nbmlzZWQsIHNvIHdlIGhhdmUgdG8gdGVzdCB0aGF0IGZpcnN0LlxuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlVHlwZSh0eXBlQXNTdHJpbmcpKTtcblxuICAgICAgICAvLyBGb3IgdXNlcnMsIGl0IGlzIHZhbGlkIHRvIGhhdmUgYSBzdGF0dXMgdGhhdCB0b2dnbGVzIHRvIGl0c2VsZi5cbiAgICAgICAgLy8gRm9yIGltcG9ydGVkIGRhdGEgZm9yIHRoZW1lcywgaXQgc2VlbXMgd29ydGggcHJldmVudGluZyB0aGF0IHNpdHVhdGlvbixcbiAgICAgICAgLy8gdG8gZ3VhcmQgYWdhaW5zdCBodW1hbiBlcnJvciB3aGVuIHNldHRpbmcgdXAgdGhlIHN0YXR1cyBjb2xsZWN0aW9ucy5cbiAgICAgICAgLy8gQnV0IG1ha2UgYW4gZXhjZXB0aW9uIGZvciBhbnkgbm9uLXRhc2tzIGluIGltcG9ydGVkIGRhdGEuXG4gICAgICAgIGlmIChzeW1ib2wgPT09IG5leHRTdGF0dXNTeW1ib2wgJiYgdHlwZUFzU3RyaW5nICE9PSAnTk9OX1RBU0snKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgU3RhdHVzIHN5bWJvbCAnJHtzeW1ib2x9JyB0b2dnbGVzIHRvIGl0c2VsZmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHJhdyBkYXRhIHdhcyBub3QgdmFsaWQsIHJldHVybiBub3csIHRvIGF2b2lkIHBvdGVudGlhbGx5IG1pc2xlYWRpbmdcbiAgICAgICAgLy8gZXJyb3JzIGZyb20gbGF0ZXIgY2hlY2tzLlxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gU3RhdHVzLmNyZWF0ZUZyb21JbXBvcnRlZFZhbHVlKGVudHJ5KS5jb25maWd1cmF0aW9uO1xuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlU3ltYm9sVHlwZUNvbnZlbnRpb25zKGNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udGhpcy52YWxpZGF0ZShjb25maWd1cmF0aW9uKSk7XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsaWRhdGVTeW1ib2woc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c1ZhbGlkYXRvci52YWxpZGF0ZU9uZVN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uLnN5bWJvbCwgJ1Rhc2sgU3RhdHVzIFN5bWJvbCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZU5leHRTeW1ib2woc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c1ZhbGlkYXRvci52YWxpZGF0ZU9uZVN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uLm5leHRTdGF0dXNTeW1ib2wsICdUYXNrIE5leHQgU3RhdHVzIFN5bWJvbCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZU5hbWUoc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmIChzdGF0dXNDb25maWd1cmF0aW9uLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnVGFzayBTdGF0dXMgTmFtZSBjYW5ub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsaWRhdGVUeXBlKHN5bWJvbE5hbWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzVHlwZUVsZW1lbnQgPSBTdGF0dXNUeXBlW3N5bWJvbE5hbWUgYXMga2V5b2YgdHlwZW9mIFN0YXR1c1R5cGVdO1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICghc3RhdHVzVHlwZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGBTdGF0dXMgVHlwZSBcIiR7c3ltYm9sTmFtZX1cIiBpcyBub3QgYSB2YWxpZCB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c1R5cGVFbGVtZW50ID09IFN0YXR1c1R5cGUuRU1QVFkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdTdGF0dXMgVHlwZSBcIkVNUFRZXCIgaXMgbm90IHBlcm1pdHRlZCBpbiB1c2VyIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZVN5bWJvbFR5cGVDb252ZW50aW9ucyhjb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgY29uc3Qgc3ltYm9sID0gY29uZmlndXJhdGlvbi5zeW1ib2w7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbmV3IFN0YXR1c1JlZ2lzdHJ5KCk7XG4gICAgICAgIGNvbnN0IHN5bWJvbFRvU2VhcmNoRm9yID0gc3ltYm9sID09PSAnWCcgPyAneCcgOiBzeW1ib2w7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdGF0dXNGcm9tUmVnaXN0cnkgPSByZWdpc3RyeS5ieVN5bWJvbChzeW1ib2xUb1NlYXJjaEZvcik7XG4gICAgICAgIGlmIChkZWZhdWx0U3RhdHVzRnJvbVJlZ2lzdHJ5LnR5cGUgIT09IFN0YXR1c1R5cGUuRU1QVFkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLm5leHRTdGF0dXNTeW1ib2wgIT09IGRlZmF1bHRTdGF0dXNGcm9tUmVnaXN0cnkubmV4dFN0YXR1c1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBgTmV4dCBTdGF0dXMgU3ltYm9sIGZvciBzeW1ib2wgJyR7c3ltYm9sfSc6ICcke2NvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbH0nIGlzIGluY29uc2lzdGVudCB3aXRoIGNvbnZlbnRpb24gJyR7ZGVmYXVsdFN0YXR1c0Zyb21SZWdpc3RyeS5uZXh0U3RhdHVzU3ltYm9sfSdgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi50eXBlICE9PSBkZWZhdWx0U3RhdHVzRnJvbVJlZ2lzdHJ5LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgYFN0YXR1cyBUeXBlIGZvciBzeW1ib2wgJyR7c3ltYm9sfSc6ICcke2NvbmZpZ3VyYXRpb24udHlwZX0nIGlzIGluY29uc2lzdGVudCB3aXRoIGNvbnZlbnRpb24gJyR7ZGVmYXVsdFN0YXR1c0Zyb21SZWdpc3RyeS50eXBlfSdgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlT25lU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBzeW1ib2xOYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKHN5bWJvbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGAke3N5bWJvbE5hbWV9IGNhbm5vdCBiZSBlbXB0eS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzeW1ib2wubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYCR7c3ltYm9sTmFtZX0gKFwiJHtzeW1ib2x9XCIpIG11c3QgYmUgYSBzaW5nbGUgY2hhcmFjdGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBFZGl0b3JTdWdnZXN0LCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgRWRpdG9yUG9zaXRpb24sIEVkaXRvclN1Z2dlc3RDb250ZXh0LCBFZGl0b3JTdWdnZXN0VHJpZ2dlckluZm8gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSBUYXNrc1BsdWdpbiBmcm9tICdtYWluJztcbmltcG9ydCB7IGVuc3VyZVRhc2tIYXNJZCB9IGZyb20gJy4uL1Rhc2svVGFza0RlcGVuZGVuY3knO1xuaW1wb3J0IHsgcmVwbGFjZVRhc2tXaXRoVGFza3MgfSBmcm9tICcuLi9PYnNpZGlhbi9GaWxlJztcbmltcG9ydCB7IHR5cGUgU2V0dGluZ3MsIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgY2FuU3VnZ2VzdEZvckxpbmUgfSBmcm9tICcuL1N1Z2dlc3Rvcic7XG5pbXBvcnQgdHlwZSB7IFN1Z2dlc3RJbmZvIH0gZnJvbSAnLic7XG5cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvV2l0aENvbnRleHQgPSBTdWdnZXN0SW5mbyAmIHtcbiAgICBjb250ZXh0OiBFZGl0b3JTdWdnZXN0Q29udGV4dDtcbn07XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JTdWdnZXN0b3IgZXh0ZW5kcyBFZGl0b3JTdWdnZXN0PFN1Z2dlc3RJbmZvV2l0aENvbnRleHQ+IHtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBTZXR0aW5ncztcbiAgICBwcml2YXRlIHBsdWdpbjogVGFza3NQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgc2V0dGluZ3M6IFNldHRpbmdzLCBwbHVnaW46IFRhc2tzUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cbiAgICAgICAgLy8gRWRpdG9yU3VnZ2VzdG9yIHN3YWxsb3dzIHRhYnMgd2hpbGUgdGhlIHN1Z2dlc3RvciBwb3B1cCBpcyBvcGVuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIHN1cHBvcnQgaW5kZW50aW5nIHdoaWxlIHBvcHVwIGlzIG9wZW5cbiAgICAgICAgYXBwLnNjb3BlLnJlZ2lzdGVyKFtdLCAnVGFiJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0Py5lZGl0b3I7XG4gICAgICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWMoJ2luZGVudE1vcmUnKTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5pbmcgZmFsc2UgdHJpZ2dlcnMgcHJldmVudERlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgcHJldmVudCBkb3VibGUgaW5kZW50IGlmIHRhYnMgc3RhcnQgdG8gZ2V0IHBhc3NlZCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uVHJpZ2dlcihjdXJzb3I6IEVkaXRvclBvc2l0aW9uLCBlZGl0b3I6IEVkaXRvciwgX2ZpbGU6IFRGaWxlKTogRWRpdG9yU3VnZ2VzdFRyaWdnZXJJbmZvIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hdXRvU3VnZ2VzdEluRWRpdG9yKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICAgICAgaWYgKGNhblN1Z2dlc3RGb3JMaW5lKGxpbmUsIGN1cnNvciwgZWRpdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydDogeyBsaW5lOiBjdXJzb3IubGluZSwgY2g6IDAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogY3Vyc29yLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBsaW5lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRTdWdnZXN0aW9ucyhjb250ZXh0OiBFZGl0b3JTdWdnZXN0Q29udGV4dCk6IFN1Z2dlc3RJbmZvV2l0aENvbnRleHRbXSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBjb250ZXh0LnF1ZXJ5O1xuICAgICAgICBjb25zdCBjdXJyZW50Q3Vyc29yID0gY29udGV4dC5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGNvbnN0IGFsbFRhc2tzID0gdGhpcy5wbHVnaW4uZ2V0VGFza3MoKTtcblxuICAgICAgICBjb25zdCB0YXNrVG9TdWdnZXN0Rm9yID0gYWxsVGFza3MuZmluZChcbiAgICAgICAgICAgICh0YXNrKSA9PiB0YXNrLnRhc2tMb2NhdGlvbi5wYXRoID09IGNvbnRleHQuZmlsZS5wYXRoICYmIHRhc2sudGFza0xvY2F0aW9uLmxpbmVOdW1iZXIgPT0gY3VycmVudEN1cnNvci5saW5lLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID1cbiAgICAgICAgICAgIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQoKS5idWlsZFN1Z2dlc3Rpb25zPy4oXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q3Vyc29yLmNoLFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgYWxsVGFza3MsXG4gICAgICAgICAgICAgICAgdGFza1RvU3VnZ2VzdEZvcixcbiAgICAgICAgICAgICkgPz8gW107XG5cbiAgICAgICAgLy8gQWRkIHRoZSBlZGl0b3IgY29udGV4dCB0byBhbGwgdGhlIHN1Z2dlc3Rpb25zXG4gICAgICAgIHJldHVybiBzdWdnZXN0aW9ucy5tYXAoKHMpID0+ICh7IC4uLnMsIGNvbnRleHQgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlclN1Z2dlc3Rpb24odmFsdWU6IFN1Z2dlc3RJbmZvV2l0aENvbnRleHQsIGVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBlbC5zZXRUZXh0KHZhbHVlLmRpc3BsYXlUZXh0KTtcbiAgICB9XG5cbiAgICBhc3luYyBzZWxlY3RTdWdnZXN0aW9uKHZhbHVlOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0LCBfZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB2YWx1ZS5jb250ZXh0LmVkaXRvcjtcblxuICAgICAgICBpZiAodmFsdWUuc3VnZ2VzdGlvblR5cGUgPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBzdWdnZXN0aW9uIGRpYWxvZyBhbmQgc2ltdWxhdGUgYW4gRW50ZXIgcHJlc3MgdG8gdGhlIGVkaXRvclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRDbG9uZSA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdFbnRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnRW50ZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoZWRpdG9yIGFzIGFueSk/LmNtPy5jb250ZW50RE9NPy5kaXNwYXRjaEV2ZW50KGV2ZW50Q2xvbmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnRhc2tJdERlcGVuZHNPbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUYXNrID0gZW5zdXJlVGFza0hhc0lkKFxuICAgICAgICAgICAgICAgIHZhbHVlLnRhc2tJdERlcGVuZHNPbixcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5nZXRUYXNrcygpLm1hcCgodGFzaykgPT4gdGFzay5pZCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFsdWUuYXBwZW5kVGV4dCArPSBgICR7bmV3VGFzay5pZH1gO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUuY29udGV4dC5maWxlLmJhc2VuYW1lID09IG5ld1Rhc2suZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBcIkhhcyBCZWVuIE1vZGlmZWQgRXh0ZXJuYWxseSBFcnJvclwiIGFuZCBSZXBsYWNlIFRhc2sgaW4gRWRpdG9yIENvbnRleHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZS50YXNrSXREZXBlbmRzT24udG9GaWxlTGluZVN0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdmFsdWUudGFza0l0RGVwZW5kc09uLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiB2YWx1ZS50YXNrSXREZXBlbmRzT24ubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY2g6IHZhbHVlLnRhc2tJdERlcGVuZHNPbi50b0ZpbGVMaW5lU3RyaW5nKCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFsdWUuY29udGV4dC5lZGl0b3IucmVwbGFjZVJhbmdlKG5ld1Rhc2sudG9GaWxlTGluZVN0cmluZygpLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBUYXNrIGluIEZpbGUgQ29udGV4dFxuICAgICAgICAgICAgICAgIHJlcGxhY2VUYXNrV2l0aFRhc2tzKHsgb3JpZ2luYWxUYXNrOiB2YWx1ZS50YXNrSXREZXBlbmRzT24sIG5ld1Rhc2tzOiBuZXdUYXNrIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IHZhbHVlLmNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBjb25zdCByZXBsYWNlRnJvbSA9IHtcbiAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgIGNoOiB2YWx1ZS5pbnNlcnRBdCA/PyBjdXJyZW50Q3Vyc29yLmNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXBsYWNlVG8gPSB2YWx1ZS5pbnNlcnRTa2lwXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgICAgICAgIGNoOiByZXBsYWNlRnJvbS5jaCArIHZhbHVlLmluc2VydFNraXAsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB2YWx1ZS5jb250ZXh0LmVkaXRvci5yZXBsYWNlUmFuZ2UodmFsdWUuYXBwZW5kVGV4dCwgcmVwbGFjZUZyb20sIHJlcGxhY2VUbyk7XG4gICAgICAgIHZhbHVlLmNvbnRleHQuZWRpdG9yLnNldEN1cnNvcih7XG4gICAgICAgICAgICBsaW5lOiBjdXJyZW50Q3Vyc29yLmxpbmUsXG4gICAgICAgICAgICBjaDogcmVwbGFjZUZyb20uY2ggKyB2YWx1ZS5hcHBlbmRUZXh0Lmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzay9UYXNrJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgdG8gcmVtb3ZlIGFsbCByZWZlcmVuY2VzIHRvIHtUYXNrTW9kYWx9IGluIHRoaXMgZmlsZS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIG1ha2Uge2NyZWF0ZVRhc2tMaW5lTW9kYWx9IHRlc3RhYmxlLlxuICogT25jZSBKZXN0IGlzIGNvbmZpZ3VyZWQgdG8gd29yayB3aXRoIFN2ZWx0ZSwgdGhpcyBjYW4gYmUgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVGFza01vZGFsIHtcbiAgICBvcGVuKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogU2lnbmF0dXJlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZCBmb3Ige0BsaW5rIFRhc2tNb2RhbH0uXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYWtlIHtAbGluayBjcmVhdGVUYXNrTGluZU1vZGFsfSB0ZXN0YWJsZS5cbiAqIE9uY2UgSmVzdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgd2l0aCBTdmVsdGUsIHRoaXMgY2FuIGJlIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIHRhc2tNb2RhbEZhY3RvcnkgPSB7XG4gICAgKGFwcDogQXBwLCBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkKTogSVRhc2tNb2RhbDtcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIFRhc2tzIFVJIGFuZCByZXR1cm5zIHRoZSBNYXJrZG93biBzdHJpbmcgZm9yIHRoZSB0YXNrIGVudGVyZWQuXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHBcbiAqIEBwYXJhbSB0YXNrTW9kYWxGYWN0b3J5IC0gRmFjdG9yeSBtZXRob2QgdG8gaW5zdGFudGlhdGUge0BsaW5rIFRhc2tNb2RhbH0uIERlZmF1bHQgdmFsdWUgaXMge0BsaW5rIGRlZmF1bHRUYXNrTW9kYWxGYWN0b3J5fS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgVXNlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBNYXJrZG93biBzdHJpbmcgZm9yIHRoZSB0YXNrIGVudGVyZWQgb3JcbiAqIGFuIGVtcHR5IHN0cmluZywgaWYgZGF0YSBlbnRyeSB3YXMgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGFza0xpbmVNb2RhbCA9IChhcHA6IEFwcCwgdGFza01vZGFsRmFjdG9yeTogdGFza01vZGFsRmFjdG9yeSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlOiAoaW5wdXQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICBjb25zdCB3YWl0Rm9yQ2xvc2UgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfKSA9PiB7XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uU3VibWl0ID0gKHVwZGF0ZWRUYXNrczogVGFza1tdKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB1cGRhdGVkVGFza3MubWFwKCh0YXNrOiBUYXNrKSA9PiB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSkuam9pbignXFxuJyk7XG4gICAgICAgIHJlc29sdmVQcm9taXNlKGxpbmUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0YXNrTW9kYWwgPSB0YXNrTW9kYWxGYWN0b3J5KGFwcCwgb25TdWJtaXQpO1xuICAgIHRhc2tNb2RhbC5vcGVuKCk7XG4gICAgcmV0dXJuIHdhaXRGb3JDbG9zZTtcbn07XG4iLCAiaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrL1Rhc2snO1xuaW1wb3J0IHsgdGFza0Zyb21MaW5lIH0gZnJvbSAnLi4vQ29tbWFuZHMvQ3JlYXRlT3JFZGl0VGFza1BhcnNlcic7XG5pbXBvcnQgeyBUYXNrTW9kYWwgfSBmcm9tICcuLi9PYnNpZGlhbi9UYXNrTW9kYWwnO1xuaW1wb3J0IHR5cGUgeyBJVGFza01vZGFsLCB0YXNrTW9kYWxGYWN0b3J5IH0gZnJvbSAnLi9jcmVhdGVUYXNrTGluZU1vZGFsJztcblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcge0BsaW5rIFRhc2tNb2RhbH0uXG4gKlxuICogVGhlIGN1cnJlbnQgc2V0dXAgb2YgSmVzdCBkb2VzIG5vdCB3b3JrIHdpdGggU3ZlbHRlLCB0aGVyZWZvcmUgaXQgaXMgbmVjZXNzYXJ5IHRvIHJlbW92ZVxuICogYWxsIGNvZGUgcmVmZXJlbmNpbmcge0BsaW5rIEVkaXRUYXNrfSBmcm9tIHRoZSBmaWxlIHtAbGluayBjcmVhdGVUYXNrTGluZU1vZGFsfSBsaXZlcyBpbiwgdG8gbWFrZSBpdCB0ZXN0YWJsZS5cbiAqIE9uY2UgSmVzdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgd2l0aCBTdmVsdGUsIHRoaXMgY2FuIGJlIG1vdmVkIGluIHRoZSBzYW1lIGZpbGUgYXMge0BsaW5rIGNyZWF0ZVRhc2tMaW5lTW9kYWx9LlxuICpcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwXG4gKiBAcGFyYW0gb25TdWJtaXQgLSBDYWxsYmFjayB0byBiZSBydW4gd2hlbiB0aGUge0BsaW5rIEVkaXRUYXNrfSBmb3JtIGlzIHN1Ym1pdHRlZCB0byByZXRyaWV2ZSB0aGUgZWRpdGVkIHRhc2suXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGFza01vZGFsRmFjdG9yeTogdGFza01vZGFsRmFjdG9yeSA9IChcbiAgICBhcHA6IEFwcCxcbiAgICBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkLFxuKTogSVRhc2tNb2RhbCA9PiB7XG4gICAgY29uc3QgdGFzayA9IHRhc2tGcm9tTGluZSh7IGxpbmU6ICcnLCBwYXRoOiAnJyB9KTtcbiAgICAvLyBUT0RPIFRoaXMgaXMgZ29pbmcgdG8gbmVlZCBzb21lIHRob3VnaHQuIEl0IGlzIG1pc3NpbmcgdGhlIENhY2hlIGFyZ3VtZW50LlxuICAgIC8vICAgICAgVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIFRhc2tzIEFQSSB0aGF0IGFsbG93cyB1c2VycyB0byBvcGVuIHRoZSBFZGl0IFRhc2sgbW9kYWwgZnJvbSBKYXZhU2NyaXB0OlxuICAgIC8vICAgICAgICAgIGh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9BZHZhbmNlZC9UYXNrcytBcGlcbiAgICAvLyAgICAgIEFzIGEgcHVibGlzaGVkIEFQSSwgdG8gY2hhbmdlIHRoZSBwYXJhbWV0ZXJzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICAgIC8vICAgICAgT25lIG9wdGlvbiBpcyB0byBtYWtlIHRoZSBhbGxUYXNrcyBwYXJhbWV0ZXIgdG8gdGhlIEVkaXQgdGFzayBtb2RhbCBiZSBvcHRpb25hbCxcbiAgICAvLyAgICAgIGFuZCBpZiBpdCdzIG5vdCBwcm92aWRlZCwgdGhlbiBoaWRlIHRoZSBkZXBlbmRlbmN5IGZpZWxkcyBpbiB0aGUgbW9kYWwuXG4gICAgLy8gICAgICBGb3Igbm93LCB3ZSBwYXNzIGluIGFuIGVtcHR5IGxpc3Qgb2YgdGFza3MuXG4gICAgcmV0dXJuIG5ldyBUYXNrTW9kYWwoeyBhcHAsIHRhc2ssIG9uU3VibWl0LCBhbGxUYXNrczogW10gfSkgYXMgSVRhc2tNb2RhbDtcbn07XG4iLCAiaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyB0b2dnbGVMaW5lIH0gZnJvbSAnLi4vQ29tbWFuZHMvVG9nZ2xlRG9uZSc7XG5pbXBvcnQgeyBjcmVhdGVUYXNrTGluZU1vZGFsIH0gZnJvbSAnLi9jcmVhdGVUYXNrTGluZU1vZGFsJztcbmltcG9ydCB0eXBlIHsgVGFza3NBcGlWMSB9IGZyb20gJy4vVGFza3NBcGlWMSc7XG5pbXBvcnQgeyBkZWZhdWx0VGFza01vZGFsRmFjdG9yeSB9IGZyb20gJy4vY3JlYXRlVGFza0xpbmVNb2RhbEhlbHBlcic7XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgZm9yIEFQSSB2MVxuICpcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwXG4gKi9cbmV4cG9ydCBjb25zdCB0YXNrc0FwaVYxID0gKGFwcDogQXBwKTogVGFza3NBcGlWMSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlVGFza0xpbmVNb2RhbDogKCk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVGFza0xpbmVNb2RhbChhcHAsIGRlZmF1bHRUYXNrTW9kYWxGYWN0b3J5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhlY3V0ZVRvZ2dsZVRhc2tEb25lQ29tbWFuZDogKGxpbmU6IHN0cmluZywgcGF0aDogc3RyaW5nKSA9PiB0b2dnbGVMaW5lKGxpbmUsIHBhdGgpLnRleHQsXG4gICAgfTtcbn07XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxhQUFnQix3QkFBd0IsUUFBZ0IsdUJBQTZCO0FBQ2pGLFlBQU0saUNBQWlDLHNCQUFzQixRQUFRLGFBQWEsS0FBSztBQUN2RixhQUFPLEdBQUcsU0FBUyxzREFBc0Q7SUFDN0U7QUFIQSxZQUFBLDBCQUFBO0FBS0EsYUFBZ0IsYUFBYSxZQUEwQjtBQUNuRCxVQUFJO0FBQ0osVUFBSSxzQkFBc0IsT0FBTztBQUM3QixlQUFPLENBQUMsR0FBRyxVQUFVO2lCQUNkLHNCQUFzQixLQUFLO0FBQ2xDLGVBQU8sTUFBTSxLQUFNLFdBQW9DLEtBQUksQ0FBRTthQUMxRDtBQUNILGVBQU8sT0FBTyxLQUFLLFVBQVU7O0FBR2pDLGFBQU87SUFDWDtBQVhBLFlBQUEsZUFBQTtBQWFBLGFBQWdCLGdCQUFnQixZQUEwQjtBQUd0RCxZQUFNLGNBQWMsYUFBYSxVQUFVLEVBQ3RDLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUNsQyxLQUFLLEdBQUcsRUFDUixRQUFRLE9BQU8sS0FBSztBQUV6QixhQUFPLE1BQU07SUFDakI7QUFUQSxZQUFBLGtCQUFBOzs7OztBQ3BCQTtBQUFBLDZDQUFBQSxTQUFBO0FBQUEsS0FBQyxTQUFTLEdBQUUsR0FBRTtBQUFDLGtCQUFVLE9BQU8sV0FBUyxlQUFhLE9BQU9BLFVBQU9BLFFBQU8sVUFBUSxFQUFFLElBQUUsY0FBWSxPQUFPLFVBQVEsT0FBTyxNQUFJLE9BQU8sQ0FBQyxLQUFHLElBQUUsZUFBYSxPQUFPLGFBQVcsYUFBVyxLQUFHLE1BQU0sUUFBTSxFQUFFO0FBQUEsSUFBQyxFQUFFLFNBQU0sV0FBVTtBQUFDO0FBQWEsVUFBSSxJQUFFLEtBQUksSUFBRSxLQUFJLElBQUUsTUFBSyxJQUFFLGVBQWMsSUFBRSxVQUFTLElBQUUsVUFBUyxJQUFFLFFBQU8sSUFBRSxPQUFNLElBQUUsUUFBTyxJQUFFLFNBQVEsSUFBRSxXQUFVLElBQUUsUUFBTyxJQUFFLFFBQU8sSUFBRSxnQkFBZSxJQUFFLDhGQUE2RixJQUFFLHVGQUFzRixJQUFFLEVBQUMsTUFBSyxNQUFLLFVBQVMsMkRBQTJELE1BQU0sR0FBRyxHQUFFLFFBQU8sd0ZBQXdGLE1BQU0sR0FBRyxFQUFDLEdBQUUsSUFBRSxTQUFTQyxJQUFFQyxJQUFFQyxJQUFFO0FBQUMsWUFBSUMsS0FBRSxPQUFPSCxFQUFDO0FBQUUsZUFBTSxDQUFDRyxNQUFHQSxHQUFFLFVBQVFGLEtBQUVELEtBQUUsS0FBRyxNQUFNQyxLQUFFLElBQUVFLEdBQUUsTUFBTSxFQUFFLEtBQUtELEVBQUMsSUFBRUY7QUFBQSxNQUFDLEdBQUUsSUFBRSxFQUFDLEdBQUUsR0FBRSxHQUFFLFNBQVNBLElBQUU7QUFBQyxZQUFJQyxLQUFFLENBQUNELEdBQUUsVUFBVSxHQUFFRSxLQUFFLEtBQUssSUFBSUQsRUFBQyxHQUFFRSxLQUFFLEtBQUssTUFBTUQsS0FBRSxFQUFFLEdBQUVFLEtBQUVGLEtBQUU7QUFBRyxnQkFBT0QsTUFBRyxJQUFFLE1BQUksT0FBSyxFQUFFRSxJQUFFLEdBQUUsR0FBRyxJQUFFLE1BQUksRUFBRUMsSUFBRSxHQUFFLEdBQUc7QUFBQSxNQUFDLEdBQUUsR0FBRSxTQUFTSixHQUFFQyxJQUFFQyxJQUFFO0FBQUMsWUFBR0QsR0FBRSxLQUFLLElBQUVDLEdBQUUsS0FBSztBQUFFLGlCQUFNLENBQUNGLEdBQUVFLElBQUVELEVBQUM7QUFBRSxZQUFJRSxLQUFFLE1BQUlELEdBQUUsS0FBSyxJQUFFRCxHQUFFLEtBQUssTUFBSUMsR0FBRSxNQUFNLElBQUVELEdBQUUsTUFBTSxJQUFHRyxLQUFFSCxHQUFFLE1BQU0sRUFBRSxJQUFJRSxJQUFFLENBQUMsR0FBRUUsS0FBRUgsS0FBRUUsS0FBRSxHQUFFRSxLQUFFTCxHQUFFLE1BQU0sRUFBRSxJQUFJRSxNQUFHRSxLQUFFLEtBQUcsSUFBRyxDQUFDO0FBQUUsZUFBTSxFQUFFLEVBQUVGLE1BQUdELEtBQUVFLE9BQUlDLEtBQUVELEtBQUVFLEtBQUVBLEtBQUVGLFFBQUs7QUFBQSxNQUFFLEdBQUUsR0FBRSxTQUFTSixJQUFFO0FBQUMsZUFBT0EsS0FBRSxJQUFFLEtBQUssS0FBS0EsRUFBQyxLQUFHLElBQUUsS0FBSyxNQUFNQSxFQUFDO0FBQUEsTUFBQyxHQUFFLEdBQUUsU0FBU0EsSUFBRTtBQUFDLGVBQU0sRUFBQyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEVBQUMsRUFBRUEsT0FBSSxPQUFPQSxNQUFHLEVBQUUsRUFBRSxZQUFZLEVBQUUsUUFBUSxNQUFLLEVBQUU7QUFBQSxNQUFDLEdBQUUsR0FBRSxTQUFTQSxJQUFFO0FBQUMsZUFBTyxXQUFTQTtBQUFBLE1BQUMsRUFBQyxHQUFFLElBQUUsTUFBSyxJ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TixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsT0FBTztNQUNQLE9BQU87TUFDUCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsSUFBSTtNQUNKLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFD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TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsSUFBSTtNQUNKLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7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LHNCQUFVLE1BQU0sVUFBVSxDQUFDO0FBQzNCLHNCQUFVLE1BQU0sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN2QztlQUVDO0FBQ0Qsc0JBQVUsTUFBTSxRQUFRLENBQUM7QUFDekIsc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxZQUFZLFFBQUEsU0FBUyxFQUFFO0FBQ3ZDO2VBRUM7ZUFDQTtBQUNELHNCQUFVLE1BQU0sUUFBUSxFQUFFO0FBQzFCLHNCQUFVLE1BQU0sVUFBVSxDQUFDO0FBQzNCLHNCQUFVLE1BQU0sVUFBVSxDQUFDO0FBQzNCLHNCQUFVLE1BQU0sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN2QztlQUVDO0FBQ0Qsc0JBQVUsTUFBTSxRQUFRLEVBQUU7QUFDMUIsc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxZQUFZLFFBQUEsU0FBUyxFQUFFO0FBQ3ZDO2VBRUM7QUFDRCxzQkFBVSxNQUFNLFFBQVEsRUFBRTtBQUMxQixzQkFBVSxNQUFNLFVBQVUsQ0FBQztBQUMzQixzQkFBVSxNQUFNLFVBQVUsQ0FBQztBQUMzQixzQkFBVSxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7QUFDdkM7ZUFFQztBQUNELHNCQUFVLE1BQU0sUUFBUSxFQUFFO0FBQzFCLHNCQUFVLE1BQU0sVUFBVSxDQUFDO0FBQzNCLHNCQUFVLE1BQU0sVUFBVSxDQUFDO0FBQzNCLHNCQUFVLE1BQU0sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN2QztlQUVDO0FBQ0QsZ0JBQUksVUFBVSxJQUFJLE1BQU0sSUFBSSxHQUFHO0FBQzNCLDBCQUFZLFlBQUEsb0JBQW9CLFdBQVcsRUFBRSxPQUFPLEVBQUMsQ0FBRTs7QUFHM0Qsc0JBQVUsTUFBTSxRQUFRLENBQUM7QUFDekIsc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxVQUFVLENBQUM7QUFDM0Isc0JBQVUsTUFBTSxZ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QUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsQ0FBQSxHQUNULE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFBQSxHQUNkLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFBQSxHQUNkLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFBQSxHQUNkLE9BQU8sR0FBRyxDQUFDLEdBQUMsSUFBQTtBQUdqQixJQUFNLFdBQVEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxDQUFBLEdBQ1QsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxHQUFHLEVBQUUsR0FBQyxJQUFBLEdBQ2IsT0FBTyxJQUFJLEVBQUUsR0FBQyxJQUFBLEdBQ2QsT0FBTyxJQUFJLEVBQUUsR0FBQyxJQUFBLEdBQ2QsT0FBTyxJQUFJLEVBQUUsR0FBQyxJQUFBLEdBQ2QsT0FBTyxHQUFHLENBQUMsR0FBQyxJQUFBO0FBR2pC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QUFBLElBQ3hCLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3ZCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLEVBQzdCO0FBQ0EsU0FBTztBQUNYOzs7QUN6Qk8sU0FBUywyQkFBMkI7QUFDdkMsUUFBTSxNQUF3QjtBQUFBLElBQzFCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxjQUFjLEtBQUssYUFBYTtBQUFBLElBQ3RDLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxZQUFZLEtBQUssV0FBVztBQUFBLElBQ2xDLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxjQUFjLEtBQUssTUFBTTtBQUFBLElBQy9CLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxlQUFlLEtBQUssTUFBTTtBQUFBLElBQ2hDLENBQUMsS0FBSyxXQUFXLEtBQUssTUFBTTtBQUFBLElBQzVCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3ZCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLEVBQzdCO0FBQ0EsU0FBTztBQUNYOzs7QUMzQk8sU0FBUywwQkFBMEI7QUFDdEMsUUFBTSxNQUF3QjtBQUFBLElBRTFCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxjQUFjLEtBQUssYUFBYTtBQUFBLElBQ3RDLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxZQUFZLEtBQUssV0FBVztBQUFBLElBQ2xDLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxjQUFjLEtBQUssTUFBTTtBQUFBLElBRS9CLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxlQUFlLEtBQUssTUFBTTtBQUFBLElBQ2hDLENBQUMsS0FBSyxXQUFXLEtBQUssTUFBTTtBQUFBLElBQzVCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3ZCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLEVBQzdCO0FBQ0EsU0FB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QUNaLE9BQU87QUFDSCxhQUFPLEtBQUssTUFBTSxTQUFTO0FBQUEsSUFDL0I7QUFBQSxFQUNKO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJ0IiwgImUiLCAibiIsICJyIiwgImkiLCAicyIsICJ1IiwgIk0iLCAibSIsICJoIiwgIiQiLCAibCIsICJ5IiwgImciLCAiRCIsICJ2IiwgIm8iLCAiZCIsICJhIiwgImYiLCAiYyIsICJtb2R1bGUiLCAidCIsICJlIiwgImkiLCAiciIsICJzIiwgInRleHQiLCAidGV4dCIsICJGaWx0ZXIiLCAiX2EiLCAib2Zmc2V0IiwgIm9mZnNldCIsICJvZmZzZXQiLCAidGV4dCIsICJ0ZXh0IiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgIm9mZnNldCIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJvZmZzZXQiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAidGV4dCIsICJ0ZXh0IiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgIm9mZnNldCIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJvZmZzZXQiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAidGV4dCIsICJvZmZzZXQiLCAib2Zmc2V0IiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgInRleHQiLCAib2Zmc2V0IiwgIm9mZnNldCIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJvZmZzZXQiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiTWVyaWRpZW0iLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAibW9kdWxlIiwgInVuZGVmaW5lZCIsICJpc0FycmF5IiwgImluaXQiLCAidG9BcnJheSIsICJQcm9taXNlIiwgInJlamVjdCIsICJldmVudCIsICJsaXN0ZW4iLCAiZXZlbnRzIiwgInNlbGYiLCAicmVxdWlyZV9kaXN0IiwgIk9wZXJhdG9ycyIsICJTdHJ1Y3R1cmFsQ2hhcmFjdGVycyIsICJUb2tlbnMiLCAicmVxdWlyZV9jb25zdCIsICJfX2Fzc2lnbiIsICJyZXF1aXJlX3V0aWxzIiwgIl9fc3ByZWFkQXJyYXkiLCAiX19zcHJlYWRBcnJheSIsICJwYXJzZSIsICJyZXF1aXJlX3V0aWxzIiwgInJlcXVpcmVfY29uc3QiLCAiX19zcHJlYWRBcnJheSIsICJldmFsdWF0ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJhbmdlIiwgInJhbmdlIiwgIldlZWtkYXkiLCAidHpPZmZzZXQiLCAiSXRlclJlc3VsdCIsICJkIiwgImIiLCAiX19hc3NpZ24iLCAiQ2FsbGJhY2tJdGVyUmVzdWx0IiwgIlRvVGV4dCIsICJQYXJzZXIiLCAidGV4dCIsICJGcmVxdWVuY3kiLCAidGV4dCIsICJUaW1lIiwgIkRhdGVUaW1lIiwgImF0dHIiLCAiRGF0ZVdpdGhab25lIiwgImRlZmF1bHRLZXlzIiwgImtleSIsICJ2YWx1ZSIsICJDYWNoZSIsICJpdGVtIiwgImkiLCAib2Zmc2V0IiwgIkl0ZXJpbmZvIiwgIlJSdWxlIiwgInRleHQiLCAiem9uZWREYXRlIiwgIkRFRkFVTFRfT1BUSU9OUyIsICJ2YWwiLCAiaW5pdGlhbGl6ZU9wdGlvbnMiLCAiZGVmYXVsdEtleXMiLCAiUlJ1bGVTZXQiLCAiY2hyb25vIiwgInRleHQiLCAiVGFza0xheW91dENvbXBvbmVudCIsICJzZXR0aW5ncyIsICJsaW5lIiwgIlN0YXR1c1R5cGUiLCAiZGVmYXVsdFNldHRpbmdzIiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm1vZHVsZSIsICJjaGlsZHJlbiIsICJlbGVtZW50IiwgIkNhY2hlIiwgIm1ldGFkYXRhQ2FjaGUiLCAidmF1bHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJlbGVtZW50IiwgIl9hIiwgImVtcHR5IiwgImVsZW1lbnQiLCAidGV4dCIsICJjcm9zc29yaWdpbiIsICJlbGVtZW50IiwgImRldGFjaCIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiYXR0ciIsICJpbXBvcnRfb2JzaWRpYW4iLCAidmF1bHQiLCAibWV0YWRhdGFDYWNoZSIsICJ3b3Jrc3BhY2UiLCAidGV4dCIsICJjdHgiLCAicGxhdGZvcm0iLCAiZWxlbWVudCIsICJwbGF0Zm9ybSIsICJfYSIsICJwbGFjZW1lbnRzIiwgInNpZGVzIiwgInNpZGUiLCAicGxhY2VtZW50IiwgIm92ZXJmbG93IiwgInBsYXRmb3JtIiwgInJhd1ZhbHVlIiwgIl9hIiwgIngiLCAieSIsICJtaW4iLCAibWF4IiwgInBsYXRmb3JtIiwgIl9hIiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImdldENvbXB1dGVkU3R5bGUiLCAid2luZG93IiwgImNvbXB1dGVQb3NpdGlvbiIsICJjdHgiLCAidGFzayIsICJzZWFyY2giLCAiaW5wdXQiLCAiZHJvcGRvd24iLCAiY29tcHV0ZVBvc2l0aW9uIiwgImVsZW1lbnQiLCAidGV4dCIsICJjdHgiLCAiY3R4IiwgImN0eCIsICJjcmVhdGVfaWZfYmxvY2tfMiIsICJ0YXNrIiwgImFwcCIsICJhcHAiLCAidGFzayIsICJpbXBvcnRfb2JzaWRpYW4iLCAidGV4dCIsICJpc0FycmF5IiwgImVzY2FwZVJlZ0V4cCIsICJwYXJzZSIsICJzZWxmIiwgImNsZWFyQ2FjaGUiLCAicmVuZGVyIiwgInRleHQiLCAicHJveHlEYXRhIiwgInRleHQiLCAiY2hpbGRyZW4iLCAiYm9vblBhcnNlIiwgImxpbmUiLCAiaGlkZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJlbGVtZW50IiwgImRhdGUiLCAidGV4dCIsICJlbGVtZW50IiwgInBFbGVtZW50IiwgInRvb2x0aXAiLCAiZWxlbWVudCIsICJfYSIsICJzZWN0aW9uSW5kZXgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJoaWRlIiwgImhpZGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImJ1dHRvbiIsICJwb3N0cG9uaW5nRnVuY3Rpb24iLCAiZWxlbWVudCIsICJhcHAiLCAidGV4dCIsICJ2YXVsdCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInRleHQiLCAidXBkYXRlIiwgInRleHQiLCAic2V0dGluZ3MiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJzZXR0aW5ncyIsICJhcHAiLCAiYXBwIiwgImFwcCIsICJDYWNoZSJdCn0K
