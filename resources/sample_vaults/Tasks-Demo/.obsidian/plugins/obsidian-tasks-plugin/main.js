/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

/*
License obsidian-tasks:
MIT License

Copyright (c) 2021 Martin Schenck and Clare Macrae

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
License rrule (included library):
rrule.js: Library for working with recurrence rules for calendar dates.
=======================================================================

Copyright 2010, Jakub Roztocil <jakub@roztocil.name> and Lars Schöning

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of The author nor the names of its contributors may
       be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



./rrule.js and ./test/tests.js is based on python-dateutil. LICENCE:

python-dateutil - Extensions to the standard Python datetime module.
====================================================================

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
License chrono-node (included library):
The MIT License

Copyright (c) 2014, Wanasit Tanakitrungruang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, g = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function(t2, e2, n2) {
        var r2;
        if (!t2)
          return D;
        if ("string" == typeof t2)
          v[t2] && (r2 = t2), e2 && (v[t2] = e2, r2 = t2);
        else {
          var i2 = t2.name;
          v[i2] = t2, r2 = i2;
        }
        return !n2 && r2 && (D = r2), r2 || !n2 && D;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match(l);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), $2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, l2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $2(1, 0) : $2(31, 11);
            case f:
              return r2 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
              return $2(r2 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $2 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y2 = function(t2) {
            var e2 = w($2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || $;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || l2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b = _.prototype;
      return w.prototype = b, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        b[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault2(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault2(require_quarterOfYear());
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference, knownComponents) {
        this.reference = reference;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        return new Date(date.getTime() + this.getSystemTimezoneAdjustmentMinute(date) * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      getSystemTimezoneAdjustmentMinute(date) {
        var _a, _b;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_b = (_a = this.get("timezoneOffset")) !== null && _a !== void 0 ? _a : this.reference.timezoneOffset) !== null && _b !== void 0 ? _b : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
      static createRelativeFromReference(reference, fragments) {
        let date = dayjs_1.default(reference.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference, index, text2, start, end) {
        this.reference = reference;
        this.refDate = reference.instant;
        this.index = index;
        this.text = text2;
        this.start = start || new ParsingComponents(reference);
        this.end = end;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context) {
        const innerPattern = this.innerPattern(context);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i = 2; i < match.length; i++) {
          match[i - 1] = match[i];
        }
        return this.innerExtract(context, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context, match) {
        const startComponents = this.extractPrimaryTimeComponents(context, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text2 = match[0].substring(match[1].length);
        const result = context.createParsingResult(index, text2, startComponents);
        match.index += match[0].length;
        const remainingText = context.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text2.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context, match, strict = false) {
        const components = context.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context, match, result) {
        const components = context.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter2 = class {
      refine(context, results) {
        return results.filter((r) => this.isValid(context, r));
      }
    };
    exports.Filter = Filter2;
    var MergingRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i = 1; i < results.length; i++) {
          nextResult = results[i];
          const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left = curResult;
            const right = nextResult;
            const mergedResult = this.mergeResults(textBetween, left, right, context);
            context.debug(() => {
              console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context, results) {
        var _a;
        const timezoneOverrides = (_a = context.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i = 1; i < results.length; i++) {
          const result = results[i];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context, results) {
        if (!context.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
              result.start.imply("year", result.start.get("year") + 1);
              context.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context, result);
        }
        return true;
      }
      isStrictModeValid(context, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset = hourOffset * 60;
            if (offset < 0) {
              offset -= minuteOffset;
            } else {
              offset += minuteOffset;
            }
            components["timezoneOffset"] = offset;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault2(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault2(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault2(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault2(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault2(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference) {
      return theDayBefore(reference, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference, numDay) {
      return theDayAfter(reference, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference) {
      return theDayAfter(reference, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference, nDays) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference, implyHour = 22) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference, implyHour = 0) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference, implyHour = 20) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context.reference);
          case "today":
            return references.today(context.reference);
          case "yesterday":
            return references.yesterday(context.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context.reference);
          case "tonight":
            return references.tonight(context.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/calculation/weeks.js
var require_weeks = __commonJS({
  "node_modules/chrono-node/dist/calculation/weeks.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDayJSClosestWeekday = exports.toDayJSWeekday = void 0;
    var dayjs_1 = __importDefault2(require_dayjs_min());
    function toDayJSWeekday(refDate, offset, modifier) {
      if (!modifier) {
        return toDayJSClosestWeekday(refDate, offset);
      }
      let date = dayjs_1.default(refDate);
      switch (modifier) {
        case "this":
          date = date.day(offset);
          break;
        case "next":
          date = date.day(offset + 7);
          break;
        case "last":
          date = date.day(offset - 7);
          break;
      }
      return date;
    }
    exports.toDayJSWeekday = toDayJSWeekday;
    function toDayJSClosestWeekday(refDate, offset) {
      let date = dayjs_1.default(refDate);
      const refOffset = date.day();
      if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset - 7);
      } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset + 7);
      } else {
        date = date.day(offset);
      }
      return date;
    }
    exports.toDayJSClosestWeekday = toDayJSClosestWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text2, referenceDate, option) {
        const results = this.parse(text2, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text2, referenceDate, option) {
        const context = new ParsingContext(text2, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a, b) => {
          return a.index - b.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context, results);
        });
        return results;
      }
      static executeParser(context, parser) {
        const results = [];
        const pattern = parser.pattern(context);
        const originalText = context.text;
        let remainingText = context.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context.createParsingResult(match.index, match[0], result);
          }
          context.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text2, refDate, option) {
        this.text = text2;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text2 = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start = startComponents ? this.createParsingComponents(startComponents) : null;
        const end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text2, start, end);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text2 = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text2.match(/^\d\.\d$/) || text2.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context.createParsingResult(index, text2);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault2(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault2(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault2(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault2(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault2(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault2(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault2(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault2(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault2(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault2(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault2(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault2(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault2(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault2(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault2(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault2(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var references = __importStar2(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context.reference);
            break;
          case "heute":
            component = references.today(context.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault2(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault2(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault2(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault2(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault2(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault2(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault2(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault2(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context.reference);
          case "aujourd'hui":
            return references.today(context.reference);
          case "hier":
            return references.yesterday(context.reference);
          case "demain":
            return references.tomorrow(context.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault2(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault2(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault2(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault2(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault2(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault2(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault2(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault2(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault2(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault2(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault2(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text2) {
      return String(text2).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment = dayjs_1.default(context.refDate);
          components.assign("year", moment.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const text2 = match[0];
        const date = dayjs_1.default(context.refDate);
        const components = context.createParsingComponents();
        switch (text2) {
          case "\u6628\u65E5":
            return references.yesterday(context.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context.reference);
        }
        if (text2 == "\u4ECA\u591C" || text2 == "\u4ECA\u5915" || text2 == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text2.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault2(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault2(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault2(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context.reference);
          case "hoje":
            return references.today(context.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context.reference);
          case "ontem":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_2.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault2(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault2(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault2(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault2(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault2(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault2(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault2(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context.reference);
          case "vandaag":
            return references.today(context.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context.reference);
          case "gisteren":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context.refDate.getDate());
          component.assign("month", context.refDate.getMonth() + 1);
          component.assign("year", context.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = context.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context.createParsingComponents();
        const targetDate = dayjs_2.default(context.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault2(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault2(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault2(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault2(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault2(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault2(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault2(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault2(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault2(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault2(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault2(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault2(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault2(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault2(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault2(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u5E7E") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault2(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault2(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault2(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault2(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault2(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault2(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault2(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault2(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u51E0") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault2(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault2(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault2(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault2(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault2(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault2(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault2(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault2(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar2(require_hant(), exports);
    exports.hans = __importStar2(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u0435\u043C\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var xf = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = xf;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        const lowerText = match[1].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_2.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault2(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault2(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault2(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault2(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault2(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault2(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault2(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault2(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault2(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault2(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault2(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar2(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var de = __importStar2(require_de());
    exports.de = de;
    var fr = __importStar2(require_fr());
    exports.fr = fr;
    var ja = __importStar2(require_ja());
    exports.ja = ja;
    var pt = __importStar2(require_pt());
    exports.pt = pt;
    var nl = __importStar2(require_nl());
    exports.nl = nl;
    var zh = __importStar2(require_zh());
    exports.zh = zh;
    var ru = __importStar2(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
  }
});

// node_modules/boon-js/lib/types.js
var require_types = __commonJS({
  "node_modules/boon-js/lib/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var Operators;
    (function(Operators2) {
      Operators2["AND"] = "AND";
      Operators2["OR"] = "OR";
      Operators2["XOR"] = "XOR";
      Operators2["NOT"] = "NOT";
    })(Operators = exports.Operators || (exports.Operators = {}));
    var StructuralCharacters;
    (function(StructuralCharacters2) {
      StructuralCharacters2["OPEN_PARENTHESIS"] = "(";
      StructuralCharacters2["CLOSE_PARENTHESIS"] = ")";
    })(StructuralCharacters = exports.StructuralCharacters || (exports.StructuralCharacters = {}));
    var Tokens;
    (function(Tokens2) {
      Tokens2["IDENTIFIER"] = "IDENTIFIER";
      Tokens2["OPERATOR"] = "OPERATOR";
      Tokens2["STRUCTURAL_CHARACTER"] = "STRUCTURAL_CHARACTER";
      Tokens2["EOF"] = "EOF";
      Tokens2["COMMENT"] = "COMMENT";
    })(Tokens = exports.Tokens || (exports.Tokens = {}));
  }
});

// node_modules/boon-js/lib/parse/const.js
var require_const = __commonJS({
  "node_modules/boon-js/lib/parse/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.OPERATOR_PRECEDENCE = {
      NOT: 0,
      XOR: 1,
      AND: 2,
      OR: 3
    };
    exports.VALID_TOKENS = {
      identifierOnly: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        }
      ],
      identifierOrNot: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }
      ],
      binaryOperator: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR }
      ],
      binaryOperatorOrClose: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.CLOSE_PARENTHESIS
        }
      ]
    };
  }
});

// node_modules/boon-js/lib/lex/const.js
var require_const2 = __commonJS({
  "node_modules/boon-js/lib/lex/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.STRUCTURAL_CHARACTERS = {
      "(": types_1.StructuralCharacters.OPEN_PARENTHESIS,
      ")": types_1.StructuralCharacters.CLOSE_PARENTHESIS
    };
    exports.OPERATORS = {
      AND: types_1.Operators.AND,
      OR: types_1.Operators.OR,
      XOR: types_1.Operators.XOR,
      NOT: types_1.Operators.NOT
    };
    exports.SEPARATORS = new Set([
      32,
      9,
      10,
      13
    ].map(function(separator) {
      return String.fromCodePoint(separator);
    }));
    exports.QUOTED_IDENTIFIER_DELIMITER = String.fromCodePoint(34);
    exports.COMMENT_DELIMITER = String.fromCodePoint(35);
    exports.EOL = String.fromCodePoint(10);
    exports.ESCAPE_CHARACTER = String.fromCodePoint(92);
  }
});

// node_modules/boon-js/lib/lex/utils.js
var require_utils = __commonJS({
  "node_modules/boon-js/lib/lex/utils.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const2();
    exports.createResult = function(name, value, remainingString) {
      return {
        token: __assign2({ name }, value !== null ? { value } : {}),
        remainingString
      };
    };
    exports.getComment = function(expression) {
      var tokenEnd = expression.length;
      for (var i = 0; i < expression.length; i += 1) {
        var letter = expression[i];
        if (letter === const_1.EOL) {
          tokenEnd = i;
          break;
        }
      }
      return exports.createResult(types_1.Tokens.COMMENT, expression.slice(0, tokenEnd), expression.slice(tokenEnd + 1));
    };
    exports.getQuotedIdentifier = function(expression) {
      var escapeQuotation = false;
      var value = "";
      var tokenEnd = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenEnd === null) {
          if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
            if (escapeQuotation) {
              value = value.slice(-1) + const_1.QUOTED_IDENTIFIER_DELIMITER;
            } else {
              tokenEnd = i;
            }
          } else {
            if (char === const_1.ESCAPE_CHARACTER) {
              escapeQuotation = true;
            } else {
              escapeQuotation = false;
            }
            value = value += char;
          }
        } else {
          if (!const_1.SEPARATORS.has(char) && !const_1.STRUCTURAL_CHARACTERS[char]) {
            throw new Error("Unexpected character: " + char + " Expected ) character or separator");
          }
          break;
        }
      }
      if (tokenEnd === null) {
        throw new Error("Unexpected end of expression: expected " + const_1.QUOTED_IDENTIFIER_DELIMITER + " character");
      }
      return exports.createResult(types_1.Tokens.IDENTIFIER, value, expression.slice(tokenEnd + 1));
    };
  }
});

// node_modules/boon-js/lib/lex/lex.js
var require_lex = __commonJS({
  "node_modules/boon-js/lib/lex/lex.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const2();
    var utils_1 = require_utils();
    exports.lex = function(expression) {
      var tokenStart = null;
      var tokenEnd = null;
      var delimitingCharacter = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenStart === null) {
          if (!const_1.SEPARATORS.has(char)) {
            var structuralChar = const_1.STRUCTURAL_CHARACTERS[char];
            if (structuralChar) {
              var nextChar = expression[i + 1];
              if (structuralChar === types_1.StructuralCharacters.CLOSE_PARENTHESIS && nextChar && !const_1.SEPARATORS.has(nextChar) && nextChar !== types_1.StructuralCharacters.CLOSE_PARENTHESIS) {
                throw new Error("Unexpected character: " + nextChar + ". A closing parenthesis should be followed by another closing parenthesis or whitespace");
              }
              return utils_1.createResult(types_1.Tokens.STRUCTURAL_CHARACTER, const_1.STRUCTURAL_CHARACTERS[char], expression.slice(i + 1));
            }
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
              return utils_1.getQuotedIdentifier(expression.slice(i + 1));
            }
            if (char === const_1.COMMENT_DELIMITER) {
              return utils_1.getComment(expression.slice(i + 1));
            }
            tokenStart = i;
          }
        } else {
          if (const_1.SEPARATORS.has(char) || const_1.STRUCTURAL_CHARACTERS[char]) {
            tokenEnd = i;
            delimitingCharacter = char;
            break;
          } else {
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER || char === const_1.COMMENT_DELIMITER) {
              throw new Error("Unexpected character: " + char);
            }
          }
        }
      }
      if (tokenStart !== null) {
        tokenEnd = tokenEnd !== null && tokenEnd !== void 0 ? tokenEnd : expression.length;
        var value = expression.slice(tokenStart, tokenEnd);
        var remainingString = expression.slice(tokenEnd);
        if (const_1.OPERATORS[value]) {
          if (delimitingCharacter && !const_1.SEPARATORS.has(delimitingCharacter)) {
            throw new Error("Unexpected character: " + delimitingCharacter + ". Operators should be separated using whitespace");
          }
          return utils_1.createResult(types_1.Tokens.OPERATOR, const_1.OPERATORS[value], remainingString);
        } else {
          return utils_1.createResult(types_1.Tokens.IDENTIFIER, value, remainingString);
        }
      }
      return utils_1.createResult(types_1.Tokens.EOF, null, "");
    };
  }
});

// node_modules/boon-js/lib/parse/utils.js
var require_utils2 = __commonJS({
  "node_modules/boon-js/lib/parse/utils.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var lex_1 = require_lex();
    var types_1 = require_types();
    var const_1 = require_const();
    exports.newTokenGenerator = function(expression) {
      var remainingExpression = expression;
      return function(validTokens, endIsValid) {
        if (endIsValid === void 0) {
          endIsValid = false;
        }
        while (true) {
          var _a = lex_1.lex(remainingExpression), token = _a.token, remainingString = _a.remainingString;
          remainingExpression = remainingString;
          if (token.name !== types_1.Tokens.COMMENT) {
            exports.validateToken(token, validTokens, endIsValid);
            return token;
          }
        }
      };
    };
    exports.getValue = function(getNextToken, parser) {
      var nextToken = getNextToken(const_1.VALID_TOKENS.identifierOrNot);
      var negatedValue = nextToken.value === types_1.Operators.NOT;
      if (negatedValue) {
        nextToken = getNextToken(const_1.VALID_TOKENS.identifierOnly);
      }
      var value = nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER ? parser(getNextToken, true) : [nextToken];
      return negatedValue ? __spreadArrays2(value, [{ name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }]) : value;
    };
    exports.previousOperatorTakesPrecedent = function(previousOperator, nextOperator) {
      return const_1.OPERATOR_PRECEDENCE[previousOperator] <= const_1.OPERATOR_PRECEDENCE[nextOperator];
    };
    exports.validateToken = function(token, validTokens, endIsValid) {
      if (endIsValid === void 0) {
        endIsValid = false;
      }
      if (token.name === types_1.Tokens.EOF) {
        if (endIsValid) {
          return;
        }
        throw new Error("Unexpected end of expression");
      }
      for (var _i = 0, validTokens_1 = validTokens; _i < validTokens_1.length; _i++) {
        var validToken = validTokens_1[_i];
        if (validToken.name === token.name) {
          if (!validToken.value || validToken.value === token.value) {
            return;
          }
        }
      }
      throw new TypeError("Invalid token");
    };
  }
});

// node_modules/boon-js/lib/parse/parse.js
var require_parse = __commonJS({
  "node_modules/boon-js/lib/parse/parse.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const();
    var utils_1 = require_utils2();
    exports.parse = function(expression) {
      if (typeof expression !== "string") {
        throw new Error("Expected string but received " + typeof expression);
      }
      var getNextToken = utils_1.newTokenGenerator(expression);
      return parseInternal(getNextToken);
    };
    var parseInternal = function(getNextToken, nested) {
      if (nested === void 0) {
        nested = false;
      }
      var output = __spreadArrays2(utils_1.getValue(getNextToken, parseInternal));
      var operators = [];
      while (true) {
        var validTokens = nested ? const_1.VALID_TOKENS.binaryOperatorOrClose : const_1.VALID_TOKENS.binaryOperator;
        var nextToken = getNextToken(validTokens, !nested);
        if (nextToken.name === types_1.Tokens.EOF || nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER) {
          return __spreadArrays2(output, __spreadArrays2(operators).reverse());
        }
        while (operators.length) {
          var previousOperator = operators[operators.length - 1] || null;
          if (previousOperator && utils_1.previousOperatorTakesPrecedent(previousOperator.value, nextToken.value)) {
            output = __spreadArrays2(output, [previousOperator]);
            operators = operators.slice(0, -1);
          } else {
            break;
          }
        }
        operators = __spreadArrays2(operators, [nextToken]);
        output = __spreadArrays2(output, utils_1.getValue(getNextToken, parseInternal));
      }
    };
  }
});

// node_modules/boon-js/lib/evaluate/utils.js
var require_utils3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.andUtil = function(left, right) {
      return left && right;
    };
    exports.orUtil = function(left, right) {
      return left || right;
    };
    exports.xorUtil = function(left, right) {
      return !(left === right);
    };
    exports.notUtil = function(identifier) {
      return !identifier;
    };
    exports.isIdentifier = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.IDENTIFIER && typeof value === "string";
    };
    exports.isOperator = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.OPERATOR && typeof value === "string";
    };
    exports.throwInvalidExpression = function(message) {
      throw new TypeError("Invalid postfix expression: " + message);
    };
  }
});

// node_modules/boon-js/lib/evaluate/const.js
var require_const3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/const.js"(exports) {
    "use strict";
    var _a;
    exports.__esModule = true;
    var types_1 = require_types();
    var utils_1 = require_utils3();
    exports.OPERATOR_MAP = (_a = {}, _a[types_1.Operators.AND] = utils_1.andUtil, _a[types_1.Operators.OR] = utils_1.orUtil, _a[types_1.Operators.XOR] = utils_1.xorUtil, _a);
  }
});

// node_modules/boon-js/lib/evaluate/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/boon-js/lib/evaluate/evaluate.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var parse_1 = require_parse();
    var types_1 = require_types();
    var const_1 = require_const3();
    var utils_1 = require_utils3();
    exports.getEvaluator = function(expression) {
      var parsedExpression = parse_1.parse(expression);
      return function(booleanMap) {
        return exports.evaluate(parsedExpression, booleanMap);
      };
    };
    exports.evaluate = function(expression, booleanMap) {
      if (!Array.isArray(expression)) {
        throw new Error(expression + " should be an array. evaluate takes in a parsed expression. Use in combination with parse or use getEvaluator");
      }
      var evaluatedExpression = expression.reduce(function(stack, token, i) {
        if (!(token && (utils_1.isIdentifier(token) || utils_1.isOperator(token)))) {
          throw new Error("Invalid token: " + token + ". Found in parsed expression at index " + i);
        }
        if (token.name === types_1.Tokens.IDENTIFIER) {
          return __spreadArrays2(stack, [Boolean(booleanMap[token.value])]);
        }
        var secondLastItem = stack[stack.length - 2];
        var lastItem = stack[stack.length - 1];
        if (token.value === types_1.Operators.NOT) {
          if (lastItem === void 0) {
            utils_1.throwInvalidExpression("missing identifier");
          }
          return __spreadArrays2(stack.slice(0, -1), [utils_1.notUtil(lastItem)]);
        }
        if (lastItem === void 0 || secondLastItem === void 0) {
          utils_1.throwInvalidExpression("missing identifier");
        }
        var operatorUtil = const_1.OPERATOR_MAP[token.value];
        if (!operatorUtil) {
          utils_1.throwInvalidExpression("unknown operator");
        }
        return __spreadArrays2(stack.slice(0, -2), [operatorUtil(secondLastItem, lastItem)]);
      }, []);
      if (evaluatedExpression.length !== 1) {
        utils_1.throwInvalidExpression("too many identifiers after evaluation");
      }
      return evaluatedExpression[0];
    };
  }
});

// node_modules/boon-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/boon-js/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var evaluate_1 = require_evaluate();
    exports.getEvaluator = evaluate_1.getEvaluator;
    exports.evaluate = evaluate_1.evaluate;
    var parse_1 = require_parse();
    exports.parse = parse_1.parse;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TasksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/Cache.ts
var import_obsidian3 = require("obsidian");

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_maxConcurrency, _cancelError = E_CANCELED) {
    this._maxConcurrency = _maxConcurrency;
    this._cancelError = _cancelError;
    this._queue = [];
    this._waiters = [];
    if (_maxConcurrency <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
    this._value = _maxConcurrency;
  }
  acquire() {
    const locked = this.isLocked();
    const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));
    if (!locked)
      this._dispatch();
    return ticketPromise;
  }
  runExclusive(callback) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire();
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (!this.isLocked()) {
        return Promise.resolve();
      }
      const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));
      return waitPromise;
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  release() {
    if (this._maxConcurrency > 1) {
      throw new Error("this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
    }
    if (this._currentReleaser) {
      const releaser = this._currentReleaser;
      this._currentReleaser = void 0;
      releaser();
    }
  }
  cancel() {
    this._queue.forEach((ticket) => ticket.reject(this._cancelError));
    this._queue = [];
  }
  _dispatch() {
    const nextTicket = this._queue.shift();
    if (!nextTicket)
      return;
    let released = false;
    this._currentReleaser = () => {
      if (released)
        return;
      released = true;
      this._value++;
      this._resolveWaiters();
      this._dispatch();
    };
    nextTicket.resolve([this._value--, this._currentReleaser]);
  }
  _resolveWaiters() {
    this._waiters.forEach((waiter) => waiter.resolve());
    this._waiters = [];
  }
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/TaskLayout.ts
var LayoutOptions = class {
  constructor() {
    this.hideTaskCount = false;
    this.hideBacklinks = false;
    this.hidePriority = false;
    this.hideStartDate = false;
    this.hideScheduledDate = false;
    this.hideDoneDate = false;
    this.hideDueDate = false;
    this.hideRecurrenceRule = false;
    this.hideEditButton = false;
    this.hideUrgency = true;
    this.shortMode = false;
    this.explainQuery = false;
  }
};
var TaskLayout = class {
  constructor(options, components) {
    this.defaultLayout = [
      "description",
      "priority",
      "recurrenceRule",
      "startDate",
      "scheduledDate",
      "dueDate",
      "doneDate",
      "blockLink"
    ];
    if (options) {
      this.options = options;
    } else {
      this.options = new LayoutOptions();
    }
    if (components) {
      this.layoutComponents = components;
    } else {
      this.layoutComponents = this.defaultLayout;
    }
    this.layoutComponents = this.applyOptions(this.options);
  }
  applyOptions(layoutOptions) {
    const removeIf = (taskComponents, shouldRemove, componentToRemove) => {
      if (shouldRemove) {
        return taskComponents.filter((element2) => element2 != componentToRemove);
      } else {
        return taskComponents;
      }
    };
    let newComponents = this.layoutComponents;
    newComponents = removeIf(newComponents, layoutOptions.hidePriority, "priority");
    newComponents = removeIf(newComponents, layoutOptions.hideRecurrenceRule, "recurrenceRule");
    newComponents = removeIf(newComponents, layoutOptions.hideStartDate, "startDate");
    newComponents = removeIf(newComponents, layoutOptions.hideScheduledDate, "scheduledDate");
    newComponents = removeIf(newComponents, layoutOptions.hideDueDate, "dueDate");
    newComponents = removeIf(newComponents, layoutOptions.hideDoneDate, "doneDate");
    return newComponents;
  }
};

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = function() {
  function Weekday2(weekday, n) {
    if (n === 0)
      throw new Error("Can't create weekday with n == 0");
    this.weekday = weekday;
    this.n = n;
  }
  Weekday2.fromStr = function(str) {
    return new Weekday2(ALL_WEEKDAYS.indexOf(str));
  };
  Weekday2.prototype.nth = function(n) {
    return this.n === n ? this : new Weekday2(this.weekday, n);
  };
  Weekday2.prototype.equals = function(other) {
    return this.weekday === other.weekday && this.n === other.n;
  };
  Weekday2.prototype.toString = function() {
    var s = ALL_WEEKDAYS[this.weekday];
    if (this.n)
      s = (this.n > 0 ? "+" : "") + String(this.n) + s;
    return s;
  };
  Weekday2.prototype.getJsWeekday = function() {
    return this.weekday === 6 ? 0 : this.weekday + 1;
  };
  return Weekday2;
}();

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var dateutil;
(function(dateutil2) {
  dateutil2.MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  dateutil2.ONE_DAY = 1e3 * 60 * 60 * 24;
  dateutil2.MAXYEAR = 9999;
  dateutil2.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1));
  dateutil2.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
  dateutil2.getYearDay = function(date) {
    var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    return Math.ceil((dateNoTime.valueOf() - new Date(date.getUTCFullYear(), 0, 1).valueOf()) / dateutil2.ONE_DAY) + 1;
  };
  dateutil2.isLeapYear = function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  };
  dateutil2.isDate = function(value) {
    return value instanceof Date;
  };
  dateutil2.isValidDate = function(value) {
    return dateutil2.isDate(value) && !isNaN(value.getTime());
  };
  dateutil2.tzOffset = function(date) {
    return date.getTimezoneOffset() * 60 * 1e3;
  };
  dateutil2.daysBetween = function(date1, date2) {
    var date1ms = date1.getTime() - dateutil2.tzOffset(date1);
    var date2ms = date2.getTime() - dateutil2.tzOffset(date2);
    var differencems = date1ms - date2ms;
    return Math.round(differencems / dateutil2.ONE_DAY);
  };
  dateutil2.toOrdinal = function(date) {
    return dateutil2.daysBetween(date, dateutil2.ORDINAL_BASE);
  };
  dateutil2.fromOrdinal = function(ordinal) {
    return new Date(dateutil2.ORDINAL_BASE.getTime() + ordinal * dateutil2.ONE_DAY);
  };
  dateutil2.getMonthDays = function(date) {
    var month = date.getUTCMonth();
    return month === 1 && dateutil2.isLeapYear(date.getUTCFullYear()) ? 29 : dateutil2.MONTH_DAYS[month];
  };
  dateutil2.getWeekday = function(date) {
    return dateutil2.PY_WEEKDAYS[date.getUTCDay()];
  };
  dateutil2.monthRange = function(year, month) {
    var date = new Date(Date.UTC(year, month, 1));
    return [dateutil2.getWeekday(date), dateutil2.getMonthDays(date)];
  };
  dateutil2.combine = function(date, time) {
    time = time || date;
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
  };
  dateutil2.clone = function(date) {
    var dolly = new Date(date.getTime());
    return dolly;
  };
  dateutil2.cloneDates = function(dates) {
    var clones = [];
    for (var i = 0; i < dates.length; i++) {
      clones.push(dateutil2.clone(dates[i]));
    }
    return clones;
  };
  dateutil2.sort = function(dates) {
    dates.sort(function(a, b) {
      return a.getTime() - b.getTime();
    });
  };
  dateutil2.timeToUntilString = function(time, utc) {
    if (utc === void 0) {
      utc = true;
    }
    var date = new Date(time);
    return [
      padStart(date.getUTCFullYear().toString(), 4, "0"),
      padStart(date.getUTCMonth() + 1, 2, "0"),
      padStart(date.getUTCDate(), 2, "0"),
      "T",
      padStart(date.getUTCHours(), 2, "0"),
      padStart(date.getUTCMinutes(), 2, "0"),
      padStart(date.getUTCSeconds(), 2, "0"),
      utc ? "Z" : ""
    ].join("");
  };
  dateutil2.untilStringToDate = function(until) {
    var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
    var bits = re.exec(until);
    if (!bits)
      throw new Error("Invalid UNTIL value: ".concat(until));
    return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
  };
})(dateutil || (dateutil = {}));
var dateutil_default = dateutil;

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = function() {
  function IterResult2(method, args) {
    this.minDate = null;
    this.maxDate = null;
    this._result = [];
    this.total = 0;
    this.method = method;
    this.args = args;
    if (method === "between") {
      this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
      this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
    } else if (method === "before") {
      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
    } else if (method === "after") {
      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
    }
  }
  IterResult2.prototype.accept = function(date) {
    ++this.total;
    var tooEarly = this.minDate && date < this.minDate;
    var tooLate = this.maxDate && date > this.maxDate;
    if (this.method === "between") {
      if (tooEarly)
        return true;
      if (tooLate)
        return false;
    } else if (this.method === "before") {
      if (tooLate)
        return false;
    } else if (this.method === "after") {
      if (tooEarly)
        return true;
      this.add(date);
      return false;
    }
    return this.add(date);
  };
  IterResult2.prototype.add = function(date) {
    this._result.push(date);
    return true;
  };
  IterResult2.prototype.getValue = function() {
    var res = this._result;
    switch (this.method) {
      case "all":
      case "between":
        return res;
      case "before":
      case "after":
      default:
        return res.length ? res[res.length - 1] : null;
    }
  };
  IterResult2.prototype.clone = function() {
    return new IterResult2(this.method, this.args);
  };
  return IterResult2;
}();
var iterresult_default = IterResult;

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = function(_super) {
  __extends(CallbackIterResult2, _super);
  function CallbackIterResult2(method, args, iterator) {
    var _this = _super.call(this, method, args) || this;
    _this.iterator = iterator;
    return _this;
  }
  CallbackIterResult2.prototype.add = function(date) {
    if (this.iterator(date, this._result.length)) {
      this._result.push(date);
      return true;
    }
    return false;
  };
  return CallbackIterResult2;
}(iterresult_default);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = function() {
  function ToText2(rrule, gettext, language, dateFormatter) {
    if (gettext === void 0) {
      gettext = defaultGetText;
    }
    if (language === void 0) {
      language = i18n_default;
    }
    if (dateFormatter === void 0) {
      dateFormatter = defaultDateFormatter;
    }
    this.text = [];
    this.language = language || i18n_default;
    this.gettext = gettext;
    this.dateFormatter = dateFormatter;
    this.rrule = rrule;
    this.options = rrule.options;
    this.origOptions = rrule.origOptions;
    if (this.origOptions.bymonthday) {
      var bymonthday = [].concat(this.options.bymonthday);
      var bynmonthday = [].concat(this.options.bynmonthday);
      bymonthday.sort(function(a, b) {
        return a - b;
      });
      bynmonthday.sort(function(a, b) {
        return b - a;
      });
      this.bymonthday = bymonthday.concat(bynmonthday);
      if (!this.bymonthday.length)
        this.bymonthday = null;
    }
    if (isPresent(this.origOptions.byweekday)) {
      var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
      var days = String(byweekday);
      this.byweekday = {
        allWeeks: byweekday.filter(function(weekday) {
          return !weekday.n;
        }),
        someWeeks: byweekday.filter(function(weekday) {
          return Boolean(weekday.n);
        }),
        isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
        isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
      };
      var sortWeekDays = function(a, b) {
        return a.weekday - b.weekday;
      };
      this.byweekday.allWeeks.sort(sortWeekDays);
      this.byweekday.someWeeks.sort(sortWeekDays);
      if (!this.byweekday.allWeeks.length)
        this.byweekday.allWeeks = null;
      if (!this.byweekday.someWeeks.length)
        this.byweekday.someWeeks = null;
    } else {
      this.byweekday = null;
    }
  }
  ToText2.isFullyConvertible = function(rrule) {
    var canConvert = true;
    if (!(rrule.options.freq in ToText2.IMPLEMENTED))
      return false;
    if (rrule.origOptions.until && rrule.origOptions.count)
      return false;
    for (var key in rrule.origOptions) {
      if (contains(["dtstart", "wkst", "freq"], key))
        return true;
      if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
        return false;
    }
    return canConvert;
  };
  ToText2.prototype.isFullyConvertible = function() {
    return ToText2.isFullyConvertible(this.rrule);
  };
  ToText2.prototype.toString = function() {
    var gettext = this.gettext;
    if (!(this.options.freq in ToText2.IMPLEMENTED)) {
      return gettext("RRule error: Unable to fully convert this rrule to text");
    }
    this.text = [gettext("every")];
    this[RRule.FREQUENCIES[this.options.freq]]();
    if (this.options.until) {
      this.add(gettext("until"));
      var until = this.options.until;
      this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
    } else if (this.options.count) {
      this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
    }
    if (!this.isFullyConvertible())
      this.add(gettext("(~ approximate)"));
    return this.text.join("");
  };
  ToText2.prototype.HOURLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
  };
  ToText2.prototype.MINUTELY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
  };
  ToText2.prototype.DAILY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
    } else {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    }
    if (this.origOptions.bymonth) {
      this.add(gettext("in"));
      this._bymonth();
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };
  ToText2.prototype.WEEKLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
    }
    if (this.byweekday && this.byweekday.isWeekdays) {
      if (this.options.interval === 1) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(gettext("on")).add(gettext("weekdays"));
      }
    } else if (this.byweekday && this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    } else {
      if (this.options.interval === 1)
        this.add(gettext("week"));
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
    }
  };
  ToText2.prototype.MONTHLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(gettext("months"));
        if (this.plural(this.options.interval))
          this.add(gettext("in"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(gettext("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };
  ToText2.prototype.YEARLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
        this.add(gettext("years"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }
    if (this.options.byyearday) {
      this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
    }
    if (this.options.byweekno) {
      this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
    }
  };
  ToText2.prototype._bymonthday = function() {
    var gettext = this.gettext;
    if (this.byweekday && this.byweekday.allWeeks) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
    } else {
      this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
    }
  };
  ToText2.prototype._byweekday = function() {
    var gettext = this.gettext;
    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
    }
    if (this.byweekday.someWeeks) {
      if (this.byweekday.allWeeks)
        this.add(gettext("and"));
      this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
    }
  };
  ToText2.prototype._byhour = function() {
    var gettext = this.gettext;
    this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
  };
  ToText2.prototype._bymonth = function() {
    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
  };
  ToText2.prototype.nth = function(n) {
    n = parseInt(n.toString(), 10);
    var nth;
    var gettext = this.gettext;
    if (n === -1)
      return gettext("last");
    var npos = Math.abs(n);
    switch (npos) {
      case 1:
      case 21:
      case 31:
        nth = npos + gettext("st");
        break;
      case 2:
      case 22:
        nth = npos + gettext("nd");
        break;
      case 3:
      case 23:
        nth = npos + gettext("rd");
        break;
      default:
        nth = npos + gettext("th");
    }
    return n < 0 ? nth + " " + gettext("last") : nth;
  };
  ToText2.prototype.monthtext = function(m) {
    return this.language.monthNames[m - 1];
  };
  ToText2.prototype.weekdaytext = function(wday) {
    var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
    return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
  };
  ToText2.prototype.plural = function(n) {
    return n % 100 !== 1;
  };
  ToText2.prototype.add = function(s) {
    this.text.push(" ");
    this.text.push(s);
    return this;
  };
  ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
    var _this = this;
    if (delim === void 0) {
      delim = ",";
    }
    if (!isArray(arr)) {
      arr = [arr];
    }
    var delimJoin = function(array, delimiter, finalDelimiter) {
      var list = "";
      for (var i = 0; i < array.length; i++) {
        if (i !== 0) {
          if (i === array.length - 1) {
            list += " " + finalDelimiter + " ";
          } else {
            list += delimiter + " ";
          }
        }
        list += array[i];
      }
      return list;
    };
    callback = callback || function(o) {
      return o.toString();
    };
    var realCallback = function(arg) {
      return callback && callback.call(_this, arg);
    };
    if (finalDelim) {
      return delimJoin(arr.map(realCallback), delim, finalDelim);
    } else {
      return arr.map(realCallback).join(delim + " ");
    }
  };
  return ToText2;
}();
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = function() {
  function Parser2(rules) {
    this.done = true;
    this.rules = rules;
  }
  Parser2.prototype.start = function(text2) {
    this.text = text2;
    this.done = false;
    return this.nextSymbol();
  };
  Parser2.prototype.isDone = function() {
    return this.done && this.symbol === null;
  };
  Parser2.prototype.nextSymbol = function() {
    var best;
    var bestSymbol;
    this.symbol = null;
    this.value = null;
    do {
      if (this.done)
        return false;
      var rule = void 0;
      best = null;
      for (var name_1 in this.rules) {
        rule = this.rules[name_1];
        var match = rule.exec(this.text);
        if (match) {
          if (best === null || match[0].length > best[0].length) {
            best = match;
            bestSymbol = name_1;
          }
        }
      }
      if (best != null) {
        this.text = this.text.substr(best[0].length);
        if (this.text === "")
          this.done = true;
      }
      if (best == null) {
        this.done = true;
        this.symbol = null;
        this.value = null;
        return;
      }
    } while (bestSymbol === "SKIP");
    this.symbol = bestSymbol;
    this.value = best;
    return true;
  };
  Parser2.prototype.accept = function(name) {
    if (this.symbol === name) {
      if (this.value) {
        var v = this.value;
        this.nextSymbol();
        return v;
      }
      this.nextSymbol();
      return true;
    }
    return false;
  };
  Parser2.prototype.acceptNumber = function() {
    return this.accept("number");
  };
  Parser2.prototype.expect = function(name) {
    if (this.accept(name))
      return true;
    throw new Error("expected " + name + " but found " + this.symbol);
  };
  return Parser2;
}();
function parseText(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text2))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text2, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = function() {
  function Time2(hour, minute, second, millisecond) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond || 0;
  }
  Time2.prototype.getHours = function() {
    return this.hour;
  };
  Time2.prototype.getMinutes = function() {
    return this.minute;
  };
  Time2.prototype.getSeconds = function() {
    return this.second;
  };
  Time2.prototype.getMilliseconds = function() {
    return this.millisecond;
  };
  Time2.prototype.getTime = function() {
    return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
  };
  return Time2;
}();
var DateTime = function(_super) {
  __extends(DateTime2, _super);
  function DateTime2(year, month, day, hour, minute, second, millisecond) {
    var _this = _super.call(this, hour, minute, second, millisecond) || this;
    _this.year = year;
    _this.month = month;
    _this.day = day;
    return _this;
  }
  DateTime2.fromDate = function(date) {
    return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
  };
  DateTime2.prototype.getWeekday = function() {
    return dateutil.getWeekday(new Date(this.getTime()));
  };
  DateTime2.prototype.getTime = function() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
  };
  DateTime2.prototype.getDay = function() {
    return this.day;
  };
  DateTime2.prototype.getMonth = function() {
    return this.month;
  };
  DateTime2.prototype.getYear = function() {
    return this.year;
  };
  DateTime2.prototype.addYears = function(years) {
    this.year += years;
  };
  DateTime2.prototype.addMonths = function(months) {
    this.month += months;
    if (this.month > 12) {
      var yearDiv = Math.floor(this.month / 12);
      var monthMod = pymod(this.month, 12);
      this.month = monthMod;
      this.year += yearDiv;
      if (this.month === 0) {
        this.month = 12;
        --this.year;
      }
    }
  };
  DateTime2.prototype.addWeekly = function(days, wkst) {
    if (wkst > this.getWeekday()) {
      this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
    } else {
      this.day += -(this.getWeekday() - wkst) + days * 7;
    }
    this.fixDay();
  };
  DateTime2.prototype.addDaily = function(days) {
    this.day += days;
    this.fixDay();
  };
  DateTime2.prototype.addHours = function(hours, filtered, byhour) {
    if (filtered) {
      this.hour += Math.floor((23 - this.hour) / hours) * hours;
    }
    for (; ; ) {
      this.hour += hours;
      var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
      if (dayDiv) {
        this.hour = hourMod;
        this.addDaily(dayDiv);
      }
      if (empty(byhour) || includes(byhour, this.hour))
        break;
    }
  };
  DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
    if (filtered) {
      this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
    }
    for (; ; ) {
      this.minute += minutes;
      var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
      if (hourDiv) {
        this.minute = minuteMod;
        this.addHours(hourDiv, false, byhour);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
        break;
      }
    }
  };
  DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
    if (filtered) {
      this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
    }
    for (; ; ) {
      this.second += seconds;
      var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
      if (minuteDiv) {
        this.second = secondMod;
        this.addMinutes(minuteDiv, false, byhour, byminute);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
        break;
      }
    }
  };
  DateTime2.prototype.fixDay = function() {
    if (this.day <= 28) {
      return;
    }
    var daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    if (this.day <= daysinmonth) {
      return;
    }
    while (this.day > daysinmonth) {
      this.day -= daysinmonth;
      ++this.month;
      if (this.month === 13) {
        this.month = 1;
        ++this.year;
        if (this.year > dateutil.MAXYEAR) {
          return;
        }
      }
      daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    }
  };
  DateTime2.prototype.add = function(options, filtered) {
    var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
    switch (freq) {
      case Frequency.YEARLY:
        return this.addYears(interval);
      case Frequency.MONTHLY:
        return this.addMonths(interval);
      case Frequency.WEEKLY:
        return this.addWeekly(interval, wkst);
      case Frequency.DAILY:
        return this.addDaily(interval);
      case Frequency.HOURLY:
        return this.addHours(interval, filtered, byhour);
      case Frequency.MINUTELY:
        return this.addMinutes(interval, filtered, byhour, byminute);
      case Frequency.SECONDLY:
        return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
    }
  };
  return DateTime2;
}(Time);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (dateutil_default.isDate(options[key]) && !dateutil_default.isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [dateutil_default.getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = dateutil_default.untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr2) {
    var _a = attr2.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = dateutil_default.untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = function() {
  function DateWithZone2(date, tzid) {
    if (isNaN(date.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date = date;
    this.tzid = tzid;
  }
  Object.defineProperty(DateWithZone2.prototype, "isUTC", {
    get: function() {
      return !this.tzid || this.tzid.toUpperCase() === "UTC";
    },
    enumerable: false,
    configurable: true
  });
  DateWithZone2.prototype.toString = function() {
    var datestr = dateutil_default.timeToUntilString(this.date.getTime(), this.isUTC);
    if (!this.isUTC) {
      return ";TZID=".concat(this.tzid, ":").concat(datestr);
    }
    return ":".concat(datestr);
  };
  DateWithZone2.prototype.getTime = function() {
    return this.date.getTime();
  };
  DateWithZone2.prototype.rezonedDate = function() {
    var _a;
    if (this.isUTC) {
      return this.date;
    }
    var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    var dateInLocalTZ = new Date(this.date.toLocaleString(void 0, { timeZone: localTimeZone }));
    var dateInTargetTZ = new Date(this.date.toLocaleString(void 0, { timeZone: (_a = this.tzid) !== null && _a !== void 0 ? _a : "UTC" }));
    var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
    return new Date(this.date.getTime() - tzOffset);
  };
  return DateWithZone2;
}();

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value = options[keys[i]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = dateutil_default.timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = function() {
  function Cache3() {
    this.all = false;
    this.before = [];
    this.after = [];
    this.between = [];
  }
  Cache3.prototype._cacheAdd = function(what, value, args) {
    if (value) {
      value = value instanceof Date ? dateutil_default.clone(value) : dateutil_default.cloneDates(value);
    }
    if (what === "all") {
      this.all = value;
    } else {
      args._value = value;
      this[what].push(args);
    }
  };
  Cache3.prototype._cacheGet = function(what, args) {
    var cached = false;
    var argsKeys = args ? Object.keys(args) : [];
    var findCacheDiff = function(item2) {
      for (var i2 = 0; i2 < argsKeys.length; i2++) {
        var key = argsKeys[i2];
        if (!argsMatch(args[key], item2[key])) {
          return true;
        }
      }
      return false;
    };
    var cachedObject = this[what];
    if (what === "all") {
      cached = this.all;
    } else if (isArray(cachedObject)) {
      for (var i = 0; i < cachedObject.length; i++) {
        var item = cachedObject[i];
        if (argsKeys.length && findCacheDiff(item))
          continue;
        cached = item._value;
        break;
      }
    }
    if (!cached && this.all) {
      var iterResult = new iterresult_default(what, args);
      for (var i = 0; i < this.all.length; i++) {
        if (!iterResult.accept(this.all[i]))
          break;
      }
      cached = iterResult.getValue();
      this._cacheAdd(what, cached, args);
    }
    return isArray(cached) ? dateutil_default.cloneDates(cached) : cached instanceof Date ? dateutil_default.clone(cached) : cached;
  };
  return Cache3;
}();

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var nextyearlen = dateutil_default.isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = dateutil_default.toOrdinal(firstyday);
  var yearweekday = dateutil_default.getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = dateutil_default.getWeekday(new Date(Date.UTC(year - 1, 0, 1)));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = dateutil_default.isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var wday = dateutil_default.getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = function() {
  function Iterinfo2(options) {
    this.options = options;
  }
  Iterinfo2.prototype.rebuild = function(year, month) {
    var options = this.options;
    if (year !== this.lastyear) {
      this.yearinfo = rebuildYear(year, options);
    }
    if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
      this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
    }
    if (isPresent(options.byeaster)) {
      this.eastermask = easter(year, options.byeaster);
    }
  };
  Object.defineProperty(Iterinfo2.prototype, "lastyear", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastyear : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastmonth : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearlen", {
    get: function() {
      return this.yearinfo.yearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
    get: function() {
      return this.yearinfo.yearordinal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mrange", {
    get: function() {
      return this.yearinfo.mrange;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
    get: function() {
      return this.yearinfo.wdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mmask", {
    get: function() {
      return this.yearinfo.mmask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wnomask", {
    get: function() {
      return this.yearinfo.wnomask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
    get: function() {
      return this.monthinfo ? this.monthinfo.nwdaymask : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
    get: function() {
      return this.yearinfo.nextyearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
    get: function() {
      return this.yearinfo.mdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
    get: function() {
      return this.yearinfo.nmdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Iterinfo2.prototype.ydayset = function() {
    return [range(this.yearlen), 0, this.yearlen];
  };
  Iterinfo2.prototype.mdayset = function(_, month) {
    var start = this.mrange[month - 1];
    var end = this.mrange[month];
    var set = repeat(null, this.yearlen);
    for (var i = start; i < end; i++)
      set[i] = i;
    return [set, start, end];
  };
  Iterinfo2.prototype.wdayset = function(year, month, day) {
    var set = repeat(null, this.yearlen + 7);
    var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    var start = i;
    for (var j = 0; j < 7; j++) {
      set[i] = i;
      ++i;
      if (this.wdaymask[i] === this.options.wkst)
        break;
    }
    return [set, start, i];
  };
  Iterinfo2.prototype.ddayset = function(year, month, day) {
    var set = repeat(null, this.yearlen);
    var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    set[i] = i;
    return [set, i, i + 1];
  };
  Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
    var _this = this;
    var set = [];
    this.options.byminute.forEach(function(minute) {
      set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
    });
    dateutil_default.sort(set);
    return set;
  };
  Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
    var set = this.options.bysecond.map(function(second) {
      return new Time(hour, minute, second, millisecond);
    });
    dateutil_default.sort(set);
    return set;
  };
  Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
    return [new Time(hour, minute, second, millisecond)];
  };
  Iterinfo2.prototype.getdayset = function(freq) {
    switch (freq) {
      case Frequency.YEARLY:
        return this.ydayset.bind(this);
      case Frequency.MONTHLY:
        return this.mdayset.bind(this);
      case Frequency.WEEKLY:
        return this.wdayset.bind(this);
      case Frequency.DAILY:
        return this.ddayset.bind(this);
      default:
        return this.ddayset.bind(this);
    }
  };
  Iterinfo2.prototype.gettimeset = function(freq) {
    switch (freq) {
      case Frequency.HOURLY:
        return this.htimeset.bind(this);
      case Frequency.MINUTELY:
        return this.mtimeset.bind(this);
      case Frequency.SECONDLY:
        return this.stimeset.bind(this);
    }
  };
  return Iterinfo2;
}();
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = dateutil_default.fromOrdinal(ii.yearordinal + i);
    var res = dateutil_default.combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  dateutil_default.sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = dateutil_default.fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = dateutil_default.combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > dateutil_default.MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = function() {
  function RRule2(options, noCache) {
    if (options === void 0) {
      options = {};
    }
    if (noCache === void 0) {
      noCache = false;
    }
    this._cache = noCache ? null : new Cache();
    this.origOptions = initializeOptions(options);
    var parsedOptions = parseOptions(options).parsedOptions;
    this.options = parsedOptions;
  }
  RRule2.parseText = function(text2, language) {
    return parseText(text2, language);
  };
  RRule2.fromText = function(text2, language) {
    return fromText(text2, language);
  };
  RRule2.fromString = function(str) {
    return new RRule2(RRule2.parseString(str) || void 0);
  };
  RRule2.prototype._iter = function(iterResult) {
    return iter(iterResult, this.options);
  };
  RRule2.prototype._cacheGet = function(what, args) {
    if (!this._cache)
      return false;
    return this._cache._cacheGet(what, args);
  };
  RRule2.prototype._cacheAdd = function(what, value, args) {
    if (!this._cache)
      return;
    return this._cache._cacheAdd(what, value, args);
  };
  RRule2.prototype.all = function(iterator) {
    if (iterator) {
      return this._iter(new callbackiterresult_default("all", {}, iterator));
    }
    var result = this._cacheGet("all");
    if (result === false) {
      result = this._iter(new iterresult_default("all", {}));
      this._cacheAdd("all", result);
    }
    return result;
  };
  RRule2.prototype.between = function(after, before, inc, iterator) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(after) || !dateutil_default.isValidDate(before)) {
      throw new Error("Invalid date passed in to RRule.between");
    }
    var args = {
      before,
      after,
      inc
    };
    if (iterator) {
      return this._iter(new callbackiterresult_default("between", args, iterator));
    }
    var result = this._cacheGet("between", args);
    if (result === false) {
      result = this._iter(new iterresult_default("between", args));
      this._cacheAdd("between", result, args);
    }
    return result;
  };
  RRule2.prototype.before = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.before");
    }
    var args = { dt, inc };
    var result = this._cacheGet("before", args);
    if (result === false) {
      result = this._iter(new iterresult_default("before", args));
      this._cacheAdd("before", result, args);
    }
    return result;
  };
  RRule2.prototype.after = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.after");
    }
    var args = { dt, inc };
    var result = this._cacheGet("after", args);
    if (result === false) {
      result = this._iter(new iterresult_default("after", args));
      this._cacheAdd("after", result, args);
    }
    return result;
  };
  RRule2.prototype.count = function() {
    return this.all().length;
  };
  RRule2.prototype.toString = function() {
    return optionsToString(this.origOptions);
  };
  RRule2.prototype.toText = function(gettext, language, dateFormatter) {
    return toText(this, gettext, language, dateFormatter);
  };
  RRule2.prototype.isFullyConvertibleToText = function() {
    return isFullyConvertible(this);
  };
  RRule2.prototype.clone = function() {
    return new RRule2(this.origOptions);
  };
  RRule2.FREQUENCIES = [
    "YEARLY",
    "MONTHLY",
    "WEEKLY",
    "DAILY",
    "HOURLY",
    "MINUTELY",
    "SECONDLY"
  ];
  RRule2.YEARLY = Frequency.YEARLY;
  RRule2.MONTHLY = Frequency.MONTHLY;
  RRule2.WEEKLY = Frequency.WEEKLY;
  RRule2.DAILY = Frequency.DAILY;
  RRule2.HOURLY = Frequency.HOURLY;
  RRule2.MINUTELY = Frequency.MINUTELY;
  RRule2.SECONDLY = Frequency.SECONDLY;
  RRule2.MO = Days.MO;
  RRule2.TU = Days.TU;
  RRule2.WE = Days.WE;
  RRule2.TH = Days.TH;
  RRule2.FR = Days.FR;
  RRule2.SA = Days.SA;
  RRule2.SU = Days.SU;
  RRule2.parseString = parseString;
  RRule2.optionsToString = optionsToString;
  return RRule2;
}();

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  dateutil_default.sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return dateutil_default.untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = function(_super) {
  __extends(RRuleSet2, _super);
  function RRuleSet2(noCache) {
    if (noCache === void 0) {
      noCache = false;
    }
    var _this = _super.call(this, {}, noCache) || this;
    _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
    _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
    _this._rrule = [];
    _this._rdate = [];
    _this._exrule = [];
    _this._exdate = [];
    return _this;
  }
  RRuleSet2.prototype._iter = function(iterResult) {
    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
  };
  RRuleSet2.prototype.rrule = function(rrule) {
    _addRule(rrule, this._rrule);
  };
  RRuleSet2.prototype.exrule = function(rrule) {
    _addRule(rrule, this._exrule);
  };
  RRuleSet2.prototype.rdate = function(date) {
    _addDate(date, this._rdate);
  };
  RRuleSet2.prototype.exdate = function(date) {
    _addDate(date, this._exdate);
  };
  RRuleSet2.prototype.rrules = function() {
    return this._rrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.exrules = function() {
    return this._exrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.rdates = function() {
    return this._rdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.exdates = function() {
    return this._exdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.valueOf = function() {
    var result = [];
    if (!this._rrule.length && this._dtstart) {
      result = result.concat(optionsToString({ dtstart: this._dtstart }));
    }
    this._rrule.forEach(function(rrule) {
      result = result.concat(rrule.toString().split("\n"));
    });
    this._exrule.forEach(function(exrule) {
      result = result.concat(exrule.toString().split("\n").map(function(line) {
        return line.replace(/^RRULE:/, "EXRULE:");
      }).filter(function(line) {
        return !/^DTSTART/.test(line);
      }));
    });
    if (this._rdate.length) {
      result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
    }
    if (this._exdate.length) {
      result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
    }
    return result;
  };
  RRuleSet2.prototype.toString = function() {
    return this.valueOf().join("\n");
  };
  RRuleSet2.prototype.clone = function() {
    var rrs = new RRuleSet2(!!this._cache);
    this._rrule.forEach(function(rule) {
      return rrs.rrule(rule.clone());
    });
    this._exrule.forEach(function(rule) {
      return rrs.exrule(rule.clone());
    });
    this._rdate.forEach(function(date) {
      return rrs.rdate(new Date(date.getTime()));
    });
    this._exdate.forEach(function(date) {
      return rrs.exdate(new Date(date.getTime()));
    });
    return rrs;
  };
  return RRuleSet2;
}(RRule);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    dateutil_default.sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return dateutil_default.timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// src/Query/DateParser.ts
var chrono = __toESM(require_dist());
var DateParser = class {
  static parseDate(input, forwardDate = false) {
    return window.moment(
      chrono.parseDate(input, void 0, {
        forwardDate
      })
    ).startOf("day");
  }
};

// src/Query/Explain/Explanation.ts
var Explanation = class {
  constructor(description, children2 = [], symbol = "") {
    this.description = description;
    this.symbol = symbol;
    this.children = children2;
  }
  static booleanAnd(children2) {
    return this.combineOrCreateExplanation("All of", children2, "AND");
  }
  static booleanOr(children2) {
    return this.combineOrCreateExplanation("At least one of", children2, "OR");
  }
  static booleanNot(children2) {
    return new Explanation("None of", children2, "NOT");
  }
  static booleanXor(children2) {
    return new Explanation("Exactly one of", children2, "XOR");
  }
  asString(currentIndentation = "") {
    if (this.children.length == 0) {
      return currentIndentation + this.description;
    }
    let result = currentIndentation + `${this.symbol}`;
    if (this.children.length > 1) {
      result += ` (${this.description})`;
    }
    result += ":";
    const newIndentation = currentIndentation + "  ";
    for (let i = 0; i < this.children.length; i++) {
      result += `
${this.children[i].asString(newIndentation)}`;
    }
    return result;
  }
  static combineOrCreateExplanation(description, children2, symbol) {
    if (children2.length === 2) {
      const child0 = children2[0];
      const child1 = children2[1];
      if (child0.symbol === symbol && child1.symbol === "") {
        child0.children.push(child1);
        return child0;
      }
    }
    return new Explanation(description, children2, symbol);
  }
};

// src/Query/Sorter.ts
var Sorter = class {
  constructor(property, comparator, reverse) {
    this.property = property;
    this.comparator = Sorter.maybeReverse(reverse, comparator);
  }
  static maybeReverse(reverse, comparator) {
    return reverse ? Sorter.makeReversedComparator(comparator) : comparator;
  }
  static makeReversedComparator(comparator) {
    return (a, b) => comparator(a, b) * -1;
  }
};

// src/lib/RegExpTools.ts
function escapeRegExp(s) {
  return s.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
}

// src/Query/Grouper.ts
var Grouper = class {
  constructor(property, grouper) {
    this.property = property;
    this.grouper = grouper;
  }
};

// src/Query/Filter/Field.ts
var Field = class {
  canCreateFilterForLine(line) {
    return Field.lineMatchesFilter(this.filterRegExp(), line);
  }
  static lineMatchesFilter(filter, line) {
    if (filter) {
      return filter.test(line);
    } else {
      return false;
    }
  }
  static getMatch(filterRegExp, line) {
    if (filterRegExp) {
      return line.match(filterRegExp);
    } else {
      return null;
    }
  }
  fieldNameSingular() {
    return this.fieldName();
  }
  fieldNameSingularEscaped() {
    return escapeRegExp(this.fieldNameSingular());
  }
  supportsSorting() {
    return false;
  }
  parseSortLine(line) {
    if (!this.supportsSorting()) {
      return null;
    }
    if (!this.canCreateSorterForLine(line)) {
      return null;
    }
    return this.createSorterFromLine(line);
  }
  canCreateSorterForLine(line) {
    if (!this.supportsSorting()) {
      return false;
    }
    return Field.lineMatchesFilter(this.sorterRegExp(), line);
  }
  createSorterFromLine(line) {
    if (!this.supportsSorting()) {
      return null;
    }
    const match = Field.getMatch(this.sorterRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    return this.createSorter(reverse);
  }
  sorterRegExp() {
    if (!this.supportsSorting()) {
      throw Error(`sorterRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^sort by ${this.fieldNameSingularEscaped()}( reverse)?`);
  }
  comparator() {
    throw Error(`comparator() unimplemented for ${this.fieldNameSingular()}`);
  }
  createSorter(reverse) {
    return new Sorter(this.fieldNameSingular(), this.comparator(), reverse);
  }
  createNormalSorter() {
    return this.createSorter(false);
  }
  createReverseSorter() {
    return this.createSorter(true);
  }
  supportsGrouping() {
    return false;
  }
  grouper() {
    throw Error(`grouper() unimplemented for ${this.fieldNameSingular()}`);
  }
  createGrouper() {
    return new Grouper(this.fieldNameSingular(), this.grouper());
  }
};

// src/Query/Filter/Filter.ts
var Filter = class {
  constructor(instruction, filterFunction, explanation) {
    this.instruction = instruction;
    this.explanation = explanation;
    this.filterFunction = filterFunction;
  }
  explainFilterIndented(indent) {
    const explanation = this.explanation;
    const unindentedExplanation = explanation.asString();
    if (unindentedExplanation === this.instruction) {
      return `${indent}${this.instruction}
`;
    } else {
      return `${indent}${this.instruction} =>
${explanation.asString("  ")}
`;
    }
  }
};
var FilterOrErrorMessage = class {
  constructor(instruction) {
    this.instruction = instruction;
  }
  get filter() {
    return this._filter;
  }
  set filter(value) {
    this._filter = value;
  }
  get filterFunction() {
    if (this._filter) {
      return this._filter.filterFunction;
    } else {
      return void 0;
    }
  }
  static fromFilter(filter) {
    const result = new FilterOrErrorMessage(filter.instruction);
    result.filter = filter;
    return result;
  }
  static fromError(instruction, errorMessage) {
    const result = new FilterOrErrorMessage(instruction);
    result.error = errorMessage;
    return result;
  }
};

// src/Query/Filter/FilterInstruction.ts
var FilterInstruction = class {
  constructor(instruction, filter) {
    this._instruction = instruction;
    this._filter = filter;
  }
  canCreateFilterForLine(line) {
    return line == this._instruction;
  }
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage(line);
    if (line === this._instruction) {
      result.filter = new Filter(line, this._filter, new Explanation(line));
      return result;
    }
    result.error = `do not understand filter: ${line}`;
    return result;
  }
};

// src/Query/Filter/FilterInstructions.ts
var FilterInstructions = class {
  constructor() {
    this._filters = [];
  }
  add(instruction, filter) {
    this._filters.push(new FilterInstruction(instruction, filter));
  }
  canCreateFilterForLine(line) {
    for (const filter of this._filters) {
      if (filter.canCreateFilterForLine(line)) {
        return true;
      }
    }
    return false;
  }
  createFilterOrErrorMessage(line) {
    for (const filter of this._filters) {
      const x = filter.createFilterOrErrorMessage(line);
      if (x.error === void 0) {
        return x;
      }
    }
    const result = new FilterOrErrorMessage(line);
    result.error = `do not understand filter: ${line}`;
    return result;
  }
};

// src/Query/Filter/DateField.ts
var DateField = class extends Field {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add(`has ${this.fieldName()} date`, (task) => this.date(task) !== null);
    this.filterInstructions.add(`no ${this.fieldName()} date`, (task) => this.date(task) === null);
    this.filterInstructions.add(`${this.fieldName()} date is invalid`, (task) => {
      const date = this.date(task);
      return date !== null && !date.isValid();
    });
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.filter !== void 0) {
      return filterResult;
    }
    const result = new FilterOrErrorMessage(line);
    const match = Field.getMatch(this.filterRegExp(), line);
    let filterFunction;
    if (match !== null) {
      const filterDate = DateParser.parseDate(match[2]);
      if (!filterDate.isValid()) {
        result.error = "do not understand " + this.fieldName() + " date";
      } else {
        let relative;
        if (match[1] === "before") {
          filterFunction = (task) => {
            const date = this.date(task);
            return date ? date.isBefore(filterDate) : this.filterResultIfFieldMissing();
          };
          relative = " " + match[1];
        } else if (match[1] === "after") {
          filterFunction = (task) => {
            const date = this.date(task);
            return date ? date.isAfter(filterDate) : this.filterResultIfFieldMissing();
          };
          relative = " " + match[1];
        } else {
          filterFunction = (task) => {
            const date = this.date(task);
            return date ? date.isSame(filterDate) : this.filterResultIfFieldMissing();
          };
          relative = " on";
        }
        const explanation = DateField.getExplanationString(
          this.fieldName(),
          relative,
          this.filterResultIfFieldMissing(),
          filterDate
        );
        result.filter = new Filter(line, filterFunction, new Explanation(explanation));
      }
    } else {
      result.error = "do not understand query filter (" + this.fieldName() + " date)";
    }
    return result;
  }
  static getExplanationString(fieldName, relationshipPrefixedWithSpace, filterResultIfFieldMissing, filterDate) {
    const actualDate = filterDate.format("YYYY-MM-DD (dddd Do MMMM YYYY)");
    let result = `${fieldName} date is${relationshipPrefixedWithSpace} ${actualDate}`;
    if (filterResultIfFieldMissing) {
      result += ` OR no ${fieldName} date`;
    }
    return result;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return DateField.compareByDate(this.date(a), this.date(b));
    };
  }
  static compareByDate(a, b) {
    if (a !== null && b === null) {
      return -1;
    } else if (a === null && b !== null) {
      return 1;
    } else if (a !== null && b !== null) {
      if (a.isValid() && !b.isValid()) {
        return -1;
      } else if (!a.isValid() && b.isValid()) {
        return 1;
      }
      if (a.isAfter(b)) {
        return 1;
      } else if (a.isBefore(b)) {
        return -1;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
};

// src/Recurrence.ts
var Recurrence = class {
  constructor({
    rrule,
    baseOnToday,
    referenceDate,
    startDate,
    scheduledDate,
    dueDate
  }) {
    this.rrule = rrule;
    this.baseOnToday = baseOnToday;
    this.referenceDate = referenceDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
  }
  static fromText({
    recurrenceRuleText,
    startDate,
    scheduledDate,
    dueDate
  }) {
    try {
      const match = recurrenceRuleText.match(/^([a-zA-Z0-9, !]+?)( when done)?$/i);
      if (match == null) {
        return null;
      }
      const isolatedRuleText = match[1].trim();
      const baseOnToday = match[2] !== void 0;
      const options = RRule.parseText(isolatedRuleText);
      if (options !== null) {
        let referenceDate = null;
        if (dueDate) {
          referenceDate = window.moment(dueDate);
        } else if (scheduledDate) {
          referenceDate = window.moment(scheduledDate);
        } else if (startDate) {
          referenceDate = window.moment(startDate);
        }
        if (!baseOnToday && referenceDate !== null) {
          options.dtstart = window.moment(referenceDate).startOf("day").utc(true).toDate();
        } else {
          options.dtstart = window.moment().startOf("day").utc(true).toDate();
        }
        const rrule = new RRule(options);
        return new Recurrence({
          rrule,
          baseOnToday,
          referenceDate,
          startDate,
          scheduledDate,
          dueDate
        });
      }
    } catch (error) {
    }
    return null;
  }
  toText() {
    let text2 = this.rrule.toText();
    if (this.baseOnToday) {
      text2 += " when done";
    }
    return text2;
  }
  next() {
    var _a;
    let next;
    if (this.baseOnToday) {
      const today = window.moment();
      const ruleBasedOnToday = new RRule(__spreadProps(__spreadValues({}, this.rrule.origOptions), {
        dtstart: today.startOf("day").utc(true).toDate()
      }));
      next = this.nextAfter(today.endOf("day"), ruleBasedOnToday);
    } else {
      const after = window.moment((_a = this.referenceDate) != null ? _a : void 0).endOf("day");
      next = this.nextAfter(after, this.rrule);
    }
    if (next !== null) {
      let startDate = null;
      let scheduledDate = null;
      let dueDate = null;
      if (this.referenceDate) {
        if (this.startDate) {
          const originalDifference = window.moment.duration(this.startDate.diff(this.referenceDate));
          startDate = window.moment(next);
          startDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.scheduledDate) {
          const originalDifference = window.moment.duration(this.scheduledDate.diff(this.referenceDate));
          scheduledDate = window.moment(next);
          scheduledDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.dueDate) {
          const originalDifference = window.moment.duration(this.dueDate.diff(this.referenceDate));
          dueDate = window.moment(next);
          dueDate.add(Math.round(originalDifference.asDays()), "days");
        }
      }
      return {
        startDate,
        scheduledDate,
        dueDate
      };
    }
    return null;
  }
  identicalTo(other) {
    if (this.baseOnToday !== other.baseOnToday) {
      return false;
    }
    if (DateField.compareByDate(this.startDate, other.startDate) !== 0) {
      return false;
    }
    if (DateField.compareByDate(this.scheduledDate, other.scheduledDate) !== 0) {
      return false;
    }
    if (DateField.compareByDate(this.dueDate, other.dueDate) !== 0) {
      return false;
    }
    return this.toText() === other.toText();
  }
  nextAfter(after, rrule) {
    after.utc(true);
    let next = window.moment(rrule.after(after.toDate()));
    const asText = this.toText();
    const monthMatch = asText.match(/every( \d+)? month(s)?(.*)?/);
    if (monthMatch !== null) {
      if (!asText.includes(" on ")) {
        next = Recurrence.nextAfterMonths(after, next, rrule, monthMatch[1]);
      }
    }
    const yearMatch = asText.match(/every( \d+)? year(s)?(.*)?/);
    if (yearMatch !== null) {
      next = Recurrence.nextAfterYears(after, next, rrule, yearMatch[1]);
    }
    return Recurrence.addTimezone(next).toDate();
  }
  static nextAfterMonths(after, next, rrule, skippingMonths) {
    let parsedSkippingMonths = 1;
    if (skippingMonths !== void 0) {
      parsedSkippingMonths = Number.parseInt(skippingMonths.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyMonths(after, next, parsedSkippingMonths)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyMonths(after, next, skippingMonths) {
    let diffMonths = next.month() - after.month();
    const diffYears = next.year() - after.year();
    diffMonths += diffYears * 12;
    return diffMonths > skippingMonths;
  }
  static nextAfterYears(after, next, rrule, skippingYears) {
    let parsedSkippingYears = 1;
    if (skippingYears !== void 0) {
      parsedSkippingYears = Number.parseInt(skippingYears.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyYears(after, next, parsedSkippingYears)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyYears(after, next, skippingYears) {
    const diff = next.year() - after.year();
    return diff > skippingYears;
  }
  static fromOneDayEarlier(after, rrule) {
    after.subtract(1, "days").endOf("day");
    const options = rrule.origOptions;
    options.dtstart = after.startOf("day").toDate();
    rrule = new RRule(options);
    return window.moment(rrule.after(after.toDate()));
  }
  static addTimezone(date) {
    const localTimeZone = window.moment.utc(date).local(true);
    return localTimeZone.startOf("day");
  }
};

// src/StatusConfiguration.ts
var StatusType = /* @__PURE__ */ ((StatusType2) => {
  StatusType2["TODO"] = "TODO";
  StatusType2["DONE"] = "DONE";
  StatusType2["IN_PROGRESS"] = "IN_PROGRESS";
  StatusType2["CANCELLED"] = "CANCELLED";
  StatusType2["NON_TASK"] = "NON_TASK";
  StatusType2["EMPTY"] = "EMPTY";
  return StatusType2;
})(StatusType || {});
var StatusConfiguration = class {
  constructor(symbol, name, nextStatusSymbol, availableAsCommand, type = "TODO" /* TODO */) {
    this.symbol = symbol;
    this.name = name;
    this.nextStatusSymbol = nextStatusSymbol;
    this.availableAsCommand = availableAsCommand;
    this.type = type;
  }
};

// src/Status.ts
var _Status = class {
  get symbol() {
    return this.configuration.symbol;
  }
  get name() {
    return this.configuration.name;
  }
  get nextStatusSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  get availableAsCommand() {
    return this.configuration.availableAsCommand;
  }
  get type() {
    return this.configuration.type;
  }
  constructor(configuration) {
    this.configuration = configuration;
  }
  static makeDone() {
    return new _Status(new StatusConfiguration("x", "Done", " ", true, "DONE" /* DONE */));
  }
  static makeEmpty() {
    return new _Status(new StatusConfiguration("", "EMPTY", "", true, "EMPTY" /* EMPTY */));
  }
  static makeTodo() {
    return new _Status(new StatusConfiguration(" ", "Todo", "x", true, "TODO" /* TODO */));
  }
  static makeCancelled() {
    return new _Status(new StatusConfiguration("-", "Cancelled", " ", true, "CANCELLED" /* CANCELLED */));
  }
  static makeInProgress() {
    return new _Status(new StatusConfiguration("/", "In Progress", "x", true, "IN_PROGRESS" /* IN_PROGRESS */));
  }
  static getTypeForUnknownSymbol(symbol) {
    switch (symbol) {
      case "x":
      case "X":
        return "DONE" /* DONE */;
      case "/":
        return "IN_PROGRESS" /* IN_PROGRESS */;
      case "-":
        return "CANCELLED" /* CANCELLED */;
      case "":
        return "EMPTY" /* EMPTY */;
      case " ":
      default:
        return "TODO" /* TODO */;
    }
  }
  static getTypeFromStatusTypeString(statusTypeAsString) {
    return StatusType[statusTypeAsString] || "TODO" /* TODO */;
  }
  static createUnknownStatus(unknownSymbol) {
    return new _Status(new StatusConfiguration(unknownSymbol, "Unknown", "x", false, "TODO" /* TODO */));
  }
  static createFromImportedValue(imported) {
    const symbol = imported[0];
    const type = _Status.getTypeFromStatusTypeString(imported[3]);
    return new _Status(new StatusConfiguration(symbol, imported[1], imported[2], false, type));
  }
  isCompleted() {
    return this.type === "DONE" /* DONE */;
  }
  previewText() {
    let commandNotice = "";
    if (_Status.tasksPluginCanCreateCommandsForStatuses() && this.availableAsCommand) {
      commandNotice = " Available as a command.";
    }
    return `- [${this.symbol}] => [${this.nextStatusSymbol}], name: '${this.name}', type: '${this.configuration.type}'.${commandNotice}`;
  }
  static tasksPluginCanCreateCommandsForStatuses() {
    return false;
  }
};
var Status = _Status;
Status.DONE = _Status.makeDone();
Status.EMPTY = _Status.makeEmpty();
Status.TODO = _Status.makeTodo();

// src/Config/StatusSettings.ts
var StatusSettings = class {
  constructor() {
    this.coreStatuses = [
      Status.makeTodo().configuration,
      Status.makeDone().configuration
    ];
    this.customStatuses = [
      Status.makeInProgress().configuration,
      Status.makeCancelled().configuration
    ];
  }
  static addStatus(statuses, newStatus) {
    statuses.push(newStatus);
  }
  static replaceStatus(statuses, originalStatus, newStatus) {
    const index = this.findStatusIndex(originalStatus, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1, newStatus);
    return true;
  }
  static findStatusIndex(statusConfiguration, statuses) {
    const originalStatusAsStatus = new Status(statusConfiguration);
    return statuses.findIndex((s) => {
      return new Status(s).previewText() == originalStatusAsStatus.previewText();
    });
  }
  static deleteStatus(statuses, status) {
    const index = this.findStatusIndex(status, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1);
    return true;
  }
  static deleteAllCustomStatuses(statusSettings) {
    statusSettings.customStatuses.splice(0);
  }
  static resetAllCustomStatuses(statusSettings) {
    StatusSettings.deleteAllCustomStatuses(statusSettings);
    const defaultSettings2 = new StatusSettings();
    defaultSettings2.customStatuses.forEach((s) => {
      StatusSettings.addStatus(statusSettings.customStatuses, s);
    });
  }
  static bulkAddStatusCollection(statusSettings, supportedStatuses) {
    const notices = [];
    supportedStatuses.forEach((importedStatus) => {
      const hasStatus = statusSettings.customStatuses.find((element2) => {
        return element2.symbol == importedStatus[0] && element2.name == importedStatus[1] && element2.nextStatusSymbol == importedStatus[2];
      });
      if (!hasStatus) {
        StatusSettings.addStatus(statusSettings.customStatuses, Status.createFromImportedValue(importedStatus));
      } else {
        notices.push(`The status ${importedStatus[1]} (${importedStatus[0]}) is already added.`);
      }
    });
    return notices;
  }
  static applyToStatusRegistry(statusSettings, statusRegistry) {
    statusRegistry.clearStatuses();
    statusSettings.coreStatuses.forEach((statusType) => {
      statusRegistry.add(statusType);
    });
    statusSettings.customStatuses.forEach((statusType) => {
      statusRegistry.add(statusType);
    });
  }
};

// src/Config/featureConfiguration.json
var featureConfiguration_default = [
  {
    index: 9999,
    internalName: "INTERNAL_TESTING_ENABLED_BY_DEFAULT",
    displayName: "Test Item. Used to validate the Feature Framework.",
    description: "Description",
    enabledByDefault: true,
    stable: false
  }
];

// src/Config/Feature.ts
var Feature = class {
  constructor(internalName, index, description, displayName, enabledByDefault, stable) {
    this.internalName = internalName;
    this.index = index;
    this.description = description;
    this.displayName = displayName;
    this.enabledByDefault = enabledByDefault;
    this.stable = stable;
  }
  static get values() {
    let availableFeatures = [];
    featureConfiguration_default.forEach((feature) => {
      availableFeatures = [
        ...availableFeatures,
        new Feature(
          feature.internalName,
          feature.index,
          feature.description,
          feature.displayName,
          feature.enabledByDefault,
          feature.stable
        )
      ];
    });
    return availableFeatures;
  }
  static get settingsFlags() {
    const featureFlags = {};
    Feature.values.forEach((feature) => {
      featureFlags[feature.internalName] = feature.enabledByDefault;
    });
    return featureFlags;
  }
  static fromString(name) {
    for (const feature of Feature.values) {
      if (name === feature.internalName) {
        return feature;
      }
    }
    throw new RangeError(
      `Illegal argument passed to fromString(): ${name} does not correspond to any available Feature ${this.prototype.constructor.name}`
    );
  }
};

// src/Config/Settings.ts
var defaultSettings = {
  globalFilter: "",
  removeGlobalFilter: false,
  setDoneDate: true,
  autoSuggestInEditor: true,
  autoSuggestMinMatch: 0,
  autoSuggestMaxItems: 6,
  provideAccessKeys: true,
  useFilenameAsScheduledDate: false,
  filenameAsDateFolders: [],
  statusSettings: new StatusSettings(),
  features: Feature.settingsFlags,
  generalSettings: {},
  headingOpened: {}
};
var settings = __spreadValues({}, defaultSettings);
var getSettings = () => {
  for (const flag in Feature.settingsFlags) {
    if (settings.features[flag] === void 0) {
      settings.features[flag] = Feature.settingsFlags[flag];
    }
  }
  settings.statusSettings.customStatuses.forEach((s, index, array) => {
    var _a, _b;
    const newType = Status.getTypeFromStatusTypeString(s.type);
    array[index] = new StatusConfiguration(
      (_a = s.symbol) != null ? _a : " ",
      s.name,
      (_b = s.nextStatusSymbol) != null ? _b : "x",
      s.availableAsCommand,
      newType
    );
  });
  return __spreadValues({}, settings);
};
var updateSettings = (newSettings) => {
  settings = __spreadValues(__spreadValues({}, settings), newSettings);
  return getSettings();
};
var updateGeneralSetting = (name, value) => {
  settings.generalSettings[name] = value;
  return getSettings();
};
var isFeatureEnabled = (internalName) => {
  var _a;
  return (_a = settings.features[internalName]) != null ? _a : false;
};

// src/StatusRegistry.ts
var StatusRegistry = class {
  constructor() {
    this._registeredStatuses = [];
    this.addDefaultStatusTypes();
  }
  get registeredStatuses() {
    return this._registeredStatuses.filter(({ symbol }) => symbol !== Status.EMPTY.symbol);
  }
  static getInstance() {
    if (!StatusRegistry.instance) {
      StatusRegistry.instance = new StatusRegistry();
    }
    return StatusRegistry.instance;
  }
  add(status) {
    if (!this.hasSymbol(status.symbol)) {
      if (status instanceof Status) {
        this._registeredStatuses.push(status);
      } else {
        this._registeredStatuses.push(new Status(status));
      }
    }
  }
  bySymbol(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.EMPTY;
  }
  bySymbolOrCreate(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.createUnknownStatus(symbol);
  }
  byName(nameToFind) {
    if (this._registeredStatuses.filter(({ name }) => name === nameToFind).length > 0) {
      return this._registeredStatuses.filter(({ name }) => name === nameToFind)[0];
    }
    return Status.EMPTY;
  }
  resetToDefaultStatuses() {
    this.clearStatuses();
    this.addDefaultStatusTypes();
  }
  clearStatuses() {
    this._registeredStatuses = [];
  }
  getNextStatus(status) {
    if (status.nextStatusSymbol !== "") {
      const nextStatus = this.bySymbol(status.nextStatusSymbol);
      if (nextStatus !== null) {
        return nextStatus;
      }
    }
    return Status.EMPTY;
  }
  getNextStatusOrCreate(status) {
    const nextStatus = this.getNextStatus(status);
    if (nextStatus.type !== "EMPTY" /* EMPTY */) {
      return nextStatus;
    }
    return Status.createUnknownStatus(status.nextStatusSymbol);
  }
  findUnknownStatuses(tasks) {
    const allStatuses = tasks.map((task) => {
      return task.status;
    });
    const unknownStatuses = allStatuses.filter((s) => {
      return !this.hasSymbol(s.symbol);
    });
    const newStatusRegistry = new StatusRegistry();
    const namedUniqueStatuses = [];
    unknownStatuses.forEach((s) => {
      if (newStatusRegistry.hasSymbol(s.symbol)) {
        return;
      }
      const newStatus = StatusRegistry.copyStatusWithNewName(s, `Unknown (${s.symbol})`);
      namedUniqueStatuses.push(newStatus);
      newStatusRegistry.add(newStatus);
    });
    return namedUniqueStatuses;
  }
  static copyStatusWithNewName(s, newName) {
    const statusConfiguration = new StatusConfiguration(
      s.symbol,
      newName,
      s.nextStatusSymbol,
      s.availableAsCommand,
      s.type
    );
    return new Status(statusConfiguration);
  }
  getSymbol(symbolToFind) {
    return this._registeredStatuses.filter(({ symbol }) => symbol === symbolToFind)[0];
  }
  hasSymbol(symbolToFind) {
    return this._registeredStatuses.find((element2) => {
      return element2.symbol === symbolToFind;
    }) !== void 0;
  }
  addDefaultStatusTypes() {
    const defaultStatuses = [Status.makeTodo(), Status.makeInProgress(), Status.makeDone(), Status.makeCancelled()];
    defaultStatuses.forEach((status) => {
      this.add(status);
    });
  }
};

// src/Urgency.ts
var _Urgency = class {
  static calculate(task) {
    let urgency = 0;
    if (task.dueDate !== null) {
      const daysOverdue = Math.round(window.moment().diff(task.dueDate) / _Urgency.milliSecondsPerDay);
      let dueMultiplier;
      if (daysOverdue >= 7) {
        dueMultiplier = 1;
      } else if (daysOverdue >= -14) {
        dueMultiplier = (daysOverdue + 14) * 0.8 / 21 + 0.2;
      } else {
        dueMultiplier = 0.2;
      }
      urgency += dueMultiplier * _Urgency.dueCoefficient;
    }
    if (task.scheduledDate !== null) {
      if (window.moment().isSameOrAfter(task.scheduledDate)) {
        urgency += 1 * _Urgency.scheduledCoefficient;
      }
    }
    if (task.startDate !== null) {
      if (window.moment().isBefore(task.startDate)) {
        urgency += 1 * _Urgency.startedCoefficient;
      }
    }
    switch (task.priority) {
      case "1":
        urgency += 1 * _Urgency.priorityCoefficient;
        break;
      case "2":
        urgency += 0.65 * _Urgency.priorityCoefficient;
        break;
      case "3":
        urgency += 0.325 * _Urgency.priorityCoefficient;
        break;
    }
    return urgency;
  }
};
var Urgency = _Urgency;
Urgency.dueCoefficient = 12;
Urgency.scheduledCoefficient = 5;
Urgency.startedCoefficient = -3;
Urgency.priorityCoefficient = 6;
Urgency.milliSecondsPerDay = 1e3 * 60 * 60 * 24;

// src/TaskLineRenderer.ts
var import_obsidian2 = require("obsidian");

// src/File.ts
var import_obsidian = require("obsidian");
var metadataCache;
var vault;
var initializeFile = ({
  metadataCache: newMetadataCache,
  vault: newVault
}) => {
  metadataCache = newMetadataCache;
  vault = newVault;
};
var replaceTaskWithTasks = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks
}) {
  if (vault === void 0 || metadataCache === void 0) {
    console.error("Tasks: cannot use File before initializing it.");
    return;
  }
  if (!Array.isArray(newTasks)) {
    newTasks = [newTasks];
  }
  tryRepetitive({
    originalTask,
    newTasks,
    vault,
    metadataCache,
    previousTries: 0
  });
});
var tryRepetitive = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks,
  vault: vault2,
  metadataCache: metadataCache2,
  previousTries
}) {
  const retry = () => {
    if (previousTries > 10) {
      console.error("Tasks: Too many retries. File update not possible ...");
      return;
    }
    const timeout = Math.min(Math.pow(10, previousTries), 100);
    setTimeout(() => {
      tryRepetitive({
        originalTask,
        newTasks,
        vault: vault2,
        metadataCache: metadataCache2,
        previousTries: previousTries + 1
      });
    }, timeout);
  };
  const file = vault2.getAbstractFileByPath(originalTask.path);
  if (!(file instanceof import_obsidian.TFile)) {
    console.warn(`Tasks: No file found for task ${originalTask.description}. Retrying ...`);
    return retry();
  }
  if (file.extension !== "md") {
    console.error("Tasks: Only supporting files with the .md file extension.");
    return;
  }
  const fileCache = metadataCache2.getFileCache(file);
  if (fileCache == void 0 || fileCache === null) {
    console.warn(`Tasks: No file cache found for file ${file.path}. Retrying ...`);
    return retry();
  }
  const listItemsCache = fileCache.listItems;
  if (listItemsCache === void 0 || listItemsCache.length === 0) {
    console.warn(`Tasks: No list items found in file cache of ${file.path}. Retrying ...`);
    return retry();
  }
  const fileContent = yield vault2.read(file);
  const fileLines = fileContent.split("\n");
  const { globalFilter } = getSettings();
  let listItem;
  let sectionIndex = 0;
  for (const listItemCache of listItemsCache) {
    if (listItemCache.position.start.line < originalTask.sectionStart) {
      continue;
    }
    if (listItemCache.task === void 0) {
      continue;
    }
    const line = fileLines[listItemCache.position.start.line];
    if (line.includes(globalFilter)) {
      if (sectionIndex === originalTask.sectionIndex) {
        listItem = listItemCache;
        break;
      }
      sectionIndex++;
    }
  }
  if (listItem === void 0) {
    console.error("Tasks: could not find task to toggle in the file.");
    return;
  }
  const updatedFileLines = [
    ...fileLines.slice(0, listItem.position.start.line),
    ...newTasks.map((task) => task.toFileLineString()),
    ...fileLines.slice(listItem.position.start.line + 1)
  ];
  yield vault2.modify(file, updatedFileLines.join("\n"));
});

// src/TaskLineRenderer.ts
function obsidianMarkdownRenderer(text2, element2, path) {
  return __async(this, null, function* () {
    yield import_obsidian2.MarkdownRenderer.renderMarkdown(text2, element2, path, null);
  });
}
function renderTaskLine(task, renderDetails, textRenderer = null) {
  return __async(this, null, function* () {
    var _a;
    if (!textRenderer)
      textRenderer = obsidianMarkdownRenderer;
    const li = document.createElement("li");
    renderDetails.parentUlElement.appendChild(li);
    li.classList.add("task-list-item", "plugin-tasks-list-item");
    const textSpan = document.createElement("span");
    li.appendChild(textSpan);
    textSpan.classList.add("tasks-list-text");
    yield taskToHtml(task, renderDetails, textSpan, textRenderer);
    const checkbox = document.createElement("input");
    li.appendChild(checkbox);
    checkbox.classList.add("task-list-item-checkbox");
    checkbox.type = "checkbox";
    if (task.status.symbol !== " ") {
      checkbox.checked = true;
      li.classList.add("is-checked");
    }
    checkbox.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      checkbox.disabled = true;
      const toggledTasks = task.toggle();
      replaceTaskWithTasks({
        originalTask: task,
        newTasks: toggledTasks
      });
    });
    li.prepend(checkbox);
    li.setAttribute("data-task", task.status.symbol.trim());
    li.setAttribute("data-line", renderDetails.listIndex.toString());
    checkbox.setAttribute("data-line", renderDetails.listIndex.toString());
    if ((_a = renderDetails.layoutOptions) == null ? void 0 : _a.shortMode) {
      addTooltip({ task, element: textSpan, isFilenameUnique: renderDetails.isFilenameUnique });
    }
    return li;
  });
}
function taskToHtml(task, renderDetails, parentElement, textRenderer) {
  return __async(this, null, function* () {
    let taskAsString = "";
    const taskLayout = new TaskLayout(renderDetails.layoutOptions);
    for (const component of taskLayout.layoutComponents) {
      let componentString = task.componentToString(taskLayout, component);
      if (componentString) {
        if (component === "description")
          componentString = removeGlobalFilterIfNeeded(componentString);
        taskAsString += componentString;
      }
    }
    yield renderComponentText(parentElement, taskAsString, "description", task, textRenderer);
  });
}
function renderComponentText(span, componentString, component, task, textRenderer) {
  return __async(this, null, function* () {
    if (component === "description") {
      yield textRenderer(componentString, span, task.path);
      const blockQuote = span.querySelector("blockquote");
      const directParentOfPTag = blockQuote != null ? blockQuote : span;
      const pElement = directParentOfPTag.querySelector("p");
      if (pElement !== null) {
        while (pElement.firstChild) {
          directParentOfPTag.insertBefore(pElement.firstChild, pElement);
        }
        pElement.remove();
      }
      span.querySelectorAll("p").forEach((pElement2) => {
        if (!pElement2.hasChildNodes()) {
          pElement2.remove();
        }
      });
      span.querySelectorAll(".footnotes").forEach((footnoteElement) => {
        footnoteElement.remove();
      });
    } else {
      span.innerHTML = componentString;
    }
  });
}
function addTooltip({
  task,
  element: element2,
  isFilenameUnique
}) {
  element2.addEventListener("mouseenter", () => {
    const tooltip = element2.createDiv();
    tooltip.addClasses(["tooltip", "mod-right"]);
    if (task.recurrence) {
      const recurrenceDiv = tooltip.createDiv();
      recurrenceDiv.setText(`${recurrenceSymbol} ${task.recurrence.toText()}`);
    }
    if (task.startDate) {
      const startDateDiv = tooltip.createDiv();
      startDateDiv.setText(
        toTooltipDate({
          signifier: startDateSymbol,
          date: task.startDate
        })
      );
    }
    if (task.scheduledDate) {
      const scheduledDateDiv = tooltip.createDiv();
      scheduledDateDiv.setText(
        toTooltipDate({
          signifier: scheduledDateSymbol,
          date: task.scheduledDate
        })
      );
    }
    if (task.dueDate) {
      const dueDateDiv = tooltip.createDiv();
      dueDateDiv.setText(
        toTooltipDate({
          signifier: dueDateSymbol,
          date: task.dueDate
        })
      );
    }
    if (task.doneDate) {
      const doneDateDiv = tooltip.createDiv();
      doneDateDiv.setText(
        toTooltipDate({
          signifier: doneDateSymbol,
          date: task.doneDate
        })
      );
    }
    const linkText = task.getLinkText({ isFilenameUnique });
    if (linkText) {
      const backlinkDiv = tooltip.createDiv();
      backlinkDiv.setText(`\u{1F517} ${linkText}`);
    }
    element2.addEventListener("mouseleave", () => {
      tooltip.remove();
    });
  });
}
function toTooltipDate({ signifier, date }) {
  return `${signifier} ${date.format(TaskRegularExpressions.dateFormat)} (${date.from(
    window.moment().startOf("day")
  )})`;
}
function removeGlobalFilterIfNeeded(description) {
  const { globalFilter, removeGlobalFilter } = getSettings();
  if (removeGlobalFilter) {
    return description.replace(globalFilter, "").trim();
  }
  return description;
}

// src/DateFallback.ts
var DateFallback = class {
  static fromPath(path) {
    const { useFilenameAsScheduledDate, filenameAsDateFolders } = getSettings();
    if (!useFilenameAsScheduledDate) {
      return null;
    }
    if (!this.matchesAnyFolder(filenameAsDateFolders, path)) {
      return null;
    }
    return this.extractDateFromPath(path);
  }
  static matchesAnyFolder(folders, path) {
    if (folders.length === 0) {
      return true;
    }
    return folders.some((folder) => path.startsWith(folder + "/"));
  }
  static extractDateFromPath(path) {
    const firstPos = Math.max(0, path.lastIndexOf("/") + 1);
    const lastPos = path.lastIndexOf(".");
    const basename = path.substring(firstPos, lastPos);
    let dateMatch = /(\d{4})-(\d{2})-(\d{2})/.exec(basename);
    if (!dateMatch)
      dateMatch = /(\d{4})(\d{2})(\d{2})/.exec(basename);
    if (dateMatch) {
      const date = window.moment([parseInt(dateMatch[1]), parseInt(dateMatch[2]) - 1, parseInt(dateMatch[3])]);
      if (date.isValid()) {
        return date;
      }
    }
    return null;
  }
  static canApplyFallback({
    startDate,
    scheduledDate,
    dueDate
  }) {
    return startDate === null && dueDate === null && scheduledDate === null;
  }
  static updateTaskPath(task, newPath, fallbackDate) {
    let scheduledDate = task.scheduledDate;
    let scheduledDateIsInferred = task.scheduledDateIsInferred;
    if (fallbackDate === null) {
      if (scheduledDateIsInferred) {
        scheduledDateIsInferred = false;
        scheduledDate = null;
      } else {
      }
    } else {
      if (scheduledDateIsInferred) {
        scheduledDate = fallbackDate;
      } else if (this.canApplyFallback(task)) {
        scheduledDate = fallbackDate;
        scheduledDateIsInferred = true;
      } else {
      }
    }
    return new Task(__spreadProps(__spreadValues({}, task), {
      path: newPath,
      scheduledDate,
      scheduledDateIsInferred
    }));
  }
  static removeInferredStatusIfNeeded(originalTask, updatedTasks) {
    const inferredScheduledDate = originalTask.scheduledDateIsInferred ? originalTask.scheduledDate : null;
    return updatedTasks.map((task) => {
      if (inferredScheduledDate !== null && !inferredScheduledDate.isSame(task.scheduledDate, "day")) {
        task = new Task(__spreadProps(__spreadValues({}, task), { scheduledDateIsInferred: false }));
      }
      return task;
    });
  }
};

// src/Task.ts
var prioritySymbols = {
  High: "\u23EB",
  Medium: "\u{1F53C}",
  Low: "\u{1F53D}",
  None: ""
};
var recurrenceSymbol = "\u{1F501}";
var startDateSymbol = "\u{1F6EB}";
var scheduledDateSymbol = "\u23F3";
var dueDateSymbol = "\u{1F4C5}";
var doneDateSymbol = "\u2705";
var _TaskRegularExpressions = class {
};
var TaskRegularExpressions = _TaskRegularExpressions;
TaskRegularExpressions.dateFormat = "YYYY-MM-DD";
TaskRegularExpressions.indentationRegex = /^([\s\t>]*)/;
TaskRegularExpressions.listMarkerRegex = /([-*]|[0-9]+\.)/;
TaskRegularExpressions.checkboxRegex = /\[(.)\]/u;
TaskRegularExpressions.afterCheckboxRegex = / *(.*)/u;
TaskRegularExpressions.taskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + " +" + _TaskRegularExpressions.checkboxRegex.source + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.nonTaskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + "? *(" + _TaskRegularExpressions.checkboxRegex.source + ")?" + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.listItemRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source
);
TaskRegularExpressions.blockLinkRegex = / \^[a-zA-Z0-9-]+$/u;
TaskRegularExpressions.priorityRegex = /([⏫🔼🔽])$/u;
TaskRegularExpressions.startDateRegex = /🛫 *(\d{4}-\d{2}-\d{2})$/u;
TaskRegularExpressions.scheduledDateRegex = /[⏳⌛] *(\d{4}-\d{2}-\d{2})$/u;
TaskRegularExpressions.dueDateRegex = /[📅📆🗓] *(\d{4}-\d{2}-\d{2})$/u;
TaskRegularExpressions.doneDateRegex = /✅ *(\d{4}-\d{2}-\d{2})$/u;
TaskRegularExpressions.recurrenceRegex = /🔁 ?([a-zA-Z0-9, !]+)$/iu;
TaskRegularExpressions.hashTags = /(^|\s)#[^ !@#$%^&*(),.?":{}|<>]*/g;
TaskRegularExpressions.hashTagsFromEnd = new RegExp(_TaskRegularExpressions.hashTags.source + "$");
var Task = class {
  constructor({
    status,
    description,
    path,
    indentation,
    listMarker,
    sectionStart,
    sectionIndex,
    precedingHeader,
    priority,
    startDate,
    scheduledDate,
    dueDate,
    doneDate,
    recurrence,
    blockLink,
    tags,
    originalMarkdown,
    scheduledDateIsInferred
  }) {
    this._urgency = null;
    this.status = status;
    this.description = description;
    this.path = path;
    this.indentation = indentation;
    this.listMarker = listMarker;
    this.sectionStart = sectionStart;
    this.sectionIndex = sectionIndex;
    this.precedingHeader = precedingHeader;
    this.tags = tags;
    this.priority = priority;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.doneDate = doneDate;
    this.recurrence = recurrence;
    this.blockLink = blockLink;
    this.originalMarkdown = originalMarkdown;
    this.scheduledDateIsInferred = scheduledDateIsInferred;
  }
  static fromLine({
    line,
    path,
    sectionStart,
    sectionIndex,
    precedingHeader,
    fallbackDate
  }) {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch === null) {
      return null;
    }
    const body = regexMatch[4].trim();
    const { globalFilter } = getSettings();
    if (!body.includes(globalFilter)) {
      return null;
    }
    let description = body;
    const indentation = regexMatch[1];
    const listMarker = regexMatch[2];
    const statusString = regexMatch[3];
    const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
    const blockLinkMatch = description.match(TaskRegularExpressions.blockLinkRegex);
    const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
    if (blockLink !== "") {
      description = description.replace(TaskRegularExpressions.blockLinkRegex, "").trim();
    }
    let matched;
    let priority = "3" /* None */;
    let startDate = null;
    let scheduledDate = null;
    let scheduledDateIsInferred = false;
    let dueDate = null;
    let doneDate = null;
    let recurrenceRule = "";
    let recurrence = null;
    let tags = [];
    let trailingTags = "";
    const maxRuns = 20;
    let runs = 0;
    do {
      matched = false;
      const priorityMatch = description.match(TaskRegularExpressions.priorityRegex);
      if (priorityMatch !== null) {
        switch (priorityMatch[1]) {
          case prioritySymbols.Low:
            priority = "4" /* Low */;
            break;
          case prioritySymbols.Medium:
            priority = "2" /* Medium */;
            break;
          case prioritySymbols.High:
            priority = "1" /* High */;
            break;
        }
        description = description.replace(TaskRegularExpressions.priorityRegex, "").trim();
        matched = true;
      }
      const doneDateMatch = description.match(TaskRegularExpressions.doneDateRegex);
      if (doneDateMatch !== null) {
        doneDate = window.moment(doneDateMatch[1], TaskRegularExpressions.dateFormat);
        description = description.replace(TaskRegularExpressions.doneDateRegex, "").trim();
        matched = true;
      }
      const dueDateMatch = description.match(TaskRegularExpressions.dueDateRegex);
      if (dueDateMatch !== null) {
        dueDate = window.moment(dueDateMatch[1], TaskRegularExpressions.dateFormat);
        description = description.replace(TaskRegularExpressions.dueDateRegex, "").trim();
        matched = true;
      }
      const scheduledDateMatch = description.match(TaskRegularExpressions.scheduledDateRegex);
      if (scheduledDateMatch !== null) {
        scheduledDate = window.moment(scheduledDateMatch[1], TaskRegularExpressions.dateFormat);
        description = description.replace(TaskRegularExpressions.scheduledDateRegex, "").trim();
        matched = true;
      }
      const startDateMatch = description.match(TaskRegularExpressions.startDateRegex);
      if (startDateMatch !== null) {
        startDate = window.moment(startDateMatch[1], TaskRegularExpressions.dateFormat);
        description = description.replace(TaskRegularExpressions.startDateRegex, "").trim();
        matched = true;
      }
      const recurrenceMatch = description.match(TaskRegularExpressions.recurrenceRegex);
      if (recurrenceMatch !== null) {
        recurrenceRule = recurrenceMatch[1].trim();
        description = description.replace(TaskRegularExpressions.recurrenceRegex, "").trim();
        matched = true;
      }
      const tagsMatch = description.match(TaskRegularExpressions.hashTagsFromEnd);
      if (tagsMatch != null) {
        description = description.replace(TaskRegularExpressions.hashTagsFromEnd, "").trim();
        matched = true;
        const tagName = tagsMatch[0].trim();
        trailingTags = trailingTags.length > 0 ? [tagName, trailingTags].join(" ") : tagName;
      }
      runs++;
    } while (matched && runs <= maxRuns);
    if (recurrenceRule.length > 0) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    if (DateFallback.canApplyFallback({ startDate, scheduledDate, dueDate }) && fallbackDate !== null) {
      scheduledDate = fallbackDate;
      scheduledDateIsInferred = true;
    }
    if (trailingTags.length > 0)
      description += " " + trailingTags;
    const hashTagMatch = description.match(TaskRegularExpressions.hashTags);
    if (hashTagMatch !== null) {
      tags = hashTagMatch.filter((tag) => tag !== globalFilter).map((tag) => tag.trim());
    }
    return new Task({
      status,
      description,
      path,
      indentation,
      listMarker,
      sectionStart,
      sectionIndex,
      precedingHeader,
      priority,
      startDate,
      scheduledDate,
      dueDate,
      doneDate,
      recurrence,
      blockLink,
      tags,
      originalMarkdown: line,
      scheduledDateIsInferred
    });
  }
  toLi(renderDetails) {
    return __async(this, null, function* () {
      return renderTaskLine(this, renderDetails);
    });
  }
  toString(layoutOptions) {
    const taskLayout = new TaskLayout(layoutOptions);
    let taskString = "";
    for (const component of taskLayout.layoutComponents) {
      taskString += this.componentToString(taskLayout, component);
    }
    return taskString;
  }
  componentToString(layout, component) {
    var _a;
    switch (component) {
      case "description":
        return this.description;
      case "priority": {
        let priority = "";
        if (this.priority === "1" /* High */) {
          priority = " " + prioritySymbols.High;
        } else if (this.priority === "2" /* Medium */) {
          priority = " " + prioritySymbols.Medium;
        } else if (this.priority === "4" /* Low */) {
          priority = " " + prioritySymbols.Low;
        }
        return priority;
      }
      case "startDate":
        if (!this.startDate)
          return "";
        return layout.options.shortMode ? " " + startDateSymbol : ` ${startDateSymbol} ${this.startDate.format(TaskRegularExpressions.dateFormat)}`;
      case "scheduledDate":
        if (!this.scheduledDate || this.scheduledDateIsInferred)
          return "";
        return layout.options.shortMode ? " " + scheduledDateSymbol : ` ${scheduledDateSymbol} ${this.scheduledDate.format(TaskRegularExpressions.dateFormat)}`;
      case "doneDate":
        if (!this.doneDate)
          return "";
        return layout.options.shortMode ? " " + doneDateSymbol : ` ${doneDateSymbol} ${this.doneDate.format(TaskRegularExpressions.dateFormat)}`;
      case "dueDate":
        if (!this.dueDate)
          return "";
        return layout.options.shortMode ? " " + dueDateSymbol : ` ${dueDateSymbol} ${this.dueDate.format(TaskRegularExpressions.dateFormat)}`;
      case "recurrenceRule":
        if (!this.recurrence)
          return "";
        return layout.options.shortMode ? " " + recurrenceSymbol : ` ${recurrenceSymbol} ${this.recurrence.toText()}`;
      case "blockLink":
        return (_a = this.blockLink) != null ? _a : "";
      default:
        throw new Error(`Don't know how to render task component of type '${component}'`);
    }
  }
  toFileLineString() {
    return `${this.indentation}${this.listMarker} [${this.status.symbol}] ${this.toString()}`;
  }
  toggle() {
    const newStatus = StatusRegistry.getInstance().getNextStatusOrCreate(this.status);
    let newDoneDate = null;
    let nextOccurrence = null;
    if (newStatus.isCompleted()) {
      const { setDoneDate } = getSettings();
      if (setDoneDate) {
        newDoneDate = window.moment();
      }
      if (this.recurrence !== null) {
        nextOccurrence = this.recurrence.next();
      }
    }
    const toggledTask = new Task(__spreadProps(__spreadValues({}, this), {
      status: newStatus,
      doneDate: newDoneDate
    }));
    const newTasks = [];
    if (nextOccurrence !== null) {
      const nextStatus = StatusRegistry.getInstance().getNextStatusOrCreate(newStatus);
      const nextTask = new Task(__spreadProps(__spreadValues(__spreadValues({}, this), nextOccurrence), {
        status: nextStatus,
        blockLink: ""
      }));
      newTasks.push(nextTask);
    }
    newTasks.push(toggledTask);
    return newTasks;
  }
  get urgency() {
    if (this._urgency === null) {
      this._urgency = Urgency.calculate(this);
    }
    return this._urgency;
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)\.md$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return null;
    }
  }
  getLinkText({ isFilenameUnique }) {
    let linkText;
    if (isFilenameUnique) {
      linkText = this.filename;
    } else {
      linkText = "/" + this.path;
    }
    if (linkText === null) {
      return null;
    }
    if (this.precedingHeader !== null && this.precedingHeader !== linkText) {
      linkText = linkText + " > " + this.precedingHeader;
    }
    return linkText;
  }
  static tasksListsIdentical(oldTasks, newTasks) {
    if (oldTasks.length !== newTasks.length) {
      return false;
    }
    return oldTasks.every((oldTask, index) => oldTask.identicalTo(newTasks[index]));
  }
  identicalTo(other) {
    let args = [
      "status",
      "description",
      "path",
      "indentation",
      "listMarker",
      "sectionStart",
      "sectionIndex",
      "precedingHeader",
      "priority",
      "blockLink",
      "scheduledDateIsInferred"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    if (this.tags.length !== other.tags.length) {
      return false;
    }
    if (!this.tags.every(function(element2, index) {
      return element2 === other.tags[index];
    })) {
      return false;
    }
    args = ["startDate", "scheduledDate", "dueDate", "doneDate"];
    for (const el of args) {
      const date1 = this[el];
      const date2 = other[el];
      if (DateField.compareByDate(date1, date2) !== 0) {
        return false;
      }
    }
    const recurrence1 = this.recurrence;
    const recurrence2 = other.recurrence;
    if (recurrence1 === null && recurrence2 !== null) {
      return false;
    } else if (recurrence1 !== null && recurrence2 === null) {
      return false;
    } else if (recurrence1 && recurrence2 && !recurrence1.identicalTo(recurrence2)) {
      return false;
    }
    return true;
  }
  getDescriptionWithoutGlobalFilter() {
    const { globalFilter } = getSettings();
    let description = this.description;
    if (globalFilter.length === 0)
      return description;
    const globalFilterRegex = RegExp("(^|\\s)" + escapeRegExp(globalFilter) + "($|\\s)", "ug");
    if (this.description.search(globalFilterRegex) > -1) {
      description = description.replace(globalFilterRegex, "$1$2").replace("  ", " ").trim();
    }
    return description;
  }
};

// src/lib/Lazy.ts
var Lazy = class {
  constructor(fetch) {
    this.fetch = fetch;
    this._value = void 0;
  }
  get value() {
    if (this._value === void 0) {
      this._value = this.fetch();
    }
    return this._value;
  }
};

// src/Cache.ts
var Cache2 = class {
  constructor({ metadataCache: metadataCache2, vault: vault2, events }) {
    this.metadataCache = metadataCache2;
    this.metadataCacheEventReferences = [];
    this.vault = vault2;
    this.vaultEventReferences = [];
    this.events = events;
    this.eventsEventReferences = [];
    this.tasksMutex = new Mutex();
    this.state = "Cold" /* Cold */;
    this.tasks = [];
    this.loadedAfterFirstResolve = false;
    this.subscribeToCache();
    this.subscribeToVault();
    this.subscribeToEvents();
    this.loadVault();
  }
  unload() {
    for (const eventReference of this.metadataCacheEventReferences) {
      this.metadataCache.offref(eventReference);
    }
    for (const eventReference of this.vaultEventReferences) {
      this.vault.offref(eventReference);
    }
    for (const eventReference of this.eventsEventReferences) {
      this.events.off(eventReference);
    }
  }
  getTasks() {
    return this.tasks;
  }
  getState() {
    return this.state;
  }
  notifySubscribers() {
    this.events.triggerCacheUpdate({
      tasks: this.tasks,
      state: this.state
    });
  }
  subscribeToCache() {
    const resolvedEventeReference = this.metadataCache.on("resolved", () => __async(this, null, function* () {
      if (!this.loadedAfterFirstResolve) {
        this.loadedAfterFirstResolve = true;
        this.loadVault();
      }
    }));
    this.metadataCacheEventReferences.push(resolvedEventeReference);
    const changedEventReference = this.metadataCache.on("changed", (file) => {
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.metadataCacheEventReferences.push(changedEventReference);
  }
  subscribeToVault() {
    const { useFilenameAsScheduledDate } = getSettings();
    const createdEventReference = this.vault.on("create", (file) => {
      if (!(file instanceof import_obsidian3.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.vaultEventReferences.push(createdEventReference);
    const deletedEventReference = this.vault.on("delete", (file) => {
      if (!(file instanceof import_obsidian3.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        this.tasks = this.tasks.filter((task) => {
          return task.path !== file.path;
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(deletedEventReference);
    const renamedEventReference = this.vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian3.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        const fallbackDate = new Lazy(() => DateFallback.fromPath(file.path));
        this.tasks = this.tasks.map((task) => {
          if (task.path === oldPath) {
            if (!useFilenameAsScheduledDate) {
              return new Task(__spreadProps(__spreadValues({}, task), { path: file.path }));
            } else {
              return DateFallback.updateTaskPath(task, file.path, fallbackDate.value);
            }
          } else {
            return task;
          }
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(renamedEventReference);
  }
  subscribeToEvents() {
    const requestReference = this.events.onRequestCacheUpdate((handler) => {
      handler({ tasks: this.tasks, state: this.state });
    });
    this.eventsEventReferences.push(requestReference);
  }
  loadVault() {
    return this.tasksMutex.runExclusive(() => __async(this, null, function* () {
      this.state = "Initializing" /* Initializing */;
      yield Promise.all(
        this.vault.getMarkdownFiles().map((file) => {
          return this.indexFile(file);
        })
      );
      this.state = "Warm" /* Warm */;
      this.notifySubscribers();
    }));
  }
  indexFile(file) {
    return __async(this, null, function* () {
      const fileCache = this.metadataCache.getFileCache(file);
      if (fileCache === null || fileCache === void 0) {
        return;
      }
      const oldTasks = this.tasks.filter((task) => {
        return task.path === file.path;
      });
      const listItems = fileCache.listItems;
      let newTasks = [];
      if (listItems !== void 0) {
        const fileContent = yield this.vault.cachedRead(file);
        newTasks = this.getTasksFromFileContent(fileContent, listItems, fileCache, file);
      }
      if (Task.tasksListsIdentical(oldTasks, newTasks)) {
        return;
      }
      if (this.getState() == "Warm" /* Warm */) {
        console.debug(
          `At least one task, its line number or its heading has changed in ${file.path}: triggering a refresh of all active Tasks blocks in Live Preview and Reading mode views.`
        );
      }
      this.tasks = this.tasks.filter((task) => {
        return task.path !== file.path;
      });
      this.tasks.push(...newTasks);
      this.notifySubscribers();
    });
  }
  getTasksFromFileContent(fileContent, listItems, fileCache, file) {
    const tasks = [];
    const fileLines = fileContent.split("\n");
    const linesInFile = fileLines.length;
    const dateFromFileName = new Lazy(() => DateFallback.fromPath(file.path));
    let currentSection = null;
    let sectionIndex = 0;
    for (const listItem of listItems) {
      if (listItem.task !== void 0) {
        const lineNumber = listItem.position.start.line;
        if (lineNumber >= linesInFile) {
          console.log(
            `${file.path} Obsidian gave us a line number ${lineNumber} past the end of the file. ${linesInFile}.`
          );
          return tasks;
        }
        if (currentSection === null || currentSection.position.end.line < lineNumber) {
          currentSection = Cache2.getSection(lineNumber, fileCache.sections);
          sectionIndex = 0;
        }
        if (currentSection === null) {
          continue;
        }
        const line = fileLines[lineNumber];
        if (line === void 0) {
          console.log(`${file.path}: line ${lineNumber} - ignoring 'undefined' line.`);
          continue;
        }
        let task;
        try {
          task = Task.fromLine({
            line,
            path: file.path,
            sectionStart: currentSection.position.start.line,
            sectionIndex,
            precedingHeader: Cache2.getPrecedingHeader(lineNumber, fileCache.headings),
            fallbackDate: dateFromFileName.value
          });
        } catch (e) {
          this.reportTaskParsingErrorToUser(e, file, listItem, line);
          continue;
        }
        if (task !== null) {
          sectionIndex++;
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  reportTaskParsingErrorToUser(e, file, listItem, line) {
    const msg = `There was an error reading one of the tasks in this vault.
The following task has been ignored, to prevent Tasks queries getting stuck with 'Loading Tasks ...'
Error: ${e}
File: ${file.path}
Line number: ${listItem.position.start.line}
Task line: ${line}

Please create a bug report for this message at
https://github.com/obsidian-tasks-group/obsidian-tasks/issues/new/choose
to help us find and fix the underlying issue.

Include:
- either a screenshot of the error popup, or copy the text from the console, if on a desktop machine.
- the output from running the Obsidian command 'Show debug info'

The error popup will only be shown when Tasks is starting up, but if the error persists,
it will be shown in the console every time this file is edited during the Obsidian
session.
`;
    console.error(msg);
    if (e instanceof Error) {
      console.error(e.stack);
    }
    if (this.state === "Initializing" /* Initializing */) {
      new import_obsidian3.Notice(msg, 1e4);
    }
  }
  static getSection(lineNumberTask, sections) {
    if (sections === void 0) {
      return null;
    }
    for (const section of sections) {
      if (section.position.start.line <= lineNumberTask && section.position.end.line >= lineNumberTask) {
        return section;
      }
    }
    return null;
  }
  static getPrecedingHeader(lineNumberTask, headings) {
    if (headings === void 0) {
      return null;
    }
    let precedingHeader = null;
    for (const heading of headings) {
      if (heading.position.start.line > lineNumberTask) {
        return precedingHeader;
      }
      precedingHeader = heading.heading;
    }
    return precedingHeader;
  }
};

// src/Commands/CreateOrEdit.ts
var import_obsidian5 = require("obsidian");

// src/TaskModal.ts
var import_obsidian4 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/EditTask.svelte
var chrono2 = __toESM(require_dist());

// src/DateAbbreviations.ts
var abbreviations = {
  td: "today",
  tm: "tomorrow",
  yd: "yesterday",
  tw: "this week",
  nw: "next week",
  weekend: "sat",
  we: "sat"
};
function doAutocomplete(date) {
  for (const [key, val] of Object.entries(abbreviations)) {
    date = date.replace(RegExp(`\\b${key}\\s`, "i"), val);
  }
  return date;
}

// src/ui/EditTask.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i].value;
  child_ctx[34] = list[i].label;
  child_ctx[35] = list[i].symbol;
  return child_ctx;
}
function create_if_block(ctx) {
  let span;
  let t_value = ctx[35] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_1(ctx) {
  let span1;
  let input;
  let input_id_value;
  let input_value_value;
  let input_accesskey_value;
  let t0;
  let label;
  let span0;
  let t1_value = ctx[34] + "";
  let t1;
  let t2;
  let show_if = ctx[35] && ctx[35].charCodeAt(0) >= 256;
  let label_for_value;
  let t3;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block(ctx);
  return {
    c() {
      span1 = element("span");
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = "priority-" + ctx[33]);
      input.__value = input_value_value = ctx[33];
      input.value = input.__value;
      attr(input, "accesskey", input_accesskey_value = ctx[9](ctx[34].charAt(0).toLowerCase()));
      ctx[21][0].push(input);
      attr(span0, "class", "accesskey-first");
      attr(label, "for", label_for_value = "priority-" + ctx[33]);
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, input);
      input.checked = input.__value === ctx[1].priority;
      append(span1, t0);
      append(span1, label);
      append(label, span0);
      append(span0, t1);
      append(label, t2);
      if (if_block)
        if_block.m(label, null);
      append(span1, t3);
      if (!mounted) {
        dispose = listen(input, "change", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && input_accesskey_value !== (input_accesskey_value = ctx2[9](ctx2[34].charAt(0).toLowerCase()))) {
        attr(input, "accesskey", input_accesskey_value);
      }
      if (dirty[0] & 3) {
        input.checked = input.__value === ctx2[1].priority;
      }
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx[21][0].splice(ctx[21][0].indexOf(input), 1);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let option;
  let t0_value = ctx[30].name + "";
  let t0;
  let t1;
  let t2_value = ctx[30].symbol + "";
  let t2;
  let t3;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = text(" [");
      t2 = text(t2_value);
      t3 = text("]");
      option.__value = option_value_value = ctx[30];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
      append(option, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t0_value !== (t0_value = ctx2[30].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[30].symbol + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 1 && option_value_value !== (option_value_value = ctx2[30])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment(ctx) {
  let div9;
  let form;
  let div0;
  let label0;
  let t3;
  let input0;
  let input0_accesskey_value;
  let t4;
  let div1;
  let label1;
  let t5;
  let label1_for_value;
  let t6;
  let t7;
  let div3;
  let label2;
  let t9;
  let input1;
  let input1_accesskey_value;
  let t10;
  let code0;
  let t11;
  let t12;
  let html_tag;
  let t13;
  let label3;
  let t15;
  let input2;
  let input2_accesskey_value;
  let t16;
  let code1;
  let t17;
  let t18;
  let html_tag_1;
  let t19;
  let label4;
  let t21;
  let input3;
  let input3_accesskey_value;
  let t22;
  let code2;
  let t23;
  let t24;
  let html_tag_2;
  let t25;
  let label5;
  let t29;
  let input4;
  let input4_accesskey_value;
  let t30;
  let code3;
  let t31;
  let t32;
  let html_tag_3;
  let t33;
  let div2;
  let label6;
  let t37;
  let input5;
  let input5_accesskey_value;
  let t38;
  let div4;
  let label7;
  let t40;
  let select;
  let t41;
  let div7;
  let div5;
  let label8;
  let t43;
  let input6;
  let input6_checked_value;
  let t44;
  let div6;
  let span3;
  let t46;
  let code4;
  let t47;
  let div8;
  let button0;
  let t49;
  let button1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[10];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div9 = element("div");
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      label0.innerHTML = `Descrip<span class="accesskey">t</span>ion`;
      t3 = space();
      input0 = element("input");
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      t5 = text("Priority");
      t6 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t7 = space();
      div3 = element("div");
      label2 = element("label");
      label2.textContent = "Recurs";
      t9 = space();
      input1 = element("input");
      t10 = space();
      code0 = element("code");
      t11 = text(recurrenceSymbol);
      t12 = space();
      html_tag = new HtmlTag(false);
      t13 = space();
      label3 = element("label");
      label3.textContent = "Due";
      t15 = space();
      input2 = element("input");
      t16 = space();
      code1 = element("code");
      t17 = text(dueDateSymbol);
      t18 = space();
      html_tag_1 = new HtmlTag(false);
      t19 = space();
      label4 = element("label");
      label4.textContent = "Scheduled";
      t21 = space();
      input3 = element("input");
      t22 = space();
      code2 = element("code");
      t23 = text(scheduledDateSymbol);
      t24 = space();
      html_tag_2 = new HtmlTag(false);
      t25 = space();
      label5 = element("label");
      label5.innerHTML = `St<span class="accesskey">a</span>rt`;
      t29 = space();
      input4 = element("input");
      t30 = space();
      code3 = element("code");
      t31 = text(startDateSymbol);
      t32 = space();
      html_tag_3 = new HtmlTag(false);
      t33 = space();
      div2 = element("div");
      label6 = element("label");
      label6.innerHTML = `Only
                    <span class="accesskey-first">future</span> dates:`;
      t37 = space();
      input5 = element("input");
      t38 = space();
      div4 = element("div");
      label7 = element("label");
      label7.textContent = "Status";
      t40 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t41 = space();
      div7 = element("div");
      div5 = element("div");
      label8 = element("label");
      label8.textContent = "Completed:";
      t43 = space();
      input6 = element("input");
      t44 = space();
      div6 = element("div");
      span3 = element("span");
      span3.textContent = "Done on:";
      t46 = space();
      code4 = element("code");
      t47 = space();
      div8 = element("div");
      button0 = element("button");
      button0.textContent = "Apply";
      t49 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(label0, "for", "description");
      attr(input0, "id", "description");
      attr(input0, "type", "text");
      attr(input0, "class", "tasks-modal-description");
      attr(input0, "placeholder", "Take out the trash");
      attr(input0, "accesskey", input0_accesskey_value = ctx[9]("t"));
      attr(div0, "class", "tasks-modal-section");
      attr(label1, "for", label1_for_value = "priority-" + ctx[1].priority);
      attr(div1, "class", "tasks-modal-section tasks-modal-priorities");
      attr(label2, "for", "recurrence");
      attr(label2, "class", "accesskey-first");
      attr(input1, "id", "recurrence");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Try 'every 2 weeks on Thursday'.");
      attr(input1, "accesskey", input1_accesskey_value = ctx[9]("r"));
      html_tag.a = null;
      attr(label3, "for", "due");
      attr(label3, "class", "accesskey-first");
      attr(input2, "id", "due");
      attr(input2, "type", "text");
      attr(input2, "placeholder", datePlaceholder);
      attr(input2, "accesskey", input2_accesskey_value = ctx[9]("d"));
      html_tag_1.a = null;
      attr(label4, "for", "scheduled");
      attr(label4, "class", "accesskey-first");
      attr(input3, "id", "scheduled");
      attr(input3, "type", "text");
      attr(input3, "placeholder", datePlaceholder);
      attr(input3, "accesskey", input3_accesskey_value = ctx[9]("s"));
      html_tag_2.a = null;
      attr(label5, "for", "start");
      attr(input4, "id", "start");
      attr(input4, "type", "text");
      attr(input4, "placeholder", datePlaceholder);
      attr(input4, "accesskey", input4_accesskey_value = ctx[9]("a"));
      html_tag_3.a = null;
      attr(label6, "for", "forwardOnly");
      attr(input5, "id", "forwardOnly");
      attr(input5, "type", "checkbox");
      attr(input5, "class", "task-list-item-checkbox tasks-modal-checkbox");
      attr(input5, "accesskey", input5_accesskey_value = ctx[9]("f"));
      attr(div3, "class", "tasks-modal-section tasks-modal-dates");
      attr(label7, "for", "status");
      attr(select, "id", "status-type");
      attr(select, "class", "dropdown");
      if (ctx[1].status === void 0)
        add_render_callback(() => ctx[27].call(select));
      attr(div4, "class", "tasks-modal-section");
      attr(label8, "for", "status");
      attr(input6, "id", "status");
      attr(input6, "type", "checkbox");
      attr(input6, "class", "task-list-item-checkbox tasks-modal-checkbox");
      input6.checked = input6_checked_value = ctx[1].status.isCompleted();
      input6.disabled = true;
      attr(div7, "class", "tasks-modal-section tasks-modal-status");
      attr(button0, "type", "submit");
      attr(button0, "class", "mod-cta");
      attr(button1, "type", "button");
      attr(div8, "class", "tasks-modal-section tasks-modal-buttons");
      toggle_class(form, "with-accesskeys", ctx[2]);
      attr(div9, "class", "tasks-modal");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t3);
      append(div0, input0);
      set_input_value(input0, ctx[1].description);
      ctx[19](input0);
      append(form, t4);
      append(form, div1);
      append(div1, label1);
      append(label1, t5);
      append(div1, t6);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div1, null);
      }
      append(form, t7);
      append(form, div3);
      append(div3, label2);
      append(div3, t9);
      append(div3, input1);
      set_input_value(input1, ctx[1].recurrenceRule);
      append(div3, t10);
      append(div3, code0);
      append(code0, t11);
      append(code0, t12);
      html_tag.m(ctx[7], code0);
      append(div3, t13);
      append(div3, label3);
      append(div3, t15);
      append(div3, input2);
      set_input_value(input2, ctx[1].dueDate);
      append(div3, t16);
      append(div3, code1);
      append(code1, t17);
      append(code1, t18);
      html_tag_1.m(ctx[6], code1);
      append(div3, t19);
      append(div3, label4);
      append(div3, t21);
      append(div3, input3);
      set_input_value(input3, ctx[1].scheduledDate);
      append(div3, t22);
      append(div3, code2);
      append(code2, t23);
      append(code2, t24);
      html_tag_2.m(ctx[5], code2);
      append(div3, t25);
      append(div3, label5);
      append(div3, t29);
      append(div3, input4);
      set_input_value(input4, ctx[1].startDate);
      append(div3, t30);
      append(div3, code3);
      append(code3, t31);
      append(code3, t32);
      html_tag_3.m(ctx[4], code3);
      append(div3, t33);
      append(div3, div2);
      append(div2, label6);
      append(div2, t37);
      append(div2, input5);
      input5.checked = ctx[1].forwardOnly;
      append(form, t38);
      append(form, div4);
      append(div4, label7);
      append(div4, t40);
      append(div4, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[1].status);
      append(form, t41);
      append(form, div7);
      append(div7, div5);
      append(div5, label8);
      append(div5, t43);
      append(div5, input6);
      append(div7, t44);
      append(div7, div6);
      append(div6, span3);
      append(div6, t46);
      append(div6, code4);
      code4.innerHTML = ctx[8];
      append(form, t47);
      append(form, div8);
      append(div8, button0);
      append(div8, t49);
      append(div8, button1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[18]),
          listen(div1, "keyup", ctx[11]),
          listen(input1, "input", ctx[22]),
          listen(input2, "input", ctx[23]),
          listen(input3, "input", ctx[24]),
          listen(input4, "input", ctx[25]),
          listen(input5, "change", ctx[26]),
          listen(select, "change", ctx[27]),
          listen(button1, "click", ctx[12]),
          listen(form, "submit", prevent_default(ctx[13]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && input0_accesskey_value !== (input0_accesskey_value = ctx2[9]("t"))) {
        attr(input0, "accesskey", input0_accesskey_value);
      }
      if (dirty[0] & 3 && input0.value !== ctx2[1].description) {
        set_input_value(input0, ctx2[1].description);
      }
      if (dirty[0] & 3 && label1_for_value !== (label1_for_value = "priority-" + ctx2[1].priority)) {
        attr(label1, "for", label1_for_value);
      }
      if (dirty[0] & 1538) {
        each_value_1 = ctx2[10];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty[0] & 512 && input1_accesskey_value !== (input1_accesskey_value = ctx2[9]("r"))) {
        attr(input1, "accesskey", input1_accesskey_value);
      }
      if (dirty[0] & 3 && input1.value !== ctx2[1].recurrenceRule) {
        set_input_value(input1, ctx2[1].recurrenceRule);
      }
      if (dirty[0] & 128)
        html_tag.p(ctx2[7]);
      if (dirty[0] & 512 && input2_accesskey_value !== (input2_accesskey_value = ctx2[9]("d"))) {
        attr(input2, "accesskey", input2_accesskey_value);
      }
      if (dirty[0] & 3 && input2.value !== ctx2[1].dueDate) {
        set_input_value(input2, ctx2[1].dueDate);
      }
      if (dirty[0] & 64)
        html_tag_1.p(ctx2[6]);
      if (dirty[0] & 512 && input3_accesskey_value !== (input3_accesskey_value = ctx2[9]("s"))) {
        attr(input3, "accesskey", input3_accesskey_value);
      }
      if (dirty[0] & 3 && input3.value !== ctx2[1].scheduledDate) {
        set_input_value(input3, ctx2[1].scheduledDate);
      }
      if (dirty[0] & 32)
        html_tag_2.p(ctx2[5]);
      if (dirty[0] & 512 && input4_accesskey_value !== (input4_accesskey_value = ctx2[9]("a"))) {
        attr(input4, "accesskey", input4_accesskey_value);
      }
      if (dirty[0] & 3 && input4.value !== ctx2[1].startDate) {
        set_input_value(input4, ctx2[1].startDate);
      }
      if (dirty[0] & 16)
        html_tag_3.p(ctx2[4]);
      if (dirty[0] & 512 && input5_accesskey_value !== (input5_accesskey_value = ctx2[9]("f"))) {
        attr(input5, "accesskey", input5_accesskey_value);
      }
      if (dirty[0] & 3) {
        input5.checked = ctx2[1].forwardOnly;
      }
      if (dirty[0] & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 3) {
        select_option(select, ctx2[1].status);
      }
      if (dirty[0] & 3 && input6_checked_value !== (input6_checked_value = ctx2[1].status.isCompleted())) {
        input6.checked = input6_checked_value;
      }
      if (dirty[0] & 256)
        code4.innerHTML = ctx2[8];
      ;
      if (dirty[0] & 4) {
        toggle_class(form, "with-accesskeys", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div9);
      ctx[19](null);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
var datePlaceholder = "Try 'Monday' or 'tomorrow', or [td|tm|yd|tw|nw|we] then space.";
function instance($$self, $$props, $$invalidate) {
  let accesskey;
  var _a, _b;
  let { task } = $$props;
  let { onSubmit } = $$props;
  let { statusOptions } = $$props;
  let descriptionInput;
  let editableTask = {
    description: "",
    status: Status.TODO,
    priority: "none",
    recurrenceRule: "",
    startDate: "",
    scheduledDate: "",
    dueDate: "",
    doneDate: "",
    forwardOnly: true
  };
  let parsedStartDate = "";
  let parsedScheduledDate = "";
  let parsedDueDate = "";
  let parsedRecurrence = "";
  let parsedDone = "";
  let addGlobalFilterOnSave = false;
  let withAccessKeys = true;
  const priorityOptions = [
    {
      value: "low",
      label: "Low",
      symbol: prioritySymbols.Low
    },
    {
      value: "none",
      label: "Normal",
      symbol: prioritySymbols.None
    },
    {
      value: "medium",
      label: "Medium",
      symbol: prioritySymbols.Medium
    },
    {
      value: "high",
      label: "High",
      symbol: prioritySymbols.High
    }
  ];
  function parseDate3(type, date, forwardDate = void 0) {
    if (!date) {
      return `<i>no ${type} date</i>`;
    }
    const parsed = chrono2.parseDate(date, forwardDate, { forwardDate: forwardDate != void 0 });
    if (parsed !== null) {
      return window.moment(parsed).format("YYYY-MM-DD");
    }
    return `<i>invalid ${type} date</i>`;
  }
  onMount(() => {
    const { globalFilter, provideAccessKeys } = getSettings();
    $$invalidate(2, withAccessKeys = provideAccessKeys);
    const description = task.getDescriptionWithoutGlobalFilter();
    if (description != task.description || description.indexOf(globalFilter) == -1)
      addGlobalFilterOnSave = true;
    let priority = "none";
    if (task.priority === "4" /* Low */) {
      priority = "low";
    } else if (task.priority === "2" /* Medium */) {
      priority = "medium";
    } else if (task.priority === "1" /* High */) {
      priority = "high";
    }
    $$invalidate(1, editableTask = {
      description,
      status: task.status,
      priority,
      recurrenceRule: task.recurrence ? task.recurrence.toText() : "",
      startDate: task.startDate ? task.startDate.format("YYYY-MM-DD") : "",
      scheduledDate: task.scheduledDate ? task.scheduledDate.format("YYYY-MM-DD") : "",
      dueDate: task.dueDate ? task.dueDate.format("YYYY-MM-DD") : "",
      doneDate: task.doneDate ? task.doneDate.format("YYYY-MM-DD") : "",
      forwardOnly: true
    });
    setTimeout(
      () => {
        descriptionInput.focus();
      },
      10
    );
  });
  const _onPriorityKeyup = (event) => {
    if (event.key && !event.altKey && !event.ctrlKey) {
      const priorityOption = priorityOptions.find((option) => option.label.charAt(0).toLowerCase() == event.key);
      if (priorityOption) {
        $$invalidate(1, editableTask.priority = priorityOption.value, editableTask);
      }
    }
  };
  const _onClose = () => {
    onSubmit([]);
  };
  const _onSubmit = () => {
    const { globalFilter } = getSettings();
    let description = editableTask.description.trim();
    if (addGlobalFilterOnSave) {
      description = globalFilter + " " + description;
    }
    let startDate = null;
    const parsedStartDate2 = chrono2.parseDate(editableTask.startDate, new Date(), { forwardDate: editableTask.forwardOnly });
    if (parsedStartDate2 !== null) {
      startDate = window.moment(parsedStartDate2);
    }
    let scheduledDate = null;
    const parsedScheduledDate2 = chrono2.parseDate(editableTask.scheduledDate, new Date(), { forwardDate: editableTask.forwardOnly });
    if (parsedScheduledDate2 !== null) {
      scheduledDate = window.moment(parsedScheduledDate2);
    }
    let dueDate = null;
    const parsedDueDate2 = chrono2.parseDate(editableTask.dueDate, new Date(), { forwardDate: editableTask.forwardOnly });
    if (parsedDueDate2 !== null) {
      dueDate = window.moment(parsedDueDate2);
    }
    let recurrence = null;
    if (editableTask.recurrenceRule) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: editableTask.recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    let parsedPriority;
    switch (editableTask.priority) {
      case "low":
        parsedPriority = "4" /* Low */;
        break;
      case "medium":
        parsedPriority = "2" /* Medium */;
        break;
      case "high":
        parsedPriority = "1" /* High */;
        break;
      default:
        parsedPriority = "3" /* None */;
    }
    const updatedTask = new Task(Object.assign(Object.assign({}, task), {
      description,
      status: editableTask.status,
      priority: parsedPriority,
      recurrence,
      startDate,
      scheduledDate,
      dueDate,
      doneDate: window.moment(editableTask.doneDate, "YYYY-MM-DD").isValid() ? window.moment(editableTask.doneDate, "YYYY-MM-DD") : null
    }));
    onSubmit([updatedTask]);
  };
  const $$binding_groups = [[]];
  function input0_input_handler() {
    editableTask.description = this.value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      descriptionInput = $$value;
      $$invalidate(3, descriptionInput);
    });
  }
  function input_change_handler() {
    editableTask.priority = this.__value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input1_input_handler() {
    editableTask.recurrenceRule = this.value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input2_input_handler() {
    editableTask.dueDate = this.value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input3_input_handler() {
    editableTask.scheduledDate = this.value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input4_input_handler() {
    editableTask.startDate = this.value;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function input5_change_handler() {
    editableTask.forwardOnly = this.checked;
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  function select_change_handler() {
    editableTask.status = select_value(this);
    $$invalidate(1, editableTask);
    $$invalidate(0, statusOptions);
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(14, task = $$props2.task);
    if ("onSubmit" in $$props2)
      $$invalidate(15, onSubmit = $$props2.onSubmit);
    if ("statusOptions" in $$props2)
      $$invalidate(0, statusOptions = $$props2.statusOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4) {
      $:
        $$invalidate(9, accesskey = (key) => withAccessKeys ? key : null);
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        $$invalidate(1, editableTask.startDate = doAutocomplete(editableTask.startDate), editableTask);
        $$invalidate(4, parsedStartDate = parseDate3("start", editableTask.startDate, editableTask.forwardOnly ? new Date() : void 0));
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        $$invalidate(1, editableTask.scheduledDate = doAutocomplete(editableTask.scheduledDate), editableTask);
        $$invalidate(5, parsedScheduledDate = parseDate3("scheduled", editableTask.scheduledDate, editableTask.forwardOnly ? new Date() : void 0));
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        $$invalidate(1, editableTask.dueDate = doAutocomplete(editableTask.dueDate), editableTask);
        $$invalidate(6, parsedDueDate = parseDate3("due", editableTask.dueDate, editableTask.forwardOnly ? new Date() : void 0));
      }
    }
    if ($$self.$$.dirty[0] & 196610) {
      $: {
        if (!editableTask.recurrenceRule) {
          $$invalidate(7, parsedRecurrence = "<i>not recurring</>");
        } else {
          $$invalidate(7, parsedRecurrence = $$invalidate(17, _b = $$invalidate(16, _a = Recurrence.fromText({
            recurrenceRuleText: editableTask.recurrenceRule,
            startDate: null,
            scheduledDate: null,
            dueDate: null
          })) === null || _a === void 0 ? void 0 : _a.toText()) !== null && _b !== void 0 ? _b : "<i>invalid recurrence rule</i>");
        }
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        $$invalidate(8, parsedDone = parseDate3("done", editableTask.doneDate));
      }
    }
  };
  return [
    statusOptions,
    editableTask,
    withAccessKeys,
    descriptionInput,
    parsedStartDate,
    parsedScheduledDate,
    parsedDueDate,
    parsedRecurrence,
    parsedDone,
    accesskey,
    priorityOptions,
    _onPriorityKeyup,
    _onClose,
    _onSubmit,
    task,
    onSubmit,
    _a,
    _b,
    input0_input_handler,
    input0_binding,
    input_change_handler,
    $$binding_groups,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_change_handler,
    select_change_handler
  ];
}
var EditTask = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { task: 14, onSubmit: 15, statusOptions: 0 }, null, [-1, -1]);
  }
};
var EditTask_default = EditTask;

// src/TaskModal.ts
var TaskModal = class extends import_obsidian4.Modal {
  constructor({ app, task, onSubmit }) {
    super(app);
    this.task = task;
    this.onSubmit = (updatedTasks) => {
      updatedTasks.length && onSubmit(updatedTasks);
      this.close();
    };
  }
  onOpen() {
    this.titleEl.setText("Create or edit Task");
    const { contentEl } = this;
    const statusOptions = this.getKnownStatusesAndCurrentTaskStatusIfNotKnown();
    new EditTask_default({
      target: contentEl,
      props: { task: this.task, statusOptions, onSubmit: this.onSubmit }
    });
  }
  getKnownStatusesAndCurrentTaskStatusIfNotKnown() {
    const statusOptions = StatusRegistry.getInstance().registeredStatuses;
    if (StatusRegistry.getInstance().bySymbol(this.task.status.symbol) === Status.EMPTY) {
      statusOptions.push(this.task.status);
    }
    return statusOptions;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Commands/CreateOrEditTaskParser.ts
var taskFromLine = ({ line, path }) => {
  var _a, _b;
  const fallbackDate = DateFallback.fromPath(path);
  const task = Task.fromLine({
    line,
    path,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null,
    fallbackDate
  });
  if (task !== null) {
    return task;
  }
  const nonTaskMatch = line.match(TaskRegularExpressions.nonTaskRegex);
  if (nonTaskMatch === null) {
    console.error("Tasks: Cannot create task on line:", line);
    return new Task({
      status: Status.TODO,
      description: "",
      path,
      indentation: "",
      listMarker: "-",
      priority: "3" /* None */,
      startDate: null,
      scheduledDate: null,
      dueDate: null,
      doneDate: null,
      recurrence: null,
      sectionStart: 0,
      sectionIndex: 0,
      precedingHeader: null,
      blockLink: "",
      tags: [],
      originalMarkdown: "",
      scheduledDateIsInferred: false
    });
  }
  const indentation = nonTaskMatch[1];
  const listMarker = (_a = nonTaskMatch[2]) != null ? _a : "-";
  const statusString = (_b = nonTaskMatch[4]) != null ? _b : " ";
  const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
  let description = nonTaskMatch[5];
  const blockLinkMatch = line.match(TaskRegularExpressions.blockLinkRegex);
  const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
  if (blockLink !== "") {
    description = description.replace(TaskRegularExpressions.blockLinkRegex, "");
  }
  return new Task({
    status,
    description,
    path,
    indentation,
    listMarker,
    blockLink,
    priority: "3" /* None */,
    startDate: null,
    scheduledDate: null,
    dueDate: null,
    doneDate: null,
    recurrence: null,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null,
    tags: [],
    originalMarkdown: "",
    scheduledDateIsInferred: false
  });
};

// src/Commands/CreateOrEdit.ts
var createOrEdit = (checking, editor, view, app) => {
  var _a;
  if (checking) {
    return view instanceof import_obsidian5.MarkdownView;
  }
  if (!(view instanceof import_obsidian5.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const cursorPosition = editor.getCursor();
  const lineNumber = cursorPosition.line;
  const line = editor.getLine(lineNumber);
  const task = taskFromLine({ line, path });
  const onSubmit = (updatedTasks) => {
    const serialized = DateFallback.removeInferredStatusIfNeeded(task, updatedTasks).map((task2) => task2.toFileLineString()).join("\n");
    editor.setLine(lineNumber, serialized);
  };
  const taskModal = new TaskModal({
    app,
    task,
    onSubmit
  });
  taskModal.open();
};

// src/Commands/ToggleDone.ts
var import_obsidian6 = require("obsidian");
var toggleDone = (checking, editor, view) => {
  var _a;
  if (checking) {
    if (!(view instanceof import_obsidian6.MarkdownView)) {
      return false;
    }
    return true;
  }
  if (!(view instanceof import_obsidian6.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const origCursorPos = editor.getCursor();
  const lineNumber = origCursorPos.line;
  const line = editor.getLine(lineNumber);
  const toggledLine = toggleLine(line, path);
  editor.setLine(lineNumber, toggledLine);
  editor.setCursor({
    line: origCursorPos.line,
    ch: calculateCursorOffset(origCursorPos.ch, line, toggledLine)
  });
};
var toggleLine = (line, path) => {
  let toggledLine = line;
  const task = Task.fromLine({
    line,
    path,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null,
    fallbackDate: null
  });
  if (task !== null) {
    toggledLine = toggleTask(task);
  } else {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch !== null) {
      const statusString = regexMatch[3];
      const status = StatusRegistry.getInstance().bySymbol(statusString);
      const newStatusString = status.nextStatusSymbol;
      toggledLine = line.replace(TaskRegularExpressions.taskRegex, `$1- [${newStatusString}] $4`);
    } else if (TaskRegularExpressions.listItemRegex.test(line)) {
      toggledLine = line.replace(TaskRegularExpressions.listItemRegex, "$1$2 [ ]");
    } else {
      toggledLine = line.replace(TaskRegularExpressions.indentationRegex, "$1- ");
    }
  }
  return toggledLine;
};
var toggleTask = (task) => {
  const toggledTasks = task.toggle();
  return toggledTasks.map((task2) => task2.toFileLineString()).join("\n");
};
var calculateCursorOffset = (origCursorCh, line, toggledLine) => {
  let newLineLen = toggledLine.length;
  if (newLineLen <= line.length) {
    return origCursorCh >= toggledLine.length ? newLineLen : origCursorCh;
  }
  const doneDateLength = " \u2705 YYYY-MM-DD".length;
  if (toggledLine.match(TaskRegularExpressions.doneDateRegex) && newLineLen - line.length >= doneDateLength) {
    newLineLen -= doneDateLength;
  }
  if (newLineLen >= 2 * line.length && toggledLine.search(".+\n.+") !== -1) {
    return origCursorCh + newLineLen - line.length;
  }
  const firstListItemChar = toggledLine.search(/[-*]/);
  if (origCursorCh < firstListItemChar) {
    return origCursorCh;
  }
  return origCursorCh + newLineLen - line.length;
};

// src/Commands/index.ts
var Commands = class {
  get app() {
    return this.plugin.app;
  }
  constructor({ plugin }) {
    this.plugin = plugin;
    plugin.addCommand({
      id: "edit-task",
      name: "Create or edit task",
      icon: "pencil",
      editorCheckCallback: (checking, editor, view) => {
        return createOrEdit(checking, editor, view, this.app);
      }
    });
    plugin.addCommand({
      id: "toggle-done",
      name: "Toggle task done",
      icon: "check-in-circle",
      editorCheckCallback: toggleDone
    });
  }
};

// src/TasksEvents.ts
var TasksEvents = class {
  constructor({ obsidianEvents }) {
    this.obsidianEvents = obsidianEvents;
  }
  onCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, handler);
  }
  triggerCacheUpdate(cacheData) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, cacheData);
  }
  onRequestCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, handler);
  }
  triggerRequestCacheUpdate(fn) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, fn);
  }
  off(eventRef) {
    this.obsidianEvents.offref(eventRef);
  }
};

// src/InlineRenderer.ts
var InlineRenderer = class {
  constructor({ plugin }) {
    this.markdownPostProcessor = this._markdownPostProcessor.bind(this);
    plugin.registerMarkdownPostProcessor(this._markdownPostProcessor.bind(this));
  }
  _markdownPostProcessor(element2, context) {
    return __async(this, null, function* () {
      var _a;
      const { globalFilter } = getSettings();
      const renderedElements = element2.findAll(".task-list-item").filter((taskItem) => {
        var _a2;
        const linesText = (_a2 = taskItem.textContent) == null ? void 0 : _a2.split("\n");
        if (linesText === void 0) {
          return false;
        }
        let firstLineText = null;
        for (let i = 0; i < linesText.length; i = i + 1) {
          if (linesText[i] !== "") {
            firstLineText = linesText[i];
            break;
          }
        }
        if (firstLineText === null) {
          return false;
        }
        return firstLineText.includes(globalFilter);
      });
      if (renderedElements.length === 0) {
        return;
      }
      const path = context.sourcePath;
      const section = context.getSectionInfo(element2);
      if (section === null) {
        return;
      }
      const fileLines = section.text.split("\n");
      let sectionIndex = 0;
      const fileTasks = [];
      for (let lineNumber = section.lineStart; lineNumber <= section.lineEnd; lineNumber++) {
        const line = fileLines[lineNumber];
        if (line === void 0) {
          continue;
        }
        const task = Task.fromLine({
          line,
          path,
          sectionStart: section.lineStart,
          sectionIndex,
          precedingHeader: null,
          fallbackDate: null
        });
        if (task !== null) {
          fileTasks.push(task);
          sectionIndex++;
        }
      }
      for (let sectionIndex2 = 0; sectionIndex2 < renderedElements.length; sectionIndex2++) {
        const task = fileTasks[sectionIndex2];
        const renderedElement = renderedElements[sectionIndex2];
        if (task === void 0 || renderedElement === void 0) {
          continue;
        }
        const dataLine = (_a = renderedElement.getAttr("data-line")) != null ? _a : "0";
        const listIndex = Number.parseInt(dataLine, 10);
        const taskElement = yield task.toLi({
          parentUlElement: element2,
          listIndex
        });
        const renderedChildren = renderedElement.childNodes;
        for (let i = 0; i < renderedChildren.length; i = i + 1) {
          const renderedChild = renderedChildren[i];
          if (renderedChild.nodeName.toLowerCase() === "div") {
            taskElement.prepend(renderedChild);
          } else if (renderedChild.nodeName.toLowerCase() === "ul") {
            taskElement.append(renderedChild);
          }
        }
        const originalFootnotes = renderedElement.querySelectorAll("[data-footnote-id]");
        const newFootnotes = taskElement.querySelectorAll("[data-footnote-id]");
        if (originalFootnotes.length === newFootnotes.length) {
          for (let i = 0; i < originalFootnotes.length; i++) {
            newFootnotes[i].replaceWith(originalFootnotes[i]);
          }
        }
        renderedElement.replaceWith(taskElement);
      }
    });
  }
};

// src/LivePreviewExtension.ts
var import_view = require("@codemirror/view");
var import_obsidian7 = require("obsidian");
var newLivePreviewExtension = () => {
  return import_view.ViewPlugin.fromClass(LivePreviewExtension);
};
var LivePreviewExtension = class {
  constructor(view) {
    this.view = view;
    this.handleClickEvent = this.handleClickEvent.bind(this);
    this.view.dom.addEventListener("click", this.handleClickEvent);
  }
  destroy() {
    this.view.dom.removeEventListener("click", this.handleClickEvent);
  }
  handleClickEvent(event) {
    const { target } = event;
    if (!target || !(target instanceof HTMLInputElement) || target.type !== "checkbox") {
      return false;
    }
    const ancestor = target.closest("ul.plugin-tasks-query-result, div.callout-content");
    if (ancestor) {
      if (ancestor.matches("div.callout-content")) {
        const msg = 'obsidian-tasks-plugin warning: Tasks cannot add or remove completion dates or make the next copy of a recurring task for tasks written inside a callout when you click their checkboxes in Live Preview. \nIf you wanted Tasks to do these things, please undo your change, then either click the line of the task and use the "Toggle Task Done" command, or switch to Reading View to click the checkbox.';
        console.warn(msg);
        new import_obsidian7.Notice(msg, 45e3);
      }
      return false;
    }
    const { state } = this.view;
    const position = this.view.posAtDOM(target);
    const line = state.doc.lineAt(position);
    const task = Task.fromLine({
      line: line.text,
      path: "",
      sectionStart: 0,
      sectionIndex: 0,
      precedingHeader: null,
      fallbackDate: null
    });
    console.debug(`Live Preview Extension: toggle called. Position: ${position} Line: ${line.text}`);
    if (task === null) {
      return false;
    }
    event.preventDefault();
    const toggled = task.toggle();
    const toggledString = toggled.map((t) => t.toFileLineString()).join(state.lineBreak);
    const transaction = state.update({
      changes: {
        from: line.from,
        to: line.to,
        insert: toggledString
      }
    });
    this.view.dispatch(transaction);
    const desiredCheckedStatus = target.checked;
    setTimeout(() => {
      target.checked = desiredCheckedStatus;
    }, 1);
    return true;
  }
};

// src/QueryRenderer.ts
var import_obsidian8 = require("obsidian");

// src/Query/Filter/FilterInstructionsBasedField.ts
var FilterInstructionsBasedField = class extends Field {
  constructor() {
    super(...arguments);
    this._filters = new FilterInstructions();
  }
  canCreateFilterForLine(line) {
    return this._filters.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    return this._filters.createFilterOrErrorMessage(line);
  }
  filterRegExp() {
    return null;
  }
};

// src/Query/Filter/StatusField.ts
var StatusField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add(
      "done",
      (task) => task.status.type === "DONE" /* DONE */ || task.status.type === "CANCELLED" /* CANCELLED */ || task.status.type === "NON_TASK" /* NON_TASK */
    );
    this._filters.add(
      "not done",
      (task) => task.status.type === "TODO" /* TODO */ || task.status.type === "IN_PROGRESS" /* IN_PROGRESS */
    );
  }
  fieldName() {
    return "status";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const oldStatusNameA = StatusField.oldStatusName(a);
      const oldStatusNameB = StatusField.oldStatusName(b);
      if (oldStatusNameA < oldStatusNameB) {
        return 1;
      } else if (oldStatusNameA > oldStatusNameB) {
        return -1;
      } else {
        return 0;
      }
    };
  }
  static oldStatusName(a) {
    if (a.status.symbol === " ") {
      return "Todo";
    } else {
      return "Done";
    }
  }
};

// src/Query/Filter/DueDateField.ts
var _DueDateField = class extends DateField {
  filterRegExp() {
    return _DueDateField.dueRegexp;
  }
  fieldName() {
    return "due";
  }
  date(task) {
    return task.dueDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var DueDateField = _DueDateField;
DueDateField.dueRegexp = /^due (before|after|on)? ?(.*)/;

// src/Query/Filter/PriorityField.ts
var _PriorityField = class extends Field {
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage(line);
    const priorityMatch = Field.getMatch(this.filterRegExp(), line);
    if (priorityMatch !== null) {
      const filterPriorityString = priorityMatch[5];
      let filterPriority = null;
      switch (filterPriorityString) {
        case "low":
          filterPriority = "4" /* Low */;
          break;
        case "none":
          filterPriority = "3" /* None */;
          break;
        case "medium":
          filterPriority = "2" /* Medium */;
          break;
        case "high":
          filterPriority = "1" /* High */;
          break;
      }
      if (filterPriority === null) {
        result.error = "do not understand priority";
        return result;
      }
      let explanation = line;
      let filter;
      switch (priorityMatch[3]) {
        case "above":
          filter = (task) => task.priority.localeCompare(filterPriority) < 0;
          break;
        case "below":
          filter = (task) => task.priority.localeCompare(filterPriority) > 0;
          break;
        case "not":
          filter = (task) => task.priority !== filterPriority;
          break;
        default:
          filter = (task) => task.priority === filterPriority;
          explanation = `${this.fieldName()} is ${filterPriorityString}`;
      }
      result.filter = new Filter(line, filter, new Explanation(explanation));
    } else {
      result.error = "do not understand query filter (priority)";
    }
    return result;
  }
  fieldName() {
    return "priority";
  }
  filterRegExp() {
    return _PriorityField.priorityRegexp;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return a.priority.localeCompare(b.priority);
    };
  }
};
var PriorityField = _PriorityField;
PriorityField.priorityRegexp = /^priority(\s+is)?(\s+(above|below|not))?(\s+(low|none|medium|high))$/;

// src/Query/Matchers/IStringMatcher.ts
var IStringMatcher = class {
  matchesAnyOf(stringsToSearch) {
    return stringsToSearch.some((s) => this.matches(s));
  }
};

// src/Query/Matchers/SubstringMatcher.ts
var SubstringMatcher = class extends IStringMatcher {
  constructor(stringToFind) {
    super();
    this.stringToFind = stringToFind;
  }
  matches(stringToSearch) {
    return SubstringMatcher.stringIncludesCaseInsensitive(stringToSearch, this.stringToFind);
  }
  static stringIncludesCaseInsensitive(haystack, needle) {
    return haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase());
  }
};

// src/Query/Matchers/RegexMatcher.ts
var RegexMatcher = class extends IStringMatcher {
  constructor(regex) {
    super();
    this.regex = regex;
  }
  static validateAndConstruct(regexInput) {
    const regexPattern = /\/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/;
    const query = regexInput.match(regexPattern);
    if (query !== null) {
      const regExp = new RegExp(query[1], query[2]);
      return new RegexMatcher(regExp);
    } else {
      return null;
    }
  }
  matches(stringToSearch) {
    return stringToSearch.match(this.regex) !== null;
  }
};

// src/Query/Filter/TextField.ts
var TextField = class extends Field {
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const [_, filterOperator, filterValue] = match;
    let matcher = null;
    if (filterOperator.includes("include")) {
      matcher = new SubstringMatcher(filterValue);
    } else if (filterOperator.includes("regex")) {
      matcher = RegexMatcher.validateAndConstruct(filterValue);
      if (matcher === null) {
        return FilterOrErrorMessage.fromError(
          line,
          `cannot parse regex (${this.fieldName()}); check your leading and trailing slashes for your query`
        );
      }
    }
    if (matcher === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const negate = filterOperator.match(/not/) !== null;
    const filter = new Filter(line, this.getFilter(matcher, negate), new Explanation(line));
    return FilterOrErrorMessage.fromFilter(filter);
  }
  fieldPattern() {
    return this.fieldNameSingularEscaped();
  }
  filterOperatorPattern() {
    return "includes|does not include|regex matches|regex does not match";
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldPattern()}) (${this.filterOperatorPattern()}) (.*)`);
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matches(this.value(task));
      return negate ? !match : match;
    };
  }
  comparator() {
    return (a, b) => {
      return this.value(a).localeCompare(this.value(b), void 0, { numeric: true });
    };
  }
  grouper() {
    return (task) => {
      return [this.value(task)];
    };
  }
};

// src/Query/Filter/PathField.ts
var PathField = class extends TextField {
  fieldName() {
    return "path";
  }
  value(task) {
    return task.path;
  }
  supportsSorting() {
    return true;
  }
};

// src/Query/Filter/UrgencyField.ts
var UrgencyField = class extends Field {
  canCreateFilterForLine(_line) {
    return false;
  }
  createFilterOrErrorMessage(line) {
    return FilterOrErrorMessage.fromError(line, "Filtering by urgency is not yet supported");
  }
  fieldName() {
    return "urgency";
  }
  filterRegExp() {
    throw Error(`filterRegExp() unimplemented for ${this.fieldName()}`);
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return b.urgency - a.urgency;
    };
  }
};

// src/Query/Sort.ts
var Sort = class {
  static by(sorters, tasks) {
    const defaultComparators = [
      new UrgencyField().comparator(),
      new StatusField().comparator(),
      new DueDateField().comparator(),
      new PriorityField().comparator(),
      new PathField().comparator()
    ];
    const userComparators = [];
    for (const sorter of sorters) {
      userComparators.push(sorter.comparator);
    }
    return tasks.sort(Sort.makeCompositeComparator([...userComparators, ...defaultComparators]));
  }
  static makeCompositeComparator(comparators) {
    return (a, b) => {
      for (const comparator of comparators) {
        const result = comparator(a, b);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    };
  }
};

// src/Query/Filter/DescriptionField.ts
var DescriptionField = class extends TextField {
  fieldName() {
    return "description";
  }
  value(task) {
    const globalFilter = getSettings().globalFilter;
    return task.description.replace(globalFilter, "").trim();
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const descriptionA = DescriptionField.cleanDescription(a.description);
      const descriptionB = DescriptionField.cleanDescription(b.description);
      return descriptionA.localeCompare(descriptionB, void 0, { numeric: true });
    };
  }
  static cleanDescription(description) {
    const globalFilter = getSettings().globalFilter;
    description = description.replace(globalFilter, "").trim();
    const startsWithLinkRegex = /^\[\[?([^\]]*)]]?/;
    const linkRegexMatch = description.match(startsWithLinkRegex);
    if (linkRegexMatch !== null) {
      const innerLinkText = linkRegexMatch[1];
      description = innerLinkText.substring(innerLinkText.indexOf("|") + 1) + description.replace(startsWithLinkRegex, "");
    }
    description = this.replaceFormatting(description, /^\*\*([^*]+)\*\*/);
    description = this.replaceFormatting(description, /^\*([^*]+)\*/);
    description = this.replaceFormatting(description, /^==([^=]+)==/);
    description = this.replaceFormatting(description, /^__([^_]+)__/);
    description = this.replaceFormatting(description, /^_([^_]+)_/);
    return description;
  }
  static replaceFormatting(description, regExp) {
    const italicBoldRegexMatch = description.match(regExp);
    if (italicBoldRegexMatch !== null) {
      const innerItalicBoldText = italicBoldRegexMatch[1];
      description = innerItalicBoldText + description.replace(regExp, "");
    }
    return description;
  }
};

// src/Query/Filter/DoneDateField.ts
var _DoneDateField = class extends DateField {
  filterRegExp() {
    return _DoneDateField.doneRegexp;
  }
  fieldName() {
    return "done";
  }
  date(task) {
    return task.doneDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var DoneDateField = _DoneDateField;
DoneDateField.doneRegexp = /^done (before|after|on)? ?(.*)/;

// src/Query/Filter/ExcludeSubItemsField.ts
var ExcludeSubItemsField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("exclude sub-items", (task) => {
      if (task.indentation === "")
        return true;
      const lastBlockquoteMark = task.indentation.lastIndexOf(">");
      if (lastBlockquoteMark === -1)
        return false;
      return /^ ?$/.test(task.indentation.slice(lastBlockquoteMark + 1));
    });
  }
  fieldName() {
    return "exclude";
  }
};

// src/Query/Filter/HeadingField.ts
var HeadingField = class extends TextField {
  fieldName() {
    return "heading";
  }
  value(task) {
    if (task.precedingHeader) {
      return task.precedingHeader;
    } else {
      return "";
    }
  }
  supportsSorting() {
    return true;
  }
};

// src/Query/Filter/ScheduledDateField.ts
var _ScheduledDateField = class extends DateField {
  filterRegExp() {
    return _ScheduledDateField.scheduledRegexp;
  }
  fieldName() {
    return "scheduled";
  }
  date(task) {
    return task.scheduledDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var ScheduledDateField = _ScheduledDateField;
ScheduledDateField.scheduledRegexp = /^scheduled (before|after|on)? ?(.*)/;

// src/Query/Filter/StartDateField.ts
var _StartDateField = class extends DateField {
  filterRegExp() {
    return _StartDateField.startRegexp;
  }
  fieldName() {
    return "start";
  }
  date(task) {
    return task.startDate;
  }
  filterResultIfFieldMissing() {
    return true;
  }
};
var StartDateField = _StartDateField;
StartDateField.startRegexp = /^starts (before|after|on)? ?(.*)/;

// src/Query/Filter/HappensDateField.ts
var _HappensDateField = class extends Field {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add(
      _HappensDateField.instructionForFieldPresence,
      (task) => this.dates(task).some((date) => date !== null)
    );
    this.filterInstructions.add(
      _HappensDateField.instructionForFieldAbsence,
      (task) => !this.dates(task).some((date) => date !== null)
    );
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.filter !== void 0) {
      return filterResult;
    }
    const result = new FilterOrErrorMessage(line);
    const happensMatch = Field.getMatch(this.filterRegExp(), line);
    if (happensMatch !== null) {
      const filterDate = DateParser.parseDate(happensMatch[2]);
      if (!filterDate.isValid()) {
        result.error = "do not understand happens date";
      } else {
        let filterFunction;
        let relative;
        if (happensMatch[1] === "before") {
          filterFunction = (task) => {
            return this.dates(task).some((date) => date && date.isBefore(filterDate));
          };
          relative = " " + happensMatch[1];
        } else if (happensMatch[1] === "after") {
          filterFunction = (task) => {
            return this.dates(task).some((date) => date && date.isAfter(filterDate));
          };
          relative = " " + happensMatch[1];
        } else {
          filterFunction = (task) => {
            return this.dates(task).some((date) => date && date.isSame(filterDate));
          };
          relative = " on";
        }
        const explanation = DateField.getExplanationString(
          "due, start or scheduled",
          relative,
          false,
          filterDate
        );
        result.filter = new Filter(line, filterFunction, new Explanation(explanation));
      }
    } else {
      result.error = "do not understand query filter (happens date)";
    }
    return result;
  }
  earliestDate(task) {
    const happensDates = new _HappensDateField().dates(task);
    const sortedHappensDates = happensDates.sort(DateField.compareByDate);
    return sortedHappensDates[0];
  }
  filterRegExp() {
    return _HappensDateField.happensRegexp;
  }
  dates(task) {
    return Array.of(task.startDate, task.scheduledDate, task.dueDate);
  }
  fieldName() {
    return "happens";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return DateField.compareByDate(this.earliestDate(a), this.earliestDate(b));
    };
  }
};
var HappensDateField = _HappensDateField;
HappensDateField.happensRegexp = /^happens (before|after|on)? ?(.*)/;
HappensDateField.instructionForFieldPresence = "has happens date";
HappensDateField.instructionForFieldAbsence = "no happens date";

// src/Query/Filter/RecurringField.ts
var RecurringField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("is recurring", (task) => task.recurrence !== null);
    this._filters.add("is not recurring", (task) => task.recurrence === null);
  }
  fieldName() {
    return "recurring";
  }
};

// src/Query/Filter/MultiTextField.ts
var MultiTextField = class extends TextField {
  fieldNamePlural() {
    return this.fieldNameSingular() + "s";
  }
  fieldName() {
    return `${this.fieldNameSingular()}/${this.fieldNamePlural()}`;
  }
  fieldPattern() {
    return `${this.fieldNameSingular()}|${this.fieldNamePlural()}`;
  }
  filterOperatorPattern() {
    return `${super.filterOperatorPattern()}|include|do not include`;
  }
  value(task) {
    return this.values(task).join(", ");
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matchesAnyOf(this.values(task));
      return negate ? !match : match;
    };
  }
};

// src/Query/Filter/TagsField.ts
var TagsField = class extends MultiTextField {
  fieldNameSingular() {
    return "tag";
  }
  values(task) {
    return task.tags;
  }
  supportsSorting() {
    return true;
  }
  createSorterFromLine(line) {
    const match = line.match(this.sorterRegExp());
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const propertyInstance = isNaN(+match[2]) ? 1 : +match[2];
    const comparator = TagsField.makeCompareByTagComparator(propertyInstance);
    return new Sorter(this.fieldNameSingular(), comparator, reverse);
  }
  sorterRegExp() {
    return /^sort by tag( reverse)?[\s]*(\d+)?/;
  }
  comparator() {
    return TagsField.makeCompareByTagComparator(1);
  }
  static makeCompareByTagComparator(propertyInstance) {
    return (a, b) => {
      if (a.tags.length === 0 && b.tags.length === 0) {
        return 0;
      } else if (a.tags.length === 0) {
        return 1;
      } else if (b.tags.length === 0) {
        return -1;
      }
      const tagInstanceToSortBy = propertyInstance - 1;
      if (a.tags.length < propertyInstance && b.tags.length >= propertyInstance) {
        return 1;
      } else if (b.tags.length < propertyInstance && a.tags.length >= propertyInstance) {
        return -1;
      } else if (a.tags.length < propertyInstance && b.tags.length < propertyInstance) {
        return 0;
      }
      const tagA = a.tags[tagInstanceToSortBy];
      const tagB = b.tags[tagInstanceToSortBy];
      return tagA.localeCompare(tagB, void 0, { numeric: true });
    };
  }
};

// src/Query/Filter/BooleanField.ts
var import_boon_js = __toESM(require_lib());
var BooleanField = class extends Field {
  constructor() {
    super(...arguments);
    this.basicBooleanRegexp = /(.*(AND|OR|XOR|NOT)\s*[("].*|\(.+\))/g;
    this.supportedOperators = ["AND", "OR", "XOR", "NOT"];
    this.subFields = {};
  }
  filterRegExp() {
    return this.basicBooleanRegexp;
  }
  createFilterOrErrorMessage(line) {
    return this.parseLine(line);
  }
  fieldName() {
    return "boolean query";
  }
  parseLine(line) {
    const result = new FilterOrErrorMessage(line);
    if (line.length === 0) {
      result.error = "empty line";
      return result;
    }
    const preprocessed = this.preprocessExpression(line);
    try {
      const postfixExpression = (0, import_boon_js.parse)(preprocessed);
      for (const token of postfixExpression) {
        if (token.name === "IDENTIFIER" && token.value) {
          const identifier = token.value.trim();
          if (!(identifier in this.subFields)) {
            const parsedField = parseFilter(identifier);
            if (parsedField === null) {
              result.error = `couldn't parse sub-expression '${identifier}'`;
              return result;
            }
            if (parsedField.error) {
              result.error = `couldn't parse sub-expression '${identifier}': ${parsedField.error}`;
              return result;
            } else if (parsedField.filter) {
              this.subFields[identifier] = parsedField.filter;
            }
          }
        } else if (token.name === "OPERATOR") {
          if (token.value == void 0) {
            result.error = "empty operator in boolean query";
            return result;
          }
          if (!this.supportedOperators.includes(token.value)) {
            result.error = `unknown boolean operator '${token.value}'`;
            return result;
          }
        }
      }
      const filterFunction = (task) => {
        return this.filterTaskWithParsedQuery(task, postfixExpression);
      };
      const explanation = this.constructExplanation(postfixExpression);
      result.filter = new Filter(line, filterFunction, explanation);
      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error type";
      result.error = `malformed boolean query -- ${message} (check the documentation for guidelines)`;
      return result;
    }
    return result;
  }
  preprocessExpression(line) {
    return line.replace(/\(([^()]+)\)/g, '("$1")');
  }
  filterTaskWithParsedQuery(task, postfixExpression) {
    const toBool = (s) => {
      return s === "true";
    };
    const toString = (b) => {
      return b ? "true" : "false";
    };
    const booleanStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        const result = filter.filterFunction(task);
        booleanStack.push(toString(result));
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = toBool(booleanStack.pop());
          booleanStack.push(toString(!arg1));
        } else if (token.value === "OR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 || arg2));
        } else if (token.value === "AND") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && arg2));
        } else if (token.value === "XOR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && !arg2 || !arg1 && arg2));
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token);
      }
    }
    return toBool(booleanStack[0]);
  }
  constructExplanation(postfixExpression) {
    const explanationStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        explanationStack.push(filter.explanation);
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanNot([arg1]));
        } else if (token.value === "OR") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanOr([arg1, arg2]));
        } else if (token.value === "AND") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanAnd([arg1, arg2]));
        } else if (token.value === "XOR") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanXor([arg1, arg2]));
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token);
      }
    }
    return explanationStack[0];
  }
};

// src/Query/Filter/FilenameField.ts
var FilenameField = class extends TextField {
  fieldName() {
    return "filename";
  }
  value(task) {
    const filename = task.filename;
    if (filename === null) {
      return "";
    }
    return filename + ".md";
  }
  supportsSorting() {
    return true;
  }
};

// src/Query/Filter/StatusNameField.ts
var StatusNameField = class extends TextField {
  constructor() {
    super();
  }
  fieldName() {
    return "status.name";
  }
  value(task) {
    return task.status.name;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
};

// src/Query/Filter/StatusTypeField.ts
var StatusTypeField = class extends Field {
  canCreateFilterForLine(line) {
    const relaxedRegExp = new RegExp(`^(?:${this.fieldNameSingularEscaped()})`);
    return Field.lineMatchesFilter(relaxedRegExp, line);
  }
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return this.helpMessage(line);
    }
    const [_, filterOperator, statusTypeAsString] = match;
    const statusTypeElement = StatusType[statusTypeAsString.toUpperCase()];
    if (!statusTypeElement) {
      return this.helpMessage(line);
    }
    let filterFunction;
    switch (filterOperator) {
      case "is":
        filterFunction = (task) => {
          return task.status.type === statusTypeElement;
        };
        break;
      case "is not":
        filterFunction = (task) => {
          return task.status.type !== statusTypeElement;
        };
        break;
      default:
        return this.helpMessage(line);
    }
    return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, new Explanation(line)));
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldNameSingularEscaped()}) (is|is not) ([^ ]+)$`);
  }
  helpMessage(line) {
    const allowedTypes = Object.values(StatusType).filter((t) => t !== "EMPTY" /* EMPTY */).join(" ");
    const message = `Invalid ${this.fieldNameSingular()} instruction: '${line}'.
    Allowed options: 'is' and 'is not' (without quotes).
    Allowed values:  ${allowedTypes}
                     Note: values are case-insensitive,
                           so 'in_progress' works too, for example.
    Example:         ${this.fieldNameSingular()} is not NON_TASK`;
    return FilterOrErrorMessage.fromError(line, message);
  }
  fieldName() {
    return "status.type";
  }
  value(task) {
    return task.status.type;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const keyA = StatusTypeField.groupName(a);
      const keyB = StatusTypeField.groupName(b);
      return keyA.localeCompare(keyB, void 0, { numeric: true });
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [StatusTypeField.groupName(task)];
    };
  }
  static groupName(task) {
    let prefix;
    switch (task.status.type) {
      case "IN_PROGRESS" /* IN_PROGRESS */:
        prefix = "1";
        break;
      case "TODO" /* TODO */:
        prefix = "2";
        break;
      case "DONE" /* DONE */:
        prefix = "3";
        break;
      case "CANCELLED" /* CANCELLED */:
        prefix = "4";
        break;
      case "NON_TASK" /* NON_TASK */:
        prefix = "5";
        break;
      case "EMPTY" /* EMPTY */:
        prefix = "6";
        break;
    }
    return prefix + " " + task.status.type;
  }
};

// src/Query/Filter/RecurrenceField.ts
var RecurrenceField = class extends TextField {
  fieldName() {
    return "recurrence";
  }
  value(task) {
    if (task.recurrence !== null) {
      return task.recurrence.toText();
    } else {
      return "";
    }
  }
};

// src/Query/FilterParser.ts
var fieldCreators = [
  () => new StatusNameField(),
  () => new StatusTypeField(),
  () => new StatusField(),
  () => new RecurringField(),
  () => new PriorityField(),
  () => new HappensDateField(),
  () => new StartDateField(),
  () => new ScheduledDateField(),
  () => new DueDateField(),
  () => new DoneDateField(),
  () => new PathField(),
  () => new DescriptionField(),
  () => new TagsField(),
  () => new HeadingField(),
  () => new ExcludeSubItemsField(),
  () => new BooleanField(),
  () => new FilenameField(),
  () => new UrgencyField(),
  () => new RecurrenceField()
];
function parseFilter(filterString) {
  for (const creator of fieldCreators) {
    const field = creator();
    if (field.canCreateFilterForLine(filterString))
      return field.createFilterOrErrorMessage(filterString);
  }
  return null;
}
function parseSorter(sorterString) {
  const sortByRegexp = /^sort by /;
  if (sorterString.match(sortByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const sorter = field.parseSortLine(sorterString);
    if (sorter) {
      return sorter;
    }
  }
  return null;
}
function parseGrouper(line) {
  const groupByRegexp = /^group by /;
  if (line.match(groupByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const fieldName = field.fieldNameSingular();
    if (line === `group by ${fieldName}`) {
      if (field.supportsGrouping()) {
        return field.createGrouper();
      }
    }
  }
  return null;
}

// src/Query/GroupHeading.ts
var GroupHeading = class {
  constructor(nestingLevel, name) {
    this.nestingLevel = nestingLevel;
    this.name = name;
  }
};

// src/Query/GroupHeadings.ts
var GroupHeadings = class {
  constructor(groupedTasks) {
    this.lastHeadingAtLevel = new Array();
    const firstGroup = groupedTasks.keys().next().value;
    const groupCount = firstGroup.length;
    for (let i = 0; i < groupCount; i++) {
      this.lastHeadingAtLevel.push("");
    }
  }
  getHeadingsForTaskGroup(groupNames) {
    const headingsForGroup = new Array();
    for (let level = 0; level < groupNames.length; level++) {
      const group = groupNames[level];
      if (group != this.lastHeadingAtLevel[level]) {
        headingsForGroup.push(new GroupHeading(level, group));
        for (let j = level; j < groupNames.length; j++) {
          this.lastHeadingAtLevel[j] = "";
        }
        this.lastHeadingAtLevel[level] = group;
      }
    }
    return headingsForGroup;
  }
};

// src/Query/GroupingTreeNode.ts
var GroupingTreeNode = class {
  constructor(values) {
    this.children = /* @__PURE__ */ new Map();
    this.values = [];
    this.values = values;
  }
  generateAllPaths(pathSoFar = []) {
    const resultMap = /* @__PURE__ */ new Map();
    if (this.children.size == 0) {
      resultMap.set([...pathSoFar], this.values);
      return resultMap;
    }
    for (const [property, child] of this.children) {
      pathSoFar.push(property);
      const childResult = child.generateAllPaths(pathSoFar);
      childResult.forEach((value, key) => resultMap.set(key, value));
      pathSoFar.pop();
    }
    return resultMap;
  }
};

// src/Query/IntermediateTaskGroups.ts
var IntermediateTaskGroupsStorage = class extends Map {
};
var TaskGroupingTreeNode = class extends GroupingTreeNode {
};
var IntermediateTaskGroups = class {
  constructor(groupings, tasks) {
    this.groups = new IntermediateTaskGroupsStorage();
    const tree = this.buildGroupingTree(groupings, tasks);
    this.groups = tree.generateAllPaths();
    this.groups = this.getSortedGroups();
  }
  buildGroupingTree(groupings, tasks) {
    const root = new TaskGroupingTreeNode(tasks);
    let currentTreeLevel = [root];
    for (const grouping of groupings) {
      const nextTreeLevel = [];
      for (const currentTreeNode of currentTreeLevel) {
        for (const task of currentTreeNode.values) {
          const groupNames = Group.getGroupNamesForTask(grouping, task);
          for (const groupName of groupNames) {
            let child = currentTreeNode.children.get(groupName);
            if (child === void 0) {
              child = new TaskGroupingTreeNode([]);
              currentTreeNode.children.set(groupName, child);
              nextTreeLevel.push(child);
            }
            child.values.push(task);
          }
        }
      }
      currentTreeLevel = nextTreeLevel;
    }
    return root;
  }
  getSortedGroups() {
    return new IntermediateTaskGroupsStorage([...this.groups.entries()].sort());
  }
};

// src/Query/TaskGroup.ts
var TaskGroup = class {
  constructor(groups, groupHeadings, tasks) {
    this.groups = groups;
    this.groupHeadings = groupHeadings;
    this.tasks = tasks;
  }
  tasksAsStringOfLines() {
    let output = "";
    for (const task of this.tasks) {
      output += task.toFileLineString() + "\n";
    }
    return output;
  }
  toString() {
    let output = "\n";
    output += `Group names: [${this.groups}]
`;
    for (const heading of this.groupHeadings) {
      const headingPrefix = "#".repeat(4 + heading.nestingLevel);
      output += `${headingPrefix} ${heading.name}
`;
    }
    output += this.tasksAsStringOfLines();
    return output;
  }
};

// src/Query/TaskGroups.ts
var TaskGroups = class {
  constructor(groups, tasks) {
    this._groups = new Array();
    this._totalTaskCount = 0;
    this._totalTaskCount = tasks.length;
    const initialGroups = new IntermediateTaskGroups(groups, tasks);
    this.addTasks(initialGroups);
  }
  get groups() {
    return this._groups;
  }
  totalTasksCount() {
    return this._totalTaskCount;
  }
  toString() {
    let output = "";
    for (const taskGroup of this.groups) {
      output += taskGroup.toString();
      output += "\n---\n";
    }
    const totalTasksCount = this.totalTasksCount();
    output += `
${totalTasksCount} tasks
`;
    return output;
  }
  addTasks(initialGroups) {
    const grouper = new GroupHeadings(initialGroups.groups);
    for (const [groups, tasks] of initialGroups.groups) {
      const groupHeadings = grouper.getHeadingsForTaskGroup(groups);
      const taskGroup = new TaskGroup(groups, groupHeadings, tasks);
      this.add(taskGroup);
    }
  }
  add(taskGroup) {
    this._groups.push(taskGroup);
  }
};

// src/Query/Group.ts
var _Group = class {
  static fromGroupingProperty(property) {
    return new Grouper(property, _Group.grouperForProperty(property));
  }
  static by(grouping, tasks) {
    return new TaskGroups(grouping, tasks);
  }
  static getGroupNamesForTask(grouping, task) {
    return grouping.grouper(task);
  }
  static grouperForProperty(property) {
    return _Group.groupers[property];
  }
  static escapeMarkdownCharacters(filename) {
    return filename.replace(/\\/g, "\\\\").replace(/_/g, "\\_");
  }
  static groupByPriority(task) {
    let priorityName = "ERROR";
    switch (task.priority) {
      case "1" /* High */:
        priorityName = "High";
        break;
      case "2" /* Medium */:
        priorityName = "Medium";
        break;
      case "3" /* None */:
        priorityName = "None";
        break;
      case "4" /* Low */:
        priorityName = "Low";
        break;
    }
    return [`Priority ${task.priority}: ${priorityName}`];
  }
  static groupByRecurrence(task) {
    if (task.recurrence !== null) {
      return [task.recurrence.toText()];
    } else {
      return ["None"];
    }
  }
  static groupByRecurring(task) {
    if (task.recurrence !== null) {
      return ["Recurring"];
    } else {
      return ["Not Recurring"];
    }
  }
  static groupByStartDate(task) {
    return [_Group.stringFromDate(task.startDate, "start")];
  }
  static groupByScheduledDate(task) {
    return [_Group.stringFromDate(task.scheduledDate, "scheduled")];
  }
  static groupByDueDate(task) {
    return [_Group.stringFromDate(task.dueDate, "due")];
  }
  static groupByDoneDate(task) {
    return [_Group.stringFromDate(task.doneDate, "done")];
  }
  static groupByHappensDate(task) {
    const earliestDateIfAny = new HappensDateField().earliestDate(task);
    return [_Group.stringFromDate(earliestDateIfAny, "happens")];
  }
  static stringFromDate(date, field) {
    if (date === null) {
      return "No " + field + " date";
    }
    return date.format(_Group.groupDateFormat);
  }
  static groupByPath(task) {
    return [_Group.escapeMarkdownCharacters(task.path.replace(".md", ""))];
  }
  static groupByFolder(task) {
    const path = task.path;
    const fileNameWithExtension = task.filename + ".md";
    const folder = path.substring(0, path.lastIndexOf(fileNameWithExtension));
    if (folder === "") {
      return ["/"];
    }
    return [_Group.escapeMarkdownCharacters(folder)];
  }
  static groupByFileName(task) {
    const filename = task.filename;
    if (filename === null) {
      return ["Unknown Location"];
    }
    return ["[[" + _Group.escapeMarkdownCharacters(filename) + "]]"];
  }
  static groupByRoot(task) {
    const path = task.path.replace(/\\/g, "/");
    const separatorIndex = path.indexOf("/");
    if (separatorIndex == -1) {
      return ["/"];
    }
    return [_Group.escapeMarkdownCharacters(path.substring(0, separatorIndex + 1))];
  }
  static groupByBacklink(task) {
    const linkText = task.getLinkText({ isFilenameUnique: true });
    if (linkText === null) {
      return ["Unknown Location"];
    }
    let filenameComponent = "Unknown Location";
    if (task.filename !== null) {
      filenameComponent = _Group.escapeMarkdownCharacters(task.filename);
    }
    if (task.precedingHeader === null || task.precedingHeader.length === 0) {
      return [filenameComponent];
    }
    const headingComponent = _Group.groupByHeading(task)[0];
    if (filenameComponent === headingComponent) {
      return [filenameComponent];
    } else {
      return [`${filenameComponent} > ${headingComponent}`];
    }
  }
  static groupByStatus(task) {
    if (task.status.symbol === " ") {
      return ["Todo"];
    } else {
      return ["Done"];
    }
  }
  static groupByHeading(task) {
    if (task.precedingHeader === null || task.precedingHeader.length === 0) {
      return ["(No heading)"];
    }
    return [task.precedingHeader];
  }
  static groupByTags(task) {
    if (task.tags.length == 0) {
      return ["(No tags)"];
    }
    return task.tags;
  }
};
var Group = _Group;
Group.groupDateFormat = "YYYY-MM-DD dddd";
Group.groupers = {
  backlink: _Group.groupByBacklink,
  done: _Group.groupByDoneDate,
  due: _Group.groupByDueDate,
  filename: _Group.groupByFileName,
  folder: _Group.groupByFolder,
  happens: _Group.groupByHappensDate,
  heading: _Group.groupByHeading,
  path: _Group.groupByPath,
  priority: _Group.groupByPriority,
  recurrence: _Group.groupByRecurrence,
  recurring: _Group.groupByRecurring,
  root: _Group.groupByRoot,
  scheduled: _Group.groupByScheduledDate,
  start: _Group.groupByStartDate,
  status: _Group.groupByStatus,
  tags: _Group.groupByTags
};

// src/Query/Query.ts
var Query = class {
  constructor({ source }) {
    this._limit = void 0;
    this._layoutOptions = new LayoutOptions();
    this._filters = [];
    this._error = void 0;
    this._sorting = [];
    this._grouping = [];
    this.groupByRegexp = /^group by (backlink|done|due|filename|folder|happens|heading|path|priority|recurrence|recurring|root|scheduled|start|status|tags)/;
    this.hideOptionsRegexp = /^(hide|show) (task count|backlink|priority|start date|scheduled date|done date|due date|recurrence rule|edit button|urgency)/;
    this.shortModeRegexp = /^short/;
    this.explainQueryRegexp = /^explain/;
    this.limitRegexp = /^limit (to )?(\d+)( tasks?)?/;
    this.commentRegexp = /^#.*/;
    this.source = source;
    source.split("\n").map((line) => line.trim()).forEach((line) => {
      switch (true) {
        case line === "":
          break;
        case this.shortModeRegexp.test(line):
          this._layoutOptions.shortMode = true;
          break;
        case this.explainQueryRegexp.test(line):
          this._layoutOptions.explainQuery = true;
          break;
        case this.limitRegexp.test(line):
          this.parseLimit({ line });
          break;
        case this.parseSortBy({ line }):
          break;
        case this.parseGroupBy2({ line }):
          break;
        case this.groupByRegexp.test(line):
          this.parseGroupBy({ line });
          break;
        case this.hideOptionsRegexp.test(line):
          this.parseHideOptions({ line });
          break;
        case this.commentRegexp.test(line):
          break;
        case this.parseFilter(line):
          break;
        default:
          this._error = `do not understand query: ${line}`;
      }
    });
  }
  explainQuery() {
    return "Explanation of this Tasks code block query:\n\n" + this.explainQueryWithoutIntroduction();
  }
  explainQueryWithoutIntroduction() {
    let result = "";
    const { globalFilter } = getSettings();
    if (globalFilter.length !== 0) {
      result += `Only tasks containing the global filter '${globalFilter}'.

`;
    }
    const numberOfFilters = this.filters.length;
    if (numberOfFilters === 0) {
      result += "No filters supplied. All tasks will match the query.";
    } else {
      for (let i = 0; i < numberOfFilters; i++) {
        if (i > 0)
          result += "\n";
        result += this.filters[i].explainFilterIndented("");
      }
    }
    if (this._limit !== void 0) {
      result += `

At most ${this._limit} task`;
      if (this._limit !== 1) {
        result += "s";
      }
      result += ".\n";
    }
    return result;
  }
  get limit() {
    return this._limit;
  }
  get layoutOptions() {
    return this._layoutOptions;
  }
  get filters() {
    return this._filters;
  }
  get sorting() {
    return this._sorting;
  }
  get grouping() {
    return this._grouping;
  }
  get error() {
    return this._error;
  }
  applyQueryToTasks(tasks) {
    this.filters.forEach((filter) => {
      tasks = tasks.filter(filter.filterFunction);
    });
    const tasksSortedLimited = Sort.by(this.sorting, tasks).slice(0, this.limit);
    return Group.by(this.grouping, tasksSortedLimited);
  }
  parseHideOptions({ line }) {
    const hideOptionsMatch = line.match(this.hideOptionsRegexp);
    if (hideOptionsMatch !== null) {
      const hide = hideOptionsMatch[1] === "hide";
      const option = hideOptionsMatch[2];
      switch (option) {
        case "task count":
          this._layoutOptions.hideTaskCount = hide;
          break;
        case "backlink":
          this._layoutOptions.hideBacklinks = hide;
          break;
        case "priority":
          this._layoutOptions.hidePriority = hide;
          break;
        case "start date":
          this._layoutOptions.hideStartDate = hide;
          break;
        case "scheduled date":
          this._layoutOptions.hideScheduledDate = hide;
          break;
        case "due date":
          this._layoutOptions.hideDueDate = hide;
          break;
        case "done date":
          this._layoutOptions.hideDoneDate = hide;
          break;
        case "recurrence rule":
          this._layoutOptions.hideRecurrenceRule = hide;
          break;
        case "edit button":
          this._layoutOptions.hideEditButton = hide;
          break;
        case "urgency":
          this._layoutOptions.hideUrgency = hide;
          break;
        default:
          this._error = "do not understand hide/show option";
      }
    }
  }
  parseFilter(line) {
    const filterOrError = parseFilter(line);
    if (filterOrError != null) {
      if (filterOrError.filter)
        this._filters.push(filterOrError.filter);
      else
        this._error = filterOrError.error;
      return true;
    }
    return false;
  }
  parseLimit({ line }) {
    const limitMatch = line.match(this.limitRegexp);
    if (limitMatch !== null) {
      this._limit = Number.parseInt(limitMatch[2], 10);
    } else {
      this._error = "do not understand query limit";
    }
  }
  parseSortBy({ line }) {
    const sortingMaybe = parseSorter(line);
    if (sortingMaybe) {
      this._sorting.push(sortingMaybe);
      return true;
    }
    return false;
  }
  parseGroupBy({ line }) {
    const fieldMatch = line.match(this.groupByRegexp);
    if (fieldMatch !== null) {
      this._grouping.push(Group.fromGroupingProperty(fieldMatch[1]));
    } else {
      this._error = "do not understand query grouping";
    }
  }
  parseGroupBy2({ line }) {
    const groupingMaybe = parseGrouper(line);
    if (groupingMaybe) {
      this._grouping.push(groupingMaybe);
      return true;
    }
    return false;
  }
};

// src/QueryRenderer.ts
var QueryRenderer = class {
  constructor({ plugin, events }) {
    this.addQueryRenderChild = this._addQueryRenderChild.bind(this);
    this.app = plugin.app;
    this.events = events;
    plugin.registerMarkdownCodeBlockProcessor("tasks", this._addQueryRenderChild.bind(this));
  }
  _addQueryRenderChild(source, element2, context) {
    return __async(this, null, function* () {
      context.addChild(
        new QueryRenderChild({
          app: this.app,
          events: this.events,
          container: element2,
          source,
          filePath: context.sourcePath
        })
      );
    });
  }
};
var QueryRenderChild = class extends import_obsidian8.MarkdownRenderChild {
  constructor({
    app,
    events,
    container,
    source,
    filePath
  }) {
    super(container);
    this.app = app;
    this.events = events;
    this.source = source;
    this.filePath = filePath;
    switch (this.containerEl.className) {
      case "block-language-tasks":
        this.query = new Query({ source });
        this.queryType = "tasks";
        break;
      default:
        this.query = new Query({ source });
        this.queryType = "tasks";
        break;
    }
  }
  onload() {
    this.events.triggerRequestCacheUpdate(this.render.bind(this));
    this.renderEventRef = this.events.onCacheUpdate(this.render.bind(this));
    this.reloadQueryAtMidnight();
  }
  onunload() {
    if (this.renderEventRef !== void 0) {
      this.events.off(this.renderEventRef);
    }
    if (this.queryReloadTimeout !== void 0) {
      clearTimeout(this.queryReloadTimeout);
    }
  }
  reloadQueryAtMidnight() {
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    const now = new Date();
    const millisecondsToMidnight = midnight.getTime() - now.getTime();
    this.queryReloadTimeout = setTimeout(() => {
      this.query = new Query({ source: this.source });
      this.events.triggerRequestCacheUpdate(this.render.bind(this));
      this.reloadQueryAtMidnight();
    }, millisecondsToMidnight + 1e3);
  }
  render(_0) {
    return __async(this, arguments, function* ({ tasks, state }) {
      var _a;
      const content = this.containerEl.createEl("div");
      if (state === "Warm" /* Warm */ && this.query.error === void 0) {
        console.debug(
          `Render ${this.queryType} called for a block in active file "${this.filePath}", to select from ${tasks.length} tasks: plugin state: ${state}`
        );
        if (this.query.layoutOptions.explainQuery) {
          this.createExplanation(content);
        }
        const tasksSortedLimitedGrouped = this.query.applyQueryToTasks(tasks);
        for (const group of tasksSortedLimitedGrouped.groups) {
          this.addGroupHeadings(content, group.groupHeadings);
          const { taskList } = yield this.createTasksList({
            tasks: group.tasks,
            content
          });
          content.appendChild(taskList);
        }
        const totalTasksCount = tasksSortedLimitedGrouped.totalTasksCount();
        console.debug(`${totalTasksCount} of ${tasks.length} tasks displayed in a block in "${this.filePath}"`);
        this.addTaskCount(content, totalTasksCount);
      } else if (this.query.error !== void 0) {
        content.createDiv().innerHTML = `<pre>Tasks query: ${this.query.error.replace(/\n/g, "<br>")}</pre>`;
      } else {
        content.setText("Loading Tasks ...");
      }
      (_a = this.containerEl.firstChild) == null ? void 0 : _a.replaceWith(content);
    });
  }
  createExplanation(content) {
    const explanationAsString = this.query.explainQuery();
    const explanationsBlock = content.createEl("pre");
    explanationsBlock.addClasses(["plugin-tasks-query-explanation"]);
    explanationsBlock.setText(explanationAsString);
    content.appendChild(explanationsBlock);
  }
  createTasksList(_0) {
    return __async(this, arguments, function* ({
      tasks,
      content
    }) {
      const tasksCount = tasks.length;
      const taskList = content.createEl("ul");
      taskList.addClasses(["contains-task-list", "plugin-tasks-query-result"]);
      for (let i = 0; i < tasksCount; i++) {
        const task = tasks[i];
        const isFilenameUnique = this.isFilenameUnique({ task });
        const listItem = yield task.toLi({
          parentUlElement: taskList,
          listIndex: i,
          layoutOptions: this.query.layoutOptions,
          isFilenameUnique
        });
        const footnotes = listItem.querySelectorAll("[data-footnote-id]");
        footnotes.forEach((footnote) => footnote.remove());
        const shortMode = this.query.layoutOptions.shortMode;
        if (!this.query.layoutOptions.hideUrgency) {
          this.addUrgency(listItem, task);
        }
        if (!this.query.layoutOptions.hideBacklinks) {
          this.addBacklinks(listItem, task, shortMode, isFilenameUnique);
        }
        if (!this.query.layoutOptions.hideEditButton) {
          this.addEditButton(listItem, task);
        }
        taskList.appendChild(listItem);
      }
      return { taskList, tasksCount };
    });
  }
  addEditButton(listItem, task) {
    const editTaskPencil = listItem.createEl("a", {
      cls: "tasks-edit"
    });
    editTaskPencil.onClickEvent((event) => {
      event.preventDefault();
      const onSubmit = (updatedTasks) => {
        replaceTaskWithTasks({
          originalTask: task,
          newTasks: DateFallback.removeInferredStatusIfNeeded(task, updatedTasks)
        });
      };
      const taskModal = new TaskModal({
        app: this.app,
        task,
        onSubmit
      });
      taskModal.open();
    });
  }
  addUrgency(listItem, task) {
    const text2 = new Intl.NumberFormat().format(task.urgency);
    listItem.createSpan({ text: text2, cls: "tasks-urgency" });
  }
  addGroupHeadings(content, groupHeadings) {
    for (const heading of groupHeadings) {
      this.addGroupHeading(content, heading);
    }
  }
  addGroupHeading(content, group) {
    return __async(this, null, function* () {
      let header;
      if (group.nestingLevel === 0) {
        header = content.createEl("h4", {
          cls: "tasks-group-heading"
        });
      } else if (group.nestingLevel === 1) {
        header = content.createEl("h5", {
          cls: "tasks-group-heading"
        });
      } else {
        header = content.createEl("h6", {
          cls: "tasks-group-heading"
        });
      }
      yield import_obsidian8.MarkdownRenderer.renderMarkdown(group.name, header, this.filePath, this);
    });
  }
  addBacklinks(listItem, task, shortMode, isFilenameUnique) {
    var _a;
    const backLink = listItem.createSpan({ cls: "tasks-backlink" });
    if (!shortMode) {
      backLink.append(" (");
    }
    const link = backLink.createEl("a");
    link.href = task.path;
    link.setAttribute("data-href", task.path);
    link.rel = "noopener";
    link.target = "_blank";
    link.addClass("internal-link");
    if (shortMode) {
      link.addClass("internal-link-short-mode");
    }
    if (task.precedingHeader !== null) {
      const sanitisedHeading = task.precedingHeader.replace(/#/g, "");
      link.href = link.href + "#" + sanitisedHeading;
      link.setAttribute("data-href", link.getAttribute("data-href") + "#" + sanitisedHeading);
    }
    let linkText;
    if (shortMode) {
      linkText = " \u{1F517}";
    } else {
      linkText = (_a = task.getLinkText({ isFilenameUnique })) != null ? _a : "";
    }
    link.setText(linkText);
    if (!shortMode) {
      backLink.append(")");
    }
  }
  addTaskCount(content, tasksCount) {
    if (!this.query.layoutOptions.hideTaskCount) {
      content.createDiv({
        text: `${tasksCount} task${tasksCount !== 1 ? "s" : ""}`,
        cls: "tasks-count"
      });
    }
  }
  isFilenameUnique({ task }) {
    const filenameMatch = task.path.match(/([^/]*)\..+$/i);
    if (filenameMatch === null) {
      return void 0;
    }
    const filename = filenameMatch[1];
    const allFilesWithSameName = this.app.vault.getMarkdownFiles().filter((file) => {
      if (file.basename === filename) {
        return true;
      }
    });
    return allFilesWithSameName.length < 2;
  }
};

// src/Config/SettingsTab.ts
var import_obsidian10 = require("obsidian");

// src/Config/settingsConfiguration.json
var settingsConfiguration_default = [
  {
    text: "Core Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: "<p>These are the core statuses that Tasks supports natively, with no need for custom CSS styling or theming.</p><p>You can add edit and add your own custom statuses in the section below.</p>"
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertTaskCoreStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  },
  {
    text: "Custom Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: `<p>You should first <b>select and install a CSS Snippet or Theme</b> to style custom checkboxes.</p><p>Then, use the buttons below to set up your custom statuses, to match your chosen CSS checkboxes.</p><p><b>Note</b> Any statuses with the same symbol as any earlier statuses will be ignored. You can confirm the actually loaded statuses by running the 'Create or edit task' command and looking at the Status drop-down.</p><p></p><p>See the <a href="https://obsidian-tasks-group.github.io/obsidian-tasks/getting-started/statuses/">documentation</a> to get started!</p>`
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertCustomTaskStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  }
];

// src/Config/CustomStatusModal.ts
var import_obsidian9 = require("obsidian");

// src/StatusValidator.ts
var StatusValidator = class {
  validate(statusConfiguration) {
    const errors = [];
    errors.push(...this.validateSymbol(statusConfiguration));
    errors.push(...this.validateName(statusConfiguration));
    errors.push(...this.validateNextSymbol(statusConfiguration));
    return errors;
  }
  validateSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.symbol, "Task Status Symbol");
  }
  validateNextSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.nextStatusSymbol, "Task Next Status Symbol");
  }
  validateName(statusConfiguration) {
    const errors = [];
    if (statusConfiguration.name.length === 0) {
      errors.push("Task Status Name cannot be empty.");
    }
    return errors;
  }
  static validateOneSymbol(symbol, symbolName) {
    const errors = [];
    if (symbol.length === 0) {
      errors.push(`${symbolName} cannot be empty.`);
    }
    if (symbol.length > 1) {
      errors.push(`${symbolName} ("${symbol}") must be a single character.`);
    }
    return errors;
  }
};

// src/Config/CustomStatusModal.ts
var validator = new StatusValidator();
var CustomStatusModal = class extends import_obsidian9.Modal {
  constructor(plugin, statusType, isCoreStatus) {
    super(plugin.app);
    this.plugin = plugin;
    this.saved = false;
    this.error = false;
    this.statusSymbol = statusType.symbol;
    this.statusName = statusType.name;
    this.statusNextSymbol = statusType.nextStatusSymbol;
    this.statusAvailableAsCommand = statusType.availableAsCommand;
    this.type = statusType.type;
    this.isCoreStatus = isCoreStatus;
  }
  statusConfiguration() {
    return new StatusConfiguration(
      this.statusSymbol,
      this.statusName,
      this.statusNextSymbol,
      this.statusAvailableAsCommand,
      this.type
    );
  }
  display() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      const settingDiv = contentEl.createDiv();
      let statusSymbolText;
      new import_obsidian9.Setting(settingDiv).setName("Task Status Symbol").setDesc(
        "This is the character between the square braces. (It can only be edited for Custom statuses, and not Core statuses.)"
      ).addText((text2) => {
        statusSymbolText = text2;
        text2.setValue(this.statusSymbol).onChange((v) => {
          this.statusSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateSymbol(this.statusConfiguration()));
        });
      }).setDisabled(this.isCoreStatus).then((_setting) => {
        CustomStatusModal.setValid(statusSymbolText, validator.validateSymbol(this.statusConfiguration()));
      });
      let statusNameText;
      new import_obsidian9.Setting(settingDiv).setName("Task Status Name").setDesc("This is the friendly name of the task status.").addText((text2) => {
        statusNameText = text2;
        text2.setValue(this.statusName).onChange((v) => {
          this.statusName = v;
          CustomStatusModal.setValid(text2, validator.validateName(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(statusNameText, validator.validateName(this.statusConfiguration()));
      });
      let statusNextSymbolText;
      new import_obsidian9.Setting(settingDiv).setName("Task Next Status Symbol").setDesc("When clicked on this is the symbol that should be used next.").addText((text2) => {
        statusNextSymbolText = text2;
        text2.setValue(this.statusNextSymbol).onChange((v) => {
          this.statusNextSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateNextSymbol(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(
          statusNextSymbolText,
          validator.validateNextSymbol(this.statusConfiguration())
        );
      });
      new import_obsidian9.Setting(settingDiv).setName("Task Status Type").setDesc("Control how the status behaves for searching and toggling.").addDropdown((dropdown) => {
        const types = [
          "TODO" /* TODO */,
          "IN_PROGRESS" /* IN_PROGRESS */,
          "DONE" /* DONE */,
          "CANCELLED" /* CANCELLED */,
          "NON_TASK" /* NON_TASK */
        ];
        types.forEach((s) => {
          dropdown.addOption(s, s);
        });
        dropdown.setValue(this.type).onChange((v) => {
          this.type = Status.getTypeFromStatusTypeString(v);
        });
      });
      if (Status.tasksPluginCanCreateCommandsForStatuses()) {
        new import_obsidian9.Setting(settingDiv).setName("Available as command").setDesc(
          "If enabled this status will be available as a command so you can assign a hotkey and toggle the status using it."
        ).addToggle((toggle) => {
          toggle.setValue(this.statusAvailableAsCommand).onChange((value) => __async(this, null, function* () {
            this.statusAvailableAsCommand = value;
          }));
        });
      }
      const footerEl = contentEl.createDiv();
      const footerButtons = new import_obsidian9.Setting(footerEl);
      footerButtons.addButton((b) => {
        b.setTooltip("Save").setIcon("checkmark").onClick(() => __async(this, null, function* () {
          const errors = validator.validate(this.statusConfiguration());
          if (errors.length > 0) {
            const message = errors.join("\n") + "\n\nFix errors before saving.";
            new import_obsidian9.Notice(message);
            return;
          }
          this.saved = true;
          this.close();
        }));
        return b;
      });
      footerButtons.addExtraButton((b) => {
        b.setIcon("cross").setTooltip("Cancel").onClick(() => {
          this.saved = false;
          this.close();
        });
        return b;
      });
    });
  }
  onOpen() {
    this.display();
  }
  static setValidationError(textInput) {
    textInput.inputEl.addClass("tasks-settings-is-invalid");
  }
  static removeValidationError(textInput) {
    textInput.inputEl.removeClass("tasks-settings-is-invalid");
  }
  static setValid(text2, messages) {
    const valid = messages.length === 0;
    if (valid) {
      CustomStatusModal.removeValidationError(text2);
    } else {
      CustomStatusModal.setValidationError(text2);
    }
  }
};

// src/Config/Themes/ITSThemeCollection.ts
function itsSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Regular", " ", "DONE"],
    ["X", "Checked", " ", "DONE"],
    ["-", "Dropped", "x", "CANCELLED"],
    [">", "Forward", "x", "TODO"],
    ["D", "Date", "x", "TODO"],
    ["?", "Question", "x", "TODO"],
    ["/", "Half Done", "x", "IN_PROGRESS"],
    ["+", "Add", "x", "TODO"],
    ["R", "Research", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["i", "Idea", "x", "TODO"],
    ["B", "Brainstorm", "x", "TODO"],
    ["P", "Pro", "x", "TODO"],
    ["C", "Con", "x", "TODO"],
    ["Q", "Quote", "x", "TODO"],
    ["N", "Note", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ["I", "Information", "x", "TODO"],
    ["p", "Paraphrase", "x", "TODO"],
    ["L", "Location", "x", "TODO"],
    ["E", "Example", "x", "TODO"],
    ["A", "Answer", "x", "TODO"],
    ["r", "Reward", "x", "TODO"],
    ["c", "Choice", "x", "TODO"],
    ["d", "Doing", "x", "TODO"],
    ["T", "Time", "x", "TODO"],
    ["@", "Character / Person", "x", "TODO"],
    ["t", "Talk", "x", "TODO"],
    ["O", "Outline / Plot", "x", "TODO"],
    ["~", "Conflict", "x", "TODO"],
    ["W", "World", "x", "TODO"],
    ["f", "Clue / Find", "x", "TODO"],
    ["F", "Foreshadow", "x", "TODO"],
    ["H", "Favorite / Health", "x", "TODO"],
    ["&", "Symbolism", "x", "TODO"],
    ["s", "Secret", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/MinimalThemeCollection.ts
function minimalSupportedStatuses() {
  const zzz = [
    [" ", "to-do", "x", "TODO"],
    ["/", "incomplete", "x", "IN_PROGRESS"],
    ["x", "done", " ", "DONE"],
    ["-", "canceled", "x", "CANCELLED"],
    [">", "forwarded", "x", "TODO"],
    ["<", "scheduling", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["!", "important", "x", "TODO"],
    ["*", "star", "x", "TODO"],
    ['"', "quote", "x", "TODO"],
    ["l", "location", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["i", "information", "x", "TODO"],
    ["S", "savings", "x", "TODO"],
    ["I", "idea", "x", "TODO"],
    ["p", "pros", "x", "TODO"],
    ["c", "cons", "x", "TODO"],
    ["f", "fire", "x", "TODO"],
    ["k", "key", "x", "TODO"],
    ["w", "win", "x", "TODO"],
    ["u", "up", "x", "TODO"],
    ["d", "down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/SettingsTab.ts
var _SettingsTab = class extends import_obsidian10.PluginSettingTab {
  constructor({ plugin }) {
    super(plugin.app, plugin);
    this.customFunctions = {
      insertTaskCoreStatusSettings: this.insertTaskCoreStatusSettings.bind(this),
      insertCustomTaskStatusSettings: this.insertCustomTaskStatusSettings.bind(this)
    };
    this.plugin = plugin;
  }
  saveSettings(update2) {
    return __async(this, null, function* () {
      yield this.plugin.saveSettings();
      if (update2) {
        this.display();
      }
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.addClass("tasks-settings");
    containerEl.createEl("h3", { text: "Tasks Settings" });
    containerEl.createEl("p", {
      cls: "tasks-setting-important",
      text: "Changing any settings requires a restart of obsidian."
    });
    containerEl.createEl("h4", { text: "Global filter Settings" });
    new import_obsidian10.Setting(containerEl).setName("Global task filter").setDesc(
      _SettingsTab.createFragmentWithHTML(
        '<p><b>Recommended: Leave empty if you want all checklist items in your vault to be tasks managed by this plugin.</b></p><p>Use a global filter if you want Tasks to only act on a subset of your "<code>- [ ]</code>" checklist items, so that a checklist item must include the specified string in its description in order to be considered a task.<p><p>For example, if you set the global filter to <code>#task</code>, the Tasks plugin will only handle checklist items tagged with <code>#task</code>.</br>Other checklist items will remain normal checklist items and not appear in queries or get a done date set.</p><p>See the <a href="https://obsidian-tasks-group.github.io/obsidian-tasks/getting-started/global-filter/">documentation</a>.</p>'
      )
    ).addText((text2) => {
      const settings2 = getSettings();
      text2.setPlaceholder("e.g. #task or TODO").setValue(settings2.globalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ globalFilter: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Remove global filter from description").setDesc(
      "Enabling this removes the string that you set as global filter from the task description when displaying a task."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.removeGlobalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ removeGlobalFilter: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Task Statuses" });
    const { headingOpened } = getSettings();
    settingsConfiguration_default.forEach((heading) => {
      this.addOneSettingsBlock(containerEl, heading, headingOpened);
    });
    containerEl.createEl("h4", { text: "Date Settings" });
    new import_obsidian10.Setting(containerEl).setName("Set done date on every completed task").setDesc("Enabling this will add a timestamp \u2705 YYYY-MM-DD at the end when a task is toggled to done").addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setDoneDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setDoneDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Use filename as Scheduled date for undated tasks").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Save time entering Scheduled (\u23F3) dates.</br>If this option is enabled, any undated tasks will be given a default Scheduled date extracted from their file name.</br>The date in the file name must be in one of <code>YYYY-MM-DD</code> or <code>YYYYMMDD</code> formats.</br>Undated tasks have none of Due (\u{1F4C5} ), Scheduled (\u23F3) and Start (\u{1F6EB}) dates.</br><p>See the <a href="https://obsidian-tasks-group.github.io/obsidian-tasks/getting-started/use-filename-as-default-date/">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.useFilenameAsScheduledDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ useFilenameAsScheduledDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Folders with default Scheduled dates").setDesc(
      "Leave empty if you want to use default Scheduled dates everywhere, or enter a comma-separated list of folders."
    ).addText((input) => __async(this, null, function* () {
      const settings2 = getSettings();
      yield this.plugin.saveSettings();
      input.setValue(_SettingsTab.renderFolderArray(settings2.filenameAsDateFolders)).onChange((value) => __async(this, null, function* () {
        const folders = _SettingsTab.parseCommaSeparatedFolders(value);
        updateSettings({ filenameAsDateFolders: folders });
        yield this.plugin.saveSettings();
      }));
    }));
    containerEl.createEl("h4", { text: "Auto-suggest Settings" });
    new import_obsidian10.Setting(containerEl).setName("Auto-suggest task content").setDesc("Enabling this will open an intelligent suggest menu while typing inside a recognized task line.").addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.autoSuggestInEditor).onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestInEditor: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Minimum match length for auto-suggest").setDesc(
      "If higher than 0, auto-suggest will be triggered only when the beginning of any supported keywords is recognized."
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(0, 3, 1).setValue(settings2.autoSuggestMinMatch).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMinMatch: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Maximum number of auto-suggestions to show").setDesc(
      'How many suggestions should be shown when an auto-suggest menu pops up (including the "\u23CE" option).'
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(3, 12, 1).setValue(settings2.autoSuggestMaxItems).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMaxItems: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Dialog Settings" });
    new import_obsidian10.Setting(containerEl).setName("Provide access keys in dialogs").setDesc(
      "If the access keys (keyboard shortcuts) for various controls in dialog boxes conflict with system keyboard shortcuts or assistive technology functionality that is important for you, you may want to deactivate them here."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.provideAccessKeys).onChange((value) => __async(this, null, function* () {
        updateSettings({ provideAccessKeys: value });
        yield this.plugin.saveSettings();
      }));
    });
  }
  addOneSettingsBlock(containerEl, heading, headingOpened) {
    const detailsContainer = containerEl.createEl("details", {
      cls: "tasks-nested-settings",
      attr: __spreadValues({}, heading.open || headingOpened[heading.text] ? { open: true } : {})
    });
    detailsContainer.empty();
    detailsContainer.ontoggle = () => {
      headingOpened[heading.text] = detailsContainer.open;
      updateSettings({ headingOpened });
      this.plugin.saveSettings();
    };
    const summary = detailsContainer.createEl("summary");
    new import_obsidian10.Setting(summary).setHeading().setName(heading.text);
    summary.createDiv("collapser").createDiv("handle");
    if (heading.notice !== null) {
      const notice = detailsContainer.createEl("div", {
        cls: heading.notice.class,
        text: heading.notice.text
      });
      if (heading.notice.html !== null) {
        notice.insertAdjacentHTML("beforeend", heading.notice.html);
      }
    }
    heading.settings.forEach((setting) => {
      if (setting.featureFlag !== "" && !isFeatureEnabled(setting.featureFlag)) {
        return;
      }
      if (setting.type === "checkbox") {
        new import_obsidian10.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addToggle((toggle) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          toggle.setValue(settings2.generalSettings[setting.settingName]).onChange((value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          }));
        });
      } else if (setting.type === "text") {
        new import_obsidian10.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addText((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian10.debounce)(onChange, 500, true));
        });
      } else if (setting.type === "textarea") {
        new import_obsidian10.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addTextArea((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian10.debounce)(onChange, 500, true));
          text2.inputEl.rows = 8;
          text2.inputEl.cols = 40;
        });
      } else if (setting.type === "function") {
        this.customFunctions[setting.settingName](detailsContainer, this);
      }
      if (setting.notice !== null) {
        const notice = detailsContainer.createEl("p", {
          cls: setting.notice.class,
          text: setting.notice.text
        });
        if (setting.notice.html !== null) {
          notice.insertAdjacentHTML("beforeend", setting.notice.html);
        }
      }
    });
  }
  static parseCommaSeparatedFolders(input) {
    return input.split(",").map((folder) => folder.trim()).map((folder) => folder.replace(/^\/|\/$/g, "")).filter((folder) => folder !== "");
  }
  static renderFolderArray(folders) {
    return folders.join(",");
  }
  insertTaskCoreStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.coreStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.coreStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        true
      );
    });
  }
  insertCustomTaskStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.customStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.customStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        false
      );
    });
    containerEl.createEl("div");
    const setting = new import_obsidian10.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add New Task Status").setCta().onClick(() => __async(this, null, function* () {
        StatusSettings.addStatus(
          statusSettings.customStatuses,
          new StatusConfiguration("", "", "", false, "TODO" /* TODO */)
        );
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    setting.infoEl.remove();
    const addStatusesSupportedByMinimalTheme = new import_obsidian10.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add all Status types supported by Minimal Theme").setCta().onClick(() => __async(this, null, function* () {
        yield addCustomStatesToSettings(minimalSupportedStatuses(), statusSettings, settings2);
      }));
    });
    addStatusesSupportedByMinimalTheme.infoEl.remove();
    const addStatusesSupportedByITSTheme = new import_obsidian10.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add all Status types supported by ITS Theme").setCta().onClick(() => __async(this, null, function* () {
        yield addCustomStatesToSettings(itsSupportedStatuses(), statusSettings, settings2);
      }));
    });
    addStatusesSupportedByITSTheme.infoEl.remove();
    const addAllUnknownStatuses = new import_obsidian10.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add All Unknown Status Types").setCta().onClick(() => __async(this, null, function* () {
        const tasks = this.plugin.getTasks();
        const unknownStatuses = StatusRegistry.getInstance().findUnknownStatuses(tasks);
        if (unknownStatuses.length === 0) {
          return;
        }
        unknownStatuses.forEach((s) => {
          StatusSettings.addStatus(statusSettings.customStatuses, s);
        });
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    addAllUnknownStatuses.infoEl.remove();
    const clearCustomStatuses = new import_obsidian10.Setting(containerEl).addButton((button) => {
      button.setButtonText("Reset Custom Status Types to Defaults").setWarning().onClick(() => __async(this, null, function* () {
        StatusSettings.resetAllCustomStatuses(statusSettings);
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    clearCustomStatuses.infoEl.remove();
  }
};
var SettingsTab = _SettingsTab;
SettingsTab.createFragmentWithHTML = (html) => createFragment((documentFragment) => documentFragment.createDiv().innerHTML = html);
function createRowForTaskStatus(containerEl, statusType, statuses, statusSettings, settings2, plugin, isCoreStatus) {
  const taskStatusPreview = containerEl.createEl("pre");
  taskStatusPreview.addClass("row-for-status");
  taskStatusPreview.textContent = new Status(statusType).previewText();
  const setting = new import_obsidian10.Setting(containerEl);
  setting.infoEl.replaceWith(taskStatusPreview);
  if (!isCoreStatus) {
    setting.addExtraButton((extra) => {
      extra.setIcon("cross").setTooltip("Delete").onClick(() => __async(this, null, function* () {
        if (StatusSettings.deleteStatus(statuses, statusType)) {
          yield updateAndSaveStatusSettings(statusSettings, settings2);
        }
      }));
    });
  }
  setting.addExtraButton((extra) => {
    extra.setIcon("pencil").setTooltip("Edit").onClick(() => __async(this, null, function* () {
      const modal = new CustomStatusModal(plugin, statusType, isCoreStatus);
      modal.onClose = () => __async(this, null, function* () {
        if (modal.saved) {
          if (StatusSettings.replaceStatus(statuses, statusType, modal.statusConfiguration())) {
            yield updateAndSaveStatusSettings(statusSettings, settings2);
          }
        }
      });
      modal.open();
    }));
  });
  setting.infoEl.remove();
}
function addCustomStatesToSettings(supportedStatuses, statusSettings, settings2) {
  return __async(this, null, function* () {
    const notices = StatusSettings.bulkAddStatusCollection(statusSettings, supportedStatuses);
    notices.forEach((notice) => {
      new import_obsidian10.Notice(notice);
    });
    yield updateAndSaveStatusSettings(statusSettings, settings2);
  });
}
function updateAndSaveStatusSettings(statusTypes, settings2) {
  return __async(this, null, function* () {
    updateSettings({
      statusSettings: statusTypes
    });
    StatusSettings.applyToStatusRegistry(statusTypes, StatusRegistry.getInstance());
    yield settings2.saveSettings(true);
  });
}

// src/Suggestor/EditorSuggestorPopup.ts
var import_obsidian11 = require("obsidian");

// src/Suggestor/Suggestor.ts
var datePrefixCharacters = `${startDateSymbol}${scheduledDateSymbol}${dueDateSymbol}`;
function buildSuggestions(line, cursorPos, settings2) {
  let suggestions = [];
  suggestions = suggestions.concat(addDatesSuggestions(line, cursorPos, settings2));
  suggestions = suggestions.concat(addRecurrenceSuggestions(line, cursorPos, settings2));
  const morePossibleSuggestions = getPossibleComponentSuggestions(line, settings2);
  const wordMatch = matchByPosition(line, /([a-zA-Z'_-]*)/g, cursorPos);
  let addedSuggestions = false;
  if (wordMatch && wordMatch.length > 0) {
    const wordUnderCursor = wordMatch[0];
    if (wordUnderCursor.length >= Math.max(1, settings2.autoSuggestMinMatch)) {
      const filteredSuggestions = morePossibleSuggestions.filter(
        (suggestInfo) => suggestInfo.displayText.toLowerCase().includes(wordUnderCursor.toLowerCase())
      );
      for (const filtered of filteredSuggestions) {
        suggestions.push({
          suggestionType: "match",
          displayText: filtered.displayText,
          appendText: filtered.appendText,
          insertAt: wordMatch.index,
          insertSkip: wordUnderCursor.length
        });
        addedSuggestions = true;
      }
    }
  }
  if (!addedSuggestions && settings2.autoSuggestMinMatch === 0)
    suggestions = suggestions.concat(morePossibleSuggestions);
  if (suggestions.length > 0 && !suggestions.some((value) => value.suggestionType === "match")) {
    suggestions.unshift({
      suggestionType: "empty",
      displayText: "\u23CE",
      appendText: "\n"
    });
  }
  suggestions = suggestions.slice(0, settings2.autoSuggestMaxItems);
  return suggestions;
}
function hasPriority(line) {
  if (Object.values(prioritySymbols).some((value) => value.length > 0 && line.includes(value)))
    return true;
}
function getPossibleComponentSuggestions(line, _settings) {
  const suggestions = [];
  if (!line.includes(dueDateSymbol))
    suggestions.push({
      displayText: `${dueDateSymbol} due date`,
      appendText: `${dueDateSymbol} `
    });
  if (!line.includes(startDateSymbol))
    suggestions.push({
      displayText: `${startDateSymbol} start date`,
      appendText: `${startDateSymbol} `
    });
  if (!line.includes(scheduledDateSymbol))
    suggestions.push({
      displayText: `${scheduledDateSymbol} scheduled date`,
      appendText: `${scheduledDateSymbol} `
    });
  if (!hasPriority(line)) {
    suggestions.push({
      displayText: `${prioritySymbols.High} high priority`,
      appendText: `${prioritySymbols.High} `
    });
    suggestions.push({
      displayText: `${prioritySymbols.Medium} medium priority`,
      appendText: `${prioritySymbols.Medium} `
    });
    suggestions.push({
      displayText: `${prioritySymbols.Low} low priority`,
      appendText: `${prioritySymbols.Low} `
    });
  }
  if (!line.includes(recurrenceSymbol))
    suggestions.push({
      displayText: `${recurrenceSymbol} recurring (repeat)`,
      appendText: `${recurrenceSymbol} `
    });
  return suggestions;
}
function addDatesSuggestions(line, cursorPos, settings2) {
  const genericSuggestions = [
    "today",
    "tomorrow",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "next week",
    "next month",
    "next year"
  ];
  const results = [];
  const dateRegex = new RegExp(`([${datePrefixCharacters}])\\s*([0-9a-zA-Z ]*)`, "ug");
  const dateMatch = matchByPosition(line, dateRegex, cursorPos);
  if (dateMatch && dateMatch.length >= 2) {
    const datePrefix = dateMatch[1];
    const dateString = dateMatch[2];
    if (dateString.length < settings2.autoSuggestMinMatch) {
      return [];
    }
    const possibleDate = dateString && dateString.length > 1 ? DateParser.parseDate(doAutocomplete(dateString), true) : null;
    if (possibleDate && possibleDate.isValid()) {
      results.push({
        displayText: `${possibleDate.format(TaskRegularExpressions.dateFormat)}`,
        appendText: `${datePrefix} ${possibleDate.format(TaskRegularExpressions.dateFormat)} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
    const minMatch = 1;
    const maxGenericSuggestions = 5;
    let genericMatches = genericSuggestions.filter(
      (value) => dateString && dateString.length >= minMatch && value.toLowerCase().includes(dateString.toLowerCase())
    ).slice(0, maxGenericSuggestions);
    if (genericMatches.length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericSuggestions);
    }
    for (const match of genericMatches) {
      const parsedDate = DateParser.parseDate(match, true);
      const formattedDate = `${parsedDate.format(TaskRegularExpressions.dateFormat)}`;
      results.push({
        suggestionType: "match",
        displayText: `${match} (${formattedDate})`,
        appendText: `${datePrefix} ${formattedDate} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
  }
  return results;
}
function addRecurrenceSuggestions(line, cursorPos, settings2) {
  var _a;
  const genericSuggestions = [
    "every",
    "every day",
    "every week",
    "every month",
    "every month on the",
    "every year",
    "every week on Sunday",
    "every week on Monday",
    "every week on Tuesday",
    "every week on Wednesday",
    "every week on Thursday",
    "every week on Friday",
    "every week on Saturday"
  ];
  const results = [];
  const recurrenceRegex = new RegExp(`(${recurrenceSymbol})\\s*([0-9a-zA-Z ]*)`, "ug");
  const recurrenceMatch = matchByPosition(line, recurrenceRegex, cursorPos);
  if (recurrenceMatch && recurrenceMatch.length >= 2) {
    const recurrencePrefix = recurrenceMatch[1];
    const recurrenceString = recurrenceMatch[2];
    if (recurrenceString.length < settings2.autoSuggestMinMatch)
      return [];
    if (recurrenceString.length > 0) {
      const parsedRecurrence = (_a = Recurrence.fromText({
        recurrenceRuleText: recurrenceString,
        startDate: null,
        scheduledDate: null,
        dueDate: null
      })) == null ? void 0 : _a.toText();
      if (parsedRecurrence) {
        const appendedText = `${recurrencePrefix} ${parsedRecurrence} `;
        results.push({
          suggestionType: "match",
          displayText: `\u2705 ${parsedRecurrence}`,
          appendText: appendedText,
          insertAt: recurrenceMatch.index,
          insertSkip: recurrenceMatch[0].length
        });
        if (recurrenceMatch[0] == appendedText)
          return [];
      }
    }
    const minMatch = 1;
    const maxGenericDateSuggestions = settings2.autoSuggestMaxItems / 2;
    let genericMatches = genericSuggestions.filter(
      (value) => recurrenceString && recurrenceString.length >= minMatch && value.toLowerCase().includes(recurrenceString.toLowerCase())
    ).slice(0, maxGenericDateSuggestions);
    if (genericMatches.length === 0 && recurrenceString.trim().length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericDateSuggestions);
    }
    for (const match of genericMatches) {
      results.push({
        suggestionType: "match",
        displayText: `${match}`,
        appendText: `${recurrencePrefix} ${match} `,
        insertAt: recurrenceMatch.index,
        insertSkip: recurrenceMatch[0].length
      });
    }
  }
  return results;
}
function matchByPosition(s, r, position) {
  const matches = s.matchAll(r);
  for (const match of matches) {
    if ((match == null ? void 0 : match.index) && match.index <= position && position <= match.index + match[0].length)
      return match;
  }
  return [];
}

// src/Suggestor/EditorSuggestorPopup.ts
var EditorSuggestor = class extends import_obsidian11.EditorSuggest {
  constructor(app, settings2) {
    super(app);
    this.settings = settings2;
  }
  onTrigger(cursor, editor, _file) {
    if (!this.settings.autoSuggestInEditor)
      return null;
    const line = editor.getLine(cursor.line);
    if (line.contains(this.settings.globalFilter) && line.match(TaskRegularExpressions.taskRegex)) {
      return {
        start: { line: cursor.line, ch: 0 },
        end: {
          line: cursor.line,
          ch: line.length
        },
        query: line
      };
    }
    return null;
  }
  getSuggestions(context) {
    const line = context.query;
    const currentCursor = context.editor.getCursor();
    const suggestions = buildSuggestions(line, currentCursor.ch, this.settings);
    const suggestionsWithContext = [];
    for (const suggestion of suggestions)
      suggestionsWithContext.push(__spreadProps(__spreadValues({}, suggestion), { context }));
    return suggestionsWithContext;
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    var _a, _b, _c;
    const editor = value.context.editor;
    if (value.suggestionType === "empty") {
      this.close();
      const eventClone = new KeyboardEvent("keydown", {
        code: "Enter",
        key: "Enter"
      });
      (_b = (_a = editor == null ? void 0 : editor.cm) == null ? void 0 : _a.contentDOM) == null ? void 0 : _b.dispatchEvent(eventClone);
      return;
    }
    const currentCursor = value.context.editor.getCursor();
    const replaceFrom = {
      line: currentCursor.line,
      ch: (_c = value.insertAt) != null ? _c : currentCursor.ch
    };
    const replaceTo = value.insertSkip ? {
      line: currentCursor.line,
      ch: replaceFrom.ch + value.insertSkip
    } : void 0;
    value.context.editor.replaceRange(value.appendText, replaceFrom, replaceTo);
    value.context.editor.setCursor({
      line: currentCursor.line,
      ch: replaceFrom.ch + value.appendText.length
    });
  }
};

// src/main.ts
var TasksPlugin = class extends import_obsidian12.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log('loading plugin "tasks"');
      yield this.loadSettings();
      this.addSettingTab(new SettingsTab({ plugin: this }));
      initializeFile({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault
      });
      yield this.loadTaskStatuses();
      const events = new TasksEvents({ obsidianEvents: this.app.workspace });
      this.cache = new Cache2({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        events
      });
      this.inlineRenderer = new InlineRenderer({ plugin: this });
      this.queryRenderer = new QueryRenderer({ plugin: this, events });
      this.registerEditorExtension(newLivePreviewExtension());
      this.registerEditorSuggest(new EditorSuggestor(this.app, getSettings()));
      new Commands({ plugin: this });
    });
  }
  loadTaskStatuses() {
    return __async(this, null, function* () {
      const { statusSettings } = getSettings();
      StatusSettings.applyToStatusRegistry(statusSettings, StatusRegistry.getInstance());
    });
  }
  onunload() {
    var _a;
    console.log('unloading plugin "tasks"');
    (_a = this.cache) == null ? void 0 : _a.unload();
  }
  loadSettings() {
    return __async(this, null, function* () {
      const newSettings = yield this.loadData();
      updateSettings(newSettings);
      yield this.loadTaskStatuses();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(getSettings());
    });
  }
  getTasks() {
    var _a;
    return (_a = this.cache) == null ? void 0 : _a.getTasks();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdXRpbHMvcGF0dGVybi50cyIsICJub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24veWVhcnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3F1YXJ0ZXJPZlllYXIuanMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy91dGlscy9kYXlqcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3RpbWV6b25lLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvcmVzdWx0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0UGFyc2VyV2l0aFdvcmRCb3VuZGFyeS50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTWlkZGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOQ2FzdWFsWWVhck1vbnRoRGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOU2xhc2hNb250aEZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0VGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3V0aWxzL3RpbWV1bml0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRMYXRlckZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9hYnN0cmFjdFJlZmluZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0Fic3RyYWN0TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NhbGN1bGF0aW9uL21lcmdpbmdDYWxjdWxhdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9BYnN0cmFjdE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZUFiYnJSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvT3ZlcmxhcFJlbW92YWxSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0ZvcndhcmREYXRlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9Vbmxpa2VseUZvcm1hdEZpbHRlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0lTT0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9NZXJnZVdlZWtkYXlDb21wb25lbnRSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29uZmlndXJhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vY2FzdWFsUmVmZXJlbmNlcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTkNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5DYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24vd2Vla3MudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5XZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2hyb25vLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvU2xhc2hEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcmVmaW5lcnMvRU5NZXJnZVJlbGF0aXZlRGF0ZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVTcGVjaWZpY1RpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9yZWZpbmVycy9ERU1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcmVmaW5lcnMvREVNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERUNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFVGltZVVuaXRSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9yZWZpbmVycy9GUk1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9yZWZpbmVycy9GUk1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlNwZWNpZmljVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lVW5pdEFnb0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZVVuaXRSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvcGFyc2Vycy9KUFN0YW5kYXJkUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9yZWZpbmVycy9KUE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvcGFyc2Vycy9KUENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3JlZmluZXJzL1BUTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3JlZmluZXJzL1BUTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVENhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9yZWZpbmVycy9OTE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcmVmaW5lcnMvTkxNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdFdpdGhpbkZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxNb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxNb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxTbGFzaE1vbnRoRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxZZWFyTW9udGhEYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxEYXRlVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0Q2FzdWFsUmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxSZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdEFnb0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0TGF0ZXJGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50Q2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnREYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50RGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRSZWxhdGlvbldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcmVmaW5lcnMvWkhIYW50TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3JlZmluZXJzL1pISGFudE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zRGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNSZWxhdGlvbldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1dlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcmVmaW5lcnMvWkhIYW5zTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3JlZmluZXJzL1pISGFuc01lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVNb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9yZWZpbmVycy9SVU1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcmVmaW5lcnMvUlVNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVUNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVVbml0Q2FzdWFsUmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9jb25zdC5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvbGV4L2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9sZXgvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2xleC9sZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3BhcnNlL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvZXZhbHVhdGUvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2V2YWx1YXRlL2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9ldmFsdWF0ZS9ldmFsdWF0ZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvaW5kZXguanMiLCAic3JjL21haW4udHMiLCAic3JjL0NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy1tdXRleC9pbmRleC5tanMiLCAic3JjL1Rhc2tMYXlvdXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy93ZWVrZGF5LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV1dGlsLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhbGxiYWNraXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pMThuLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3RvdGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9wYXJzZXRleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy90eXBlcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV0aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VvcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VzdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRld2l0aHpvbmUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9vcHRpb25zdG9zdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWNoZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL21hc2tzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8veWVhcmluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9tb250aGluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9lYXN0ZXIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvcG9zbGlzdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJzZXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXN0ci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc2V0LnRzIiwgInNyYy9RdWVyeS9EYXRlUGFyc2VyLnRzIiwgInNyYy9RdWVyeS9FeHBsYWluL0V4cGxhbmF0aW9uLnRzIiwgInNyYy9RdWVyeS9Tb3J0ZXIudHMiLCAic3JjL2xpYi9SZWdFeHBUb29scy50cyIsICJzcmMvUXVlcnkvR3JvdXBlci50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVyLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVySW5zdHJ1Y3Rpb24udHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJJbnN0cnVjdGlvbnMudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9EYXRlRmllbGQudHMiLCAic3JjL1JlY3VycmVuY2UudHMiLCAic3JjL1N0YXR1c0NvbmZpZ3VyYXRpb24udHMiLCAic3JjL1N0YXR1cy50cyIsICJzcmMvQ29uZmlnL1N0YXR1c1NldHRpbmdzLnRzIiwgInNyYy9Db25maWcvRmVhdHVyZS50cyIsICJzcmMvQ29uZmlnL1NldHRpbmdzLnRzIiwgInNyYy9TdGF0dXNSZWdpc3RyeS50cyIsICJzcmMvVXJnZW5jeS50cyIsICJzcmMvVGFza0xpbmVSZW5kZXJlci50cyIsICJzcmMvRmlsZS50cyIsICJzcmMvRGF0ZUZhbGxiYWNrLnRzIiwgInNyYy9UYXNrLnRzIiwgInNyYy9saWIvTGF6eS50cyIsICJzcmMvQ29tbWFuZHMvQ3JlYXRlT3JFZGl0LnRzIiwgInNyYy9UYXNrTW9kYWwudHMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanMiLCAic3JjL3VpL0VkaXRUYXNrLnN2ZWx0ZSIsICJzcmMvRGF0ZUFiYnJldmlhdGlvbnMudHMiLCAic3JjL0NvbW1hbmRzL0NyZWF0ZU9yRWRpdFRhc2tQYXJzZXIudHMiLCAic3JjL0NvbW1hbmRzL1RvZ2dsZURvbmUudHMiLCAic3JjL0NvbW1hbmRzL2luZGV4LnRzIiwgInNyYy9UYXNrc0V2ZW50cy50cyIsICJzcmMvSW5saW5lUmVuZGVyZXIudHMiLCAic3JjL0xpdmVQcmV2aWV3RXh0ZW5zaW9uLnRzIiwgInNyYy9RdWVyeVJlbmRlcmVyLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRHVlRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvUHJpb3JpdHlGaWVsZC50cyIsICJzcmMvUXVlcnkvTWF0Y2hlcnMvSVN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1N1YnN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1JlZ2V4TWF0Y2hlci50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1RleHRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1BhdGhGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1VyZ2VuY3lGaWVsZC50cyIsICJzcmMvUXVlcnkvU29ydC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0Rlc2NyaXB0aW9uRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Eb25lRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRXhjbHVkZVN1Ykl0ZW1zRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9IZWFkaW5nRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TY2hlZHVsZWREYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TdGFydERhdGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0hhcHBlbnNEYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9SZWN1cnJpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL011bHRpVGV4dEZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvVGFnc0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQm9vbGVhbkZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsZW5hbWVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c05hbWVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c1R5cGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1JlY3VycmVuY2VGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyUGFyc2VyLnRzIiwgInNyYy9RdWVyeS9Hcm91cEhlYWRpbmcudHMiLCAic3JjL1F1ZXJ5L0dyb3VwSGVhZGluZ3MudHMiLCAic3JjL1F1ZXJ5L0dyb3VwaW5nVHJlZU5vZGUudHMiLCAic3JjL1F1ZXJ5L0ludGVybWVkaWF0ZVRhc2tHcm91cHMudHMiLCAic3JjL1F1ZXJ5L1Rhc2tHcm91cC50cyIsICJzcmMvUXVlcnkvVGFza0dyb3Vwcy50cyIsICJzcmMvUXVlcnkvR3JvdXAudHMiLCAic3JjL1F1ZXJ5L1F1ZXJ5LnRzIiwgInNyYy9Db25maWcvU2V0dGluZ3NUYWIudHMiLCAic3JjL0NvbmZpZy9DdXN0b21TdGF0dXNNb2RhbC50cyIsICJzcmMvU3RhdHVzVmFsaWRhdG9yLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL0lUU1RoZW1lQ29sbGVjdGlvbi50cyIsICJzcmMvQ29uZmlnL1RoZW1lcy9NaW5pbWFsVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9TdWdnZXN0b3IvRWRpdG9yU3VnZ2VzdG9yUG9wdXAudHMiLCAic3JjL1N1Z2dlc3Rvci9TdWdnZXN0b3IudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwgbnVsbCwgIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuZGF5anM9ZSgpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PTFlMyxlPTZlNCxuPTM2ZTUscj1cIm1pbGxpc2Vjb25kXCIsaT1cInNlY29uZFwiLHM9XCJtaW51dGVcIix1PVwiaG91clwiLGE9XCJkYXlcIixvPVwid2Vla1wiLGY9XCJtb250aFwiLGg9XCJxdWFydGVyXCIsYz1cInllYXJcIixkPVwiZGF0ZVwiLCQ9XCJJbnZhbGlkIERhdGVcIixsPS9eKFxcZHs0fSlbLS9dPyhcXGR7MSwyfSk/Wy0vXT8oXFxkezAsMn0pW1R0XFxzXSooXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Wy46XT8oXFxkKyk/JC8seT0vXFxbKFteXFxdXSspXXxZezEsNH18TXsxLDR9fER7MSwyfXxkezEsNH18SHsxLDJ9fGh7MSwyfXxhfEF8bXsxLDJ9fHN7MSwyfXxaezEsMn18U1NTL2csTT17bmFtZTpcImVuXCIsd2Vla2RheXM6XCJTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheVwiLnNwbGl0KFwiX1wiKSxtb250aHM6XCJKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyXCIuc3BsaXQoXCJfXCIpfSxtPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1TdHJpbmcodCk7cmV0dXJuIXJ8fHIubGVuZ3RoPj1lP3Q6XCJcIitBcnJheShlKzEtci5sZW5ndGgpLmpvaW4obikrdH0sZz17czptLHo6ZnVuY3Rpb24odCl7dmFyIGU9LXQudXRjT2Zmc2V0KCksbj1NYXRoLmFicyhlKSxyPU1hdGguZmxvb3Iobi82MCksaT1uJTYwO3JldHVybihlPD0wP1wiK1wiOlwiLVwiKSttKHIsMixcIjBcIikrXCI6XCIrbShpLDIsXCIwXCIpfSxtOmZ1bmN0aW9uIHQoZSxuKXtpZihlLmRhdGUoKTxuLmRhdGUoKSlyZXR1cm4tdChuLGUpO3ZhciByPTEyKihuLnllYXIoKS1lLnllYXIoKSkrKG4ubW9udGgoKS1lLm1vbnRoKCkpLGk9ZS5jbG9uZSgpLmFkZChyLGYpLHM9bi1pPDAsdT1lLmNsb25lKCkuYWRkKHIrKHM/LTE6MSksZik7cmV0dXJuKygtKHIrKG4taSkvKHM/aS11OnUtaSkpfHwwKX0sYTpmdW5jdGlvbih0KXtyZXR1cm4gdDwwP01hdGguY2VpbCh0KXx8MDpNYXRoLmZsb29yKHQpfSxwOmZ1bmN0aW9uKHQpe3JldHVybntNOmYseTpjLHc6byxkOmEsRDpkLGg6dSxtOnMsczppLG1zOnIsUTpofVt0XXx8U3RyaW5nKHR8fFwiXCIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvcyQvLFwiXCIpfSx1OmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fX0sRD1cImVuXCIsdj17fTt2W0RdPU07dmFyIHA9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBffSxTPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcjtpZighdClyZXR1cm4gRDtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl2W3RdJiYocj10KSxlJiYodlt0XT1lLHI9dCk7ZWxzZXt2YXIgaT10Lm5hbWU7dltpXT10LHI9aX1yZXR1cm4hbiYmciYmKEQ9cikscnx8IW4mJkR9LHc9ZnVuY3Rpb24odCxlKXtpZihwKHQpKXJldHVybiB0LmNsb25lKCk7dmFyIG49XCJvYmplY3RcIj09dHlwZW9mIGU/ZTp7fTtyZXR1cm4gbi5kYXRlPXQsbi5hcmdzPWFyZ3VtZW50cyxuZXcgXyhuKX0sTz1nO08ubD1TLE8uaT1wLE8udz1mdW5jdGlvbih0LGUpe3JldHVybiB3KHQse2xvY2FsZTplLiRMLHV0YzplLiR1LHg6ZS4keCwkb2Zmc2V0OmUuJG9mZnNldH0pfTt2YXIgXz1mdW5jdGlvbigpe2Z1bmN0aW9uIE0odCl7dGhpcy4kTD1TKHQubG9jYWxlLG51bGwsITApLHRoaXMucGFyc2UodCl9dmFyIG09TS5wcm90b3R5cGU7cmV0dXJuIG0ucGFyc2U9ZnVuY3Rpb24odCl7dGhpcy4kZD1mdW5jdGlvbih0KXt2YXIgZT10LmRhdGUsbj10LnV0YztpZihudWxsPT09ZSlyZXR1cm4gbmV3IERhdGUoTmFOKTtpZihPLnUoZSkpcmV0dXJuIG5ldyBEYXRlO2lmKGUgaW5zdGFuY2VvZiBEYXRlKXJldHVybiBuZXcgRGF0ZShlKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIS9aJC9pLnRlc3QoZSkpe3ZhciByPWUubWF0Y2gobCk7aWYocil7dmFyIGk9clsyXS0xfHwwLHM9KHJbN118fFwiMFwiKS5zdWJzdHJpbmcoMCwzKTtyZXR1cm4gbj9uZXcgRGF0ZShEYXRlLlVUQyhyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKSk6bmV3IERhdGUoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscyl9fXJldHVybiBuZXcgRGF0ZShlKX0odCksdGhpcy4keD10Lnh8fHt9LHRoaXMuaW5pdCgpfSxtLmluaXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRkO3RoaXMuJHk9dC5nZXRGdWxsWWVhcigpLHRoaXMuJE09dC5nZXRNb250aCgpLHRoaXMuJEQ9dC5nZXREYXRlKCksdGhpcy4kVz10LmdldERheSgpLHRoaXMuJEg9dC5nZXRIb3VycygpLHRoaXMuJG09dC5nZXRNaW51dGVzKCksdGhpcy4kcz10LmdldFNlY29uZHMoKSx0aGlzLiRtcz10LmdldE1pbGxpc2Vjb25kcygpfSxtLiR1dGlscz1mdW5jdGlvbigpe3JldHVybiBPfSxtLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuJGQudG9TdHJpbmcoKT09PSQpfSxtLmlzU2FtZT1mdW5jdGlvbih0LGUpe3ZhciBuPXcodCk7cmV0dXJuIHRoaXMuc3RhcnRPZihlKTw9biYmbjw9dGhpcy5lbmRPZihlKX0sbS5pc0FmdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCk8dGhpcy5zdGFydE9mKGUpfSxtLmlzQmVmb3JlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5kT2YoZSk8dyh0KX0sbS4kZz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE8udSh0KT90aGlzW2VdOnRoaXMuc2V0KG4sdCl9LG0udW5peD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpLzFlMyl9LG0udmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLmdldFRpbWUoKX0sbS5zdGFydE9mPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPSEhTy51KGUpfHxlLGg9Ty5wKHQpLCQ9ZnVuY3Rpb24odCxlKXt2YXIgaT1PLncobi4kdT9EYXRlLlVUQyhuLiR5LGUsdCk6bmV3IERhdGUobi4keSxlLHQpLG4pO3JldHVybiByP2k6aS5lbmRPZihhKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBPLncobi50b0RhdGUoKVt0XS5hcHBseShuLnRvRGF0ZShcInNcIiksKHI/WzAsMCwwLDBdOlsyMyw1OSw1OSw5OTldKS5zbGljZShlKSksbil9LHk9dGhpcy4kVyxNPXRoaXMuJE0sbT10aGlzLiRELGc9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpO3N3aXRjaChoKXtjYXNlIGM6cmV0dXJuIHI/JCgxLDApOiQoMzEsMTEpO2Nhc2UgZjpyZXR1cm4gcj8kKDEsTSk6JCgwLE0rMSk7Y2FzZSBvOnZhciBEPXRoaXMuJGxvY2FsZSgpLndlZWtTdGFydHx8MCx2PSh5PEQ/eSs3OnkpLUQ7cmV0dXJuICQocj9tLXY6bSsoNi12KSxNKTtjYXNlIGE6Y2FzZSBkOnJldHVybiBsKGcrXCJIb3Vyc1wiLDApO2Nhc2UgdTpyZXR1cm4gbChnK1wiTWludXRlc1wiLDEpO2Nhc2UgczpyZXR1cm4gbChnK1wiU2Vjb25kc1wiLDIpO2Nhc2UgaTpyZXR1cm4gbChnK1wiTWlsbGlzZWNvbmRzXCIsMyk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5jbG9uZSgpfX0sbS5lbmRPZj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydE9mKHQsITEpfSxtLiRzZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbixvPU8ucCh0KSxoPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKSwkPShuPXt9LG5bYV09aCtcIkRhdGVcIixuW2RdPWgrXCJEYXRlXCIsbltmXT1oK1wiTW9udGhcIixuW2NdPWgrXCJGdWxsWWVhclwiLG5bdV09aCtcIkhvdXJzXCIsbltzXT1oK1wiTWludXRlc1wiLG5baV09aCtcIlNlY29uZHNcIixuW3JdPWgrXCJNaWxsaXNlY29uZHNcIixuKVtvXSxsPW89PT1hP3RoaXMuJEQrKGUtdGhpcy4kVyk6ZTtpZihvPT09Znx8bz09PWMpe3ZhciB5PXRoaXMuY2xvbmUoKS5zZXQoZCwxKTt5LiRkWyRdKGwpLHkuaW5pdCgpLHRoaXMuJGQ9eS5zZXQoZCxNYXRoLm1pbih0aGlzLiRELHkuZGF5c0luTW9udGgoKSkpLiRkfWVsc2UgJCYmdGhpcy4kZFskXShsKTtyZXR1cm4gdGhpcy5pbml0KCksdGhpc30sbS5zZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLiRzZXQodCxlKX0sbS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbTy5wKHQpXSgpfSxtLmFkZD1mdW5jdGlvbihyLGgpe3ZhciBkLCQ9dGhpcztyPU51bWJlcihyKTt2YXIgbD1PLnAoaCkseT1mdW5jdGlvbih0KXt2YXIgZT13KCQpO3JldHVybiBPLncoZS5kYXRlKGUuZGF0ZSgpK01hdGgucm91bmQodCpyKSksJCl9O2lmKGw9PT1mKXJldHVybiB0aGlzLnNldChmLHRoaXMuJE0rcik7aWYobD09PWMpcmV0dXJuIHRoaXMuc2V0KGMsdGhpcy4keStyKTtpZihsPT09YSlyZXR1cm4geSgxKTtpZihsPT09bylyZXR1cm4geSg3KTt2YXIgTT0oZD17fSxkW3NdPWUsZFt1XT1uLGRbaV09dCxkKVtsXXx8MSxtPXRoaXMuJGQuZ2V0VGltZSgpK3IqTTtyZXR1cm4gTy53KG0sdGhpcyl9LG0uc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hZGQoLTEqdCxlKX0sbS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMuJGxvY2FsZSgpO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm4gbi5pbnZhbGlkRGF0ZXx8JDt2YXIgcj10fHxcIllZWVktTU0tRERUSEg6bW06c3NaXCIsaT1PLnoodGhpcykscz10aGlzLiRILHU9dGhpcy4kbSxhPXRoaXMuJE0sbz1uLndlZWtkYXlzLGY9bi5tb250aHMsaD1mdW5jdGlvbih0LG4saSxzKXtyZXR1cm4gdCYmKHRbbl18fHQoZSxyKSl8fGlbbl0uc3Vic3RyKDAscyl9LGM9ZnVuY3Rpb24odCl7cmV0dXJuIE8ucyhzJTEyfHwxMix0LFwiMFwiKX0sZD1uLm1lcmlkaWVtfHxmdW5jdGlvbih0LGUsbil7dmFyIHI9dDwxMj9cIkFNXCI6XCJQTVwiO3JldHVybiBuP3IudG9Mb3dlckNhc2UoKTpyfSxsPXtZWTpTdHJpbmcodGhpcy4keSkuc2xpY2UoLTIpLFlZWVk6dGhpcy4keSxNOmErMSxNTTpPLnMoYSsxLDIsXCIwXCIpLE1NTTpoKG4ubW9udGhzU2hvcnQsYSxmLDMpLE1NTU06aChmLGEpLEQ6dGhpcy4kRCxERDpPLnModGhpcy4kRCwyLFwiMFwiKSxkOlN0cmluZyh0aGlzLiRXKSxkZDpoKG4ud2Vla2RheXNNaW4sdGhpcy4kVyxvLDIpLGRkZDpoKG4ud2Vla2RheXNTaG9ydCx0aGlzLiRXLG8sMyksZGRkZDpvW3RoaXMuJFddLEg6U3RyaW5nKHMpLEhIOk8ucyhzLDIsXCIwXCIpLGg6YygxKSxoaDpjKDIpLGE6ZChzLHUsITApLEE6ZChzLHUsITEpLG06U3RyaW5nKHUpLG1tOk8ucyh1LDIsXCIwXCIpLHM6U3RyaW5nKHRoaXMuJHMpLHNzOk8ucyh0aGlzLiRzLDIsXCIwXCIpLFNTUzpPLnModGhpcy4kbXMsMyxcIjBcIiksWjppfTtyZXR1cm4gci5yZXBsYWNlKHksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fGxbdF18fGkucmVwbGFjZShcIjpcIixcIlwiKX0pKX0sbS51dGNPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMTUqLU1hdGgucm91bmQodGhpcy4kZC5nZXRUaW1lem9uZU9mZnNldCgpLzE1KX0sbS5kaWZmPWZ1bmN0aW9uKHIsZCwkKXt2YXIgbCx5PU8ucChkKSxNPXcociksbT0oTS51dGNPZmZzZXQoKS10aGlzLnV0Y09mZnNldCgpKSplLGc9dGhpcy1NLEQ9Ty5tKHRoaXMsTSk7cmV0dXJuIEQ9KGw9e30sbFtjXT1ELzEyLGxbZl09RCxsW2hdPUQvMyxsW29dPShnLW0pLzYwNDhlNSxsW2FdPShnLW0pLzg2NGU1LGxbdV09Zy9uLGxbc109Zy9lLGxbaV09Zy90LGwpW3ldfHxnLCQ/RDpPLmEoRCl9LG0uZGF5c0luTW9udGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRPZihmKS4kRH0sbS4kbG9jYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHZbdGhpcy4kTF19LG0ubG9jYWxlPWZ1bmN0aW9uKHQsZSl7aWYoIXQpcmV0dXJuIHRoaXMuJEw7dmFyIG49dGhpcy5jbG9uZSgpLHI9Uyh0LGUsITApO3JldHVybiByJiYobi4kTD1yKSxufSxtLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIE8udyh0aGlzLiRkLHRoaXMpfSxtLnRvRGF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSl9LG0udG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNWYWxpZCgpP3RoaXMudG9JU09TdHJpbmcoKTpudWxsfSxtLnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9JU09TdHJpbmcoKX0sbS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvVVRDU3RyaW5nKCl9LE19KCksYj1fLnByb3RvdHlwZTtyZXR1cm4gdy5wcm90b3R5cGU9YixbW1wiJG1zXCIscl0sW1wiJHNcIixpXSxbXCIkbVwiLHNdLFtcIiRIXCIsdV0sW1wiJFdcIixhXSxbXCIkTVwiLGZdLFtcIiR5XCIsY10sW1wiJERcIixkXV0uZm9yRWFjaCgoZnVuY3Rpb24odCl7Ylt0WzFdXT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy4kZyhlLHRbMF0sdFsxXSl9fSkpLHcuZXh0ZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuJGl8fCh0KGUsXyx3KSx0LiRpPSEwKSx3fSx3LmxvY2FsZT1TLHcuaXNEYXlqcz1wLHcudW5peD1mdW5jdGlvbih0KXtyZXR1cm4gdygxZTMqdCl9LHcuZW49dltEXSx3LkxzPXYsdy5wPXt9LHd9KSk7IiwgbnVsbCwgbnVsbCwgIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKG4pOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuZGF5anNfcGx1Z2luX3F1YXJ0ZXJPZlllYXI9bigpfSh0aGlzLChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PVwibW9udGhcIixuPVwicXVhcnRlclwiO3JldHVybiBmdW5jdGlvbihlLGkpe3ZhciByPWkucHJvdG90eXBlO3IucXVhcnRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy4kdXRpbHMoKS51KHQpP01hdGguY2VpbCgodGhpcy5tb250aCgpKzEpLzMpOnRoaXMubW9udGgodGhpcy5tb250aCgpJTMrMyoodC0xKSl9O3ZhciBzPXIuYWRkO3IuYWRkPWZ1bmN0aW9uKGUsaSl7cmV0dXJuIGU9TnVtYmVyKGUpLHRoaXMuJHV0aWxzKCkucChpKT09PW4/dGhpcy5hZGQoMyplLHQpOnMuYmluZCh0aGlzKShlLGkpfTt2YXIgdT1yLnN0YXJ0T2Y7ci5zdGFydE9mPWZ1bmN0aW9uKGUsaSl7dmFyIHI9dGhpcy4kdXRpbHMoKSxzPSEhci51KGkpfHxpO2lmKHIucChlKT09PW4pe3ZhciBvPXRoaXMucXVhcnRlcigpLTE7cmV0dXJuIHM/dGhpcy5tb250aCgzKm8pLnN0YXJ0T2YodCkuc3RhcnRPZihcImRheVwiKTp0aGlzLm1vbnRoKDMqbysyKS5lbmRPZih0KS5lbmRPZihcImRheVwiKX1yZXR1cm4gdS5iaW5kKHRoaXMpKGUsaSl9fX0pKTsiLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE9wZXJhdG9ycztcbihmdW5jdGlvbiAoT3BlcmF0b3JzKSB7XG4gICAgT3BlcmF0b3JzW1wiQU5EXCJdID0gXCJBTkRcIjtcbiAgICBPcGVyYXRvcnNbXCJPUlwiXSA9IFwiT1JcIjtcbiAgICBPcGVyYXRvcnNbXCJYT1JcIl0gPSBcIlhPUlwiO1xuICAgIE9wZXJhdG9yc1tcIk5PVFwiXSA9IFwiTk9UXCI7XG59KShPcGVyYXRvcnMgPSBleHBvcnRzLk9wZXJhdG9ycyB8fCAoZXhwb3J0cy5PcGVyYXRvcnMgPSB7fSkpO1xudmFyIFN0cnVjdHVyYWxDaGFyYWN0ZXJzO1xuKGZ1bmN0aW9uIChTdHJ1Y3R1cmFsQ2hhcmFjdGVycykge1xuICAgIFN0cnVjdHVyYWxDaGFyYWN0ZXJzW1wiT1BFTl9QQVJFTlRIRVNJU1wiXSA9IFwiKFwiO1xuICAgIFN0cnVjdHVyYWxDaGFyYWN0ZXJzW1wiQ0xPU0VfUEFSRU5USEVTSVNcIl0gPSBcIilcIjtcbn0pKFN0cnVjdHVyYWxDaGFyYWN0ZXJzID0gZXhwb3J0cy5TdHJ1Y3R1cmFsQ2hhcmFjdGVycyB8fCAoZXhwb3J0cy5TdHJ1Y3R1cmFsQ2hhcmFjdGVycyA9IHt9KSk7XG52YXIgVG9rZW5zO1xuKGZ1bmN0aW9uIChUb2tlbnMpIHtcbiAgICBUb2tlbnNbXCJJREVOVElGSUVSXCJdID0gXCJJREVOVElGSUVSXCI7XG4gICAgVG9rZW5zW1wiT1BFUkFUT1JcIl0gPSBcIk9QRVJBVE9SXCI7XG4gICAgVG9rZW5zW1wiU1RSVUNUVVJBTF9DSEFSQUNURVJcIl0gPSBcIlNUUlVDVFVSQUxfQ0hBUkFDVEVSXCI7XG4gICAgVG9rZW5zW1wiRU9GXCJdID0gXCJFT0ZcIjtcbiAgICBUb2tlbnNbXCJDT01NRU5UXCJdID0gXCJDT01NRU5UXCI7XG59KShUb2tlbnMgPSBleHBvcnRzLlRva2VucyB8fCAoZXhwb3J0cy5Ub2tlbnMgPSB7fSkpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuZXhwb3J0cy5PUEVSQVRPUl9QUkVDRURFTkNFID0ge1xuICAgIE5PVDogMCxcbiAgICBYT1I6IDEsXG4gICAgQU5EOiAyLFxuICAgIE9SOiAzXG59O1xuZXhwb3J0cy5WQUxJRF9UT0tFTlMgPSB7XG4gICAgaWRlbnRpZmllck9ubHk6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSLFxuICAgICAgICAgICAgdmFsdWU6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgIF0sXG4gICAgaWRlbnRpZmllck9yTm90OiBbXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUixcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLk9QRU5fUEFSRU5USEVTSVNcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCB9LFxuICAgIF0sXG4gICAgYmluYXJ5T3BlcmF0b3I6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuT1IgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUiB9LFxuICAgIF0sXG4gICAgYmluYXJ5T3BlcmF0b3JPckNsb3NlOiBbXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5BTkQgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk9SIH0sXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5YT1IgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgIF1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5leHBvcnRzLlNUUlVDVFVSQUxfQ0hBUkFDVEVSUyA9IHtcbiAgICAnKCc6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJUyxcbiAgICAnKSc6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuQ0xPU0VfUEFSRU5USEVTSVNcbn07XG5leHBvcnRzLk9QRVJBVE9SUyA9IHtcbiAgICBBTkQ6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCxcbiAgICBPUjogdHlwZXNfMS5PcGVyYXRvcnMuT1IsXG4gICAgWE9SOiB0eXBlc18xLk9wZXJhdG9ycy5YT1IsXG4gICAgTk9UOiB0eXBlc18xLk9wZXJhdG9ycy5OT1Rcbn07XG5leHBvcnRzLlNFUEFSQVRPUlMgPSBuZXcgU2V0KFtcbiAgICAweDAwMjAsXG4gICAgMHgwMDA5LFxuICAgIDB4MDAwYSxcbiAgICAweDAwMGQsXG5dLm1hcChmdW5jdGlvbiAoc2VwYXJhdG9yKSB7IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChzZXBhcmF0b3IpOyB9KSk7XG5leHBvcnRzLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDAyMik7XG5leHBvcnRzLkNPTU1FTlRfREVMSU1JVEVSID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDIzKTtcbmV4cG9ydHMuRU9MID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDBhKTtcbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDA1Yyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmV4cG9ydHMuY3JlYXRlUmVzdWx0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCByZW1haW5pbmdTdHJpbmcpIHsgcmV0dXJuICh7XG4gICAgdG9rZW46IF9fYXNzaWduKHsgbmFtZTogbmFtZSB9LCAodmFsdWUgIT09IG51bGwgPyB7IHZhbHVlOiB2YWx1ZSB9IDoge30pKSxcbiAgICByZW1haW5pbmdTdHJpbmc6IHJlbWFpbmluZ1N0cmluZ1xufSk7IH07XG5leHBvcnRzLmdldENvbW1lbnQgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciB0b2tlbkVuZCA9IGV4cHJlc3Npb24ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGV0dGVyID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgaWYgKGxldHRlciA9PT0gY29uc3RfMS5FT0wpIHtcbiAgICAgICAgICAgIHRva2VuRW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZVJlc3VsdCh0eXBlc18xLlRva2Vucy5DT01NRU5ULCBleHByZXNzaW9uLnNsaWNlKDAsIHRva2VuRW5kKSwgZXhwcmVzc2lvbi5zbGljZSh0b2tlbkVuZCArIDEpKTtcbn07XG5leHBvcnRzLmdldFF1b3RlZElkZW50aWZpZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciBlc2NhcGVRdW90YXRpb24gPSBmYWxzZTtcbiAgICB2YXIgdmFsdWUgPSAnJztcbiAgICB2YXIgdG9rZW5FbmQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hhciA9IGV4cHJlc3Npb25baV07XG4gICAgICAgIGlmICh0b2tlbkVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZVF1b3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKC0xKSArIGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLkVTQ0FQRV9DSEFSQUNURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlUXVvdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVF1b3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICs9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnN0XzEuU0VQQVJBVE9SUy5oYXMoY2hhcikgJiYgIWNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiICsgY2hhciArIFwiIEV4cGVjdGVkICkgY2hhcmFjdGVyIG9yIHNlcGFyYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0b2tlbkVuZCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBleHBlY3RlZCBcIiArIGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSICsgXCIgY2hhcmFjdGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGVSZXN1bHQodHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiwgdmFsdWUsIGV4cHJlc3Npb24uc2xpY2UodG9rZW5FbmQgKyAxKSk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmxleCA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHRva2VuU3RhcnQgPSBudWxsO1xuICAgIHZhciB0b2tlbkVuZCA9IG51bGw7XG4gICAgdmFyIGRlbGltaXRpbmdDaGFyYWN0ZXIgPSBudWxsO1xuICAgIC8vIExvb3BzIHRocm91Z2ggY2hhcmFjdGVycyBpbiB0aGUgZXhwcmVzc2lvbiB1bnRpbCB0aGUgbmV4dCB0b2tlbiBpcyBmb3VuZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hhciA9IGV4cHJlc3Npb25baV07XG4gICAgICAgIC8vIEZpbmRzIHRva2VtIHN0YXJ0IGFuZCByZXR1cm5zIGltbWVkaWF0ZWx5IHJldHVybnMgYW55IGlkZW50aWZpYWJsZSB0b2tlbnNcbiAgICAgICAgaWYgKHRva2VuU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJ1Y3R1cmFsQ2hhciA9IGNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdO1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmFsQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBleHByZXNzaW9uW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdHVyYWxDaGFyID09PSB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLkNMT1NFX1BBUkVOVEhFU0lTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnN0XzEuU0VQQVJBVE9SUy5oYXMobmV4dENoYXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciAhPT0gdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiICsgbmV4dENoYXIgKyBcIi4gQSBjbG9zaW5nIHBhcmVudGhlc2lzIHNob3VsZCBiZSBmb2xsb3dlZCBieSBhbm90aGVyIGNsb3NpbmcgcGFyZW50aGVzaXMgb3Igd2hpdGVzcGFjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5jcmVhdGVSZXN1bHQodHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIsIGNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdLCBleHByZXNzaW9uLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9uY2UgYSBxdW90ZWQgaWRlbnRpZmllciBoYXMgYmVlbiBpZGVudGlmaWVkIGl0IGlzIHJldHJpZXZlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldFF1b3RlZElkZW50aWZpZXIoZXhwcmVzc2lvbi5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIGEgY29tbWVudCBoYXMgYmVlbiBpZGVudGlmaWVkIGl0IGlzIHJldHJpZXZlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuQ09NTUVOVF9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0Q29tbWVudChleHByZXNzaW9uLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuU3RhcnQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJlYWtzIG9uIHRoZSBlbmQgb2YgdGhlIHRva2VuIGFuZCB0aHJvd3Mgb24gaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBpZiAoY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSB8fCBjb25zdF8xLlNUUlVDVFVSQUxfQ0hBUkFDVEVSU1tjaGFyXSkge1xuICAgICAgICAgICAgICAgIHRva2VuRW5kID0gaTtcbiAgICAgICAgICAgICAgICBkZWxpbWl0aW5nQ2hhcmFjdGVyID0gY2hhcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUiB8fFxuICAgICAgICAgICAgICAgICAgICBjaGFyID09PSBjb25zdF8xLkNPTU1FTlRfREVMSU1JVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIiArIGNoYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXBhcmF0ZXMgb3BlcmF0b3JzIGZyb20gaWRlbnRpZmllcnMgYW5kIHJldHVybnMgdGhlIGNvcnJlY3QgdG9rZW5cbiAgICBpZiAodG9rZW5TdGFydCAhPT0gbnVsbCkge1xuICAgICAgICB0b2tlbkVuZCA9ICh0b2tlbkVuZCAhPT0gbnVsbCAmJiB0b2tlbkVuZCAhPT0gdm9pZCAwID8gdG9rZW5FbmQgOiBleHByZXNzaW9uLmxlbmd0aCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHJlc3Npb24uc2xpY2UodG9rZW5TdGFydCwgdG9rZW5FbmQpO1xuICAgICAgICB2YXIgcmVtYWluaW5nU3RyaW5nID0gZXhwcmVzc2lvbi5zbGljZSh0b2tlbkVuZCk7XG4gICAgICAgIGlmIChjb25zdF8xLk9QRVJBVE9SU1t2YWx1ZV0pIHtcbiAgICAgICAgICAgIGlmIChkZWxpbWl0aW5nQ2hhcmFjdGVyICYmICFjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGRlbGltaXRpbmdDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiICsgZGVsaW1pdGluZ0NoYXJhY3RlciArIFwiLiBPcGVyYXRvcnMgc2hvdWxkIGJlIHNlcGFyYXRlZCB1c2luZyB3aGl0ZXNwYWNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuY3JlYXRlUmVzdWx0KHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCBjb25zdF8xLk9QRVJBVE9SU1t2YWx1ZV0sIHJlbWFpbmluZ1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5jcmVhdGVSZXN1bHQodHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiwgdmFsdWUsIHJlbWFpbmluZ1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyByZWFjaGVkIG5vIHRva2VucyB3ZXJlIGZvdW5kIHNvIEVPRiBpcyByZXR1cm5lZFxuICAgIHJldHVybiB1dGlsc18xLmNyZWF0ZVJlc3VsdCh0eXBlc18xLlRva2Vucy5FT0YsIG51bGwsICcnKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbGV4XzEgPSByZXF1aXJlKFwiLi4vbGV4L2xleFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmV4cG9ydHMubmV3VG9rZW5HZW5lcmF0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciByZW1haW5pbmdFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbGlkVG9rZW5zLCBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGlmIChlbmRJc1ZhbGlkID09PSB2b2lkIDApIHsgZW5kSXNWYWxpZCA9IGZhbHNlOyB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBsZXhfMS5sZXgocmVtYWluaW5nRXhwcmVzc2lvbiksIHRva2VuID0gX2EudG9rZW4sIHJlbWFpbmluZ1N0cmluZyA9IF9hLnJlbWFpbmluZ1N0cmluZztcbiAgICAgICAgICAgIHJlbWFpbmluZ0V4cHJlc3Npb24gPSByZW1haW5pbmdTdHJpbmc7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmFtZSAhPT0gdHlwZXNfMS5Ub2tlbnMuQ09NTUVOVCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVUb2tlbih0b2tlbiwgdmFsaWRUb2tlbnMsIGVuZElzVmFsaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChnZXROZXh0VG9rZW4sIHBhcnNlcikge1xuICAgIHZhciBuZXh0VG9rZW4gPSBnZXROZXh0VG9rZW4oY29uc3RfMS5WQUxJRF9UT0tFTlMuaWRlbnRpZmllck9yTm90KTtcbiAgICB2YXIgbmVnYXRlZFZhbHVlID0gbmV4dFRva2VuLnZhbHVlID09PSB0eXBlc18xLk9wZXJhdG9ycy5OT1Q7XG4gICAgaWYgKG5lZ2F0ZWRWYWx1ZSkge1xuICAgICAgICBuZXh0VG9rZW4gPSBnZXROZXh0VG9rZW4oY29uc3RfMS5WQUxJRF9UT0tFTlMuaWRlbnRpZmllck9ubHkpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBuZXh0VG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVJcbiAgICAgICAgPyBwYXJzZXIoZ2V0TmV4dFRva2VuLCB0cnVlKVxuICAgICAgICA6IFtuZXh0VG9rZW5dO1xuICAgIHJldHVybiBuZWdhdGVkVmFsdWVcbiAgICAgICAgPyBfX3NwcmVhZEFycmF5cyh2YWx1ZSwgW3sgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5OT1QgfV0pIDogdmFsdWU7XG59O1xuZXhwb3J0cy5wcmV2aW91c09wZXJhdG9yVGFrZXNQcmVjZWRlbnQgPSBmdW5jdGlvbiAocHJldmlvdXNPcGVyYXRvciwgbmV4dE9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0XzEuT1BFUkFUT1JfUFJFQ0VERU5DRVtwcmV2aW91c09wZXJhdG9yXSA8PSBjb25zdF8xLk9QRVJBVE9SX1BSRUNFREVOQ0VbbmV4dE9wZXJhdG9yXTtcbn07XG5leHBvcnRzLnZhbGlkYXRlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbGlkVG9rZW5zLCBlbmRJc1ZhbGlkKSB7XG4gICAgaWYgKGVuZElzVmFsaWQgPT09IHZvaWQgMCkgeyBlbmRJc1ZhbGlkID0gZmFsc2U7IH1cbiAgICBpZiAodG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuRU9GKSB7XG4gICAgICAgIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uJyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgdmFsaWRUb2tlbnNfMSA9IHZhbGlkVG9rZW5zOyBfaSA8IHZhbGlkVG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB2YWxpZFRva2VuID0gdmFsaWRUb2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh2YWxpZFRva2VuLm5hbWUgPT09IHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRUb2tlbi52YWx1ZSB8fCB2YWxpZFRva2VuLnZhbHVlID09PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIFJldHVybnMgdGhlIHRva2VucyB1c2luZyBwb3N0Zml4IG5vdGF0aW9uXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQgXCIgKyB0eXBlb2YgZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIC8vIGdldE5leHRUb2tlbiBrZWVwcyB0cmFjayBvZiB0aGUgcmVtYWluaW5nIGV4cHJlc3Npb25cbiAgICAvLyBhbmQgcmV0dXJuIHRoZSBuZXh0IHRva2VuIGVhY2ggdGltZSBpdCBpcyBjYWxsZWRcbiAgICB2YXIgZ2V0TmV4dFRva2VuID0gdXRpbHNfMS5uZXdUb2tlbkdlbmVyYXRvcihleHByZXNzaW9uKTtcbiAgICByZXR1cm4gcGFyc2VJbnRlcm5hbChnZXROZXh0VG9rZW4pO1xufTtcbi8vIHBhcnNlSW50ZXJuYWwgd2lsbCByZWN1cnNlIG92ZXIgYnJhY2tldGVkIGV4cHJlc3Npb25zXG52YXIgcGFyc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIChnZXROZXh0VG9rZW4sIG5lc3RlZCkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkgeyBuZXN0ZWQgPSBmYWxzZTsgfVxuICAgIC8vIFRoaXMgaW5pdGlhbGlzZXMgdGhlIG91dHB1dCB3aXRoIGV2ZXJ5dGhpbmcgdXAgdGhlIGZpcnN0IHVubmVzdGVkIG9wZXJhdG9yXG4gICAgdmFyIG91dHB1dCA9IF9fc3ByZWFkQXJyYXlzKHV0aWxzXzEuZ2V0VmFsdWUoZ2V0TmV4dFRva2VuLCBwYXJzZUludGVybmFsKSk7XG4gICAgdmFyIG9wZXJhdG9ycyA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciB2YWxpZFRva2VucyA9IG5lc3RlZFxuICAgICAgICAgICAgPyBjb25zdF8xLlZBTElEX1RPS0VOUy5iaW5hcnlPcGVyYXRvck9yQ2xvc2VcbiAgICAgICAgICAgIDogY29uc3RfMS5WQUxJRF9UT0tFTlMuYmluYXJ5T3BlcmF0b3I7XG4gICAgICAgIC8vIFJldHJpZXZlcyB0aGUgbmV4dCBUb2tlblxuICAgICAgICB2YXIgbmV4dFRva2VuID0gZ2V0TmV4dFRva2VuKHZhbGlkVG9rZW5zLCAhbmVzdGVkKTtcbiAgICAgICAgaWYgKG5leHRUb2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5FT0YgfHwgLy8gSWYgdGhlIGVuZCBvZiBmaWxlIGlzIGZvdW5kIGhlcmUgdGhlbiByZXR1cm4gd2hhdCB3ZSBoYXZlXG4gICAgICAgICAgICBuZXh0VG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIgLy8gVGhlIGV4cHJlc3Npb24gd2lsbCBiZSByZXR1cm5lZCBhbmQgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGZpbmFsIGV4cHJlc3Npb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXMob3V0cHV0LCBfX3NwcmVhZEFycmF5cyhvcGVyYXRvcnMpLnJldmVyc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gcG9zdGZpeCBub3RhdGlvbiBvcGVyYXRvciBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5IHByZWNlZGVuY2VcbiAgICAgICAgd2hpbGUgKG9wZXJhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c09wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdG9ycy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0b3IgJiZcbiAgICAgICAgICAgICAgICB1dGlsc18xLnByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudChwcmV2aW91c09wZXJhdG9yLnZhbHVlLCBuZXh0VG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gX19zcHJlYWRBcnJheXMob3V0cHV0LCBbcHJldmlvdXNPcGVyYXRvcl0pO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9ycyA9IG9wZXJhdG9ycy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV3IG9wZXJhdG9yIGlzIG5vdyBhZGRlZCB0byB0aGUgc3RhY2tcbiAgICAgICAgb3BlcmF0b3JzID0gX19zcHJlYWRBcnJheXMob3BlcmF0b3JzLCBbbmV4dFRva2VuXSk7XG4gICAgICAgIC8vIE9uY2UgdGhpcyBpcyBkb25lIHdlIGNhbiBnZXQgZXZlcnl0aGluZyB1bnRpbCB0aGUgbmV4dCB1bm5lc3RlZFxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgYWRkIGl0IHRvIHRoZSBvdXRwdXRcbiAgICAgICAgb3V0cHV0ID0gX19zcHJlYWRBcnJheXMob3V0cHV0LCB1dGlsc18xLmdldFZhbHVlKGdldE5leHRUb2tlbiwgcGFyc2VJbnRlcm5hbCkpO1xuICAgIH1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5leHBvcnRzLmFuZFV0aWwgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7IH07XG5leHBvcnRzLm9yVXRpbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCB8fCByaWdodDsgfTtcbmV4cG9ydHMueG9yVXRpbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gIShsZWZ0ID09PSByaWdodCk7IH07XG5leHBvcnRzLm5vdFV0aWwgPSBmdW5jdGlvbiAoaWRlbnRpZmllcikgeyByZXR1cm4gIWlkZW50aWZpZXI7IH07XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcbmV4cG9ydHMuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn07XG5leHBvcnRzLnRocm93SW52YWxpZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBvc3RmaXggZXhwcmVzc2lvbjogXCIgKyBtZXNzYWdlKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5PUEVSQVRPUl9NQVAgPSAoX2EgPSB7fSxcbiAgICBfYVt0eXBlc18xLk9wZXJhdG9ycy5BTkRdID0gdXRpbHNfMS5hbmRVdGlsLFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLk9SXSA9IHV0aWxzXzEub3JVdGlsLFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLlhPUl0gPSB1dGlsc18xLnhvclV0aWwsXG4gICAgX2EpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi4vcGFyc2UvcGFyc2VcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5nZXRFdmFsdWF0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciBwYXJzZWRFeHByZXNzaW9uID0gcGFyc2VfMS5wYXJzZShleHByZXNzaW9uKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJvb2xlYW5NYXApIHsgcmV0dXJuIGV4cG9ydHMuZXZhbHVhdGUocGFyc2VkRXhwcmVzc2lvbiwgYm9vbGVhbk1hcCk7IH07XG59O1xuZXhwb3J0cy5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBib29sZWFuTWFwKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihleHByZXNzaW9uICsgXCIgc2hvdWxkIGJlIGFuIGFycmF5LiBldmFsdWF0ZSB0YWtlcyBpbiBhIHBhcnNlZCBleHByZXNzaW9uLiBVc2UgaW4gY29tYmluYXRpb24gd2l0aCBwYXJzZSBvciB1c2UgZ2V0RXZhbHVhdG9yXCIpO1xuICAgIH1cbiAgICAvLyBSZXNvbHZlcyBlYWNoIGlkZW50aWZpZXIgYW5kIGFkZHMgaXQgdG8gYSBzdGFja1xuICAgIC8vIFdoZW4gb3BlcmF0b3IgaXMgZm91bmQgaXQgb3BlcmF0ZXMgb24gdGhlIHRvcCB2YWx1ZShzKVxuICAgIC8vIG9uIHRoZSBzdGFjaywgcmVtb3ZlcyB0aGVtIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggdGhlXG4gICAgLy8gcmVzdWx0XG4gICAgdmFyIGV2YWx1YXRlZEV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlZHVjZShmdW5jdGlvbiAoc3RhY2ssIHRva2VuLCBpKSB7XG4gICAgICAgIGlmICghKHRva2VuICYmICh1dGlsc18xLmlzSWRlbnRpZmllcih0b2tlbikgfHwgdXRpbHNfMS5pc09wZXJhdG9yKHRva2VuKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuOiBcIiArIHRva2VuICsgXCIuIEZvdW5kIGluIHBhcnNlZCBleHByZXNzaW9uIGF0IGluZGV4IFwiICsgaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09IHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyhzdGFjaywgW0Jvb2xlYW4oYm9vbGVhbk1hcFt0b2tlbi52YWx1ZV0pXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlY29uZExhc3RJdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgIHZhciBsYXN0SXRlbSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCkge1xuICAgICAgICAgICAgaWYgKGxhc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24oJ21pc3NpbmcgaWRlbnRpZmllcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKHN0YWNrLnNsaWNlKDAsIC0xKSwgW3V0aWxzXzEubm90VXRpbChsYXN0SXRlbSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEl0ZW0gPT09IHVuZGVmaW5lZCB8fCBzZWNvbmRMYXN0SXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24oJ21pc3NpbmcgaWRlbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRvclV0aWwgPSBjb25zdF8xLk9QRVJBVE9SX01BUFt0b2tlbi52YWx1ZV07XG4gICAgICAgIGlmICghb3BlcmF0b3JVdGlsKSB7XG4gICAgICAgICAgICB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24oJ3Vua25vd24gb3BlcmF0b3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXMoc3RhY2suc2xpY2UoMCwgLTIpLCBbb3BlcmF0b3JVdGlsKHNlY29uZExhc3RJdGVtLCBsYXN0SXRlbSldKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGV2YWx1YXRlZEV4cHJlc3Npb24ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbigndG9vIG1hbnkgaWRlbnRpZmllcnMgYWZ0ZXIgZXZhbHVhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbHVhdGVkRXhwcmVzc2lvblswXTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGV2YWx1YXRlXzEgPSByZXF1aXJlKFwiLi9ldmFsdWF0ZS9ldmFsdWF0ZVwiKTtcbmV4cG9ydHMuZ2V0RXZhbHVhdG9yID0gZXZhbHVhdGVfMS5nZXRFdmFsdWF0b3I7XG5leHBvcnRzLmV2YWx1YXRlID0gZXZhbHVhdGVfMS5ldmFsdWF0ZTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vcGFyc2UvcGFyc2VcIik7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VfMS5wYXJzZTtcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZSc7XG5pbXBvcnQgeyBDb21tYW5kcyB9IGZyb20gJy4vQ29tbWFuZHMnO1xuaW1wb3J0IHsgVGFza3NFdmVudHMgfSBmcm9tICcuL1Rhc2tzRXZlbnRzJztcbmltcG9ydCB7IGluaXRpYWxpemVGaWxlIH0gZnJvbSAnLi9GaWxlJztcbmltcG9ydCB7IElubGluZVJlbmRlcmVyIH0gZnJvbSAnLi9JbmxpbmVSZW5kZXJlcic7XG5pbXBvcnQgeyBuZXdMaXZlUHJldmlld0V4dGVuc2lvbiB9IGZyb20gJy4vTGl2ZVByZXZpZXdFeHRlbnNpb24nO1xuaW1wb3J0IHsgUXVlcnlSZW5kZXJlciB9IGZyb20gJy4vUXVlcnlSZW5kZXJlcic7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSBmcm9tICcuL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBTZXR0aW5nc1RhYiB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzVGFiJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi9TdGF0dXNSZWdpc3RyeSc7XG5pbXBvcnQgeyBFZGl0b3JTdWdnZXN0b3IgfSBmcm9tICcuL1N1Z2dlc3Rvci9FZGl0b3JTdWdnZXN0b3JQb3B1cCc7XG5pbXBvcnQgeyBTdGF0dXNTZXR0aW5ncyB9IGZyb20gJy4vQ29uZmlnL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBwcml2YXRlIGNhY2hlOiBDYWNoZSB8IHVuZGVmaW5lZDtcbiAgICBwdWJsaWMgaW5saW5lUmVuZGVyZXI6IElubGluZVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBxdWVyeVJlbmRlcmVyOiBRdWVyeVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbG9hZGluZyBwbHVnaW4gXCJ0YXNrc1wiJyk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nc1RhYih7IHBsdWdpbjogdGhpcyB9KSk7XG5cbiAgICAgICAgaW5pdGlhbGl6ZUZpbGUoe1xuICAgICAgICAgICAgbWV0YWRhdGFDYWNoZTogdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgIHZhdWx0OiB0aGlzLmFwcC52YXVsdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTG9hZCBjb25maWd1cmVkIHN0YXR1cyB0eXBlcy5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkVGFza1N0YXR1c2VzKCk7XG5cbiAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFRhc2tzRXZlbnRzKHsgb2JzaWRpYW5FdmVudHM6IHRoaXMuYXBwLndvcmtzcGFjZSB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZSh7XG4gICAgICAgICAgICBtZXRhZGF0YUNhY2hlOiB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgdmF1bHQ6IHRoaXMuYXBwLnZhdWx0LFxuICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmxpbmVSZW5kZXJlciA9IG5ldyBJbmxpbmVSZW5kZXJlcih7IHBsdWdpbjogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlbmRlcmVyID0gbmV3IFF1ZXJ5UmVuZGVyZXIoeyBwbHVnaW46IHRoaXMsIGV2ZW50cyB9KTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKG5ld0xpdmVQcmV2aWV3RXh0ZW5zaW9uKCkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRWRpdG9yU3VnZ2VzdChuZXcgRWRpdG9yU3VnZ2VzdG9yKHRoaXMuYXBwLCBnZXRTZXR0aW5ncygpKSk7XG4gICAgICAgIG5ldyBDb21tYW5kcyh7IHBsdWdpbjogdGhpcyB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkVGFza1N0YXR1c2VzKCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1c1NldHRpbmdzIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBTdGF0dXNTZXR0aW5ncy5hcHBseVRvU3RhdHVzUmVnaXN0cnkoc3RhdHVzU2V0dGluZ3MsIFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygndW5sb2FkaW5nIHBsdWdpbiBcInRhc2tzXCInKTtcbiAgICAgICAgdGhpcy5jYWNoZT8udW5sb2FkKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IHRoaXMubG9hZERhdGEoKTtcbiAgICAgICAgdXBkYXRlU2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRUYXNrU3RhdHVzZXMoKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEoZ2V0U2V0dGluZ3MoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRhc2tzKCk6IFRhc2tbXSB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlPy5nZXRUYXNrcygpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBNZXRhZGF0YUNhY2hlLCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgQ2FjaGVkTWV0YWRhdGEsIEV2ZW50UmVmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBIZWFkaW5nQ2FjaGUsIExpc3RJdGVtQ2FjaGUsIFNlY3Rpb25DYWNoZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IE11dGV4IH0gZnJvbSAnYXN5bmMtbXV0ZXgnO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgVGFza3NFdmVudHMgfSBmcm9tICcuL1Rhc2tzRXZlbnRzJztcbmltcG9ydCB7IERhdGVGYWxsYmFjayB9IGZyb20gJy4vRGF0ZUZhbGxiYWNrJztcbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgTGF6eSB9IGZyb20gJy4vbGliL0xhenknO1xuXG5leHBvcnQgZW51bSBTdGF0ZSB7XG4gICAgQ29sZCA9ICdDb2xkJyxcbiAgICBJbml0aWFsaXppbmcgPSAnSW5pdGlhbGl6aW5nJyxcbiAgICBXYXJtID0gJ1dhcm0nLFxufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXM6IEV2ZW50UmVmW107XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdDogVmF1bHQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdEV2ZW50UmVmZXJlbmNlczogRXZlbnRSZWZbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogVGFza3NFdmVudHM7XG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudHNFdmVudFJlZmVyZW5jZXM6IEV2ZW50UmVmW107XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhc2tzTXV0ZXg6IE11dGV4O1xuICAgIHByaXZhdGUgc3RhdGU6IFN0YXRlO1xuICAgIHByaXZhdGUgdGFza3M6IFRhc2tbXTtcblxuICAgIC8qKlxuICAgICAqIFdlIGNhbm5vdCBrbm93IGlmIHRoaXMgY2xhc3Mgd2lsbCBiZSBpbnN0YW50aWF0ZWQgYmVjYXVzZSBvYnNpZGlhbiBzdGFydGVkXG4gICAgICogb3IgYmVjYXVzZSB0aGUgcGx1Z2luIHdhcyBhY3RpdmF0ZWQgbGF0ZXIuIFRoaXMgbWVhbnMgd2UgaGF2ZSB0byBsb2FkIHRoZVxuICAgICAqIHdob2xlIHZhdWx0IG9uY2UgYWZ0ZXIgdGhlIGZpcnN0IG1ldGFkYXRhIGNhY2hlIHJlc29sdmUgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgKiBsb2FkIHRoZSBlbnRpcmUgdmF1bHQgaW4gY2FzZSBvYnNpZGlhbiBpcyBzdGFydGluZyB1cC4gSW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiBvYnNpZGlhbiBzdGFydGluZywgdGhlIHRhc2sgY2FjaGUncyBpbml0aWFsIGxvYWQgd291bGQgZW5kIHVwIHdpdGggMCB0YXNrcyxcbiAgICAgKiBhcyB0aGUgbWV0YWRhdGEgY2FjaGUgd291bGQgc3RpbGwgYmUgZW1wdHkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkZWRBZnRlckZpcnN0UmVzb2x2ZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQsIGV2ZW50cyB9OiB7IG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7IHZhdWx0OiBWYXVsdDsgZXZlbnRzOiBUYXNrc0V2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG1ldGFkYXRhQ2FjaGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnZhdWx0ID0gdmF1bHQ7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgdGhpcy50YXNrc011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5Db2xkO1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG5cbiAgICAgICAgdGhpcy5sb2FkZWRBZnRlckZpcnN0UmVzb2x2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DYWNoZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvVmF1bHQoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xuXG4gICAgICAgIHRoaXMubG9hZFZhdWx0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVubG9hZCgpOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudFJlZmVyZW5jZSBvZiB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5vZmZyZWYoZXZlbnRSZWZlcmVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBldmVudFJlZmVyZW5jZSBvZiB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnZhdWx0Lm9mZnJlZihldmVudFJlZmVyZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50UmVmZXJlbmNlIG9mIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vZmYoZXZlbnRSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRhc2tzKCk6IFRhc2tbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdGF0ZSgpOiBTdGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5U3Vic2NyaWJlcnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJDYWNoZVVwZGF0ZSh7XG4gICAgICAgICAgICB0YXNrczogdGhpcy50YXNrcyxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRXZlbnRlUmVmZXJlbmNlID0gdGhpcy5tZXRhZGF0YUNhY2hlLm9uKCdyZXNvbHZlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmVkIGZpcmVzIG9uIGV2ZXJ5IGNoYW5nZS5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBpbml0aWFsaXplIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRBZnRlckZpcnN0UmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZFZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChyZXNvbHZlZEV2ZW50ZVJlZmVyZW5jZSk7XG5cbiAgICAgICAgLy8gRG9lcyBub3QgZmlyZSB3aGVuIHN0YXJ0aW5nIHVwIG9ic2lkaWFuIGFuZCBvbmx5IHdvcmtzIGZvciBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBjaGFuZ2VkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLm1ldGFkYXRhQ2FjaGUub24oJ2NoYW5nZWQnLCAoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChjaGFuZ2VkRXZlbnRSZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9WYXVsdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyB1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSB9ID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICBjb25zdCBjcmVhdGVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdjcmVhdGUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50YXNrc011dGV4LnJ1bkV4Y2x1c2l2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMucHVzaChjcmVhdGVkRXZlbnRSZWZlcmVuY2UpO1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRFdmVudFJlZmVyZW5jZSA9IHRoaXMudmF1bHQub24oJ2RlbGV0ZScsIChmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5maWx0ZXIoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCAhPT0gZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2goZGVsZXRlZEV2ZW50UmVmZXJlbmNlKTtcblxuICAgICAgICBjb25zdCByZW5hbWVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja0RhdGUgPSBuZXcgTGF6eSgoKSA9PiBEYXRlRmFsbGJhY2suZnJvbVBhdGgoZmlsZS5wYXRoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5tYXAoKHRhc2s6IFRhc2spOiBUYXNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sucGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayh7IC4uLnRhc2ssIHBhdGg6IGZpbGUucGF0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGYWxsYmFjay51cGRhdGVUYXNrUGF0aCh0YXNrLCBmaWxlLnBhdGgsIGZhbGxiYWNrRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2gocmVuYW1lZEV2ZW50UmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvRXZlbnRzKCk6IHZvaWQge1xuICAgICAgICBjb25zdCByZXF1ZXN0UmVmZXJlbmNlID0gdGhpcy5ldmVudHMub25SZXF1ZXN0Q2FjaGVVcGRhdGUoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIoeyB0YXNrczogdGhpcy50YXNrcywgc3RhdGU6IHRoaXMuc3RhdGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50c0V2ZW50UmVmZXJlbmNlcy5wdXNoKHJlcXVlc3RSZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9hZFZhdWx0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrc011dGV4LnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5pdGlhbGl6aW5nO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgdGhpcy52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkubWFwKChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleEZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldhcm07XG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgY2FjaGUgaXMgbm93IHdhcm06XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW5kZXhGaWxlKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgIGlmIChmaWxlQ2FjaGUgPT09IG51bGwgfHwgZmlsZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9sZFRhc2tzID0gdGhpcy50YXNrcy5maWx0ZXIoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLnBhdGggPT09IGZpbGUucGF0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gZmlsZUNhY2hlLmxpc3RJdGVtcztcbiAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBsaXN0IGl0ZW1zIGNhY2hlLCB0aGVyZSBhcmUgbm8gdGFza3MuXG4gICAgICAgIC8vIFN0aWxsIGNvbnRpbnVlIHRvIG5vdGlmeSB3YXRjaGVycyBvZiByZW1vdmFsLlxuXG4gICAgICAgIGxldCBuZXdUYXNrczogVGFza1tdID0gW107XG4gICAgICAgIGlmIChsaXN0SXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gT25seSByZWFkIHRoZSBmaWxlIGFuZCBwcm9jZXNzIGZvciB0YXNrcyBpZiB0aGVyZSBhcmUgbGlzdCBpdGVtcy5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xuICAgICAgICAgICAgbmV3VGFza3MgPSB0aGlzLmdldFRhc2tzRnJvbUZpbGVDb250ZW50KGZpbGVDb250ZW50LCBsaXN0SXRlbXMsIGZpbGVDYWNoZSwgZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBpbiBhbnkgb2YgdGhlIHRhc2tzLCB0aGVyZSdzXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIHNvIGp1c3QgcmV0dXJuLlxuICAgICAgICBpZiAoVGFzay50YXNrc0xpc3RzSWRlbnRpY2FsKG9sZFRhc2tzLCBuZXdUYXNrcykpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSBrZXB0IGZvciBub3csIHRvIGFsbG93IGZvciBkZWJ1Z2dpbmcgZHVyaW5nIGRldmVsb3BtZW50LlxuICAgICAgICAgICAgLy8gSXQgaXMgdG9vIHZlcmJvc2UgdG8gcmVsZWFzZSB0byB1c2Vycy5cbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmdldFN0YXRlKCkgPT0gU3RhdGUuV2FybSkge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuZGVidWcoYFRhc2tzIHVuY2hhbmdlZCBpbiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldFN0YXRlKCkgPT0gU3RhdGUuV2FybSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgQXQgbGVhc3Qgb25lIHRhc2ssIGl0cyBsaW5lIG51bWJlciBvciBpdHMgaGVhZGluZyBoYXMgY2hhbmdlZCBpbiAke2ZpbGUucGF0aH06IHRyaWdnZXJpbmcgYSByZWZyZXNoIG9mIGFsbCBhY3RpdmUgVGFza3MgYmxvY2tzIGluIExpdmUgUHJldmlldyBhbmQgUmVhZGluZyBtb2RlIHZpZXdzLmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0YXNrcyBmcm9tIHRoaXMgZmlsZSBmcm9tIHRoZSBjYWNoZSBiZWZvcmVcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBvbmVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGUgZmlsZS5cbiAgICAgICAgdGhpcy50YXNrcyA9IHRoaXMudGFza3MuZmlsdGVyKCh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wYXRoICE9PSBmaWxlLnBhdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudGFza3MucHVzaCguLi5uZXdUYXNrcyk7XG5cbiAgICAgICAgLy8gQWxsIHVwZGF0ZWQsIGluZm9ybSBvdXIgc3Vic2NyaWJlcnMuXG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRhc2tzRnJvbUZpbGVDb250ZW50KFxuICAgICAgICBmaWxlQ29udGVudDogc3RyaW5nLFxuICAgICAgICBsaXN0SXRlbXM6IExpc3RJdGVtQ2FjaGVbXSxcbiAgICAgICAgZmlsZUNhY2hlOiBDYWNoZWRNZXRhZGF0YSxcbiAgICAgICAgZmlsZTogVEZpbGUsXG4gICAgKTogVGFza1tdIHtcbiAgICAgICAgY29uc3QgdGFza3M6IFRhc2tbXSA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlTGluZXMgPSBmaWxlQ29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGxpbmVzSW5GaWxlID0gZmlsZUxpbmVzLmxlbmd0aDtcblxuICAgICAgICAvLyBMYXppbHkgc3RvcmUgZGF0ZSBleHRyYWN0ZWQgZnJvbSBmaWxlbmFtZSB0byBhdm9pZCBwYXJzaW5nIG1vcmUgdGhhbiBuZWVkZWRcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQoKSByZWFkaW5nICR7ZmlsZS5wYXRofWApO1xuICAgICAgICBjb25zdCBkYXRlRnJvbUZpbGVOYW1lID0gbmV3IExhenkoKCkgPT4gRGF0ZUZhbGxiYWNrLmZyb21QYXRoKGZpbGUucGF0aCkpO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc3RvcmUgc2VjdGlvbiBpbmZvcm1hdGlvbiB3aXRoIGV2ZXJ5IHRhc2sgc29cbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gdXNlIHRoYXQgd2hlbiB3ZSBwb3N0IHByb2Nlc3MgdGhlIG1hcmtkb3duXG4gICAgICAgIC8vIHJlbmRlcmVkIGxpc3RzLlxuICAgICAgICBsZXQgY3VycmVudFNlY3Rpb246IFNlY3Rpb25DYWNoZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbS50YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGlzdEl0ZW0ucG9zaXRpb24uc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlciA+PSBsaW5lc0luRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JzaWRpYW4gQ2FjaGVkTWV0YWRhdGEgaGFzIHRvbGQgdXMgdGhhdCB0aGVyZSBpcyBhIHRhc2sgb24gbGluZU51bWJlciwgYnV0IHRoZXJlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90IHRoYXQgbWFueSBsaW5lcyBpbiB0aGUgZmlsZS5cblxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB3YXMgdGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgYWxsIHRoZSAnU3R1Y2sgb24gXCJMb2FkaW5nIFRhc2tzLi4uXCInIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMgaXQgcmVzdWx0ZWQgaW4gdGhlIGxpbmUgJ3VuZGVmaW5lZCcgYmVpbmcgcGFyc2VkLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBTb21laG93IHRoZSBmaWxlIGhhZCBiZWVuIHNob3J0ZW5lZCB3aGlsc3QgT2JzaWRpYW4gd2FzIGNsb3NlZCwgbWVhbmluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuIE9ic2lkaWFuIHN0YXJ0ZWQgdXAsIGl0IGdvdCB0aGUgbmV3IGZpbGUgY29udGVudCwgYnV0IHN0aWxsIGhhZCB0aGUgb2xkIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSBhYm91dCBsb2NhdGlvbnMgb2YgbGlzdCBpdGVtcyBpbiB0aGUgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZmlsZS5wYXRofSBPYnNpZGlhbiBnYXZlIHVzIGEgbGluZSBudW1iZXIgJHtsaW5lTnVtYmVyfSBwYXN0IHRoZSBlbmQgb2YgdGhlIGZpbGUuICR7bGluZXNJbkZpbGV9LmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lIDwgbGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZW50IHBhc3QgdGhlIGN1cnJlbnQgc2VjdGlvbiAob3IgdGhpcyBpcyB0aGUgZmlyc3QgdGFzaykuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gdGhhdCBpcyByZWxldmFudCBmb3IgdGhpcyB0YXNrIGFuZCB0aGUgZm9sbG93aW5nIG9mIHRoZSBzYW1lIHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gQ2FjaGUuZ2V0U2VjdGlvbihsaW5lTnVtYmVyLCBmaWxlQ2FjaGUuc2VjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcHJvY2VzcyBhIHRhc2sgd2l0aG91dCBhIHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBmaWxlTGluZXNbbGluZU51bWJlcl07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtmaWxlLnBhdGh9OiBsaW5lICR7bGluZU51bWJlcn0gLSBpZ25vcmluZyAndW5kZWZpbmVkJyBsaW5lLmApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvblN0YXJ0OiBjdXJyZW50U2VjdGlvbi5wb3NpdGlvbi5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBDYWNoZS5nZXRQcmVjZWRpbmdIZWFkZXIobGluZU51bWJlciwgZmlsZUNhY2hlLmhlYWRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrRGF0ZTogZGF0ZUZyb21GaWxlTmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFRhc2tQYXJzaW5nRXJyb3JUb1VzZXIoZSwgZmlsZSwgbGlzdEl0ZW0sIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFza3M7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXBvcnRUYXNrUGFyc2luZ0Vycm9yVG9Vc2VyKGU6IGFueSwgZmlsZTogVEZpbGUsIGxpc3RJdGVtOiBMaXN0SXRlbUNhY2hlLCBsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZXJlIHdhcyBhbiBlcnJvciByZWFkaW5nIG9uZSBvZiB0aGUgdGFza3MgaW4gdGhpcyB2YXVsdC5cblRoZSBmb2xsb3dpbmcgdGFzayBoYXMgYmVlbiBpZ25vcmVkLCB0byBwcmV2ZW50IFRhc2tzIHF1ZXJpZXMgZ2V0dGluZyBzdHVjayB3aXRoICdMb2FkaW5nIFRhc2tzIC4uLidcbkVycm9yOiAke2V9XG5GaWxlOiAke2ZpbGUucGF0aH1cbkxpbmUgbnVtYmVyOiAke2xpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmV9XG5UYXNrIGxpbmU6ICR7bGluZX1cblxuUGxlYXNlIGNyZWF0ZSBhIGJ1ZyByZXBvcnQgZm9yIHRoaXMgbWVzc2FnZSBhdFxuaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy9uZXcvY2hvb3NlXG50byBoZWxwIHVzIGZpbmQgYW5kIGZpeCB0aGUgdW5kZXJseWluZyBpc3N1ZS5cblxuSW5jbHVkZTpcbi0gZWl0aGVyIGEgc2NyZWVuc2hvdCBvZiB0aGUgZXJyb3IgcG9wdXAsIG9yIGNvcHkgdGhlIHRleHQgZnJvbSB0aGUgY29uc29sZSwgaWYgb24gYSBkZXNrdG9wIG1hY2hpbmUuXG4tIHRoZSBvdXRwdXQgZnJvbSBydW5uaW5nIHRoZSBPYnNpZGlhbiBjb21tYW5kICdTaG93IGRlYnVnIGluZm8nXG5cblRoZSBlcnJvciBwb3B1cCB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiBUYXNrcyBpcyBzdGFydGluZyB1cCwgYnV0IGlmIHRoZSBlcnJvciBwZXJzaXN0cyxcbml0IHdpbGwgYmUgc2hvd24gaW4gdGhlIGNvbnNvbGUgZXZlcnkgdGltZSB0aGlzIGZpbGUgaXMgZWRpdGVkIGR1cmluZyB0aGUgT2JzaWRpYW5cbnNlc3Npb24uXG5gO1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluaXRpYWxpemluZykge1xuICAgICAgICAgICAgbmV3IE5vdGljZShtc2csIDEwMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFNlY3Rpb24obGluZU51bWJlclRhc2s6IG51bWJlciwgc2VjdGlvbnM6IFNlY3Rpb25DYWNoZVtdIHwgdW5kZWZpbmVkKTogU2VjdGlvbkNhY2hlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZSA8PSBsaW5lTnVtYmVyVGFzayAmJiBzZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lID49IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRQcmVjZWRpbmdIZWFkZXIobGluZU51bWJlclRhc2s6IG51bWJlciwgaGVhZGluZ3M6IEhlYWRpbmdDYWNoZVtdIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGlmIChoZWFkaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmVjZWRpbmdIZWFkZXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiBoZWFkaW5ncykge1xuICAgICAgICAgICAgaWYgKGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSA+IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlciA9IGhlYWRpbmcuaGVhZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cbn1cbiIsICJjb25zdCBFX1RJTUVPVVQgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgbXV0ZXggdG8gYmVjb21lIGF2YWlsYWJsZScpO1xuY29uc3QgRV9BTFJFQURZX0xPQ0tFRCA9IG5ldyBFcnJvcignbXV0ZXggYWxyZWFkeSBsb2NrZWQnKTtcbmNvbnN0IEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoJ3JlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWQnKTtcblxudmFyIF9fYXdhaXRlciQyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKF9tYXhDb25jdXJyZW5jeSwgX2NhbmNlbEVycm9yID0gRV9DQU5DRUxFRCkge1xuICAgICAgICB0aGlzLl9tYXhDb25jdXJyZW5jeSA9IF9tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fY2FuY2VsRXJyb3IgPSBfY2FuY2VsRXJyb3I7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX3dhaXRlcnMgPSBbXTtcbiAgICAgICAgaWYgKF9tYXhDb25jdXJyZW5jeSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbWFwaG9yZSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIGEgcG9zaXRpdmUgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9tYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgY29uc3QgbG9ja2VkID0gdGhpcy5pc0xvY2tlZCgpO1xuICAgICAgICBjb25zdCB0aWNrZXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gdGhpcy5fcXVldWUucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KSk7XG4gICAgICAgIGlmICghbG9ja2VkKVxuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2goKTtcbiAgICAgICAgcmV0dXJuIHRpY2tldFByb21pc2U7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHJlbGVhc2VdID0geWllbGQgdGhpcy5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhaXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMuX3dhaXRlcnMucHVzaCh7IHJlc29sdmUgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHdhaXRQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA8PSAwO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiAwLjMuMCwgd2lsbCBiZSByZW1vdmVkIGluIDAuNC4wLiBVc2UgcnVuRXhjbHVzaXZlIGluc3RlYWQuICovXG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21heENvbmN1cnJlbmN5ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIG1ldGhvZCBpcyB1bmF2YWlsYWJsZSBvbiBzZW1hcGhvcmVzIHdpdGggY29uY3VycmVuY3kgPiAxOyB1c2UgdGhlIHNjb3BlZCByZWxlYXNlIHJldHVybmVkIGJ5IGFjcXVpcmUgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50UmVsZWFzZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VyID0gdGhpcy5fY3VycmVudFJlbGVhc2VyO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJlbGVhc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goKHRpY2tldCkgPT4gdGlja2V0LnJlamVjdCh0aGlzLl9jYW5jZWxFcnJvcikpO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBfZGlzcGF0Y2goKSB7XG4gICAgICAgIGNvbnN0IG5leHRUaWNrZXQgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIW5leHRUaWNrZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCByZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50UmVsZWFzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVsZWFzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUrKztcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVXYWl0ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgICAgICB9O1xuICAgICAgICBuZXh0VGlja2V0LnJlc29sdmUoW3RoaXMuX3ZhbHVlLS0sIHRoaXMuX2N1cnJlbnRSZWxlYXNlcl0pO1xuICAgIH1cbiAgICBfcmVzb2x2ZVdhaXRlcnMoKSB7XG4gICAgICAgIHRoaXMuX3dhaXRlcnMuZm9yRWFjaCgod2FpdGVyKSA9PiB3YWl0ZXIucmVzb2x2ZSgpKTtcbiAgICAgICAgdGhpcy5fd2FpdGVycyA9IFtdO1xuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciQxID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBNdXRleCB7XG4gICAgY29uc3RydWN0b3IoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc2VtYXBob3JlID0gbmV3IFNlbWFwaG9yZSgxLCBjYW5jZWxFcnJvcik7XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHJlbGVhc2VyXSA9IHlpZWxkIHRoaXMuX3NlbWFwaG9yZS5hY3F1aXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5ydW5FeGNsdXNpdmUoKCkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUud2FpdEZvclVubG9jaygpO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiAwLjMuMCwgd2lsbCBiZSByZW1vdmVkIGluIDAuNC4wLiBVc2UgcnVuRXhjbHVzaXZlIGluc3RlYWQuICovXG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgdGhpcy5fc2VtYXBob3JlLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHdpdGhUaW1lb3V0KHN5bmMsIHRpbWVvdXQsIHRpbWVvdXRFcnJvciA9IEVfVElNRU9VVCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjcXVpcmU6ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgc3luYy5hY3F1aXJlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlID0gQXJyYXkuaXNBcnJheSh0aWNrZXQpID8gdGlja2V0WzFdIDogdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSxcbiAgICAgICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCByZWxlYXNlID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIHRoaXMuYWNxdWlyZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aWNrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHRpY2tldFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gMC4zLjAsIHdpbGwgYmUgcmVtb3ZlZCBpbiAwLjQuMC4gVXNlIHJ1bkV4Y2x1c2l2ZSBpbnN0ZWFkLiAqL1xuICAgICAgICByZWxlYXNlKCkge1xuICAgICAgICAgICAgc3luYy5yZWxlYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICB3YWl0Rm9yVW5sb2NrOiAoKSA9PiBzeW5jLndhaXRGb3JVbmxvY2soKSxcbiAgICAgICAgaXNMb2NrZWQ6ICgpID0+IHN5bmMuaXNMb2NrZWQoKSxcbiAgICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpc25lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHRyeUFjcXVpcmUoc3luYywgYWxyZWFkeUFjcXVpcmVkRXJyb3IgPSBFX0FMUkVBRFlfTE9DS0VEKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gd2l0aFRpbWVvdXQoc3luYywgMCwgYWxyZWFkeUFjcXVpcmVkRXJyb3IpO1xufVxuXG5leHBvcnQgeyBFX0FMUkVBRFlfTE9DS0VELCBFX0NBTkNFTEVELCBFX1RJTUVPVVQsIE11dGV4LCBTZW1hcGhvcmUsIHRyeUFjcXVpcmUsIHdpdGhUaW1lb3V0IH07XG4iLCAiLyoqXG4gKiBWYXJpb3VzIHJlbmRlcmluZyBvcHRpb25zIGZvciBhIHF1ZXJ5LlxuICovXG5leHBvcnQgY2xhc3MgTGF5b3V0T3B0aW9ucyB7XG4gICAgaGlkZVRhc2tDb3VudDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVCYWNrbGlua3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlUHJpb3JpdHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlU3RhcnREYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZVNjaGVkdWxlZERhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlRG9uZURhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlRHVlRGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVSZWN1cnJlbmNlUnVsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVFZGl0QnV0dG9uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZVVyZ2VuY3k6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3J0TW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGV4cGxhaW5RdWVyeTogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5leHBvcnQgdHlwZSBUYXNrTGF5b3V0Q29tcG9uZW50ID1cbiAgICB8ICdkZXNjcmlwdGlvbidcbiAgICB8ICdwcmlvcml0eSdcbiAgICB8ICdyZWN1cnJlbmNlUnVsZSdcbiAgICB8ICdzdGFydERhdGUnXG4gICAgfCAnc2NoZWR1bGVkRGF0ZSdcbiAgICB8ICdkdWVEYXRlJ1xuICAgIHwgJ2RvbmVEYXRlJ1xuICAgIHwgJ2Jsb2NrTGluayc7XG5cbi8qKlxuICogVGhpcyByZXByZXNlbnRzIHRoZSBkZXNpcmVkIGxheW91dCBvZiB0YXNrcyB3aGVuIHRoZXkgYXJlIHJlbmRlcmVkIGluIGEgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiAqIFRoZSBsYXlvdXQgaXMgdXNlZCB3aGVuIGZsYXR0ZW5pbmcgdGhlIHRhc2sgdG8gYSBzdHJpbmcgYW5kIHdoZW4gcmVuZGVyaW5nIHF1ZXJpZXMsIGFuZCBjYW4gYmVcbiAqIG1vZGlmaWVkIGJ5IGFwcGx5aW5nIHtAbGluayBMYXlvdXRPcHRpb25zfSBvYmplY3RzLlxuICovXG5leHBvcnQgY2xhc3MgVGFza0xheW91dCB7XG4gICAgcHVibGljIGRlZmF1bHRMYXlvdXQ6IFRhc2tMYXlvdXRDb21wb25lbnRbXSA9IFtcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ3ByaW9yaXR5JyxcbiAgICAgICAgJ3JlY3VycmVuY2VSdWxlJyxcbiAgICAgICAgJ3N0YXJ0RGF0ZScsXG4gICAgICAgICdzY2hlZHVsZWREYXRlJyxcbiAgICAgICAgJ2R1ZURhdGUnLFxuICAgICAgICAnZG9uZURhdGUnLFxuICAgICAgICAnYmxvY2tMaW5rJyxcbiAgICBdO1xuICAgIHB1YmxpYyBsYXlvdXRDb21wb25lbnRzOiBUYXNrTGF5b3V0Q29tcG9uZW50W107XG4gICAgcHVibGljIG9wdGlvbnM6IExheW91dE9wdGlvbnM7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogTGF5b3V0T3B0aW9ucywgY29tcG9uZW50cz86IFRhc2tMYXlvdXRDb21wb25lbnRbXSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBMYXlvdXRPcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENvbXBvbmVudHMgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheW91dENvbXBvbmVudHMgPSB0aGlzLmFwcGx5T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBsaXN0IG9mIGNvbXBvbmVudHMgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhcHBsaWVkLlxuICAgICAqL1xuICAgIGFwcGx5T3B0aW9ucyhsYXlvdXRPcHRpb25zOiBMYXlvdXRPcHRpb25zKTogVGFza0xheW91dENvbXBvbmVudFtdIHtcbiAgICAgICAgLy8gUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIHRhc2tDb21wb25lbnRzIGFycmF5IGlmIHRoZSBnaXZlbiBsYXlvdXRPcHRpb24gY3JpdGVyaWEgaXMgbWV0XG4gICAgICAgIGNvbnN0IHJlbW92ZUlmID0gKFxuICAgICAgICAgICAgdGFza0NvbXBvbmVudHM6IFRhc2tMYXlvdXRDb21wb25lbnRbXSxcbiAgICAgICAgICAgIHNob3VsZFJlbW92ZTogYm9vbGVhbixcbiAgICAgICAgICAgIGNvbXBvbmVudFRvUmVtb3ZlOiBUYXNrTGF5b3V0Q29tcG9uZW50LFxuICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza0NvbXBvbmVudHMuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50ICE9IGNvbXBvbmVudFRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tDb21wb25lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSBsYXlvdXQgYWNjb3JkaW5nIHRvIHRoZSB0YXNrIG9wdGlvbnMuIFRoZXNlIHJlcHJlc2VudCB0aGUgZXhpc3RpbmcgdGFzayBvcHRpb25zLFxuICAgICAgICAvLyBzbyBzb21lIGNvbXBvbmVudHMgKGUuZy4gdGhlIGRlc2NyaXB0aW9uKSBhcmUgbm90IGhlcmUgYmVjYXVzZSB0aGVyZSBhcmUgbm8gbGF5b3V0IG9wdGlvbnMgdG8gcmVtb3ZlIHRoZW0uXG4gICAgICAgIGxldCBuZXdDb21wb25lbnRzID0gdGhpcy5sYXlvdXRDb21wb25lbnRzO1xuICAgICAgICBuZXdDb21wb25lbnRzID0gcmVtb3ZlSWYobmV3Q29tcG9uZW50cywgbGF5b3V0T3B0aW9ucy5oaWRlUHJpb3JpdHksICdwcmlvcml0eScpO1xuICAgICAgICBuZXdDb21wb25lbnRzID0gcmVtb3ZlSWYobmV3Q29tcG9uZW50cywgbGF5b3V0T3B0aW9ucy5oaWRlUmVjdXJyZW5jZVJ1bGUsICdyZWN1cnJlbmNlUnVsZScpO1xuICAgICAgICBuZXdDb21wb25lbnRzID0gcmVtb3ZlSWYobmV3Q29tcG9uZW50cywgbGF5b3V0T3B0aW9ucy5oaWRlU3RhcnREYXRlLCAnc3RhcnREYXRlJyk7XG4gICAgICAgIG5ld0NvbXBvbmVudHMgPSByZW1vdmVJZihuZXdDb21wb25lbnRzLCBsYXlvdXRPcHRpb25zLmhpZGVTY2hlZHVsZWREYXRlLCAnc2NoZWR1bGVkRGF0ZScpO1xuICAgICAgICBuZXdDb21wb25lbnRzID0gcmVtb3ZlSWYobmV3Q29tcG9uZW50cywgbGF5b3V0T3B0aW9ucy5oaWRlRHVlRGF0ZSwgJ2R1ZURhdGUnKTtcbiAgICAgICAgbmV3Q29tcG9uZW50cyA9IHJlbW92ZUlmKG5ld0NvbXBvbmVudHMsIGxheW91dE9wdGlvbnMuaGlkZURvbmVEYXRlLCAnZG9uZURhdGUnKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbXBvbmVudHM7XG4gICAgfVxufVxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImltcG9ydCB0c2xpYiBmcm9tICcuLi90c2xpYi5qcyc7XHJcbmNvbnN0IHtcclxuICAgIF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduLFxyXG4gICAgX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3IsXHJcbiAgICBfX2V4cG9ydFN0YXIsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZCxcclxuICAgIF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxyXG4gICAgX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXHJcbn0gPSB0c2xpYjtcclxuZXhwb3J0IHtcclxuICAgIF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduLFxyXG4gICAgX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3IsXHJcbiAgICBfX2V4cG9ydFN0YXIsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZCxcclxuICAgIF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxyXG4gICAgX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXHJcbn07XHJcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgKiBhcyBjaHJvbm8gZnJvbSAnY2hyb25vLW5vZGUnO1xuXG5leHBvcnQgY2xhc3MgRGF0ZVBhcnNlciB7XG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGUoaW5wdXQ6IHN0cmluZywgZm9yd2FyZERhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IG1vbWVudC5Nb21lbnQge1xuICAgICAgICAvLyBVc2luZyBzdGFydCBvZiBkYXkgdG8gY29ycmVjdGx5IG1hdGNoIG9uIGNvbXBhcmlzb24gd2l0aCBvdGhlciBkYXRlcyAobGlrZSBlcXVhbGl0eSkuXG4gICAgICAgIHJldHVybiB3aW5kb3dcbiAgICAgICAgICAgIC5tb21lbnQoXG4gICAgICAgICAgICAgICAgY2hyb25vLnBhcnNlRGF0ZShpbnB1dCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmREYXRlOiBmb3J3YXJkRGF0ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdGFydE9mKCdkYXknKTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBBbiBFeHBsYW5hdGlvbiBvYmplY3Qgc3RvcmVzIGEgdGV4dCBkZXNjcmlwdGlvbiBvZiBhIFF1ZXJ5IGluc3RydWN0aW9uLCBvciBhIGNvbXBvbmVudCBvZiBvbmUuXG4gKlxuICogSXQgc3VwcG9ydHMgQm9vbGVhbiBjb21iaW5hdGlvbnMgdmlhIHRoZSB7QGxpbmsgY2hpbGRyZW59IGZpZWxkLlxuICpcbiAqIEluaXRpYWxseSwgdGhlIHtAbGluayBkZXNjcmlwdGlvbn0gd2lsbCBzaW1wbHkgcmVzdGF0ZSB0aGUgaW5zdHJ1Y3Rpb24gZmlsdGVyLlxuICogTGF0ZXIsIG1vcmUgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb25zIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgRXhwbGFuYXRpb24ge1xuICAgIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBzeW1ib2w6IHN0cmluZzsgLy8gQU5ELCBPUiwgTk9ULCBYT1JcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2hpbGRyZW46IEV4cGxhbmF0aW9uW107XG5cbiAgICBjb25zdHJ1Y3RvcihkZXNjcmlwdGlvbjogc3RyaW5nLCBjaGlsZHJlbjogRXhwbGFuYXRpb25bXSA9IFtdLCBzeW1ib2w6IHN0cmluZyA9ICcnKSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gRXhwbGFuYXRpb24gb2JqZWN0IHJlcHJlc2VudGluZyBCb29sZWFuIEFORFxuICAgICAqIEBwYXJhbSBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYm9vbGVhbkFuZChjaGlsZHJlbjogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lT3JDcmVhdGVFeHBsYW5hdGlvbignQWxsIG9mJywgY2hpbGRyZW4sICdBTkQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gRXhwbGFuYXRpb24gb2JqZWN0IHJlcHJlc2VudGluZyBCb29sZWFuIE9SXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuT3IoY2hpbGRyZW46IEV4cGxhbmF0aW9uW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tYmluZU9yQ3JlYXRlRXhwbGFuYXRpb24oJ0F0IGxlYXN0IG9uZSBvZicsIGNoaWxkcmVuLCAnT1InKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gRXhwbGFuYXRpb24gb2JqZWN0IHJlcHJlc2VudGluZyBCb29sZWFuIE5PVFxuICAgICAqIEBwYXJhbSBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYm9vbGVhbk5vdChjaGlsZHJlbjogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKCdOb25lIG9mJywgY2hpbGRyZW4sICdOT1QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gRXhwbGFuYXRpb24gb2JqZWN0IHJlcHJlc2VudGluZyBCb29sZWFuIFhPUlxuICAgICAqIEBwYXJhbSBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYm9vbGVhblhvcihjaGlsZHJlbjogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKCdFeGFjdGx5IG9uZSBvZicsIGNoaWxkcmVuLCAnWE9SJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFeHBsYW5hdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpdCB3aWxsIG5vdCBoYXZlIGEgZmluYWwgZW5kLW9mLWxpbmUgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VycmVudEluZGVudGF0aW9uIC0gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFVzZXJzIGNhbiBpZ25vcmUgaXQuXG4gICAgICovXG4gICAgcHVibGljIGFzU3RyaW5nKGN1cnJlbnRJbmRlbnRhdGlvbjogc3RyaW5nID0gJycpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZW50YXRpb24gKyB0aGlzLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgaGF2ZSBjaGlsZHJlbiwgc28gY29uY2F0ZW5hdGUgdGhlbSB0b2dldGhlclxuICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudEluZGVudGF0aW9uICsgYCR7dGhpcy5zeW1ib2x9YDtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlc2NyaXB0aW9ucyBsaWtlICdBbGwgb2YnLCAnTm9uZSBvZicgYXJlIG9uZSByZWFsbHkgbWVhbmluZ2Z1bFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBmaWx0ZXIuIE90aGVyd2lzZSwgdGhleSBhcmUganVzdCBjb25mdXNpbmcuXG4gICAgICAgICAgICByZXN1bHQgKz0gYCAoJHt0aGlzLmRlc2NyaXB0aW9ufSlgO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnOic7XG4gICAgICAgIGNvbnN0IG5ld0luZGVudGF0aW9uID0gY3VycmVudEluZGVudGF0aW9uICsgJyAgJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFxcbiR7dGhpcy5jaGlsZHJlbltpXS5hc1N0cmluZyhuZXdJbmRlbnRhdGlvbil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNvbWJpbmVPckNyZWF0ZUV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcsIGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdLCBzeW1ib2w6IHN0cmluZykge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDAgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkMSA9IGNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgaWYgKGNoaWxkMC5zeW1ib2wgPT09IHN5bWJvbCAmJiBjaGlsZDEuc3ltYm9sID09PSAnJykge1xuICAgICAgICAgICAgICAgIGNoaWxkMC5jaGlsZHJlbi5wdXNoKGNoaWxkMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uLCBjaGlsZHJlbiwgc3ltYm9sKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5cbi8qKlxuICogQSBzb3J0aW5nIGZ1bmN0aW9uLCB0aGF0IHRha2VzIHR3byBUYXNrIG9iamVjdHMgYW5kIHJldHVybnNcbiAqIGFuZCByZXR1cm5zIG9uZSBvZjpcbiAqIC0gYC0xYCBvciBzb21lIG90aGVyIG5lZ2F0aXZlIG51bWJlciwgaWYgYSBpcyBsZXNzIHRoYW4gYiBieSBzb21lIG9yZGVyaW5nIGNyaXRlcmlvbi5cbiAqIC0gYCsxYCBvciBzb21lIG90aGVyIHBvc2l0aXZlIG51bWJlciwgaWYgYSBpcyBncmVhdGVyIHRoYW4gYiBieSB0aGUgb3JkZXJpbmcgY3JpdGVyaW9uLlxuICogLSBgMGAgb3Igc29tZXRpbWVzIGAtMGAsIGlmIGEgZXF1YWxzIGIgYnkgdGhlIG9yZGVyaW5nIGNyaXRlcmlvbi5cbiAqXG4gKiBUeXBpY2FsbHkgQ29tcGFyYXRvciBmdW5jdGlvbnMgYXJlIHN0b3JlZCBpbiBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdC5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGFyYXRvciA9IChhOiBUYXNrLCBiOiBUYXNrKSA9PiBudW1iZXI7XG5cbi8qKlxuICogU29ydGVyIHJlcHJlc2VudHMgYSBzaW5nbGUgJ3NvcnQgYnknIGluc3RydWN0aW9uLlxuICogSXQgc3RvcmVzIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIGFzIGEge0BsaW5rIENvbXBhcmF0b3J9LlxuICovXG5leHBvcnQgY2xhc3MgU29ydGVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgY29tcGFyYXRvcjogQ29tcGFyYXRvcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3BlcnR5IC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0ge0BsaW5rIENvbXBhcmF0b3J9IGZ1bmN0aW9uLCBmb3Igc29ydGluZyBpbiB0aGUgc3RhbmRhcmQgZGlyZWN0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgSWYgYHJldmVyc2VgIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBjb252ZXJ0ZWQgdG8gcmV2ZXJzZSB0aGUgc29ydCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHJldmVyc2UgLSB3aGV0aGVyIHRoZSBzb3J0IG9yZGVyIHNob3VsZCBiZSByZXZlcnNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eTogc3RyaW5nLCBjb21wYXJhdG9yOiBDb21wYXJhdG9yLCByZXZlcnNlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gU29ydGVyLm1heWJlUmV2ZXJzZShyZXZlcnNlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYXliZVJldmVyc2UocmV2ZXJzZTogYm9vbGVhbiwgY29tcGFyYXRvcjogQ29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSA/IFNvcnRlci5tYWtlUmV2ZXJzZWRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIDogY29tcGFyYXRvcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYWtlUmV2ZXJzZWRDb21wYXJhdG9yKGNvbXBhcmF0b3I6IENvbXBhcmF0b3IpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBjYW4gcmV0dXJuIC0wLlxuICAgICAgICByZXR1cm4gKGEsIGIpID0+IChjb21wYXJhdG9yKGEsIGIpICogLTEpIGFzIC0xIHwgMCB8IDE7XG4gICAgfVxufVxuIiwgIi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGFzIHBhcnQgb2YgYSBSZWdFeHAgbGl0ZXJhbGx5LlxuICogVGFrZW4gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMjZXNjYXBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzOiBzdHJpbmcpIHtcbiAgICAvLyBOT1RFOiA9IGlzIG5vdCBlc2NhcGVkLCBhcyBkb2luZyBzbyBnaXZlcyBlcnJvcjpcbiAgICAvLyAgICAgICAgIEludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvKF58XFxzKWhlbGxvXFw9d29ybGQoJHxcXHMpLzogSW52YWxpZCBlc2NhcGVcbiAgICAvLyBOT1RFOiAhIGlzIG5vdCBlc2NhcGVkLCBhcyBkb2luZyBzbyBnaXZlcyBlcnJvcjpcbiAgICAvLyAgICAgICAgIEludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvKF58XFxzKWhlbGxvXFwhd29ybGQoJHxcXHMpLzogSW52YWxpZCBlc2NhcGVcbiAgICAvLyBOT1RFOiA6IGlzIG5vdCBlc2NhcGVkLCBhcyBkb2luZyBzbyBnaXZlcyBlcnJvcjpcbiAgICAvLyAgICAgICAgIEludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvKF58XFxzKWhlbGxvXFw6d29ybGQoJHxcXHMpLzogSW52YWxpZCBlc2NhcGVcbiAgICAvL1xuICAgIC8vIEV4cGxhbmF0aW9uIGZyb20gQEFubmFLb3JuZmVsZFNpbXBzb24gaW46XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzbTcvb2JzaWRpYW4tdGFza3MvcHVsbC8xOCNpc3N1ZWNvbW1lbnQtMTE5NjExNTQwN1xuICAgIC8vIEZyb20gd2hhdCBJIGNhbiB0ZWxsLCB0aGUgdGhyZWUgbWlzc2luZyBjaGFyYWN0ZXJzIGZyb20gdGhlIG9yaWdpbmFsIHJlZ2V4IC0gOiAhID1cbiAgICAvLyBhcmUgYWxsIG9ubHkgY29uc2lkZXJlZCB0byBoYXZlIHNwZWNpYWwgbWVhbmluZ3MgaWYgdGhleSBkaXJlY3RseSBmb2xsb3dcbiAgICAvLyBhID8gKGFsbCAzKSBvciBhID88ICghIGFuZCA9KS5cbiAgICAvLyBTbyB0aGVvcmV0aWNhbGx5IGlmIHRoZSA/IGFyZSBhbGwgZXNjYXBlZCwgdGhvc2UgdGhyZWUgY2hhcmFjdGVycyBkbyBub3QgaGF2ZSB0byBiZS5cbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9eJHt9KCl8W1xcXS9cXFxcXSkvZywgJ1xcXFwkMScpO1xufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuXG4vKipcbiAqIEEgbmFtaW5nIGZ1bmN0aW9uLCB0aGF0IHRha2VzIGEgVGFzayBvYmplY3QgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ3JvdXAgcHJvcGVydHkgbmFtZVxuICovXG5leHBvcnQgdHlwZSBHcm91cGVyRnVuY3Rpb24gPSAodGFzazogVGFzaykgPT4gc3RyaW5nW107XG5cbmV4cG9ydCB0eXBlIEdyb3VwaW5nUHJvcGVydHkgPVxuICAgIHwgJ2JhY2tsaW5rJ1xuICAgIHwgJ2RvbmUnXG4gICAgfCAnZHVlJ1xuICAgIHwgJ2ZpbGVuYW1lJ1xuICAgIHwgJ2ZvbGRlcidcbiAgICB8ICdoYXBwZW5zJ1xuICAgIHwgJ2hlYWRpbmcnXG4gICAgfCAncGF0aCdcbiAgICB8ICdwcmlvcml0eSdcbiAgICB8ICdyZWN1cnJlbmNlJ1xuICAgIHwgJ3JlY3VycmluZydcbiAgICB8ICdyb290J1xuICAgIHwgJ3NjaGVkdWxlZCdcbiAgICB8ICdzdGFydCdcbiAgICB8ICdzdGF0dXMnXG4gICAgfCAndGFncyc7XG5cbmV4cG9ydCBjbGFzcyBHcm91cGVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IHN0cmluZztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZ3JvdXBlcjogR3JvdXBlckZ1bmN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJvcGVydHk6IHN0cmluZywgZ3JvdXBlcjogR3JvdXBlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5ncm91cGVyID0gZ3JvdXBlcjtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU29ydGVyIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgKiBhcyBSZWdFeHBUb29scyBmcm9tICcuLi8uLi9saWIvUmVnRXhwVG9vbHMnO1xuaW1wb3J0IHsgR3JvdXBlciB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZWFjaCB0eXBlIG9mIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZGVyaXZlZCBjbGFzcyBTdGFydERhdGVGaWVsZCBpbXBsZW1lbnRzIHRoZSBwYXJzaW5nXG4gKiBvZiAnc3RhcnRzJyBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGhlIG5hbWUgJ0ZpZWxkJyBtYXkgc2VlbSBjb25mdXNpbmcsIGFzIGl0IG1pZ2h0IGN1cnJlbnRseSBiZVxuICogZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgd29yZCAnRmlsdGVyJyBpbiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBDdXJyZW50IHRoaW5raW5nIGlzIHRoYXQgaXQgbWF5IHdlbGwgZXZvbHZlIGxhdGVyIHRvIGFsc28gaW1wbGVtZW50XG4gKiB0aGUgcHJlc2VuY2UgYW5kIGFic2VuY2Ugc2VhcmNoZXMgYXMgd2VsbFxuICogKHN1Y2ggJ25vIHN0YXJ0IGRhdGUnIGFuZCAnaGFzIHN0YXJ0IGRhdGUnKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZpZWxkIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNsYXNzIGNhbiBwYXJzZSB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNoZWNrcyB3aGV0aGVyIHRoZSBsaW5lIG1hdGNoZXNcbiAgICAgKiB0aGlzLmZpbHRlclJlZ0V4cCgpLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSBgYGB0YXNrc2BgYCBibG9jay5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIEZpbHRlciBmdW5jdGlvbiBvciBhbiBlcnJvciBzdHJpbmcsXG4gICAgICogd2hpY2ggYXJlIGJvdGggd3JhcHBlZCBpbiBhIEZpbHRlck9yRXJyb3JNZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlO1xuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgZ2l2ZW4gbGluZSBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyP1xuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBBIFJlZ0V4cCByZWd1bGFyIGV4cHJlc3Npb24sIHRoYXQgc3BlY2lmaWVzIG9uZSBxdWVyeSBpbnN0cnVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgT3IgbnVsbCwgaWYgdGhlIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgcmVnZXhwLWJhc2VkIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgdGFza3MgY29kZSBibG9jayBxdWVyeS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBsaW5lTWF0Y2hlc0ZpbHRlcihmaWx0ZXI6IFJlZ0V4cCB8IG51bGwsIGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLnRlc3QobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1hdGNoIGZvciB0aGUgZ2l2ZW4gZmlsdGVyLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IG1hdGNoXG4gICAgICogQHBhcmFtIGZpbHRlclJlZ0V4cCAtIEEgUmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhhdCBzcGVjaWZpZXMgb25lIHF1ZXJ5IGluc3RydWN0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBPciBudWxsLCBpZiB0aGUgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCByZWdleHAtYmFzZWQgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrIHF1ZXJ5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldE1hdGNoKGZpbHRlclJlZ0V4cDogUmVnRXhwIHwgbnVsbCwgbGluZTogc3RyaW5nKTogUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwge1xuICAgICAgICBpZiAoZmlsdGVyUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5tYXRjaChmaWx0ZXJSZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGZpbHRlcmluZyBUYXNrcyBieSBpbnNwZWN0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLlxuICAgICAqIE9yIG51bGwsIGlmIHRoaXMgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHJlZ2V4LWJhc2VkIGluc3RydWN0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhpcyBmaWVsZCwgdG8gYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBUaGlzIHVzdWFsbHkgbWF0Y2hlcyB0aGUgaW5zdHJ1Y3Rpb24gbmFtZSwgYnV0IGRvZXMgbm90IGFsd2F5c1xuICAgICAqIChzZWUgc3RhcnQgYW5kIHN0YXJ0cykuXG4gICAgICpcbiAgICAgKiBBbHNvLCBzb21lIGZpZWxkcyBoYXZlIG1vcmUgdGhhbiBvbmUgbmFtZSwgc2VwYXJhdGVkIGJ5ICcvJy5cbiAgICAgKiBTZWUge0BsaW5rIFRhZ3NGaWVsZH0sIGZvciBleGFtcGxlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBmaWVsZE5hbWUoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lXG4gICAgICogQHNlZSBmaWVsZE5hbWVTaW5ndWxhckVzY2FwZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLCBlc2NhcGVkIGZvciB1c2UgaW4gcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGZvciBmaWVsZCBuYW1lcyB0aGF0IGNvbnRhaW4gYC5gIGluLCBmb3IgZXhhbXBsZS5cbiAgICAgKiBAcHVibGljXG4gICAgICpcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwVG9vbHMuZXNjYXBlUmVnRXhwKHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBjb2RlIGZvciB0aGlzIGZpZWxkIGltcGxlbWVudHMgc29ydGluZyBvZiB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIG92ZXJyaWRpbmcgdGhpcyB0byByZXR1cm4gdHJ1ZSwgaW4gb3JkZXIgdG8gZW5hYmxlIHNvcnRpbmcsXG4gICAgICogdGhlIG1ldGhvZCB7QGxpbmsgY29tcGFyYXRvcn0gbXVzdCBhbHNvIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgJ3NvcnQgYnknIGxpbmUgYW5kIHJldHVybiBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgbnVsbCBsaW5lIGRvZXMgbm90IG1hdGNoIHRoaXMgZmllbGQgb3IgaXMgaW52YWxpZCxcbiAgICAgKiBvciB0aGlzIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgc29ydGluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyc2VTb3J0TGluZShsaW5lOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzU29ydGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jYW5DcmVhdGVTb3J0ZXJGb3JMaW5lKGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvcnRlckZyb21MaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2xhc3MgY2FuIHBhcnNlIHRoZSBnaXZlbiAnc29ydCBieScgaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNoZWNrcyB3aGV0aGVyIHRoZSBjbGFzcyBkb2VzIHN1cHBvcnQgc29ydGluZyxcbiAgICAgKiBhbmQgd2hldGhlciB0aGUgbGluZSBtYXRjaGVzIHRoaXMuc29ydGVyUmVnRXhwKCkuXG4gICAgICogQHBhcmFtIGxpbmUgLSBBIGxpbmUgZnJvbSBhIGBgYHRhc2tzYGBgIGJsb2NrLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlU29ydGVyRnJvbUxpbmV9XG4gICAgICovXG4gICAgcHVibGljIGNhbkNyZWF0ZVNvcnRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1NvcnRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHRoaXMuc29ydGVyUmVnRXhwKCksIGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBvciBudWxsLlxuICAgICAqXG4gICAgICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdvcmtzIGZvciBhbGwgZmllbGRzIHRoYXQgc3VwcG9ydFxuICAgICAqIHRoZSBkZWZhdWx0IHNvcnRpbmcgcGF0dGVybiBvZiBgc29ydCBieSA8ZmllbGROYW1lPiAocmV2ZXJzZSk/YC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ3NvcnQgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgJ3NvcnQgYnknIGxpbmUgZnJvbSBhIGBgYHRhc2tzYGBgIGJsb2NrLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY2FuQ3JlYXRlU29ydGVyRm9yTGluZX1cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlU29ydGVyRnJvbUxpbmUobGluZTogc3RyaW5nKTogU29ydGVyIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1NvcnRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuc29ydGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9ICEhbWF0Y2hbMV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvcnRlcihyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIHNvcnRpbmcgVGFza3MgYnkgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIFRocm93cyBpZiB0aGlzIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgc29ydGluZy5cbiAgICAgKlxuICAgICAqIGBtYXRjaFsxXWAgd2lsbCBiZSBlaXRoZXIgYHJldmVyc2VgIG9yIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ3NvcnQgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNvcnRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNTb3J0aW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBzb3J0ZXJSZWdFeHAoKSB1bmltcGxlbWVudGVkIGZvciAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBec29ydCBieSAke3RoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCl9KCByZXZlcnNlKT9gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0byBjb21wYXJlIHR3byBUYXNrIG9iamVjdHMsIGZvciB1c2UgaW4gc29ydGluZyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIHN1cHBvcnRzU29ydGluZ30gZm9yIHdoYXQgdG8gZG8sIHRvIGVuYWJsZSBzdXBwb3J0IG9mIHNvcnRpbmcgaW4gYVxuICAgICAqIHBhcnRpY3VsYXIge0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGNvbXBhcmF0b3IoKSB1bmltcGxlbWVudGVkIGZvciAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgU29ydGVyfSBvYmplY3QgZm9yIHNvcnRpbmcgdGFza3MgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLlxuICAgICAqIEBwYXJhbSByZXZlcnNlIC0gZmFsc2UgZm9yIG5vcm1hbCBzb3J0IG9yZGVyLCB0cnVlIGZvciByZXZlcnNlIHNvcnQgb3JkZXIuXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZVNvcnRlcihyZXZlcnNlOiBib29sZWFuKTogU29ydGVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZXIodGhpcy5maWVsZE5hbWVTaW5ndWxhcigpLCB0aGlzLmNvbXBhcmF0b3IoKSwgcmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIFNvcnRlcn0gb2JqZWN0IGZvciBzb3J0aW5nIHRhc2tzIGJ5IHRoaXMgZmllbGQncyB2YWx1ZSxcbiAgICAgKiBpbiB0aGUgc3RhbmRhcmQvbm9ybWFsIHNvcnQgb3JkZXIgZm9yIHRoaXMgZmllbGQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGVSZXZlcnNlU29ydGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVOb3JtYWxTb3J0ZXIoKTogU29ydGVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ydGVyKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgU29ydGVyfSBvYmplY3QgZm9yIHNvcnRpbmcgdGFza3MgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLFxuICAgICAqIGluIHRoZSByZXZlcnNlIG9mIHRoZSBzdGFuZGFyZC9ub3JtYWwgc29ydCBvcmRlciBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZU5vcm1hbFNvcnRlcn1cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlUmV2ZXJzZVNvcnRlcigpOiBTb3J0ZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb3J0ZXIodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHcm91cGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciB0aGUgY29kZSBmb3IgdGhpcyBmaWVsZCBpbXBsZW1lbnRzIGdyb3VwaW5nIG9mIHRhc2tzLlxuICAgICAqXG4gICAgICogSWYgb3ZlcnJpZGluZyB0aGlzIHRvIHJldHVybiB0cnVlLCBpbiBvcmRlciB0byBlbmFibGUgZ3JvdXBpbmcsXG4gICAgICogdGhlIG1ldGhvZCB7QGxpbmsgZ3JvdXBlcn0gbXVzdCBhbHNvIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0byBnZXQgYSBsaXN0IG9mIGEgdGFzaydzIGdyb3VwIG5hbWVzLCBmb3IgdXNlIGluIGdyb3VwaW5nIGJ5IHRoaXMgZmllbGQncyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgc3VwcG9ydHNHcm91cGluZ30gZm9yIHdoYXQgdG8gZG8sIHRvIGVuYWJsZSBzdXBwb3J0IG9mIGdyb3VwaW5nIGluIGFcbiAgICAgKiBwYXJ0aWN1bGFyIHtAbGluayBGaWVsZH0gaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGdyb3VwZXIoKSB1bmltcGxlbWVudGVkIGZvciAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0IGZvciBncm91cGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUuXG4gICAgICpcbiAgICAgKiBGb3Igbm93LCBwYXJzaW5nIG9mIGBncm91cCBieWAgbGluZXMgaXMgY3VycmVudGx5IGRvbmUgaW4ge0BsaW5rIEZpbHRlclBhcnNlci5wYXJzZUdyb3VwZXIoKX0uXG4gICAgICogTGF0ZXIsIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBtb3ZlZCB0byB0aGUge0BsaW5rIEZpZWxkfSBjbGFzc2VzLlxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVHcm91cGVyKCk6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIodGhpcy5maWVsZE5hbWVTaW5ndWxhcigpLCB0aGlzLmdyb3VwZXIoKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuXG4vKipcbiAqIEEgZmlsdGVyaW5nIGZ1bmN0aW9uLCB0aGF0IHRha2VzIGEgVGFzayBvYmplY3QgYW5kIHJldHVybnNcbiAqIHdoZXRoZXIgaXQgbWF0Y2hlcyBhIHBhcnRpY3VsYXIgZmlsdGVyaW5nIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgdHlwZSBGaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiBib29sZWFuO1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcGFyc2VkIGZpbHRlcmluZyBpbnN0cnVjdGlvbiBmcm9tIGEgdGFza3MgY29kZSBibG9jay5cbiAqXG4gKiBDdXJyZW50bHkgaXQgcHJvdmlkZXMgYWNjZXNzIHRvOlxuICpcbiAqIC0gVGhlIG9yaWdpbmFsIHtAbGluayBpbnN0cnVjdGlvbn1cbiAqIC0gVGhlIHtAbGluayBmaWx0ZXJGdW5jdGlvbn0gLSBhIHtAbGluayBGaWx0ZXJGdW5jdGlvbn0gd2hpY2ggdGVzdHMgd2hldGhlciBhIHRhc2sgbWF0Y2hlcyB0aGUgZmlsdGVyXG4gKlxuICogTGF0ZXIsIHRoZSBwbGFuIGlzIHRvIGFkZCBhIGh1bWFuLXJlYWRhYmxlIGV4cGxhbmF0aW9uIG9mIHRoZSBmaWx0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXIge1xuICAgIHJlYWRvbmx5IGluc3RydWN0aW9uOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZXhwbGFuYXRpb246IEV4cGxhbmF0aW9uO1xuICAgIHB1YmxpYyBmaWx0ZXJGdW5jdGlvbjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgZmlsdGVyRnVuY3Rpb246IEZpbHRlckZ1bmN0aW9uLCBleHBsYW5hdGlvbjogRXhwbGFuYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gICAgICAgIHRoaXMuZmlsdGVyRnVuY3Rpb24gPSBmaWx0ZXJGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXhwbGFpbkZpbHRlckluZGVudGVkKGluZGVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gdGhpcy5leHBsYW5hdGlvbjtcbiAgICAgICAgY29uc3QgdW5pbmRlbnRlZEV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb24uYXNTdHJpbmcoKTtcbiAgICAgICAgaWYgKHVuaW5kZW50ZWRFeHBsYW5hdGlvbiA9PT0gdGhpcy5pbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGAke2luZGVudH0ke3RoaXMuaW5zdHJ1Y3Rpb259XFxuYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtpbmRlbnR9JHt0aGlzLmluc3RydWN0aW9ufSA9PlxcbiR7ZXhwbGFuYXRpb24uYXNTdHJpbmcoJyAgJyl9XFxuYDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHdoaWNoIHN0b3JlcyBvbmUgb2Y6XG4gKiAtIFRoZSBvcmlnaW5hbCBpbnN0cnVjdGlvbiBzdHJpbmcgLSBhIGxpbmUgZnJvbSBhIHRhc2tzIGNvZGUgYmxvY2tcbiAqIC0gQW4gb3B0aW9uYWwge0BsaW5rIEZpbHRlcn1cbiAqIC0gQW4gb3B0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICpcbiAqIFRoaXMgaXMgcmVhbGx5IGN1cnJlbnRseSBhIGNvbnZlbmllbmNlIGZvciByZXR1cm5pbmcgZGF0YSBmcm9tXG4gKiB7QGxpbmsgRmllbGQuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UoKX0gYW5kIGRlcml2ZWQgY2xhc3Nlcy5cbiAqXG4gKiBCeSB0aGUgdGltZSB0aGUgY29kZSBoYXMgZmluaXNoZWQgd2l0aCBwYXJzaW5nIHRoZSBsaW5lLCB0eXBpY2FsbHkgdGhlXG4gKiBjb250YWluZWQge0BsaW5rIEZpbHRlcn0gd2lsbCBiZSBzYXZlZCwgZm9yIGxhdGVyIHVzZSBpbiBzZWFyY2hpbmcgZm9yIFRhc2tzXG4gKiB0aGF0IG1hdGNoIHRoZSB1c2VyJ3MgZmlsdGVyIGluc3RydWN0aW9uLlxuICpcbiAqIExhdGVyLCBpdCBtYXkgZ2FpbiBoZWxwZXIgZnVuY3Rpb25zIGZvciBjb25zdHJ1Y3RpbmcgcGFyc2VyIGVycm9yIG1lc3NhZ2VzLFxuICogYXMgY3VycmVudGx5IHRoZXNlIGFyZSBjcmVhdGVkIGJ5IHNvbWUgcmF0aGVyIHJlcGV0aXRpb3VzIGNvZGUsIGFuZCBhbHNvXG4gKiB0aGVyZSBpcyBzY29wZSBmb3IgbWFraW5nIHRoZXNlIG1lc3NhZ2VzIG1vcmUgaW5mb3JtYXRpdmUgKGluY2x1ZGluZyB0aGVcbiAqIHByb2JsZW0gbGluZSwgYW5kIHBlcmhhcHMgbGlzdGluZyBhbGxvd2VkIG9wdGlvbnMpLlxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgIHJlYWRvbmx5IGluc3RydWN0aW9uOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfZmlsdGVyOiBGaWx0ZXIgfCB1bmRlZmluZWQ7XG4gICAgZXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKGluc3RydWN0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlsdGVyKCk6IEZpbHRlciB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXI7XG4gICAgfVxuXG4gICAgc2V0IGZpbHRlcih2YWx1ZTogRmlsdGVyIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBmaWx0ZXJGdW5jdGlvbigpOiBGaWx0ZXJGdW5jdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXIuZmlsdGVyRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgYSBtZWFuaW5nZnVsIHtAbGluayBFeHBsYW5hdGlvbn0gdG8gYmUgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gYSB7QGxpbmsgRmlsdGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUZpbHRlcihmaWx0ZXI6IEZpbHRlcik6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZpbHRlck9yRXJyb3JNZXNzYWdlKGZpbHRlci5pbnN0cnVjdGlvbik7XG4gICAgICAgIHJlc3VsdC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tRXJyb3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgZXJyb3JNZXNzYWdlOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZShpbnN0cnVjdGlvbik7XG4gICAgICAgIHJlc3VsdC5lcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB7IEZpbHRlciwgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgc2luZ2xlIGluc3RydWN0aW9uIGZvciBmaWx0ZXJpbmcgdGFza3MsIGFuZCBpdHMgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUuXG4gKlxuICogVGhpcyBpcyByZWFsbHkgYSBoZWxwZXIgdG8gc2ltcGxpZnkgdGhlIGltcGxlbWVudGF0aW9uIG9mIGluZGl2aWR1YWwgZmlsdGVyXG4gKiBpbnN0cnVjdGlvbnMsIGhpZGluZyBhd2F5IHRoZSBkZXRhaWxzIG9mIHBhcnNpbmcgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbiBsaW5lcy5cbiAqXG4gKiBUaGlzIHdpbGwgdXN1YWxseSBiZSBhY2Nlc3NlZCB2aWEge0BsaW5rIEZpbHRlckluc3RydWN0aW9ucy5hZGR9XG4gKlxuICogQHNlZSBGaWx0ZXJJbnN0cnVjdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlckluc3RydWN0aW9uIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnN0cnVjdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpbHRlcjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvcjpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gLSBGdWxsIHRleHQgb2YgdGhlIGluc3RydWN0aW9uIGZvciB0aGUgZmlsdGVyOiBtdXN0IGJlIG1hdGNoZWQgZXhhY3RseVxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXI6IEZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGxpbmUgPT0gdGhpcy5faW5zdHJ1Y3Rpb247XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuXG4gICAgICAgIGlmIChsaW5lID09PSB0aGlzLl9pbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IG5ldyBGaWx0ZXIobGluZSwgdGhpcy5fZmlsdGVyLCBuZXcgRXhwbGFuYXRpb24obGluZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5lcnJvciA9IGBkbyBub3QgdW5kZXJzdGFuZCBmaWx0ZXI6ICR7bGluZX1gO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbiB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb24nO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgY29sbGVjdGlvbiBvZiBpbnN0cnVjdGlvbnMgZm9yIGZpbHRlcmluZyB0YXNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpbHRlcnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG4gKiAgICAgdGhpcy5fZmlsdGVycy5hZGQoJ2lzIHJlY3VycmluZycsICh0YXNrKSA9PiB0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpO1xuICpcbiAqIEBzZWUgRmlsdGVySW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlckluc3RydWN0aW9ucyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZmlsdGVyczogRmlsdGVySW5zdHJ1Y3Rpb25bXSA9IFtdO1xuXG4gICAgcHVibGljIGFkZChpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXI6IEZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaChuZXcgRmlsdGVySW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGZpbHRlcikpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGZpbHRlci5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgICAgIGlmICh4LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgcmVzdWx0LmVycm9yID0gYGRvIG5vdCB1bmRlcnN0YW5kIGZpbHRlcjogJHtsaW5lfWA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9ucyB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zJztcblxuLyoqXG4gKiBEYXRlRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0byBoZWxwIGltcGxlbWVudFxuICogYWxsIHRoZSBmaWx0ZXIgaW5zdHJ1Y3Rpb25zIHRoYXQgYWN0IG9uIGEgc2luZ2xlIHR5cGUgb2YgZGF0ZVxuICogdmFsdWUsIHN1Y2ggYXMgdGhlIGRvbmUgZGF0ZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGVGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbHRlckluc3RydWN0aW9uczogRmlsdGVySW5zdHJ1Y3Rpb25zO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zID0gbmV3IEZpbHRlckluc3RydWN0aW9ucygpO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYGhhcyAke3RoaXMuZmllbGROYW1lKCl9IGRhdGVgLCAodGFzazogVGFzaykgPT4gdGhpcy5kYXRlKHRhc2spICE9PSBudWxsKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuYWRkKGBubyAke3RoaXMuZmllbGROYW1lKCl9IGRhdGVgLCAodGFzazogVGFzaykgPT4gdGhpcy5kYXRlKHRhc2spID09PSBudWxsKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuYWRkKGAke3RoaXMuZmllbGROYW1lKCl9IGRhdGUgaXMgaW52YWxpZGAsICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgIT09IG51bGwgJiYgIWRhdGUuaXNWYWxpZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgZmlsdGVyUmVzdWx0ID0gdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHQuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmZpbHRlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgbGV0IGZpbHRlckZ1bmN0aW9uO1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckRhdGUgPSBEYXRlUGFyc2VyLnBhcnNlRGF0ZShtYXRjaFsyXSk7XG4gICAgICAgICAgICBpZiAoIWZpbHRlckRhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kICcgKyB0aGlzLmZpZWxkTmFtZSgpICsgJyBkYXRlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGF0aXZlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnVuY3Rpb24gPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZSh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlID8gZGF0ZS5pc0JlZm9yZShmaWx0ZXJEYXRlKSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUgPSAnICcgKyBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzFdID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGUodGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZSA/IGRhdGUuaXNBZnRlcihmaWx0ZXJEYXRlKSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUgPSAnICcgKyBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPyBkYXRlLmlzU2FtZShmaWx0ZXJEYXRlKSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUgPSAnIG9uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBEYXRlRmllbGQuZ2V0RXhwbGFuYXRpb25TdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmllbGROYW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGUsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gbmV3IEZpbHRlcihsaW5lLCBmaWx0ZXJGdW5jdGlvbiwgbmV3IEV4cGxhbmF0aW9uKGV4cGxhbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZmlsdGVyICgnICsgdGhpcy5maWVsZE5hbWUoKSArICcgZGF0ZSknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrJ3MgdmFsdWUgZm9yIHRoaXMgZGF0ZSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEBwYXJhbSB0YXNrIC0gYSBUYXNrIG9iamVjdFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHN0cmluZyB1c2VkIHRvIGV4cGxhaW4gYSBkYXRlLWJhc2VkIGZpbHRlclxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWUgLSBmb3IgZXhhbXBsZSwgJ2R1ZSdcbiAgICAgKiBAcGFyYW0gcmVsYXRpb25zaGlwUHJlZml4ZWRXaXRoU3BhY2UgLSBmb3IgZXhhbXBsZSAnIGJlZm9yZScgb3IgJydcbiAgICAgKiBAcGFyYW0gZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcgLSB3aGV0aGVyIHRoZSBzZWFyY2ggbWF0Y2hlcyB0YXNrcyB3aXRob3V0IHRoZSByZXF1ZXN0ZWQgZGF0ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBmaWx0ZXJEYXRlIC0gdGhlIGRhdGUgdXNlZCBpbiB0aGUgZmlsdGVyXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRFeHBsYW5hdGlvblN0cmluZyhcbiAgICAgICAgZmllbGROYW1lOiBzdHJpbmcsXG4gICAgICAgIHJlbGF0aW9uc2hpcFByZWZpeGVkV2l0aFNwYWNlOiBzdHJpbmcsXG4gICAgICAgIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nOiBib29sZWFuLFxuICAgICAgICBmaWx0ZXJEYXRlOiBtb21lbnQuTW9tZW50LFxuICAgICkge1xuICAgICAgICAvLyBFeGFtcGxlIG9mIGZvcm1hdHRlZCBkYXRlOiAnMjAyNC0wMS0wMiAoVHVlc2RheSAybmQgSmFudWFyeSAyMDI0KSdcbiAgICAgICAgY29uc3QgYWN0dWFsRGF0ZSA9IGZpbHRlckRhdGUuZm9ybWF0KCdZWVlZLU1NLUREIChkZGRkIERvIE1NTU0gWVlZWSknKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGAke2ZpZWxkTmFtZX0gZGF0ZSBpcyR7cmVsYXRpb25zaGlwUHJlZml4ZWRXaXRoU3BhY2V9ICR7YWN0dWFsRGF0ZX1gO1xuICAgICAgICBpZiAoZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgIE9SIG5vICR7ZmllbGROYW1lfSBkYXRlYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGEgdGFzayB0aGF0IGRvZXMgbm90IGhhdmUgdGhlIHBhcnRpY3VsYXIgZGF0ZSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbWF0Y2guIEZvciBleGFtcGxlLCAnc3RhcnRzJyBzZWFyY2hlcyBtYXRjaCBhbGwgdGFza3NcbiAgICAgKiB0aGF0IGhhdmUgbm8gc3RhcnQgZGF0ZSwgd2hpY2ggYmVoYXZlcyBkaWZmZXJlbnRseSBmcm9tICdkdWUnLCAnZG9uZScgYW5kXG4gICAgICogJ3NjaGVkdWxlZCcgc2VhcmNoZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpOiBib29sZWFuO1xuXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERhdGVGaWVsZC5jb21wYXJlQnlEYXRlKHRoaXMuZGF0ZShhKSwgdGhpcy5kYXRlKGIpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNvbXBhcmVCeURhdGUoYTogbW9tZW50Lk1vbWVudCB8IG51bGwsIGI6IG1vbWVudC5Nb21lbnQgfCBudWxsKTogLTEgfCAwIHwgMSB7XG4gICAgICAgIGlmIChhICE9PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGEuaXNWYWxpZCgpICYmICFiLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWEuaXNWYWxpZCgpICYmIGIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhLmlzQWZ0ZXIoYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5pc0JlZm9yZShiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBSUnVsZSB9IGZyb20gJ3JydWxlJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vUXVlcnkvRmlsdGVyL0RhdGVGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSZWN1cnJlbmNlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJydWxlOiBSUnVsZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhc2VPblRvZGF5OiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVmZXJlbmNlIGRhdGUgaXMgdXNlZCB0byBjYWxjdWxhdGUgZnV0dXJlIG9jY3VycmVuY2VzLlxuICAgICAqXG4gICAgICogRnV0dXJlIG9jY3VycmVuY2VzIHdpbGwgcmVjdXIgYmFzZWQgb24gdGhlIHJlZmVyZW5jZSBkYXRlLlxuICAgICAqIFRoZSByZWZlcmVuY2UgZGF0ZSBpcyB0aGUgZHVlIGRhdGUsIGlmIGl0IGlzIGdpdmVuLlxuICAgICAqIE90aGVyd2lzZSB0aGUgc2NoZWR1bGVkIGRhdGUsIGlmIGl0IGlzIGdpdmVuLiBBbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBSZWN1cnJlbmNlIG9mIGFsbCBkYXRlcyB3aWxsIGJlIGtlcHQgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSBkYXRlLlxuICAgICAqIEZvciBleGFtcGxlOiBpZiB0aGUgZHVlIGRhdGUgYW5kIHRoZSBzdGFydCBkYXRlIGFyZSBnaXZlbiwgdGhlIGR1ZSBkYXRlXG4gICAgICogaXMgdGhlIHJlZmVyZW5jZSBkYXRlLiBGdXR1cmUgb2NjdXJyZW5jZXMgd2lsbCBoYXZlIGEgc3RhcnQgZGF0ZSB3aXRoIHRoZVxuICAgICAqIHNhbWUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIGR1ZSBkYXRlIGFzIHRoZSBvcmlnaW5hbCB0YXNrLiBGb3IgZXhhbXBsZVxuICAgICAqIFwic3RhcnRzIG9uZSB3ZWVrIGJlZm9yZSBpdCBpcyBkdWVcIi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlZmVyZW5jZURhdGU6IE1vbWVudCB8IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIHJydWxlLFxuICAgICAgICBiYXNlT25Ub2RheSxcbiAgICAgICAgcmVmZXJlbmNlRGF0ZSxcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICBkdWVEYXRlLFxuICAgIH06IHtcbiAgICAgICAgcnJ1bGU6IFJSdWxlO1xuICAgICAgICBiYXNlT25Ub2RheTogYm9vbGVhbjtcbiAgICAgICAgcmVmZXJlbmNlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5ycnVsZSA9IHJydWxlO1xuICAgICAgICB0aGlzLmJhc2VPblRvZGF5ID0gYmFzZU9uVG9kYXk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGF0ZSA9IHJlZmVyZW5jZURhdGU7XG4gICAgICAgIHRoaXMuc3RhcnREYXRlID0gc3RhcnREYXRlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZERhdGUgPSBzY2hlZHVsZWREYXRlO1xuICAgICAgICB0aGlzLmR1ZURhdGUgPSBkdWVEYXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbVRleHQoe1xuICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQsXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgZHVlRGF0ZSxcbiAgICB9OiB7XG4gICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogc3RyaW5nO1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IFJlY3VycmVuY2UgfCBudWxsIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVjdXJyZW5jZVJ1bGVUZXh0Lm1hdGNoKC9eKFthLXpBLVowLTksICFdKz8pKCB3aGVuIGRvbmUpPyQvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc29sYXRlZFJ1bGVUZXh0ID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgYmFzZU9uVG9kYXkgPSBtYXRjaFsyXSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gUlJ1bGUucGFyc2VUZXh0KGlzb2xhdGVkUnVsZVRleHQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSByZWZlcmVuY2UgZGF0ZSBmb3IgcmVjdXJyZW5jZSBiYXNlZCBvbiBpbXBvcnRhbmNlLlxuICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIGR1ZSBkYXRlIGhhcyB0aGUgaGlnaGVzdCBwcmlvcml0eS5cbiAgICAgICAgICAgICAgICBsZXQgcmVmZXJlbmNlRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIG1vbWVudCBvYmplY3RzLlxuICAgICAgICAgICAgICAgIGlmIChkdWVEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZURhdGUgPSB3aW5kb3cubW9tZW50KGR1ZURhdGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChzY2hlZHVsZWREYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYmFzZU9uVG9kYXkgJiYgcmVmZXJlbmNlRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmR0c3RhcnQgPSB3aW5kb3cubW9tZW50KHJlZmVyZW5jZURhdGUpLnN0YXJ0T2YoJ2RheScpLnV0Yyh0cnVlKS50b0RhdGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmR0c3RhcnQgPSB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5JykudXRjKHRydWUpLnRvRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJydWxlID0gbmV3IFJSdWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdXJyZW5jZSh7XG4gICAgICAgICAgICAgICAgICAgIHJydWxlLFxuICAgICAgICAgICAgICAgICAgICBiYXNlT25Ub2RheSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ291bGQgbm90IHJlYWQgcmVjdXJyZW5jZSBydWxlLiBVc2VyIHBvc3NpYmx5IG5vdCBkb25lIHR5cGluZy5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1RleHQoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLnJydWxlLnRvVGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgdGV4dCArPSAnIHdoZW4gZG9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlcyBvZiB0aGUgbmV4dCBvY2N1cnJlbmNlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0KCk6IHtcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0gfCBudWxsIHtcbiAgICAgICAgbGV0IG5leHQ6IERhdGU7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5KSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV4dCBvY2N1cnJlbmNlIHNob3VsZCBoYXBwZW4gYmFzZWQgb2ZmIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICAgICAgICBjb25zdCB0b2RheSA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVCYXNlZE9uVG9kYXkgPSBuZXcgUlJ1bGUoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucnJ1bGUub3JpZ09wdGlvbnMsXG4gICAgICAgICAgICAgICAgZHRzdGFydDogdG9kYXkuc3RhcnRPZignZGF5JykudXRjKHRydWUpLnRvRGF0ZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5uZXh0QWZ0ZXIodG9kYXkuZW5kT2YoJ2RheScpLCBydWxlQmFzZWRPblRvZGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9jY3VycmVuY2Ugc2hvdWxkIGhhcHBlbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBkYXRlIGlmIHBvc3NpYmxlLiBPdGhlcndpc2UsIGJhc2UgaXQgb24gdG9kYXkgaWYgd2UgZG8gbm90IGhhdmUgYVxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGRhdGUuXG4gICAgICAgICAgICBjb25zdCBhZnRlciA9IHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBkYXRlIGNhbiBiZSBgdW5kZWZpbmVkYCB0byBtZWFuIFwidG9kYXlcIi5cbiAgICAgICAgICAgICAgICAvLyBNb21lbnQgb25seSBhY2NlcHRzIGB1bmRlZmluZWRgLCBub3QgYG51bGxgLlxuICAgICAgICAgICAgICAgIC5tb21lbnQodGhpcy5yZWZlcmVuY2VEYXRlID8/IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAuZW5kT2YoJ2RheScpO1xuXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5uZXh0QWZ0ZXIoYWZ0ZXIsIHRoaXMucnJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGRhdGUgYW5kXG4gICAgICAgICAgICAvLyBzdGFydC9zY2hlZHVsZWQvZHVlLlxuICAgICAgICAgICAgbGV0IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZHVlRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgaWYgYSByZWZlcmVuY2UgZGF0ZSBpcyBnaXZlbi4gQSByZWZlcmVuY2UgZGF0ZSB3aWxsIGV4aXN0IGlmIGF0XG4gICAgICAgICAgICAvLyBsZWFzdCBvbmUgb2YgdGhlIG90aGVyIGRhdGVzIGlzIHNldC5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbih0aGlzLnN0YXJ0RGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25pbmcgc28gdGhhdCBvcmlnaW5hbCB3b24ndCBiZSBtYW5pcHVsYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlID0gd2luZG93Lm1vbWVudChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgZGF5cyB0byBoYW5kbGUgY3Jvc3MgZGF5bGlnaHQtc2F2aW5ncy10aW1lIHJlY3VycmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKE1hdGgucm91bmQob3JpZ2luYWxEaWZmZXJlbmNlLmFzRGF5cygpKSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbERpZmZlcmVuY2UgPSB3aW5kb3cubW9tZW50LmR1cmF0aW9uKHRoaXMuc2NoZWR1bGVkRGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25pbmcgc28gdGhhdCBvcmlnaW5hbCB3b24ndCBiZSBtYW5pcHVsYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IHdpbmRvdy5tb21lbnQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIGRheXMgdG8gaGFuZGxlIGNyb3NzIGRheWxpZ2h0LXNhdmluZ3MtdGltZSByZWN1cnJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZS5hZGQoTWF0aC5yb3VuZChvcmlnaW5hbERpZmZlcmVuY2UuYXNEYXlzKCkpLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kdWVEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGlmZmVyZW5jZSA9IHdpbmRvdy5tb21lbnQuZHVyYXRpb24odGhpcy5kdWVEYXRlLmRpZmYodGhpcy5yZWZlcmVuY2VEYXRlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBzbyB0aGF0IG9yaWdpbmFsIHdvbid0IGJlIG1hbmlwdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlID0gd2luZG93Lm1vbWVudChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgZGF5cyB0byBoYW5kbGUgY3Jvc3MgZGF5bGlnaHQtc2F2aW5ncy10aW1lIHJlY3VycmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlLmFkZChNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGlkZW50aWNhbFRvKG90aGVyOiBSZWN1cnJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5ICE9PSBvdGhlci5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBpZiAoRGF0ZUZpZWxkLmNvbXBhcmVCeURhdGUodGhpcy5zdGFydERhdGUsIG90aGVyLnN0YXJ0RGF0ZSkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGF0ZUZpZWxkLmNvbXBhcmVCeURhdGUodGhpcy5zY2hlZHVsZWREYXRlLCBvdGhlci5zY2hlZHVsZWREYXRlKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEYXRlRmllbGQuY29tcGFyZUJ5RGF0ZSh0aGlzLmR1ZURhdGUsIG90aGVyLmR1ZURhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b1RleHQoKSA9PT0gb3RoZXIudG9UZXh0KCk7IC8vIHRoaXMgYWxzbyBjaGVja3MgYmFzZU9uVG9kYXlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXIgcmV0dXJucyB0aGUgbmV4dCBvY2N1cnJlbmNlJ3MgZGF0ZSBhZnRlciBgYWZ0ZXJgLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcnJ1bGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29tbW9uIGNhc2UgaXMgdGhhdCBgcnJ1bGUuYWZ0ZXJgIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhbmQgaXRcbiAgICAgKiBjYW4gYmUgdXNlZCBhcyBpcy5cbiAgICAgKlxuICAgICAqIEluIHRoZSBzcGVjaWFsIGNhc2VzIG9mIG1vbnRobHkgYW5kIHllYXJseSByZWN1cnJlbmNlcywgdGhlcmUgZXhpc3RzIGFuXG4gICAgICogZWRnZSBjYXNlIHdoZXJlIGFuIG9jY3VycmVuY2UgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZiBtb250aHMgb3IgeWVhcnNcbiAgICAgKiBpcyBub3QgcG9zc2libGUuIEZvciBleGFtcGxlOiBBIHRhc2sgaXMgZHVlIG9uIDIwMjItMDEtMzEgYW5kIGhhcyBhXG4gICAgICogcmVjdXJyZW5jZSBvZiBgZXZlcnkgbW9udGhgLiBXaGVuIG1hcmtpbmcgdGhlIHRhc2sgYXMgZG9uZSwgdGhlIG5leHRcbiAgICAgKiBvY2N1cnJlbmNlIHdpbGwgaGFwcGVuIG9uIDIwMjItMDMtMzEuIFRoZSByZWFzb24gYmVpbmcgdGhhdCBGZWJydWFyeVxuICAgICAqIGRvZXMgbm90IGhhdmUgMzEgZGF5cywgeWV0IFJSdWxlIHNldHMgYGJ5bW9udGhkYXlgIHRvIGAzMWAgZm9yIGxhY2sgb2ZcbiAgICAgKiBoYXZpbmcgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUuXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBmaXggdGhpcywgYGFmdGVyYCB3aWxsIG1vdmUgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LiBFYWNoXG4gICAgICogZGF5LCB0aGUgbmV4dCBvY2N1cnJlbmNlIGlzIGNoZWNrZWQgdG8gYmUgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZlxuICAgICAqIG1vbnRocyBvciB5ZWFycy4gQnkgbW92aW5nIGBhZnRlcmAgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LCBpdCB3aWxsXG4gICAgICogZXZlbnR1YWxseSBjYWxjdWxhdGUgdGhlIG5leHQgb2NjdXJyZW5jZSBiYXNlZCBvbiBgMjAyMi0wMS0yOGAsIGVuZGluZyB1cFxuICAgICAqIGluIEZlYnJ1YXJ5IGFzIHRoZSB1c2VyIHdvdWxkIGV4cGVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5leHRBZnRlcihhZnRlcjogTW9tZW50LCBycnVsZTogUlJ1bGUpOiBEYXRlIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIHRpbWV6b25lLCBhcyBycnVsZSBkb2VzIG5vdCByZWdhcmQgdGltZXpvbmVzIGFuZCBhbHdheXNcbiAgICAgICAgLy8gY2FsY3VsYXRlcyBpbiBVVEMuXG4gICAgICAgIC8vIFRoZSB0aW1lem9uZSBpcyBhZGRlZCBhZ2FpbiBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXh0IGRhdGUuXG4gICAgICAgIGFmdGVyLnV0Yyh0cnVlKTtcbiAgICAgICAgbGV0IG5leHQgPSB3aW5kb3cubW9tZW50KHJydWxlLmFmdGVyKGFmdGVyLnRvRGF0ZSgpKSk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG1vbnRobHkgcmVjdXJyZW5jZSwgdHJlYXQgaXQgc3BlY2lhbC5cbiAgICAgICAgY29uc3QgYXNUZXh0ID0gdGhpcy50b1RleHQoKTtcbiAgICAgICAgY29uc3QgbW9udGhNYXRjaCA9IGFzVGV4dC5tYXRjaCgvZXZlcnkoIFxcZCspPyBtb250aChzKT8oLiopPy8pO1xuICAgICAgICBpZiAobW9udGhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gLi4uIHVubGVzcyB0aGUgcnVsZSBmaXhlcyB0aGUgZGF0ZSwgc3VjaCBhcyAnZXZlcnkgbW9udGggb24gdGhlIDMxc3QnXG4gICAgICAgICAgICBpZiAoIWFzVGV4dC5pbmNsdWRlcygnIG9uICcpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UubmV4dEFmdGVyTW9udGhzKGFmdGVyLCBuZXh0LCBycnVsZSwgbW9udGhNYXRjaFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgeWVhcmx5IHJlY3VycmVuY2UsIHRyZWF0IGl0IHNwZWNpYWwuXG4gICAgICAgIGNvbnN0IHllYXJNYXRjaCA9IGFzVGV4dC5tYXRjaCgvZXZlcnkoIFxcZCspPyB5ZWFyKHMpPyguKik/Lyk7XG4gICAgICAgIGlmICh5ZWFyTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5leHQgPSBSZWN1cnJlbmNlLm5leHRBZnRlclllYXJzKGFmdGVyLCBuZXh0LCBycnVsZSwgeWVhck1hdGNoWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlcmUgd2UgYWRkIHRoZSB0aW1lem9uZSBhZ2FpbiB0aGF0IHdlIHJlbW92ZWQgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGlzIG1ldGhvZC5cbiAgICAgICAgcmV0dXJuIFJlY3VycmVuY2UuYWRkVGltZXpvbmUobmV4dCkudG9EYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbmV4dEFmdGVyTW9udGhzIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhZnRlciBgc2tpcHBpbmdNb250aHNgIG1vbnRocy5cbiAgICAgKlxuICAgICAqIGBza2lwcGluZ01vbnRoc2AgZGVmYXVsdHMgdG8gYDFgIGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBuZXh0QWZ0ZXJNb250aHMoXG4gICAgICAgIGFmdGVyOiBNb21lbnQsXG4gICAgICAgIG5leHQ6IE1vbWVudCxcbiAgICAgICAgcnJ1bGU6IFJSdWxlLFxuICAgICAgICBza2lwcGluZ01vbnRoczogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICk6IE1vbWVudCB7XG4gICAgICAgIC8vIFBhcnNlIGBza2lwcGluZ01vbnRoc2AsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgbGV0IHBhcnNlZFNraXBwaW5nTW9udGhzOiBOdW1iZXIgPSAxO1xuICAgICAgICBpZiAoc2tpcHBpbmdNb250aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyc2VkU2tpcHBpbmdNb250aHMgPSBOdW1iZXIucGFyc2VJbnQoc2tpcHBpbmdNb250aHMudHJpbSgpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGlsZSB3ZSBza2lwIHRoZSB3cm9uZyBudW1iZXIgb2YgbW9udGhzLCBtb3ZlIGBhZnRlcmAgb25lIGRheSBpbnRvIHRoZSBwYXN0LlxuICAgICAgICB3aGlsZSAoUmVjdXJyZW5jZS5pc1NraXBwaW5nVG9vTWFueU1vbnRocyhhZnRlciwgbmV4dCwgcGFyc2VkU2tpcHBpbmdNb250aHMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV4dCBsaW5lIGFsdGVycyBgYWZ0ZXJgIHRvIGJlIG9uZSBkYXkgZWFybGllci5cbiAgICAgICAgICAgIC8vIFRoZW4gcmV0dXJucyBgbmV4dGAgYmFzZWQgb24gdGhhdC5cbiAgICAgICAgICAgIG5leHQgPSBSZWN1cnJlbmNlLmZyb21PbmVEYXlFYXJsaWVyKGFmdGVyLCBycnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpc1NraXBwaW5nVG9vTWFueU1vbnRocyByZXR1cm5zIHRydWUgaWYgYG5leHRgIGlzIG1vcmUgdGhhbiBgc2tpcHBpbmdNb250aHNgIG1vbnRocyBhZnRlciBgYWZ0ZXJgLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGlzU2tpcHBpbmdUb29NYW55TW9udGhzKGFmdGVyOiBNb21lbnQsIG5leHQ6IE1vbWVudCwgc2tpcHBpbmdNb250aHM6IE51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZGlmZk1vbnRocyA9IG5leHQubW9udGgoKSAtIGFmdGVyLm1vbnRoKCk7XG5cbiAgICAgICAgLy8gTWF5YmUgc29tZSB5ZWFycyBoYXZlIHBhc3NlZD9cbiAgICAgICAgY29uc3QgZGlmZlllYXJzID0gbmV4dC55ZWFyKCkgLSBhZnRlci55ZWFyKCk7XG4gICAgICAgIGRpZmZNb250aHMgKz0gZGlmZlllYXJzICogMTI7XG5cbiAgICAgICAgcmV0dXJuIGRpZmZNb250aHMgPiBza2lwcGluZ01vbnRocztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXJZZWFycyBjYWxjdWxhdGVzIHRoZSBuZXh0IGRhdGUgYWZ0ZXIgYHNraXBwaW5nWWVhcnNgIHllYXJzLlxuICAgICAqXG4gICAgICogYHNraXBwaW5nWWVhcnNgIGRlZmF1bHRzIHRvIGAxYCBpZiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgbmV4dEFmdGVyWWVhcnMoXG4gICAgICAgIGFmdGVyOiBNb21lbnQsXG4gICAgICAgIG5leHQ6IE1vbWVudCxcbiAgICAgICAgcnJ1bGU6IFJSdWxlLFxuICAgICAgICBza2lwcGluZ1llYXJzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgKTogTW9tZW50IHtcbiAgICAgICAgLy8gUGFyc2UgYHNraXBwaW5nWWVhcnNgLCBpZiBpdCBleGlzdHMuXG4gICAgICAgIGxldCBwYXJzZWRTa2lwcGluZ1llYXJzOiBOdW1iZXIgPSAxO1xuICAgICAgICBpZiAoc2tpcHBpbmdZZWFycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJzZWRTa2lwcGluZ1llYXJzID0gTnVtYmVyLnBhcnNlSW50KHNraXBwaW5nWWVhcnMudHJpbSgpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGlsZSB3ZSBza2lwIHRoZSB3cm9uZyBudW1iZXIgb2YgeWVhcnMsIG1vdmUgYGFmdGVyYCBvbmUgZGF5IGludG8gdGhlIHBhc3QuXG4gICAgICAgIHdoaWxlIChSZWN1cnJlbmNlLmlzU2tpcHBpbmdUb29NYW55WWVhcnMoYWZ0ZXIsIG5leHQsIHBhcnNlZFNraXBwaW5nWWVhcnMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV4dCBsaW5lIGFsdGVycyBgYWZ0ZXJgIHRvIGJlIG9uZSBkYXkgZWFybGllci5cbiAgICAgICAgICAgIC8vIFRoZW4gcmV0dXJucyBgbmV4dGAgYmFzZWQgb24gdGhhdC5cbiAgICAgICAgICAgIG5leHQgPSBSZWN1cnJlbmNlLmZyb21PbmVEYXlFYXJsaWVyKGFmdGVyLCBycnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpc1NraXBwaW5nVG9vTWFueVllYXJzIHJldHVybnMgdHJ1ZSBpZiBgbmV4dGAgaXMgbW9yZSB0aGFuIGBza2lwcGluZ1llYXJzYCB5ZWFycyBhZnRlciBgYWZ0ZXJgLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGlzU2tpcHBpbmdUb29NYW55WWVhcnMoYWZ0ZXI6IE1vbWVudCwgbmV4dDogTW9tZW50LCBza2lwcGluZ1llYXJzOiBOdW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IG5leHQueWVhcigpIC0gYWZ0ZXIueWVhcigpO1xuXG4gICAgICAgIHJldHVybiBkaWZmID4gc2tpcHBpbmdZZWFycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmcm9tT25lRGF5RWFybGllciByZXR1cm5zIHRoZSBuZXh0IG9jY3VycmVuY2UgYWZ0ZXIgbW92aW5nIGBhZnRlcmAgb25lIGRheSBpbnRvIHRoZSBwYXN0LlxuICAgICAqXG4gICAgICogV0FSTklORzogVGhpcyBtZXRob2QgbWFuaXB1bGF0ZXMgdGhlIGdpdmVuIGluc3RhbmNlIG9mIGBhZnRlcmAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnJvbU9uZURheUVhcmxpZXIoYWZ0ZXI6IE1vbWVudCwgcnJ1bGU6IFJSdWxlKTogTW9tZW50IHtcbiAgICAgICAgYWZ0ZXIuc3VidHJhY3QoMSwgJ2RheXMnKS5lbmRPZignZGF5Jyk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHJydWxlLm9yaWdPcHRpb25zO1xuICAgICAgICBvcHRpb25zLmR0c3RhcnQgPSBhZnRlci5zdGFydE9mKCdkYXknKS50b0RhdGUoKTtcbiAgICAgICAgcnJ1bGUgPSBuZXcgUlJ1bGUob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5tb21lbnQocnJ1bGUuYWZ0ZXIoYWZ0ZXIudG9EYXRlKCkpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhZGRUaW1lem9uZShkYXRlOiBNb21lbnQpOiBNb21lbnQge1xuICAgICAgICBjb25zdCBsb2NhbFRpbWVab25lID0gd2luZG93Lm1vbWVudC51dGMoZGF0ZSkubG9jYWwodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsVGltZVpvbmUuc3RhcnRPZignZGF5Jyk7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQ29sbGVjdGlvbiBvZiBzdGF0dXMgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBwbHVnaW4uXG4gKi9cbmV4cG9ydCBlbnVtIFN0YXR1c1R5cGUge1xuICAgIFRPRE8gPSAnVE9ETycsXG4gICAgRE9ORSA9ICdET05FJyxcbiAgICBJTl9QUk9HUkVTUyA9ICdJTl9QUk9HUkVTUycsXG4gICAgQ0FOQ0VMTEVEID0gJ0NBTkNFTExFRCcsXG4gICAgTk9OX1RBU0sgPSAnTk9OX1RBU0snLFxuICAgIEVNUFRZID0gJ0VNUFRZJyxcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBvYmplY3Qgc3RvcmVkIGJ5IHRoZSBPYnNpZGlhbiBjb25maWd1cmF0aW9uIGFuZCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RhdHVzXG4gKiBvYmplY3RzIGZvciB0aGUgc2Vzc2lvblxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNDb25maWd1cmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcmFjdGVyIHVzZWQgYmV0d2VlbiB0aGUgdHdvIHNxdWFyZSBicmFja2V0cyBpbiB0aGUgbWFya2Rvd24gdGFzay5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBzeW1ib2w6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHN0YXR1cyBmb3IgZGlzcGxheSBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHN0YXR1cyBmb3IgYSB0YXNrIHdoZW4gdG9nZ2xlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBuZXh0U3RhdHVzU3ltYm9sOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZW4gaXQgaXMgcmVnaXN0ZXJlZCBhcyBhIGNvbW1hbmQgdGhhdCB0aGUgdXNlciBjYW4gbWFwIHRvLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBhdmFpbGFibGVBc0NvbW1hbmQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgdHlwZS4gU2VlIHtAbGluayBTdGF0dXNUeXBlfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogU3RhdHVzVHlwZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3RhdHVzLiBUaGUgcmVnaXN0cnkgd2lsbCBiZSBhZGRlZCBsYXRlciBpbiB0aGUgY2FzZVxuICAgICAqIG9mIHRoZSBkZWZhdWx0IHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IG5leHRTdGF0dXNTeW1ib2xcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF2YWlsYWJsZUFzQ29tbWFuZFxuICAgICAqIEBwYXJhbSB7U3RhdHVzVHlwZX0gdHlwZVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc3ltYm9sOiBzdHJpbmcsXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgbmV4dFN0YXR1c1N5bWJvbDogc3RyaW5nLFxuICAgICAgICBhdmFpbGFibGVBc0NvbW1hbmQ6IGJvb2xlYW4sXG4gICAgICAgIHR5cGU6IFN0YXR1c1R5cGUgPSBTdGF0dXNUeXBlLlRPRE8sIC8vIFRPRE8gUmVtb3ZlIGRlZmF1bHQgdmFsdWVcbiAgICApIHtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubmV4dFN0YXR1c1N5bWJvbCA9IG5leHRTdGF0dXNTeW1ib2w7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlQXNDb21tYW5kID0gYXZhaWxhYmxlQXNDb21tYW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbkVudHJ5IH0gZnJvbSAnLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBUcmFja3MgdGhlIHBvc3NpYmxlIHN0YXRlcyB0aGF0IGEgdGFzayBjYW4gYmUgaW4uXG4gKlxuICogUmVsYXRlZCBjbGFzc2VzOlxuICogQHNlZSBTdGF0dXNDb25maWd1cmF0aW9uXG4gKiBAc2VlIFN0YXR1c1JlZ2lzdHJ5XG4gKiBAc2VlIFN0YXR1c1NldHRpbmdzXG4gKiBAc2VlIFN0YXR1c1NldHRpbmdzSGVscGVycy50c1xuICogQHNlZSBDdXN0b21TdGF0dXNNb2RhbFxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgRG9uZSBzdGF0dXMuIEdvZXMgdG8gVG9kbyB3aGVuIHRvZ2dsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBET05FOiBTdGF0dXMgPSBTdGF0dXMubWFrZURvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBzdGF0dXMgb2YgZW1wdHksIHVzZWQgd2hlbiB0aGluZ3MgZ28gd3JvbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgRU1QVFk6IFN0YXR1cyA9IFN0YXR1cy5tYWtlRW1wdHkoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IFRvZG8gc3RhdHVzLiBHb2VzIHRvIERvbmUgd2hlbiB0b2dnbGVkLlxuICAgICAqIFVzZXIgbWF5IGxhdGVyIGJlIGFibGUgdG8gb3ZlcnJpZGUgdGhpcyB0byBnbyB0byBJbiBQcm9ncmVzcyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVE9ETzogU3RhdHVzID0gU3RhdHVzLm1ha2VUb2RvKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBzdG9yZWQgaW4gdGhlIGRhdGEuanNvbiBmaWxlLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0YXR1c0NvbmZpZ3VyYXRpb259XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBjb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCB1c2VkIGJldHdlZW4gdGhlIHR3byBzcXVhcmUgYnJhY2tldHMgaW4gdGhlIG1hcmtkb3duIHRhc2suXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN5bWJvbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnN5bWJvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBzdGF0dXMgZm9yIGRpc3BsYXkgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgc3RhdHVzIGZvciBhIHRhc2sgd2hlbiB0b2dnbGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGdldCBuZXh0U3RhdHVzU3ltYm9sKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZW4gaXQgaXMgcmVnaXN0ZXJlZCBhcyBhIGNvbW1hbmQgdGhhdCB0aGUgdXNlciBjYW4gbWFwIHRvLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXZhaWxhYmxlQXNDb21tYW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmF2YWlsYWJsZUFzQ29tbWFuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgdHlwZS4gU2VlIHtAbGluayBTdGF0dXNUeXBlfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogU3RhdHVzVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN0YXR1cy4gVGhlIHJlZ2lzdHJ5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhlIGNhc2VcbiAgICAgKiBvZiB0aGUgZGVmYXVsdCBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RhdHVzQ29uZmlndXJhdGlvbn0gY29uZmlndXJhdGlvblxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgRG9uZSBzdGF0dXMuIEdvZXMgdG8gVG9kbyB3aGVuIHRvZ2dsZWQuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VEb25lKCk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCd4JywgJ0RvbmUnLCAnICcsIHRydWUsIFN0YXR1c1R5cGUuRE9ORSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBzdGF0dXMgb2YgZW1wdHksIHVzZWQgd2hlbiB0aGluZ3MgZ28gd3JvbmcuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VFbXB0eSgpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignJywgJ0VNUFRZJywgJycsIHRydWUsIFN0YXR1c1R5cGUuRU1QVFkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBUb2RvIHN0YXR1cy4gR29lcyB0byBEb25lIHdoZW4gdG9nZ2xlZC5cbiAgICAgKiBVc2VyIG1heSBsYXRlciBiZSBhYmxlIHRvIG92ZXJyaWRlIHRoaXMgdG8gZ28gdG8gSW4gUHJvZ3Jlc3MgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZVRvZG8oKTogU3RhdHVzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXMobmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJyAnLCAnVG9kbycsICd4JywgdHJ1ZSwgU3RhdHVzVHlwZS5UT0RPKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgQ2FuY2VsbGVkIHN0YXR1cy4gR29lcyB0byBUb2RvIHdoZW4gdG9nZ2xlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZUNhbmNlbGxlZCgpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignLScsICdDYW5jZWxsZWQnLCAnICcsIHRydWUsIFN0YXR1c1R5cGUuQ0FOQ0VMTEVEKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgSW4gUHJvZ3Jlc3Mgc3RhdHVzLiBHb2VzIHRvIERvbmUgd2hlbiB0b2dnbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYWtlSW5Qcm9ncmVzcygpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignLycsICdJbiBQcm9ncmVzcycsICd4JywgdHJ1ZSwgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgU3RhdHVzVHlwZSB0byB1c2UgZm9yIGEgc3ltYm9sLCBpZiBpdCBpcyBub3QgaW4gdGhlIFN0YXR1c1JlZ2lzdHJ5LlxuICAgICAqIFRoZSBjb3JlIHN5bWJvbHMgYXJlIHJlY29nbmlzZWQuXG4gICAgICogT3RoZXIgc3ltYm9scyBhcmUgdHJlYXRlZCBhcyBTdGF0dXNUeXBlLlRPRE9cbiAgICAgKiBAcGFyYW0gc3ltYm9sXG4gICAgICovXG4gICAgc3RhdGljIGdldFR5cGVGb3JVbmtub3duU3ltYm9sKHN5bWJvbDogc3RyaW5nKTogU3RhdHVzVHlwZSB7XG4gICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLkRPTkU7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzVHlwZS5JTl9QUk9HUkVTUztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLkNBTkNFTExFRDtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGUuRU1QVFk7XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGUuVE9ETztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGV4dCB0aGF0IHdhcyBzYXZlZCBmcm9tIGEgU3RhdHVzVHlwZSB2YWx1ZSBiYWNrIHRvIGEgU3RhdHVzVHlwZS5cbiAgICAgKiBSZXR1cm5zIFN0YXR1c1R5cGUuVE9ETyBpZiB0aGUgc3RyaW5nIGlzIG5vdCB2YWxpZC5cbiAgICAgKiBAcGFyYW0gc3RhdHVzVHlwZUFzU3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGdldFR5cGVGcm9tU3RhdHVzVHlwZVN0cmluZyhzdGF0dXNUeXBlQXNTdHJpbmc6IHN0cmluZyk6IFN0YXR1c1R5cGUge1xuICAgICAgICByZXR1cm4gU3RhdHVzVHlwZVtzdGF0dXNUeXBlQXNTdHJpbmcgYXMga2V5b2YgdHlwZW9mIFN0YXR1c1R5cGVdIHx8IFN0YXR1c1R5cGUuVE9ETztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdGF0dXMgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiwgdW5rbm93biBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBTdGF0dXNSZWdpc3RyeSBkb2VzIG5vdCByZWNvZ25pc2UgYSBzeW1ib2wsXG4gICAgICogYW5kIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgdXNlcidzIGRhdGEgdG8gdGhlIFN0YXR1cy5FTVBUWSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHlwZSBpcyBzZXQgdG8gVE9ETy5cbiAgICAgKiBAcGFyYW0gdW5rbm93blN5bWJvbFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVVbmtub3duU3RhdHVzKHVua25vd25TeW1ib2w6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbih1bmtub3duU3ltYm9sLCAnVW5rbm93bicsICd4JywgZmFsc2UsIFN0YXR1c1R5cGUuVE9ETykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYnVsay1pbXBvcnRpbmcgc2V0dGluZ3MgZnJvbSBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbXBvcnRlZCBBbiBhcnJheSBvZiBzeW1ib2wsIG5hbWUsIG5leHQgc3ltYm9sLCBzdGF0dXMgdHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tSW1wb3J0ZWRWYWx1ZShpbXBvcnRlZDogU3RhdHVzQ29sbGVjdGlvbkVudHJ5KSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGltcG9ydGVkWzBdO1xuICAgICAgICBjb25zdCB0eXBlID0gU3RhdHVzLmdldFR5cGVGcm9tU3RhdHVzVHlwZVN0cmluZyhpbXBvcnRlZFszXSk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKHN5bWJvbCwgaW1wb3J0ZWRbMV0sIGltcG9ydGVkWzJdLCBmYWxzZSwgdHlwZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBsZXRpb24gc3RhdHVzIGZvciBhIHRhc2ssIHRoaXMgaXMgb25seSBzdXBwb3J0ZWRcbiAgICAgKiB3aGVuIHRoZSB0YXNrIGlzIGRvbmUveC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGlzQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTdGF0dXNUeXBlLkRPTkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgb25lLWxpbmUgc3VtbWFyeSBvZiB0aGUgc3RhdHVzLCBmb3IgcHJlc2VudGF0aW9uIHRvIHVzZXJzLlxuICAgICAqL1xuICAgIHB1YmxpYyBwcmV2aWV3VGV4dCgpIHtcbiAgICAgICAgbGV0IGNvbW1hbmROb3RpY2UgPSAnJztcbiAgICAgICAgaWYgKFN0YXR1cy50YXNrc1BsdWdpbkNhbkNyZWF0ZUNvbW1hbmRzRm9yU3RhdHVzZXMoKSAmJiB0aGlzLmF2YWlsYWJsZUFzQ29tbWFuZCkge1xuICAgICAgICAgICAgY29tbWFuZE5vdGljZSA9ICcgQXZhaWxhYmxlIGFzIGEgY29tbWFuZC4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBgLSBbJHt0aGlzLnN5bWJvbH1dYCArIC8vIGNvbW1lbnQgdG8gYnJlYWsgbGluZVxuICAgICAgICAgICAgYCA9PiBbJHt0aGlzLm5leHRTdGF0dXNTeW1ib2x9XSxgICtcbiAgICAgICAgICAgIGAgbmFtZTogJyR7dGhpcy5uYW1lfScsYCArXG4gICAgICAgICAgICBgIHR5cGU6ICcke3RoaXMuY29uZmlndXJhdGlvbi50eXBlfScuYCArXG4gICAgICAgICAgICBgJHtjb21tYW5kTm90aWNlfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIFRhc2tzIGNhbiB5ZXQgY3JlYXRlICdUb2dnbGUgU3RhdHVzJyBjb21tYW5kcyBmb3Igc3RhdHVzZXNcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IHlldCBwb3NzaWJsZSwgYW5kIHNvIHNvbWUgVUkgZmVhdHVyZXMgYXJlIHRlbXBvcmFyaWx5IGhpZGRlbi5cbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy8xNDg2XG4gICAgICogT25jZSB0aGF0IGlzc3VlIGlzIGFkZHJlc3NlZCwgdGhpcyBtZXRob2QgY2FuIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB0YXNrc1BsdWdpbkNhbkNyZWF0ZUNvbW1hbmRzRm9yU3RhdHVzZXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi4vU3RhdHVzUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzJztcbmltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbiB9IGZyb20gJy4uL1N0YXR1c0NvbGxlY3Rpb24nO1xuXG4vKipcbiAqIENsYXNzIGZvciBlbmNhcHN1bGF0aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGNvbnRyb2wgY3VzdG9tIHN0YXR1c2VzLlxuICpcbiAqIE1vc3QgbWV0aG9kcyBhcmUgc3RhdGljIHRvIGFsbG93IHRoZW0gdG8gYmUgY2FsbGVkIGZyb20gY2FsbC1iYWNrcy5cbiAqXG4gKiBAc2VlIFN0YXR1c1xuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzU2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvcmVTdGF0dXNlcyA9IFtcbiAgICAgICAgICAgIC8vIFRoZSB0d28gc3RhdHVzZXMgdGhhdCBkbyBub3QgbmVlZCBDU1Mgc3R5bGluZ1xuICAgICAgICAgICAgU3RhdHVzLm1ha2VUb2RvKCkuY29uZmlndXJhdGlvbixcbiAgICAgICAgICAgIFN0YXR1cy5tYWtlRG9uZSgpLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgIF07IC8vIERvIG5vdCBtb2RpZnkgZGlyZWN0bHk6IHVzZSB0aGUgc3RhdGljIG11dGF0aW9uIG1ldGhvZHMgaW4gdGhpcyBjbGFzcy5cbiAgICAgICAgdGhpcy5jdXN0b21TdGF0dXNlcyA9IFtcbiAgICAgICAgICAgIC8vIEFueSBzdGF0dXNlcyB0aGF0IGFyZSBhbHdheXMgc3VwcG9ydGVkLCBidXQgbmVlZCBjdXN0b20gQ1NTIHN0eWxpbmdcbiAgICAgICAgICAgIFN0YXR1cy5tYWtlSW5Qcm9ncmVzcygpLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICBTdGF0dXMubWFrZUNhbmNlbGxlZCgpLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgIF07IC8vIERvIG5vdCBtb2RpZnkgZGlyZWN0bHk6IHVzZSB0aGUgc3RhdGljIG11dGF0aW9uIG1ldGhvZHMgaW4gdGhpcyBjbGFzcy5cbiAgICB9XG4gICAgcmVhZG9ubHkgY29yZVN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW107XG4gICAgcmVhZG9ubHkgY3VzdG9tU3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjdXN0b20gc3RhdHVzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBzdGF0aWMgc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gbW9kYWwgb25DbGljaygpIGNhbGwtYmFja3MuXG4gICAgICpcbiAgICAgKiAtIEN1cnJlbnRseSwgZHVwbGljYXRlcyBhcmUgYWxsb3dlZC5cbiAgICAgKiAtIEFsbG93cyBlbXB0eSBTdGF0dXNDb25maWd1cmF0aW9uIG9iamVjdHMgLSB3aGVyZSBldmVyeSBzdHJpbmcgaXMgZW1wdHlcbiAgICAgKiBAcGFyYW0gc3RhdHVzZXNcbiAgICAgKiBAcGFyYW0gbmV3U3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhZGRTdGF0dXMoc3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSwgbmV3U3RhdHVzOiBTdGF0dXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHN0YXR1c2VzLnB1c2gobmV3U3RhdHVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBnaXZlbiBzdGF0dXMsIHRvIGVmZmVjdGl2ZWx5IGVkaXQgaXQuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZXR0aW5ncyB3ZXJlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIC0gRG9lcyBub3QgY3VycmVudGx5IGNoZWNrIHdoZXRoZXIgdGhlIHN0YXR1cyBjaGFyYWN0ZXIgaXMgdGhlIHNhbWVcbiAgICAgKiAtIElmIHRoZSBzdGF0dXMgY2hhcmFjdGVyIGlzIGRpZmZlcmVudCwgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgbmV3IG9uZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBzdGF0dXNcbiAgICAgKiBAcGFyYW0gc3RhdHVzZXNcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGF0dXNcbiAgICAgKiBAcGFyYW0gbmV3U3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXBsYWNlU3RhdHVzKFxuICAgICAgICBzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdLFxuICAgICAgICBvcmlnaW5hbFN0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbixcbiAgICAgICAgbmV3U3RhdHVzOiBTdGF0dXNDb25maWd1cmF0aW9uLFxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZFN0YXR1c0luZGV4KG9yaWdpbmFsU3RhdHVzLCBzdGF0dXNlcyk7XG4gICAgICAgIGlmIChpbmRleCA8PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1c2VzLnNwbGljZShpbmRleCwgMSwgbmV3U3RhdHVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHRoZSBmYWN0IHRoYXQgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzVHlwZXMuaW5kZXhPZihzdGF0dXNDb25maWd1cmF0aW9uKVxuICAgICAqIHN0b3BwZWQgZmluZGluZyBpZGVudGljYWwgc3RhdHVzZXMgc2luY2UgdGhlIGFkZGl0aW9uIG9mIFN0YXR1c0NvbmZpZ3VyYXRpb24udHlwZS5cbiAgICAgKiBAcGFyYW0gc3RhdHVzQ29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBzdGF0dXNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZFN0YXR1c0luZGV4KHN0YXR1c0NvbmZpZ3VyYXRpb246IFN0YXR1c0NvbmZpZ3VyYXRpb24sIHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGF0dXNBc1N0YXR1cyA9IG5ldyBTdGF0dXMoc3RhdHVzQ29uZmlndXJhdGlvbik7XG4gICAgICAgIHJldHVybiBzdGF0dXNlcy5maW5kSW5kZXgoKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdHVzKHMpLnByZXZpZXdUZXh0KCkgPT0gb3JpZ2luYWxTdGF0dXNBc1N0YXR1cy5wcmV2aWV3VGV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGdpdmVuIHN0YXR1cy5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZGVsZXRlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc3RhdGljIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIG1vZGFsIG9uQ2xpY2soKSBjYWxsLWJhY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIHN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlU3RhdHVzKHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10sIHN0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZFN0YXR1c0luZGV4KHN0YXR1cywgc3RhdHVzZXMpO1xuICAgICAgICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIGN1c3RvbSBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc3RhdGljIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIG1vZGFsIG9uQ2xpY2soKSBjYWxsLWJhY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1NldHRpbmdzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVBbGxDdXN0b21TdGF0dXNlcyhzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MpIHtcbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuc3BsaWNlKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIGRlZmF1bHQgY3VzdG9tIHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1NldHRpbmdzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXNldEFsbEN1c3RvbVN0YXR1c2VzKHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncykge1xuICAgICAgICBTdGF0dXNTZXR0aW5ncy5kZWxldGVBbGxDdXN0b21TdGF0dXNlcyhzdGF0dXNTZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IG5ldyBTdGF0dXNTZXR0aW5ncygpO1xuICAgICAgICBkZWZhdWx0U2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgU3RhdHVzU2V0dGluZ3MuYWRkU3RhdHVzKHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLCBzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29sbGVjdGlvbiBvZiBjdXN0b20gc3VwcG9ydGVkIHN0YXR1c2VzIHRvIGEgU3RhdHVzU2V0dGluZ3MuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBxdWlja2x5IHBvcHVsYXRlIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAgICogSWYgdGhlcmUgYXJlIGFueSBleGFjdCBkdXBsaWNhdGVzIGFscmVhZHkgcHJlc2VudCwgdGhleSBhcmUgc2tpcHBlZCwgYW5kIG5vdGVkIGluIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc3RhdGljIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIG1vZGFsIG9uQ2xpY2soKSBjYWxsLWJhY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1NldHRpbmdzIGEgU3RhdHVzU2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gc3VwcG9ydGVkU3RhdHVzZXMgLSBhbiBhcnJheSBvZiBzdGF0dXMgc3BlY2lmaWNhdGlvbnMsIGZvciBleGFtcGxlIGBbJ2InLCAnQm9va21hcmsnLCAneCddYFxuICAgICAqIEByZXR1cm4gQW4gYXJyYXkgb2Ygd2FybmluZyBtZXNzYWdlcyB0byBzaG93IHRoZSB1c2VyLCBvbmUgZm9yIGVhY2ggcmVqZWN0ZWQgZXhhY3QgZHVwbGljYXRlIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIG1pbmltYWxTdXBwb3J0ZWRTdGF0dXNlc30sIHtAbGluayBpdHNTdXBwb3J0ZWRTdGF0dXNlc31cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9uKFxuICAgICAgICBzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MsXG4gICAgICAgIHN1cHBvcnRlZFN0YXR1c2VzOiBTdGF0dXNDb2xsZWN0aW9uLFxuICAgICk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3Qgbm90aWNlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgc3VwcG9ydGVkU3RhdHVzZXMuZm9yRWFjaCgoaW1wb3J0ZWRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N0YXR1cyA9IHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLmZpbmQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN5bWJvbCA9PSBpbXBvcnRlZFN0YXR1c1swXSAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm5hbWUgPT0gaW1wb3J0ZWRTdGF0dXNbMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5uZXh0U3RhdHVzU3ltYm9sID09IGltcG9ydGVkU3RhdHVzWzJdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFoYXNTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBTdGF0dXNTZXR0aW5ncy5hZGRTdGF0dXMoc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMsIFN0YXR1cy5jcmVhdGVGcm9tSW1wb3J0ZWRWYWx1ZShpbXBvcnRlZFN0YXR1cykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3RpY2VzLnB1c2goYFRoZSBzdGF0dXMgJHtpbXBvcnRlZFN0YXR1c1sxXX0gKCR7aW1wb3J0ZWRTdGF0dXNbMF19KSBpcyBhbHJlYWR5IGFkZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vdGljZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGN1c3RvbSBzdGF0dXNlcyBpbiB0aGUgc3RhdHVzU2V0dGluZ3Mgb2JqZWN0IHRvIHRoZSBzdGF0dXNSZWdpc3RyeS5cbiAgICAgKiBAcGFyYW0gc3RhdHVzU2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gc3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFwcGx5VG9TdGF0dXNSZWdpc3RyeShzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MsIHN0YXR1c1JlZ2lzdHJ5OiBTdGF0dXNSZWdpc3RyeSkge1xuICAgICAgICBzdGF0dXNSZWdpc3RyeS5jbGVhclN0YXR1c2VzKCk7XG4gICAgICAgIHN0YXR1c1NldHRpbmdzLmNvcmVTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXNUeXBlKSA9PiB7XG4gICAgICAgICAgICBzdGF0dXNSZWdpc3RyeS5hZGQoc3RhdHVzVHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcy5mb3JFYWNoKChzdGF0dXNUeXBlKSA9PiB7XG4gICAgICAgICAgICBzdGF0dXNSZWdpc3RyeS5hZGQoc3RhdHVzVHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgZmVhdHVyZXNKc29uIGZyb20gJy4vZmVhdHVyZUNvbmZpZ3VyYXRpb24uanNvbic7XG5cbmV4cG9ydCB0eXBlIEZlYXR1cmVGbGFnID0ge1xuICAgIFtpbnRlcm5hbE5hbWU6IHN0cmluZ106IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIFRoZSBGZWF0dXJlIGNsYXNzIHRyYWNrcyBhbGwgdGhlIHBvc3NpYmxlIGZlYXR1cmVzIHRoYXQgdXNlcnMgY2FuIGVuYWJsZWQgdGhhdCBhcmUgaW4gZGV2ZWxvcG1lbnQuIFRoaXMgYWxsb3dzXG4gKiBuZXcgZmVhdHVyZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHBsYXRmb3JtIGJ1dCBub3QgZW5hYmxlZCBieSBkZWZhdWx0LiBUaGlzIHJlZHVjZXMgdGhlIGNvbXBsaWNhdGlvbnMgd2hlbiBpdFxuICogY29tZXMgdG8gYWRkaW5nIG5ldyBmZWF0dXJlcyBhbmQgYSBsYXJnZSBjYXNjYWRlIG9mIGRlcGVuZGVudCBicmFuY2hlcy5cbiAqXG4gKiBXaGVuIHlvdSBhZGQgYSBuZXcgZmVhdHVyZSB5b3UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGZlYXR1cmVDb25maWd1cmF0aW9uLmpzb24gZmlsZS4gSXQgdGhlbiBuZWVkcyB0byBiZSBhZGRlZCB0b1xuICogc2V0dGluZ3Mgc28gYSB1c2VyIGNhbiBlbmFibGUgaXQuIElmIHlvdSB3YW50IGl0IGhpZGRlbiB5b3Ugd2lsbCBuZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGUgZGF0YS5qc29uIGZpbGUuIEluIHRoZVxuICogcGx1Z2luIGZvbGRlci5cbiAqXG4gKiBAc2luY2UgMjAyMi0wNS0yOVxuICovXG5leHBvcnQgY2xhc3MgRmVhdHVyZSB7XG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGludGVybmFsTmFtZTogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgaW5kZXg6IG51bWJlcixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBkaXNwbGF5TmFtZTogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZW5hYmxlZEJ5RGVmYXVsdDogYm9vbGVhbixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHN0YWJsZTogYm9vbGVhbixcbiAgICApIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0ZlYXR1cmVbXX1cbiAgICAgKiBAbWVtYmVyb2YgRmVhdHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdmFsdWVzKCk6IEZlYXR1cmVbXSB7XG4gICAgICAgIGxldCBhdmFpbGFibGVGZWF0dXJlczogRmVhdHVyZVtdID0gW107XG5cbiAgICAgICAgZmVhdHVyZXNKc29uLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZUZlYXR1cmVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmF2YWlsYWJsZUZlYXR1cmVzLFxuICAgICAgICAgICAgICAgIG5ldyBGZWF0dXJlKFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmludGVybmFsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5lbmFibGVkQnlEZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0YWJsZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVGZWF0dXJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBmZWF0dXJlLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGZWF0dXJlRmxhZ31cbiAgICAgKiBAbWVtYmVyb2YgRmVhdHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgc2V0dGluZ3NGbGFncygpOiBGZWF0dXJlRmxhZyB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVGbGFnczogeyBbaW50ZXJuYWxOYW1lOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuICAgICAgICBGZWF0dXJlLnZhbHVlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICBmZWF0dXJlRmxhZ3NbZmVhdHVyZS5pbnRlcm5hbE5hbWVdID0gZmVhdHVyZS5lbmFibGVkQnlEZWZhdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVGbGFncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIG5hbWUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgZGVmYXVsdCBGZWF0dXJlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgdG8gY29udmVydCB0byBGZWF0dXJlXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yLCBpZiBhIHN0cmluZyB0aGF0IGhhcyBubyBjb3JyZXNwb25kaW5nIEZlYXR1cmUgdmFsdWUgd2FzIHBhc3NlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbWF0Y2hpbmcgRmVhdHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKG5hbWU6IHN0cmluZyk6IEZlYXR1cmUge1xuICAgICAgICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgRmVhdHVyZS52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBmZWF0dXJlLmludGVybmFsTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICBgSWxsZWdhbCBhcmd1bWVudCBwYXNzZWQgdG8gZnJvbVN0cmluZygpOiAke25hbWV9IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW55IGF2YWlsYWJsZSBGZWF0dXJlICR7XG4gICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KS5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZVxuICAgICAgICAgICAgfWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c0NvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1cyc7XG5pbXBvcnQgeyBTdGF0dXNTZXR0aW5ncyB9IGZyb20gJy4vU3RhdHVzU2V0dGluZ3MnO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJy4vRmVhdHVyZSc7XG5pbXBvcnQgdHlwZSB7IEZlYXR1cmVGbGFnIH0gZnJvbSAnLi9GZWF0dXJlJztcblxuaW50ZXJmYWNlIFNldHRpbmdzTWFwIHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBIZWFkaW5nU3RhdGUgPSB7XG4gICAgW2lkOiBzdHJpbmddOiBib29sZWFuO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5ncyB7XG4gICAgZ2xvYmFsRmlsdGVyOiBzdHJpbmc7XG4gICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiBib29sZWFuO1xuICAgIHNldERvbmVEYXRlOiBib29sZWFuO1xuICAgIGF1dG9TdWdnZXN0SW5FZGl0b3I6IGJvb2xlYW47XG4gICAgYXV0b1N1Z2dlc3RNaW5NYXRjaDogbnVtYmVyO1xuICAgIGF1dG9TdWdnZXN0TWF4SXRlbXM6IG51bWJlcjtcbiAgICBwcm92aWRlQWNjZXNzS2V5czogYm9vbGVhbjtcbiAgICB1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZTogYm9vbGVhbjtcbiAgICBmaWxlbmFtZUFzRGF0ZUZvbGRlcnM6IHN0cmluZ1tdO1xuXG4gICAgLy8gVGhlIGN1c3RvbSBzdGF0dXMgc3RhdGVzLlxuICAgIHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncztcblxuICAgIC8vIENvbGxlY3Rpb24gb2YgZmVhdHVyZSBmbGFnIElEcyBhbmQgdGhlaXIgc3RhdGUuXG4gICAgZmVhdHVyZXM6IEZlYXR1cmVGbGFnO1xuXG4gICAgLy8gU2V0dGluZ3MgYXJlIG1vdmVkIHRvIGEgbW9yZSBnZW5lcmFsIG1hcCB0byBhbGxvdyB0aGUgc2V0dGluZ3MgVUkgdG8gYmVcbiAgICAvLyBkeW5hbWljYWxseSBnZW5lcmF0ZWQuXG4gICAgZ2VuZXJhbFNldHRpbmdzOiBTZXR0aW5nc01hcDtcblxuICAgIC8vIFRyYWNrcyB0aGUgc3RhZ2Ugb2YgdGhlIGhlYWRpbmdzIGluIHRoZSBzZXR0aW5ncyBVSS5cbiAgICBoZWFkaW5nT3BlbmVkOiBIZWFkaW5nU3RhdGU7XG59XG5cbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogU2V0dGluZ3MgPSB7XG4gICAgZ2xvYmFsRmlsdGVyOiAnJyxcbiAgICByZW1vdmVHbG9iYWxGaWx0ZXI6IGZhbHNlLFxuICAgIHNldERvbmVEYXRlOiB0cnVlLFxuICAgIGF1dG9TdWdnZXN0SW5FZGl0b3I6IHRydWUsXG4gICAgYXV0b1N1Z2dlc3RNaW5NYXRjaDogMCxcbiAgICBhdXRvU3VnZ2VzdE1heEl0ZW1zOiA2LFxuICAgIHByb3ZpZGVBY2Nlc3NLZXlzOiB0cnVlLFxuICAgIHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlOiBmYWxzZSxcbiAgICBmaWxlbmFtZUFzRGF0ZUZvbGRlcnM6IFtdLFxuICAgIHN0YXR1c1NldHRpbmdzOiBuZXcgU3RhdHVzU2V0dGluZ3MoKSxcbiAgICBmZWF0dXJlczogRmVhdHVyZS5zZXR0aW5nc0ZsYWdzLFxuICAgIGdlbmVyYWxTZXR0aW5nczoge1xuICAgICAgICAvKiBQcmV2ZW50IGR1cGxpY2F0ZSB2YWx1ZXMgaW4gdXNlciBzZXR0aW5ncyBmb3Igbm93LFxuICAgICAgICAgICBhdCBsZWFzdCB1bnRpbCBJIHN0YXJ0IHBvcnRpbmcgdGhlIHByZS0xLjIzLjAgc2V0dGluZ3NcbiAgICAgICAgICAgY29kZSB0byBiZSBnZW5lcmF0ZWQgZnJvbSBzZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGdsb2JhbEZpbHRlcjogJycsXG4gICAgICAgIC8vIHJlbW92ZUdsb2JhbEZpbHRlcjogZmFsc2UsXG4gICAgICAgIC8vIHNldERvbmVEYXRlOiB0cnVlLFxuICAgIH0sXG4gICAgaGVhZGluZ09wZW5lZDoge30sXG59O1xuXG5sZXQgc2V0dGluZ3M6IFNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0dGluZ3MgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNldHRpbmdzIGFzIGEgb2JqZWN0LCBpdCB3aWxsIGFsc28gY2hlY2sgYW5kXG4gKiB1cGRhdGUgdGhlIGZsYWdzIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBhbGwgc2hvd24gaW4gdGhlIGRhdGEuanNvblxuICogZmlsZS4gRXhwb3N1cmUgdmlhIHRoZSBzZXR0aW5ncyBVSSBpcyBvcHRpb25hbC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZXR0aW5ncyA9ICgpOiBTZXR0aW5ncyA9PiB7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbmV3IGZsYWcgYW5kIGlmIHNvIGFkZCBpdCB0byB0aGUgdXNlcnMgc2V0dGluZ3MuXG4gICAgZm9yIChjb25zdCBmbGFnIGluIEZlYXR1cmUuc2V0dGluZ3NGbGFncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuZmVhdHVyZXNbZmxhZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZmVhdHVyZXNbZmxhZ10gPSBGZWF0dXJlLnNldHRpbmdzRmxhZ3NbZmxhZ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHNhdmVzIHByZS1kYXRlZCBTdGF0dXNDb25maWd1cmF0aW9uLnR5cGVcbiAgICAvLyBUT0RPIFNwZWNpYWwgY2FzZSBmb3Igc3ltYm9sICdYJyBvciAneCcgKGp1c3QgaW4gY2FzZSlcbiAgICBzZXR0aW5ncy5zdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcy5mb3JFYWNoKChzLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VHlwZSA9IFN0YXR1cy5nZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcocy50eXBlKTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gbmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgICBzLnN5bWJvbCA/PyAnICcsXG4gICAgICAgICAgICBzLm5hbWUsXG4gICAgICAgICAgICBzLm5leHRTdGF0dXNTeW1ib2wgPz8gJ3gnLFxuICAgICAgICAgICAgcy5hdmFpbGFibGVBc0NvbW1hbmQsXG4gICAgICAgICAgICBuZXdUeXBlLFxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgLi4uc2V0dGluZ3MgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IChuZXdTZXR0aW5nczogUGFydGlhbDxTZXR0aW5ncz4pOiBTZXR0aW5ncyA9PiB7XG4gICAgc2V0dGluZ3MgPSB7IC4uLnNldHRpbmdzLCAuLi5uZXdTZXR0aW5ncyB9O1xuXG4gICAgcmV0dXJuIGdldFNldHRpbmdzKCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRTZXR0aW5ncyA9ICgpOiBTZXR0aW5ncyA9PiB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldHRpbmdzKGRlZmF1bHRTZXR0aW5ncyk7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlR2VuZXJhbFNldHRpbmcgPSAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgYm9vbGVhbik6IFNldHRpbmdzID0+IHtcbiAgICBzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8qIFByZXZlbnQgZHVwbGljYXRlIHZhbHVlcyBpbiB1c2VyIHNldHRpbmdzIGZvciBub3csXG4gICAgICAgYXQgbGVhc3QgdW50aWwgSSBzdGFydCBwb3J0aW5nIHRoZSBwcmUtMS4yMy4wIHNldHRpbmdzXG4gICAgICAgY29kZSB0byBiZSBnZW5lcmF0ZWQgZnJvbSBzZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbi5cbiAgICAgKi9cbiAgICAvLyBzeW5jIHRoZSBvbGQgc2V0dGluZ3MgZm9yIHRoZSBtb21lbnQgc28gYSBsYXJnZXIgY2hhbmdlIGlzIG5vdCBuZWVkZWQuXG4gICAgLy8gdXBkYXRlU2V0dGluZ3Moe1xuICAgIC8vICAgICBnbG9iYWxGaWx0ZXI6IDxzdHJpbmc+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzWydnbG9iYWxGaWx0ZXInXSxcbiAgICAvLyAgICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiA8Ym9vbGVhbj5zZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3NbJ3JlbW92ZUdsb2JhbEZpbHRlciddLFxuICAgIC8vICAgICBzZXREb25lRGF0ZTogPGJvb2xlYW4+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzWydzZXREb25lRGF0ZSddLFxuICAgIC8vIH0pO1xuXG4gICAgcmV0dXJuIGdldFNldHRpbmdzKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIGZlYXR1cmUgZnJvbSBzZXR0aW5ncy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gaW50ZXJuYWxOYW1lIHRoZSBpbnRlcm5hbCBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgaXNGZWF0dXJlRW5hYmxlZCA9IChpbnRlcm5hbE5hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBzZXR0aW5ncy5mZWF0dXJlc1tpbnRlcm5hbE5hbWVdID8/IGZhbHNlO1xufTtcblxuLyoqXG4gKiBlbmFibGVzIHRvZ2dsaW5nIHRoZSBmZWF0dXJlIGFuZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiB3aXRoIHN0YXRlLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSBpbnRlcm5hbE5hbWUgdGhlIGludGVybmFsIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gKiBAcGFyYW0gZW5hYmxlZCB0aGUgZXhwZWN0ZWQgc3RhdGUgb2YgdGhlIGZlYXR1cmUuXG4gKiBAcmV0dXJucyB0aGUgZmVhdHVyZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGZlYXR1cmUgdG9nZ2xlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZlYXR1cmUgPSAoaW50ZXJuYWxOYW1lOiBzdHJpbmcsIGVuYWJsZWQ6IGJvb2xlYW4pOiBGZWF0dXJlRmxhZyA9PiB7XG4gICAgc2V0dGluZ3MuZmVhdHVyZXNbaW50ZXJuYWxOYW1lXSA9IGVuYWJsZWQ7XG4gICAgcmV0dXJuIHNldHRpbmdzLmZlYXR1cmVzO1xufTtcbiIsICJpbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuL1N0YXR1cyc7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbi8qKlxuICogVHJhY2tzIGFsbCB0aGUgcmVnaXN0ZXJlZCBzdGF0dXNlcyBhIHRhc2sgY2FuIGhhdmUuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIG9mIHVzaW5nIHRoaXMgY2xhc3MuXG4gKiAtIEluICdwcm9kdWN0aW9uJyBjb2RlLCB0aGF0IGlzIGluIHRoZSBhY3R1YWwgcGx1Z2luIGNvZGUgdGhhdCBpcyByZWxlYXNlZCxcbiAqICAgY2FsbCBgU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKWAgdG8gb2J0YWluIHRoZSBzaW5nbGUgZ2xvYmFsIGluc3RhbmNlLlxuICogICBBbnkgY2hhbmdlcyB0byB0aGUgc3RhdHVzZXMgaW4gdGhhdCBpbnN0YW5jZSBhcmUgcmVmbGVjdGVkIGV2ZXJ5d2hlcmUgdGhyb3VnaG91dFxuICogICB0aGUgcGx1Z2luLlxuICogICBGb3IgZXhhbXBsZSwgdGhlIGNvZGUgdG8gdG9nZ2xlIHRhc2sgc3RhdHVzZXMgdXNlIHRoZSBnbG9iYWwgaW5zdGFuY2UuXG4gKiAtIFRlc3RzIG9mIFN0YXR1c1JlZ2lzdHJ5IGNhcGFiaWxpdGllcyBkbyBub3QgbmVlZCB0byBtb2RpZnkgdGhlIGdsb2JhbCBpbnN0YW5jZTpcbiAqICAgVGhleSBzaG91bGQgdXNlIGBuZXcgU3RhdHVzUmVnaXN0cnkoKWAsIHdoaWNoIG1ha2VzIGZvciBzaW1wbGVyLCBtb3JlIHJlYWRhYmxlXG4gKiAgIHRlc3RzIHRoYXQgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU3RhdHVzUmVnaXN0cnlcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1c1JlZ2lzdHJ5IHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU3RhdHVzUmVnaXN0cnk7XG5cbiAgICBwcml2YXRlIF9yZWdpc3RlcmVkU3RhdHVzZXM6IFN0YXR1c1tdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN0YXR1cyBhbmQgcmVnaXN0ZXJzIGl0IGZvciB1c2UuIEl0IHdpbGwgYWxzbyBjaGVjayB0byBzZWVcbiAgICAgKiBpZiB0aGUgZGVmYXVsdCB0b2RvIGFuZCBkb25lIGFyZSByZWdpc3RlcmVkIGFuZCBpZiBub3QgaGFuZGxlIGl0IGludGVybmFsbHkuXG4gICAgICpcbiAgICAgKiBDb2RlIGluIHRoZSBwbHVnaW4gc2hvdWxkIHVzZSB7QGxpbmsgZ2V0SW5zdGFuY2V9IHRvIHVzZSBhbmQgbW9kaWZ5IHRoZSBnbG9iYWxcbiAgICAgKiBTdGF0dXNSZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hZGREZWZhdWx0U3RhdHVzVHlwZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBzdGF0dXNlcyBtaW51cyB0aGUgZW1wdHkgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0YXR1c1tdfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcmVnaXN0ZXJlZFN0YXR1c2VzKCk6IFN0YXR1c1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRTdGF0dXNlcy5maWx0ZXIoKHsgc3ltYm9sIH0pID0+IHN5bWJvbCAhPT0gU3RhdHVzLkVNUFRZLnN5bWJvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXRpYyBtZXRob2QgdGhhdCBjb250cm9scyB0aGUgYWNjZXNzIHRvIHRoZSBTdGF0dXNSZWdpc3RyeSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHsqfSAge1N0YXR1c1JlZ2lzdHJ5fVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogU3RhdHVzUmVnaXN0cnkge1xuICAgICAgICBpZiAoIVN0YXR1c1JlZ2lzdHJ5Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICBTdGF0dXNSZWdpc3RyeS5pbnN0YW5jZSA9IG5ldyBTdGF0dXNSZWdpc3RyeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0YXR1c1JlZ2lzdHJ5Lmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgU3RhdHVzIHRvIHRoZSByZWdpc3RyeSBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdGF0dXNDb25maWd1cmF0aW9uIHwgU3RhdHVzfSBzdGF0dXNcbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkKHN0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbiB8IFN0YXR1cyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3ltYm9sKHN0YXR1cy5zeW1ib2wpKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzIGluc3RhbmNlb2YgU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLnB1c2goc3RhdHVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLnB1c2gobmV3IFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgc3RhdHVzIGJ5IHRoZSBzeW1ib2wgYmV0d2VlbiB0aGVcbiAgICAgKiBzcXVhcmUgYnJhY2VzIGluIHRoZSBtYXJrZG93biB0YXNrLlxuICAgICAqIFJldHVybnMgYW4gRU1QVFkgc3RhdHVzIGlmIHN5bWJvbCBpcyB1bmtub3duLlxuICAgICAqXG4gICAgICogQHNlZSBieVN5bWJvbE9yQ3JlYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGJ5U3ltYm9sKHN5bWJvbDogc3RyaW5nKTogU3RhdHVzIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN5bWJvbChzeW1ib2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5FTVBUWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIHN0YXR1cyBieSB0aGUgc3ltYm9sIGJldHdlZW4gdGhlXG4gICAgICogc3F1YXJlIGJyYWNlcyBpbiB0aGUgbWFya2Rvd24gdGFzay5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSB1c2FibGUgbmV3IFN0YXR1cyB3aXRoIHRoaXMgZ2l2ZW4gc3ltYm9sIGlmIHN5bWJvbCBpcyB1bmtub3duLlxuICAgICAqIE5vdGU6IEFuIHVua25vd24gc3ltYm9sIGlzIG5vdCBhZGRlZCB0byB0aGUgcmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiBAc2VlIGhhc1N5bWJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFxuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBieVN5bWJvbE9yQ3JlYXRlKHN5bWJvbDogc3RyaW5nKTogU3RhdHVzIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN5bWJvbChzeW1ib2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5jcmVhdGVVbmtub3duU3RhdHVzKHN5bWJvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBzdGF0dXMgYnkgdGhlIG5hbWUgYXNzaWduZWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVRvRmluZFxuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBieU5hbWUobmFtZVRvRmluZDogc3RyaW5nKTogU3RhdHVzIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRTdGF0dXNlcy5maWx0ZXIoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBuYW1lVG9GaW5kKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBuYW1lIH0pID0+IG5hbWUgPT09IG5hbWVUb0ZpbmQpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5FTVBUWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGFycmF5IG9mIFN0YXR1cyB0eXBlcyB0byB0aGUgZGVmYXVsdCBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldFRvRGVmYXVsdFN0YXR1c2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNsZWFyU3RhdHVzZXMoKTtcbiAgICAgICAgdGhpcy5hZGREZWZhdWx0U3RhdHVzVHlwZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGFycmF5IG9mIFN0YXR1cyB0eXBlcyB0byBiZSBlbXB0eS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJTdGF0dXNlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gYWxsb3cgY3VzdG9tIHByb2dyZXNzaW9uIG9mIHRhc2sgc3RhdHVzIGVhY2ggc3RhdHVzIGtub3dzXG4gICAgICogd2hpY2ggc3RhdHVzIGNhbiBjb21lIGFmdGVyIGl0IGFzIGEgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqIEBzZWUgZ2V0TmV4dFN0YXR1c09yQ3JlYXRlXG4gICAgICovXG4gICAgcHVibGljIGdldE5leHRTdGF0dXMoc3RhdHVzOiBTdGF0dXMpOiBTdGF0dXMge1xuICAgICAgICBpZiAoc3RhdHVzLm5leHRTdGF0dXNTeW1ib2wgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U3RhdHVzID0gdGhpcy5ieVN5bWJvbChzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCk7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdGF0dXMuRU1QVFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IHN0YXR1cyBpZiBpdCBleGlzdHMsIGFuZCBpZiBub3QsIGNyZWF0ZSBhIG5ld1xuICAgICAqIFRPRE8gc3RhdHVzIHVzaW5nIHRoZSByZXF1ZXN0ZWQgbmV4dCBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSAge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKiBAc2VlIGdldE5leHRTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TmV4dFN0YXR1c09yQ3JlYXRlKHN0YXR1czogU3RhdHVzKTogU3RhdHVzIHtcbiAgICAgICAgY29uc3QgbmV4dFN0YXR1cyA9IHRoaXMuZ2V0TmV4dFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICBpZiAobmV4dFN0YXR1cy50eXBlICE9PSBTdGF0dXNUeXBlLkVNUFRZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0dXMgaXMgY29uZmlndXJlZCB0byBhZHZhbmNlIHRvIGEgc3ltYm9sIHRoYXQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICAgIC8vIFNvIHdlIGdvIGFoZWFkIGFuZCBjcmVhdGUgaXQgYW55d2F5IC0gd2UganVzdCBjYW5ub3QgZ2l2ZSBpdCBhIG1lYW5pbmdmdWwgbmFtZS5cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5jcmVhdGVVbmtub3duU3RhdHVzKHN0YXR1cy5uZXh0U3RhdHVzU3ltYm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFueSBzdGF0dXNlcyBpbiB0aGUgZ2l2ZW4gdGFza3MgdGhhdCBhcmUgbm90IGtub3duIHRvIHRoaXMgcmVnaXN0cnkuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGQgYWxsIHVua25vd24gc3RhdHVzIHR5cGVzIHRvIHRoZSBzZXR0aW5ncyxcbiAgICAgKiB0byBzYXZlIHVzZXJzIGZyb20gaGF2aW5nIHRvIGRvIHRoYXQgbWFudWFsbHkuXG4gICAgICpcbiAgICAgKiBTdGF0dXNlcyBhcmUgcmV0dXJuZWQgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgZmlyc3QgZm91bmQgaW4gdGhlXG4gICAgICogc3VwcGxpZWQgdGFza3MuXG4gICAgICogQHBhcmFtIHRhc2tzXG4gICAgICovXG4gICAgcHVibGljIGZpbmRVbmtub3duU3RhdHVzZXModGFza3M6IFRhc2tbXSk6IFN0YXR1c1tdIHtcbiAgICAgICAgY29uc3QgYWxsU3RhdHVzZXMgPSB0YXNrcy5tYXAoKHRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLnN0YXR1cztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdW5rbm93blN0YXR1c2VzID0gYWxsU3RhdHVzZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaGFzU3ltYm9sKHMuc3ltYm9sKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXNlIGEgc2VwYXJhdGUgU3RhdHVzUmVnaXN0cnkgdG8ga2VlcCB0cmFjayBvZiBkdXBsaWNhdGVzLFxuICAgICAgICAvLyBiZWNhdXNlIFNldCBpcyBubyB1c2UgdG8gdXM6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI5NzU5NDgwL2hvdy10by1jdXN0b21pemUtb2JqZWN0LWVxdWFsaXR5LWZvci1qYXZhc2NyaXB0LXNldFxuICAgICAgICBjb25zdCBuZXdTdGF0dXNSZWdpc3RyeSA9IG5ldyBTdGF0dXNSZWdpc3RyeSgpO1xuXG4gICAgICAgIGNvbnN0IG5hbWVkVW5pcXVlU3RhdHVzZXM6IFN0YXR1c1tdID0gW107XG4gICAgICAgIHVua25vd25TdGF0dXNlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHNlZW4gdGhpcyBzeW1ib2wgYWxyZWFkeTpcbiAgICAgICAgICAgIGlmIChuZXdTdGF0dXNSZWdpc3RyeS5oYXNTeW1ib2wocy5zeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHbyBhaGVhZCBhbmQgY3JlYXRlIGEgc3VpdGFibHktbmFtZWQgY29weSxcbiAgICAgICAgICAgIC8vIGluY2x1ZGluZyB0aGUgc3ltYm9sIGluIHRoZSBuYW1lLlxuICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuY29weVN0YXR1c1dpdGhOZXdOYW1lKHMsIGBVbmtub3duICgke3Muc3ltYm9sfSlgKTtcbiAgICAgICAgICAgIG5hbWVkVW5pcXVlU3RhdHVzZXMucHVzaChuZXdTdGF0dXMpO1xuICAgICAgICAgICAgLy8gQW5kIGFkZCBpdCB0byBvdXIgbG9jYWwgcmVnaXN0cnksIHRvIHByZXZlbnQgZHVwbGljYXRlcy5cbiAgICAgICAgICAgIG5ld1N0YXR1c1JlZ2lzdHJ5LmFkZChuZXdTdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWVkVW5pcXVlU3RhdHVzZXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29weVN0YXR1c1dpdGhOZXdOYW1lKHM6IFN0YXR1cywgbmV3TmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c0NvbmZpZ3VyYXRpb24gPSBuZXcgU3RhdHVzQ29uZmlndXJhdGlvbihcbiAgICAgICAgICAgIHMuc3ltYm9sLFxuICAgICAgICAgICAgbmV3TmFtZSxcbiAgICAgICAgICAgIHMubmV4dFN0YXR1c1N5bWJvbCxcbiAgICAgICAgICAgIHMuYXZhaWxhYmxlQXNDb21tYW5kLFxuICAgICAgICAgICAgcy50eXBlLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhzdGF0dXNDb25maWd1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHRoZSBTdGF0dXMgdHlwZXMgYnkgdGhlIHN5bWJvbCBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgb25lIGZvdW5kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTeW1ib2woc3ltYm9sVG9GaW5kOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBzeW1ib2wgfSkgPT4gc3ltYm9sID09PSBzeW1ib2xUb0ZpbmQpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgYWxsIHRoZSBTdGF0dXMgdHlwZXMgYnkgdGhlIHN5bWJvbCBhbmQgcmV0dXJucyB0cnVlIGlmIGZvdW5kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHByaXZhdGUgaGFzU3ltYm9sKHN5bWJvbFRvRmluZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMuZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnN5bWJvbCA9PT0gc3ltYm9sVG9GaW5kO1xuICAgICAgICAgICAgfSkgIT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgcmVnaXN0cnkgYW5kIGFkZHMgdGhlIGRlZmF1bHQgc3RhdHVzIHR5cGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGFkZERlZmF1bHRTdGF0dXNUeXBlcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0YXR1c2VzID0gW1N0YXR1cy5tYWtlVG9kbygpLCBTdGF0dXMubWFrZUluUHJvZ3Jlc3MoKSwgU3RhdHVzLm1ha2VEb25lKCksIFN0YXR1cy5tYWtlQ2FuY2VsbGVkKCldO1xuXG4gICAgICAgIGRlZmF1bHRTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG5leHBvcnQgY2xhc3MgVXJnZW5jeSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZHVlQ29lZmZpY2llbnQgPSAxMi4wO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHNjaGVkdWxlZENvZWZmaWNpZW50ID0gNS4wO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHN0YXJ0ZWRDb2VmZmljaWVudCA9IC0zLjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcHJpb3JpdHlDb2VmZmljaWVudCA9IDYuMDtcblxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IG1pbGxpU2Vjb25kc1BlckRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG5cbiAgICBwdWJsaWMgc3RhdGljIGNhbGN1bGF0ZSh0YXNrOiBUYXNrKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHVyZ2VuY3kgPSAwLjA7XG5cbiAgICAgICAgaWYgKHRhc2suZHVlRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTWFwIGEgcmFuZ2Ugb2YgMjEgZGF5cyB0byB0aGUgdmFsdWUgMC4yIC0gMS4wXG4gICAgICAgICAgICBjb25zdCBkYXlzT3ZlcmR1ZSA9IE1hdGgucm91bmQod2luZG93Lm1vbWVudCgpLmRpZmYodGFzay5kdWVEYXRlKSAvIFVyZ2VuY3kubWlsbGlTZWNvbmRzUGVyRGF5KTtcblxuICAgICAgICAgICAgbGV0IGR1ZU11bHRpcGxpZXI6IG51bWJlcjtcbiAgICAgICAgICAgIGlmIChkYXlzT3ZlcmR1ZSA+PSA3LjApIHtcbiAgICAgICAgICAgICAgICBkdWVNdWx0aXBsaWVyID0gMS4wOyAvLyA8IDEgd2sgYWdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRheXNPdmVyZHVlID49IC0xNC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gRHVlIGJldHdlZW4gNyBkYXlzICgrNykgYWdvIGFuZCBpbiAxNCBkYXlzICgtMTQpXG4gICAgICAgICAgICAgICAgZHVlTXVsdGlwbGllciA9ICgoZGF5c092ZXJkdWUgKyAxNC4wKSAqIDAuOCkgLyAyMS4wICsgMC4yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdWVNdWx0aXBsaWVyID0gMC4yOyAvLyA+IDIgd2tzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVyZ2VuY3kgKz0gZHVlTXVsdGlwbGllciAqIFVyZ2VuY3kuZHVlQ29lZmZpY2llbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzay5zY2hlZHVsZWREYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lm1vbWVudCgpLmlzU2FtZU9yQWZ0ZXIodGFzay5zY2hlZHVsZWREYXRlKSkge1xuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMSAqIFVyZ2VuY3kuc2NoZWR1bGVkQ29lZmZpY2llbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzay5zdGFydERhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubW9tZW50KCkuaXNCZWZvcmUodGFzay5zdGFydERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAxICogVXJnZW5jeS5zdGFydGVkQ29lZmZpY2llbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRhc2sucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIC8vIEhpZ2hcbiAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMS4wICogVXJnZW5jeS5wcmlvcml0eUNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gTWVkaXVtXG4gICAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDAuNjUgKiBVcmdlbmN5LnByaW9yaXR5Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBOb25lXG4gICAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDAuMzI1ICogVXJnZW5jeS5wcmlvcml0eUNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVyZ2VuY3k7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgTWFya2Rvd25SZW5kZXJlciB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5pbXBvcnQgKiBhcyB0YXNrTW9kdWxlIGZyb20gJy4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IExheW91dE9wdGlvbnMsIFRhc2tMYXlvdXRDb21wb25lbnQgfSBmcm9tICcuL1Rhc2tMYXlvdXQnO1xuaW1wb3J0IHsgVGFza0xheW91dCB9IGZyb20gJy4vVGFza0xheW91dCc7XG5pbXBvcnQgeyByZXBsYWNlVGFza1dpdGhUYXNrcyB9IGZyb20gJy4vRmlsZSc7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzJztcblxuZXhwb3J0IHR5cGUgVGFza0xpbmVSZW5kZXJEZXRhaWxzID0ge1xuICAgIHBhcmVudFVsRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgLyoqIFRoZSBudGggaXRlbSBpbiB0aGlzIGxpc3QgKGluY2x1ZGluZyBub24tdGFza3MpLiAqL1xuICAgIGxpc3RJbmRleDogbnVtYmVyO1xuICAgIGxheW91dE9wdGlvbnM/OiBMYXlvdXRPcHRpb25zO1xuICAgIGlzRmlsZW5hbWVVbmlxdWU/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gdXNlZCB0byByZW5kZXIgYSBNYXJrZG93biB0YXNrIGxpbmUgaW50byBhbiBleGlzdGluZyBIVE1MIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCB0eXBlIFRleHRSZW5kZXJlciA9ICh0ZXh0OiBzdHJpbmcsIGVsZW1lbnQ6IEhUTUxTcGFuRWxlbWVudCwgcGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG5hc3luYyBmdW5jdGlvbiBvYnNpZGlhbk1hcmtkb3duUmVuZGVyZXIodGV4dDogc3RyaW5nLCBlbGVtZW50OiBIVE1MU3BhbkVsZW1lbnQsIHBhdGg6IHN0cmluZykge1xuICAgIGF3YWl0IE1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24odGV4dCwgZWxlbWVudCwgcGF0aCwgbnVsbCBhcyB1bmtub3duIGFzIENvbXBvbmVudCk7XG59XG5cbi8qKlxuICogUmVuZGVycyBhIGdpdmVuIFRhc2sgb2JqZWN0IGludG8gYW4gSFRNTCBMaXN0IEl0ZW0gKExJKSBlbGVtZW50LCB1c2luZyB0aGUgZ2l2ZW4gcmVuZGVyRGV0YWlsc1xuICogY29uZmlndXJhdGlvbiBhbmQgYSBzdXBwbGllZCBUZXh0UmVuZGVyZXIgKHR5cGljYWxseSB0aGUgT2JzaWRpYW4gTWFya2Rvd24gcmVuZGVyZXIsIGJ1dCBmb3IgdGVzdGluZ1xuICogcHVycG9zZXMgaXQgY2FuIGJlIGEgc2ltcGxlciBvbmUpLlxuICogVGhlIGVsZW1lbnQgaW5jbHVkZXMgdGhlIHRhc2sgYW5kIGl0cyB2YXJpb3VzIGNvbXBvbmVudHMgKGRlc2NyaXB0aW9uLCBwcmlvcml0eSwgYmxvY2sgbGluayBldGMpLCB0aGVcbiAqIGNoZWNrYm94IG9uIHRoZSBsZWZ0IHdpdGggaXRzIGV2ZW50IGhhbmRsaW5nIG9mIGNvbXBsZXRpbmcgdGhlIHRhc2ssIGFuZCB0aGUgYnV0dG9uIGZvciBlZGl0aW5nIHRoZSB0YXNrLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyVGFza0xpbmUoXG4gICAgdGFzazogVGFzayxcbiAgICByZW5kZXJEZXRhaWxzOiBUYXNrTGluZVJlbmRlckRldGFpbHMsXG4gICAgdGV4dFJlbmRlcmVyOiBUZXh0UmVuZGVyZXIgfCBudWxsID0gbnVsbCxcbik6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgIGlmICghdGV4dFJlbmRlcmVyKSB0ZXh0UmVuZGVyZXIgPSBvYnNpZGlhbk1hcmtkb3duUmVuZGVyZXI7XG4gICAgY29uc3QgbGk6IEhUTUxMSUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIHJlbmRlckRldGFpbHMucGFyZW50VWxFbGVtZW50LmFwcGVuZENoaWxkKGxpKTtcblxuICAgIGxpLmNsYXNzTGlzdC5hZGQoJ3Rhc2stbGlzdC1pdGVtJywgJ3BsdWdpbi10YXNrcy1saXN0LWl0ZW0nKTtcblxuICAgIC8vIE1haW50ZW5hbmNlIG5vdGU6XG4gICAgLy8gIFdlIGRvbid0IHVzZSB0aGUgT2JzaWRpYW4gY29udmVuaWVuY2UgZnVuY3Rpb24gbGkuY3JlYXRlRWwoKSBoZXJlLCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgaXQgYXZhaWxhYmxlXG4gICAgLy8gIHdoZW4gcnVubmluZyB0ZXN0cywgYW5kIHdlIHdhbnQgdGhlIHRlc3RzIHRvIGJlIGFibGUgdG8gY3JlYXRlIHRoZSBmdWxsIGRpdiBhbmQgc3BhbiBzdHJ1Y3R1cmUsXG4gICAgLy8gIHNvIGhhZCB0byBjb252ZXJ0IGFsbCBvZiB0aGVzZSB0byB0aGUgZXF1aXZhbGVudCBidXQgbW9yZSBlbGFib3JhdGUgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgpIGFuZFxuICAgIC8vICBhcHBlbmRDaGlsZCgpIGNhbGxzLlxuXG4gICAgY29uc3QgdGV4dFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgbGkuYXBwZW5kQ2hpbGQodGV4dFNwYW4pO1xuICAgIHRleHRTcGFuLmNsYXNzTGlzdC5hZGQoJ3Rhc2tzLWxpc3QtdGV4dCcpO1xuICAgIGF3YWl0IHRhc2tUb0h0bWwodGFzaywgcmVuZGVyRGV0YWlscywgdGV4dFNwYW4sIHRleHRSZW5kZXJlcik7XG5cbiAgICAvLyBOT1RFOiB0aGlzIGFyZWEgaXMgbWVudGlvbmVkIGluIGBDT05UUklCVVRJTkcubWRgIHVuZGVyIFwiSG93IGRvZXMgVGFza3MgaGFuZGxlIHN0YXR1cyBjaGFuZ2VzXCIuIFdoZW5cbiAgICAvLyBtb3ZpbmcgdGhlIGNvZGUsIHJlbWVtYmVyIHRvIHVwZGF0ZSB0aGF0IHJlZmVyZW5jZSB0b28uXG4gICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGxpLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgICBjaGVja2JveC5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbS1jaGVja2JveCcpO1xuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgIGlmICh0YXNrLnN0YXR1cy5zeW1ib2wgIT09ICcgJykge1xuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCgnaXMtY2hlY2tlZCcpO1xuICAgIH1cblxuICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEl0IGlzIHJlcXVpcmVkIHRvIHN0b3AgcHJvcGFnYXRpb24gc28gdGhhdCBvYnNpZGlhbiB3b24ndCB3cml0ZSB0aGUgZmlsZSB3aXRoIHRoZVxuICAgICAgICAvLyBjaGVja2JveCAodW4pY2hlY2tlZC4gT2JzaWRpYW4gd291bGQgd3JpdGUgYWZ0ZXIgdXMgYW5kIG92ZXJ3cml0ZSBvdXIgY2hhbmdlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAvLyBTaG91bGQgYmUgcmUtcmVuZGVyZWQgYXMgZW5hYmxlZCBhZnRlciB1cGRhdGUgaW4gZmlsZS5cbiAgICAgICAgY2hlY2tib3guZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0b2dnbGVkVGFza3MgPSB0YXNrLnRvZ2dsZSgpO1xuICAgICAgICByZXBsYWNlVGFza1dpdGhUYXNrcyh7XG4gICAgICAgICAgICBvcmlnaW5hbFRhc2s6IHRhc2ssXG4gICAgICAgICAgICBuZXdUYXNrczogdG9nZ2xlZFRhc2tzLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxpLnByZXBlbmQoY2hlY2tib3gpO1xuXG4gICAgLy8gU2V0IHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBzdG9jayBvYnNpZGlhbiBsaXN0czpcbiAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGFzaycsIHRhc2suc3RhdHVzLnN5bWJvbC50cmltKCkpOyAvLyBUcmltIHRvIGVuc3VyZSBlbXB0eSBhdHRyaWJ1dGUgZm9yIHNwYWNlLiBTYW1lIHdheSBhcyBvYnNpZGlhbi5cbiAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZScsIHJlbmRlckRldGFpbHMubGlzdEluZGV4LnRvU3RyaW5nKCkpO1xuICAgIGNoZWNrYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1saW5lJywgcmVuZGVyRGV0YWlscy5saXN0SW5kZXgudG9TdHJpbmcoKSk7XG5cbiAgICBpZiAocmVuZGVyRGV0YWlscy5sYXlvdXRPcHRpb25zPy5zaG9ydE1vZGUpIHtcbiAgICAgICAgYWRkVG9vbHRpcCh7IHRhc2ssIGVsZW1lbnQ6IHRleHRTcGFuLCBpc0ZpbGVuYW1lVW5pcXVlOiByZW5kZXJEZXRhaWxzLmlzRmlsZW5hbWVVbmlxdWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0YXNrVG9IdG1sKFxuICAgIHRhc2s6IFRhc2ssXG4gICAgcmVuZGVyRGV0YWlsczogVGFza0xpbmVSZW5kZXJEZXRhaWxzLFxuICAgIHBhcmVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgIHRleHRSZW5kZXJlcjogVGV4dFJlbmRlcmVyLFxuKSB7XG4gICAgbGV0IHRhc2tBc1N0cmluZyA9ICcnO1xuICAgIGNvbnN0IHRhc2tMYXlvdXQgPSBuZXcgVGFza0xheW91dChyZW5kZXJEZXRhaWxzLmxheW91dE9wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIHRhc2tMYXlvdXQubGF5b3V0Q29tcG9uZW50cykge1xuICAgICAgICBsZXQgY29tcG9uZW50U3RyaW5nID0gdGFzay5jb21wb25lbnRUb1N0cmluZyh0YXNrTGF5b3V0LCBjb21wb25lbnQpO1xuICAgICAgICBpZiAoY29tcG9uZW50U3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnZGVzY3JpcHRpb24nKSBjb21wb25lbnRTdHJpbmcgPSByZW1vdmVHbG9iYWxGaWx0ZXJJZk5lZWRlZChjb21wb25lbnRTdHJpbmcpO1xuICAgICAgICAgICAgdGFza0FzU3RyaW5nICs9IGNvbXBvbmVudFN0cmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHJlbmRlckNvbXBvbmVudFRleHQocGFyZW50RWxlbWVudCwgdGFza0FzU3RyaW5nLCAnZGVzY3JpcHRpb24nLCB0YXNrLCB0ZXh0UmVuZGVyZXIpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJDb21wb25lbnRUZXh0KFxuICAgIHNwYW46IEhUTUxTcGFuRWxlbWVudCxcbiAgICBjb21wb25lbnRTdHJpbmc6IHN0cmluZyxcbiAgICBjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQsXG4gICAgdGFzazogVGFzayxcbiAgICB0ZXh0UmVuZGVyZXI6IFRleHRSZW5kZXJlcixcbikge1xuICAgIGlmIChjb21wb25lbnQgPT09ICdkZXNjcmlwdGlvbicpIHtcbiAgICAgICAgYXdhaXQgdGV4dFJlbmRlcmVyKGNvbXBvbmVudFN0cmluZywgc3BhbiwgdGFzay5wYXRoKTtcblxuICAgICAgICAvLyBJZiB0aGUgdGFzayBpcyBhIGJsb2NrIHF1b3RlLCB0aGUgYmxvY2sgcXVvdGUgd3JhcHMgdGhlIHAtdGFnIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB1bndyYXAgdGhlIHAtdGFnICppbnNpZGUqIHRoZSBzdXJyb3VuZGluZyBibG9jayBxdW90ZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB1bndyYXAgdGhlIHAtdGFnIGFzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIHNwYW4uXG4gICAgICAgIGNvbnN0IGJsb2NrUXVvdGUgPSBzcGFuLnF1ZXJ5U2VsZWN0b3IoJ2Jsb2NrcXVvdGUnKTtcbiAgICAgICAgY29uc3QgZGlyZWN0UGFyZW50T2ZQVGFnID0gYmxvY2tRdW90ZSA/PyBzcGFuO1xuXG4gICAgICAgIC8vIFVud3JhcCB0aGUgcC10YWcgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgTWFya2Rvd25SZW5kZXJlcjpcbiAgICAgICAgY29uc3QgcEVsZW1lbnQgPSBkaXJlY3RQYXJlbnRPZlBUYWcucXVlcnlTZWxlY3RvcigncCcpO1xuICAgICAgICBpZiAocEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlIChwRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0UGFyZW50T2ZQVGFnLmluc2VydEJlZm9yZShwRWxlbWVudC5maXJzdENoaWxkLCBwRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbiBlbXB0eSB0cmFpbGluZyBwLXRhZyB0aGF0IHRoZSBNYXJrZG93blJlbmRlcmVyIGFwcGVuZHMgd2hlbiB0aGVyZSBpcyBhIGJsb2NrIGxpbms6XG4gICAgICAgIHNwYW4ucXVlcnlTZWxlY3RvckFsbCgncCcpLmZvckVhY2goKHBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBFbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIHBFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZvb3Rub3RlIHRoYXQgdGhlIE1hcmtkb3duUmVuZGVyZXIgYXBwZW5kcyB3aGVuIHRoZXJlIGlzIGEgZm9vdG5vdGUgaW4gdGhlIHRhc2s6XG4gICAgICAgIHNwYW4ucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rub3RlcycpLmZvckVhY2goKGZvb3Rub3RlRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZm9vdG5vdGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvbXBvbmVudFN0cmluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRvb2x0aXAoe1xuICAgIHRhc2ssXG4gICAgZWxlbWVudCxcbiAgICBpc0ZpbGVuYW1lVW5pcXVlLFxufToge1xuICAgIHRhc2s6IFRhc2s7XG4gICAgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgaXNGaWxlbmFtZVVuaXF1ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn0pOiB2b2lkIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBlbGVtZW50LmNyZWF0ZURpdigpO1xuICAgICAgICB0b29sdGlwLmFkZENsYXNzZXMoWyd0b29sdGlwJywgJ21vZC1yaWdodCddKTtcblxuICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCByZWN1cnJlbmNlRGl2ID0gdG9vbHRpcC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgIHJlY3VycmVuY2VEaXYuc2V0VGV4dChgJHt0YXNrTW9kdWxlLnJlY3VycmVuY2VTeW1ib2x9ICR7dGFzay5yZWN1cnJlbmNlLnRvVGV4dCgpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2suc3RhcnREYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydERhdGVEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgc3RhcnREYXRlRGl2LnNldFRleHQoXG4gICAgICAgICAgICAgICAgdG9Ub29sdGlwRGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmllcjogdGFza01vZHVsZS5zdGFydERhdGVTeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHRhc2suc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLnNjaGVkdWxlZERhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZERhdGVEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgIHRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpZXI6IHRhc2tNb2R1bGUuc2NoZWR1bGVkRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGFzay5zY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLmR1ZURhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1ZURhdGVEaXYgPSB0b29sdGlwLmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgZHVlRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgIHRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpZXI6IHRhc2tNb2R1bGUuZHVlRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGFzay5kdWVEYXRlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLmRvbmVEYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lRGF0ZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICBkb25lRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgIHRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpZXI6IHRhc2tNb2R1bGUuZG9uZURhdGVTeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHRhc2suZG9uZURhdGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlua1RleHQgPSB0YXNrLmdldExpbmtUZXh0KHsgaXNGaWxlbmFtZVVuaXF1ZSB9KTtcbiAgICAgICAgaWYgKGxpbmtUZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrbGlua0RpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICBiYWNrbGlua0Rpdi5zZXRUZXh0KGBcdUQ4M0RcdUREMTcgJHtsaW5rVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0b1Rvb2x0aXBEYXRlKHsgc2lnbmlmaWVyLCBkYXRlIH06IHsgc2lnbmlmaWVyOiBzdHJpbmc7IGRhdGU6IE1vbWVudCB9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7c2lnbmlmaWVyfSAke2RhdGUuZm9ybWF0KHRhc2tNb2R1bGUuVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX0gKCR7ZGF0ZS5mcm9tKFxuICAgICAgICB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5JyksXG4gICAgKX0pYDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlR2xvYmFsRmlsdGVySWZOZWVkZWQoZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyLCByZW1vdmVHbG9iYWxGaWx0ZXIgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgaWYgKHJlbW92ZUdsb2JhbEZpbHRlcikge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24ucmVwbGFjZShnbG9iYWxGaWx0ZXIsICcnKS50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbn1cbiIsICJpbXBvcnQgeyBNZXRhZGF0YUNhY2hlLCBURmlsZSwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IExpc3RJdGVtQ2FjaGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxubGV0IG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGUgfCB1bmRlZmluZWQ7XG5sZXQgdmF1bHQ6IFZhdWx0IHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUZpbGUgPSAoe1xuICAgIG1ldGFkYXRhQ2FjaGU6IG5ld01ldGFkYXRhQ2FjaGUsXG4gICAgdmF1bHQ6IG5ld1ZhdWx0LFxufToge1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgdmF1bHQ6IFZhdWx0O1xufSkgPT4ge1xuICAgIG1ldGFkYXRhQ2FjaGUgPSBuZXdNZXRhZGF0YUNhY2hlO1xuICAgIHZhdWx0ID0gbmV3VmF1bHQ7XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBvcmlnaW5hbCB0YXNrIHdpdGggb25lIG9yIG1vcmUgbmV3IHRhc2tzLlxuICpcbiAqIElmIHlvdSBwYXNzIG1vcmUgdGhhbiBvbmUgcmVwbGFjZW1lbnQgdGFzaywgYWxsIHN1YnNlcXVlbnQgdGFza3MgaW4gdGhlIHNhbWVcbiAqIHNlY3Rpb24gbXVzdCBiZSByZS1yZW5kZXJlZCwgYXMgdGhlaXIgc2VjdGlvbiBpbmRleGVzIGNoYW5nZS4gQXNzdW1pbmcgdGhhdFxuICogdGhpcyBpcyBkb25lIGZhc3RlciB0aGFuIHVzZXIgaW50ZXJhY3Rpb24gaW4gcHJhY3RpY2UuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlVGFza1dpdGhUYXNrcyA9IGFzeW5jICh7XG4gICAgb3JpZ2luYWxUYXNrLFxuICAgIG5ld1Rhc2tzLFxufToge1xuICAgIG9yaWdpbmFsVGFzazogVGFzaztcbiAgICBuZXdUYXNrczogVGFzayB8IFRhc2tbXTtcbn0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAodmF1bHQgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza3M6IGNhbm5vdCB1c2UgRmlsZSBiZWZvcmUgaW5pdGlhbGl6aW5nIGl0LicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld1Rhc2tzKSkge1xuICAgICAgICBuZXdUYXNrcyA9IFtuZXdUYXNrc107XG4gICAgfVxuXG4gICAgdHJ5UmVwZXRpdGl2ZSh7XG4gICAgICAgIG9yaWdpbmFsVGFzayxcbiAgICAgICAgbmV3VGFza3MsXG4gICAgICAgIHZhdWx0LFxuICAgICAgICBtZXRhZGF0YUNhY2hlLFxuICAgICAgICBwcmV2aW91c1RyaWVzOiAwLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0byByZS10cnkgd2hlbiB0aGUgcmV0dXJuZWQgZmlsZSBjYWNoZSBpcyBgdW5kZWZpbmVkYC5cbiAqIFJldHJ5aW5nIGFmdGVyIGEgd2hpbGUgbWF5IHJldHVybiBhIHZhbGlkIGZpbGUgY2FjaGUuXG4gKiBSZXBvcnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzg3XG4gKi9cbmNvbnN0IHRyeVJlcGV0aXRpdmUgPSBhc3luYyAoe1xuICAgIG9yaWdpbmFsVGFzayxcbiAgICBuZXdUYXNrcyxcbiAgICB2YXVsdCxcbiAgICBtZXRhZGF0YUNhY2hlLFxuICAgIHByZXZpb3VzVHJpZXMsXG59OiB7XG4gICAgb3JpZ2luYWxUYXNrOiBUYXNrO1xuICAgIG5ld1Rhc2tzOiBUYXNrW107XG4gICAgdmF1bHQ6IFZhdWx0O1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgcHJldmlvdXNUcmllczogbnVtYmVyO1xufSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXNUcmllcyA+IDEwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrczogVG9vIG1hbnkgcmV0cmllcy4gRmlsZSB1cGRhdGUgbm90IHBvc3NpYmxlIC4uLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZW91dCA9IE1hdGgubWluKE1hdGgucG93KDEwLCBwcmV2aW91c1RyaWVzKSwgMTAwKTsgLy8gMSwgMTAsIDEwMCwgMTAwLCAxMDAsIC4uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRyeVJlcGV0aXRpdmUoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzayxcbiAgICAgICAgICAgICAgICBuZXdUYXNrcyxcbiAgICAgICAgICAgICAgICB2YXVsdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVHJpZXM6IHByZXZpb3VzVHJpZXMgKyAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9yaWdpbmFsVGFzay5wYXRoKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGFza3M6IE5vIGZpbGUgZm91bmQgZm9yIHRhc2sgJHtvcmlnaW5hbFRhc2suZGVzY3JpcHRpb259LiBSZXRyeWluZyAuLi5gKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5KCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGUuZXh0ZW5zaW9uICE9PSAnbWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tzOiBPbmx5IHN1cHBvcnRpbmcgZmlsZXMgd2l0aCB0aGUgLm1kIGZpbGUgZXh0ZW5zaW9uLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZUNhY2hlID0gbWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgaWYgKGZpbGVDYWNoZSA9PSB1bmRlZmluZWQgfHwgZmlsZUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGFza3M6IE5vIGZpbGUgY2FjaGUgZm91bmQgZm9yIGZpbGUgJHtmaWxlLnBhdGh9LiBSZXRyeWluZyAuLi5gKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdEl0ZW1zQ2FjaGUgPSBmaWxlQ2FjaGUubGlzdEl0ZW1zO1xuICAgIGlmIChsaXN0SXRlbXNDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IGxpc3RJdGVtc0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRhc2tzOiBObyBsaXN0IGl0ZW1zIGZvdW5kIGluIGZpbGUgY2FjaGUgb2YgJHtmaWxlLnBhdGh9LiBSZXRyeWluZyAuLi5gKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB2YXVsdC5yZWFkKGZpbGUpO1xuICAgIGNvbnN0IGZpbGVMaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcblxuICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgIGxldCBsaXN0SXRlbTogTGlzdEl0ZW1DYWNoZSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgc2VjdGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxpc3RJdGVtQ2FjaGUgb2YgbGlzdEl0ZW1zQ2FjaGUpIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtQ2FjaGUucG9zaXRpb24uc3RhcnQubGluZSA8IG9yaWdpbmFsVGFzay5zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RJdGVtQ2FjaGUudGFzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBmaWxlTGluZXNbbGlzdEl0ZW1DYWNoZS5wb3NpdGlvbi5zdGFydC5saW5lXTtcblxuICAgICAgICBpZiAobGluZS5pbmNsdWRlcyhnbG9iYWxGaWx0ZXIpKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbkluZGV4ID09PSBvcmlnaW5hbFRhc2suc2VjdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gPSBsaXN0SXRlbUNhY2hlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGlzdEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrczogY291bGQgbm90IGZpbmQgdGFzayB0byB0b2dnbGUgaW4gdGhlIGZpbGUuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkRmlsZUxpbmVzID0gW1xuICAgICAgICAuLi5maWxlTGluZXMuc2xpY2UoMCwgbGlzdEl0ZW0ucG9zaXRpb24uc3RhcnQubGluZSksXG4gICAgICAgIC4uLm5ld1Rhc2tzLm1hcCgodGFzazogVGFzaykgPT4gdGFzay50b0ZpbGVMaW5lU3RyaW5nKCkpLFxuICAgICAgICAuLi5maWxlTGluZXMuc2xpY2UobGlzdEl0ZW0ucG9zaXRpb24uc3RhcnQubGluZSArIDEpLCAvLyBPbmx5IHN1cHBvcnRzIHNpbmdsZS1saW5lIHRhc2tzLlxuICAgIF07XG5cbiAgICBhd2FpdCB2YXVsdC5tb2RpZnkoZmlsZSwgdXBkYXRlZEZpbGVMaW5lcy5qb2luKCdcXG4nKSk7XG59O1xuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50L21vbWVudCc7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG4vKipcbiAqIEltcGxlbWVudCBkYXRlIGZyb20gcGF0aCBkZXRlY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGVGYWxsYmFjayB7XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBwYXJzZSB0aGUgZmlsZW5hbWUgdG8gZXh0cmFjdCBhIGRhdGUgdGFraW5nIHVzZXIgc2V0dGluZ3MgaW50byBhY2NvdW50LiBJZiBkYXRlIGluZmVyZW5jZSBpcyBub3RcbiAgICAgKiBlbmFibGVkIHBhcnNpbmcgaXMgYnlwYXNzZWQgYW5kIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZVxuICAgICAqIEByZXR1cm4gYSBNb21lbnQgb3IgbnVsbCBpZiBubyBkYXRlIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21QYXRoKHBhdGg6IHN0cmluZyk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCB7IHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlLCBmaWxlbmFtZUFzRGF0ZUZvbGRlcnMgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgLy8gZmVhdHVyZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlc0FueUZvbGRlcihmaWxlbmFtZUFzRGF0ZUZvbGRlcnMsIHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBmaWxlIGlzIG5vdCBpbiBhbnkgZm9sZGVyIG9yIHN1YmZvbGRlciB0aGF0IHdhcyBzZWxlY3RlZCBmb3IgZGF0ZSBpbmZlcmVuY2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGVGcm9tUGF0aChwYXRoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYXRjaGVzQW55Rm9sZGVyKGZvbGRlcnM6IHN0cmluZ1tdLCBwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGZvbGRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBubyBjb25zdHJhaW50cyBvbiBtYXRjaGluZyBmb2xkZXJzXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvbGRlcnMgbmV2ZXIgZW5kIHdpdGggYSAnLycsIGFuZCBwYXRocyBjb250YWluIGF0IGxlYXN0IG9uIHNsYXNoIChzZXBhcmF0aW5nIHRoZSBmb2xkZXIgZnJvbSB0aGVcbiAgICAgICAgLy8gZmlsZW5hbWUpXG4gICAgICAgIHJldHVybiBmb2xkZXJzLnNvbWUoKGZvbGRlcikgPT4gcGF0aC5zdGFydHNXaXRoKGZvbGRlciArICcvJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGV4dHJhY3REYXRlRnJvbVBhdGgocGF0aDogc3RyaW5nKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gTWF0aC5tYXgoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb3MgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLnN1YnN0cmluZyhmaXJzdFBvcywgbGFzdFBvcyk7XG5cbiAgICAgICAgbGV0IGRhdGVNYXRjaCA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KS8uZXhlYyhiYXNlbmFtZSk7XG4gICAgICAgIGlmICghZGF0ZU1hdGNoKSBkYXRlTWF0Y2ggPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pLy5leGVjKGJhc2VuYW1lKTtcblxuICAgICAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gd2luZG93Lm1vbWVudChbcGFyc2VJbnQoZGF0ZU1hdGNoWzFdKSwgcGFyc2VJbnQoZGF0ZU1hdGNoWzJdKSAtIDEsIHBhcnNlSW50KGRhdGVNYXRjaFszXSldKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWZmIGEgZmFsbGJhY2sgY2FuIGJlIHNldFxuICAgICAqKi9cbiAgICBwdWJsaWMgc3RhdGljIGNhbkFwcGx5RmFsbGJhY2soe1xuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgfToge1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3RhcnREYXRlID09PSBudWxsICYmIGR1ZURhdGUgPT09IG51bGwgJiYgc2NoZWR1bGVkRGF0ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdGhlIGxvZ2ljIHRvIHVwZGF0ZSB0aGUgZmllbGRzIHJlbGF0ZWQgdG8gZGF0ZSBmYWxsYmFjayBvZiBhIHRhc2sgd2hlbiBpdHMgZmlsZSBoYXMgbW92ZWRcbiAgICAgKiBAcGFyYW0gdGFzayAgICAgICAgIC0gdGFzayB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gbmV3UGF0aCAgICAgIC0gbmV3IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIGZhbGxiYWNrRGF0ZSAtIGZhbGxiYWNrIGRhdGUgZnJvbSBuZXcgbG9jYXRpb24sIGZvciBlZmZpY2llbmN5LiBDYW4gYmUgbnVsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlVGFza1BhdGgodGFzazogVGFzaywgbmV3UGF0aDogc3RyaW5nLCBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGwpOiBUYXNrIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB3aXRoIHZhbHVlcyBmcm9tIGJlZm9yZSB0aGUgcGF0aCB3YXMgY2hhbmdlZFxuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZSA9IHRhc2suc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gdGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZDtcblxuICAgICAgICBpZiAoZmFsbGJhY2tEYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggZG9lc24ndCBjb250YWluIGEgZGF0ZS4uLlxuXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhlIHByZXZpb3VzIHBhdGggaGFkIG9uZSA6IHJlbW92ZSBpbmZlcnJlZCBkYXRlIGZyb20gVGFza1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB0aGUgb2xkIHBhdGggZGlkbid0IGNvbnRhaW4gYW55IGVpdGhlciA6XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZywgYW5kIGtlZXAgYW55IGV4cGxpY2l0bHkgc2V0IHNjaGVkdWxlZCBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggY29udGFpbnMgYSBkYXRlLi4uXG5cbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCkge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB3ZSB1c2VkIHRoZSBmYWxsYmFjayBkYXRlIGZyb20gdGhlIHByZXZpb3VzIHBhdGggOlxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgbmV3IHBhdGhcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gZmFsbGJhY2tEYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbkFwcGx5RmFsbGJhY2sodGFzaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5hbmQgdGhlIHRhc2sgaXMgY2FuZGlkYXRlIHRvIGRhdGUgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBzZXN0IHRoZSBzY2hlZHVsZWQgZGF0ZSBmcm9tIHRoZSBuZXcgcGF0aFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUgPSBmYWxsYmFja0RhdGU7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBleGlzdGluZyBkYXRlcywgaW5jbHVkaW5nIGV4cGxpY2l0IHNjaGVkdWxlZERhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50YXNrLFxuICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFycmF5IG9mIHVwZGF0ZWQgdGFza3MgdG8gcmVtb3ZlIHRoZSBpbmZlcnJlZCBzY2hlZHVsZWQgZGF0ZSBzdGF0dXMgaWYgdGhlIHNjaGVkdWxlZCBkYXRlIGhhcyBiZWVuXG4gICAgICogbW9kaWZpZWQgYXMgY29tcGFyZWQgdG8gdGhlIG9yaWdpbmFsIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUluZmVycmVkU3RhdHVzSWZOZWVkZWQob3JpZ2luYWxUYXNrOiBUYXNrLCB1cGRhdGVkVGFza3M6IFRhc2tbXSk6IFRhc2tbXSB7XG4gICAgICAgIGNvbnN0IGluZmVycmVkU2NoZWR1bGVkRGF0ZSA9IG9yaWdpbmFsVGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZCA/IG9yaWdpbmFsVGFzay5zY2hlZHVsZWREYXRlIDogbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlZFRhc2tzLm1hcCgodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgaWYgKGluZmVycmVkU2NoZWR1bGVkRGF0ZSAhPT0gbnVsbCAmJiAhaW5mZXJyZWRTY2hlZHVsZWREYXRlLmlzU2FtZSh0YXNrLnNjaGVkdWxlZERhdGUsICdkYXknKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgZmFsbGJhY2sgZGF0ZSB3YXMgdXNlZCBiZWZvcmUgbW9kaWZpY2F0aW9uLCBhbmQgdGhlIHNjaGVkdWxlZCBkYXRlIHdhcyBtb2RpZmllZCwgd2UgaGF2ZSB0byBtYXJrXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNjaGVkdWxlZCBkYXRlIGFzIG5vdCBpbmZlcnJlZCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHRhc2sgPSBuZXcgVGFzayh7IC4uLnRhc2ssIHNjaGVkdWxlZERhdGVJc0luZmVycmVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBMYXlvdXRPcHRpb25zLCBUYXNrTGF5b3V0IH0gZnJvbSAnLi9UYXNrTGF5b3V0JztcbmltcG9ydCB0eXBlIHsgVGFza0xheW91dENvbXBvbmVudCB9IGZyb20gJy4vVGFza0xheW91dCc7XG5pbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi9SZWN1cnJlbmNlJztcbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB0eXBlIHsgU3RhdHVzIH0gZnJvbSAnLi9TdGF0dXMnO1xuaW1wb3J0IHsgVXJnZW5jeSB9IGZyb20gJy4vVXJnZW5jeSc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL1F1ZXJ5L0ZpbHRlci9EYXRlRmllbGQnO1xuaW1wb3J0IHsgcmVuZGVyVGFza0xpbmUgfSBmcm9tICcuL1Rhc2tMaW5lUmVuZGVyZXInO1xuaW1wb3J0IHR5cGUgeyBUYXNrTGluZVJlbmRlckRldGFpbHMgfSBmcm9tICcuL1Rhc2tMaW5lUmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi9EYXRlRmFsbGJhY2snO1xuaW1wb3J0ICogYXMgUmVnRXhwVG9vbHMgZnJvbSAnLi9saWIvUmVnRXhwVG9vbHMnO1xuXG4vKipcbiAqIFdoZW4gc29ydGluZywgbWFrZSBzdXJlIGxvdyBhbHdheXMgY29tZXMgYWZ0ZXIgbm9uZS4gVGhpcyB3YXkgYW55IHRhc2tzIHdpdGggbG93IHdpbGwgYmUgYmVsb3cgYW55IGV4aXRpbmdcbiAqIHRhc2tzIHRoYXQgaGF2ZSBubyBwcmlvcml0eSB3aGljaCB3b3VsZCBiZSB0aGUgZGVmYXVsdC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZW51bSBQcmlvcml0eSB7XG4gICAgSGlnaCA9ICcxJyxcbiAgICBNZWRpdW0gPSAnMicsXG4gICAgTm9uZSA9ICczJyxcbiAgICBMb3cgPSAnNCcsXG59XG5cbmV4cG9ydCBjb25zdCBwcmlvcml0eVN5bWJvbHMgPSB7XG4gICAgSGlnaDogJ1x1MjNFQicsXG4gICAgTWVkaXVtOiAnXHVEODNEXHVERDNDJyxcbiAgICBMb3c6ICdcdUQ4M0RcdUREM0QnLFxuICAgIE5vbmU6ICcnLFxufTtcblxuZXhwb3J0IGNvbnN0IHJlY3VycmVuY2VTeW1ib2wgPSAnXHVEODNEXHVERDAxJztcbmV4cG9ydCBjb25zdCBzdGFydERhdGVTeW1ib2wgPSAnXHVEODNEXHVERUVCJztcbmV4cG9ydCBjb25zdCBzY2hlZHVsZWREYXRlU3ltYm9sID0gJ1x1MjNGMyc7XG5leHBvcnQgY29uc3QgZHVlRGF0ZVN5bWJvbCA9ICdcdUQ4M0RcdURDQzUnO1xuZXhwb3J0IGNvbnN0IGRvbmVEYXRlU3ltYm9sID0gJ1x1MjcwNSc7XG5cbmV4cG9ydCBjbGFzcyBUYXNrUmVndWxhckV4cHJlc3Npb25zIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRhdGVGb3JtYXQgPSAnWVlZWS1NTS1ERCc7XG5cbiAgICAvLyBNYXRjaGVzIGluZGVudGF0aW9uIGJlZm9yZSBhIGxpc3QgbWFya2VyIChpbmNsdWRpbmcgPiBmb3IgcG90ZW50aWFsbHkgbmVzdGVkIGJsb2NrcXVvdGVzIG9yIE9ic2lkaWFuIGNhbGxvdXRzKVxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaW5kZW50YXRpb25SZWdleCA9IC9eKFtcXHNcXHQ+XSopLztcblxuICAgIC8vIE1hdGNoZXMgLSBvciAqIGxpc3QgbWFya2Vycywgb3IgbnVtYmVyZWQgbGlzdCBtYXJrZXJzIChlZyAxLilcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGxpc3RNYXJrZXJSZWdleCA9IC8oWy0qXXxbMC05XStcXC4pLztcblxuICAgIC8vIE1hdGNoZXMgYSBjaGVja2JveCBhbmQgc2F2ZXMgdGhlIHN0YXR1cyBjaGFyYWN0ZXIgaW5zaWRlXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBjaGVja2JveFJlZ2V4ID0gL1xcWyguKVxcXS91O1xuXG4gICAgLy8gTWF0Y2hlcyB0aGUgcmVzdCBvZiB0aGUgdGFzayBhZnRlciB0aGUgY2hlY2tib3guXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBhZnRlckNoZWNrYm94UmVnZXggPSAvICooLiopL3U7XG5cbiAgICAvLyBNYWluIHJlZ2V4IGZvciBwYXJzaW5nIGEgbGluZS4gSXQgbWF0Y2hlcyB0aGUgZm9sbG93aW5nOlxuICAgIC8vIC0gSW5kZW50YXRpb25cbiAgICAvLyAtIExpc3QgbWFya2VyXG4gICAgLy8gLSBTdGF0dXMgY2hhcmFjdGVyXG4gICAgLy8gLSBSZXN0IG9mIHRhc2sgYWZ0ZXIgY2hlY2tib3ggbWFya2Rvd25cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRhc2tSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaW5kZW50YXRpb25SZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0TWFya2VyUmVnZXguc291cmNlICtcbiAgICAgICAgICAgICcgKycgK1xuICAgICAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5jaGVja2JveFJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmFmdGVyQ2hlY2tib3hSZWdleC5zb3VyY2UsXG4gICAgICAgICd1JyxcbiAgICApO1xuXG4gICAgLy8gVXNlZCB3aXRoIHRoZSBcIkNyZWF0ZSBvciBFZGl0IFRhc2tcIiBjb21tYW5kIHRvIHBhcnNlIGluZGVudGF0aW9uIGFuZCBzdGF0dXMgaWYgcHJlc2VudFxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbm9uVGFza1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5pbmRlbnRhdGlvblJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RNYXJrZXJSZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgJz8gKignICtcbiAgICAgICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuY2hlY2tib3hSZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgJyk/JyArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmFmdGVyQ2hlY2tib3hSZWdleC5zb3VyY2UsXG4gICAgICAgICd1JyxcbiAgICApO1xuXG4gICAgLy8gVXNlZCB3aXRoIFwiVG9nZ2xlIERvbmVcIiBjb21tYW5kIHRvIGRldGVjdCBhIGxpc3QgaXRlbSB0aGF0IGNhbiBnZXQgYSBjaGVja2JveCBhZGRlZCB0byBpdC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGxpc3RJdGVtUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmluZGVudGF0aW9uUmVnZXguc291cmNlICsgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0TWFya2VyUmVnZXguc291cmNlLFxuICAgICk7XG5cbiAgICAvLyBNYXRjaCBvbiBibG9jayBsaW5rIGF0IGVuZC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJsb2NrTGlua1JlZ2V4ID0gLyBcXF5bYS16QS1aMC05LV0rJC91O1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCdzIGVuZCB3aXRoIGAkYCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIGFuZFxuICAgIC8vIHJlbW92ZWQgZnJvbSB0aGUgZW5kIHVudGlsIG5vbmUgYXJlIGxlZnQuXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBwcmlvcml0eVJlZ2V4ID0gLyhbXHUyM0VCXHVEODNEXHVERDNDXHVEODNEXHVERDNEXSkkL3U7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdGFydERhdGVSZWdleCA9IC9cdUQ4M0RcdURFRUIgKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3U7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzY2hlZHVsZWREYXRlUmVnZXggPSAvW1x1MjNGM1x1MjMxQl0gKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3U7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkdWVEYXRlUmVnZXggPSAvW1x1RDgzRFx1RENDNVx1RDgzRFx1RENDNlx1RDgzRFx1REREM10gKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3U7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkb25lRGF0ZVJlZ2V4ID0gL1x1MjcwNSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHJlY3VycmVuY2VSZWdleCA9IC9cdUQ4M0RcdUREMDEgPyhbYS16QS1aMC05LCAhXSspJC9pdTtcblxuICAgIC8vIFJlZ2V4IHRvIG1hdGNoIGFsbCBoYXNoIHRhZ3MsIGJhc2ljYWxseSBoYXNoIGZvbGxvd2VkIGJ5IGFueXRoaW5nIGJ1dCB0aGUgY2hhcmFjdGVycyBpbiB0aGUgbmVnYXRpb24uXG4gICAgLy8gVG8gZW5zdXJlIFVSTHMgYXJlIG5vdCBjYXVnaHQgaXQgaXMgbG9va2luZyBvZiBiZWdpbm5pbmcgb2Ygc3RyaW5nIHRhZyBhbmQgYW55XG4gICAgLy8gdGFnIHRoYXQgaGFzIGEgc3BhY2UgaW4gZnJvbnQgb2YgaXQuIEFueSAjIHRoYXQgaGFzIGEgY2hhcmFjdGVyIGluIGZyb250XG4gICAgLy8gb2YgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgIC8vIEVYQU1QTEU6XG4gICAgLy8gZGVzY3JpcHRpb246ICcjZG9nICNjYXIgaHR0cDovL3d3dy9kZGQjZXJlICNob3VzZSdcbiAgICAvLyBtYXRjaGVzOiAjZG9nLCAjY2FyLCAjaG91c2VcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhhc2hUYWdzID0gLyhefFxccykjW14gIUAjJCVeJiooKSwuP1wiOnt9fDw+XSovZztcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhhc2hUYWdzRnJvbUVuZCA9IG5ldyBSZWdFeHAodGhpcy5oYXNoVGFncy5zb3VyY2UgKyAnJCcpO1xufVxuXG4vKipcbiAqIFRhc2sgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBNYXJrRG93biB0YXNrIGFsb25nIHdpdGhcbiAqIHRoZSBleHRlbnNpb25zIHByb3ZpZGVkIGJ5IHRoaXMgcGx1Z2luLiBUaGlzIGlzIHVzZWQgdG8gcGFyc2UgYW5kXG4gKiBnZW5lcmF0ZSB0aGUgbWFya2Rvd24gdGFzayBmb3IgYWxsIHVwZGF0ZXMgYW5kIHJlcGxhY2VtZW50cy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVGFza1xuICovXG5leHBvcnQgY2xhc3MgVGFzayB7XG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXR1czogU3RhdHVzO1xuICAgIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBwYXRoOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGluZGVudGF0aW9uOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGxpc3RNYXJrZXI6IHN0cmluZztcbiAgICAvKiogTGluZSBudW1iZXIgd2hlcmUgdGhlIHNlY3Rpb24gc3RhcnRzIHRoYXQgY29udGFpbnMgdGhpcyB0YXNrLiAqL1xuICAgIHB1YmxpYyByZWFkb25seSBzZWN0aW9uU3RhcnQ6IG51bWJlcjtcbiAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBudGggdGFzayBpbiBpdHMgc2VjdGlvbi4gKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgcHVibGljIHJlYWRvbmx5IHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbDtcblxuICAgIHB1YmxpYyByZWFkb25seSB0YWdzOiBzdHJpbmdbXTtcblxuICAgIHB1YmxpYyByZWFkb25seSBwcmlvcml0eTogUHJpb3JpdHk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBkb25lRGF0ZTogTW9tZW50IHwgbnVsbDtcblxuICAgIHB1YmxpYyByZWFkb25seSByZWN1cnJlbmNlOiBSZWN1cnJlbmNlIHwgbnVsbDtcbiAgICAvKiogVGhlIGJsb2NrTGluayBpcyBhIFwiXlwiIGFubm90YXRpb24gYWZ0ZXIgdGhlIGRhdGVzL3JlY3VycmVuY2UgcnVsZXMuICovXG4gICAgcHVibGljIHJlYWRvbmx5IGJsb2NrTGluazogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBvcmlnaW5hbCBsaW5lIHJlYWQgZnJvbSBmaWxlLlxuICAgICAqXG4gICAgICogV2lsbCBiZSBlbXB0eSBpZiBUYXNrIHdhcyBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgKiAoZm9yIGV4YW1wbGUsIGJ5IENyZWF0ZSBvciBFZGl0IFRhc2ssIG9yIGluIHRlc3RzLCBpbmNsdWRpbmcgdmlhIHtAbGluayBUYXNrQnVpbGRlcn0pLiAqL1xuICAgIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbE1hcmtkb3duOiBzdHJpbmc7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQ6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF91cmdlbmN5OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgcGF0aCxcbiAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgIGxpc3RNYXJrZXIsXG4gICAgICAgIHNlY3Rpb25TdGFydCxcbiAgICAgICAgc2VjdGlvbkluZGV4LFxuICAgICAgICBwcmVjZWRpbmdIZWFkZXIsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgICAgIGRvbmVEYXRlLFxuICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICBibG9ja0xpbmssXG4gICAgICAgIHRhZ3MsXG4gICAgICAgIG9yaWdpbmFsTWFya2Rvd24sXG4gICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkLFxuICAgIH06IHtcbiAgICAgICAgc3RhdHVzOiBTdGF0dXM7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICAgIHBhdGg6IHN0cmluZztcbiAgICAgICAgaW5kZW50YXRpb246IHN0cmluZztcbiAgICAgICAgbGlzdE1hcmtlcjogc3RyaW5nO1xuICAgICAgICBzZWN0aW9uU3RhcnQ6IG51bWJlcjtcbiAgICAgICAgc2VjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgICAgIHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5O1xuICAgICAgICBzdGFydERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIGRvbmVEYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGw7XG4gICAgICAgIGJsb2NrTGluazogc3RyaW5nO1xuICAgICAgICB0YWdzOiBzdHJpbmdbXSB8IFtdO1xuICAgICAgICBvcmlnaW5hbE1hcmtkb3duOiBzdHJpbmc7XG4gICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkOiBib29sZWFuO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICB0aGlzLmxpc3RNYXJrZXIgPSBsaXN0TWFya2VyO1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHNlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWN0aW9uSW5kZXggPSBzZWN0aW9uSW5kZXg7XG4gICAgICAgIHRoaXMucHJlY2VkaW5nSGVhZGVyID0gcHJlY2VkaW5nSGVhZGVyO1xuXG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG5cbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICAgIHRoaXMuc3RhcnREYXRlID0gc3RhcnREYXRlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZERhdGUgPSBzY2hlZHVsZWREYXRlO1xuICAgICAgICB0aGlzLmR1ZURhdGUgPSBkdWVEYXRlO1xuICAgICAgICB0aGlzLmRvbmVEYXRlID0gZG9uZURhdGU7XG5cbiAgICAgICAgdGhpcy5yZWN1cnJlbmNlID0gcmVjdXJyZW5jZTtcbiAgICAgICAgdGhpcy5ibG9ja0xpbmsgPSBibG9ja0xpbms7XG4gICAgICAgIHRoaXMub3JpZ2luYWxNYXJrZG93biA9IG9yaWdpbmFsTWFya2Rvd247XG5cbiAgICAgICAgdGhpcy5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZCA9IHNjaGVkdWxlZERhdGVJc0luZmVycmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSBnaXZlbiBsaW5lIGZyb20gYSBvYnNpZGlhbiBub3RlIGFuZCByZXR1cm5zIGEgVGFzayBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSBUaGUgZnVsbCBsaW5lIGluIHRoZSBub3RlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gUGF0aCB0byB0aGUgbm90ZSBpbiBvYnNpZGlhbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VjdGlvblN0YXJ0IC0gTGluZSBudW1iZXIgd2hlcmUgdGhlIHNlY3Rpb24gc3RhcnRzIHRoYXQgY29udGFpbnMgdGhpcyB0YXNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZWN0aW9uSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG50aCB0YXNrIGluIGl0cyBzZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IG51bGwpfSBwcmVjZWRpbmdIZWFkZXIgLSBUaGUgaGVhZGVyIGJlZm9yZSB0aGlzIHRhc2suXG4gICAgICogQHBhcmFtIHsoTW9tZW50IHwgbnVsbCl9IGZhbGxiYWNrRGF0ZSAtIFRoZSBkYXRlIHRvIHVzZSBhcyB0aGUgc2NoZWR1bGVkIGRhdGUgaWYgbm8gb3RoZXIgZGF0ZSBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHsqfSAgeyhUYXNrIHwgbnVsbCl9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21MaW5lKHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc2VjdGlvblN0YXJ0LFxuICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgIHByZWNlZGluZ0hlYWRlcixcbiAgICAgICAgZmFsbGJhY2tEYXRlLFxuICAgIH06IHtcbiAgICAgICAgbGluZTogc3RyaW5nO1xuICAgICAgICBwYXRoOiBzdHJpbmc7XG4gICAgICAgIHNlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgICAgICBzZWN0aW9uSW5kZXg6IG51bWJlcjtcbiAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IFRhc2sgfCBudWxsIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxpbmUgdG8gc2VlIGlmIGl0IGlzIGEgbWFya2Rvd24gdGFzay5cbiAgICAgICAgY29uc3QgcmVnZXhNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgpO1xuICAgICAgICBpZiAocmVnZXhNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXRjaFs0XSBpbmNsdWRlcyB0aGUgd2hvbGUgYm9keSBvZiB0aGUgdGFzayBhZnRlciB0aGUgYnJhY2tldHMuXG4gICAgICAgIGNvbnN0IGJvZHkgPSByZWdleE1hdGNoWzRdLnRyaW0oKTtcblxuICAgICAgICAvLyByZXR1cm4gaWYgdGFzayBkb2VzIG5vdCBoYXZlIHRoZSBnbG9iYWwgZmlsdGVyLiBEbyB0aGlzIGJlZm9yZSBwcm9jZXNzaW5nXG4gICAgICAgIC8vIHJlc3Qgb2YgbWF0Y2ggdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBnbG9iYWxGaWx0ZXIgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGlmICghYm9keS5pbmNsdWRlcyhnbG9iYWxGaWx0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IGJvZHk7XG4gICAgICAgIGNvbnN0IGluZGVudGF0aW9uID0gcmVnZXhNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgbGlzdE1hcmtlciA9IHJlZ2V4TWF0Y2hbMl07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzdGF0dXMgb2YgdGhlIHRhc2suXG4gICAgICAgIGNvbnN0IHN0YXR1c1N0cmluZyA9IHJlZ2V4TWF0Y2hbM107XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuYnlTeW1ib2xPckNyZWF0ZShzdGF0dXNTdHJpbmcpO1xuXG4gICAgICAgIC8vIE1hdGNoIGZvciBibG9jayBsaW5rIGFuZCByZW1vdmUgaWYgZm91bmQuIEFsd2F5cyBleHBlY3RlZCB0byBiZVxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICBjb25zdCBibG9ja0xpbmtNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYmxvY2tMaW5rUmVnZXgpO1xuICAgICAgICBjb25zdCBibG9ja0xpbmsgPSBibG9ja0xpbmtNYXRjaCAhPT0gbnVsbCA/IGJsb2NrTGlua01hdGNoWzBdIDogJyc7XG5cbiAgICAgICAgaWYgKGJsb2NrTGluayAhPT0gJycpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmJsb2NrTGlua1JlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCBtYXRjaGluZyBhbmQgcmVtb3Zpbmcgc3BlY2lhbCBzdHJpbmdzIGZyb20gdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZGVzY3JpcHRpb24gaW4gYW55IG9yZGVyLiBUaGUgbG9vcCBzaG91bGQgb25seSBydW4gb25jZSBpZiB0aGVcbiAgICAgICAgLy8gc3RyaW5ncyBhcmUgaW4gdGhlIGV4cGVjdGVkIG9yZGVyIGFmdGVyIHRoZSBkZXNjcmlwdGlvbi5cbiAgICAgICAgbGV0IG1hdGNoZWQ6IGJvb2xlYW47XG4gICAgICAgIGxldCBwcmlvcml0eTogUHJpb3JpdHkgPSBQcmlvcml0eS5Ob25lO1xuICAgICAgICBsZXQgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGR1ZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgZG9uZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZVJ1bGU6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgdGFnczogYW55ID0gW107XG4gICAgICAgIC8vIFRhZ3MgdGhhdCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlbmQgd2hpbGUgcGFyc2luZywgYnV0IHdlIHdhbnQgdG8gYWRkIHRoZW0gYmFjayBmb3IgYmVpbmcgcGFydCBvZiB0aGUgZGVzY3JpcHRpb24uXG4gICAgICAgIC8vIEluIHRoZSBvcmlnaW5hbCB0YXNrIGRlc2NyaXB0aW9uIHRoZXkgYXJlIHBvc3NpYmx5IG1peGVkIHdpdGggb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAvLyAoZS5nLiAjdGFnMSA8ZHVlIGRhdGU+ICN0YWcyKSwgdGhleSBkbyBub3QgaGF2ZSB0byBhbGwgdHJhaWwgYWxsIHRhc2sgY29tcG9uZW50cyxcbiAgICAgICAgLy8gYnV0IGV2ZW50dWFsbHkgd2Ugd2FudCB0byBwYXN0ZSB0aGVtIGJhY2sgdG8gdGhlIHRhc2sgZGVzY3JpcHRpb24gYXQgdGhlIGVuZFxuICAgICAgICBsZXQgdHJhaWxpbmdUYWdzID0gJyc7XG4gICAgICAgIC8vIEFkZCBhIFwibWF4IHJ1bnNcIiBmYWlsc2FmZSB0byBuZXZlciBlbmQgaW4gYW4gZW5kbGVzcyBsb29wOlxuICAgICAgICBjb25zdCBtYXhSdW5zID0gMjA7XG4gICAgICAgIGxldCBydW5zID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMucHJpb3JpdHlSZWdleCk7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHlNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJpb3JpdHlNYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5Mb3c6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IFByaW9yaXR5LkxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5NZWRpdW06XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5IaWdoOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMucHJpb3JpdHlSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZG9uZURhdGVNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZG9uZURhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoZG9uZURhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRvbmVEYXRlID0gd2luZG93Lm1vbWVudChkb25lRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmRvbmVEYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGR1ZURhdGVNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZHVlRGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChkdWVEYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkdWVEYXRlID0gd2luZG93Lm1vbWVudChkdWVEYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZHVlRGF0ZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZWREYXRlTWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLnNjaGVkdWxlZERhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkRGF0ZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IHdpbmRvdy5tb21lbnQoc2NoZWR1bGVkRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLnNjaGVkdWxlZERhdGVSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhcnREYXRlTWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLnN0YXJ0RGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChzdGFydERhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQoc3RhcnREYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuc3RhcnREYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlY3VycmVuY2VNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMucmVjdXJyZW5jZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChyZWN1cnJlbmNlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSByZWN1cnJlbmNlIHJ1bGUsIGJ1dCAqZG8gbm90IHBhcnNlIGl0IHlldCouXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIFJlY3VycmVuY2Ugb2JqZWN0IHJlcXVpcmVzIGEgcmVmZXJlbmNlIGRhdGUgKGUuZy4gYSBkdWUgZGF0ZSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IG1pZ2h0IGFwcGVhciBpbiB0aGUgbmV4dCAoZWFybGllciBpbiB0aGUgbGluZSkgdG9rZW5zIHRvIHBhcnNlXG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZVJ1bGUgPSByZWN1cnJlbmNlTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLnJlY3VycmVuY2VSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggdGFncyBmcm9tIHRoZSBlbmQgdG8gYWxsb3cgdXNlcnMgdG8gbWl4IHRoZSB2YXJpb3VzIHRhc2sgY29tcG9uZW50cyB3aXRoXG4gICAgICAgICAgICAvLyB0YWdzLiBUaGVzZSB0YWdzIHdpbGwgYmUgYWRkZWQgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gYmVsb3dcbiAgICAgICAgICAgIGNvbnN0IHRhZ3NNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaGFzaFRhZ3NGcm9tRW5kKTtcbiAgICAgICAgICAgIGlmICh0YWdzTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmhhc2hUYWdzRnJvbUVuZCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFnc01hdGNoWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIGxlZnQgYmVjYXVzZSB0aGUgbWF0Y2hpbmcgaXMgZG9uZSByaWdodC10by1sZWZ0XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdUYWdzID0gdHJhaWxpbmdUYWdzLmxlbmd0aCA+IDAgPyBbdGFnTmFtZSwgdHJhaWxpbmdUYWdzXS5qb2luKCcgJykgOiB0YWdOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBydW5zKys7XG4gICAgICAgIH0gd2hpbGUgKG1hdGNoZWQgJiYgcnVucyA8PSBtYXhSdW5zKTtcblxuICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGFsbCB0aGUgdGFzayBkZXRhaWxzLCBwYXJzZSB0aGUgcmVjdXJyZW5jZSBydWxlIGlmIHdlIGZvdW5kIGFueVxuICAgICAgICBpZiAocmVjdXJyZW5jZVJ1bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVjdXJyZW5jZSA9IFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogcmVjdXJyZW5jZVJ1bGUsXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5mZXIgdGhlIHNjaGVkdWxlZCBkYXRlIGZyb20gdGhlIGZpbGUgbmFtZSBpZiBub3Qgc2V0IGV4cGxpY2l0bHlcbiAgICAgICAgaWYgKERhdGVGYWxsYmFjay5jYW5BcHBseUZhbGxiYWNrKHsgc3RhcnREYXRlLCBzY2hlZHVsZWREYXRlLCBkdWVEYXRlIH0pICYmIGZhbGxiYWNrRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IGZhbGxiYWNrRGF0ZTtcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBiYWNrIGFueSB0cmFpbGluZyB0YWdzIHRvIHRoZSBkZXNjcmlwdGlvbi4gV2UgcmVtb3ZlZCB0aGVtIHNvIHdlIGNhbiBwYXJzZSB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50cyBidXQgbm93IHdlIHdhbnQgdGhlbSBiYWNrLlxuICAgICAgICAvLyBUaGUgZ29hbCBpcyBmb3IgYSB0YXNrIG9mIHRoZW0gZm9ybSAnRG8gc29tZXRoaW5nICN0YWcxIChkdWUpIHRvbW9ycm93ICN0YWcyIChzdGFydCkgdG9kYXknXG4gICAgICAgIC8vIHRvIGFjdHVhbGx5IGhhdmUgdGhlIGRlc2NyaXB0aW9uICdEbyBzb21ldGhpbmcgI3RhZzEgI3RhZzInXG4gICAgICAgIGlmICh0cmFpbGluZ1RhZ3MubGVuZ3RoID4gMCkgZGVzY3JpcHRpb24gKz0gJyAnICsgdHJhaWxpbmdUYWdzO1xuXG4gICAgICAgIC8vIFRhZ3MgYXJlIGZvdW5kIGluIHRoZSBzdHJpbmcgYW5kIHB1bGxlZCBvdXQgYnV0IG5vdCByZW1vdmVkLFxuICAgICAgICAvLyBzbyB3aGVuIHJldHVybmluZyB0aGUgZW50aXJlIHRhc2sgaXQgd2lsbCBtYXRjaCB3aGF0IHRoZSB1c2VyXG4gICAgICAgIC8vIGVudGVyZWQuXG4gICAgICAgIC8vIFRoZSBnbG9iYWwgZmlsdGVyIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICBjb25zdCBoYXNoVGFnTWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLmhhc2hUYWdzKTtcbiAgICAgICAgaWYgKGhhc2hUYWdNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGFncyA9IGhhc2hUYWdNYXRjaC5maWx0ZXIoKHRhZykgPT4gdGFnICE9PSBnbG9iYWxGaWx0ZXIpLm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbmRlbnRhdGlvbixcbiAgICAgICAgICAgIGxpc3RNYXJrZXIsXG4gICAgICAgICAgICBzZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICBwcmVjZWRpbmdIZWFkZXIsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgZG9uZURhdGUsXG4gICAgICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICAgICAgYmxvY2tMaW5rLFxuICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgIG9yaWdpbmFsTWFya2Rvd246IGxpbmUsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEhUTUwgcmVuZGVyZWQgTGlzdCBJdGVtIGVsZW1lbnQgKExJKSBmb3IgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAgKiBAcGFyYW0ge3JlbmRlclRhaWxzfVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyB0b0xpKHJlbmRlckRldGFpbHM6IFRhc2tMaW5lUmVuZGVyRGV0YWlscyk6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgICAgICByZXR1cm4gcmVuZGVyVGFza0xpbmUodGhpcywgcmVuZGVyRGV0YWlscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbiB0aGUgdGFzayBhcyBhIHN0cmluZyB0aGF0IGluY2x1ZGVzIGFsbCBpdHMgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge0xheW91dE9wdGlvbnN9IFtsYXlvdXRPcHRpb25zXVxuICAgICAqIEByZXR1cm4geyp9ICB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBUYXNrXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKGxheW91dE9wdGlvbnM/OiBMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdGFza0xheW91dCA9IG5ldyBUYXNrTGF5b3V0KGxheW91dE9wdGlvbnMpO1xuICAgICAgICBsZXQgdGFza1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiB0YXNrTGF5b3V0LmxheW91dENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRhc2tTdHJpbmcgKz0gdGhpcy5jb21wb25lbnRUb1N0cmluZyh0YXNrTGF5b3V0LCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpYyBUYXNrTGF5b3V0Q29tcG9uZW50IG9mIHRoZSB0YXNrIChpdHMgZGVzY3JpcHRpb24sIHByaW9yaXR5LCBldGMpIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wb25lbnRUb1N0cmluZyhsYXlvdXQ6IFRhc2tMYXlvdXQsIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgY2FzZSAncHJpb3JpdHknOiB7XG4gICAgICAgICAgICAgICAgbGV0IHByaW9yaXR5OiBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByaW9yaXR5ID09PSBQcmlvcml0eS5IaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkhpZ2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByaW9yaXR5ID09PSBQcmlvcml0eS5NZWRpdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnICcgKyBwcmlvcml0eVN5bWJvbHMuTWVkaXVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkxvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3RhcnREYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnREYXRlKSByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheW91dC5vcHRpb25zLnNob3J0TW9kZVxuICAgICAgICAgICAgICAgICAgICA/ICcgJyArIHN0YXJ0RGF0ZVN5bWJvbFxuICAgICAgICAgICAgICAgICAgICA6IGAgJHtzdGFydERhdGVTeW1ib2x9ICR7dGhpcy5zdGFydERhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ3NjaGVkdWxlZERhdGUnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY2hlZHVsZWREYXRlIHx8IHRoaXMuc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQpIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5b3V0Lm9wdGlvbnMuc2hvcnRNb2RlXG4gICAgICAgICAgICAgICAgICAgID8gJyAnICsgc2NoZWR1bGVkRGF0ZVN5bWJvbFxuICAgICAgICAgICAgICAgICAgICA6IGAgJHtzY2hlZHVsZWREYXRlU3ltYm9sfSAke3RoaXMuc2NoZWR1bGVkRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX1gO1xuICAgICAgICAgICAgY2FzZSAnZG9uZURhdGUnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb25lRGF0ZSkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXlvdXQub3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAnICcgKyBkb25lRGF0ZVN5bWJvbFxuICAgICAgICAgICAgICAgICAgICA6IGAgJHtkb25lRGF0ZVN5bWJvbH0gJHt0aGlzLmRvbmVEYXRlLmZvcm1hdChUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpfWA7XG4gICAgICAgICAgICBjYXNlICdkdWVEYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHVlRGF0ZSkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXlvdXQub3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAnICcgKyBkdWVEYXRlU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIDogYCAke2R1ZURhdGVTeW1ib2x9ICR7dGhpcy5kdWVEYXRlLmZvcm1hdChUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpfWA7XG4gICAgICAgICAgICBjYXNlICdyZWN1cnJlbmNlUnVsZSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlY3VycmVuY2UpIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5b3V0Lm9wdGlvbnMuc2hvcnRNb2RlXG4gICAgICAgICAgICAgICAgICAgID8gJyAnICsgcmVjdXJyZW5jZVN5bWJvbFxuICAgICAgICAgICAgICAgICAgICA6IGAgJHtyZWN1cnJlbmNlU3ltYm9sfSAke3RoaXMucmVjdXJyZW5jZS50b1RleHQoKX1gO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2tMaW5rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0xpbmsgPz8gJyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9uJ3Qga25vdyBob3cgdG8gcmVuZGVyIHRhc2sgY29tcG9uZW50IG9mIHR5cGUgJyR7Y29tcG9uZW50fSdgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRhc2sgYXMgYSBsaXN0IGl0ZW0gd2l0aCBhIGNoZWNrYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9GaWxlTGluZVN0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pbmRlbnRhdGlvbn0ke3RoaXMubGlzdE1hcmtlcn0gWyR7dGhpcy5zdGF0dXMuc3ltYm9sfV0gJHt0aGlzLnRvU3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoaXMgdGFzayBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHRhc2tzLlxuICAgICAqXG4gICAgICogVG9nZ2xpbmcgY2FuIHJlc3VsdCBpbiBtb3JlIHRoYW4gb25lIHJldHVybmVkIHRhc2sgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiByZWN1cnJlbmNlLiBJZiBpdCBpcyBhIHJlY3VycmluZyB0YXNrLCB0aGUgdG9nZ2xlZCB0YXNrIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiB0b2dldGhlciB3aXRoIHRoZSBuZXh0IG9jY3VycmVuY2UgaW4gdGhlIG9yZGVyIGBbbmV4dCwgdG9nZ2xlZF1gLiBJZiB0aGVcbiAgICAgKiB0YXNrIGlzIG5vdCByZWN1cnJpbmcsIGl0IHdpbGwgcmV0dXJuIGBbdG9nZ2xlZF1gLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKTogVGFza1tdIHtcbiAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5nZXROZXh0U3RhdHVzT3JDcmVhdGUodGhpcy5zdGF0dXMpO1xuXG4gICAgICAgIGxldCBuZXdEb25lRGF0ZSA9IG51bGw7XG5cbiAgICAgICAgbGV0IG5leHRPY2N1cnJlbmNlOiB7XG4gICAgICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXdTdGF0dXMuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgLy8gU2V0IGRvbmUgZGF0ZSBvbmx5IGlmIHNldHRpbmcgdmFsdWUgaXMgdHJ1ZVxuICAgICAgICAgICAgY29uc3QgeyBzZXREb25lRGF0ZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmIChzZXREb25lRGF0ZSkge1xuICAgICAgICAgICAgICAgIG5ld0RvbmVEYXRlID0gd2luZG93Lm1vbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHRhc2sgaXMgbm8gbG9uZ2VyIHRvZG8sIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgcmVjdXJyaW5nOlxuICAgICAgICAgICAgaWYgKHRoaXMucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHRPY2N1cnJlbmNlID0gdGhpcy5yZWN1cnJlbmNlLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvZ2dsZWRUYXNrID0gbmV3IFRhc2soe1xuICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgIHN0YXR1czogbmV3U3RhdHVzLFxuICAgICAgICAgICAgZG9uZURhdGU6IG5ld0RvbmVEYXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBuZXdUYXNrczogVGFza1tdID0gW107XG5cbiAgICAgICAgaWYgKG5leHRPY2N1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5nZXROZXh0U3RhdHVzT3JDcmVhdGUobmV3U3RhdHVzKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUYXNrID0gbmV3IFRhc2soe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgICAgICAgLi4ubmV4dE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBuZXh0U3RhdHVzLFxuICAgICAgICAgICAgICAgIC8vIE5ldyBvY2N1cnJlbmNlcyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBibG9jayBsaW5rLlxuICAgICAgICAgICAgICAgIC8vIEFuZCByYW5kb20gYmxvY2sgbGlua3MgZG9uJ3QgaGVscC5cbiAgICAgICAgICAgICAgICBibG9ja0xpbms6ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdUYXNrcy5wdXNoKG5leHRUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIG5leHQgb2NjdXJyZW5jZSBiZWZvcmUgcHJldmlvdXMgb2NjdXJyZW5jZS5cbiAgICAgICAgbmV3VGFza3MucHVzaCh0b2dnbGVkVGFzayk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1Rhc2tzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdXJnZW5jeSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5fdXJnZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdXJnZW5jeSA9IFVyZ2VuY3kuY2FsY3VsYXRlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VyZ2VuY3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIHRhc2ssIHdpdGggdGhlIC5tZCBleHRlbnNpb24gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZpbGVuYW1lKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBjb25zdCBmaWxlTmFtZU1hdGNoID0gdGhpcy5wYXRoLm1hdGNoKC8oW14vXSspXFwubWQkLyk7XG4gICAgICAgIGlmIChmaWxlTmFtZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWVNYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2hlbiBsaW5raW5nIHRvIHRoZSBvcmlnaW4gb2YgdGhlIHRhc2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0ZpbGVuYW1lVW5pcXVlIHtib29sZWFufG51bGx9IFdoZXRoZXIgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdGhhdCBjb250YWlucyB0aGUgdGFzayBpcyB1bmlxdWUgaW4gdGhlIHZhdWx0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGl0IGlzIHVuZGVmaW5lZCwgdGhlIG91dGNvbWUgd2lsbCBiZSB0aGUgc2FtZSBhcyB3aXRoIGEgdW5pcXVlIGZpbGUgbmFtZTogdGhlIGZpbGUgbmFtZSBvbmx5LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBmdWxsIHBhdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TGlua1RleHQoeyBpc0ZpbGVuYW1lVW5pcXVlIH06IHsgaXNGaWxlbmFtZVVuaXF1ZTogYm9vbGVhbiB8IHVuZGVmaW5lZCB9KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGxldCBsaW5rVGV4dDogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaWYgKGlzRmlsZW5hbWVVbmlxdWUpIHtcbiAgICAgICAgICAgIGxpbmtUZXh0ID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEEgc2xhc2ggYXQgdGhlIGJlZ2lubmluZyBpbmRpY2F0ZXMgdGhpcyBpcyBhIHBhdGgsIG5vdCBhIGZpbGVuYW1lLlxuICAgICAgICAgICAgbGlua1RleHQgPSAnLycgKyB0aGlzLnBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlua1RleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIHdvdWxkbid0IHByb3ZpZGUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhbmQgb25seSB0YWtlIHVwIHNwYWNlLlxuICAgICAgICBpZiAodGhpcy5wcmVjZWRpbmdIZWFkZXIgIT09IG51bGwgJiYgdGhpcy5wcmVjZWRpbmdIZWFkZXIgIT09IGxpbmtUZXh0KSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IGxpbmtUZXh0ICsgJyA+ICcgKyB0aGlzLnByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBsaXN0cyBvZiBUYXNrIG9iamVjdHMsIGFuZCByZXBvcnQgd2hldGhlciB0aGVpclxuICAgICAqIHRhc2tzIGFyZSBpZGVudGljYWwgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIG9wdGltaXNpbmcgY29kZSBpZiBpdCBpcyBndWFyYW50ZWVkIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gcG9zc2libGUgZGlmZmVyZW5jZXMgaW4gdGhlIHRhc2tzIGluIGEgZmlsZVxuICAgICAqIGFmdGVyIGFuIGVkaXQsIGZvciBleGFtcGxlLlxuICAgICAqXG4gICAgICogSWYgYW55IGZpZWxkIGlzIGRpZmZlcmVudCBpbiBhbnkgdGFzaywgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2xkVGFza3NcbiAgICAgKiBAcGFyYW0gbmV3VGFza3NcbiAgICAgKi9cbiAgICBzdGF0aWMgdGFza3NMaXN0c0lkZW50aWNhbChvbGRUYXNrczogVGFza1tdLCBuZXdUYXNrczogVGFza1tdKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvbGRUYXNrcy5sZW5ndGggIT09IG5ld1Rhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRUYXNrcy5ldmVyeSgob2xkVGFzaywgaW5kZXgpID0+IG9sZFRhc2suaWRlbnRpY2FsVG8obmV3VGFza3NbaW5kZXhdKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBhbGwgdGhlIGZpZWxkcyBpbiBhbm90aGVyIFRhc2ssIHRvIGRldGVjdCBhbnkgZGlmZmVyZW5jZXMgZnJvbSB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIElmIGFueSBmaWVsZCBpcyBkaWZmZXJlbnQgaW4gYW55IHdheSwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgaW4gc29tZSBvcHRpbWlzYXRpb25zLCB0byBhdm9pZCB3b3JrIGlmIGFuIGVkaXQgdG8gZmlsZVxuICAgICAqIGRvZXMgbm90IGNoYW5nZSBhbnkgdGFza3MsIHNvIGl0IGlzIHZpdGFsIHRoYXQgaXRzIGRlZmluaXRpb25cbiAgICAgKiBvZiBpZGVudGljYWwgaXMgdmVyeSBzdHJpY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgaWRlbnRpY2FsVG8ob3RoZXI6IFRhc2spIHtcbiAgICAgICAgLy8gQmFzZWQgb24gaWRlYXMgZnJvbSBrb2FsYS4gQXF1YUNhdCBhbmQgamF2YWxlbnQgaW4gRGlzY29yZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82ODYwNTM3MDgyNjEyMjg1NzcvODQwMjg2MjY0OTY0MDIyMzAyLzk5NjczNTIwMDM4ODE4NjE4MlxuICAgICAgICAvLyBhbmQgbGF0ZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IHNlY3Rpb25TdGFydCBjaGFuZ2VzIGV2ZXJ5IHRpbWUgYSBsaW5lIGlzIGFkZGVkIG9yIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAgIC8vICAgICAgIGFueSBvZiB0aGUgdGFza3MgaW4gYSBmaWxlLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHJlZHJhd2luZyBvZiB0YXNrcyBibG9ja3NcbiAgICAgICAgLy8gICAgICAgaGFwcGVucyBtb3JlIG9mdGVuIHRoYW4gaXMgaWRlYWwuXG4gICAgICAgIGxldCBhcmdzOiBBcnJheTxrZXlvZiBUYXNrPiA9IFtcbiAgICAgICAgICAgICdzdGF0dXMnLFxuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwYXRoJyxcbiAgICAgICAgICAgICdpbmRlbnRhdGlvbicsXG4gICAgICAgICAgICAnbGlzdE1hcmtlcicsXG4gICAgICAgICAgICAnc2VjdGlvblN0YXJ0JyxcbiAgICAgICAgICAgICdzZWN0aW9uSW5kZXgnLFxuICAgICAgICAgICAgJ3ByZWNlZGluZ0hlYWRlcicsXG4gICAgICAgICAgICAncHJpb3JpdHknLFxuICAgICAgICAgICAgJ2Jsb2NrTGluaycsXG4gICAgICAgICAgICAnc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQnLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2VsXSAhPT0gb3RoZXJbZWxdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIHRhZ3NcbiAgICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggIT09IG90aGVyLnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFncyBhcmUgdGhlIHNhbWUgb25seSBpZiB0aGUgdmFsdWVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGhpcy50YWdzLmV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09PSBvdGhlci50YWdzW2luZGV4XTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBhcmdzID0gWydzdGFydERhdGUnLCAnc2NoZWR1bGVkRGF0ZScsICdkdWVEYXRlJywgJ2RvbmVEYXRlJ107XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgYXJncykge1xuICAgICAgICAgICAgY29uc3QgZGF0ZTEgPSB0aGlzW2VsXSBhcyBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0ZTIgPSBvdGhlcltlbF0gYXMgTW9tZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChEYXRlRmllbGQuY29tcGFyZUJ5RGF0ZShkYXRlMSwgZGF0ZTIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZTEgPSB0aGlzLnJlY3VycmVuY2U7XG4gICAgICAgIGNvbnN0IHJlY3VycmVuY2UyID0gb3RoZXIucmVjdXJyZW5jZTtcbiAgICAgICAgaWYgKHJlY3VycmVuY2UxID09PSBudWxsICYmIHJlY3VycmVuY2UyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjdXJyZW5jZTEgIT09IG51bGwgJiYgcmVjdXJyZW5jZTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWN1cnJlbmNlMSAmJiByZWN1cnJlbmNlMiAmJiAhcmVjdXJyZW5jZTEuaWRlbnRpY2FsVG8ocmVjdXJyZW5jZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGZvciB0aGUgcHVycG9zZSBvZiByZW1vdmluZyBpdCBmcm9tIHRoZSBkZXNjcmlwdGlvbiwgYnV0IGRvIHNvIG9ubHlcbiAgICAgKiBpZiBpdCBpcyBhIHNlcGFyYXRlIHdvcmQgKHByZWNlZGluZyB0aGUgYmVnaW5uaW5nIG9mIGxpbmUgb3IgYSBzcGFjZSBhbmQgZm9sbG93ZWQgYnkgdGhlIGVuZCBvZiBsaW5lXG4gICAgICogb3IgYSBzcGFjZSksIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjdXQtb2ZmIG5lc3RlZCB0YWdzIGxpa2UgI3Rhc2svc3VidGFnLlxuICAgICAqIElmIHRoZSBnbG9iYWwgZmlsdGVyIGV4aXN0cyBhcyBwYXJ0IG9mIGEgbmVzdGVkIHRhZywgd2Uga2VlcCBpdCB1bnRvdWNoZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldERlc2NyaXB0aW9uV2l0aG91dEdsb2JhbEZpbHRlcigpIHtcbiAgICAgICAgY29uc3QgeyBnbG9iYWxGaWx0ZXIgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IHRoaXMuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChnbG9iYWxGaWx0ZXIubGVuZ3RoID09PSAwKSByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgZ2xvYmFsIGZpbHRlciAoYWZ0ZXIgZXNjYXBpbmcgaXQpIG9ubHkgd2hlbiBpdCdzIGEgY29tcGxldGUgd29yZFxuICAgICAgICBjb25zdCBnbG9iYWxGaWx0ZXJSZWdleCA9IFJlZ0V4cCgnKF58XFxcXHMpJyArIFJlZ0V4cFRvb2xzLmVzY2FwZVJlZ0V4cChnbG9iYWxGaWx0ZXIpICsgJygkfFxcXFxzKScsICd1ZycpO1xuICAgICAgICBpZiAodGhpcy5kZXNjcmlwdGlvbi5zZWFyY2goZ2xvYmFsRmlsdGVyUmVnZXgpID4gLTEpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShnbG9iYWxGaWx0ZXJSZWdleCwgJyQxJDInKS5yZXBsYWNlKCcgICcsICcgJykudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBMYXp5IGxvYWRlZCB2YXJpYWJsZSA6IGZldGNoaW5nIHRoZSB2YWx1ZSBpcyBwb3N0cG9uZWQgdW50aWwgdGhlIGZpcnN0IGdldCgpXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5PFQ+IHtcbiAgICBwcml2YXRlIF92YWx1ZTogVCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGxhenkgb2JqZWN0XG4gICAgICogQHBhcmFtIGZldGNoIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBmZXRjaDogKCkgPT4gVCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsYXp5IHZhbHVlLCBjYWxsaW5nIHRoZSBmZXRjaCBmdW5jdGlvbiB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKTogVCB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZmV0Y2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRhc2tNb2RhbCB9IGZyb20gJy4uL1Rhc2tNb2RhbCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IERhdGVGYWxsYmFjayB9IGZyb20gJy4uL0RhdGVGYWxsYmFjayc7XG5pbXBvcnQgeyB0YXNrRnJvbUxpbmUgfSBmcm9tICcuL0NyZWF0ZU9yRWRpdFRhc2tQYXJzZXInO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlT3JFZGl0ID0gKGNoZWNraW5nOiBib29sZWFuLCBlZGl0b3I6IEVkaXRvciwgdmlldzogVmlldywgYXBwOiBBcHApID0+IHtcbiAgICBpZiAoY2hlY2tpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXc7XG4gICAgfVxuXG4gICAgaWYgKCEodmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykpIHtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbiBkdWUgdG8gY2hlY2sgYWJvdmUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdmlldy5maWxlPy5wYXRoO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBjdXJzb3JQb3NpdGlvbi5saW5lO1xuICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcbiAgICBjb25zdCB0YXNrID0gdGFza0Zyb21MaW5lKHsgbGluZSwgcGF0aCB9KTtcblxuICAgIGNvbnN0IG9uU3VibWl0ID0gKHVwZGF0ZWRUYXNrczogVGFza1tdKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBEYXRlRmFsbGJhY2sucmVtb3ZlSW5mZXJyZWRTdGF0dXNJZk5lZWRlZCh0YXNrLCB1cGRhdGVkVGFza3MpXG4gICAgICAgICAgICAubWFwKCh0YXNrOiBUYXNrKSA9PiB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgc2VyaWFsaXplZCk7XG4gICAgfTtcblxuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUsIGFzIGN1cnNvci90YXNrIGNhbiBjaGFuZ2UuXG4gICAgY29uc3QgdGFza01vZGFsID0gbmV3IFRhc2tNb2RhbCh7XG4gICAgICAgIGFwcCxcbiAgICAgICAgdGFzayxcbiAgICAgICAgb25TdWJtaXQsXG4gICAgfSk7XG4gICAgdGFza01vZGFsLm9wZW4oKTtcbn07XG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBFZGl0VGFzayBmcm9tICcuL3VpL0VkaXRUYXNrLnN2ZWx0ZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4vU3RhdHVzJztcblxuZXhwb3J0IGNsYXNzIFRhc2tNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgdGFzazogVGFzaztcbiAgICBwdWJsaWMgcmVhZG9ubHkgb25TdWJtaXQ6ICh1cGRhdGVkVGFza3M6IFRhc2tbXSkgPT4gdm9pZDtcblxuICAgIGNvbnN0cnVjdG9yKHsgYXBwLCB0YXNrLCBvblN1Ym1pdCB9OiB7IGFwcDogQXBwOyB0YXNrOiBUYXNrOyBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkIH0pIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcblxuICAgICAgICB0aGlzLnRhc2sgPSB0YXNrO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVkVGFza3MubGVuZ3RoICYmIG9uU3VibWl0KHVwZGF0ZWRUYXNrcyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIG9uT3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aXRsZUVsLnNldFRleHQoJ0NyZWF0ZSBvciBlZGl0IFRhc2snKTtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzT3B0aW9ucyA9IHRoaXMuZ2V0S25vd25TdGF0dXNlc0FuZEN1cnJlbnRUYXNrU3RhdHVzSWZOb3RLbm93bigpO1xuXG4gICAgICAgIG5ldyBFZGl0VGFzayh7XG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRlbnRFbCxcbiAgICAgICAgICAgIHByb3BzOiB7IHRhc2s6IHRoaXMudGFzaywgc3RhdHVzT3B0aW9uczogc3RhdHVzT3B0aW9ucywgb25TdWJtaXQ6IHRoaXMub25TdWJtaXQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhc2sgYmVpbmcgZWRpdGVkIGhhcyBhbiB1bmtub3duIHN0YXR1cywgbWFrZSBzdXJlIGl0IGlzIGFkZGVkXG4gICAgICogdG8gdGhlIGRyb3Bkb3duIGxpc3QuXG4gICAgICogVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gc3dpdGNoIHRvIGEgZGlmZmVyZW50IHN0YXR1cyBhbmQgdGhlbiBjaGFuZ2UgdGhlaXJcbiAgICAgKiBtaW5kIGFuZCByZXR1cm4gdG8gdGhlIGluaXRpYWwgc3RhdHVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0S25vd25TdGF0dXNlc0FuZEN1cnJlbnRUYXNrU3RhdHVzSWZOb3RLbm93bigpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzT3B0aW9uczogU3RhdHVzW10gPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyZWRTdGF0dXNlcztcbiAgICAgICAgaWYgKFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuYnlTeW1ib2wodGhpcy50YXNrLnN0YXR1cy5zeW1ib2wpID09PSBTdGF0dXMuRU1QVFkpIHtcbiAgICAgICAgICAgIHN0YXR1c09wdGlvbnMucHVzaCh0aGlzLnRhc2suc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzT3B0aW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIH1cbn1cbiIsICJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcbiAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgIGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuICAgIH07XG59XG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG4gICAgZm5zLmZvckVhY2gocnVuKTtcbn1cbmZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcbiAgICBpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG4gICAgICAgIHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cbiAgICBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuICAgIHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cbmZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5mdW5jdGlvbiBpc19lbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuICAgIGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHN1YnNjcmliZShzdG9yZSwgXyA9PiB2YWx1ZSA9IF8pKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuXG4gICAgICAgID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpXG4gICAgICAgIDogJCRzY29wZS5jdHg7XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgICAgIGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG4gICAgICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICAgIH1cbiAgICByZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGlmIChzbG90X2NoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG4gICAgICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3Qoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcbiAgICBpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgY29uc3QgZGlydHkgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdWx0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBrZXlzID0gbmV3IFNldChrZXlzKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuICAgIC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgICAgICBpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG59XG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oeWRyYXRlX2luaXQpXG4gICAgICAgIHJldHVybjtcbiAgICB0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcbiAgICAvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG4gICAgbGV0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkTm9kZXM7XG4gICAgLy8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcbiAgICAgICAgY29uc3QgbXlDaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXlDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gbXlDaGlsZHJlbjtcbiAgICB9XG4gICAgLypcbiAgICAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG4gICAgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG4gICAgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuICAgICogc3Vic2VxdWVuY2Ugc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcbiAgICAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG4gICAgKlxuICAgICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG4gICAgKiBwb3NzaWJsZS5cbiAgICAqXG4gICAgKiBQcm9vZjpcbiAgICAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuICAgICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG4gICAgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuICAgICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cbiAgICAqL1xuICAgIC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgLy8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuICAgIGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcbiAgICAvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuICAgIGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuICAgIG1bMF0gPSAtMTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG4gICAgICAgIC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG4gICAgICAgIC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG4gICAgICAgIGNvbnN0IHNlcUxlbiA9ICgobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudCkgPyBsb25nZXN0ICsgMSA6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIGlkeCA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuICAgICAgICBwW2ldID0gbVtzZXFMZW5dICsgMTtcbiAgICAgICAgY29uc3QgbmV3TGVuID0gc2VxTGVuICsgMTtcbiAgICAgICAgLy8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuICAgICAgICBtW25ld0xlbl0gPSBpO1xuICAgICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmV3TGVuLCBsb25nZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuICAgIGNvbnN0IGxpcyA9IFtdO1xuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG4gICAgY29uc3QgdG9Nb3ZlID0gW107XG4gICAgbGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuICAgICAgICBsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG4gICAgICAgIGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG4gICAgICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC0tO1xuICAgIH1cbiAgICBmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcbiAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgIH1cbiAgICBsaXMucmV2ZXJzZSgpO1xuICAgIC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuICAgIHRvTW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG4gICAgLy8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b01vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvTW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodG9Nb3ZlW2ldLCBhbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG4gICAgICAgIGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGlmIChyb290ICYmIHJvb3QuaG9zdCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICBhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuICAgIHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcbiAgICBhcHBlbmQobm9kZS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50RWxlbWVudCAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC5pc1RydXN0ZWQpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNfc3ZnKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuY29uc3QgbWFuYWdlZF9zdHlsZXMgPSBuZXcgTWFwKCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG4gICAgY29uc3QgaW5mbyA9IHsgc3R5bGVzaGVldDogYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSksIHJ1bGVzOiB7fSB9O1xuICAgIG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG4gICAgY29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG4gICAgaWYgKCFydWxlc1tuYW1lXSkge1xuICAgICAgICBydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGVzaGVldCB9ID0gaW5mbztcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgICAgICAgICAgIGluZm8ucnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIFx1MjAxNCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIFx1MjAxNCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5jb25zdCBnbG9iYWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiBnbG9iYWwpO1xuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChjb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAoYm9vbGVhbiAmJiB2YWx1ZSA9PT0gdHJ1ZSkgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuICAgIHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG4gICAgICAgIC5maWx0ZXIoa2V5ID0+IHN0eWxlX29iamVjdFtrZXldKVxuICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9OiAke3N0eWxlX29iamVjdFtrZXldfTtgKVxuICAgICAgICAuam9pbignICcpO1xufVxuZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCk7XG4gICAgcmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBvbl9tb3VudCwgb25fZGVzdHJveSwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNDkuMCcgfSwgZGV0YWlsKSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCwgdmFsaWRhdGVfZWFjaF9hcmd1bWVudCwgdmFsaWRhdGVfZWFjaF9rZXlzLCB2YWxpZGF0ZV9zbG90cywgdmFsaWRhdGVfc3RvcmUsIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50LCB4bGlua19hdHRyIH07XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgKiBhcyBjaHJvbm8gZnJvbSAnY2hyb25vLW5vZGUnO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IFJlY3VycmVuY2UgfSBmcm9tICcuLi9SZWN1cnJlbmNlJztcbiAgICBpbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG4gICAgaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzJztcbiAgICBpbXBvcnQgeyBQcmlvcml0eSwgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuICAgIGltcG9ydCB7XG4gICAgICAgIHByaW9yaXR5U3ltYm9scyxcbiAgICAgICAgcmVjdXJyZW5jZVN5bWJvbCxcbiAgICAgICAgc3RhcnREYXRlU3ltYm9sLFxuICAgICAgICBzY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICBkdWVEYXRlU3ltYm9sLFxuICAgIH0gZnJvbSAnLi4vVGFzayc7XG4gICAgaW1wb3J0IHsgZG9BdXRvY29tcGxldGUgfSBmcm9tICcuLi9EYXRlQWJicmV2aWF0aW9ucyc7XG5cbiAgICAvLyBUaGVzZSBleHBvcnRlZCB2YXJpYWJsZXMgYXJlIHBhc3NlZCBpbiBhcyBwcm9wcyBieSBUYXNrTW9kYWwub25PcGVuKCk6XG4gICAgZXhwb3J0IGxldCB0YXNrOiBUYXNrO1xuICAgIGV4cG9ydCBsZXQgb25TdWJtaXQ6ICh1cGRhdGVkVGFza3M6IFRhc2tbXSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gICAgZXhwb3J0IGxldCBzdGF0dXNPcHRpb25zOiBTdGF0dXNbXTtcblxuICAgIGxldCBkZXNjcmlwdGlvbklucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGxldCBlZGl0YWJsZVRhc2s6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgc3RhdHVzOiBTdGF0dXM7XG4gICAgICAgIHByaW9yaXR5OiAnbm9uZScgfCAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xuICAgICAgICByZWN1cnJlbmNlUnVsZTogc3RyaW5nO1xuICAgICAgICBzdGFydERhdGU6IHN0cmluZztcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogc3RyaW5nO1xuICAgICAgICBkdWVEYXRlOiBzdHJpbmc7XG4gICAgICAgIGRvbmVEYXRlOiBzdHJpbmc7XG4gICAgICAgIGZvcndhcmRPbmx5OiBib29sZWFuO1xuICAgIH0gPSB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgc3RhdHVzOiBTdGF0dXMuVE9ETyxcbiAgICAgICAgcHJpb3JpdHk6ICdub25lJyxcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6ICcnLFxuICAgICAgICBzdGFydERhdGU6ICcnLFxuICAgICAgICBzY2hlZHVsZWREYXRlOiAnJyxcbiAgICAgICAgZHVlRGF0ZTogJycsXG4gICAgICAgIGRvbmVEYXRlOiAnJyxcbiAgICAgICAgZm9yd2FyZE9ubHk6IHRydWVcbiAgICB9O1xuXG4gICAgbGV0IHBhcnNlZFN0YXJ0RGF0ZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IHBhcnNlZFNjaGVkdWxlZERhdGU6IHN0cmluZyA9ICcnO1xuICAgIGxldCBwYXJzZWREdWVEYXRlOiBzdHJpbmcgPSAnJztcbiAgICBsZXQgcGFyc2VkUmVjdXJyZW5jZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IHBhcnNlZERvbmU6IHN0cmluZyA9ICcnO1xuICAgIGxldCBhZGRHbG9iYWxGaWx0ZXJPblNhdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBsZXQgd2l0aEFjY2Vzc0tleXM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLy8gJ3dlZWtlbmQnIGFiYnJldmlhdGlvbiBvbW1pdHRlZCBkdWUgdG8gbGFjayBvZiBzcGFjZS5cbiAgICBsZXQgZGF0ZVBsYWNlaG9sZGVyID1cbiAgICAgICAgXCJUcnkgJ01vbmRheScgb3IgJ3RvbW9ycm93Jywgb3IgW3RkfHRtfHlkfHR3fG53fHdlXSB0aGVuIHNwYWNlLlwiO1xuXG4gICAgY29uc3QgcHJpb3JpdHlPcHRpb25zOiB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIGVkaXRhYmxlVGFzay5wcmlvcml0eSxcbiAgICAgICAgICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICBzeW1ib2w6IHN0cmluZyB9W10gPVxuICAgICAgICBbe1xuICAgICAgICAgICAgdmFsdWU6ICdsb3cnLFxuICAgICAgICAgICAgbGFiZWw6ICdMb3cnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuTG93XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAnbm9uZScsXG4gICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5Ob25lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAnbWVkaXVtJyxcbiAgICAgICAgICAgIGxhYmVsOiAnTWVkaXVtJyxcbiAgICAgICAgICAgIHN5bWJvbDogcHJpb3JpdHlTeW1ib2xzLk1lZGl1bVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogJ2hpZ2gnLFxuICAgICAgICAgICAgbGFiZWw6ICdIaWdoJyxcbiAgICAgICAgICAgIHN5bWJvbDogcHJpb3JpdHlTeW1ib2xzLkhpZ2hcbiAgICAgICAgfV1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZShcbiAgICAgICAgdHlwZTogJ3N0YXJ0JyB8ICdzY2hlZHVsZWQnIHwgJ2R1ZScgfCAnZG9uZScsXG4gICAgICAgIGRhdGU6IHN0cmluZyxcbiAgICAgICAgZm9yd2FyZERhdGU6IERhdGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxpPm5vICR7dHlwZX0gZGF0ZTwvaT5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IGNocm9uby5wYXJzZURhdGUoZGF0ZSwgZm9yd2FyZERhdGUsIHtcbiAgICAgICAgICAgIGZvcndhcmREYXRlOiBmb3J3YXJkRGF0ZSAhPSB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lm1vbWVudChwYXJzZWQpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPGk+aW52YWxpZCAke3R5cGV9IGRhdGU8L2k+YDtcbiAgICB9XG5cbiAgICAkOiBhY2Nlc3NrZXkgPSAoa2V5OiBzdHJpbmcpID0+IHdpdGhBY2Nlc3NLZXlzID8ga2V5IDogbnVsbDtcblxuICAgICQ6IHtcbiAgICAgICAgZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGVkaXRhYmxlVGFzay5zdGFydERhdGUpO1xuICAgICAgICBwYXJzZWRTdGFydERhdGUgPSBwYXJzZURhdGUoXG4gICAgICAgICAgICAnc3RhcnQnLFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5mb3J3YXJkT25seSA/IG5ldyBEYXRlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBlZGl0YWJsZVRhc2suc2NoZWR1bGVkRGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGVkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlKTtcbiAgICAgICAgcGFyc2VkU2NoZWR1bGVkRGF0ZSA9IHBhcnNlRGF0ZShcbiAgICAgICAgICAgICdzY2hlZHVsZWQnLFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHkgPyBuZXcgRGF0ZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICApO1xuICAgIH1cblxuICAgICQ6IHtcbiAgICAgICAgZWRpdGFibGVUYXNrLmR1ZURhdGUgPSBkb0F1dG9jb21wbGV0ZShlZGl0YWJsZVRhc2suZHVlRGF0ZSk7XG4gICAgICAgIHBhcnNlZER1ZURhdGUgPSBwYXJzZURhdGUoXG4gICAgICAgICAgICAnZHVlJyxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5kdWVEYXRlLFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5ID8gbmV3IERhdGUoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAkOiB7XG4gICAgICAgIGlmICghZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlKSB7XG4gICAgICAgICAgICBwYXJzZWRSZWN1cnJlbmNlID0gJzxpPm5vdCByZWN1cnJpbmc8Lz4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkUmVjdXJyZW5jZSA9XG4gICAgICAgICAgICAgICAgUmVjdXJyZW5jZS5mcm9tVGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGZvciByZXByZXNlbnRhdGlvbiBpbiB0aGUgbW9kYWwsIG5vIGRhdGVzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk/LnRvVGV4dCgpID8/ICc8aT5pbnZhbGlkIHJlY3VycmVuY2UgcnVsZTwvaT4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBwYXJzZWREb25lID0gcGFyc2VEYXRlKCdkb25lJywgZWRpdGFibGVUYXNrLmRvbmVEYXRlKTtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBnbG9iYWxGaWx0ZXIsIHByb3ZpZGVBY2Nlc3NLZXlzIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICB3aXRoQWNjZXNzS2V5cyA9IHByb3ZpZGVBY2Nlc3NLZXlzO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRhc2suZ2V0RGVzY3JpcHRpb25XaXRob3V0R2xvYmFsRmlsdGVyKCk7XG4gICAgICAgIC8vIElmIHdlJ3JlIGRpc3BsYXlpbmcgdG8gdGhlIHVzZXIgdGhlIGRlc2NyaXB0aW9uIHdpdGhvdXQgdGhlIGdsb2JhbCBmaWx0ZXIgKGkuZS4gaXQgd2FzIHJlbW92ZWQgaW4gdGhlIG1ldGhvZFxuICAgICAgICAvLyBhYm92ZSksIG9yIGlmIHRoZSBkZXNjcmlwdGlvbiBkaWQgbm90IGluY2x1ZGUgYSBnbG9iYWwgZmlsdGVyIGluIHRoZSBmaXJzdCBwbGFjZSwgd2UnbGwgYWRkIHRoZSBnbG9iYWwgZmlsdGVyXG4gICAgICAgIC8vIHdoZW4gc2F2aW5nIHRoZSB0YXNrLlxuICAgICAgICAvLyBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyB3aGVuIHRoZSBnbG9iYWwgZmlsdGVyIGlzIGVtcHR5OiBpbiB0aGlzIGNhc2UgdGhlcmUncyBhbiBcImVtcHR5XCIgbWF0Y2ggaW4gdGhlIGBpbmRleE9mYFxuICAgICAgICAvLyAoaXQgcmV0dXJucyAwKSwgYW5kIHRodXMgd2UgKmRvbid0KiBzZXQgYWRkR2xvYmFsRmlsdGVyT25TYXZlLlxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT0gdGFzay5kZXNjcmlwdGlvbiB8fCBkZXNjcmlwdGlvbi5pbmRleE9mKGdsb2JhbEZpbHRlcikgPT0gLTEpXG4gICAgICAgICAgICBhZGRHbG9iYWxGaWx0ZXJPblNhdmUgPSB0cnVlO1xuICAgICAgICBsZXQgcHJpb3JpdHk6IHR5cGVvZiBlZGl0YWJsZVRhc2sucHJpb3JpdHkgPSAnbm9uZSc7XG4gICAgICAgIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5Mb3cpIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gJ2xvdyc7XG4gICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTWVkaXVtKSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdtZWRpdW0nO1xuICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5LkhpZ2gpIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gJ2hpZ2gnO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdGFibGVUYXNrID0ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBzdGF0dXM6IHRhc2suc3RhdHVzLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICByZWN1cnJlbmNlUnVsZTogdGFzay5yZWN1cnJlbmNlID8gdGFzay5yZWN1cnJlbmNlLnRvVGV4dCgpIDogJycsXG4gICAgICAgICAgICBzdGFydERhdGU6IHRhc2suc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgPyB0YXNrLnN0YXJ0RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiB0YXNrLnNjaGVkdWxlZERhdGVcbiAgICAgICAgICAgICAgICA/IHRhc2suc2NoZWR1bGVkRGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICBkdWVEYXRlOiB0YXNrLmR1ZURhdGUgPyB0YXNrLmR1ZURhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgOiAnJyxcbiAgICAgICAgICAgIGRvbmVEYXRlOiB0YXNrLmRvbmVEYXRlID8gdGFzay5kb25lRGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSA6ICcnLFxuICAgICAgICAgICAgZm9yd2FyZE9ubHk6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbnB1dC5mb2N1cygpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBfb25Qcmlvcml0eUtleXVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlPcHRpb24gPSBwcmlvcml0eU9wdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgICBvcHRpb24gPT4gb3B0aW9uLmxhYmVsLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09IGV2ZW50LmtleSk7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHlPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZVRhc2sucHJpb3JpdHkgPSBwcmlvcml0eU9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IF9vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICBvblN1Ym1pdChbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgX29uU3VibWl0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdsb2JhbEZpbHRlciB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9uLnRyaW0oKTtcbiAgICAgICAgaWYgKGFkZEdsb2JhbEZpbHRlck9uU2F2ZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBnbG9iYWxGaWx0ZXIgKyAnICcgKyBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFyc2VkU3RhcnREYXRlID0gY2hyb25vLnBhcnNlRGF0ZShcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5zdGFydERhdGUsXG4gICAgICAgICAgICBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgeyBmb3J3YXJkRGF0ZTogZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5IH0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJzZWRTdGFydERhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQocGFyc2VkU3RhcnREYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNjaGVkdWxlZERhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgeyBmb3J3YXJkRGF0ZTogZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5IH0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJzZWRTY2hlZHVsZWREYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gd2luZG93Lm1vbWVudChwYXJzZWRTY2hlZHVsZWREYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkdWVEYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnNlZER1ZURhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLmR1ZURhdGUsXG4gICAgICAgICAgICBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgeyBmb3J3YXJkRGF0ZTogZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5IH0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJzZWREdWVEYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkdWVEYXRlID0gd2luZG93Lm1vbWVudChwYXJzZWREdWVEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWN1cnJlbmNlOiBSZWN1cnJlbmNlIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChlZGl0YWJsZVRhc2sucmVjdXJyZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIHJlY3VycmVuY2UgPSBSZWN1cnJlbmNlLmZyb21UZXh0KHtcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IGVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyc2VkUHJpb3JpdHk6IFByaW9yaXR5O1xuICAgICAgICBzd2l0Y2ggKGVkaXRhYmxlVGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5LkxvdztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5NZWRpdW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5LkhpZ2g7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHBhcnNlZFByaW9yaXR5ID0gUHJpb3JpdHkuTm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUYXNrID0gbmV3IFRhc2soe1xuICAgICAgICAgICAgLi4udGFzayxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc3RhdHVzOiBlZGl0YWJsZVRhc2suc3RhdHVzLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHBhcnNlZFByaW9yaXR5LFxuICAgICAgICAgICAgcmVjdXJyZW5jZSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgZG9uZURhdGU6IHdpbmRvd1xuICAgICAgICAgICAgICAgIC5tb21lbnQoZWRpdGFibGVUYXNrLmRvbmVEYXRlLCAnWVlZWS1NTS1ERCcpXG4gICAgICAgICAgICAgICAgLmlzVmFsaWQoKVxuICAgICAgICAgICAgICAgID8gd2luZG93Lm1vbWVudChlZGl0YWJsZVRhc2suZG9uZURhdGUsICdZWVlZLU1NLUREJylcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uU3VibWl0KFt1cGRhdGVkVGFza10pO1xuICAgIH07XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsXCI+XG4gICAgPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtfb25TdWJtaXR9IGNsYXNzOndpdGgtYWNjZXNza2V5cz1cInt3aXRoQWNjZXNzS2V5c31cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkZXNjcmlwdGlvblwiPkRlc2NyaXA8c3BhbiBjbGFzcz1cImFjY2Vzc2tleVwiPnQ8L3NwYW4+aW9uPC9sYWJlbD5cbiAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWFjY2Vzc2tleSAtLT5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2VkaXRhYmxlVGFzay5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICBiaW5kOnRoaXM9e2Rlc2NyaXB0aW9uSW5wdXR9XG4gICAgICAgICAgICAgICAgaWQ9XCJkZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFza3MtbW9kYWwtZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVGFrZSBvdXQgdGhlIHRyYXNoXCJcbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleShcInRcIil9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb24gdGFza3MtbW9kYWwtcHJpb3JpdGllc1wiIG9uOmtleXVwPXtfb25Qcmlvcml0eUtleXVwfT5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJwcmlvcml0eS17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVwiPlByaW9yaXR5PC9sYWJlbD5cbiAgICAgICAgICAgIHsjZWFjaCBwcmlvcml0eU9wdGlvbnMgYXMge3ZhbHVlLCBsYWJlbCwgc3ltYm9sfX1cbiAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cInByaW9yaXR5LXt2YWx1ZX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZDpncm91cD17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkobGFiZWwuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkpfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwicHJpb3JpdHkte3ZhbHVlfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj57bGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzeW1ib2wgJiYgc3ltYm9sLmNoYXJDb2RlQXQoMCkgPj0gMHgxMDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3N5bWJvbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1zZWN0aW9uIHRhc2tzLW1vZGFsLWRhdGVzXCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwicmVjdXJyZW5jZVwiIGNsYXNzPVwiYWNjZXNza2V5LWZpcnN0XCI+UmVjdXJzPC9sYWJlbD5cbiAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWFjY2Vzc2tleSAtLT5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2VkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZX1cbiAgICAgICAgICAgICAgICBpZD1cInJlY3VycmVuY2VcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRyeSAnZXZlcnkgMiB3ZWVrcyBvbiBUaHVyc2RheScuXCJcbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleShcInJcIil9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGNvZGU+e3JlY3VycmVuY2VTeW1ib2x9IHtAaHRtbCBwYXJzZWRSZWN1cnJlbmNlfTwvY29kZT5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJkdWVcIiBjbGFzcz1cImFjY2Vzc2tleS1maXJzdFwiPkR1ZTwvbGFiZWw+XG4gICAgICAgICAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hY2Nlc3NrZXkgLS0+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtlZGl0YWJsZVRhc2suZHVlRGF0ZX1cbiAgICAgICAgICAgICAgICBpZD1cImR1ZVwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtkYXRlUGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoXCJkXCIpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjb2RlPntkdWVEYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkRHVlRGF0ZX08L2NvZGU+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwic2NoZWR1bGVkXCIgY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj5TY2hlZHVsZWQ8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGV9XG4gICAgICAgICAgICAgICAgaWQ9XCJzY2hlZHVsZWRcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17ZGF0ZVBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KFwic1wiKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8Y29kZT57c2NoZWR1bGVkRGF0ZVN5bWJvbH0ge0BodG1sIHBhcnNlZFNjaGVkdWxlZERhdGV9PC9jb2RlPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInN0YXJ0XCI+U3Q8c3BhbiBjbGFzcz1cImFjY2Vzc2tleVwiPmE8L3NwYW4+cnQ8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZX1cbiAgICAgICAgICAgICAgICBpZD1cInN0YXJ0XCJcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2RhdGVQbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleShcImFcIil9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGNvZGU+e3N0YXJ0RGF0ZVN5bWJvbH0ge0BodG1sIHBhcnNlZFN0YXJ0RGF0ZX08L2NvZGU+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJmb3J3YXJkT25seVwiPk9ubHlcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj5mdXR1cmU8L3NwYW4+IGRhdGVzOjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e2VkaXRhYmxlVGFzay5mb3J3YXJkT25seX1cbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJmb3J3YXJkT25seVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGFzay1saXN0LWl0ZW0tY2hlY2tib3ggdGFza3MtbW9kYWwtY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NrZXk9e2FjY2Vzc2tleShcImZcIil9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzdGF0dXNcIj5TdGF0dXMgPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3QgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnN0YXR1c30gaWQ9XCJzdGF0dXMtdHlwZVwiIGNsYXNzPVwiZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICB7I2VhY2ggc3RhdHVzT3B0aW9ucyBhcyBzdGF0dXN9XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e3N0YXR1c30+e3N0YXR1cy5uYW1lfSBbe3N0YXR1cy5zeW1ib2x9XTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb24gdGFza3MtbW9kYWwtc3RhdHVzXCI+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzdGF0dXNcIj5Db21wbGV0ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJzdGF0dXNcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhc2stbGlzdC1pdGVtLWNoZWNrYm94IHRhc2tzLW1vZGFsLWNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17ZWRpdGFibGVUYXNrLnN0YXR1cy5pc0NvbXBsZXRlZCgpfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4+RG9uZSBvbjo8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGNvZGU+e0BodG1sIHBhcnNlZERvbmV9PC9jb2RlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFza3MtbW9kYWwtc2VjdGlvbiB0YXNrcy1tb2RhbC1idXR0b25zXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cIm1vZC1jdGFcIj5BcHBseTwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9e19vbkNsb3NlfT5DYW5jZWw8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9mb3JtPlxuPC9kaXY+XG4iLCAiLy8gQWJicmV2aWF0aW9ucyBmb3IgZW50ZXJpbmcgZGF0ZXMgd2l0aCBjaHJvbm9cbi8vIE1BSU5URU5BTkNFIE5PVEU6XG4vLyAgICAgIElmIGFkZGluZyBtb3JlIGFiYnJldmlhdGlvbnMsIHBsZWFzZSByZXZpZXcgZGF0ZVBsYWNlaG9sZGVyIGluIHNyYy91aS9FZGl0VGFzay5zdmVsdGVcbmNvbnN0IGFiYnJldmlhdGlvbnMgPSB7XG4gICAgdGQ6ICd0b2RheScsXG4gICAgdG06ICd0b21vcnJvdycsXG4gICAgeWQ6ICd5ZXN0ZXJkYXknLFxuICAgIHR3OiAndGhpcyB3ZWVrJyxcbiAgICBudzogJ25leHQgd2VlaycsXG4gICAgd2Vla2VuZDogJ3NhdCcsXG4gICAgd2U6ICdzYXQnLFxufTtcblxuLyoqXG4gKiBFeHBhbmQgYW55IHJlY29nbmlzZWQgYWJicmV2aWF0aW9ucyBmb3IgZGF0ZXMuXG4gKlxuICogSW1wb3J0YW50OiB0aGUgYWJicmV2aWF0aW9uIGlzIG9ubHkgZXhwYW5kZWQgaWYgaXQgaXMgZm9vbG93ZWQgYnkgYSBzcGFjZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgJ3RkICcgaXMgZXhwYW5kZWQgdG8gJ3RvZGF5J1xuICogQHBhcmFtIGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvQXV0b2NvbXBsZXRlKGRhdGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGFiYnJldmlhdGlvbnMpKSB7XG4gICAgICAgIGRhdGUgPSBkYXRlLnJlcGxhY2UoUmVnRXhwKGBcXFxcYiR7a2V5fVxcXFxzYCwgJ2knKSwgdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG4iLCAiaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzJztcbmltcG9ydCB7IFByaW9yaXR5LCBUYXNrLCBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmFsbGJhY2sgfSBmcm9tICcuLi9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuLi9TdGF0dXNSZWdpc3RyeSc7XG5cbi8qKlxuICogUmVhZCBhbnkgbWFya2Rvd24gbGluZSBhbmQgdHJlYXQgaXQgYXMgYSB0YXNrLCBmb3IgdGhlIHB1cnBvc2VzIG9mXG4gKiB0aGUgJ0NyZWF0ZSBvciBlZGl0IHRhc2snIG1vZGFsLlxuICpcbiAqIFVubGlrZSB7QGxpbmsgVGFzay5mcm9tTGluZX0sIHdoaWNoIG9ubHkgcHJvY2Vzc2VzIHRhc2tzXG4gKiBhbHJlYWR5IHJlY29nbmlzZWQgYnkgdGhlIFRhc2tzIHBsdWdpbiwgdGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgYW55IGxpbmUuXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgdGhhdCBjb21tYW5kLCB3aGljaCBoYXMgYmVlbiBzZXBhcmF0ZWRcbiAqIG91dCB0byBhIGRpZmZlcmVudCBzb3VyY2UgZmlsZSBpbiBvcmRlciB0byBhbGxvdyBpdHMgbG9naWMgdG8gYmUgdGVzdGVkLlxuICpcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGxpbmUgdGhlIHVzZXIgaGFkIGNsaWNrZWQgb24gd2hlbiBydW5uaW5nICdDcmVhdGUgb3IgZWRpdCB0YXNrJyBjb21tYW5kXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIGxpbmVcbiAqL1xuZXhwb3J0IGNvbnN0IHRhc2tGcm9tTGluZSA9ICh7IGxpbmUsIHBhdGggfTogeyBsaW5lOiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KTogVGFzayA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2tEYXRlID0gRGF0ZUZhbGxiYWNrLmZyb21QYXRoKHBhdGgpO1xuXG4gICAgY29uc3QgdGFzayA9IFRhc2suZnJvbUxpbmUoe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBzZWN0aW9uU3RhcnQ6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBzZWN0aW9uSW5kZXg6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG51bGwsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBmYWxsYmFja0RhdGUsIC8vIHNldCB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgZmlsZW5hbWUsIHNvIGl0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIGRpYWxvZ1xuICAgIH0pO1xuXG4gICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIG5vdCBvbiBhIGxpbmUgb2YgYSB0YXNrLCB3ZSB0YWtlIHdoYXQgd2UgaGF2ZS5cbiAgICAvLyBUaGUgbm9uLXRhc2sgbGluZSBjYW4gc3RpbGwgYmUgYSBjaGVja2xpc3QsIGZvciBleGFtcGxlIGlmIGl0IGlzIGxhY2tpbmcgdGhlIGdsb2JhbCBmaWx0ZXIuXG4gICAgY29uc3Qgbm9uVGFza01hdGNoID0gbGluZS5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLm5vblRhc2tSZWdleCk7XG4gICAgaWYgKG5vblRhc2tNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeXRoaW5nIGluIHRoZSByZWdleCBpcyBvcHRpb25hbC5cbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza3M6IENhbm5vdCBjcmVhdGUgdGFzayBvbiBsaW5lOicsIGxpbmUpO1xuICAgICAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICAgICAgc3RhdHVzOiBTdGF0dXMuVE9ETyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbmRlbnRhdGlvbjogJycsXG4gICAgICAgICAgICBsaXN0TWFya2VyOiAnLScsXG4gICAgICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuTm9uZSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogbnVsbCxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICAgICAgZG9uZURhdGU6IG51bGwsXG4gICAgICAgICAgICByZWN1cnJlbmNlOiBudWxsLFxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgZm9sbG93aW5nIGZpZWxkcyB0byBlZGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgICAgIHNlY3Rpb25TdGFydDogMCxcbiAgICAgICAgICAgIHNlY3Rpb25JbmRleDogMCxcbiAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlcjogbnVsbCxcbiAgICAgICAgICAgIGJsb2NrTGluazogJycsXG4gICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgIG9yaWdpbmFsTWFya2Rvd246ICcnLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRlbnRhdGlvbjogc3RyaW5nID0gbm9uVGFza01hdGNoWzFdO1xuICAgIGNvbnN0IGxpc3RNYXJrZXIgPSBub25UYXNrTWF0Y2hbMl0gPz8gJy0nO1xuICAgIGNvbnN0IHN0YXR1c1N0cmluZzogc3RyaW5nID0gbm9uVGFza01hdGNoWzRdID8/ICcgJztcbiAgICBjb25zdCBzdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLmJ5U3ltYm9sT3JDcmVhdGUoc3RhdHVzU3RyaW5nKTtcblxuICAgIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nID0gbm9uVGFza01hdGNoWzVdO1xuXG4gICAgY29uc3QgYmxvY2tMaW5rTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYmxvY2tMaW5rUmVnZXgpO1xuICAgIGNvbnN0IGJsb2NrTGluayA9IGJsb2NrTGlua01hdGNoICE9PSBudWxsID8gYmxvY2tMaW5rTWF0Y2hbMF0gOiAnJztcblxuICAgIGlmIChibG9ja0xpbmsgIT09ICcnKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmJsb2NrTGlua1JlZ2V4LCAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUYXNrKHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgcGF0aCxcbiAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgIGxpc3RNYXJrZXIsXG4gICAgICAgIGJsb2NrTGluayxcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5Lk5vbmUsXG4gICAgICAgIHN0YXJ0RGF0ZTogbnVsbCxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogbnVsbCxcbiAgICAgICAgZHVlRGF0ZTogbnVsbCxcbiAgICAgICAgZG9uZURhdGU6IG51bGwsXG4gICAgICAgIHJlY3VycmVuY2U6IG51bGwsXG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGZvbGxvd2luZyBmaWVsZHMgdG8gZWRpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgIHNlY3Rpb25TdGFydDogMCxcbiAgICAgICAgc2VjdGlvbkluZGV4OiAwLFxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG51bGwsXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBvcmlnaW5hbE1hcmtkb3duOiAnJyxcbiAgICAgICAgLy8gTm90IG5lZWRlZCBzaW5jZSB0aGUgaW5mZXJyZWQgc3RhdHVzIGlzIGFsd2F5cyByZS1jb21wdXRlZCBhZnRlciBzdWJtaXR0aW5nLlxuICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDogZmFsc2UsXG4gICAgfSk7XG59O1xuIiwgImltcG9ydCB7IEVkaXRvciwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuLi9TdGF0dXNSZWdpc3RyeSc7XG5cbmltcG9ydCB7IFRhc2ssIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9UYXNrJztcblxuZXhwb3J0IGNvbnN0IHRvZ2dsZURvbmUgPSAoY2hlY2tpbmc6IGJvb2xlYW4sIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBWaWV3KSA9PiB7XG4gICAgaWYgKGNoZWNraW5nKSB7XG4gICAgICAgIGlmICghKHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluIGEgbWFya2Rvd24gdmlldywgdGhlIGNvbW1hbmQgc2hvdWxkbid0IGJlIHNob3duLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGNvbW1hbmQgc2hvdWxkIGFsd2F5cyB0cmlnZ2VyIGluIGEgbWFya2Rvd24gdmlldzpcbiAgICAgICAgLy8gLSBDb252ZXJ0IGxpbmVzIHRvIGxpc3QgaXRlbXMuXG4gICAgICAgIC8vIC0gQ29udmVydCBsaXN0IGl0ZW1zIHRvIHRhc2tzLlxuICAgICAgICAvLyAtIFRvZ2dsZSB0YXNrcycgc3RhdHVzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoISh2aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSkge1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuIGR1ZSB0byBjaGVjayBhYm92ZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIGFyZSBjZXJ0YWluIHdlIGFyZSBpbiB0aGUgZWRpdG9yIGR1ZSB0byB0aGUgY2hlY2sgYWJvdmUuXG4gICAgY29uc3QgcGF0aCA9IHZpZXcuZmlsZT8ucGF0aDtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnQ3Vyc29yUG9zID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBvcmlnQ3Vyc29yUG9zLmxpbmU7XG4gICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXG4gICAgY29uc3QgdG9nZ2xlZExpbmUgPSB0b2dnbGVMaW5lKGxpbmUsIHBhdGgpO1xuICAgIGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHRvZ2dsZWRMaW5lKTtcblxuICAgIC8qIEN1cnNvciBwb3NpdGlvbnMgYXJlIDAtYmFzZWQgZm9yIGJvdGggXCJsaW5lXCIgYW5kIFwiY2hcIiBvZmZzZXRzLlxuICAgICAqIElmIFwiY2hcIiBvZmZzZXQgYmlnZ2VyIHRoYW4gdGhlIGxpbmUgbGVuZ3RoLCB3aWxsIGp1c3QgY29udGludWUgdG8gbmV4dCBsaW5lKHMpLlxuICAgICAqIEJ5IGRlZmF1bHQgXCJlZGl0b3Iuc2V0TGluZSgpXCIgYXBwZWFycyB0byBlaXRoZXIga2VlcCB0aGUgY3Vyc29yIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgaWYgaXQgaXMgYWxyZWFkeSB0aGVyZSxcbiAgICAgKiAuLi5vciBtb3ZlIGl0IHRvIHRoZSBiZWdpbm5pbmcgaWYgaXQgaXMgYW55d2hlcmUgZWxzZS4gTGljYXQgZXhwbGFpbmVkIHRoaXMgb24gRGlzY29yZCBhcyBcInN0aWNraW5nXCIgdG8gb25lIHNpZGUgb3IgYW5vdGhlci5cbiAgICAgKiBQcmV2aW91c2x5LCBUYXNrcyB3b3VsZCByZXNldCttb3ZlLXJpZ2h0IHRoZSBjdXJzb3IgaWYgdGhlcmUgd2FzIGFueSB0ZXh0IGluIHRoZSBsaW5lLCBpbmNsdWRpbmcgc29tZXRoaW5nIGluc2lkZSB0aGUgY2hlY2tib3gsXG4gICAgICogbW92aW5nIHJpZ2h0IGJ5ICh0b2dnbGVkTGluZS5sZW5ndGggLSBsaW5lLmxlbmd0aCkuIChTdXBwb3NlZGx5LCBidXQgaXQgc3RpbGwgbW92ZXMgcmlnaHQsIGp1c3QgYnkgbGVzcywgaWYgdGhlIHRvZ2dsZWRMaW5lIGlzIHNob3J0ZXIgdGhhbiB0aGUgb2xkKS5cbiAgICAgKiBUaGlzIG1pc3NlZCB0aGUgbmVlZCB0byBtb3ZlIHJpZ2h0IG9uIHRoZSBibGFuayBsaW5lIHRvIFwiLSBcIiBjYXNlIChpc3N1ZSAjNDYwKS5cbiAgICAgKiBUaGlzIGFsc28gbWVhbnQgdGhlIGN1cnNvciBtb3ZlZCBub25zZW5zaWNhbGx5IGlmIGl0IHdhcyBiZWZvcmUgYW55IG5ld2x5IGluc2VydGVkIHRleHQsXG4gICAgICogc3VjaCBhcyBhIGRvbmUgZGF0ZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCBvciBhZnRlciB0aGUgXCI+XCIgd2hlbiBcIj4gLVwiIGNoYW5nZWQgdG8gXCI+IC0gWyBdXCIuXG4gICAgICovXG4gICAgLy8gUmVzZXQgdGhlIGN1cnNvci4gVXNlIHRoZSBkaWZmZXJlbmNlIGluIGxpbmUgbGVuZ3RocyBhbmQgb3JpZ2luYWwgY3Vyc29yIHBvc2l0aW9uIHRvIGRldGVybWluZSBiZWhhdmlvclxuICAgIGVkaXRvci5zZXRDdXJzb3Ioe1xuICAgICAgICBsaW5lOiBvcmlnQ3Vyc29yUG9zLmxpbmUsXG4gICAgICAgIGNoOiBjYWxjdWxhdGVDdXJzb3JPZmZzZXQob3JpZ0N1cnNvclBvcy5jaCwgbGluZSwgdG9nZ2xlZExpbmUpLFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvZ2dsZUxpbmUgPSAobGluZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgdG9nZ2xlZExpbmUgPSBsaW5lO1xuXG4gICAgY29uc3QgdGFzayA9IFRhc2suZnJvbUxpbmUoe1xuICAgICAgICAvLyBXaHkgYXJlIHdlIHVzaW5nIFRhc2suZnJvbUxpbmUgaW5zdGVhZCBvZiB0aGUgQ2FjaGUgaGVyZT9cbiAgICAgICAgbGluZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc2VjdGlvblN0YXJ0OiAwLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgc2VjdGlvbkluZGV4OiAwLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICB9KTtcbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICB0b2dnbGVkTGluZSA9IHRvZ2dsZVRhc2sodGFzayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhc2sgaXMgbnVsbCB0aGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgb2Y6XG4gICAgICAgIC8vIDEuIGEgcmVndWxhciBjaGVja2xpc3QgaXRlbVxuICAgICAgICAvLyAyLiBhIGxpc3QgaXRlbVxuICAgICAgICAvLyAzLiBhIHNpbXBsZSB0ZXh0IGxpbmVcbiAgICAgICAgLy8gNC4gYSBzdGFuZGFyZCB0YXNrLCBidXQgd2hpY2ggZG9lcyBub3QgY29udGFpbiB0aGUgZ2xvYmFsIGZpbHRlciwgdG8gYmUgdG9nZ2xlZCwgYnV0IG5vIGRvbmUgZGF0ZSBhZGRlZC5cblxuICAgICAgICAvLyBUaGUgdGFzayByZWdleCB3aWxsIG1hdGNoIGNoZWNrbGlzdCBpdGVtcy5cbiAgICAgICAgY29uc3QgcmVnZXhNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgpO1xuICAgICAgICBpZiAocmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBzdGF0dXMgb2YgdGhlIGNoZWNrbGlzdCBpdGVtLlxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzU3RyaW5nID0gcmVnZXhNYXRjaFszXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuYnlTeW1ib2woc3RhdHVzU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXR1c1N0cmluZyA9IHN0YXR1cy5uZXh0U3RhdHVzU3ltYm9sO1xuICAgICAgICAgICAgdG9nZ2xlZExpbmUgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgsIGAkMS0gWyR7bmV3U3RhdHVzU3RyaW5nfV0gJDRgKTtcbiAgICAgICAgfSBlbHNlIGlmIChUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RJdGVtUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbGlzdCBpdGVtIHRvIGEgY2hlY2tsaXN0IGl0ZW0uXG4gICAgICAgICAgICB0b2dnbGVkTGluZSA9IGxpbmUucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RJdGVtUmVnZXgsICckMSQyIFsgXScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbGluZSB0byBhIGxpc3QgaXRlbS5cbiAgICAgICAgICAgIHRvZ2dsZWRMaW5lID0gbGluZS5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaW5kZW50YXRpb25SZWdleCwgJyQxLSAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2dnbGVkTGluZTtcbn07XG5cbmNvbnN0IHRvZ2dsZVRhc2sgPSAodGFzazogVGFzayk6IHN0cmluZyA9PiB7XG4gICAgLy8gVG9nZ2xpbmcgYSByZWN1cnJpbmcgdGFzayB3aWxsIHByb2R1Y2UgdHdvIFRhc2tzXG4gICAgY29uc3QgdG9nZ2xlZFRhc2tzID0gdGFzay50b2dnbGUoKTtcbiAgICByZXR1cm4gdG9nZ2xlZFRhc2tzLm1hcCgodGFzazogVGFzaykgPT4gdGFzay50b0ZpbGVMaW5lU3RyaW5nKCkpLmpvaW4oJ1xcbicpO1xufTtcblxuLyogQ2FzZXMgKGFub3RoZXIgd2F5KTpcbjApIExpbmUgZ290IHNob3J0ZXI6IGRvbmUgZGF0ZSByZW1vdmVkIGZyb20gZW5kIG9mIHRhc2ssIGN1cnNvciBzaG91bGQgcmVzZXQgb3IgYmUgbW92ZWQgdG8gbmV3IGVuZCBpZiByZXNldCBwb3NpdGlvbiBpcyB0b28gbG9uZy5cbjEpIExpbmUgc3RheWVkIHRoZSBzYW1lIGxlbmd0aDogQ2hlY2tpbmcgJiB1bmNoZWNraW5nIHRleHRib3ggdGhhdCBpcyBub3QgYSB0YXNrIC0gY3Vyc29yIHNob3VsZCByZXNldC5cbjIpIExpbmUgZ290IGxvbmdlcjpcbiAgICBhKSBMaXN0IG1hcmtlciBjb3VsZCBoYXZlIGJlZW4gYWRkZWQuIEZpbmQgaXQgaW4gbmV3IHRleHQ6IGlmIGN1cnNvciB3YXMgYXQgb3IgcmlnaHQgb2Ygd2hlcmUgaXQgd2FzIGFkZGVkLCBtb3ZlIHRoZSBjdXJzb3IgcmlnaHQuXG4gICAgYikgRW1wdHkgY2hlY2tib3ggY291bGQgaGF2ZSBiZWVuIGFkZGVkLiBJZiBjdXJzb3Igd2FzIGFmdGVyIHRoZSBsaXN0IG1hcmtlciAoaW4gb2xkIG9yIG5ldyksIGl0IHNob3VsZCBtb3ZlIHJpZ2h0LlxuICAgIGMpIERvbmUgZW1vamkgYW5kIGRhdGUgY291bGQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBlbmQuIEN1cnNvciBzaG91bGQgcmVzZXQgaWYgMCwgYW5kIHN0YXkgZW5kIG9mIGxpbmUgb3RoZXJ3aXNlLlxuICAgIGQpIFJlY3VycmluZyB0YXNrIGNvdWxkIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIGFuZCBkb25lIGVtb2ppIGFuZCBkYXRlIGFkZGVkIHRvIHRoZSBlbmQuIEN1cnJlbnQgYmVoYXZpb3IgYWRkcyBzbyBtdWNoIHRvIHRoZSBvZmZzZXQgdG8gbWFrZSB0aGlzIHJpZ2h0LlxuXG5TbyBjdXJzb3Igc2hvdWxkIGJlIHJlc2V0IGlmIDAsIHdoaWNoIGluY2x1ZGVzIGJlaW5nIG1vdmVkIHRvIG5ldyBlbmQgaWYgZ290IHNob3J0ZXIuIFRoZW4gbWlnaHQgbmVlZCB0byBtb3ZlIHJpZ2h0IDIgb3IgMy5cbiovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlQ3Vyc29yT2Zmc2V0ID0gKG9yaWdDdXJzb3JDaDogbnVtYmVyLCBsaW5lOiBzdHJpbmcsIHRvZ2dsZWRMaW5lOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgbmV3TGluZUxlbiA9IHRvZ2dsZWRMaW5lLmxlbmd0aDtcbiAgICBpZiAobmV3TGluZUxlbiA8PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAvLyBMaW5lIGdvdCBzaG9ydGVyIG9yIHN0YXllZCBzYW1lIGxlbmd0aC4gUmVzZXQgY3Vyc29yIHRvIG9yaWdpbmFsIHBvc2l0aW9uLCBjYXBwZWQgYXQgZW5kIG9mIGxpbmUuXG4gICAgICAgIHJldHVybiBvcmlnQ3Vyc29yQ2ggPj0gdG9nZ2xlZExpbmUubGVuZ3RoID8gbmV3TGluZUxlbiA6IG9yaWdDdXJzb3JDaDtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsLWNhc2UgZm9yIGRvbmUtZGF0ZSBhcHBlbmQsIGZpeGVzICM0NDlcbiAgICBjb25zdCBkb25lRGF0ZUxlbmd0aCA9ICcgXHUyNzA1IFlZWVktTU0tREQnLmxlbmd0aDtcbiAgICBpZiAodG9nZ2xlZExpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kb25lRGF0ZVJlZ2V4KSAmJiBuZXdMaW5lTGVuIC0gbGluZS5sZW5ndGggPj0gZG9uZURhdGVMZW5ndGgpIHtcbiAgICAgICAgbmV3TGluZUxlbiAtPSBkb25lRGF0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVjdXJyaW5nIHRhc2tzOiBlbnRpcmUgbGluZSBwbHVzIG5ld2xpbmUgcHJlcGVuZGVkLiBGaXggZm9yICM0NDkgYWJvdmUgbWVhbnMgYXBwZW5kZWQgZG9uZSBkYXRlIHRyZWF0ZWQgY29ycmVjdGx5LlxuICAgIGlmIChuZXdMaW5lTGVuID49IDIgKiBsaW5lLmxlbmd0aCAmJiB0b2dnbGVkTGluZS5zZWFyY2goJy4rXFxuLisnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdDdXJzb3JDaCArIG5ld0xpbmVMZW4gLSBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKiBMaW5lIGdvdCBsb25nZXIsIG5vdCBhIHJlY3VycmluZyB0YXNrLiBXZXJlIHRoZSBhZGRlZCBjaGFyYWN0ZXJzIGJlZm9yZSBvciBhZnRlciB0aGUgY3Vyc29yP1xuICAgICAqIEF0IHRoaXMgcG9pbnQgdGhlIGxpbmUgaXMgYXQgbGVhc3QgYSBsaXN0IGl0ZW0uIEZpbmQgdGhlIGZpcnN0IGxpc3QgbWFya2VyLiAqL1xuICAgIGNvbnN0IGZpcnN0TGlzdEl0ZW1DaGFyID0gdG9nZ2xlZExpbmUuc2VhcmNoKC9bLSpdLyk7XG4gICAgaWYgKG9yaWdDdXJzb3JDaCA8IGZpcnN0TGlzdEl0ZW1DaGFyKSB7XG4gICAgICAgIC8vIEN1cnNvciB3YXMgaW4gaW5kZW50YXRpb24uIFJlc2V0IHRvIHdoZXJlIGl0IHdhcy5cbiAgICAgICAgcmV0dXJuIG9yaWdDdXJzb3JDaDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ0N1cnNvckNoICsgbmV3TGluZUxlbiAtIGxpbmUubGVuZ3RoO1xufTtcbiIsICJpbXBvcnQgdHlwZSB7IEFwcCwgRWRpdG9yLCBQbHVnaW4sIFZpZXcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBjcmVhdGVPckVkaXQgfSBmcm9tICcuL0NyZWF0ZU9yRWRpdCc7XG5cbmltcG9ydCB7IHRvZ2dsZURvbmUgfSBmcm9tICcuL1RvZ2dsZURvbmUnO1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZHMge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcGx1Z2luOiBQbHVnaW47XG5cbiAgICBwcml2YXRlIGdldCBhcHAoKTogQXBwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLmFwcDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiB9OiB7IHBsdWdpbjogUGx1Z2luIH0pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cbiAgICAgICAgcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdlZGl0LXRhc2snLFxuICAgICAgICAgICAgbmFtZTogJ0NyZWF0ZSBvciBlZGl0IHRhc2snLFxuICAgICAgICAgICAgaWNvbjogJ3BlbmNpbCcsXG4gICAgICAgICAgICBlZGl0b3JDaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4sIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBWaWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9yRWRpdChjaGVja2luZywgZWRpdG9yLCB2aWV3LCB0aGlzLmFwcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3RvZ2dsZS1kb25lJyxcbiAgICAgICAgICAgIG5hbWU6ICdUb2dnbGUgdGFzayBkb25lJyxcbiAgICAgICAgICAgIGljb246ICdjaGVjay1pbi1jaXJjbGUnLFxuICAgICAgICAgICAgZWRpdG9yQ2hlY2tDYWxsYmFjazogdG9nZ2xlRG9uZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgRXZlbnRSZWYsIEV2ZW50cyBhcyBPYnNpZGlhbkV2ZW50cyB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHR5cGUgeyBTdGF0ZSB9IGZyb20gJy4vQ2FjaGUnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxuZW51bSBFdmVudCB7XG4gICAgQ2FjaGVVcGRhdGUgPSAnb2JzaWRpYW4tdGFza3MtcGx1Z2luOmNhY2hlLXVwZGF0ZScsXG4gICAgUmVxdWVzdENhY2hlVXBkYXRlID0gJ29ic2lkaWFuLXRhc2tzLXBsdWdpbjpyZXF1ZXN0LWNhY2hlLXVwZGF0ZScsXG59XG5cbmludGVyZmFjZSBDYWNoZVVwZGF0ZURhdGEge1xuICAgIHRhc2tzOiBUYXNrW107XG4gICAgc3RhdGU6IFN0YXRlO1xufVxuXG5leHBvcnQgY2xhc3MgVGFza3NFdmVudHMge1xuICAgIHByaXZhdGUgb2JzaWRpYW5FdmVudHM6IE9ic2lkaWFuRXZlbnRzO1xuXG4gICAgY29uc3RydWN0b3IoeyBvYnNpZGlhbkV2ZW50cyB9OiB7IG9ic2lkaWFuRXZlbnRzOiBPYnNpZGlhbkV2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMgPSBvYnNpZGlhbkV2ZW50cztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DYWNoZVVwZGF0ZShoYW5kbGVyOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2lkaWFuRXZlbnRzLm9uKEV2ZW50LkNhY2hlVXBkYXRlLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJpZ2dlckNhY2hlVXBkYXRlKGNhY2hlRGF0YTogQ2FjaGVVcGRhdGVEYXRhKTogdm9pZCB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMudHJpZ2dlcihFdmVudC5DYWNoZVVwZGF0ZSwgY2FjaGVEYXRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25SZXF1ZXN0Q2FjaGVVcGRhdGUoaGFuZGxlcjogKGZuOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2lkaWFuRXZlbnRzLm9uKEV2ZW50LlJlcXVlc3RDYWNoZVVwZGF0ZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcHVibGljIHRyaWdnZXJSZXF1ZXN0Q2FjaGVVcGRhdGUoZm46IChjYWNoZURhdGE6IENhY2hlVXBkYXRlRGF0YSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9ic2lkaWFuRXZlbnRzLnRyaWdnZXIoRXZlbnQuUmVxdWVzdENhY2hlVXBkYXRlLCBmbik7XG4gICAgfVxuXG4gICAgcHVibGljIG9mZihldmVudFJlZjogRXZlbnRSZWYpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vYnNpZGlhbkV2ZW50cy5vZmZyZWYoZXZlbnRSZWYpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJ0NvbmZpZy9TZXR0aW5ncyc7XG5cbmltcG9ydCB0eXBlIHsgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBjbGFzcyBJbmxpbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoeyBwbHVnaW4gfTogeyBwbHVnaW46IFBsdWdpbiB9KSB7XG4gICAgICAgIHBsdWdpbi5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3Nvcih0aGlzLl9tYXJrZG93blBvc3RQcm9jZXNzb3IuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcmtkb3duUG9zdFByb2Nlc3NvciA9IHRoaXMuX21hcmtkb3duUG9zdFByb2Nlc3Nvci5iaW5kKHRoaXMpO1xuXG4gICAgcHJpdmF0ZSBhc3luYyBfbWFya2Rvd25Qb3N0UHJvY2Vzc29yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250ZXh0OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zdCByZW5kZXJlZEVsZW1lbnRzID0gZWxlbWVudC5maW5kQWxsKCcudGFzay1saXN0LWl0ZW0nKS5maWx0ZXIoKHRhc2tJdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lc1RleHQgPSB0YXNrSXRlbS50ZXh0Q29udGVudD8uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBsaW5lLiBDYW4gYmUgbXVsdGlwbGUgbGluZXMgaWYgYW4gTEkgZWxlbWVudCBjb250YWlucyBhbiBVTC5cbiAgICAgICAgICAgIC8vIFdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBsZXZlbCBMSSBpbmRlcGVuZGVudGx5IGZyb20gaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgZmFsc2UgcG9zaXRpdmUsIHdoZW4gdGhlIExJIHdhc24ndCBhIHRhc2sgaXRzZWxmLCBidXQgY29udGFpbmVkIHRoZVxuICAgICAgICAgICAgLy8gZ2xvYmFsIGZpbHRlciBpbiBjaGlsZCBMSXMuXG4gICAgICAgICAgICBsZXQgZmlyc3RMaW5lVGV4dDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBsaW5lIGlzIHRoZSBmaXJzdCBsaW5lIHRoYXQgaXMgbm90IGVtcHR5LiBFbXB0eSBsaW5lcyBjYW4gZXhpc3Qgd2hlblxuICAgICAgICAgICAgLy8gdGhlIGNoZWNrbGlzdCBpbiBtYXJrZG93biBpbmNsdWRlcyBibGFuayBsaW5lcyAoc2VlICMzMTMpLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc1RleHQubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZXNUZXh0W2ldICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmVUZXh0ID0gbGluZXNUZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdExpbmVUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RMaW5lVGV4dC5pbmNsdWRlcyhnbG9iYWxGaWx0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBObyB0YXNrcyBtZWFucyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IGNvbnRleHQuc291cmNlUGF0aDtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGNvbnRleHQuZ2V0U2VjdGlvbkluZm8oZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBwcm9jZXNzIHRoZSByZW5kZXIgd2l0aG91dCB0aGUgc2VjdGlvbiBpbmZvLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZUxpbmVzID0gc2VjdGlvbi50ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICBsZXQgc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZmlsZVRhc2tzOiBUYXNrW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGluZU51bWJlciA9IHNlY3Rpb24ubGluZVN0YXJ0OyBsaW5lTnVtYmVyIDw9IHNlY3Rpb24ubGluZUVuZDsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZmlsZUxpbmVzW2xpbmVOdW1iZXJdO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGVuZCB1cCBvdXRzaWRlIHRoZSByYW5nZSBvZiB0aGUgZmlsZSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgcHJvY2VzcyB0aGlzIHRhc2suXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBUYXNrLmZyb21MaW5lKHtcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgc2VjdGlvblN0YXJ0OiBzZWN0aW9uLmxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoZSBwcmVjZWRpbmcgaGVhZGVyIGZvciBpbi1saW5lIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICBmYWxsYmFja0RhdGU6IG51bGwsIC8vIFdlIGRvbid0IG5lZWQgdGhlIGZhbGxiYWNrIGRhdGUgZm9yIGluLWxpbmUgcmVuZGVyaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmlsZVRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc2VjdGlvbiBpbmRleCBpcyB0aGUgbnRoIHRhc2sgd2l0aGluIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbkluZGV4ID0gMDsgc2VjdGlvbkluZGV4IDwgcmVuZGVyZWRFbGVtZW50cy5sZW5ndGg7IHNlY3Rpb25JbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gZmlsZVRhc2tzW3NlY3Rpb25JbmRleF07XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZEVsZW1lbnQgPSByZW5kZXJlZEVsZW1lbnRzW3NlY3Rpb25JbmRleF07XG5cbiAgICAgICAgICAgIGlmICh0YXNrID09PSB1bmRlZmluZWQgfHwgcmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWluZyBtYXRjaCBvZiB0YXNrcyBpbiBmaWxlIGFuZCByZW5kZXIgcHJldmlldy5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG1pcy1tYXRjaCBpbiB0aGUgbnVtYmVycywgd2Ugc3RpbGwgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIHdoYXQgd2UgY2FuLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkYXRhTGluZTogc3RyaW5nID0gcmVuZGVyZWRFbGVtZW50LmdldEF0dHIoJ2RhdGEtbGluZScpID8/ICcwJztcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJbmRleDogbnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGRhdGFMaW5lLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB0YXNrRWxlbWVudCA9IGF3YWl0IHRhc2sudG9MaSh7XG4gICAgICAgICAgICAgICAgcGFyZW50VWxFbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGxpc3RJbmRleCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBhIHN1Yi1saXN0IG9yIHN1Yi1kaXYgKGUuZy4gdGhlXG4gICAgICAgICAgICAvLyBmb2xkaW5nIGFycm93KSwgd2UgbmVlZCB0byBrZWVwIGl0LlxuICAgICAgICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZHJlbiA9IHJlbmRlcmVkRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZENoaWxkcmVuLmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkQ2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RpdicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza0VsZW1lbnQucHJlcGVuZChyZW5kZXJlZENoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbmRlcmVkQ2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrRWxlbWVudC5hcHBlbmQocmVuZGVyZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZS1zZXQgdGhlIG9yaWdpbmFsIGZvb3Rub3Rlcy5cbiAgICAgICAgICAgIC8vIFRoZSBuZXdseSByZW5kZXJlZCBIVE1MIHdvbid0IGhhdmUgdGhlIGNvcnJlY3QgaW5kZXhlcyBhbmQgbGlua3NcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGRvY3VtZW50LlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb290bm90ZXMgPSByZW5kZXJlZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZm9vdG5vdGUtaWRdJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdGb290bm90ZXMgPSB0YXNrRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mb290bm90ZS1pZF0nKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEZvb3Rub3Rlcy5sZW5ndGggPT09IG5ld0Zvb3Rub3Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsRm9vdG5vdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Zvb3Rub3Rlc1tpXS5yZXBsYWNlV2l0aChvcmlnaW5hbEZvb3Rub3Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQucmVwbGFjZVdpdGgodGFza0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcsIFZpZXdQbHVnaW4gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB0eXBlIHsgUGx1Z2luVmFsdWUgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBjb25zdCBuZXdMaXZlUHJldmlld0V4dGVuc2lvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoTGl2ZVByZXZpZXdFeHRlbnNpb24pO1xufTtcblxuY2xhc3MgTGl2ZVByZXZpZXdFeHRlbnNpb24gaW1wbGVtZW50cyBQbHVnaW5WYWx1ZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSB2aWV3OiBFZGl0b3JWaWV3O1xuXG4gICAgY29uc3RydWN0b3IodmlldzogRWRpdG9yVmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCA9IHRoaXMuaGFuZGxlQ2xpY2tFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDbGlja0V2ZW50KGV2ZW50OiBNb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudDtcblxuICAgICAgICAvLyBPbmx5IGhhbmRsZSBjaGVja2JveCBjbGlja3MuXG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkgfHwgdGFyZ2V0LnR5cGUgIT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFJpZ2h0IG5vdyBPYnNpZGlhbiBBUEkgZG9lcyBub3QgZ2l2ZSB1cyBhIHdheSB0byBoYW5kbGUgY2hlY2tib3ggY2xpY2tzIGluc2lkZSByZW5kZXJlZC13aWRnZXRzLWluLUxQIHN1Y2ggYXNcbiAgICAgICAgICogY2FsbG91dHMsIHRhYmxlcywgYW5kIHRyYW5zY2x1c2lvbnMgYmVjYXVzZSBgdGhpcy52aWV3LnBvc0F0RE9NYCB3aWxsIHJldHVybiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB3aWRnZXRcbiAgICAgICAgICogYXMgdGhlIHBvc2l0aW9uIGZvciBhbnkgY2xpY2sgaW5zaWRlIHRoZSB3aWRnZXQuXG4gICAgICAgICAqIEZvciBjYWxsb3V0cywgdGhpcyBtZWFucyB0aGF0IHRoZSB0YXNrIHdpbGwgbmV2ZXIgYmUgZm91bmQsIHNpbmNlIHRoZSBgbGluZUF0YCB3aWxsIGJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNhbGxvdXQuXG4gICAgICAgICAqIFRoZXJlZm9yZSwgcHJvZHVjZSBhbiBlcnJvciBtZXNzYWdlIHBvcC11cCB1c2luZyBPYnNpZGlhbidzIFwiTm90aWNlXCIgZmVhdHVyZSwgbG9nIGEgY29uc29sZSB3YXJuaW5nLCB0aGVuIHJldHVybi5cbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gVGFza3MgZnJvbSBcInRhc2tcIiBxdWVyeSBjb2RlYmxvY2tzIGhhbmRsZSB0aGVtc2VsdmVzIHRoYW5rcyB0byBgdG9MaWAsIHNvIGJlIHNwZWNpZmljIGFib3V0IGVycm9yIG1lc3NhZ2luZywgYnV0IHN0aWxsIHJldHVybi5cbiAgICAgICAgY29uc3QgYW5jZXN0b3IgPSB0YXJnZXQuY2xvc2VzdCgndWwucGx1Z2luLXRhc2tzLXF1ZXJ5LXJlc3VsdCwgZGl2LmNhbGxvdXQtY29udGVudCcpO1xuICAgICAgICBpZiAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGlmIChhbmNlc3Rvci5tYXRjaGVzKCdkaXYuY2FsbG91dC1jb250ZW50JykpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBtZXNzYWdlIGZvciBub3cuXG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgICAgICAgICAgICAgJ29ic2lkaWFuLXRhc2tzLXBsdWdpbiB3YXJuaW5nOiBUYXNrcyBjYW5ub3QgYWRkIG9yIHJlbW92ZSBjb21wbGV0aW9uIGRhdGVzIG9yIG1ha2UgdGhlIG5leHQgY29weSBvZiBhIHJlY3VycmluZyB0YXNrIGZvciB0YXNrcyB3cml0dGVuIGluc2lkZSBhIGNhbGxvdXQgd2hlbiB5b3UgY2xpY2sgdGhlaXIgY2hlY2tib3hlcyBpbiBMaXZlIFByZXZpZXcuIFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnSWYgeW91IHdhbnRlZCBUYXNrcyB0byBkbyB0aGVzZSB0aGluZ3MsIHBsZWFzZSB1bmRvIHlvdXIgY2hhbmdlLCB0aGVuIGVpdGhlciBjbGljayB0aGUgbGluZSBvZiB0aGUgdGFzayBhbmQgdXNlIHRoZSBcIlRvZ2dsZSBUYXNrIERvbmVcIiBjb21tYW5kLCBvciBzd2l0Y2ggdG8gUmVhZGluZyBWaWV3IHRvIGNsaWNrIHRoZSBjaGVja2JveC4nO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UobXNnLCA0NTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy52aWV3LnBvc0F0RE9NKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgdGFzayA9IFRhc2suZnJvbUxpbmUoe1xuICAgICAgICAgICAgbGluZTogbGluZS50ZXh0LFxuICAgICAgICAgICAgLy8gTm9uZSBvZiB0aGlzIGRhdGEgaXMgcmVsZXZhbnQgaGVyZS5cbiAgICAgICAgICAgIC8vIFRoZSB0YXNrIGlzIGNyZWF0ZWQsIHRvZ2dsZWQsIGFuZCB3cml0dGVuIGJhY2sgdG8gdGhlIENNNiBkb2N1bWVudCxcbiAgICAgICAgICAgIC8vIHJlcGxhY2luZyB0aGUgb2xkIHRhc2sgaW4tcGxhY2UuXG4gICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgIHNlY3Rpb25TdGFydDogMCxcbiAgICAgICAgICAgIHNlY3Rpb25JbmRleDogMCxcbiAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlcjogbnVsbCxcbiAgICAgICAgICAgIGZhbGxiYWNrRGF0ZTogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5kZWJ1ZyhgTGl2ZSBQcmV2aWV3IEV4dGVuc2lvbjogdG9nZ2xlIGNhbGxlZC4gUG9zaXRpb246ICR7cG9zaXRpb259IExpbmU6ICR7bGluZS50ZXh0fWApO1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94ZXMgb2YgdGFza3MuXG4gICAgICAgIGlmICh0YXNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXZlbnQgZGVmYXVsdCBzbyB0aGF0IHRoZSBjaGVja2JveCBpcyBvbmx5IGhhbmRsZWQgYnkgdXMgYW5kIG5vdCBvYnNpZGlhbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBDbGlja2VkIG9uIGEgdGFzaydzIGNoZWNrYm94LiBUb2dnbGUgdGhlIHRhc2sgYW5kIHNldCBpdC5cbiAgICAgICAgY29uc3QgdG9nZ2xlZCA9IHRhc2sudG9nZ2xlKCk7XG4gICAgICAgIGNvbnN0IHRvZ2dsZWRTdHJpbmcgPSB0b2dnbGVkLm1hcCgodCkgPT4gdC50b0ZpbGVMaW5lU3RyaW5nKCkpLmpvaW4oc3RhdGUubGluZUJyZWFrKTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgQ29kZU1pcnJvciB0cmFuc2FjdGlvbiBpbiBvcmRlciB0byB1cGRhdGUgdGhlIGRvY3VtZW50LlxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgZnJvbTogbGluZS5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBsaW5lLnRvLFxuICAgICAgICAgICAgICAgIGluc2VydDogdG9nZ2xlZFN0cmluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuXG4gICAgICAgIC8vIERpcnR5IHdvcmthcm91bmQuXG4gICAgICAgIC8vIFdoaWxlIHRoZSBjb2RlIGluIHRoaXMgbWV0aG9kIHByb3Blcmx5IHVwZGF0ZXMgdGhlIGBjaGVja2VkYCBzdGF0ZVxuICAgICAgICAvLyBvZiB0aGUgdGFyZ2V0IGNoZWNrYm94LCBzb21lIE9ic2lkaWFuIGludGVybmFscyByZXZlcnQgdGhlIHN0YXRlLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIGNoZWNrYm94IHdvdWxkIHJlbWFpbiBpbiBpdHMgb3JpZ2luYWwgYGNoZWNrZWRgXG4gICAgICAgIC8vIHN0YXRlIChgdHJ1ZWAgb3IgYGZhbHNlYCksIGV2ZW4gdGhvdWdoIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50XG4gICAgICAgIC8vIHVwZGF0ZXMgY29ycmVjdGx5LlxuICAgICAgICAvLyBBcyBhIFwiZml4XCIsIHdlIHNldCB0aGUgY2hlY2tib3gncyBgY2hlY2tlZGAgc3RhdGUgKmFnYWluKiBhZnRlciBhXG4gICAgICAgIC8vIHRpbWVvdXQgdG8gcmV2ZXJ0IE9ic2lkaWFuJ3Mgd3JvbmdmdWwgcmV2ZXJzYWwuXG4gICAgICAgIGNvbnN0IGRlc2lyZWRDaGVja2VkU3RhdHVzID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0LmNoZWNrZWQgPSBkZXNpcmVkQ2hlY2tlZFN0YXR1cztcbiAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTWFya2Rvd25SZW5kZXJDaGlsZCwgTWFya2Rvd25SZW5kZXJlciwgUGx1Z2luLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgRXZlbnRSZWYsIE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB0eXBlIHsgSVF1ZXJ5IH0gZnJvbSAnLi9JUXVlcnknO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL0NhY2hlJztcbmltcG9ydCB7IHJlcGxhY2VUYXNrV2l0aFRhc2tzIH0gZnJvbSAnLi9GaWxlJztcbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSAnLi9RdWVyeS9RdWVyeSc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwSGVhZGluZyB9IGZyb20gJy4vUXVlcnkvR3JvdXBIZWFkaW5nJztcbmltcG9ydCB7IFRhc2tNb2RhbCB9IGZyb20gJy4vVGFza01vZGFsJztcbmltcG9ydCB0eXBlIHsgVGFza3NFdmVudHMgfSBmcm9tICcuL1Rhc2tzRXZlbnRzJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmFsbGJhY2sgfSBmcm9tICcuL0RhdGVGYWxsYmFjayc7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVJlbmRlcmVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBUYXNrc0V2ZW50cztcblxuICAgIGNvbnN0cnVjdG9yKHsgcGx1Z2luLCBldmVudHMgfTogeyBwbHVnaW46IFBsdWdpbjsgZXZlbnRzOiBUYXNrc0V2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG5cbiAgICAgICAgcGx1Z2luLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoJ3Rhc2tzJywgdGhpcy5fYWRkUXVlcnlSZW5kZXJDaGlsZC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUXVlcnlSZW5kZXJDaGlsZCA9IHRoaXMuX2FkZFF1ZXJ5UmVuZGVyQ2hpbGQuYmluZCh0aGlzKTtcblxuICAgIHByaXZhdGUgYXN5bmMgX2FkZFF1ZXJ5UmVuZGVyQ2hpbGQoc291cmNlOiBzdHJpbmcsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250ZXh0OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuYWRkQ2hpbGQoXG4gICAgICAgICAgICBuZXcgUXVlcnlSZW5kZXJDaGlsZCh7XG4gICAgICAgICAgICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGNvbnRleHQuc291cmNlUGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgIH1cbn1cblxuY2xhc3MgUXVlcnlSZW5kZXJDaGlsZCBleHRlbmRzIE1hcmtkb3duUmVuZGVyQ2hpbGQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwOiBBcHA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudHM6IFRhc2tzRXZlbnRzO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc291cmNlOiBzdHJpbmc7IC8vIFRoZSBjb21wbGV0ZSB0ZXh0IGluIHRoZSBpbnN0cnVjdGlvbiBibG9jaywgc3VjaCBhcyAnbm90IGRvbmVcXG5zaG9ydCBtb2RlJ1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsZVBhdGg6IHN0cmluZzsgLy8gVGhlIHBhdGggb2YgdGhlIGZpbGUgdGhhdCBjb250YWlucyB0aGUgaW5zdHJ1Y3Rpb24gYmxvY2tcbiAgICBwcml2YXRlIHF1ZXJ5OiBJUXVlcnk7XG4gICAgcHJpdmF0ZSBxdWVyeVR5cGU6IHN0cmluZztcblxuICAgIHByaXZhdGUgcmVuZGVyRXZlbnRSZWY6IEV2ZW50UmVmIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgcXVlcnlSZWxvYWRUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgYXBwLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBmaWxlUGF0aCxcbiAgICB9OiB7XG4gICAgICAgIGFwcDogQXBwO1xuICAgICAgICBldmVudHM6IFRhc2tzRXZlbnRzO1xuICAgICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50O1xuICAgICAgICBzb3VyY2U6IHN0cmluZztcbiAgICAgICAgZmlsZVBhdGg6IHN0cmluZztcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuXG4gICAgICAgIC8vIFRoZSBlbmdpbmUgaXMgY2hvc2VuIG9uIHRoZSBiYXNpcyBvZiB0aGUgY29kZSBibG9jayBsYW5ndWFnZS4gQ3VycmVudGx5XG4gICAgICAgIC8vIHRoZXJlIGlzIG9ubHkgdGhlIG1haW4gZW5naW5lIGZvciB0aGUgcGx1Z2luLCB0aGlzIGFsbG93cyBvdGhlcnMgdG8gYmVcbiAgICAgICAgLy8gYWRkZWQgbGF0ZXIuXG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250YWluZXJFbC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLWxhbmd1YWdlLXRhc2tzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gbmV3IFF1ZXJ5KHsgc291cmNlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ3Rhc2tzJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gbmV3IFF1ZXJ5KHsgc291cmNlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ3Rhc2tzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9ubG9hZCgpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY3VycmVudCBjYWNoZSBzdGF0ZTpcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlclJlcXVlc3RDYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTGlzdGVuIHRvIGZ1dHVyZSBjYWNoZSBjaGFuZ2VzOlxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50UmVmID0gdGhpcy5ldmVudHMub25DYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnJlbG9hZFF1ZXJ5QXRNaWRuaWdodCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJFdmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vZmYodGhpcy5yZW5kZXJFdmVudFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5xdWVyeVJlbG9hZFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucXVlcnlSZWxvYWRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIHF1ZXJ5IGFmdGVyIG1pZG5pZ2h0IHRvIHVwZGF0ZSByZXN1bHRzIGZyb20gcmVsYXRpdmUgZGF0ZSBxdWVyaWVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBxdWVyeSBgZHVlIHRvZGF5YCBjaGFuZ2VzIGV2ZXJ5IGRheS4gVGhpcyBtYWtlcyBzdXJlIHRoYXQgYWxsIHF1ZXJ5IHJlc3VsdHNcbiAgICAgKiBhcmUgcmUtcmVuZGVyZWQgYWZ0ZXIgbWlkbmlnaHQgZXZlcnkgZGF5IHRvIGVuc3VyZSB1cC10by1kYXRlIHJlc3VsdHMgd2l0aG91dCBoYXZpbmcgdG9cbiAgICAgKiByZWxvYWQgb2JzaWRpYW4uIENyZWF0aW5nIGEgbmV3IHF1ZXJ5IG9iamVjdCBmcm9tIHRoZSBzb3VyY2UgcmUtYXBwbGllcyB0aGUgcmVsYXRpdmUgZGF0ZXNcbiAgICAgKiB0byBcIm5vd1wiLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVsb2FkUXVlcnlBdE1pZG5pZ2h0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtaWRuaWdodCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIG1pZG5pZ2h0LnNldEhvdXJzKDI0LCAwLCAwLCAwKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcblxuICAgICAgICBjb25zdCBtaWxsaXNlY29uZHNUb01pZG5pZ2h0ID0gbWlkbmlnaHQuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKTtcblxuICAgICAgICB0aGlzLnF1ZXJ5UmVsb2FkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IG5ldyBRdWVyeSh7IHNvdXJjZTogdGhpcy5zb3VyY2UgfSk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBjdXJyZW50IGNhY2hlIHN0YXRlOlxuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlclJlcXVlc3RDYWNoZVVwZGF0ZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkUXVlcnlBdE1pZG5pZ2h0KCk7XG4gICAgICAgIH0sIG1pbGxpc2Vjb25kc1RvTWlkbmlnaHQgKyAxMDAwKTsgLy8gQWRkIGJ1ZmZlciB0byBiZSBzdXJlIHRvIHJ1biBhZnRlciBtaWRuaWdodC5cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlcih7IHRhc2tzLCBzdGF0ZSB9OiB7IHRhc2tzOiBUYXNrW107IHN0YXRlOiBTdGF0ZSB9KSB7XG4gICAgICAgIC8vIERvbid0IGxvZyBhbnl0aGluZyBoZXJlLCBmb3IgYW55IHN0YXRlLCBhcyBpdCBnZW5lcmF0ZXMgaHVnZSBhbW91bnRzIG9mXG4gICAgICAgIC8vIGNvbnNvbGUgbWVzc2FnZXMgaW4gbGFyZ2UgdmF1bHRzLCBpZiBPYnNpZGlhbiB3YXMgb3BlbmVkIHdpdGggYW55XG4gICAgICAgIC8vIG5vdGVzIHdpdGggdGFza3MgY29kZSBibG9ja3MgaW4gUmVhZGluZyBvciBMaXZlIFByZXZpZXcgbW9kZS5cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgnZGl2Jyk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuV2FybSAmJiB0aGlzLnF1ZXJ5LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgYFJlbmRlciAke3RoaXMucXVlcnlUeXBlfSBjYWxsZWQgZm9yIGEgYmxvY2sgaW4gYWN0aXZlIGZpbGUgXCIke3RoaXMuZmlsZVBhdGh9XCIsIHRvIHNlbGVjdCBmcm9tICR7dGFza3MubGVuZ3RofSB0YXNrczogcGx1Z2luIHN0YXRlOiAke3N0YXRlfWAsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLmV4cGxhaW5RdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRXhwbGFuYXRpb24oY29udGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRhc2tzU29ydGVkTGltaXRlZEdyb3VwZWQgPSB0aGlzLnF1ZXJ5LmFwcGx5UXVlcnlUb1Rhc2tzKHRhc2tzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGFza3NTb3J0ZWRMaW1pdGVkR3JvdXBlZC5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3ZXJlIG5vICdncm91cCBieScgaW5zdHJ1Y3Rpb25zLCBncm91cC5ncm91cEhlYWRpbmdzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBlbXB0eSwgYW5kIG5vIGhlYWRpbmdzIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRHcm91cEhlYWRpbmdzKGNvbnRlbnQsIGdyb3VwLmdyb3VwSGVhZGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YXNrTGlzdCB9ID0gYXdhaXQgdGhpcy5jcmVhdGVUYXNrc0xpc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0YXNrczogZ3JvdXAudGFza3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0YXNrTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b3RhbFRhc2tzQ291bnQgPSB0YXNrc1NvcnRlZExpbWl0ZWRHcm91cGVkLnRvdGFsVGFza3NDb3VudCgpO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgJHt0b3RhbFRhc2tzQ291bnR9IG9mICR7dGFza3MubGVuZ3RofSB0YXNrcyBkaXNwbGF5ZWQgaW4gYSBibG9jayBpbiBcIiR7dGhpcy5maWxlUGF0aH1cImApO1xuICAgICAgICAgICAgdGhpcy5hZGRUYXNrQ291bnQoY29udGVudCwgdG90YWxUYXNrc0NvdW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnF1ZXJ5LmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnQuY3JlYXRlRGl2KCkuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAnPHByZT4nICsgYFRhc2tzIHF1ZXJ5OiAke3RoaXMucXVlcnkuZXJyb3IucmVwbGFjZSgvXFxuL2csICc8YnI+Jyl9YCArICc8L3ByZT4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudC5zZXRUZXh0KCdMb2FkaW5nIFRhc2tzIC4uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5maXJzdENoaWxkPy5yZXBsYWNlV2l0aChjb250ZW50KTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlICdleHBsYWluJyBpbnN0cnVjdGlvbiB0byBlbmFibGUgdGhpc1xuICAgIHByaXZhdGUgY3JlYXRlRXhwbGFuYXRpb24oY29udGVudDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25Bc1N0cmluZyA9IHRoaXMucXVlcnkuZXhwbGFpblF1ZXJ5KCk7XG5cbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25zQmxvY2sgPSBjb250ZW50LmNyZWF0ZUVsKCdwcmUnKTtcbiAgICAgICAgZXhwbGFuYXRpb25zQmxvY2suYWRkQ2xhc3NlcyhbJ3BsdWdpbi10YXNrcy1xdWVyeS1leHBsYW5hdGlvbiddKTtcbiAgICAgICAgZXhwbGFuYXRpb25zQmxvY2suc2V0VGV4dChleHBsYW5hdGlvbkFzU3RyaW5nKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChleHBsYW5hdGlvbnNCbG9jayk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUYXNrc0xpc3Qoe1xuICAgICAgICB0YXNrcyxcbiAgICAgICAgY29udGVudCxcbiAgICB9OiB7XG4gICAgICAgIHRhc2tzOiBUYXNrW107XG4gICAgICAgIGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50O1xuICAgIH0pOiBQcm9taXNlPHsgdGFza0xpc3Q6IEhUTUxVTGlzdEVsZW1lbnQ7IHRhc2tzQ291bnQ6IG51bWJlciB9PiB7XG4gICAgICAgIGNvbnN0IHRhc2tzQ291bnQgPSB0YXNrcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgdGFza0xpc3QgPSBjb250ZW50LmNyZWF0ZUVsKCd1bCcpO1xuICAgICAgICB0YXNrTGlzdC5hZGRDbGFzc2VzKFsnY29udGFpbnMtdGFzay1saXN0JywgJ3BsdWdpbi10YXNrcy1xdWVyeS1yZXN1bHQnXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFza3NDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gdGFza3NbaV07XG4gICAgICAgICAgICBjb25zdCBpc0ZpbGVuYW1lVW5pcXVlID0gdGhpcy5pc0ZpbGVuYW1lVW5pcXVlKHsgdGFzayB9KTtcblxuICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSBhd2FpdCB0YXNrLnRvTGkoe1xuICAgICAgICAgICAgICAgIHBhcmVudFVsRWxlbWVudDogdGFza0xpc3QsXG4gICAgICAgICAgICAgICAgbGlzdEluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbnM6IHRoaXMucXVlcnkubGF5b3V0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc0ZpbGVuYW1lVW5pcXVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZm9vdG5vdGVzLiBUaGV5IGRvbid0IHJlLWFwcGVhciBpbiBhbm90aGVyIGRvY3VtZW50LlxuICAgICAgICAgICAgY29uc3QgZm9vdG5vdGVzID0gbGlzdEl0ZW0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZm9vdG5vdGUtaWRdJyk7XG4gICAgICAgICAgICBmb290bm90ZXMuZm9yRWFjaCgoZm9vdG5vdGUpID0+IGZvb3Rub3RlLnJlbW92ZSgpKTtcblxuICAgICAgICAgICAgY29uc3Qgc2hvcnRNb2RlID0gdGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLnNob3J0TW9kZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMuaGlkZVVyZ2VuY3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFVyZ2VuY3kobGlzdEl0ZW0sIHRhc2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucXVlcnkubGF5b3V0T3B0aW9ucy5oaWRlQmFja2xpbmtzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCYWNrbGlua3MobGlzdEl0ZW0sIHRhc2ssIHNob3J0TW9kZSwgaXNGaWxlbmFtZVVuaXF1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLmhpZGVFZGl0QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFZGl0QnV0dG9uKGxpc3RJdGVtLCB0YXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFza0xpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdGFza0xpc3QsIHRhc2tzQ291bnQgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZEVkaXRCdXR0b24obGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrKSB7XG4gICAgICAgIGNvbnN0IGVkaXRUYXNrUGVuY2lsID0gbGlzdEl0ZW0uY3JlYXRlRWwoJ2EnLCB7XG4gICAgICAgICAgICBjbHM6ICd0YXNrcy1lZGl0JyxcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRUYXNrUGVuY2lsLm9uQ2xpY2tFdmVudCgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gKHVwZGF0ZWRUYXNrczogVGFza1tdKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVRhc2tXaXRoVGFza3Moe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRhc2s6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIG5ld1Rhc2tzOiBEYXRlRmFsbGJhY2sucmVtb3ZlSW5mZXJyZWRTdGF0dXNJZk5lZWRlZCh0YXNrLCB1cGRhdGVkVGFza3MpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gTmVlZCB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSwgYXMgY3Vyc29yL3Rhc2sgY2FuIGNoYW5nZS5cbiAgICAgICAgICAgIGNvbnN0IHRhc2tNb2RhbCA9IG5ldyBUYXNrTW9kYWwoe1xuICAgICAgICAgICAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBvblN1Ym1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFza01vZGFsLm9wZW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRVcmdlbmN5KGxpc3RJdGVtOiBIVE1MRWxlbWVudCwgdGFzazogVGFzaykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkuZm9ybWF0KHRhc2sudXJnZW5jeSk7XG4gICAgICAgIGxpc3RJdGVtLmNyZWF0ZVNwYW4oeyB0ZXh0LCBjbHM6ICd0YXNrcy11cmdlbmN5JyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGhlYWRpbmdzIGZvciBhIGdyb3VwIG9mIHRhc2tzLlxuICAgICAqIEBwYXJhbSBjb250ZW50XG4gICAgICogQHBhcmFtIGdyb3VwSGVhZGluZ3MgLSBUaGUgaGVhZGluZ3MgdG8gZGlzcGxheS4gVGhpcyBjYW4gYmUgYW4gZW1wdHkgYXJyYXksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBpbiB3aGljaCBjYXNlIG5vIGhlYWRpbmdzIHdpbGwgYmUgYWRkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGFkZEdyb3VwSGVhZGluZ3MoY29udGVudDogSFRNTERpdkVsZW1lbnQsIGdyb3VwSGVhZGluZ3M6IEdyb3VwSGVhZGluZ1tdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiBncm91cEhlYWRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEdyb3VwSGVhZGluZyhjb250ZW50LCBoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgYWRkR3JvdXBIZWFkaW5nKGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LCBncm91cDogR3JvdXBIZWFkaW5nKSB7XG4gICAgICAgIGxldCBoZWFkZXI6IGFueTtcbiAgICAgICAgLy8gSXMgaXQgcG9zc2libGUgdG8gcmVtb3ZlIHRoZSByZXBldGl0aW9uIGhlcmU/XG4gICAgICAgIC8vIElkZWFsbHksIGJ5IGNyZWF0aW5nIGEgdmFyaWFibGUgdGhhdCBjb250YWlucyBoNCwgaDUgb3IgaDZcbiAgICAgICAgLy8gYW5kIHRoZW4gb25seSBoYXZpbmcgb25lIGNhbGwgdG8gY29udGVudC5jcmVhdGVFbCgpLlxuICAgICAgICBpZiAoZ3JvdXAubmVzdGluZ0xldmVsID09PSAwKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSBjb250ZW50LmNyZWF0ZUVsKCdoNCcsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICd0YXNrcy1ncm91cC1oZWFkaW5nJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm5lc3RpbmdMZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgaGVhZGVyID0gY29udGVudC5jcmVhdGVFbCgnaDUnLCB7XG4gICAgICAgICAgICAgICAgY2xzOiAndGFza3MtZ3JvdXAtaGVhZGluZycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhlYWRpbmdzIG5lc3RlZCB0byAyIG9yIG1vcmUgbGV2ZWxzIGFyZSBhbGwgZGlzcGxheWVkIHdpdGggJ2g2OlxuICAgICAgICAgICAgaGVhZGVyID0gY29udGVudC5jcmVhdGVFbCgnaDYnLCB7XG4gICAgICAgICAgICAgICAgY2xzOiAndGFza3MtZ3JvdXAtaGVhZGluZycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBNYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKGdyb3VwLm5hbWUsIGhlYWRlciwgdGhpcy5maWxlUGF0aCwgdGhpcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRCYWNrbGlua3MobGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrLCBzaG9ydE1vZGU6IGJvb2xlYW4sIGlzRmlsZW5hbWVVbmlxdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYmFja0xpbmsgPSBsaXN0SXRlbS5jcmVhdGVTcGFuKHsgY2xzOiAndGFza3MtYmFja2xpbmsnIH0pO1xuXG4gICAgICAgIGlmICghc2hvcnRNb2RlKSB7XG4gICAgICAgICAgICBiYWNrTGluay5hcHBlbmQoJyAoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5rID0gYmFja0xpbmsuY3JlYXRlRWwoJ2EnKTtcblxuICAgICAgICBsaW5rLmhyZWYgPSB0YXNrLnBhdGg7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLWhyZWYnLCB0YXNrLnBhdGgpO1xuICAgICAgICBsaW5rLnJlbCA9ICdub29wZW5lcic7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIGxpbmsuYWRkQ2xhc3MoJ2ludGVybmFsLWxpbmsnKTtcbiAgICAgICAgaWYgKHNob3J0TW9kZSkge1xuICAgICAgICAgICAgbGluay5hZGRDbGFzcygnaW50ZXJuYWwtbGluay1zaG9ydC1tb2RlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzay5wcmVjZWRpbmdIZWFkZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXNlZEhlYWRpbmcgPSB0YXNrLnByZWNlZGluZ0hlYWRlci5yZXBsYWNlKC8jL2csICcnKTtcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IGxpbmsuaHJlZiArICcjJyArIHNhbml0aXNlZEhlYWRpbmc7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJywgbGluay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicpICsgJyMnICsgc2FuaXRpc2VkSGVhZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGlua1RleHQ6IHN0cmluZztcbiAgICAgICAgaWYgKHNob3J0TW9kZSkge1xuICAgICAgICAgICAgbGlua1RleHQgPSAnIFx1RDgzRFx1REQxNyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IHRhc2suZ2V0TGlua1RleHQoeyBpc0ZpbGVuYW1lVW5pcXVlIH0pID8/ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluay5zZXRUZXh0KGxpbmtUZXh0KTtcblxuICAgICAgICBpZiAoIXNob3J0TW9kZSkge1xuICAgICAgICAgICAgYmFja0xpbmsuYXBwZW5kKCcpJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRhc2tDb3VudChjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgdGFza3NDb3VudDogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLmhpZGVUYXNrQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnRlbnQuY3JlYXRlRGl2KHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgJHt0YXNrc0NvdW50fSB0YXNrJHt0YXNrc0NvdW50ICE9PSAxID8gJ3MnIDogJyd9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICd0YXNrcy1jb3VudCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNGaWxlbmFtZVVuaXF1ZSh7IHRhc2sgfTogeyB0YXNrOiBUYXNrIH0pOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgLy8gV2lsbCBtYXRjaCB0aGUgZmlsZW5hbWUgd2l0aG91dCBleHRlbnNpb24gKHRoZSBmaWxlJ3MgXCJiYXNlbmFtZVwiKS5cbiAgICAgICAgY29uc3QgZmlsZW5hbWVNYXRjaCA9IHRhc2sucGF0aC5tYXRjaCgvKFteL10qKVxcLi4rJC9pKTtcbiAgICAgICAgaWYgKGZpbGVuYW1lTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGVuYW1lTWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IGFsbEZpbGVzV2l0aFNhbWVOYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcigoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlLmJhc2VuYW1lID09PSBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWUgKGl0IG1pZ2h0IGFjdHVhbGx5IGJlIHRoZSBzYW1lIGZpbGUsIGJ1dCB3ZSdsbCB0YWtlIHRoYXQgaW50byBhY2NvdW50IGxhdGVyLilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFsbEZpbGVzV2l0aFNhbWVOYW1lLmxlbmd0aCA8IDI7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnMgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGltcGxlbWVudHMgb2Yge0BsaW5rIEZpZWxkfVxuICpcbiAqIFRoZSBuYW1lZCBvZiB0aGUgY2xhc3MgaXMgd2Vhay4gSXQgaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBmYWN0IHRoYXQgdGhlXG4gKiBjbGFzcyBpcyBlbnRpcmVseSBpbXBsZW1lbnRlZCB2aWEgdGhlIHtAbGluayBGaWx0ZXJJbnN0cnVjdGlvbnN9IGNsYXNzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2ZpbHRlcnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycy5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4uLy4uL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGNoYW5nZTogSW4gVGFza3MgMS4yMi4wIGFuZCBlYXJsaWVyLCBhbGwgdGFza3NcbiAgICAgICAgLy8gd2l0aCBhbnkgc3RhdHVzIGNoYXJhY3RlciBleGNlcHQgc3BhY2Ugd2VyZSBjb25zaWRlcmVkIGJ5IHRoZSBzdGF0dXMgZmlsdGVyXG4gICAgICAgIC8vIGluc3RydWN0aW9ucyB0byBiZSBkb25lLlxuICAgICAgICAvLyBJbiBsYXRlciB2ZXJzaW9uczpcbiAgICAgICAgLy8gICBTdGF0dXNUeXBlLkRPTkUgY291bnRzIGFzIGRvbmVcbiAgICAgICAgLy8gICBTdGF0dXNUeXBlLkNBTkNFTExFRCBjb3VudHMgYXMgZG9uZVxuICAgICAgICAvLyAgIFN0YXR1c1R5cGUuVE9ETyBjb3VudHMgYXMgbm90IGRvbmVcbiAgICAgICAgLy8gICBTdGF0dXNUeXBlLklOX1BST0dSRVNTIGNvdW50cyBhcyBub3QgZG9uZVxuICAgICAgICAvLyAgIFN0YXR1c1R5cGUuTk9OX1RBU0sgY291bnRzIGFzIGRvbmVcbiAgICAgICAgdGhpcy5fZmlsdGVycy5hZGQoXG4gICAgICAgICAgICAnZG9uZScsXG4gICAgICAgICAgICAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICB0YXNrLnN0YXR1cy50eXBlID09PSBTdGF0dXNUeXBlLkRPTkUgfHxcbiAgICAgICAgICAgICAgICB0YXNrLnN0YXR1cy50eXBlID09PSBTdGF0dXNUeXBlLkNBTkNFTExFRCB8fFxuICAgICAgICAgICAgICAgIHRhc2suc3RhdHVzLnR5cGUgPT09IFN0YXR1c1R5cGUuTk9OX1RBU0ssXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKFxuICAgICAgICAgICAgJ25vdCBkb25lJyxcbiAgICAgICAgICAgICh0YXNrOiBUYXNrKSA9PiB0YXNrLnN0YXR1cy50eXBlID09PSBTdGF0dXNUeXBlLlRPRE8gfHwgdGFzay5zdGF0dXMudHlwZSA9PT0gU3RhdHVzVHlwZS5JTl9QUk9HUkVTUyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnc3RhdHVzJztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0byBjb21wYXJlIHR3byBUYXNrIG9iamVjdHMsIGZvciB1c2UgaW4gc29ydGluZyBieSBzdGF0dXMuXG4gICAgICovXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG5vdGU6IEluIFRhc2tzIDEuMjIuMCBhbmQgZWFybGllciwgdGhlXG4gICAgICAgIC8vIG9ubHkgYXZhaWxhYmxlIHN0YXR1cyBuYW1lcyB3ZXJlICdUb2RvJyBhbmQgJ0RvbmUnLlxuICAgICAgICAvLyBBbmQgJ1RvZG8nIHNvcnRlZCBiZWZvcmUgJ0RvbmUnLlxuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0YXR1c05hbWVBID0gU3RhdHVzRmllbGQub2xkU3RhdHVzTmFtZShhKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0YXR1c05hbWVCID0gU3RhdHVzRmllbGQub2xkU3RhdHVzTmFtZShiKTtcbiAgICAgICAgICAgIGlmIChvbGRTdGF0dXNOYW1lQSA8IG9sZFN0YXR1c05hbWVCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFN0YXR1c05hbWVBID4gb2xkU3RhdHVzTmFtZUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG9sZFN0YXR1c05hbWUoYTogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGlmIChhLnN0YXR1cy5zeW1ib2wgPT09ICcgJykge1xuICAgICAgICAgICAgcmV0dXJuICdUb2RvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnRG9uZSc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2R1ZScgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRHVlRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBkdWVSZWdleHAgPSAvXmR1ZSAoYmVmb3JlfGFmdGVyfG9uKT8gPyguKikvO1xuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gRHVlRGF0ZUZpZWxkLmR1ZVJlZ2V4cDtcbiAgICB9XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2R1ZSc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suZHVlRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFByaW9yaXR5LCBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXIsIEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG5leHBvcnQgY2xhc3MgUHJpb3JpdHlGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICAvLyBUaGUgdHJpY2sgaW4gdGhlIGZvbGxvd2luZyB0byBtYW5hZ2Ugd2hpdGVzcGFjZSB3aXRoIG9wdGlvbmFsIHZhbHVlc1xuICAgIC8vIGlzIHRvIGNhcHR1cmUgdGhlbSBpbiBOZXN0ZWQgQ2FwdHVyZSBHcm91cHMsIGxpa2UgdGhpczpcbiAgICAvLyAgKGxlYWRpbmctd2hpdGUtc3BhY2UtaW4tb3V0ZXItY2FwdHVyZS1ncm91cCh2YWx1ZXMtdG8tdXNlLWFyZS1pbi1pbm5lci1jYXB0dXJlLWdyb3VwKSlcbiAgICAvLyBUaGUgY2FwdHVyZSBncm91cHMgYXJlIG51bWJlcmVkIGluIHRoZSBvcmRlciBvZiB0aGVpciBvcGVuaW5nIGJyYWNrZXRzLCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcHJpb3JpdHlSZWdleHAgPSAvXnByaW9yaXR5KFxccytpcyk/KFxccysoYWJvdmV8YmVsb3d8bm90KSk/KFxccysobG93fG5vbmV8bWVkaXVtfGhpZ2gpKSQvO1xuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5TWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmZpbHRlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKHByaW9yaXR5TWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclByaW9yaXR5U3RyaW5nID0gcHJpb3JpdHlNYXRjaFs1XTtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJQcmlvcml0eTogUHJpb3JpdHkgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgc3dpdGNoIChmaWx0ZXJQcmlvcml0eVN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuTG93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5Ob25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQcmlvcml0eSA9IFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlnaCc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuSGlnaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXJQcmlvcml0eSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdkbyBub3QgdW5kZXJzdGFuZCBwcmlvcml0eSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGV4cGxhbmF0aW9uID0gbGluZTtcbiAgICAgICAgICAgIGxldCBmaWx0ZXI7XG4gICAgICAgICAgICBzd2l0Y2ggKHByaW9yaXR5TWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB0YXNrLnByaW9yaXR5LmxvY2FsZUNvbXBhcmUoZmlsdGVyUHJpb3JpdHkhKSA8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JlbG93JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRhc2sucHJpb3JpdHkubG9jYWxlQ29tcGFyZShmaWx0ZXJQcmlvcml0eSEpID4gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm90JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRhc2sucHJpb3JpdHkgIT09IGZpbHRlclByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAodGFzazogVGFzaykgPT4gdGFzay5wcmlvcml0eSA9PT0gZmlsdGVyUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gYCR7dGhpcy5maWVsZE5hbWUoKX0gaXMgJHtmaWx0ZXJQcmlvcml0eVN0cmluZ31gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gbmV3IEZpbHRlcihsaW5lLCBmaWx0ZXIsIG5ldyBFeHBsYW5hdGlvbihleHBsYW5hdGlvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAocHJpb3JpdHkpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdwcmlvcml0eSc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlGaWVsZC5wcmlvcml0eVJlZ2V4cDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eS5sb2NhbGVDb21wYXJlKGIucHJpb3JpdHkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEFuIGludGVyZmFjZSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGEgcGFydGljdWxhciBjb25kaXRpb24uXG4gKlxuICogVGhpcyBpcyB1c2VkIHRvIGhpZGUgYXdheSB0aGUgZGV0YWlscyBvZiB2YXJpb3VzIHRleHQgc2VhcmNoZXMsIHN1Y2ggYXMgdGhlXG4gKiBzaW1wbGUgaW5jbHVzaW9uIG9mIGEgc3ViLXN0cmluZywgb3IgdGhlIG1vcmUgY29tcGxleCByZWd1bGFyIGV4cHJlc3Npb24gc2VhcmNoZXMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJU3RyaW5nTWF0Y2hlciB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBtYXRjaGVzIHRoaXMgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSBzdHJpbmdUb1NlYXJjaFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBtYXRjaGVzKHN0cmluZ1RvU2VhcmNoOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgYW55IG9mIHRoZSBnaXZlbiBzdHJpbmdzIG1hdGNoZXMgdGhpcyBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZ3NUb1NlYXJjaFxuICAgICAqL1xuICAgIHB1YmxpYyBtYXRjaGVzQW55T2Yoc3RyaW5nc1RvU2VhcmNoOiBzdHJpbmdbXSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nc1RvU2VhcmNoLnNvbWUoKHMpID0+IHRoaXMubWF0Y2hlcyhzKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IElTdHJpbmdNYXRjaGVyIH0gZnJvbSAnLi9JU3RyaW5nTWF0Y2hlcic7XG5cbi8qKlxuICogU3Vic3RyaW5nLWJhc2VkIGltcGxlbWVudGF0aW9uIG9mIElTdHJpbmdNYXRjaGVyLlxuICpcbiAqIFRoaXMgZG9lcyBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICovXG5leHBvcnQgY2xhc3MgU3Vic3RyaW5nTWF0Y2hlciBleHRlbmRzIElTdHJpbmdNYXRjaGVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0cmluZ1RvRmluZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgU3Vic3RyaW5nTWF0Y2hlciBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdUb0ZpbmQgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlYXJjaGVzIHdpbGwgYmUgY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3Ioc3RyaW5nVG9GaW5kOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdUb0ZpbmQgPSBzdHJpbmdUb0ZpbmQ7XG4gICAgfVxuXG4gICAgcHVibGljIG1hdGNoZXMoc3RyaW5nVG9TZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gU3Vic3RyaW5nTWF0Y2hlci5zdHJpbmdJbmNsdWRlc0Nhc2VJbnNlbnNpdGl2ZShzdHJpbmdUb1NlYXJjaCwgdGhpcy5zdHJpbmdUb0ZpbmQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5nSW5jbHVkZXNDYXNlSW5zZW5zaXRpdmUoaGF5c3RhY2s6IHN0cmluZywgbmVlZGxlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5jbHVkZXMobmVlZGxlLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4vSVN0cmluZ01hdGNoZXInO1xuXG4vKipcbiAqIFJlZ3VsYXItZXhwcmVzc2lvbi1iYXNlZCBpbXBsZW1lbnRhdGlvbiBvZiBJU3RyaW5nTWF0Y2hlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2V4TWF0Y2hlciBleHRlbmRzIElTdHJpbmdNYXRjaGVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlZ2V4OiBSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBSZWdleE1hdGNoZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2V4IHtSZWdFeHB9IC0gQSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocmVnZXg6IFJlZ0V4cCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZ2V4ID0gcmVnZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgUmVnZXhNYXRjaGVyIG9iamVjdCBpZiB0aGUgc3VwcGxpZWQgc3RyaW5nIGlzIGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqIGFuZCBudWxsIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWdleElucHV0IC0gQSBzdHJpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgbXVzdCBiZWdpbiB3aXRoIGEgLywgYW5kIGVuZCBlaXRoZXIgd2l0aCAvIGFuZCBvcHRpb25hbGx5IGFueVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZmxhZ3MuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB2YWxpZGF0ZUFuZENvbnN0cnVjdChyZWdleElucHV0OiBzdHJpbmcpOiBSZWdleE1hdGNoZXIgfCBudWxsIHtcbiAgICAgICAgLy8gQ291cnRlc3kgb2YgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDM2OTEvamF2YXNjcmlwdC1yZWdleC10by1tYXRjaC1hLXJlZ2V4XG4gICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9XG4gICAgICAgICAgICAvXFwvKCg/IVsqKz9dKSg/OlteXFxyXFxuWy9cXFxcXXxcXFxcLnxcXFsoPzpbXlxcclxcblxcXVxcXFxdfFxcXFwuKSpdKSspXFwvKCg/OmcoPzppbT98bWk/KT98aSg/OmdtP3xtZz8pP3xtKD86Z2k/fGlnPyk/KT8pLztcbiAgICAgICAgY29uc3QgcXVlcnkgPSByZWdleElucHV0Lm1hdGNoKHJlZ2V4UGF0dGVybik7XG5cbiAgICAgICAgaWYgKHF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKHF1ZXJ5WzFdLCBxdWVyeVsyXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ2V4TWF0Y2hlcihyZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbWF0Y2hlcyhzdHJpbmdUb1NlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb1NlYXJjaC5tYXRjaCh0aGlzLnJlZ2V4KSAhPT0gbnVsbDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBTdWJzdHJpbmdNYXRjaGVyIH0gZnJvbSAnLi4vTWF0Y2hlcnMvU3Vic3RyaW5nTWF0Y2hlcic7XG5pbXBvcnQgeyBSZWdleE1hdGNoZXIgfSBmcm9tICcuLi9NYXRjaGVycy9SZWdleE1hdGNoZXInO1xuaW1wb3J0IHR5cGUgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4uL01hdGNoZXJzL0lTdHJpbmdNYXRjaGVyJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcblxuLyoqXG4gKiBUZXh0RmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0byBoZWxwIGltcGxlbWVudFxuICogYWxsIHRoZSBmaWx0ZXIgaW5zdHJ1Y3Rpb25zIHRoYXQgYWN0IG9uIGEgc2luZ2xlIHR5cGUgb2Ygc3RyaW5nXG4gKiB2YWx1ZSwgc3VjaCBhcyB0aGUgZGVzY3JpcHRpb24gb3IgZmlsZSBwYXRoLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5maWx0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgRmllbGQuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZSgpIGhhcyBiZWVuIGNoZWNrZWQsIHdlIHNob3VsZCBuZXZlciBnZXRcbiAgICAgICAgICAgIC8vIGluIHRvIHRoaXMgYmxvY2suXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gSVN0cmluZ01hdGNoZXIgZm9yIHRoaXMgZmlsdGVyLCBvciByZXR1cm5cbiAgICAgICAgLy8gaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cbiAgICAgICAgY29uc3QgW18sIGZpbHRlck9wZXJhdG9yLCBmaWx0ZXJWYWx1ZV0gPSBtYXRjaDtcbiAgICAgICAgbGV0IG1hdGNoZXI6IElTdHJpbmdNYXRjaGVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChmaWx0ZXJPcGVyYXRvci5pbmNsdWRlcygnaW5jbHVkZScpKSB7XG4gICAgICAgICAgICBtYXRjaGVyID0gbmV3IFN1YnN0cmluZ01hdGNoZXIoZmlsdGVyVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlck9wZXJhdG9yLmluY2x1ZGVzKCdyZWdleCcpKSB7XG4gICAgICAgICAgICBtYXRjaGVyID0gUmVnZXhNYXRjaGVyLnZhbGlkYXRlQW5kQ29uc3RydWN0KGZpbHRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgYGNhbm5vdCBwYXJzZSByZWdleCAoJHt0aGlzLmZpZWxkTmFtZSgpfSk7IGNoZWNrIHlvdXIgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyBmb3IgeW91ciBxdWVyeWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGxpa2VseSB0aGlzIGNhbiBub3cgbmV2ZXIgYmUgcmVhY2hlZC5cbiAgICAgICAgICAgIC8vIFJldGFpbmVkIGZvciBzYWZldHksIGZvciBub3cuXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5LCB3ZSBjYW4gY3JlYXRlIHRoZSBGaWx0ZXIsIHRoYXQgdGFrZXMgYSB0YXNrXG4gICAgICAgIC8vIGFuZCB0ZXN0cyBpZiBpdCBtYXRjaGVzIHRoZSBzdHJpbmcgZmlsdGVyaW5nIHJ1bGVcbiAgICAgICAgLy8gcmVwcmVzZW50ZWQgYnkgdGhpcyBvYmplY3QuXG4gICAgICAgIGNvbnN0IG5lZ2F0ZSA9IGZpbHRlck9wZXJhdG9yLm1hdGNoKC9ub3QvKSAhPT0gbnVsbDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbmV3IEZpbHRlcihsaW5lLCB0aGlzLmdldEZpbHRlcihtYXRjaGVyLCBuZWdhdGUpLCBuZXcgRXhwbGFuYXRpb24obGluZSkpO1xuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWdleHAgcGF0dGVybiBtYXRjaGluZyB0aGUgZmllbGQncyBuYW1lIGFuZCBwb3NzaWJsZSBhbGlhc2VzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpZWxkUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVnZXhwIHBhdHRlcm4gbWF0Y2hpbmcgYWxsIHBvc3NpYmxlIGZpbHRlciBvcGVyYXRvcnMgZm9yIHRoaXMgZmllbGQsXG4gICAgICogc3VjaCBhcyBcImluY2x1ZGVzXCIgb3IgXCJkb2VzIG5vdCBpbmNsdWRlXCIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpbHRlck9wZXJhdG9yUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2luY2x1ZGVzfGRvZXMgbm90IGluY2x1ZGV8cmVnZXggbWF0Y2hlc3xyZWdleCBkb2VzIG5vdCBtYXRjaCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OiR7dGhpcy5maWVsZFBhdHRlcm4oKX0pICgke3RoaXMuZmlsdGVyT3BlcmF0b3JQYXR0ZXJuKCl9KSAoLiopYCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IGZpZWxkTmFtZSgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWVsZCdzIHZhbHVlLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHZhbHVlIGlzIG51bGxcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgdmFsdWUodGFzazogVGFzayk6IHN0cmluZztcblxuICAgIHByb3RlY3RlZCBnZXRGaWx0ZXIobWF0Y2hlcjogSVN0cmluZ01hdGNoZXIsIG5lZ2F0ZTogYm9vbGVhbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXIhLm1hdGNoZXModGhpcy52YWx1ZSh0YXNrKSk7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRlID8gIW1hdGNoIDogbWF0Y2g7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHNvcnRpbmcsIGZvciB0ZXh0IGZpZWxkcyB3aGVyZSBzaW1wbGUgbG9jYWxlLWF3YXJlIHNvcnRpbmcgaXMgdGhlXG4gICAgICogZGVzaXJlZCBiZWhhdmlvdXIuXG4gICAgICpcbiAgICAgKiBFYWNoIGNsYXNzIHRoYXQgd2FudHMgdG8gdXNlIHRoaXMgd2lsbCBuZWVkIHRvIG92ZXJyaWRlIHN1cHBvcnRzU29ydGluZygpIHRvIHJldHVybiB0cnVlLFxuICAgICAqIHRvIHR1cm4gb24gc29ydGluZy5cbiAgICAgKi9cbiAgICBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlKGEpLmxvY2FsZUNvbXBhcmUodGhpcy52YWx1ZShiKSwgdW5kZWZpbmVkLCB7IG51bWVyaWM6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGdyb3VwaW5nLCBmb3IgdGV4dCBmaWVsZHMgd2hlcmUgc2ltcGxlIGdyb3VwaW5nIGJ5IGZpZWxkIHZhbHVlIGlzIHRoZVxuICAgICAqIGRlc2lyZWQgYmVoYXZpb3VyLlxuICAgICAqXG4gICAgICogRWFjaCBjbGFzcyB0aGF0IHdhbnRzIHRvIHVzZSB0aGlzIHdpbGwgbmVlZCB0byBvdmVycmlkZSBzdXBwb3J0c0dyb3VwaW5nKCkgdG8gcmV0dXJuIHRydWUsXG4gICAgICogdG8gdHVybiBvbiBncm91cGluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSh0YXNrKV07XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKiogU3VwcG9ydCB0aGUgJ3BhdGgnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gYWxzbyBzZWFyY2hlcyB0aGUgZmlsZSBleHRlbnNpb24sXG4gKiBzbyAncGF0aCBpbmNsdWRlcyAubWQnIHdpbGwgdHlwaWNhbGx5IG1hdGNoIGFsbCB0YXNrcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdwYXRoJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIHBhdGggaW5jbHVkaW5nIGZpbGUgZXh0ZW5zaW9uLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHBhdGggaXMgbnVsbFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRhc2sucGF0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIFN1cHBvcnQgJ3VyZ2VuY3knIHNvcnRpbmcuXG4gKlxuICogTm90ZTogU2VhcmNoaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBpbXBsZW1lbnRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVyZ2VuY3lGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKF9saW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnRmlsdGVyaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICd1cmdlbmN5JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICB0aHJvdyBFcnJvcihgZmlsdGVyUmVnRXhwKCkgdW5pbXBsZW1lbnRlZCBmb3IgJHt0aGlzLmZpZWxkTmFtZSgpfWApO1xuICAgIH1cblxuICAgIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgLy8gSGlnaGVyIHVyZ2VuY3kgc2hvdWxkIGJlIHNvcnRlZCBlYXJsaWVyLlxuICAgICAgICAgICAgcmV0dXJuIGIudXJnZW5jeSAtIGEudXJnZW5jeTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuL1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IFNvcnRlciB9IGZyb20gJy4vU29ydGVyJztcbmltcG9ydCB7IFN0YXR1c0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzRmllbGQnO1xuaW1wb3J0IHsgRHVlRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRHVlRGF0ZUZpZWxkJztcbmltcG9ydCB7IFByaW9yaXR5RmllbGQgfSBmcm9tICcuL0ZpbHRlci9Qcmlvcml0eUZpZWxkJztcbmltcG9ydCB7IFBhdGhGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1BhdGhGaWVsZCc7XG5pbXBvcnQgeyBVcmdlbmN5RmllbGQgfSBmcm9tICcuL0ZpbHRlci9VcmdlbmN5RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgU29ydCB7XG4gICAgcHVibGljIHN0YXRpYyBieShzb3J0ZXJzOiBTb3J0ZXJbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29tcGFyYXRvcnM6IENvbXBhcmF0b3JbXSA9IFtcbiAgICAgICAgICAgIG5ldyBVcmdlbmN5RmllbGQoKS5jb21wYXJhdG9yKCksXG4gICAgICAgICAgICBuZXcgU3RhdHVzRmllbGQoKS5jb21wYXJhdG9yKCksXG4gICAgICAgICAgICBuZXcgRHVlRGF0ZUZpZWxkKCkuY29tcGFyYXRvcigpLFxuICAgICAgICAgICAgbmV3IFByaW9yaXR5RmllbGQoKS5jb21wYXJhdG9yKCksXG4gICAgICAgICAgICBuZXcgUGF0aEZpZWxkKCkuY29tcGFyYXRvcigpLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHVzZXJDb21wYXJhdG9yczogQ29tcGFyYXRvcltdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBzb3J0ZXIgb2Ygc29ydGVycykge1xuICAgICAgICAgICAgdXNlckNvbXBhcmF0b3JzLnB1c2goc29ydGVyLmNvbXBhcmF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhc2tzLnNvcnQoU29ydC5tYWtlQ29tcG9zaXRlQ29tcGFyYXRvcihbLi4udXNlckNvbXBhcmF0b3JzLCAuLi5kZWZhdWx0Q29tcGFyYXRvcnNdKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFrZUNvbXBvc2l0ZUNvbXBhcmF0b3IoY29tcGFyYXRvcnM6IENvbXBhcmF0b3JbXSk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYSwgYik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2Rlc2NyaXB0aW9uJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKlxuICogTm90ZSB0aGF0IERlc2NyaXB0aW9uRmllbGQudmFsdWUoKSByZXR1cm5zIHRoZSBkZXNjcmlwdGlvblxuICogd2l0aCB0aGUgZ2xvYmFsIGZpbHRlciAoaWYgYW55KSByZW1vdmVkLlxuICovXG5leHBvcnQgY2xhc3MgRGVzY3JpcHRpb25GaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2Rlc2NyaXB0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRhc2sncyBkZXNjcmlwdGlvbiwgd2l0aCBhbnkgZ2xvYmFsIHRhZyByZW1vdmVkXG4gICAgICpcbiAgICAgKiBQcm9tb3RlZCB0byBwdWJsaWMsIHRvIGVuYWJsZSB0ZXN0aW5nLlxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgLy8gUmVtb3ZlIGdsb2JhbCBmaWx0ZXIgZnJvbSBkZXNjcmlwdGlvbiBtYXRjaCBpZiBwcmVzZW50LlxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYXRjaCBvbmx5IG9uIHRoZSBjb250ZW50IG9mIHRoZSB0YXNrLCBub3RcbiAgICAgICAgLy8gdGhlIGdsb2JhbCBmaWx0ZXIuXG4gICAgICAgIGNvbnN0IGdsb2JhbEZpbHRlciA9IGdldFNldHRpbmdzKCkuZ2xvYmFsRmlsdGVyO1xuICAgICAgICByZXR1cm4gdGFzay5kZXNjcmlwdGlvbi5yZXBsYWNlKGdsb2JhbEZpbHRlciwgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBkZXNjcmlwdGlvbiBieSBob3cgaXQgaXMgcmVuZGVyZWQgaW4gbWFya2Rvd24uXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCB1c2UgdGhlIE1hcmtkb3duUmVuZGVyZXIsIGJ1dCB0cmllcyB0byBtYXRjaCByZWdleGVzIGluc3RlYWRcbiAgICAgKiBpbiBvcmRlciB0byBiZSBzaW1wbGVyLCBmYXN0ZXIsIGFuZCBub3QgYXN5bmMuXG4gICAgICpcbiAgICAgKiBPbmx5IHNlYXJjaGVzIGF0IHRoZSBzdGFydCBvZiB0aGUgZGVzY3JpcHRpb24uIE1hcmtkb3duIGxhdGVyIGluIHRoZSB0YWsgaXMgdW5jaGFuZ2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uQSA9IERlc2NyaXB0aW9uRmllbGQuY2xlYW5EZXNjcmlwdGlvbihhLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uQiA9IERlc2NyaXB0aW9uRmllbGQuY2xlYW5EZXNjcmlwdGlvbihiLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbkEubG9jYWxlQ29tcGFyZShkZXNjcmlwdGlvbkIsIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYCpgLCBgPWAsIGFuZCBgW2AgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdpbGwgcmVtb3ZlIHRoZW0gb25seSBpZiB0aGV5IGFyZSBjbG9zaW5nLlxuICAgICAqIFByb3Blcmx5IHJlYWRzIGxpbmtzIFtbbGlrZSB0aGlzfG9uZV1dIChub3RlIHBpcGUpLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2xlYW5EZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsRmlsdGVyID0gZ2V0U2V0dGluZ3MoKS5nbG9iYWxGaWx0ZXI7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24ucmVwbGFjZShnbG9iYWxGaWx0ZXIsICcnKS50cmltKCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRzV2l0aExpbmtSZWdleCA9IC9eXFxbXFxbPyhbXlxcXV0qKV1dPy87XG4gICAgICAgIGNvbnN0IGxpbmtSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2goc3RhcnRzV2l0aExpbmtSZWdleCk7XG4gICAgICAgIGlmIChsaW5rUmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXJMaW5rVGV4dCA9IGxpbmtSZWdleE1hdGNoWzFdO1xuICAgICAgICAgICAgLy8gRm9yIGEgbGluaywgd2UgaGF2ZSB0byBjaGVjayB3aGV0aGVyIGl0IGhhcyBhbm90aGVyIHZpc2libGUgbmFtZSBzZXQuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSBgW1t0aGlzIGlzIHRoZSBsaW5rfGJ1dCB0aGlzIGlzIGFjdHVhbGx5IHNob3duXV1gLlxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIGlubmVyTGlua1RleHQuc3Vic3RyaW5nKGlubmVyTGlua1RleHQuaW5kZXhPZignfCcpICsgMSkgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHN0YXJ0c1dpdGhMaW5rUmVnZXgsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCpcXCooW14qXSspXFwqXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCooW14qXSspXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL149PShbXj1dKyk9PS8pO1xuICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMucmVwbGFjZUZvcm1hdHRpbmcoZGVzY3JpcHRpb24sIC9eX18oW15fXSspX18vKTtcbiAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLnJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uLCAvXl8oW15fXSspXy8pO1xuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc29tZSBmb3JtYXR0aW5nIGZyb20gdGV4dFxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSByZWdFeHAgQSByZWd1bGFyIGV4cHJlc3Npb24gLSBhbGwgbWF0Y2hpbmcgdGV4dCBpcyBkaXNjYXJkZWQgZXhjZXB0IHRoZSBmaXJzdCBncm91cFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHJlZ0V4cDogUmVnRXhwKSB7XG4gICAgICAgIGNvbnN0IGl0YWxpY0JvbGRSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgaWYgKGl0YWxpY0JvbGRSZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckl0YWxpY0JvbGRUZXh0ID0gaXRhbGljQm9sZFJlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGlubmVySXRhbGljQm9sZFRleHQgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHJlZ0V4cCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2RvbmUnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIERvbmVEYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRvbmVSZWdleHAgPSAvXmRvbmUgKGJlZm9yZXxhZnRlcnxvbik/ID8oLiopLztcblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIERvbmVEYXRlRmllbGQuZG9uZVJlZ2V4cDtcbiAgICB9XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2RvbmUnO1xuICAgIH1cbiAgICBwdWJsaWMgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0YXNrLmRvbmVEYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCc7XG5cbi8qKlxuICogSW1wbGVtZW50cyAnZXhjbHVkZSBzdWItaXRlbXMnIGZpbHRlclxuICovXG5leHBvcnQgY2xhc3MgRXhjbHVkZVN1Ykl0ZW1zRmllbGQgZXh0ZW5kcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnZXhjbHVkZSBzdWItaXRlbXMnLCAodGFzaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhc2suaW5kZW50YXRpb24gPT09ICcnKSByZXR1cm4gdHJ1ZTsgLy8gbm8gaW5kZW50YXRpb24sIG5vdCBhIHN1Yml0ZW1cblxuICAgICAgICAgICAgY29uc3QgbGFzdEJsb2NrcXVvdGVNYXJrID0gdGFzay5pbmRlbnRhdGlvbi5sYXN0SW5kZXhPZignPicpO1xuICAgICAgICAgICAgaWYgKGxhc3RCbG9ja3F1b3RlTWFyayA9PT0gLTEpIHJldHVybiBmYWxzZTsgLy8gaW5kZW50YXRpb24gcHJlc2VudCwgbm90IGluIGEgYmxvY2txdW90ZSwgc3ViaXRlbVxuXG4gICAgICAgICAgICAvLyBVcCB0byBvbmUgc3BhY2UgYWxsb3dlZCBhZnRlciBsYXN0ID4gaW4gYmxvY2txdW90ZS9jYWxsb3V0LCBvdGhlcndpc2Ugc3ViaXRlbVxuICAgICAgICAgICAgcmV0dXJuIC9eID8kLy50ZXN0KHRhc2suaW5kZW50YXRpb24uc2xpY2UobGFzdEJsb2NrcXVvdGVNYXJrICsgMSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZXhjbHVkZSc7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKiogU3VwcG9ydCB0aGUgJ2hlYWRpbmcnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWFkaW5nRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdoZWFkaW5nJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmVjZWRpbmcgaGVhZGluZywgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBoZWFkaW5nIGlzIG51bGxcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0YXNrLnByZWNlZGluZ0hlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJlY2VkaW5nSGVhZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ3NjaGVkdWxlZCcgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU2NoZWR1bGVkRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBzY2hlZHVsZWRSZWdleHAgPSAvXnNjaGVkdWxlZCAoYmVmb3JlfGFmdGVyfG9uKT8gPyguKikvO1xuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gU2NoZWR1bGVkRGF0ZUZpZWxkLnNjaGVkdWxlZFJlZ2V4cDtcbiAgICB9XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3NjaGVkdWxlZCc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc2NoZWR1bGVkRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdzdGFydHMnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXJ0RGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBzdGFydFJlZ2V4cCA9IC9ec3RhcnRzIChiZWZvcmV8YWZ0ZXJ8b24pPyA/KC4qKS87XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiBTdGFydERhdGVGaWVsZC5zdGFydFJlZ2V4cDtcbiAgICB9XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5zdGFydERhdGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpIHtcbiAgICAgICAgLy8gcmVmZXJlbmNlOiBodHRwczovL29ic2lkaWFuLXRhc2tzLWdyb3VwLmdpdGh1Yi5pby9vYnNpZGlhbi10YXNrcy9xdWVyaWVzL2ZpbHRlcnMvI3N0YXJ0LWRhdGVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9ucyB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAnaGFwcGVucycgc2VhcmNoIGluc3RydWN0aW9uLCB3aGljaCBzZWFyY2hlcyBhbGwgb2ZcbiAqIHN0YXJ0LCBzY2hlZHVsZWQgYW5kIGR1ZSBkYXRlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhcHBlbnNEYXRlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgaGFwcGVuc1JlZ2V4cCA9IC9eaGFwcGVucyAoYmVmb3JlfGFmdGVyfG9uKT8gPyguKikvO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGluc3RydWN0aW9uRm9yRmllbGRQcmVzZW5jZSA9ICdoYXMgaGFwcGVucyBkYXRlJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBpbnN0cnVjdGlvbkZvckZpZWxkQWJzZW5jZSA9ICdubyBoYXBwZW5zIGRhdGUnO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsdGVySW5zdHJ1Y3Rpb25zOiBGaWx0ZXJJbnN0cnVjdGlvbnM7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZChIYXBwZW5zRGF0ZUZpZWxkLmluc3RydWN0aW9uRm9yRmllbGRQcmVzZW5jZSwgKHRhc2s6IFRhc2spID0+XG4gICAgICAgICAgICB0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoXG4gICAgICAgICAgICBIYXBwZW5zRGF0ZUZpZWxkLmluc3RydWN0aW9uRm9yRmllbGRBYnNlbmNlLFxuICAgICAgICAgICAgKHRhc2s6IFRhc2spID0+ICF0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgZmlsdGVyUmVzdWx0ID0gdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHQuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZSk7XG5cbiAgICAgICAgY29uc3QgaGFwcGVuc01hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5maWx0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChoYXBwZW5zTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckRhdGUgPSBEYXRlUGFyc2VyLnBhcnNlRGF0ZShoYXBwZW5zTWF0Y2hbMl0pO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJEYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdkbyBub3QgdW5kZXJzdGFuZCBoYXBwZW5zIGRhdGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgbGV0IHJlbGF0aXZlO1xuICAgICAgICAgICAgICAgIGlmIChoYXBwZW5zTWF0Y2hbMV0gPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgJiYgZGF0ZS5pc0JlZm9yZShmaWx0ZXJEYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gJyAnICsgaGFwcGVuc01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFwcGVuc01hdGNoWzFdID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgJiYgZGF0ZS5pc0FmdGVyKGZpbHRlckRhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUgPSAnICcgKyBoYXBwZW5zTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnVuY3Rpb24gPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZXModGFzaykuc29tZSgoZGF0ZSkgPT4gZGF0ZSAmJiBkYXRlLmlzU2FtZShmaWx0ZXJEYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gJyBvbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gRGF0ZUZpZWxkLmdldEV4cGxhbmF0aW9uU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAnZHVlLCBzdGFydCBvciBzY2hlZHVsZWQnLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGUsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gbmV3IEZpbHRlcihsaW5lLCBmaWx0ZXJGdW5jdGlvbiwgbmV3IEV4cGxhbmF0aW9uKGV4cGxhbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZmlsdGVyIChoYXBwZW5zIGRhdGUpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWFybGllc3Qgb2YgdGhlIGRhdGVzIHVzZWQgYnkgJ2hhcHBlbnMnIGluIHRoZSBnaXZlbiB0YXNrLCBvciBudWxsIGlmIG5vbmUgc2V0LlxuICAgICAqXG4gICAgICogR2VuZXJhbGx5IHNwZWFraW5nLCB0aGUgZWFybGllc3QgZGF0ZSBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBoaWdoZXN0IHByaW9yaXR5LFxuICAgICAqIGFzIGl0IGlzIHRoZSBmaXJzdCBwb2ludCBhdCB3aGljaCB0aGUgdXNlciBtaWdodCB3aXNoIHRvIGFjdCBvbiB0aGUgdGFzay5cbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqL1xuICAgIHB1YmxpYyBlYXJsaWVzdERhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCBoYXBwZW5zRGF0ZXMgPSBuZXcgSGFwcGVuc0RhdGVGaWVsZCgpLmRhdGVzKHRhc2spO1xuICAgICAgICBjb25zdCBzb3J0ZWRIYXBwZW5zRGF0ZXMgPSBoYXBwZW5zRGF0ZXMuc29ydChEYXRlRmllbGQuY29tcGFyZUJ5RGF0ZSk7XG4gICAgICAgIHJldHVybiBzb3J0ZWRIYXBwZW5zRGF0ZXNbMF07XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gSGFwcGVuc0RhdGVGaWVsZC5oYXBwZW5zUmVnZXhwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGFzaydzIHN0YXJ0LCBzY2hlZHVsZWQgYW5kIGR1ZSBkYXRlcywgYW55IG9yIGFsbCBvZiB3aGljaCBtYXkgYmUgbnVsbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGF0ZXModGFzazogVGFzayk6IChNb21lbnQgfCBudWxsKVtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5Lm9mKHRhc2suc3RhcnREYXRlLCB0YXNrLnNjaGVkdWxlZERhdGUsIHRhc2suZHVlRGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2hhcHBlbnMnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgc29ydHMgb24gdGhlIGVhcmxpZXN0IG9mIHN0YXJ0LCBzY2hlZHVsZWQgYW5kIGR1ZSBkYXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZUZpZWxkLmNvbXBhcmVCeURhdGUodGhpcy5lYXJsaWVzdERhdGUoYSksIHRoaXMuZWFybGllc3REYXRlKGIpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSZWN1cnJpbmdGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdpcyBub3QgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3JlY3VycmluZyc7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4uL01hdGNoZXJzL0lTdHJpbmdNYXRjaGVyJztcbmltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogTXVsdGlUZXh0RmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0byBoZWxwIGltcGxlbWVudFxuICogYWxsIHRoZSBmaWx0ZXIgaW5zdHJ1Y3Rpb25zIHRoYXQgYWN0IG9uIG11bHRpcGxlIHN0cmluZyB2YWx1ZXNcbiAqIHN1Y2ggYXMgdGhlIHRhZ3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdWx0aVRleHRGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBmaWVsZE5hbWVTaW5ndWxhcigpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVyYWwgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLlxuICAgICAqIElmIG5vdCBvdmVycmlkZGVuLCByZXR1cm5zIHRoZSBzaW5ndWxhciBmb3JtIGFwcGVuZGVkIHdpdGggYW4gXCJzXCIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZVBsdXJhbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZE5hbWVTaW5ndWxhcigpICsgJ3MnO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX0vJHt0aGlzLmZpZWxkTmFtZVBsdXJhbCgpfWA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpZWxkUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfXwke3RoaXMuZmllbGROYW1lUGx1cmFsKCl9YDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyT3BlcmF0b3JQYXR0ZXJuKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci5maWx0ZXJPcGVyYXRvclBhdHRlcm4oKX18aW5jbHVkZXxkbyBub3QgaW5jbHVkZWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgbm90IG92ZXJyaWRkZW4sIHJldHVybnMgYSBjb21tYS1zZXBhcmF0ZWQgY29uY2F0ZW5hdGlvbiBvZiBhbGxcbiAgICAgKiB0aGUgdmFsdWVzIG9mIHRoaXMgZmllbGQgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZXJlIGFyZSBub3QgdmFsdWVzXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHVibGljIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXModGFzaykuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiB2YWx1ZXMgb2YgdGhpcyBmaWVsZCwgb3IgYW4gZW1wdHkgYXJyYXlcbiAgICAgKiBpZiB0aGUgZmllbGQgaGFzIG5vIHZhbHVlc1xuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCB2YWx1ZXModGFzazogVGFzayk6IHN0cmluZ1tdO1xuXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlcihtYXRjaGVyOiBJU3RyaW5nTWF0Y2hlciwgbmVnYXRlOiBib29sZWFuKTogRmlsdGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlciEubWF0Y2hlc0FueU9mKHRoaXMudmFsdWVzKHRhc2spKTtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGUgPyAhbWF0Y2ggOiBtYXRjaDtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgU29ydGVyIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB7IE11bHRpVGV4dEZpZWxkIH0gZnJvbSAnLi9NdWx0aVRleHRGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ3RhZycgYW5kICd0YWdzJyBzZWFyY2ggaW5zdHJ1Y3Rpb25zLlxuICpcbiAqIFRhZ3MgY2FuIGJlIHNlYXJjaGVkIGZvciB3aXRoIGFuZCB3aXRob3V0IHRoZSBoYXNoIHRhZyBhdCB0aGUgc3RhcnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWdzRmllbGQgZXh0ZW5kcyBNdWx0aVRleHRGaWVsZCB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBGaWx0ZXJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHVibGljIGZpZWxkTmFtZVNpbmd1bGFyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAndGFnJztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWVzKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0YXNrLnRhZ3M7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKiBPdmVycmlkZGVuIHRvIGFkZCBzdXBwb3J0IGZvciB0YWcgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlU29ydGVyRnJvbUxpbmUobGluZTogc3RyaW5nKTogU29ydGVyIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCh0aGlzLnNvcnRlclJlZ0V4cCgpKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSAhIW1hdGNoWzFdO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eUluc3RhbmNlID0gaXNOYU4oK21hdGNoWzJdKSA/IDEgOiArbWF0Y2hbMl07XG4gICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBUYWdzRmllbGQubWFrZUNvbXBhcmVCeVRhZ0NvbXBhcmF0b3IocHJvcGVydHlJbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVyKHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSwgY29tcGFyYXRvciwgcmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgd2lsbCBtYXRjaCBhIGNvcnJlY3RseS1mb3JtZWRcbiAgICAgKiBpbnN0cnVjdGlvbiBsaW5lIGZvciBzb3J0aW5nIFRhc2tzIGJ5IHRhZy5cbiAgICAgKlxuICAgICAqIGBtYXRjaFsxXWAgd2lsbCBiZSBlaXRoZXIgYHJldmVyc2VgIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBgbWF0Y2hbMl1gIHdpbGwgYmUgZWl0aGVyIHRoZSB0YWcgbnVtYmVyIG9yIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc29ydGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiAvXnNvcnQgYnkgdGFnKCByZXZlcnNlKT9bXFxzXSooXFxkKyk/LztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSAke0BsaW5rIENvbXBhcmF0b3J9IHRoYXQgc29ydHMgYnkgdGhlIGZpcnN0IHRhZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIFRhZ3NGaWVsZC5tYWtlQ29tcGFyZUJ5VGFnQ29tcGFyYXRvcigxKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYWtlQ29tcGFyZUJ5VGFnQ29tcGFyYXRvcihwcm9wZXJ0eUluc3RhbmNlOiBudW1iZXIpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBubyB0YWdzIHRoZW4gYXNzdW1lIHRoZXkgYXJlIGVxdWFsLlxuICAgICAgICAgICAgaWYgKGEudGFncy5sZW5ndGggPT09IDAgJiYgYi50YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBpcyBsZXNzIHRoYW4gYlxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYiBpcyBsZXNzIHRoYW4gYVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXJyYXlzIHN0YXJ0IGF0IDAgYnV0IHRoZSB1c2VycyBzcGVjaWZ5IGEgdGFnIHN0YXJ0aW5nIGF0IDEuXG4gICAgICAgICAgICBjb25zdCB0YWdJbnN0YW5jZVRvU29ydEJ5ID0gcHJvcGVydHlJbnN0YW5jZSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChhLnRhZ3MubGVuZ3RoIDwgcHJvcGVydHlJbnN0YW5jZSAmJiBiLnRhZ3MubGVuZ3RoID49IHByb3BlcnR5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi50YWdzLmxlbmd0aCA8IHByb3BlcnR5SW5zdGFuY2UgJiYgYS50YWdzLmxlbmd0aCA+PSBwcm9wZXJ0eUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhLnRhZ3MubGVuZ3RoIDwgcHJvcGVydHlJbnN0YW5jZSAmJiBiLnRhZ3MubGVuZ3RoIDwgcHJvcGVydHlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0YWdBID0gYS50YWdzW3RhZ0luc3RhbmNlVG9Tb3J0QnldO1xuICAgICAgICAgICAgY29uc3QgdGFnQiA9IGIudGFnc1t0YWdJbnN0YW5jZVRvU29ydEJ5XTtcbiAgICAgICAgICAgIHJldHVybiB0YWdBLmxvY2FsZUNvbXBhcmUodGFnQiwgdW5kZWZpbmVkLCB7IG51bWVyaWM6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB7IHBhcnNlIGFzIGJvb25QYXJzZSB9IGZyb20gJ2Jvb24tanMnO1xuaW1wb3J0IHR5cGUgeyBQb3N0Zml4RXhwcmVzc2lvbiB9IGZyb20gJ2Jvb24tanMnO1xuXG5pbXBvcnQgeyBwYXJzZUZpbHRlciB9IGZyb20gJy4uL0ZpbHRlclBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogQm9vbGVhbkZpZWxkIGlzIGEgJ2NvbnRhaW5lcicgZmllbGQgdHlwZSB0aGF0IHBhcnNlcyBhIGhpZ2gtbGV2ZWwgZmlsdGVyaW5nIHF1ZXJ5IG9mXG4gKiB0aGUgZm9ybWF0IC0tXG4gKiAgICAoZmlsdGVyMSkgQU5EICgoZmlsdGVyMikgT1IgKGZpbHRlcjMpKVxuICogVGhlIGZpbHRlcnMgY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIHdpdGggYW55IGJvb2xlYW4gb3BlcmF0b3JzIGFzIGxvbmcgYXMgdGhlIGluZGl2aWR1YWwgZmlsdGVycyBhcmVcbiAqIHdyYXBwZWQgaW4gZWl0aGVyIHBhcmFudGhlc2lzIG9yIHF1b3RlcyAtLSAoZmlsdGVyMSkgb3IgXCJmaWx0ZXIxXCIuXG4gKiBXaGF0IGhhcHBlbnMgaW50ZXJuYWxseSBpcyB0aGF0IHdoZW4gdGhlIGJvb2xlYW4gZmllbGQgaXMgYXNrZWQgdG8gY3JlYXRlIGEgZmlsdGVyLCBpdCBwYXJzZXMgdGhlIGJvb2xlYW5cbiAqIHF1ZXJ5IGludG8gYSBsb2dpY2FsIHBvc3RmaXggZXhwcmVzc2lvbiAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmV2ZXJzZV9Qb2xpc2hfbm90YXRpb24pLFxuICogd2l0aCB0aGUgaW5kaXZpZHVhbCBmaWx0ZXIgY29tcG9uZW50cyBhcyBcImlkZW50aWZpZXJcIiB0b2tlbnMuXG4gKiBUaGVzZSBpZGVudGlmaWVycyBoYXZlIGFuIGFzc29jaWF0ZWQgYWN0dWFsIEZpbHRlciAod2hpY2ggaXMgY2FjaGVkIGR1cmluZyB0aGUgcXVlcnkgcGFyc2luZykuXG4gKiBUaGUgcmV0dXJuZWQgRmlsdGVyIG9mIHRoZSB3aG9sZSBib29sZWFuIHF1ZXJ5IGlzIGV2ZW50dWFsbHkgYSBmdW5jdGlvbiB0aGF0IGZvciBlYWNoIFRhc2sgb2JqZWN0LFxuICogZXZhbHVhdGVzIHRoZSBjb21wbGV0ZSBwb3N0Zml4IGV4cHJlc3Npb24gYnkgZ29pbmcgdGhyb3VnaCB0aGUgaW5kaXZpZHVhbCBmaWx0ZXJzIGFuZCB0aGVuIHJlc29sdmluZ1xuICogdGhlIGV4cHJlc3Npb24gaW50byBhIHNpbmdsZSBib29sZWFuIGVudGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5GaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICAvLyBGaXJzdCBwYXR0ZXJuIGluIHRoaXMgbWF0Y2hlcyBjb252ZW50aW9uYWwgKGZpbHRlcjEpIE9SIChmaWx0ZXIyKSBhbmQgc2ltaWxhclxuICAgIC8vIFNlY29uZCBwYXR0ZXJuIG1hdGNoZXMgKGZpbHRlcjEpIC0gdGhhdCBpcywgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGZpbHRlciBpcyB0cmVhdGVkIGFzIHZhbGlkXG4gICAgcHJpdmF0ZSByZWFkb25seSBiYXNpY0Jvb2xlYW5SZWdleHAgPSAvKC4qKEFORHxPUnxYT1J8Tk9UKVxccypbKFwiXS4qfFxcKC4rXFwpKS9nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc3VwcG9ydGVkT3BlcmF0b3JzID0gWydBTkQnLCAnT1InLCAnWE9SJywgJ05PVCddO1xuICAgIHByaXZhdGUgc3ViRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBGaWx0ZXI+ID0ge307XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2ljQm9vbGVhblJlZ2V4cDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpbmUobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4gcXVlcnknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYnVpbGRzIGEgRmlsdGVyIGZvciBhIGNvbXBsZXRlIGJvb2xlYW4gcXVlcnkgYnk6XG4gICAgICogMS4gUHJlcHJvY2Vzc2luZyB0aGUgZXhwcmVzc2lvbiBpbnRvIHNvbWV0aGluZyBvdXIgaGVscGVyIHBhY2thZ2UsIGJvb24tanMsIGtub3dzIGhvdyB0byBidWlsZCBhbiBleHByZXNzaW9uIGZvci5cbiAgICAgKiAyLiBDcmVhdGluZyBhIHBvc3RmaXggbG9naWNhbCBleHByZXNzaW9uIHVzaW5nIGJvb24tanMsIHdoaWNoIGhhcyAtXG4gICAgICogICAgYS4gSWRlbnRpZmllcnMgKGxlYXZlcyksIHdoaWNoIGFyZSByZWd1bGFyIEZpZWxkIGZpbHRlcnMgcmVwcmVzZW50ZWQgYXMgdGhlaXIgc3RyaW5nLlxuICAgICAqICAgIGIuIE9wZXJhdG9ycywgd2hpY2ggYXJlIGxvZ2ljYWwgb3BlcmF0b3JzIGJldHdlZW4gaWRlbnRpZmllcnMgb3IgYmV0d2VlbiBwYXJlbnRoZXNpcy5cbiAgICAgKiAzLiBDcmVhdGluZyB0aGUgZmlsdGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHRoZSBJZGVudGlmaWVycyBpbiB0aGUgZXhwcmVzc2lvbiBhbmQgY2FjaGluZyB0aGVtIGluIHRoaXMuc3ViRmllbGRzLlxuICAgICAqIDQuIFJldHVybmluZyBhIGZpbmFsIGZ1bmN0aW9uIGZpbHRlciwgd2hpY2ggZm9yIGVhY2ggVGFzayBjYW4gcnVuIHRoZSBjb21wbGV0ZSBxdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlTGluZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZW1wdHkgbGluZSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXByb2Nlc3NlZCA9IHRoaXMucHJlcHJvY2Vzc0V4cHJlc3Npb24obGluZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSAocHJlcHJvY2Vzc2VkKSBsaW5lIGludG8gYSBwb3N0Zml4IGxvZ2ljYWwgZXhwcmVzc2lvblxuICAgICAgICAgICAgY29uc3QgcG9zdGZpeEV4cHJlc3Npb24gPSBib29uUGFyc2UocHJlcHJvY2Vzc2VkKTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBzdWItZmllbGQgbWFwLCBpLmUuIGhhdmUgc3ViRmllbGRzIGluY2x1ZGUgYSBmaWx0ZXIgZnVuY3Rpb24gZm9yIGV2ZXJ5XG4gICAgICAgICAgICAvLyBmaW5hbCB0b2tlbiBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBwb3N0Zml4RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnSURFTlRJRklFUicgJiYgdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRva2VuLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaWRlbnRpZmllciBpbiB0aGlzLnN1YkZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEZpZWxkID0gcGFyc2VGaWx0ZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgY291bGRuJ3QgcGFyc2Ugc3ViLWV4cHJlc3Npb24gJyR7aWRlbnRpZmllcn0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZEZpZWxkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYGNvdWxkbid0IHBhcnNlIHN1Yi1leHByZXNzaW9uICcke2lkZW50aWZpZXJ9JzogJHtwYXJzZWRGaWVsZC5lcnJvcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZEZpZWxkLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViRmllbGRzW2lkZW50aWZpZXJdID0gcGFyc2VkRmllbGQuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIHdlJ3JlIGFscmVhZHkgaXRlcmF0aW5nIG92ZXIgdGhlIGV4cHJlc3Npb24sIGFsdGhvdWdoIHdlIGRvbid0IG5lZWQgdGhlIG9wZXJhdG9ycyBhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHN0YWdlIGJ1dCBvbmx5IGluIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkgYmVsb3csIHdlJ3JlIHVzaW5nIHRoZSBvcHBvcnR1bml0eSB0byB2ZXJpZnlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgdmFsaWQuIElmIHdlIHdvbid0LCB0aGVuIGFuIGludmFsaWQgb3BlcmF0b3Igd2lsbCBvbmx5IGJlIGRldGVjdGVkIHdoZW4gdGhlIHF1ZXJ5IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBvbiBhIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2VtcHR5IG9wZXJhdG9yIGluIGJvb2xlYW4gcXVlcnknO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkT3BlcmF0b3JzLmluY2x1ZGVzKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYHVua25vd24gYm9vbGVhbiBvcGVyYXRvciAnJHt0b2tlbi52YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpbHRlciB3aXRoIGZpbHRlciBmdW5jdGlvbiB0aGF0IGNhbiBydW4gdGhlIGNvbXBsZXRlIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyVGFza1dpdGhQYXJzZWRRdWVyeSh0YXNrLCBwb3N0Zml4RXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSB0aGlzLmNvbnN0cnVjdEV4cGxhbmF0aW9uKHBvc3RmaXhFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSBuZXcgRmlsdGVyKGxpbmUsIGZpbHRlckZ1bmN0aW9uLCBleHBsYW5hdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3IgdHlwZSc7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgbWFsZm9ybWVkIGJvb2xlYW4gcXVlcnkgLS0gJHttZXNzYWdlfSAoY2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGd1aWRlbGluZXMpYDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXByb2Nlc3NFeHByZXNzaW9uKGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHF1ZXJ5IHRvIGJlIHByb2Nlc3NlZCBieSBib29uLWpzLlxuICAgICAgICAvLyBCb29uIGRvZXNuJ3QgcHJvY2VzcyBleHByZXNzaW9uIHdpdGggc3BhY2VzIHVubGVzcyB0aGV5IGFyZSBzdXJyb3VuZGVkIGJ5IHF1b3Rlcywgc28gcmVwbGFjZVxuICAgICAgICAvLyAoZHVlIHRvZGF5KSBieSAoXCJkdWUgdG9kYXlcIikuXG4gICAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoL1xcKChbXigpXSspXFwpL2csICcoXCIkMVwiKScpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhpcyBydW4gYSBUYXNrIG9iamVjdCB0aHJvdWdoIGEgY29tcGxldGUgYm9vbGVhbiBleHByZXNzaW9uLlxuICAgICAqIEl0IGJhc2ljYWxseSByZXNvbHZlcyB0aGUgcG9zdGZpeCBleHByZXNzaW9uIHVudGlsIGl0IGlzIHJlZHVjZWQgaW50byBhIHNpbmdsZSBib29sZWFuIHZhbHVlLFxuICAgICAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXBsZXRlIGV4cHJlc3Npb24uXG4gICAgICogU2VlIGhlcmUgaG93IGl0IHdvcmtzOiBodHRwOi8vd3d3LmJ0ZWNoc21hcnRjbGFzcy5jb20vZGF0YV9zdHJ1Y3R1cmVzL3Bvc3RmaXgtZXZhbHVhdGlvbi5odG1sXG4gICAgICogQW5vdGhlciByZWZlcmVuY2U6IGh0dHBzOi8vd3d3LnR1dG9yaWFsc3BvaW50LmNvbS9FdmFsdWF0ZS1Qb3N0Zml4LUV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkodGFzazogVGFzaywgcG9zdGZpeEV4cHJlc3Npb246IFBvc3RmaXhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHRvQm9vbCA9IChzOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzID09PSAndHJ1ZSc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvU3RyaW5nID0gKGI6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9vbGVhblN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ0lERU5USUZJRVInKSB7XG4gICAgICAgICAgICAgICAgLy8gSWRlbnRpZmllcnMgYXJlIHRoZSBzdWItZmllbGRzIG9mIHRoZSBleHByZXNzaW9uLCB0aGUgYWN0dWFsIGZpbHRlcnMsIGUuZy4gJ2Rlc2NyaXB0aW9uIGluY2x1ZGVzIGZvbycuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggaWRlbnRpZmllciB3ZSBjcmVhdGVkIGVhcmxpZXIgdGhlIGNvcnJlc3BvbmRpbmcgRmlsdGVyLCBzbyBub3cgd2UgY2FuIGp1c3QgZXZhbHVhdGUgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdGFzayBmb3IgZWFjaCBpZGVudGlmaWVyIHRoYXQgd2UgZmluZCBpbiB0aGUgcG9zdGZpeCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSBudWxsKSB0aHJvdyBFcnJvcignbnVsbCB0b2tlbiB2YWx1ZScpOyAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5zdWJGaWVsZHNbdG9rZW4udmFsdWUudHJpbSgpXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaWx0ZXIuZmlsdGVyRnVuY3Rpb24odGFzayk7XG4gICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcocmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdPUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICAvLyBUbyBldmFsdWF0ZSBhbiBvcGVyYXRvciB3ZSBuZWVkIHRvIHBvcCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJvb2xlYW4gc3RhY2ssXG4gICAgICAgICAgICAgICAgLy8gZG8gdGhlIGxvZ2ljYWwgZXZhbHVhdGlvbiBhbmQgcHVzaCBiYWNrIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdOT1QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoIWFyZzEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaCh0b1N0cmluZyhhcmcxIHx8IGFyZzIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnQU5EJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoYXJnMSAmJiBhcmcyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1hPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMSA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcyID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKChhcmcxICYmICFhcmcyKSB8fCAoIWFyZzEgJiYgYXJnMikpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcgKyB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgdG9rZW4gdHlwZTogJyArIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVudHVhbGx5IHRoZSByZXN1bHQgb2YgdGhlIGV4cHJlc3Npb24gZm9yIHRoaXMgVGFzayBpcyB0aGUgb25seSBpdGVtIGxlZnQgaW4gdGhlIGJvb2xlYW4gc3RhY2tcbiAgICAgICAgcmV0dXJuIHRvQm9vbChib29sZWFuU3RhY2tbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgRXhwbGFuYXRpb259IHJlcHJlc2VudGluZyB0aGUgY29tcGxldGUgQm9vbGVhbiBpbnN0cnVjdGlvbiBjdXJyZW50bHkgYmVpbmcgYW5hbHlzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zdGZpeEV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGNvbnN0cnVjdEV4cGxhbmF0aW9uKHBvc3RmaXhFeHByZXNzaW9uOiBQb3N0Zml4RXhwcmVzc2lvbik6IEV4cGxhbmF0aW9uIHtcbiAgICAgICAgLy8gRm9yIGFuIGV4cGxhbmF0aW9uIG9mIHRoZSBjb2RlLCBzZWUgdGhlIEpTZG9jIGFuZCBjb21tZW50cyBvZiBmaWx0ZXJUYXNrV2l0aFBhcnNlZFF1ZXJ5KClcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25TdGFjazogRXhwbGFuYXRpb25bXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ0lERU5USUZJRVInKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHRocm93IEVycm9yKCdudWxsIHRva2VuIHZhbHVlJyk7IC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnN1YkZpZWxkc1t0b2tlbi52YWx1ZS50cmltKCldO1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uU3RhY2sucHVzaChmaWx0ZXIuZXhwbGFuYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgLy8gVG8gZXZhbHVhdGUgYW4gb3BlcmF0b3Igd2UgbmVlZCB0byBwb3AgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBib29sZWFuIHN0YWNrLFxuICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBsb2dpY2FsIGV2YWx1YXRpb24gYW5kIHB1c2ggYmFjayB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnTk9UJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Ob3QoW2FyZzEhXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IGV4cGxhbmF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleHBsYW5hdGlvblN0YWNrLnB1c2goRXhwbGFuYXRpb24uYm9vbGVhbk9yKFthcmcxISwgYXJnMiFdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ0FORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IGV4cGxhbmF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleHBsYW5hdGlvblN0YWNrLnB1c2goRXhwbGFuYXRpb24uYm9vbGVhbkFuZChbYXJnMSEsIGFyZzIhXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdYT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Yb3IoW2FyZzEhLCBhcmcyIV0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcgKyB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgdG9rZW4gdHlwZTogJyArIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVudHVhbGx5IHRoZSBFeHBsYW5hdGlvbiBpcyB0aGUgb25seSBpdGVtIGxlZnQgaW4gdGhlIGJvb2xlYW4gc3RhY2tcbiAgICAgICAgcmV0dXJuIGV4cGxhbmF0aW9uU3RhY2tbMF07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKiogU3VwcG9ydCB0aGUgJ2ZpbGVuYW1lJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKlxuICogTm90ZSB0aGF0IHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFsc28gc2VhcmNoZXMgdGhlIGZpbGUgZXh0ZW5zaW9uLFxuICogc28gJ2ZpbGVuYW1lIGluY2x1ZGVzIC5tZCcgd2lsbCB0eXBpY2FsbHkgbWF0Y2ggYWxsIHRhc2tzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVuYW1lRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdmaWxlbmFtZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsZSBuYW1lIGluY2x1ZGluZyBmaWxlIGV4dGVuc2lvbiwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSB0YXNrIGRvZXMgbm90IGhhdmUgYSBmaWxlbmFtZVxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0YXNrLmZpbGVuYW1lO1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZW5hbWUgKyAnLm1kJztcbiAgICB9XG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcblxuLyoqXG4gKiBBIHtAbGluayBGaWVsZH0gaW1wbGVtZW50YXRpb24gZm9yIHNlYXJjaGluZyBzdGF0dXMubmFtZVxuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzTmFtZUZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnc3RhdHVzLm5hbWUnO1xuICAgIH1cblxuICAgIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5zdGF0dXMubmFtZTtcbiAgICB9XG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4uLy4uL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogQSAke0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbiBmb3Igc2VhcmNoaW5nIHN0YXR1cy50eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNUeXBlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBGaWx0ZXJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBVc2UgYSByZWxheGVkIHJlZ2V4cCwganVzdCBjaGVja2luZyBmaWVsZCBuYW1lIGFuZCBub3QgdGhlIGNvbnRlbnRzLFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGUgbGluZSBsYXRlciBhbmQgZ2l2ZSBtZWFuaW5nZnVsIGVycm9ycyBpZiB1c2VyIHVzZXMgaW52YWxpZCB2YWx1ZXMuXG4gICAgICAgIGNvbnN0IHJlbGF4ZWRSZWdFeHAgPSBuZXcgUmVnRXhwKGBeKD86JHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZCgpfSlgKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHJlbGF4ZWRSZWdFeHAsIGxpbmUpO1xuICAgIH1cblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmZpbHRlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJdCdzIE9LIHRvIGdldCBoZXJlLCBiZWNhdXNlIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUoKSB1c2VzIGEgbW9yZSByZWxheGVkIHJlZ2V4cC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlbHBNZXNzYWdlKGxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW18sIGZpbHRlck9wZXJhdG9yLCBzdGF0dXNUeXBlQXNTdHJpbmddID0gbWF0Y2g7XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzVHlwZUVsZW1lbnQgPSBTdGF0dXNUeXBlW3N0YXR1c1R5cGVBc1N0cmluZy50b1VwcGVyQ2FzZSgpIGFzIGtleW9mIHR5cGVvZiBTdGF0dXNUeXBlXTtcbiAgICAgICAgaWYgKCFzdGF0dXNUeXBlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVscE1lc3NhZ2UobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlsdGVyRnVuY3Rpb246IEZpbHRlckZ1bmN0aW9uO1xuXG4gICAgICAgIHN3aXRjaCAoZmlsdGVyT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ2lzJzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLnN0YXR1cy50eXBlID09PSBzdGF0dXNUeXBlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXMgbm90JzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLnN0YXR1cy50eXBlICE9PSBzdGF0dXNUeXBlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRmlsdGVyKG5ldyBGaWx0ZXIobGluZSwgZmlsdGVyRnVuY3Rpb24sIG5ldyBFeHBsYW5hdGlvbihsaW5lKSkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeKD86JHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZCgpfSkgKGlzfGlzIG5vdCkgKFteIF0rKSRgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhlbHBNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZFR5cGVzID0gT2JqZWN0LnZhbHVlcyhTdGF0dXNUeXBlKVxuICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gdCAhPT0gU3RhdHVzVHlwZS5FTVBUWSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBJbnZhbGlkICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfSBpbnN0cnVjdGlvbjogJyR7bGluZX0nLlxuICAgIEFsbG93ZWQgb3B0aW9uczogJ2lzJyBhbmQgJ2lzIG5vdCcgKHdpdGhvdXQgcXVvdGVzKS5cbiAgICBBbGxvd2VkIHZhbHVlczogICR7YWxsb3dlZFR5cGVzfVxuICAgICAgICAgICAgICAgICAgICAgTm90ZTogdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc28gJ2luX3Byb2dyZXNzJyB3b3JrcyB0b28sIGZvciBleGFtcGxlLlxuICAgIEV4YW1wbGU6ICAgICAgICAgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9IGlzIG5vdCBOT05fVEFTS2A7XG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXR1cy50eXBlJztcbiAgICB9XG5cbiAgICB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc3RhdHVzLnR5cGU7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlBID0gU3RhdHVzVHlwZUZpZWxkLmdyb3VwTmFtZShhKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUIgPSBTdGF0dXNUeXBlRmllbGQuZ3JvdXBOYW1lKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGtleUEubG9jYWxlQ29tcGFyZShrZXlCLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbU3RhdHVzVHlwZUZpZWxkLmdyb3VwTmFtZSh0YXNrKV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBOYW1lKHRhc2s6IFRhc2spIHtcbiAgICAgICAgbGV0IHByZWZpeDogc3RyaW5nO1xuICAgICAgICAvLyBBZGQgYSBudW1lcmljIHByZWZpeCB0byBzb3J0IGluIHRvIGEgbWVhbmluZ2Z1bCBvcmRlciBmb3IgdXNlcnNcbiAgICAgICAgc3dpdGNoICh0YXNrLnN0YXR1cy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1M6XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLlRPRE86XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLkRPTkU6XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLkNBTkNFTExFRDpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnNCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuTk9OX1RBU0s6XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0dXNUeXBlLkVNUFRZOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICc2JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgJyAnICsgdGFzay5zdGF0dXMudHlwZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSZWN1cnJlbmNlRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3JlY3VycmVuY2UnO1xuICAgIH1cblxuICAgIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5yZWN1cnJlbmNlIS50b1RleHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBEZXNjcmlwdGlvbkZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRGVzY3JpcHRpb25GaWVsZCc7XG5pbXBvcnQgeyBEb25lRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRG9uZURhdGVGaWVsZCc7XG5pbXBvcnQgeyBEdWVEYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9EdWVEYXRlRmllbGQnO1xuaW1wb3J0IHsgRXhjbHVkZVN1Ykl0ZW1zRmllbGQgfSBmcm9tICcuL0ZpbHRlci9FeGNsdWRlU3ViSXRlbXNGaWVsZCc7XG5pbXBvcnQgeyBIZWFkaW5nRmllbGQgfSBmcm9tICcuL0ZpbHRlci9IZWFkaW5nRmllbGQnO1xuaW1wb3J0IHsgUGF0aEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUGF0aEZpZWxkJztcbmltcG9ydCB7IFByaW9yaXR5RmllbGQgfSBmcm9tICcuL0ZpbHRlci9Qcmlvcml0eUZpZWxkJztcbmltcG9ydCB7IFNjaGVkdWxlZERhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1NjaGVkdWxlZERhdGVGaWVsZCc7XG5pbXBvcnQgeyBTdGFydERhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1N0YXJ0RGF0ZUZpZWxkJztcbmltcG9ydCB7IEhhcHBlbnNEYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9IYXBwZW5zRGF0ZUZpZWxkJztcbmltcG9ydCB7IFJlY3VycmluZ0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUmVjdXJyaW5nRmllbGQnO1xuaW1wb3J0IHsgU3RhdHVzRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TdGF0dXNGaWVsZCc7XG5pbXBvcnQgeyBUYWdzRmllbGQgfSBmcm9tICcuL0ZpbHRlci9UYWdzRmllbGQnO1xuaW1wb3J0IHsgQm9vbGVhbkZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvQm9vbGVhbkZpZWxkJztcbmltcG9ydCB7IEZpbGVuYW1lRmllbGQgfSBmcm9tICcuL0ZpbHRlci9GaWxlbmFtZUZpZWxkJztcbmltcG9ydCB7IFVyZ2VuY3lGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1VyZ2VuY3lGaWVsZCc7XG5pbXBvcnQgeyBTdGF0dXNOYW1lRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TdGF0dXNOYW1lRmllbGQnO1xuaW1wb3J0IHsgU3RhdHVzVHlwZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzVHlwZUZpZWxkJztcblxuaW1wb3J0IHsgUmVjdXJyZW5jZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUmVjdXJyZW5jZUZpZWxkJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlci9GaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBTb3J0ZXIgfSBmcm9tICcuL1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXIgfSBmcm9tICcuL0dyb3VwZXInO1xuXG5jb25zdCBmaWVsZENyZWF0b3JzID0gW1xuICAgICgpID0+IG5ldyBTdGF0dXNOYW1lRmllbGQoKSwgLy8gc3RhdHVzLm5hbWUgaXMgYmVmb3JlIHN0YXR1cywgdG8gYXZvaWQgYW1iaWd1aXR5XG4gICAgKCkgPT4gbmV3IFN0YXR1c1R5cGVGaWVsZCgpLCAvLyBzdGF0dXMudHlwZSBpcyBiZWZvcmUgc3RhdHVzLCB0byBhdm9pZCBhbWJpZ3VpdHlcbiAgICAoKSA9PiBuZXcgU3RhdHVzRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUmVjdXJyaW5nRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUHJpb3JpdHlGaWVsZCgpLFxuICAgICgpID0+IG5ldyBIYXBwZW5zRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFN0YXJ0RGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFNjaGVkdWxlZERhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEdWVEYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRG9uZURhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBQYXRoRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRGVzY3JpcHRpb25GaWVsZCgpLFxuICAgICgpID0+IG5ldyBUYWdzRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgSGVhZGluZ0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEV4Y2x1ZGVTdWJJdGVtc0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEJvb2xlYW5GaWVsZCgpLFxuICAgICgpID0+IG5ldyBGaWxlbmFtZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFVyZ2VuY3lGaWVsZCgpLFxuICAgICgpID0+IG5ldyBSZWN1cnJlbmNlRmllbGQoKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpbHRlcihmaWx0ZXJTdHJpbmc6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHwgbnVsbCB7XG4gICAgZm9yIChjb25zdCBjcmVhdG9yIG9mIGZpZWxkQ3JlYXRvcnMpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBjcmVhdG9yKCk7XG4gICAgICAgIGlmIChmaWVsZC5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGZpbHRlclN0cmluZykpIHJldHVybiBmaWVsZC5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShmaWx0ZXJTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU29ydGVyKHNvcnRlclN0cmluZzogc3RyaW5nKTogU29ydGVyIHwgbnVsbCB7XG4gICAgLy8gTmV3IHN0eWxlIHBhcnNpbmcsIHVzaW5nIHNvcnRpbmcgd2hpY2ggaXMgZG9uZSBieSB0aGUgRmllbGQgY2xhc3Nlcy5cblxuICAgIC8vIE9wdGltaXNhdGlvbjogQ2hlY2sgd2hldGhlciBsaW5lIGJlZ2lucyB3aXRoICdzb3J0IGJ5J1xuICAgIGNvbnN0IHNvcnRCeVJlZ2V4cCA9IC9ec29ydCBieSAvO1xuICAgIGlmIChzb3J0ZXJTdHJpbmcubWF0Y2goc29ydEJ5UmVnZXhwKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgaWYgYW55IG9mIHRoZSBmaWVsZHMgY2FuIHBhcnNlIHRoZSBsaW5lLlxuICAgIGZvciAoY29uc3QgY3JlYXRvciBvZiBmaWVsZENyZWF0b3JzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gY3JlYXRvcigpO1xuICAgICAgICBjb25zdCBzb3J0ZXIgPSBmaWVsZC5wYXJzZVNvcnRMaW5lKHNvcnRlclN0cmluZyk7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUdyb3VwZXIobGluZTogc3RyaW5nKTogR3JvdXBlciB8IG51bGwge1xuICAgIC8vIE5ldyBzdHlsZSBwYXJzaW5nLCB1c2luZyBncm91cGluZyB3aGljaCBpcyBkb25lIGJ5IHRoZSBGaWVsZCBjbGFzc2VzLlxuXG4gICAgLy8gT3B0aW1pc2F0aW9uOiBDaGVjayB3aGV0aGVyIGxpbmUgYmVnaW5zIHdpdGggJ2dyb3VwIGJ5J1xuICAgIGNvbnN0IGdyb3VwQnlSZWdleHAgPSAvXmdyb3VwIGJ5IC87XG4gICAgaWYgKGxpbmUubWF0Y2goZ3JvdXBCeVJlZ2V4cCkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgZmllbGRzIGNhbiBwYXJzZSB0aGUgbGluZS5cbiAgICBmb3IgKGNvbnN0IGNyZWF0b3Igb2YgZmllbGRDcmVhdG9ycykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNyZWF0b3IoKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGQuZmllbGROYW1lU2luZ3VsYXIoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IGBncm91cCBieSAke2ZpZWxkTmFtZX1gKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuc3VwcG9ydHNHcm91cGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmNyZWF0ZUdyb3VwZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbiIsICIvKipcbiAqIEdyb3VwSGVhZGluZyBjb250YWlucyB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIG9uZSBoZWFkaW5nIGZvciBhIGdyb3VwIG9mIHRhc2tzXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cEhlYWRpbmcge1xuICAgIC8qKlxuICAgICAqIEhvdyBuZXN0ZWQgdGhlIGhlYWRpbmcgaXMuXG4gICAgICogMCBpcyB0aGUgZmlyc3QgZ3JvdXAsIG1lYW5pbmcgdGhpcyBoZWFkaW5nIHdhcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiB0aGUgZmlyc3QgJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmVzdGluZ0xldmVsOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgR3JvdXBIZWFkaW5nIG9iamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nTGV2ZWwgLSBTZWUgdGhpcy5uZXN0aW5nTGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIGdyb3VwXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmVzdGluZ0xldmVsOiBudW1iZXIsIG5hbWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLm5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgR3JvdXBIZWFkaW5nIH0gZnJvbSAnLi9Hcm91cEhlYWRpbmcnO1xuaW1wb3J0IHR5cGUgeyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzU3RvcmFnZSB9IGZyb20gJy4vSW50ZXJtZWRpYXRlVGFza0dyb3Vwcyc7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvZiBHcm91cC50c1xuICovXG5cbi8qKlxuICogRXhwbGFuYXRpb24gb2YgdGhlIGFsZ29yaXRobXMgdXNlZCBoZXJlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdGV4dCBpcyB0YWtlbiBmcm9tXG4gKiBodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY4NjA1MzcwODI2MTIyODU3Ny84NDAyODYyNjQ5NjQwMjIzMDIvOTU1MjQwODEyOTczODA5Njc0XG4gKlxuICogVGhlIFByb2JsZW1cbiAqID09PT09PT09PT09XG4gKlxuICogSW1hZ2luZSB0aGF0IHRoZSB1c2VyIGhhcyBzdXBwbGllZCAzICdncm91cCBieScgaW5zdHJ1Y3Rpb25zLCBhbmQgaW4gb3JkZXJcbiAqIHRvIHByZXNlbnQgdGhlIHJlc3VsdHMsIHdlIHNpbXBseSBjb25jYXRlbmF0ZSB0aGUgZ3JvdXAgbmFtZXMgdG9nZXRoZXJcbiAqIHdpdGggJz4nLlxuICpcbiAqIFNvIHRoZSBkaXNwbGF5IG1pZ2h0IGxvb2sgc29tZXRoaW5nIGxpa2U6XG4gKiAgICAgICMjIyMgMTAuMCA+IDIwMjItMDMtMjAgPiBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIDEwLjAgPiAyMDIyLTAzLTIyID4gU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDdcbiAqICAgICAgLSB0YXNrIDlcbiAqXG4gKiBUaGUgaGVhZGluZ3MgZ2V0IHZlcnkgaGFyZCB0byByZWFkLCB2ZXJ5IHF1aWNrbHkuXG4gKlxuICogV2hhdCB3ZSB3YW50IGluc3RlYWQgaXM6XG4gKiAgICAgICMjIyMgMTAuMFxuICogICAgICAjIyMjIyAyMDIyLTAzLTIwXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIyAyMDIyLTAzLTIyXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgN1xuICogICAgICAtIHRhc2sgOVxuICpcbiAqIEknbSBzdHJ1Z2dsaW5nIHRvIGdldCBteSBoZWFkIGFyb3VuZCBob3csIGluIFRTLCBJIGNhbiBzdG9yZSBzb21ldGhpbmcgbGlrZSBhIHRyZWUgc3RydWN0dXJlLFxuICogb2YgYXJiaXRyYXJ5IGRlcHRoIC0gdG8gcmVwcmVzZW50IHRoZSBncm91cGVkIHRhc2tzLlxuICpcbiAqIHBqZWJ5J3MgYW5zd2VyXG4gKiA9PT09PT09PT09PT09PVxuICpcbiAqIFVzZXIgcGplYnkgcmVwbGllZDpcbiAqIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvNjg2MDUzNzA4MjYxMjI4NTc3Lzg0MDI4NjI2NDk2NDAyMjMwMi85NTU1Nzk1NjAwMzQ5ODM5NDZcbiAqXG4gKiBJZiBhbGwgeW91J3JlIGRvaW5nIGlzIGdlbmVyYXRpbmcgaGVhZGluZ3MsIHRoZSBzaW1wbGUgYWxnb3JpdGhtIHdvdWxkIGJlIHRvIHNvcnQgZXZlcnl0aGluZyBieSBhIG11bHRpLXZhbHVlIGtleSAtXG4gKiBpLmUuLCBbbGV2ZWwgMSwgbGV2ZWwgMiwgLi4uLCBpdGVtIHNvcnQga2V5XSAtLSB0aGVuIGl0ZXJhdGUgdGhlIHdob2xlIGxpc3QgYW5kIG91dHB1dCBhIGhlYWRpbmcgZm9yIGVhY2ggbGV2ZWxcbiAqIHdoZXJlIHRoZSB2YWx1ZSBjaGFuZ2VkLlxuICpcbiAqIGkuZS4sIHlvdSBzdGFydCB3aXRoIGEgW251bGwsIG51bGwsIG51bGwsIG51bGwuLi4uXSBcImxhc3Qgc2VlblwiIGFycmF5IGFuZCBjb21wYXJlIGl0IGl0ZW0gYnkgaXRlbSB0byB0aGUgY3VycmVudFxuICogaXRlbSdzIGRhdGEsIGFuZCBvdXRwdXQgYSBoZWFkaW5nIG9mIHRoZSBjb3JyZWN0IGxldmVsIGlmIHRoZXJlJ3MgYSBjaGFuZ2UsIHVwZGF0aW5nIHRoZSBpdGVtIGluIHlvdXJcbiAqIFwibGFzdCBzZWVuXCIgYXJyYXkuXG4gKlxuICogaS5lLiBpZiB0aGUgZmlyc3QgaXRlbSBpcyBkaWZmZXJlbnQsIG91dHB1dCBhbiBIMSBmb3IgdGhlIG5ldyB2YWx1ZSBhbmQgc2V0IHRoZSByZXN0IG9mIHRoZSBhcnJheSB0byBudWxsLlxuICogSWYgdGhlIHNlY29uZCBpdGVtIGlzIGFsc28gZGlmZmVyZW50LCBvdXRwdXQgYW4gSDIsIHNhdmUgdGhlIHZhbHVlLCBzZXQgdGhlIHJlc3QgdG8gbnVsbCwgYW5kIHNvIG9uLlxuICogQWZ0ZXIgYWxsIHRoZSBsZXZlbHMgYXJlIGNoZWNrZWQsIG91dHB1dCB0aGUgYWN0dWFsIGl0ZW0uXG4gKiBJZiB0aGVyZSBhcmUgbm8gY2hhbmdlcywgdGhlbiBiYXNpY2FsbHkgeW91J2xsIGp1c3QgYmUgb3V0cHV0dGluZyB0aGUgaXRlbS5cbiAqIE5vIHRyZWVzIG9yIGdyYXBocyBvciB3aGF0bm90IG5lZWRlZC5cbiAqXG4gKiBZb3UgY291bGQgYWxzbyBqdXN0IGtlZXAgdGhlIGxhc3QgaXRlbSBhbmQgc2V0IGEgZmxhZyBhcyBzb29uIGFzIHNvbWV0aGluZyBkb2Vzbid0IG1hdGNoLCBhbmQga2VlcCBvdXRwdXR0aW5nXG4gKiBoZWFkaW5ncyBhcyBzb29uIGFzIHRoZSBmbGFnIGlzIHNldC5cbiAqXG4gKiBXaGF0IHRoZSBjb2RlIGRvZXNcbiAqID09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoZSBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzIGNsYXNzIGJlbG93IGRvZXMgdGhlIGluaXRpYWwgZ3JvdXBpbmcgYW5kIHNvcnRpbmcuXG4gKlxuICogVGhlIEdyb3VwSGVhZGluZ3MgY2xhc3MgYmVsb3cgaW1wbGVtZW50cyBwamVieSdzIGhlYWRpbmcgZGV0ZWN0aW9uIGFsZ29yaXRobSwgYnV0IGluc3RlYWQgb2YgZG9pbmcgdGhlIHByaW50aW5nIGRpcmVjdGx5LFxuICogaXQgcmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWFkaW5nIGxldmVscyBpbiBhbiBhcnJheSBvZiBHcm91cEhlYWRpbmcgb2JqZWN0cywgZm9yIGxhdGVyIHVzZSBpbiBRdWVyeVJlbmRlcmVyLnRzLlxuICovXG5cbi8qKlxuICogR3JvdXBIZWFkaW5ncyBjYWxjdWxhdGVzIHdoaWNoIGhlYWRpbmdzIG5lZWQgdG8gYmUgZGlzcGxheWVkLCBmb3JcbiAqIGEgZ2l2ZW4gZ3JvdXAgb2YgdGFza3MuXG4gKlxuICogU2VlIHRoZSBleHBsYW5hdGlvbiBpbiBHcm91cEhlYWRpbmdzLnRzIGZvciBob3cgaXQgd29ya3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cEhlYWRpbmdzIHtcbiAgICBwcml2YXRlIGxhc3RIZWFkaW5nQXRMZXZlbCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihncm91cGVkVGFza3M6IEludGVybWVkaWF0ZVRhc2tHcm91cHNTdG9yYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0R3JvdXAgPSBncm91cGVkVGFza3Mua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgY29uc3QgZ3JvdXBDb3VudCA9IGZpcnN0R3JvdXAubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5sYXN0SGVhZGluZ0F0TGV2ZWwucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG1pbmltYWwgc2V0IG9mIGhlYWRpbmdzIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgICAqIGJlZm9yZSB0aGUgdGFza3Mgd2l0aCB0aGUgZ2l2ZW4gZ3JvdXAgbmFtZXMuXG4gICAgICpcbiAgICAgKiBEYXRhIGZvciBlYWNoIHJlcXVpcmVkIGhlYWRpbmcgaXMgc3RvcmVkIGluIGEgR3JvdXBIZWFkaW5nIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBOYW1lcyAwIG9yIG1vcmUgZ3JvdXAgbmFtZXMsIG9uZSBwZXIgJ2dyb3VwIGJ5JyBsaW5lXG4gICAgICovXG4gICAgZ2V0SGVhZGluZ3NGb3JUYXNrR3JvdXAoZ3JvdXBOYW1lczogc3RyaW5nW10pOiBHcm91cEhlYWRpbmdbXSB7XG4gICAgICAgIC8vIFNlZSAncGplYnkncyBhbnN3ZXInIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgaGVhZGluZ3NGb3JHcm91cCA9IG5ldyBBcnJheTxHcm91cEhlYWRpbmc+KCk7XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBncm91cE5hbWVzLmxlbmd0aDsgbGV2ZWwrKykge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cE5hbWVzW2xldmVsXTtcbiAgICAgICAgICAgIGlmIChncm91cCAhPSB0aGlzLmxhc3RIZWFkaW5nQXRMZXZlbFtsZXZlbF0pIHtcbiAgICAgICAgICAgICAgICBoZWFkaW5nc0Zvckdyb3VwLnB1c2gobmV3IEdyb3VwSGVhZGluZyhsZXZlbCwgZ3JvdXApKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgdGhlIGxvd2VyIGhlYWRpbmcgbGV2ZWxzIHRvIHVuLXNlZW5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbGV2ZWw7IGogPCBncm91cE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2xldmVsXSA9IGdyb3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkaW5nc0Zvckdyb3VwO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEEgbm9kZSBpbiB0aGUgZ3JvdXBpbmcgdHJlZS4gVGhlIG5vZGUgY29udGFpbnMgdGhlXG4gKiBsaXN0IG9mIHZhbHVlcyBtYXRjaGluZyB0aGUgcGF0aCBmcm9tIHRoZSByb290IHNvIGZhciwgYW5kIGl0cyBjaGlsZHJlblxuICogYXJlIHRoZSBmdXJ0aGVyIGdyb3VwaW5nIG9mIHRob3NlIHZhbHVlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cGluZ1RyZWVOb2RlPFQ+IHtcbiAgICBjaGlsZHJlbjogTWFwPHN0cmluZywgR3JvdXBpbmdUcmVlTm9kZTxUPj4gPSBuZXcgTWFwKCk7XG4gICAgdmFsdWVzOiBUW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHZhbHVlczogVFtdKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSB0cmVlIHRvIGdlbmVyYXRlIGFsbCB0aGUgcGF0aHMgdG8gdGhlIGxlYXZlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBtYXAgZnJvbSBldmVyeSBsZWFmIHBhdGgsIHRvIHRoZSBsaXN0IG9mIHZhbHVlc1xuICAgICAqIG1hdGNoaW5nIHRoaXMgcGF0aC5cbiAgICAgKiBOT1RFOiBUaGUgbm9kZSBpdHNlbGYgZG9lc24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBwYXRocy5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFsbFBhdGhzKHBhdGhTb0Zhcjogc3RyaW5nW10gPSBbXSk6IE1hcDxzdHJpbmdbXSwgVFtdPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IExlYWYgbm9kZS4gUG9wdWxhdGUgdGhlIHJlc3VsdHMgbWFwIHdpdGggdGhlIHBhdGggdG9cbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSwgYW5kIHRoZSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGlzIHBhdGguXG4gICAgICAgICAgICByZXN1bHRNYXAuc2V0KFsuLi5wYXRoU29GYXJdLCB0aGlzLnZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwYXRoU29GYXIucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFJlc3VsdCA9IGNoaWxkLmdlbmVyYXRlQWxsUGF0aHMocGF0aFNvRmFyKTtcbiAgICAgICAgICAgIGNoaWxkUmVzdWx0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHJlc3VsdE1hcC5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgcGF0aFNvRmFyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNYXA7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuL0dyb3VwJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgeyBHcm91cGluZ1RyZWVOb2RlIH0gZnJvbSAnLi9Hcm91cGluZ1RyZWVOb2RlJztcblxuLyoqXG4gKiBTdG9yYWdlIHVzZWQgZm9yIHRoZSBpbml0aWFsIGdyb3VwaW5nIHRvZ2V0aGVyIG9mIHRhc2tzLlxuICpcbiAqIFRoZSBrZXlzIG9mIHRoZSBtYXAgYXJlIHRoZSBuYW1lcyBvZiB0aGUgZ3JvdXBzLlxuICogRm9yIGV4YW1wbGUsIG9uZSBzZXQgb2Yga2V5cyBtaWdodCBiZSBbJ0ZvbGRlciBOYW1lLycsICdGaWxlIE5hbWUnXVxuICogYW5kIHRoZSB2YWx1ZXMgd291bGQgYmUgYWxsIHRoZSBtYXRjaGluZyBUYXNrcyBmcm9tIHRoYXQgZmlsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVybWVkaWF0ZVRhc2tHcm91cHNTdG9yYWdlIGV4dGVuZHMgTWFwPHN0cmluZ1tdLCBUYXNrW10+IHt9XG5cbi8qXG4gKiBBIHRyZWUgb2YgdGFza3Mgd2hlcmUgZXZlcnkgbGV2ZWwgaW4gdGhlIHRyZWUgY29ycmVzcG9uZHMgdG8gYSBncm91cGluZyBwcm9wZXJ0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZTpcbiAqICMgSGVhZGluZyAxXG4gKiAtIFsgXSBUYXNrIDFcbiAqICMgSGVhZGluZyAyXG4gKiAtIFsgXSBUYXNrIDJcbiAqIC0gW1hdIFRhc2sgM1xuICpcbiAqIEFuZCB3ZSBncm91cCBieSBoZWFkaW5nIHRoZW4gc3RhdHVzLCB0aGUgdHJlZSB3aWxsIGxvb2sgbGlrZTpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICBSb290IFtUMSwgVDIsIFQzXVxuICogICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAgICBcXFxuICogICAgICAgICAgICAgIEhlYWRpbmcgMSBbVDFdICAgICBIZWFkaW5nIFtUMiwgVDNdXG4gKiAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgLyAgICAgICAgXFxcbiAqICAgICAgICAgICAgICAgVE9ETyBbVDFdICAgICBUT0RPIFtUMl0gICAgRG9uZSBbVDNdXG4gKlxuICogVGhlIG5pY2UgcHJvcGVydHkgb2YgdGhpcyB0cmVlIGlzIHRoYXQgZXZlcnkgcGF0aCBmcm9tIHRoZSByb290IHRvIGEgbGVhZiwgbWFwc1xuICogdG8gaG93IHRoZSB0YXNrcyB3aWxsIGJlIHJlbmRlcmVkLlxuICpcbiAqIE5PVEU6IFRoZSBzYW1lIHRhc2sgY2FuIGFwcGVhciBpbiBtdWx0aXBsZSBsZWFmIG5vZGVzLCBpZiBpdCBtYXRjaGVzIG11bHRpcGxlIHBhdGhzLlxuICovXG5jbGFzcyBUYXNrR3JvdXBpbmdUcmVlTm9kZSBleHRlbmRzIEdyb3VwaW5nVHJlZU5vZGU8VGFzaz4ge31cblxuLyoqXG4gKiBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzIGRvZXMgdGhlIGluaXRpYWwgZ3JvdXBpbmcgdG9nZXRoZXIgb2YgdGFza3MsXG4gKiBpbiBhbHBoYWJldGljYWwgb3JkZXIgYnkgZ3JvdXAgbmFtZXMuXG4gKlxuICogSXQgaXMgZXNzZW50aWFsbHkgYSB0aGluIHdyYXBwZXIgYXJvdW5kIE1hcCAtIHNlZSBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzU3RvcmFnZS5cbiAqXG4gKiBJdCBpcyBuYW1lZCBcIkludGVybWVkaWF0ZVwiIGJlY2F1c2UgaXRzIHJlc3VsdHMgYXJlIG9ubHkgdGVtcG9yYXJ5LlxuICogVGhleSB3aWxsIGJlIGRpc2NhcmRlZCBvbmNlIHRoZSBmaW5hbCBUYXNrR3JvdXBzIG9iamVjdCBpcyBjcmVhdGVkLlxuICpcbiAqIElkZWFsbHksIHRoaXMgY29kZSB3b3VsZCBiZSBzaW1wbGlmaWVkIGFuZCBtb3ZlZCBpbiB0byBUYXNrR3JvdXBzLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJtZWRpYXRlVGFza0dyb3VwcyB7XG4gICAgcHVibGljIGdyb3VwcyA9IG5ldyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzU3RvcmFnZSgpO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYSBsaXN0IG9mIHRhc2tzLCBhY2NvcmRpbmcgdG8gb25lIG9yIG1vcmUgdGFzayBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIGdyb3VwaW5ncyAwIG9yIG1vcmUgR3JvdXBpbmcgdmFsdWVzLCBvbmUgcGVyICdncm91cCBieScgbGluZVxuICAgICAqIEBwYXJhbSB0YXNrcyBUaGUgdGFza3MgdGhhdCBtYXRjaCB0aGUgdGFzayBibG9jaydzIFF1ZXJ5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3JvdXBpbmdzOiBHcm91cGVyW10sIHRhc2tzOiBUYXNrW10pIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IHRoaXMuYnVpbGRHcm91cGluZ1RyZWUoZ3JvdXBpbmdzLCB0YXNrcyk7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gdHJlZS5nZW5lcmF0ZUFsbFBhdGhzKCk7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gdGhpcy5nZXRTb3J0ZWRHcm91cHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZ3JvdXBpbmcgdHJlZSB0aGF0IGdyb3VwcyB0aGUgcGFzc2VkIEB0YXNrcyBieSB0aGUgcGFzc2VkIEBncm91cGluZ3MuXG4gICAgICovXG4gICAgcHJpdmF0ZSBidWlsZEdyb3VwaW5nVHJlZShncm91cGluZ3M6IEdyb3VwZXJbXSwgdGFza3M6IFRhc2tbXSk6IFRhc2tHcm91cGluZ1RyZWVOb2RlIHtcbiAgICAgICAgLy8gVGhlIHRyZWUgaXMgYnVpbGQgbGF5ZXIgYnkgbGF5ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICAgIC8vIEF0IGV2ZXJ5IGxldmVsLCB3ZSBpdGVyYXRlIG9uIHRoZSBub2RlcyBvZiB0aGF0IGxldmVsIHRvIGdlbmVyYXRlXG4gICAgICAgIC8vIHRoZSBuZXh0IG9uZSB1c2luZyB0aGUgbmV4dCBncm91cGluZy5cblxuICAgICAgICAvLyBUaGUgcm9vdCBvZiB0aGUgdHJlZSBjb250YWlucyBhbGwgdGhlIHRhc2tzLlxuICAgICAgICBjb25zdCByb290ID0gbmV3IFRhc2tHcm91cGluZ1RyZWVOb2RlKHRhc2tzKTtcblxuICAgICAgICBsZXQgY3VycmVudFRyZWVMZXZlbCA9IFtyb290XTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cGluZyBvZiBncm91cGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlTGV2ZWwgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudFRyZWVOb2RlIG9mIGN1cnJlbnRUcmVlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgY3VycmVudFRyZWVOb2RlLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncm91cE5hbWVzID0gR3JvdXAuZ2V0R3JvdXBOYW1lc0ZvclRhc2soZ3JvdXBpbmcsIHRhc2spO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdyb3VwTmFtZSBvZiBncm91cE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBjdXJyZW50VHJlZU5vZGUuY2hpbGRyZW4uZ2V0KGdyb3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbmV3IFRhc2tHcm91cGluZ1RyZWVOb2RlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZU5vZGUuY2hpbGRyZW4uc2V0KGdyb3VwTmFtZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUcmVlTGV2ZWwucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC52YWx1ZXMucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRUcmVlTGV2ZWwgPSBuZXh0VHJlZUxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTb3J0ZWRHcm91cHMoKSB7XG4gICAgICAgIC8vIGdyb3Vwcy5rZXlzKCkgd2lsbCBpbml0aWFsbHkgYmUgaW4gdGhlIG9yZGVyIHRoZSBlbnRyaWVzIHdlcmUgYWRkZWQsXG4gICAgICAgIC8vIHNvIGVmZmVjdGl2ZWx5IHJhbmRvbS5cbiAgICAgICAgLy8gUmV0dXJuIGEgZHVwbGljYXRlIG1hcCwgd2l0aCB0aGUga2V5cyAodGhhdCBpcywgZ3JvdXAgbmFtZXMpIHNvcnRlZCBpbiBhbHBoYWJldGljYWwgb3JkZXI6XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJtZWRpYXRlVGFza0dyb3Vwc1N0b3JhZ2UoWy4uLnRoaXMuZ3JvdXBzLmVudHJpZXMoKV0uc29ydCgpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwSGVhZGluZyB9IGZyb20gJy4vR3JvdXBIZWFkaW5nJztcblxuLyoqXG4gKiBUYXNrR3JvdXAgc3RvcmVzIGEgc2luZ2xlIGdyb3VwIG9mIHRhc2tzLCB0aGF0IGFsbCBzaGFyZSB0aGUgc2FtZSBncm91cCBuYW1lcy5cbiAqIFRhc2tHcm91cCBvYmplY3RzIGFyZSBzdG9yZWQgaW4gYSBUYXNrR3JvdXBzIG9iamVjdC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHVzZXIgc3VwcGxpZWQgdGhlc2UgJ2dyb3VwIGJ5JyBsaW5lczpcbiAqICAgZ3JvdXAgYnkgZm9sZGVyXG4gKiAgIGdyb3VwIGJ5IGZpbGVuYW1lXG4gKiAgIGdyb3VwIGJ5IGhlYWRpbmdcbiAqIFRoZW4gdGhlIG5hbWVzIG9mIG9uZSBUYXNrR3JvdXAgbWlnaHQgYmUgdGhpczpcbiAqICAgU29tZS9Gb2xkZXIvSW4vVGhlL1ZhdWx0XG4gKiAgIEEgUGFydGljdWxhciBGaWxlIE5hbWVcbiAqICAgTXkgbG92ZWx5IGhlYWRpbmdcbiAqIEFuZCB0aGUgVGFza0dyb3VwIHdvdWxkIHN0b3JlIGFsbCB0aGUgdGFza3MgZnJvbSB0aGF0IGxvY2F0aW9uXG4gKiB0aGF0IG1hdGNoIHRoZSB0YXNrIGJsb2NrJ3MgZmlsdGVycywgaW4gdGhlIHRhc2sgYmxvY2sncyBzb3J0IG9yZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrR3JvdXAge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lcyBvZiB0aGUgZ3JvdXAgcHJvcGVydGllcyBmb3IgdGhpcyBzZXQgb2YgdGFza3MsXG4gICAgICogaW4gdGhlIG9yZGVyIG9mIHRoZSAnZ3JvdXAgYnknIGxpbmVzIHRoZSB1c2VyIHNwZWNpZmllZFxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBncm91cHM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlYWRpbmdzIHRvIGJlIGRpc3BsYXllZCBpbiBmcm9udCBvZiB0aGlzIHNldCBvZiB0YXNrcyxcbiAgICAgKiB3aGVuIHJlbmRlcmluZyB0aGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEl0IG9ubHkgY29udGFpbnMgdGhlIG1pbmltYWwgc2V0IG9mIGhlYWRpbmdzIHJlcXVpcmVkIHRvIHNlcGFyYXRlXG4gICAgICogdGhpcyBncm91cCBvZiB0YXNrcyBmcm9tIHRoZSBwcmV2aW91cyBncm91cCBvZiB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIHdlcmUgbm8gJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbnMgaW4gdGhlIHRhc2tzIGNvZGUgYmxvY2ssXG4gICAgICogdGhpcyB3aWxsIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBncm91cEhlYWRpbmdzOiBHcm91cEhlYWRpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgdGFza3MgdGhhdCBtYXRjaCB0aGUgdXNlcidzIGZpbHRlcnMgYW5kIHRoYXQgaGF2ZSB0aGVcbiAgICAgKiBncm91cCBuYW1lcyBleGFjdGx5IG1hdGNoaW5nIGdyb3VwcygpLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSB0YXNrczogVGFza1tdO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFRhc2tHcm91cFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGdyb3VwcyAtIFNlZSB0aGlzLmdyb3VwcyBmb3IgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7R3JvdXBIZWFkaW5nW119IGdyb3VwSGVhZGluZ3MgLSBTZWUgdGhpcy5ncm91cEhlYWRpbmdzIGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHRhc2tzIHtUYXNrW119IC0gU2VlIHRoaXMudGFza3MgZm9yIGRldGFpbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihncm91cHM6IHN0cmluZ1tdLCBncm91cEhlYWRpbmdzOiBHcm91cEhlYWRpbmdbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcbiAgICAgICAgdGhpcy5ncm91cEhlYWRpbmdzID0gZ3JvdXBIZWFkaW5ncztcbiAgICAgICAgdGhpcy50YXNrcyA9IHRhc2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbWFya2Rvd24tZm9ybWF0IHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgdGFza3MgaW4gdGhpcyBncm91cC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBmb3IgdGVzdGluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdGFza3NBc1N0cmluZ09mTGluZXMoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGhpcy50YXNrcykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IHRhc2sudG9GaWxlTGluZVN0cmluZygpICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGFzayBncm91cCwgaW5jbHVkaW5nIG5hbWVzXG4gICAgICogYW5kIGhlYWRpbmdzIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGlzIHVzZWQgaW4gc25hcHNob3QgdGVzdGluZywgc28gaWYgdGhlIGZvcm1hdCBpc1xuICAgICAqIGNoYW5nZWQsIHRoZSBzbmFwc2hvdHMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBvdXRwdXQgPSAnXFxuJztcbiAgICAgICAgb3V0cHV0ICs9IGBHcm91cCBuYW1lczogWyR7dGhpcy5ncm91cHN9XVxcbmA7XG5cbiAgICAgICAgZm9yIChjb25zdCBoZWFkaW5nIG9mIHRoaXMuZ3JvdXBIZWFkaW5ncykge1xuICAgICAgICAgICAgLy8gVGhlc2UgaGVhZGluZ3MgbWltaWMgdGhlIGJlaGF2aW91ciBvZiBRdWVyeVJlbmRlcmVyLFxuICAgICAgICAgICAgLy8gd2hpY2ggdXNlcyAnaDQnLCAnaDUnIGFuZCAnaDYnIGZvciBuZXN0ZWQgZ3JvdXBzLlxuICAgICAgICAgICAgY29uc3QgaGVhZGluZ1ByZWZpeCA9ICcjJy5yZXBlYXQoNCArIGhlYWRpbmcubmVzdGluZ0xldmVsKTtcbiAgICAgICAgICAgIG91dHB1dCArPSBgJHtoZWFkaW5nUHJlZml4fSAke2hlYWRpbmcubmFtZX1cXG5gO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IHRoaXMudGFza3NBc1N0cmluZ09mTGluZXMoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXIgfSBmcm9tICcuL0dyb3VwZXInO1xuaW1wb3J0IHsgR3JvdXBIZWFkaW5ncyB9IGZyb20gJy4vR3JvdXBIZWFkaW5ncyc7XG5pbXBvcnQgeyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzIH0gZnJvbSAnLi9JbnRlcm1lZGlhdGVUYXNrR3JvdXBzJztcbmltcG9ydCB7IFRhc2tHcm91cCB9IGZyb20gJy4vVGFza0dyb3VwJztcblxuLyoqXG4gKiBUYXNrR3JvdXAgc3RvcmVzIGFsbCB0aGUgZ3JvdXBzIG9mIHRhc2tzIGdlbmVyYXRlZCBieSBhbnkgJ2dyb3VwIGJ5J1xuICogaW5zdHJ1Y3Rpb25zIGluIHRoZSB0YXNrIGJsb2NrLlxuICovXG5leHBvcnQgY2xhc3MgVGFza0dyb3VwcyB7XG4gICAgcHJpdmF0ZSBfZ3JvdXBzOiBUYXNrR3JvdXBbXSA9IG5ldyBBcnJheTxUYXNrR3JvdXA+KCk7XG4gICAgcHJpdmF0ZSBfdG90YWxUYXNrQ291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFRhc2tHcm91cHNcbiAgICAgKiBAcGFyYW0ge0dyb3VwZXJbXX0gZ3JvdXBzIC0gMCBvciBtb3JlIEdyb3VwaW5nIHZhbHVlcyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgcGVyICdncm91cCBieScgbGluZSBpbiB0aGUgdGFzayBxdWVyeSBibG9ja1xuICAgICAqIEBwYXJhbSB7VGFza1tdfSB0YXNrcyAtIDAgbW9yZSBtb3JlIFRhc2sgb2JqZWN0cywgd2l0aCBhbGwgdGhlIHRhc2tzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBhbHJlYWR5IGluIHNvcnQgb3JkZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihncm91cHM6IEdyb3VwZXJbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICAvLyBHcm91cGluZyBkb2Vzbid0IGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRhc2tzLCBhbmQgYWxsIHRoZSB0YXNrc1xuICAgICAgICAvLyB3aWxsIGJlIHNob3duIGluIGF0IGxlYXN0IG9uZSBncm91cC5cbiAgICAgICAgdGhpcy5fdG90YWxUYXNrQ291bnQgPSB0YXNrcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbEdyb3VwcyA9IG5ldyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzKGdyb3VwcywgdGFza3MpO1xuICAgICAgICB0aGlzLmFkZFRhc2tzKGluaXRpYWxHcm91cHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBncm91cGVkIHRvZ2V0aGVyLCBhbmQgaW4gdGhlIG9yZGVyXG4gICAgICogdGhhdCB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHMoKTogVGFza0dyb3VwW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LlxuICAgICAqL1xuICAgIHB1YmxpYyB0b3RhbFRhc2tzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRhc2tDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgdGFzayBncm91cHMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyB1c2VkIGluIHNuYXBzaG90IHRlc3RpbmcsIHNvIGlmIHRoZSBmb3JtYXQgaXNcbiAgICAgKiBjaGFuZ2VkLCB0aGUgc25hcHNob3RzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdGFza0dyb3VwIG9mIHRoaXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gdGFza0dyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbi0tLVxcbic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxUYXNrc0NvdW50ID0gdGhpcy50b3RhbFRhc2tzQ291bnQoKTtcbiAgICAgICAgb3V0cHV0ICs9IGBcXG4ke3RvdGFsVGFza3NDb3VudH0gdGFza3NcXG5gO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVGFza3MoaW5pdGlhbEdyb3VwczogSW50ZXJtZWRpYXRlVGFza0dyb3Vwcykge1xuICAgICAgICAvLyBHZXQgdGhlIGhlYWRpbmdzXG4gICAgICAgIGNvbnN0IGdyb3VwZXIgPSBuZXcgR3JvdXBIZWFkaW5ncyhpbml0aWFsR3JvdXBzLmdyb3Vwcyk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBjb250YWluZXIgb2YgYWxsIHRoZSBncm91cHNcbiAgICAgICAgZm9yIChjb25zdCBbZ3JvdXBzLCB0YXNrc10gb2YgaW5pdGlhbEdyb3Vwcy5ncm91cHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSGVhZGluZ3MgPSBncm91cGVyLmdldEhlYWRpbmdzRm9yVGFza0dyb3VwKGdyb3Vwcyk7XG4gICAgICAgICAgICBjb25zdCB0YXNrR3JvdXAgPSBuZXcgVGFza0dyb3VwKGdyb3VwcywgZ3JvdXBIZWFkaW5ncywgdGFza3MpO1xuICAgICAgICAgICAgdGhpcy5hZGQodGFza0dyb3VwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkKHRhc2tHcm91cDogVGFza0dyb3VwKSB7XG4gICAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKHRhc2tHcm91cCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IFRhc2tHcm91cHMgfSBmcm9tICcuL1Rhc2tHcm91cHMnO1xuaW1wb3J0IHsgSGFwcGVuc0RhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0hhcHBlbnNEYXRlRmllbGQnO1xuaW1wb3J0IHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiwgR3JvdXBpbmdQcm9wZXJ0eSB9IGZyb20gJy4vR3JvdXBlcic7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlICdncm91cCBieScgaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cCB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZ3JvdXBEYXRlRm9ybWF0ID0gJ1lZWVktTU0tREQgZGRkZCc7XG5cbiAgICBwdWJsaWMgc3RhdGljIGZyb21Hcm91cGluZ1Byb3BlcnR5KHByb3BlcnR5OiBHcm91cGluZ1Byb3BlcnR5KTogR3JvdXBlciB7XG4gICAgICAgIHJldHVybiBuZXcgR3JvdXBlcihwcm9wZXJ0eSwgR3JvdXAuZ3JvdXBlckZvclByb3BlcnR5KHByb3BlcnR5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYSBsaXN0IG9mIHRhc2tzLCBhY2NvcmRpbmcgdG8gb25lIG9yIG1vcmUgdGFzayBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIGdyb3VwaW5nIDAgb3IgbW9yZSBHcm91cGluZyB2YWx1ZXMsIG9uZSBwZXIgJ2dyb3VwIGJ5JyBsaW5lXG4gICAgICogQHBhcmFtIHRhc2tzIFRoZSB0YXNrcyB0aGF0IG1hdGNoIHRoZSB0YXNrIGJsb2NrJ3MgUXVlcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJ5KGdyb3VwaW5nOiBHcm91cGVyW10sIHRhc2tzOiBUYXNrW10pOiBUYXNrR3JvdXBzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrR3JvdXBzKGdyb3VwaW5nLCB0YXNrcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcm9wZXJ0aWVzIG9mIGEgc2luZ2xlIHRhc2sgZm9yIHRoZSBwYXNzZWQgZ3JvdXBpbmcgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBzdHJpbmcgd2lsbCBiZSByZW5kZXJlZCwgc28gYW55IHNwZWNpYWwgTWFya2Rvd24gY2hhcmFjdGVycyB3aWxsIGJlIGVzY2FwZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBncm91cGluZ1xuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRHcm91cE5hbWVzRm9yVGFzayhncm91cGluZzogR3JvdXBlciwgdGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwaW5nLmdyb3VwZXIodGFzayk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBncm91cGVyRm9yUHJvcGVydHkocHJvcGVydHk6IEdyb3VwaW5nUHJvcGVydHkpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gR3JvdXAuZ3JvdXBlcnNbcHJvcGVydHldO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwZXJzOiBSZWNvcmQ8R3JvdXBpbmdQcm9wZXJ0eSwgR3JvdXBlckZ1bmN0aW9uPiA9IHtcbiAgICAgICAgYmFja2xpbms6IEdyb3VwLmdyb3VwQnlCYWNrbGluayxcbiAgICAgICAgZG9uZTogR3JvdXAuZ3JvdXBCeURvbmVEYXRlLFxuICAgICAgICBkdWU6IEdyb3VwLmdyb3VwQnlEdWVEYXRlLFxuICAgICAgICBmaWxlbmFtZTogR3JvdXAuZ3JvdXBCeUZpbGVOYW1lLFxuICAgICAgICBmb2xkZXI6IEdyb3VwLmdyb3VwQnlGb2xkZXIsXG4gICAgICAgIGhhcHBlbnM6IEdyb3VwLmdyb3VwQnlIYXBwZW5zRGF0ZSxcbiAgICAgICAgaGVhZGluZzogR3JvdXAuZ3JvdXBCeUhlYWRpbmcsXG4gICAgICAgIHBhdGg6IEdyb3VwLmdyb3VwQnlQYXRoLFxuICAgICAgICBwcmlvcml0eTogR3JvdXAuZ3JvdXBCeVByaW9yaXR5LFxuICAgICAgICByZWN1cnJlbmNlOiBHcm91cC5ncm91cEJ5UmVjdXJyZW5jZSxcbiAgICAgICAgcmVjdXJyaW5nOiBHcm91cC5ncm91cEJ5UmVjdXJyaW5nLFxuICAgICAgICByb290OiBHcm91cC5ncm91cEJ5Um9vdCxcbiAgICAgICAgc2NoZWR1bGVkOiBHcm91cC5ncm91cEJ5U2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgc3RhcnQ6IEdyb3VwLmdyb3VwQnlTdGFydERhdGUsXG4gICAgICAgIHN0YXR1czogR3JvdXAuZ3JvdXBCeVN0YXR1cyxcbiAgICAgICAgdGFnczogR3JvdXAuZ3JvdXBCeVRhZ3MsXG4gICAgfTtcblxuICAgIHByaXZhdGUgc3RhdGljIGVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyhmaWxlbmFtZTogc3RyaW5nKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd2lsc29ubWFyLmdpdGh1Yi5pby9tYXJrZG93bi10ZXh0LWZvci1naXRodWItZnJvbS1odG1sLyNzcGVjaWFsLWNoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXy9nLCAnXFxcXF8nKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cEJ5UHJpb3JpdHkodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgbGV0IHByaW9yaXR5TmFtZSA9ICdFUlJPUic7XG4gICAgICAgIHN3aXRjaCAodGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5IaWdoOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdIaWdoJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuTWVkaXVtOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdNZWRpdW0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5Ob25lOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdOb25lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuTG93OlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdMb3cnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYFByaW9yaXR5ICR7dGFzay5wcmlvcml0eX06ICR7cHJpb3JpdHlOYW1lfWBdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlSZWN1cnJlbmNlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFzay5yZWN1cnJlbmNlIS50b1RleHQoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWydOb25lJ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cEJ5UmVjdXJyaW5nKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ1JlY3VycmluZyddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsnTm90IFJlY3VycmluZyddO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeVN0YXJ0RGF0ZSh0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gW0dyb3VwLnN0cmluZ0Zyb21EYXRlKHRhc2suc3RhcnREYXRlLCAnc3RhcnQnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeVNjaGVkdWxlZERhdGUodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtHcm91cC5zdHJpbmdGcm9tRGF0ZSh0YXNrLnNjaGVkdWxlZERhdGUsICdzY2hlZHVsZWQnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUR1ZURhdGUodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtHcm91cC5zdHJpbmdGcm9tRGF0ZSh0YXNrLmR1ZURhdGUsICdkdWUnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeURvbmVEYXRlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbR3JvdXAuc3RyaW5nRnJvbURhdGUodGFzay5kb25lRGF0ZSwgJ2RvbmUnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUhhcHBlbnNEYXRlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0RGF0ZUlmQW55ID0gbmV3IEhhcHBlbnNEYXRlRmllbGQoKS5lYXJsaWVzdERhdGUodGFzayk7XG4gICAgICAgIHJldHVybiBbR3JvdXAuc3RyaW5nRnJvbURhdGUoZWFybGllc3REYXRlSWZBbnksICdoYXBwZW5zJyldO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHN0cmluZ0Zyb21EYXRlKGRhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsLCBmaWVsZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnTm8gJyArIGZpZWxkICsgJyBkYXRlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoR3JvdXAuZ3JvdXBEYXRlRm9ybWF0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cEJ5UGF0aCh0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICAvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBtYWRlIHN0cmljdGVyP1xuICAgICAgICAvLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgb2YgZ2V0dGluZyB0aGUgZmlsZSBuYW1lP1xuICAgICAgICByZXR1cm4gW0dyb3VwLmVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyh0YXNrLnBhdGgucmVwbGFjZSgnLm1kJywgJycpKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUZvbGRlcih0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBwYXRoID0gdGFzay5wYXRoO1xuICAgICAgICBjb25zdCBmaWxlTmFtZVdpdGhFeHRlbnNpb24gPSB0YXNrLmZpbGVuYW1lICsgJy5tZCc7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGFzdEluZGV4T2YoZmlsZU5hbWVXaXRoRXh0ZW5zaW9uKSk7XG4gICAgICAgIGlmIChmb2xkZXIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWycvJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtHcm91cC5lc2NhcGVNYXJrZG93bkNoYXJhY3RlcnMoZm9sZGVyKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUZpbGVOYW1lKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIC8vIE5vdGUgY3VycmVudCBsaW1pdGF0aW9uOiBUYXNrcyBmcm9tIGRpZmZlcmVudCBub3RlcyB3aXRoIHRoZVxuICAgICAgICAvLyBzYW1lIG5hbWUgd2lsbCBiZSBncm91cGVkIHRvZ2V0aGVyLCBldmVuIHRob3VnaCB0aGV5IGFyZSBpblxuICAgICAgICAvLyBkaWZmZXJlbnQgZmlsZXMgYW5kIHRoZWlyIGxpbmtzIHdpbGwgbG9vayBkaWZmZXJlbnQuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGFzay5maWxlbmFtZTtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gWydVbmtub3duIExvY2F0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnW1snICsgR3JvdXAuZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKGZpbGVuYW1lKSArICddXSddO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlSb290KHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0YXNrLnBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IHBhdGguaW5kZXhPZignLycpO1xuICAgICAgICBpZiAoc2VwYXJhdG9ySW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbJy8nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW0dyb3VwLmVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyhwYXRoLnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCArIDEpKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUJhY2tsaW5rKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGxpbmtUZXh0ID0gdGFzay5nZXRMaW5rVGV4dCh7IGlzRmlsZW5hbWVVbmlxdWU6IHRydWUgfSk7XG4gICAgICAgIGlmIChsaW5rVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnVW5rbm93biBMb2NhdGlvbiddO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbGVuYW1lQ29tcG9uZW50ID0gJ1Vua25vd24gTG9jYXRpb24nO1xuXG4gICAgICAgIGlmICh0YXNrLmZpbGVuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBNYXJrZG93biBjaGFyYWN0ZXJzIGluIHRoZSBmaWxlIG5hbWUgbXVzdCBiZSBlc2NhcGVkLlxuICAgICAgICAgICAgZmlsZW5hbWVDb21wb25lbnQgPSBHcm91cC5lc2NhcGVNYXJrZG93bkNoYXJhY3RlcnModGFzay5maWxlbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzay5wcmVjZWRpbmdIZWFkZXIgPT09IG51bGwgfHwgdGFzay5wcmVjZWRpbmdIZWFkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZpbGVuYW1lQ29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcmtkb3duIGNoYXJhY3RlcnMgaW4gdGhlIGhlYWRpbmcgbXVzdCBOT1QgYmUgZXNjYXBlZC5cbiAgICAgICAgY29uc3QgaGVhZGluZ0NvbXBvbmVudCA9IEdyb3VwLmdyb3VwQnlIZWFkaW5nKHRhc2spWzBdO1xuXG4gICAgICAgIGlmIChmaWxlbmFtZUNvbXBvbmVudCA9PT0gaGVhZGluZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtmaWxlbmFtZUNvbXBvbmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW2Ake2ZpbGVuYW1lQ29tcG9uZW50fSA+ICR7aGVhZGluZ0NvbXBvbmVudH1gXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlTdGF0dXModGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgbm90ZTogSW4gVGFza3MgMS4yMi4wIGFuZCBlYXJsaWVyLCB0aGUgb25seVxuICAgICAgICAvLyBuYW1lcyB1c2VkIGJ5ICdncm91cCBieSBzdGF0dXMnIHdlcmUgJ1RvZG8nIGFuZCAnRG9uZScgLSBhbmRcbiAgICAgICAgLy8gYW55IGNoYXJhY3RlciBvdGhlciB0aGFuIGEgc3BhY2Ugd2FzIGNvbnNpZGVyZWQgdG8gYmUgJ0RvbmUnLlxuICAgICAgICBpZiAodGFzay5zdGF0dXMuc3ltYm9sID09PSAnICcpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ1RvZG8nXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbJ0RvbmUnXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlIZWFkaW5nKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnByZWNlZGluZ0hlYWRlciA9PT0gbnVsbCB8fCB0YXNrLnByZWNlZGluZ0hlYWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbJyhObyBoZWFkaW5nKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFzay5wcmVjZWRpbmdIZWFkZXJdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlUYWdzKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbJyhObyB0YWdzKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrLnRhZ3M7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IExheW91dE9wdGlvbnMgfSBmcm9tICcuLi9UYXNrTGF5b3V0JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBJUXVlcnkgfSBmcm9tICcuLi9JUXVlcnknO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vU29ydCc7XG5pbXBvcnQgdHlwZSB7IFNvcnRlciB9IGZyb20gJy4vU29ydGVyJztcbmltcG9ydCB0eXBlIHsgVGFza0dyb3VwcyB9IGZyb20gJy4vVGFza0dyb3Vwcyc7XG5pbXBvcnQgKiBhcyBGaWx0ZXJQYXJzZXIgZnJvbSAnLi9GaWx0ZXJQYXJzZXInO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuL0dyb3VwJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwaW5nUHJvcGVydHkgfSBmcm9tICcuL0dyb3VwZXInO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlci9GaWx0ZXInO1xuXG5leHBvcnQgY2xhc3MgUXVlcnkgaW1wbGVtZW50cyBJUXVlcnkge1xuICAgIHB1YmxpYyBzb3VyY2U6IHN0cmluZztcblxuICAgIHByaXZhdGUgX2xpbWl0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfbGF5b3V0T3B0aW9uczogTGF5b3V0T3B0aW9ucyA9IG5ldyBMYXlvdXRPcHRpb25zKCk7XG4gICAgcHJpdmF0ZSBfZmlsdGVyczogRmlsdGVyW10gPSBbXTtcbiAgICBwcml2YXRlIF9lcnJvcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX3NvcnRpbmc6IFNvcnRlcltdID0gW107XG4gICAgcHJpdmF0ZSBfZ3JvdXBpbmc6IEdyb3VwZXJbXSA9IFtdO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBncm91cEJ5UmVnZXhwID1cbiAgICAgICAgL15ncm91cCBieSAoYmFja2xpbmt8ZG9uZXxkdWV8ZmlsZW5hbWV8Zm9sZGVyfGhhcHBlbnN8aGVhZGluZ3xwYXRofHByaW9yaXR5fHJlY3VycmVuY2V8cmVjdXJyaW5nfHJvb3R8c2NoZWR1bGVkfHN0YXJ0fHN0YXR1c3x0YWdzKS87XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGhpZGVPcHRpb25zUmVnZXhwID1cbiAgICAgICAgL14oaGlkZXxzaG93KSAodGFzayBjb3VudHxiYWNrbGlua3xwcmlvcml0eXxzdGFydCBkYXRlfHNjaGVkdWxlZCBkYXRlfGRvbmUgZGF0ZXxkdWUgZGF0ZXxyZWN1cnJlbmNlIHJ1bGV8ZWRpdCBidXR0b258dXJnZW5jeSkvO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hvcnRNb2RlUmVnZXhwID0gL15zaG9ydC87XG4gICAgcHJpdmF0ZSByZWFkb25seSBleHBsYWluUXVlcnlSZWdleHAgPSAvXmV4cGxhaW4vO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBsaW1pdFJlZ2V4cCA9IC9ebGltaXQgKHRvICk/KFxcZCspKCB0YXNrcz8pPy87XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbW1lbnRSZWdleHAgPSAvXiMuKi87XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHNvdXJjZSB9OiB7IHNvdXJjZTogc3RyaW5nIH0pIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLm1hcCgobGluZTogc3RyaW5nKSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChsaW5lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsaW5lID09PSAnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuc2hvcnRNb2RlUmVnZXhwLnRlc3QobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLnNob3J0TW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmV4cGxhaW5RdWVyeVJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5leHBsYWluUXVlcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5saW1pdFJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUxpbWl0KHsgbGluZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMucGFyc2VTb3J0QnkoeyBsaW5lIH0pOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZUdyb3VwQnkyKHsgbGluZSB9KTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZ3JvdXBCeVJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUdyb3VwQnkoeyBsaW5lIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5oaWRlT3B0aW9uc1JlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUhpZGVPcHRpb25zKHsgbGluZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuY29tbWVudFJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudCBsaW5lcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZUZpbHRlcihsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBgZG8gbm90IHVuZGVyc3RhbmQgcXVlcnk6ICR7bGluZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYWluUXVlcnkoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdFeHBsYW5hdGlvbiBvZiB0aGlzIFRhc2tzIGNvZGUgYmxvY2sgcXVlcnk6XFxuXFxuJyArIHRoaXMuZXhwbGFpblF1ZXJ5V2l0aG91dEludHJvZHVjdGlvbigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYWluUXVlcnlXaXRob3V0SW50cm9kdWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgICAgICBjb25zdCB7IGdsb2JhbEZpbHRlciB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKGdsb2JhbEZpbHRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgT25seSB0YXNrcyBjb250YWluaW5nIHRoZSBnbG9iYWwgZmlsdGVyICcke2dsb2JhbEZpbHRlcn0nLlxcblxcbmA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBudW1iZXJPZkZpbHRlcnMgPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtYmVyT2ZGaWx0ZXJzID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ05vIGZpbHRlcnMgc3VwcGxpZWQuIEFsbCB0YXNrcyB3aWxsIG1hdGNoIHRoZSBxdWVyeS4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkZpbHRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbHRlcnNbaV0uZXhwbGFpbkZpbHRlckluZGVudGVkKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFxcblxcbkF0IG1vc3QgJHt0aGlzLl9saW1pdH0gdGFza2A7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGltaXQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcuXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBsaW1pdCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBsYXlvdXRPcHRpb25zKCk6IExheW91dE9wdGlvbnMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0T3B0aW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpbHRlcnMoKTogRmlsdGVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHNvcnRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0aW5nO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ3JvdXBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGVycm9yKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXBwbHlRdWVyeVRvVGFza3ModGFza3M6IFRhc2tbXSk6IFRhc2tHcm91cHMge1xuICAgICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICB0YXNrcyA9IHRhc2tzLmZpbHRlcihmaWx0ZXIuZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0YXNrc1NvcnRlZExpbWl0ZWQgPSBTb3J0LmJ5KHRoaXMuc29ydGluZywgdGFza3MpLnNsaWNlKDAsIHRoaXMubGltaXQpO1xuICAgICAgICByZXR1cm4gR3JvdXAuYnkodGhpcy5ncm91cGluZywgdGFza3NTb3J0ZWRMaW1pdGVkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlSGlkZU9wdGlvbnMoeyBsaW5lIH06IHsgbGluZTogc3RyaW5nIH0pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaGlkZU9wdGlvbnNNYXRjaCA9IGxpbmUubWF0Y2godGhpcy5oaWRlT3B0aW9uc1JlZ2V4cCk7XG4gICAgICAgIGlmIChoaWRlT3B0aW9uc01hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBoaWRlID0gaGlkZU9wdGlvbnNNYXRjaFsxXSA9PT0gJ2hpZGUnO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gaGlkZU9wdGlvbnNNYXRjaFsyXTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YXNrIGNvdW50JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlVGFza0NvdW50ID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmFja2xpbmsnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVCYWNrbGlua3MgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwcmlvcml0eSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVByaW9yaXR5ID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVN0YXJ0RGF0ZSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NjaGVkdWxlZCBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlU2NoZWR1bGVkRGF0ZSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2R1ZSBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlRHVlRGF0ZSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvbmUgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZURvbmVEYXRlID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVjdXJyZW5jZSBydWxlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlUmVjdXJyZW5jZVJ1bGUgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0IGJ1dHRvbic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZUVkaXRCdXR0b24gPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1cmdlbmN5JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlVXJnZW5jeSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIGhpZGUvc2hvdyBvcHRpb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUZpbHRlcihsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyT3JFcnJvciA9IEZpbHRlclBhcnNlci5wYXJzZUZpbHRlcihsaW5lKTtcbiAgICAgICAgaWYgKGZpbHRlck9yRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGZpbHRlck9yRXJyb3IuZmlsdGVyKSB0aGlzLl9maWx0ZXJzLnB1c2goZmlsdGVyT3JFcnJvci5maWx0ZXIpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9lcnJvciA9IGZpbHRlck9yRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUxpbWl0KHsgbGluZSB9OiB7IGxpbmU6IHN0cmluZyB9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF0Y2ggPSBsaW5lLm1hdGNoKHRoaXMubGltaXRSZWdleHApO1xuICAgICAgICBpZiAobGltaXRNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbGltaXRNYXRjaFsyXSBpcyBwZXIgcmVnZXggYWx3YXlzIGRpZ2l0cyBhbmQgdGhlcmVmb3JlIHBhcnNhYmxlLlxuICAgICAgICAgICAgdGhpcy5fbGltaXQgPSBOdW1iZXIucGFyc2VJbnQobGltaXRNYXRjaFsyXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgbGltaXQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZVNvcnRCeSh7IGxpbmUgfTogeyBsaW5lOiBzdHJpbmcgfSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzb3J0aW5nTWF5YmUgPSBGaWx0ZXJQYXJzZXIucGFyc2VTb3J0ZXIobGluZSk7XG4gICAgICAgIGlmIChzb3J0aW5nTWF5YmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRpbmcucHVzaChzb3J0aW5nTWF5YmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9sZC1zdHlsZSBwYXJzaW5nIG9mIGBncm91cCBieWAgbGluZXMsIGZvciBncm91cGluZyB0aGF0IGlzIGltcGxlbWVudGVkIHdpdGggc3RhdGljXG4gICAgICogbWV0aG9kcyBpbiB7QGxpbmsgR3JvdXB9LCB0aGF0IGFyZSBsb29rZWQgdXAgZnJvbSBhIHtAbGluayBHcm91cGluZ1Byb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIFRoZXNlIHdpbGwgYmUgZ3JhZHVhbGx5IG1pZ3JhdGVkIHRvIHRoZSBncm91cGluZyBtZXRob2QgaW4ge0BsaW5rIEZpZWxkfVxuICAgICAqIGNsYXNzZXMsIGFmdGVyIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHBhcnNlR3JvdXBCeTJcbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlR3JvdXBCeSh7IGxpbmUgfTogeyBsaW5lOiBzdHJpbmcgfSk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaWVsZE1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmdyb3VwQnlSZWdleHApO1xuICAgICAgICBpZiAoZmllbGRNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBpbmcucHVzaChHcm91cC5mcm9tR3JvdXBpbmdQcm9wZXJ0eShmaWVsZE1hdGNoWzFdIGFzIEdyb3VwaW5nUHJvcGVydHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGdyb3VwaW5nJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5ldy1zdHlsZSBwYXJzaW5nIG9mIGBncm91cCBieWAgbGluZXMsIGZvciBncm91cGluZyB0aGF0IGlzIGltcGxlbWVudGVkIGluIHRoZSB7QGxpbmsgRmllbGR9XG4gICAgICogY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIE9uY2UgdGhlIG9yaWdpbmFsIHtAbGluayBwYXJzZUdyb3VwQnl9IGhhcyBiZWVuIHJlbW92ZWQsIHJlbmFtZSB0aGlzIHRvIHBhcnNlR3JvdXBCeSgpXG4gICAgICogQHBhcmFtIGxpbmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgcGFyc2VHcm91cEJ5XG4gICAgICovXG4gICAgcHJpdmF0ZSBwYXJzZUdyb3VwQnkyKHsgbGluZSB9OiB7IGxpbmU6IHN0cmluZyB9KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nTWF5YmUgPSBGaWx0ZXJQYXJzZXIucGFyc2VHcm91cGVyKGxpbmUpO1xuICAgICAgICBpZiAoZ3JvdXBpbmdNYXliZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBpbmcucHVzaChncm91cGluZ01heWJlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBkZWJvdW5jZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFN0YXR1c0NvbmZpZ3VyYXRpb24sIFN0YXR1c1R5cGUgfSBmcm9tICcuLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB0eXBlIFRhc2tzUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuLi9TdGF0dXNSZWdpc3RyeSc7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXMnO1xuaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vU3RhdHVzQ29sbGVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IEhlYWRpbmdTdGF0ZSB9IGZyb20gJy4vU2V0dGluZ3MnO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIGlzRmVhdHVyZUVuYWJsZWQsIHVwZGF0ZUdlbmVyYWxTZXR0aW5nLCB1cGRhdGVTZXR0aW5ncyB9IGZyb20gJy4vU2V0dGluZ3MnO1xuaW1wb3J0IHsgU3RhdHVzU2V0dGluZ3MgfSBmcm9tICcuL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCBzZXR0aW5nc0pzb24gZnJvbSAnLi9zZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbic7XG5cbmltcG9ydCB7IEN1c3RvbVN0YXR1c01vZGFsIH0gZnJvbSAnLi9DdXN0b21TdGF0dXNNb2RhbCc7XG5pbXBvcnQgeyBtaW5pbWFsU3VwcG9ydGVkU3RhdHVzZXMgfSBmcm9tICcuL1RoZW1lcyc7XG5pbXBvcnQgeyBpdHNTdXBwb3J0ZWRTdGF0dXNlcyB9IGZyb20gJy4vVGhlbWVzJztcblxuZXhwb3J0IGNsYXNzIFNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgLy8gSWYgdGhlIFVJIG5lZWRzIGEgbW9yZSBjb21wbGV4IHNldHRpbmcgeW91IGNhbiBjcmVhdGUgYVxuICAgIC8vIGN1c3RvbSBmdW5jdGlvbiBhbmQgc3BlY2lmeSBpdCBmcm9tIHRoZSBqc29uIGZpbGUuIEl0IHdpbGxcbiAgICAvLyB0aGVuIGJlIHJlbmRlcmVkIGluc3RlYWQgb2YgYSBub3JtYWwgY2hlY2tib3ggb3IgdGV4dCBib3guXG4gICAgY3VzdG9tRnVuY3Rpb25zOiB7IFtLOiBzdHJpbmddOiBGdW5jdGlvbiB9ID0ge1xuICAgICAgICBpbnNlcnRUYXNrQ29yZVN0YXR1c1NldHRpbmdzOiB0aGlzLmluc2VydFRhc2tDb3JlU3RhdHVzU2V0dGluZ3MuYmluZCh0aGlzKSxcbiAgICAgICAgaW5zZXJ0Q3VzdG9tVGFza1N0YXR1c1NldHRpbmdzOiB0aGlzLmluc2VydEN1c3RvbVRhc2tTdGF0dXNTZXR0aW5ncy5iaW5kKHRoaXMpLFxuICAgIH07XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHBsdWdpbjogVGFza3NQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiB9OiB7IHBsdWdpbjogVGFza3NQbHVnaW4gfSkge1xuICAgICAgICBzdXBlcihwbHVnaW4uYXBwLCBwbHVnaW4pO1xuXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUZyYWdtZW50V2l0aEhUTUwgPSAoaHRtbDogc3RyaW5nKSA9PlxuICAgICAgICBjcmVhdGVGcmFnbWVudCgoZG9jdW1lbnRGcmFnbWVudCkgPT4gKGRvY3VtZW50RnJhZ21lbnQuY3JlYXRlRGl2KCkuaW5uZXJIVE1MID0gaHRtbCkpO1xuXG4gICAgcHVibGljIGFzeW5jIHNhdmVTZXR0aW5ncyh1cGRhdGU/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5hZGRDbGFzcygndGFza3Mtc2V0dGluZ3MnKTtcblxuICAgICAgICAvLyBGb3IgcmVhc29ucyBJIGRvbid0IHVuZGVyc3RhbmQsICdoMicgaXMgdGlueSBpbiBTZXR0aW5ncyxcbiAgICAgICAgLy8gc28gSSBoYXZlIHVzZWQgJ2gzJyBhcyB0aGUgbGFyZ2VzdCBoZWFkaW5nLlxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdUYXNrcyBTZXR0aW5ncycgfSk7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgY2xzOiAndGFza3Mtc2V0dGluZy1pbXBvcnRhbnQnLFxuICAgICAgICAgICAgdGV4dDogJ0NoYW5naW5nIGFueSBzZXR0aW5ncyByZXF1aXJlcyBhIHJlc3RhcnQgb2Ygb2JzaWRpYW4uJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0dsb2JhbCBmaWx0ZXIgU2V0dGluZ3MnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdHbG9iYWwgdGFzayBmaWx0ZXInKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgJzxwPjxiPlJlY29tbWVuZGVkOiBMZWF2ZSBlbXB0eSBpZiB5b3Ugd2FudCBhbGwgY2hlY2tsaXN0IGl0ZW1zIGluIHlvdXIgdmF1bHQgdG8gYmUgdGFza3MgbWFuYWdlZCBieSB0aGlzIHBsdWdpbi48L2I+PC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlVzZSBhIGdsb2JhbCBmaWx0ZXIgaWYgeW91IHdhbnQgVGFza3MgdG8gb25seSBhY3Qgb24gYSBzdWJzZXQgb2YgeW91ciBcIjxjb2RlPi0gWyBdPC9jb2RlPlwiIGNoZWNrbGlzdCBpdGVtcywgc28gdGhhdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhIGNoZWNrbGlzdCBpdGVtIG11c3QgaW5jbHVkZSB0aGUgc3BlY2lmaWVkIHN0cmluZyBpbiBpdHMgZGVzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBhIHRhc2suPHA+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+Rm9yIGV4YW1wbGUsIGlmIHlvdSBzZXQgdGhlIGdsb2JhbCBmaWx0ZXIgdG8gPGNvZGU+I3Rhc2s8L2NvZGU+LCB0aGUgVGFza3MgcGx1Z2luIHdpbGwgb25seSBoYW5kbGUgY2hlY2tsaXN0IGl0ZW1zIHRhZ2dlZCB3aXRoIDxjb2RlPiN0YXNrPC9jb2RlPi48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ090aGVyIGNoZWNrbGlzdCBpdGVtcyB3aWxsIHJlbWFpbiBub3JtYWwgY2hlY2tsaXN0IGl0ZW1zIGFuZCBub3QgYXBwZWFyIGluIHF1ZXJpZXMgb3IgZ2V0IGEgZG9uZSBkYXRlIHNldC48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9vYnNpZGlhbi10YXNrcy1ncm91cC5naXRodWIuaW8vb2JzaWRpYW4tdGFza3MvZ2V0dGluZy1zdGFydGVkL2dsb2JhbC1maWx0ZXIvXCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgLy8gSSB3YW50ZWQgdG8gbWFrZSB0aGlzIHNheSAnZm9yIGV4YW1wbGUsICN0YXNrIG9yIFRPRE8nXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdhc24ndCBhYmxlIHRvIGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgdGhlIHRleHQgYm94XG4gICAgICAgICAgICAgICAgLy8gd2lkZSBlbm91Z2ggZm9yIHRoZSB3aG9sZSBzdHJpbmcgdG8gYmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdlLmcuICN0YXNrIG9yIFRPRE8nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuZ2xvYmFsRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGdsb2JhbEZpbHRlcjogdmFsdWUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JlbW92ZSBnbG9iYWwgZmlsdGVyIGZyb20gZGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0VuYWJsaW5nIHRoaXMgcmVtb3ZlcyB0aGUgc3RyaW5nIHRoYXQgeW91IHNldCBhcyBnbG9iYWwgZmlsdGVyIGZyb20gdGhlIHRhc2sgZGVzY3JpcHRpb24gd2hlbiBkaXNwbGF5aW5nIGEgdGFzay4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnJlbW92ZUdsb2JhbEZpbHRlcikub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgcmVtb3ZlR2xvYmFsRmlsdGVyOiB2YWx1ZSB9KTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdUYXNrIFN0YXR1c2VzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgeyBoZWFkaW5nT3BlbmVkIH0gPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgIHNldHRpbmdzSnNvbi5mb3JFYWNoKChoZWFkaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9uZVNldHRpbmdzQmxvY2soY29udGFpbmVyRWwsIGhlYWRpbmcsIGhlYWRpbmdPcGVuZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnRGF0ZSBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NldCBkb25lIGRhdGUgb24gZXZlcnkgY29tcGxldGVkIHRhc2snKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VuYWJsaW5nIHRoaXMgd2lsbCBhZGQgYSB0aW1lc3RhbXAgXHUyNzA1IFlZWVktTU0tREQgYXQgdGhlIGVuZCB3aGVuIGEgdGFzayBpcyB0b2dnbGVkIHRvIGRvbmUnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5zZXREb25lRGF0ZSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgc2V0RG9uZURhdGU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1VzZSBmaWxlbmFtZSBhcyBTY2hlZHVsZWQgZGF0ZSBmb3IgdW5kYXRlZCB0YXNrcycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSB0aW1lIGVudGVyaW5nIFNjaGVkdWxlZCAoXHUyM0YzKSBkYXRlcy48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0lmIHRoaXMgb3B0aW9uIGlzIGVuYWJsZWQsIGFueSB1bmRhdGVkIHRhc2tzIHdpbGwgYmUgZ2l2ZW4gYSBkZWZhdWx0IFNjaGVkdWxlZCBkYXRlIGV4dHJhY3RlZCBmcm9tIHRoZWlyIGZpbGUgbmFtZS48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBkYXRlIGluIHRoZSBmaWxlIG5hbWUgbXVzdCBiZSBpbiBvbmUgb2YgPGNvZGU+WVlZWS1NTS1ERDwvY29kZT4gb3IgPGNvZGU+WVlZWU1NREQ8L2NvZGU+IGZvcm1hdHMuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVbmRhdGVkIHRhc2tzIGhhdmUgbm9uZSBvZiBEdWUgKFx1RDgzRFx1RENDNSApLCBTY2hlZHVsZWQgKFx1MjNGMykgYW5kIFN0YXJ0IChcdUQ4M0RcdURFRUIpIGRhdGVzLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9vYnNpZGlhbi10YXNrcy1ncm91cC5naXRodWIuaW8vb2JzaWRpYW4tdGFza3MvZ2V0dGluZy1zdGFydGVkL3VzZS1maWxlbmFtZS1hcy1kZWZhdWx0LWRhdGUvXCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3MudXNlRmlsZW5hbWVBc1NjaGVkdWxlZERhdGUpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdGb2xkZXJzIHdpdGggZGVmYXVsdCBTY2hlZHVsZWQgZGF0ZXMnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0xlYXZlIGVtcHR5IGlmIHlvdSB3YW50IHRvIHVzZSBkZWZhdWx0IFNjaGVkdWxlZCBkYXRlcyBldmVyeXdoZXJlLCBvciBlbnRlciBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZvbGRlcnMuJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUZXh0KGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoU2V0dGluZ3NUYWIucmVuZGVyRm9sZGVyQXJyYXkoc2V0dGluZ3MuZmlsZW5hbWVBc0RhdGVGb2xkZXJzKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9sZGVycyA9IFNldHRpbmdzVGFiLnBhcnNlQ29tbWFTZXBhcmF0ZWRGb2xkZXJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgZmlsZW5hbWVBc0RhdGVGb2xkZXJzOiBmb2xkZXJzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0F1dG8tc3VnZ2VzdCBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tc3VnZ2VzdCB0YXNrIGNvbnRlbnQnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VuYWJsaW5nIHRoaXMgd2lsbCBvcGVuIGFuIGludGVsbGlnZW50IHN1Z2dlc3QgbWVudSB3aGlsZSB0eXBpbmcgaW5zaWRlIGEgcmVjb2duaXplZCB0YXNrIGxpbmUuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3MuYXV0b1N1Z2dlc3RJbkVkaXRvcikub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgYXV0b1N1Z2dlc3RJbkVkaXRvcjogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWluaW11bSBtYXRjaCBsZW5ndGggZm9yIGF1dG8tc3VnZ2VzdCcpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnSWYgaGlnaGVyIHRoYW4gMCwgYXV0by1zdWdnZXN0IHdpbGwgYmUgdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgYmVnaW5uaW5nIG9mIGFueSBzdXBwb3J0ZWQga2V5d29yZHMgaXMgcmVjb2duaXplZC4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDAsIDMsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5hdXRvU3VnZ2VzdE1pbk1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGF1dG9TdWdnZXN0TWluTWF0Y2g6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWF4aW11bSBudW1iZXIgb2YgYXV0by1zdWdnZXN0aW9ucyB0byBzaG93JylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdIb3cgbWFueSBzdWdnZXN0aW9ucyBzaG91bGQgYmUgc2hvd24gd2hlbiBhbiBhdXRvLXN1Z2dlc3QgbWVudSBwb3BzIHVwIChpbmNsdWRpbmcgdGhlIFwiXHUyM0NFXCIgb3B0aW9uKS4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDMsIDEyLCAxKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuYXV0b1N1Z2dlc3RNYXhJdGVtcylcbiAgICAgICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBhdXRvU3VnZ2VzdE1heEl0ZW1zOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdEaWFsb2cgU2V0dGluZ3MnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm92aWRlIGFjY2VzcyBrZXlzIGluIGRpYWxvZ3MnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0lmIHRoZSBhY2Nlc3Mga2V5cyAoa2V5Ym9hcmQgc2hvcnRjdXRzKSBmb3IgdmFyaW91cyBjb250cm9scycgK1xuICAgICAgICAgICAgICAgICAgICAnIGluIGRpYWxvZyBib3hlcyBjb25mbGljdCB3aXRoIHN5c3RlbSBrZXlib2FyZCBzaG9ydGN1dHMnICtcbiAgICAgICAgICAgICAgICAgICAgJyBvciBhc3Npc3RpdmUgdGVjaG5vbG9neSBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgaW1wb3J0YW50IGZvciB5b3UsJyArXG4gICAgICAgICAgICAgICAgICAgICcgeW91IG1heSB3YW50IHRvIGRlYWN0aXZhdGUgdGhlbSBoZXJlLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnByb3ZpZGVBY2Nlc3NLZXlzKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBwcm92aWRlQWNjZXNzS2V5czogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRPbmVTZXR0aW5nc0Jsb2NrKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgaGVhZGluZzogYW55LCBoZWFkaW5nT3BlbmVkOiBIZWFkaW5nU3RhdGUpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsc0NvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkZXRhaWxzJywge1xuICAgICAgICAgICAgY2xzOiAndGFza3MtbmVzdGVkLXNldHRpbmdzJyxcbiAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAuLi4oaGVhZGluZy5vcGVuIHx8IGhlYWRpbmdPcGVuZWRbaGVhZGluZy50ZXh0XSA/IHsgb3BlbjogdHJ1ZSB9IDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRldGFpbHNDb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgZGV0YWlsc0NvbnRhaW5lci5vbnRvZ2dsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGhlYWRpbmdPcGVuZWRbaGVhZGluZy50ZXh0XSA9IGRldGFpbHNDb250YWluZXIub3BlbjtcbiAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgaGVhZGluZ09wZW5lZDogaGVhZGluZ09wZW5lZCB9KTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdW1tYXJ5ID0gZGV0YWlsc0NvbnRhaW5lci5jcmVhdGVFbCgnc3VtbWFyeScpO1xuICAgICAgICBuZXcgU2V0dGluZyhzdW1tYXJ5KS5zZXRIZWFkaW5nKCkuc2V0TmFtZShoZWFkaW5nLnRleHQpO1xuICAgICAgICBzdW1tYXJ5LmNyZWF0ZURpdignY29sbGFwc2VyJykuY3JlYXRlRGl2KCdoYW5kbGUnKTtcblxuICAgICAgICAvLyBkZXRhaWxzQ29udGFpbmVyLmNyZWF0ZUVsKGhlYWRpbmcubGV2ZWwgYXMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwLCB7IHRleHQ6IGhlYWRpbmcudGV4dCB9KTtcblxuICAgICAgICBpZiAoaGVhZGluZy5ub3RpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGljZSA9IGRldGFpbHNDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbHM6IGhlYWRpbmcubm90aWNlLmNsYXNzLFxuICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRpbmcubm90aWNlLnRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoZWFkaW5nLm5vdGljZS5odG1sICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm90aWNlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaGVhZGluZy5ub3RpY2UuaHRtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgdGhlIHNldHRpbmdzIGZyb20gc2V0dGluZ3NDb25maWd1cmF0aW9uLmpzb24gYW5kIHJlbmRlclxuICAgICAgICAvLyB0aGVtIG91dCByZWR1Y2luZyB0aGUgZHVwbGljYXRpb24gb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlLiBUaGlzIHdpbGwgYmVjb21lXG4gICAgICAgIC8vIG1vcmUgaW1wb3J0YW50IGFzIGZlYXR1cmVzIGFyZSBiZWluZyBhZGRlZCBvdmVyIHRpbWUuXG4gICAgICAgIGhlYWRpbmcuc2V0dGluZ3MuZm9yRWFjaCgoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy5mZWF0dXJlRmxhZyAhPT0gJycgJiYgIWlzRmVhdHVyZUVuYWJsZWQoc2V0dGluZy5mZWF0dXJlRmxhZykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgY29uZmlndXJhdGlvbiBoYXMgYSBmZWF0dXJlRmxhZyBzZXQgYW5kIHRoZSB1c2VyIGhhcyBub3RcbiAgICAgICAgICAgICAgICAvLyBlbmFibGVkIGl0LiBTa2lwIGFkZGluZyB0aGUgc2V0dGluZ3Mgb3B0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5nLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhkZXRhaWxzQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZShzZXR0aW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKHNldHRpbmcuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCBzZXR0aW5nLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoPGJvb2xlYW4+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNldHRpbmcoc2V0dGluZy5zZXR0aW5nTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZGV0YWlsc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoc2V0dGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYyhzZXR0aW5nLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCBzZXR0aW5nLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKHNldHRpbmcucGxhY2Vob2xkZXIudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGRlYm91bmNlKG9uQ2hhbmdlLCA1MDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudHlwZSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGRldGFpbHNDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKHNldHRpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2Moc2V0dGluZy5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1tzZXR0aW5nLnNldHRpbmdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdlbmVyYWxTZXR0aW5nKHNldHRpbmcuc2V0dGluZ05hbWUsIHNldHRpbmcuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdlbmVyYWxTZXR0aW5nKHNldHRpbmcuc2V0dGluZ05hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoc2V0dGluZy5wbGFjZWhvbGRlci50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoZGVib3VuY2Uob25DaGFuZ2UsIDUwMCwgdHJ1ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwucm93cyA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuY29scyA9IDQwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZy50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21GdW5jdGlvbnNbc2V0dGluZy5zZXR0aW5nTmFtZV0oZGV0YWlsc0NvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nLm5vdGljZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGljZSA9IGRldGFpbHNDb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogc2V0dGluZy5ub3RpY2UuY2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNldHRpbmcubm90aWNlLnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubm90aWNlLmh0bWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgc2V0dGluZy5ub3RpY2UuaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZUNvbW1hU2VwYXJhdGVkRm9sZGVycyhpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyBhIGxpbWl0YXRpb24gaXMgdGhhdCBmb2xkZXIgbmFtZXMgbWF5IG5vdCBjb250YWluIGNvbW1hc1xuICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgLm1hcCgoZm9sZGVyKSA9PiBmb2xkZXIudHJpbSgpKVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoZm9sZGVyKSA9PiBmb2xkZXIucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmb2xkZXIpID0+IGZvbGRlciAhPT0gJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVuZGVyRm9sZGVyQXJyYXkoZm9sZGVyczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZm9sZGVycy5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGluZ3MgZm9yIENvcmUgVGFzayBTdGF0dXNcbiAgICAgKiBUaGVzZSBhcmUgYnVpbHQtaW4gc3RhdHVzZXMgdGhhdCBjYW4gaGF2ZSBtaW5pbWFsIGVkaXRzIG1hZGUsXG4gICAgICogYnV0IGFyZSBub3QgYWxsb3dlZCB0byBiZSBkZWxldGVkIG9yIGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyRWxcbiAgICAgKiBAcGFyYW0ge1NldHRpbmdzVGFifSBzZXR0aW5nc1xuICAgICAqIEBtZW1iZXJvZiBTZXR0aW5nc1RhYlxuICAgICAqL1xuICAgIGluc2VydFRhc2tDb3JlU3RhdHVzU2V0dGluZ3MoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzZXR0aW5nczogU2V0dGluZ3NUYWIpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXNTZXR0aW5ncyB9ID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBPbmUgcm93IHBlciBjb3JlIHN0YXR1cyBpbiB0aGUgc2V0dGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY29yZVN0YXR1c2VzLmZvckVhY2goKHN0YXR1c190eXBlKSA9PiB7XG4gICAgICAgICAgICBjcmVhdGVSb3dGb3JUYXNrU3RhdHVzKFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLFxuICAgICAgICAgICAgICAgIHN0YXR1c190eXBlLFxuICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLmNvcmVTdGF0dXNlcyxcbiAgICAgICAgICAgICAgICBzdGF0dXNTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW4sXG4gICAgICAgICAgICAgICAgdHJ1ZSwgLy8gaXNDb3JlU3RhdHVzXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5ncyBmb3IgQ3VzdG9tIFRhc2sgU3RhdHVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJFbFxuICAgICAqIEBwYXJhbSB7U2V0dGluZ3NUYWJ9IHNldHRpbmdzXG4gICAgICogQG1lbWJlcm9mIFNldHRpbmdzVGFiXG4gICAgICovXG4gICAgaW5zZXJ0Q3VzdG9tVGFza1N0YXR1c1NldHRpbmdzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc2V0dGluZ3M6IFNldHRpbmdzVGFiKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gT25lIHJvdyBwZXIgY3VzdG9tIHN0YXR1cyBpbiB0aGUgc2V0dGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzX3R5cGUpID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZVJvd0ZvclRhc2tTdGF0dXMoXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwsXG4gICAgICAgICAgICAgICAgc3RhdHVzX3R5cGUsXG4gICAgICAgICAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luLFxuICAgICAgICAgICAgICAgIGZhbHNlLCAvLyBpc0NvcmVTdGF0dXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnKTtcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAnQWRkIE5ldyBUYXNrIFN0YXR1cycgYnV0dG9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgTmV3IFRhc2sgU3RhdHVzJylcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLmFkZFN0YXR1cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJycsICcnLCAnJywgZmFsc2UsIFN0YXR1c1R5cGUuVE9ETyksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0dGluZy5pbmZvRWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gTWluaW1hbCBUaGVtZSBTdXBwb3J0ZWQgU3RhdHVzIFR5cGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IGFkZFN0YXR1c2VzU3VwcG9ydGVkQnlNaW5pbWFsVGhlbWUgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgYWxsIFN0YXR1cyB0eXBlcyBzdXBwb3J0ZWQgYnkgTWluaW1hbCBUaGVtZScpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRDdXN0b21TdGF0ZXNUb1NldHRpbmdzKG1pbmltYWxTdXBwb3J0ZWRTdGF0dXNlcygpLCBzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkU3RhdHVzZXNTdXBwb3J0ZWRCeU1pbmltYWxUaGVtZS5pbmZvRWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gSVRTIFRoZW1lIFN1cHBvcnRlZCBTdGF0dXMgVHlwZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgY29uc3QgYWRkU3RhdHVzZXNTdXBwb3J0ZWRCeUlUU1RoZW1lID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQWRkIGFsbCBTdGF0dXMgdHlwZXMgc3VwcG9ydGVkIGJ5IElUUyBUaGVtZScpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRDdXN0b21TdGF0ZXNUb1NldHRpbmdzKGl0c1N1cHBvcnRlZFN0YXR1c2VzKCksIHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRTdGF0dXNlc1N1cHBvcnRlZEJ5SVRTVGhlbWUuaW5mb0VsLnJlbW92ZSgpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tICdBZGQgQWxsIFVua25vd24gU3RhdHVzIFR5cGVzJyBidXR0b24gLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgY29uc3QgYWRkQWxsVW5rbm93blN0YXR1c2VzID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQWRkIEFsbCBVbmtub3duIFN0YXR1cyBUeXBlcycpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrcyA9IHRoaXMucGx1Z2luLmdldFRhc2tzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25TdGF0dXNlcyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuZmluZFVua25vd25TdGF0dXNlcyh0YXNrcyEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5rbm93blN0YXR1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25TdGF0dXNlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0dXNTZXR0aW5ncy5hZGRTdGF0dXMoc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMsIHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRBbGxVbmtub3duU3RhdHVzZXMuaW5mb0VsLnJlbW92ZSgpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tICdSZXNldCBDdXN0b20gU3RhdHVzIFR5cGVzIHRvIERlZmF1bHRzJyBidXR0b24gLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgY29uc3QgY2xlYXJDdXN0b21TdGF0dXNlcyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Jlc2V0IEN1c3RvbSBTdGF0dXMgVHlwZXMgdG8gRGVmYXVsdHMnKVxuICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLnJlc2V0QWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQ3VzdG9tU3RhdHVzZXMuaW5mb0VsLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHJvdyB0byBzZWUgYW5kIG1vZGlmeSBzZXR0aW5ncyBmb3IgYSBzaW5nbGUgdGFzayBzdGF0dXMgdHlwZS5cbiAqIEBwYXJhbSBjb250YWluZXJFbFxuICogQHBhcmFtIHN0YXR1c1R5cGUgLSBUaGUgc3RhdHVzIHR5cGUgdG8gYmUgZWRpdGVkLlxuICogQHBhcmFtIHN0YXR1c2VzIC0gVGhlIGxpc3Qgb2Ygc3RhdHVzZXMgdGhhdCBzdGF0dXNUeXBlIGlzIHN0b3JlZCBpbi5cbiAqIEBwYXJhbSBzdGF0dXNTZXR0aW5ncyAtIEFsbCB0aGUgc3RhdHVzIHR5cGVzIGFscmVhZHkgaW4gdGhlIHVzZXIncyBzZXR0aW5ncywgRVhDRVBUIHRoZSBzdGFuZGFyZCBvbmVzLlxuICogQHBhcmFtIHNldHRpbmdzXG4gKiBAcGFyYW0gcGx1Z2luXG4gKiBAcGFyYW0gaXNDb3JlU3RhdHVzIC0gd2hldGhlciB0aGUgc3RhdHVzIGlzIGEgY29yZSBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm93Rm9yVGFza1N0YXR1cyhcbiAgICBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG4gICAgc3RhdHVzVHlwZTogU3RhdHVzQ29uZmlndXJhdGlvbixcbiAgICBzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdLFxuICAgIHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncyxcbiAgICBzZXR0aW5nczogU2V0dGluZ3NUYWIsXG4gICAgcGx1Z2luOiBUYXNrc1BsdWdpbixcbiAgICBpc0NvcmVTdGF0dXM6IGJvb2xlYW4sXG4pIHtcbiAgICAvL2NvbnN0IHRhc2tTdGF0dXNEaXYgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2Jyk7XG5cbiAgICBjb25zdCB0YXNrU3RhdHVzUHJldmlldyA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwcmUnKTtcbiAgICB0YXNrU3RhdHVzUHJldmlldy5hZGRDbGFzcygncm93LWZvci1zdGF0dXMnKTtcbiAgICB0YXNrU3RhdHVzUHJldmlldy50ZXh0Q29udGVudCA9IG5ldyBTdGF0dXMoc3RhdHVzVHlwZSkucHJldmlld1RleHQoKTtcblxuICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCk7XG5cbiAgICBzZXR0aW5nLmluZm9FbC5yZXBsYWNlV2l0aCh0YXNrU3RhdHVzUHJldmlldyk7XG5cbiAgICBpZiAoIWlzQ29yZVN0YXR1cykge1xuICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKChleHRyYSkgPT4ge1xuICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignY3Jvc3MnKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdEZWxldGUnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFN0YXR1c1NldHRpbmdzLmRlbGV0ZVN0YXR1cyhzdGF0dXNlcywgc3RhdHVzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oKGV4dHJhKSA9PiB7XG4gICAgICAgIGV4dHJhXG4gICAgICAgICAgICAuc2V0SWNvbigncGVuY2lsJylcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKCdFZGl0JylcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBDdXN0b21TdGF0dXNNb2RhbChwbHVnaW4sIHN0YXR1c1R5cGUsIGlzQ29yZVN0YXR1cyk7XG5cbiAgICAgICAgICAgICAgICBtb2RhbC5vbkNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWwuc2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTdGF0dXNTZXR0aW5ncy5yZXBsYWNlU3RhdHVzKHN0YXR1c2VzLCBzdGF0dXNUeXBlLCBtb2RhbC5zdGF0dXNDb25maWd1cmF0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXR0aW5nLmluZm9FbC5yZW1vdmUoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkQ3VzdG9tU3RhdGVzVG9TZXR0aW5ncyhcbiAgICBzdXBwb3J0ZWRTdGF0dXNlczogU3RhdHVzQ29sbGVjdGlvbixcbiAgICBzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MsXG4gICAgc2V0dGluZ3M6IFNldHRpbmdzVGFiLFxuKSB7XG4gICAgY29uc3Qgbm90aWNlcyA9IFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9uKHN0YXR1c1NldHRpbmdzLCBzdXBwb3J0ZWRTdGF0dXNlcyk7XG5cbiAgICBub3RpY2VzLmZvckVhY2goKG5vdGljZSkgPT4ge1xuICAgICAgICBuZXcgTm90aWNlKG5vdGljZSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1R5cGVzOiBTdGF0dXNTZXR0aW5ncywgc2V0dGluZ3M6IFNldHRpbmdzVGFiKSB7XG4gICAgdXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICBzdGF0dXNTZXR0aW5nczogc3RhdHVzVHlwZXMsXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGFjdGl2ZSBzdGF0dXNlcy5cbiAgICAvLyBUaGlzIHNhdmVzIHRoZSB1c2VyIGZyb20gaGF2aW5nIHRvIHJlc3RhcnQgT2JzaWRpYW4gaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGNoYW5nZWQgc3RhdHVzKGVzKS5cbiAgICBTdGF0dXNTZXR0aW5ncy5hcHBseVRvU3RhdHVzUmVnaXN0cnkoc3RhdHVzVHlwZXMsIFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkpO1xuXG4gICAgYXdhaXQgc2V0dGluZ3Muc2F2ZVNldHRpbmdzKHRydWUpO1xufVxuIiwgImltcG9ydCB7IE1vZGFsLCBOb3RpY2UsIFNldHRpbmcsIFRleHRDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSBUYXNrc1BsdWdpbiBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IFN0YXR1c1ZhbGlkYXRvciB9IGZyb20gJy4uL1N0YXR1c1ZhbGlkYXRvcic7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXMnO1xuXG5jb25zdCB2YWxpZGF0b3IgPSBuZXcgU3RhdHVzVmFsaWRhdG9yKCk7XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21TdGF0dXNNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBzdGF0dXNTeW1ib2w6IHN0cmluZztcbiAgICBzdGF0dXNOYW1lOiBzdHJpbmc7XG4gICAgc3RhdHVzTmV4dFN5bWJvbDogc3RyaW5nO1xuICAgIHN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZDogYm9vbGVhbjtcbiAgICB0eXBlOiBTdGF0dXNUeXBlO1xuXG4gICAgc2F2ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBlcnJvcjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgaXNDb3JlU3RhdHVzOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwbHVnaW46IFRhc2tzUGx1Z2luLCBzdGF0dXNUeXBlOiBTdGF0dXNDb25maWd1cmF0aW9uLCBpc0NvcmVTdGF0dXM6IGJvb2xlYW4pIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCk7XG4gICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sID0gc3RhdHVzVHlwZS5zeW1ib2w7XG4gICAgICAgIHRoaXMuc3RhdHVzTmFtZSA9IHN0YXR1c1R5cGUubmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXNOZXh0U3ltYm9sID0gc3RhdHVzVHlwZS5uZXh0U3RhdHVzU3ltYm9sO1xuICAgICAgICB0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCA9IHN0YXR1c1R5cGUuYXZhaWxhYmxlQXNDb21tYW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSBzdGF0dXNUeXBlLnR5cGU7XG4gICAgICAgIHRoaXMuaXNDb3JlU3RhdHVzID0gaXNDb3JlU3RhdHVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHtAbGluayBTdGF0dXNDb25maWd1cmF0aW9ufSBmcm9tIHRoZSBtb2RhbCdzIGNvbnRlbnRzXG4gICAgICovXG4gICAgcHVibGljIHN0YXR1c0NvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzQ29uZmlndXJhdGlvbihcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNOYW1lLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNOZXh0U3ltYm9sLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNBdmFpbGFibGVBc0NvbW1hbmQsXG4gICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcGxheSgpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ0RpdiA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoKTtcbiAgICAgICAgLy9jb25zdCB0aXRsZSA9IHRoaXMudGl0bGUgPz8gJy4uLic7XG5cbiAgICAgICAgbGV0IHN0YXR1c1N5bWJvbFRleHQ6IFRleHRDb21wb25lbnQ7XG4gICAgICAgIG5ldyBTZXR0aW5nKHNldHRpbmdEaXYpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVGFzayBTdGF0dXMgU3ltYm9sJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdUaGlzIGlzIHRoZSBjaGFyYWN0ZXIgYmV0d2VlbiB0aGUgc3F1YXJlIGJyYWNlcy4gKEl0IGNhbiBvbmx5IGJlIGVkaXRlZCBmb3IgQ3VzdG9tIHN0YXR1c2VzLCBhbmQgbm90IENvcmUgc3RhdHVzZXMuKScsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N5bWJvbFRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5zdGF0dXNTeW1ib2wpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzU3ltYm9sID0gdjtcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tU3RhdHVzTW9kYWwuc2V0VmFsaWQodGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlU3ltYm9sKHRoaXMuc3RhdHVzQ29uZmlndXJhdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNldERpc2FibGVkKHRoaXMuaXNDb3JlU3RhdHVzKVxuICAgICAgICAgICAgLnRoZW4oKF9zZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhbnkgZXJyb3IgaWYgdGhlIGluaXRpYWwgdmFsdWUgbG9hZGVkIGlzIGluY29ycmVjdC5cbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChzdGF0dXNTeW1ib2xUZXh0LCB2YWxpZGF0b3IudmFsaWRhdGVTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBzdGF0dXNOYW1lVGV4dDogVGV4dENvbXBvbmVudDtcbiAgICAgICAgbmV3IFNldHRpbmcoc2V0dGluZ0RpdilcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXNrIFN0YXR1cyBOYW1lJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGlzIGlzIHRoZSBmcmllbmRseSBuYW1lIG9mIHRoZSB0YXNrIHN0YXR1cy4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNOYW1lVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnN0YXR1c05hbWUpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTmFtZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHRleHQsIHZhbGlkYXRvci52YWxpZGF0ZU5hbWUodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoX3NldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChzdGF0dXNOYW1lVGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlTmFtZSh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHN0YXR1c05leHRTeW1ib2xUZXh0OiBUZXh0Q29tcG9uZW50O1xuICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgTmV4dCBTdGF0dXMgU3ltYm9sJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVuIGNsaWNrZWQgb24gdGhpcyBpcyB0aGUgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHVzZWQgbmV4dC4nKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNOZXh0U3ltYm9sVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnN0YXR1c05leHRTeW1ib2wpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTmV4dFN5bWJvbCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHRleHQsIHZhbGlkYXRvci52YWxpZGF0ZU5leHRTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoX3NldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZChcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzTmV4dFN5bWJvbFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci52YWxpZGF0ZU5leHRTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgU3RhdHVzIFR5cGUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0NvbnRyb2wgaG93IHRoZSBzdGF0dXMgYmVoYXZlcyBmb3Igc2VhcmNoaW5nIGFuZCB0b2dnbGluZy4nKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICAgICBTdGF0dXNUeXBlLlRPRE8sXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuSU5fUFJPR1JFU1MsXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuRE9ORSxcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzVHlwZS5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuTk9OX1RBU0ssXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0eXBlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbihzLCBzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLnR5cGUpLm9uQ2hhbmdlKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFN0YXR1cy5nZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcodik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU3RhdHVzLnRhc2tzUGx1Z2luQ2FuQ3JlYXRlQ29tbWFuZHNGb3JTdGF0dXNlcygpKSB7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBdmFpbGFibGUgYXMgY29tbWFuZCcpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgICAgICdJZiBlbmFibGVkIHRoaXMgc3RhdHVzIHdpbGwgYmUgYXZhaWxhYmxlIGFzIGEgY29tbWFuZCBzbyB5b3UgY2FuIGFzc2lnbiBhIGhvdGtleSBhbmQgdG9nZ2xlIHRoZSBzdGF0dXMgdXNpbmcgaXQuJyxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvb3RlckVsID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xuICAgICAgICBjb25zdCBmb290ZXJCdXR0b25zID0gbmV3IFNldHRpbmcoZm9vdGVyRWwpO1xuICAgICAgICBmb290ZXJCdXR0b25zLmFkZEJ1dHRvbigoYikgPT4ge1xuICAgICAgICAgICAgYi5zZXRUb29sdGlwKCdTYXZlJylcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignY2hlY2ttYXJrJylcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRvci52YWxpZGF0ZSh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9ycy5qb2luKCdcXG4nKSArICdcXG5cXG4nICsgJ0ZpeCBlcnJvcnMgYmVmb3JlIHNhdmluZy4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9vdGVyQnV0dG9ucy5hZGRFeHRyYUJ1dHRvbigoYikgPT4ge1xuICAgICAgICAgICAgYi5zZXRJY29uKCdjcm9zcycpXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0NhbmNlbCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGVUaXRsZShhZG1vbml0aW9uUHJldmlldzogSFRNTEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcpIHtcbiAgICAvLyAgICAgbGV0IHRpdGxlU3BhbiA9IGFkbW9uaXRpb25QcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoJy5hZG1vbml0aW9uLXRpdGxlLWNvbnRlbnQnKTtcbiAgICAvLyAgICAgbGV0IGljb25FbCA9IGFkbW9uaXRpb25QcmV2aWV3LnF1ZXJ5U2VsZWN0b3IoJy5hZG1vbml0aW9uLXRpdGxlLWljb24nKTtcbiAgICAvLyAgICAgdGl0bGVTcGFuLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgLy8gICAgIHRpdGxlU3Bhbi5wcmVwZW5kKGljb25FbCk7XG4gICAgLy8gfVxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFZhbGlkYXRpb25FcnJvcih0ZXh0SW5wdXQ6IFRleHRDb21wb25lbnQpIHtcbiAgICAgICAgdGV4dElucHV0LmlucHV0RWwuYWRkQ2xhc3MoJ3Rhc2tzLXNldHRpbmdzLWlzLWludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlVmFsaWRhdGlvbkVycm9yKHRleHRJbnB1dDogVGV4dENvbXBvbmVudCkge1xuICAgICAgICB0ZXh0SW5wdXQuaW5wdXRFbC5yZW1vdmVDbGFzcygndGFza3Mtc2V0dGluZ3MtaXMtaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHNldFZhbGlkKHRleHQ6IFRleHRDb21wb25lbnQsIG1lc3NhZ2VzOiBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5yZW1vdmVWYWxpZGF0aW9uRXJyb3IodGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZGF0aW9uRXJyb3IodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFN0YXR1c1ZhbGlkYXRvciB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGRhdGUgaW4gdGhpcyBvYmplY3QgaXMgdmFsaWQsIGFuZCByZXR1cm4gZXJyb3IgbWVzc2FnZShzKSBmb3IgZGlzcGxheSBpZiBub3QuXG4gICAgICovXG4gICAgcHVibGljIHZhbGlkYXRlKHN0YXR1c0NvbmZpZ3VyYXRpb246IFN0YXR1c0NvbmZpZ3VyYXRpb24pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBNZXNzYWdlcyBhcmUgYWRkZWQgaW4gdGhlIG9yZGVyIGZpZWxkcyBhcmUgc2hvd24gd2hlbiBlZGl0aW5nIHN0YXR1c2VzLlxuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlU3ltYm9sKHN0YXR1c0NvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udGhpcy52YWxpZGF0ZU5hbWUoc3RhdHVzQ29uZmlndXJhdGlvbikpO1xuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlTmV4dFN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uKSk7XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsaWRhdGVTeW1ib2woc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c1ZhbGlkYXRvci52YWxpZGF0ZU9uZVN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uLnN5bWJvbCwgJ1Rhc2sgU3RhdHVzIFN5bWJvbCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZU5leHRTeW1ib2woc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c1ZhbGlkYXRvci52YWxpZGF0ZU9uZVN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uLm5leHRTdGF0dXNTeW1ib2wsICdUYXNrIE5leHQgU3RhdHVzIFN5bWJvbCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZU5hbWUoc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmIChzdGF0dXNDb25maWd1cmF0aW9uLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnVGFzayBTdGF0dXMgTmFtZSBjYW5ub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyB2YWxpZGF0ZU9uZVN5bWJvbChzeW1ib2w6IHN0cmluZywgc3ltYm9sTmFtZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmIChzeW1ib2wubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgJHtzeW1ib2xOYW1lfSBjYW5ub3QgYmUgZW1wdHkuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ltYm9sLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGAke3N5bWJvbE5hbWV9IChcIiR7c3ltYm9sfVwiKSBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBJVFMgdGhlbWUuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vU2xSdmIvT2JzaWRpYW4tLUlUUy1UaGVtZX1cbiAqIFZhbHVlcyByZWNvZ25pc2VkIGJ5IFRhc2tzIGFyZSBleGNsdWRlZC5cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXRzU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICBbJyAnLCAnVW5jaGVja2VkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3gnLCAnUmVndWxhcicsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWydYJywgJ0NoZWNrZWQnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnLScsICdEcm9wcGVkJywgJ3gnLCAnQ0FOQ0VMTEVEJ10sXG4gICAgICAgIFsnPicsICdGb3J3YXJkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0QnLCAnRGF0ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc/JywgJ1F1ZXN0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJy8nLCAnSGFsZiBEb25lJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWycrJywgJ0FkZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydSJywgJ1Jlc2VhcmNoJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyEnLCAnSW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnSWRlYScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydCJywgJ0JyYWluc3Rvcm0nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUCcsICdQcm8nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnQycsICdDb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUScsICdRdW90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydOJywgJ05vdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYicsICdCb29rbWFyaycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydJJywgJ0luZm9ybWF0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3AnLCAnUGFyYXBocmFzZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydMJywgJ0xvY2F0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0UnLCAnRXhhbXBsZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydBJywgJ0Fuc3dlcicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydyJywgJ1Jld2FyZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydjJywgJ0Nob2ljZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydkJywgJ0RvaW5nJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1QnLCAnVGltZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydAJywgJ0NoYXJhY3RlciAvIFBlcnNvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd0JywgJ1RhbGsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnTycsICdPdXRsaW5lIC8gUGxvdCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd+JywgJ0NvbmZsaWN0JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1cnLCAnV29ybGQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZicsICdDbHVlIC8gRmluZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydGJywgJ0ZvcmVzaGFkb3cnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSCcsICdGYXZvcml0ZSAvIEhlYWx0aCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycmJywgJ1N5bWJvbGlzbScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydzJywgJ1NlY3JldCcsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgTWluaW1hbCB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXBhbm8vb2JzaWRpYW4tbWluaW1hbH1cbiAqIFZhbHVlcyByZWNvZ25pc2VkIGJ5IFRhc2tzIGFyZSBleGNsdWRlZC5cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluaW1hbFN1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ3RvLWRvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJy8nLCAnaW5jb21wbGV0ZScsICd4JywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICAgIFsneCcsICdkb25lJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJy0nLCAnY2FuY2VsZWQnLCAneCcsICdDQU5DRUxMRUQnXSxcbiAgICAgICAgWyc+JywgJ2ZvcndhcmRlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc8JywgJ3NjaGVkdWxpbmcnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPycsICdxdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ2ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycqJywgJ3N0YXInLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnXCInLCAncXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnbCcsICdsb2NhdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydiJywgJ2Jvb2ttYXJrJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnaW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUycsICdzYXZpbmdzJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnaWRlYScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydwJywgJ3Byb3MnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYycsICdjb25zJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2YnLCAnZmlyZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydrJywgJ2tleScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd3JywgJ3dpbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd1JywgJ3VwJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2QnLCAnZG93bicsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEVkaXRvclN1Z2dlc3QsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JQb3NpdGlvbiwgRWRpdG9yU3VnZ2VzdENvbnRleHQsIEVkaXRvclN1Z2dlc3RUcmlnZ2VySW5mbyB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHR5cGUgeyBTZXR0aW5ncyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgKiBhcyB0YXNrIGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgYnVpbGRTdWdnZXN0aW9ucyB9IGZyb20gJy4vU3VnZ2VzdG9yJztcbmltcG9ydCB0eXBlIHsgU3VnZ2VzdEluZm8gfSBmcm9tICcuL1N1Z2dlc3Rvcic7XG5cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvV2l0aENvbnRleHQgPSBTdWdnZXN0SW5mbyAmIHtcbiAgICBjb250ZXh0OiBFZGl0b3JTdWdnZXN0Q29udGV4dDtcbn07XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JTdWdnZXN0b3IgZXh0ZW5kcyBFZGl0b3JTdWdnZXN0PFN1Z2dlc3RJbmZvV2l0aENvbnRleHQ+IHtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBTZXR0aW5ncztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogU2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cblxuICAgIG9uVHJpZ2dlcihjdXJzb3I6IEVkaXRvclBvc2l0aW9uLCBlZGl0b3I6IEVkaXRvciwgX2ZpbGU6IFRGaWxlKTogRWRpdG9yU3VnZ2VzdFRyaWdnZXJJbmZvIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hdXRvU3VnZ2VzdEluRWRpdG9yKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICAgICAgaWYgKGxpbmUuY29udGFpbnModGhpcy5zZXR0aW5ncy5nbG9iYWxGaWx0ZXIpICYmIGxpbmUubWF0Y2godGFzay5UYXNrUmVndWxhckV4cHJlc3Npb25zLnRhc2tSZWdleCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogY3Vyc29yLmxpbmUsIGNoOiAwIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnNvci5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjaDogbGluZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeTogbGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoY29udGV4dDogRWRpdG9yU3VnZ2VzdENvbnRleHQpOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0W10ge1xuICAgICAgICBjb25zdCBsaW5lID0gY29udGV4dC5xdWVyeTtcbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IGNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gYnVpbGRTdWdnZXN0aW9ucyhsaW5lLCBjdXJyZW50Q3Vyc29yLmNoLCB0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGVkaXRvciBjb250ZXh0IHRvIGFsbCB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnNXaXRoQ29udGV4dDogU3VnZ2VzdEluZm9XaXRoQ29udGV4dFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3VnZ2VzdGlvbiBvZiBzdWdnZXN0aW9ucykgc3VnZ2VzdGlvbnNXaXRoQ29udGV4dC5wdXNoKHsgLi4uc3VnZ2VzdGlvbiwgY29udGV4dDogY29udGV4dCB9KTtcblxuICAgICAgICByZXR1cm4gc3VnZ2VzdGlvbnNXaXRoQ29udGV4dDtcbiAgICB9XG5cbiAgICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgZWwuc2V0VGV4dCh2YWx1ZS5kaXNwbGF5VGV4dCk7XG4gICAgfVxuXG4gICAgc2VsZWN0U3VnZ2VzdGlvbih2YWx1ZTogU3VnZ2VzdEluZm9XaXRoQ29udGV4dCwgX2V2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdmFsdWUuY29udGV4dC5lZGl0b3I7XG4gICAgICAgIGlmICh2YWx1ZS5zdWdnZXN0aW9uVHlwZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIHN1Z2dlc3Rpb24gZGlhbG9nIGFuZCBzaW11bGF0ZSBhbiBFbnRlciBwcmVzcyB0byB0aGUgZWRpdG9yXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBldmVudENsb25lID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAgY29kZTogJ0VudGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdFbnRlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChlZGl0b3IgYXMgYW55KT8uY20/LmNvbnRlbnRET00/LmRpc3BhdGNoRXZlbnQoZXZlbnRDbG9uZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IHZhbHVlLmNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBjb25zdCByZXBsYWNlRnJvbSA9IHtcbiAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgIGNoOiB2YWx1ZS5pbnNlcnRBdCA/PyBjdXJyZW50Q3Vyc29yLmNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXBsYWNlVG8gPSB2YWx1ZS5pbnNlcnRTa2lwXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgICAgICAgIGNoOiByZXBsYWNlRnJvbS5jaCArIHZhbHVlLmluc2VydFNraXAsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB2YWx1ZS5jb250ZXh0LmVkaXRvci5yZXBsYWNlUmFuZ2UodmFsdWUuYXBwZW5kVGV4dCwgcmVwbGFjZUZyb20sIHJlcGxhY2VUbyk7XG4gICAgICAgIHZhbHVlLmNvbnRleHQuZWRpdG9yLnNldEN1cnNvcih7XG4gICAgICAgICAgICBsaW5lOiBjdXJyZW50Q3Vyc29yLmxpbmUsXG4gICAgICAgICAgICBjaDogcmVwbGFjZUZyb20uY2ggKyB2YWx1ZS5hcHBlbmRUZXh0Lmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2V0dGluZ3MgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL1F1ZXJ5L0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgZG9BdXRvY29tcGxldGUgfSBmcm9tICcuLi9EYXRlQWJicmV2aWF0aW9ucyc7XG5pbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vUmVjdXJyZW5jZSc7XG5cbmltcG9ydCAqIGFzIHRhc2sgZnJvbSAnLi4vVGFzayc7XG5cbmNvbnN0IGRhdGVQcmVmaXhDaGFyYWN0ZXJzID0gYCR7dGFzay5zdGFydERhdGVTeW1ib2x9JHt0YXNrLnNjaGVkdWxlZERhdGVTeW1ib2x9JHt0YXNrLmR1ZURhdGVTeW1ib2x9YDtcblxuLypcbiAqIEEgc3VnZ2VzdGlvbiBwcmVzZW50ZWQgdG8gdGhlIHVzZXIgYW5kIHNvbWUgbWV0YWRhdGEgYWJvdXQgaXQuXG4gKi9cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvID0ge1xuICAgIHN1Z2dlc3Rpb25UeXBlPzogJ21hdGNoJyB8ICdkZWZhdWx0JyB8ICdlbXB0eSc7XG4gICAgLy8gV2hhdCB0byBkaXNwbGF5IHRvIHRoZSB1c2VyXG4gICAgZGlzcGxheVRleHQ6IHN0cmluZztcbiAgICAvLyBXaGF0IHRvIGFwcGVuZCB0byB0aGUgbm90ZVxuICAgIGFwcGVuZFRleHQ6IHN0cmluZztcbiAgICAvLyBBdCB3aGF0IGluZGV4IGluIHRoZSBsaW5lIHRvIGRvIHRoZSBpbnNlcnRpb24gKGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJzb3IgbG9jYXRpb24gaXMgdXNlZClcbiAgICBpbnNlcnRBdD86IG51bWJlcjtcbiAgICAvLyBIb3cgbWFueSBjaGFyYWN0ZXJzIHRvIHNraXAgZnJvbSB0aGUgb3JpZ2luYWwgbGluZSAoZS5nLiBpZiByZXBsYWNpbmcgZXhpc3RpbmcgdGV4dClcbiAgICBpbnNlcnRTa2lwPzogbnVtYmVyO1xufTtcblxuLypcbiAqIFJldHVybiBhIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMsIGVpdGhlciBnZW5lcmljIG9yIG1vcmUgZmluZS1ncmFpbmVkIHRvIHRoZSB3b3JkcyBhdCB0aGUgY3Vyc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTdWdnZXN0aW9ucyhsaW5lOiBzdHJpbmcsIGN1cnNvclBvczogbnVtYmVyLCBzZXR0aW5nczogU2V0dGluZ3MpOiBTdWdnZXN0SW5mb1tdIHtcbiAgICBsZXQgc3VnZ2VzdGlvbnM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcblxuICAgIC8vIFN0ZXAgMTogYWRkIGRhdGUgc3VnZ2VzdGlvbnMgaWYgcmVsZXZhbnRcbiAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChhZGREYXRlc1N1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MpKTtcblxuICAgIC8vIFN0ZXAgMjogYWRkIHJlY3VycmVuY2Ugc3VnZ2VzdGlvbnMgaWYgcmVsZXZhbnRcbiAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChhZGRSZWN1cnJlbmNlU3VnZ2VzdGlvbnMobGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncykpO1xuXG4gICAgLy8gU3RlcCAzOiBhZGQgbW9yZSBnZW5lcmFsIHN1Z2dlc3Rpb25zICgnZHVlJywgJ3JlY3VycmVuY2UnIGV0YylcbiAgICBjb25zdCBtb3JlUG9zc2libGVTdWdnZXN0aW9ucyA9IGdldFBvc3NpYmxlQ29tcG9uZW50U3VnZ2VzdGlvbnMobGluZSwgc2V0dGluZ3MpO1xuICAgIC8vIFdlIG5vdyBmaWx0ZXIgdGhlIGdlbmVyYWwgc3VnZ2VzdGlvbnMgYWNjb3JkaW5nIHRvIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3IuIElmIHRoZXJlJ3NcbiAgICAvLyBzb21ldGhpbmcgdG8gbWF0Y2gsIHdlIGZpbHRlciB0aGUgc3VnZ2VzdGlvbnMgYWNjb3JkaW5nbHksIHNvIHRoZSB1c2VyIGNhbiBnZXQgbW9yZSBzcGVjaWZpY1xuICAgIC8vIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHdoYXQgc2hlJ3MgdHlwaW5nLlxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZ29vZCBtYXRjaCwgcHJlc2VudCB0aGUgc3VnZ2VzdGlvbnMgYXMgdGhleSBhcmVcbiAgICBjb25zdCB3b3JkTWF0Y2ggPSBtYXRjaEJ5UG9zaXRpb24obGluZSwgLyhbYS16QS1aJ18tXSopL2csIGN1cnNvclBvcyk7XG4gICAgbGV0IGFkZGVkU3VnZ2VzdGlvbnMgPSBmYWxzZTtcbiAgICBpZiAod29yZE1hdGNoICYmIHdvcmRNYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmRVbmRlckN1cnNvciA9IHdvcmRNYXRjaFswXTtcbiAgICAgICAgaWYgKHdvcmRVbmRlckN1cnNvci5sZW5ndGggPj0gTWF0aC5tYXgoMSwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkU3VnZ2VzdGlvbnMgPSBtb3JlUG9zc2libGVTdWdnZXN0aW9ucy5maWx0ZXIoKHN1Z2dlc3RJbmZvKSA9PlxuICAgICAgICAgICAgICAgIHN1Z2dlc3RJbmZvLmRpc3BsYXlUZXh0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZFVuZGVyQ3Vyc29yLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyZWQgb2YgZmlsdGVyZWRTdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGZpbHRlcmVkLmRpc3BsYXlUZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBmaWx0ZXJlZC5hcHBlbmRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBdDogd29yZE1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiB3b3JkVW5kZXJDdXJzb3IubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZGVkU3VnZ2VzdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoYXQncyB3aGVyZSB3ZSdyZSBhZGRpbmcgYWxsIHRoZSBzdWdnZXN0aW9ucyBpbiBjYXNlIHRoZXJlJ3Mgbm90aGluZyBzcGVjaWZpYyB0byBtYXRjaFxuICAgIC8vIChhbmQgd2UncmUgYWxsb3dlZCBieSB0aGUgc2V0dGluZ3MgdG8gYnJpbmcgYmFjayBhIHplcm8tc2l6ZWQgbWF0Y2gpXG4gICAgaWYgKCFhZGRlZFN1Z2dlc3Rpb25zICYmIHNldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2ggPT09IDApXG4gICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KG1vcmVQb3NzaWJsZVN1Z2dlc3Rpb25zKTtcblxuICAgIC8vIFVubGVzcyB3ZSBoYXZlIGEgc3VnZ2VzdGlvbiB0aGF0IGlzIGEgbWF0Y2ggZm9yIHNvbWV0aGluZyB0aGUgdXNlciBpcyBjdXJyZW50bHkgdHlwaW5nLCBhZGRcbiAgICAvLyBhbiAnRW50ZXInIGVudHJ5IGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1lbnUsIHNvIGFuIEVudGVyIHByZXNzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCBsaW5lXG4gICAgLy8gcmF0aGVyIHRoYW4gaW5zZXJ0IGEgc3VnZ2VzdGlvblxuICAgIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPiAwICYmICFzdWdnZXN0aW9ucy5zb21lKCh2YWx1ZSkgPT4gdmFsdWUuc3VnZ2VzdGlvblR5cGUgPT09ICdtYXRjaCcpKSB7XG4gICAgICAgIC8vIE5vIGFjdHVhbCBtYXRjaCwgb25seSBkZWZhdWx0IG9uZXNcbiAgICAgICAgc3VnZ2VzdGlvbnMudW5zaGlmdCh7XG4gICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ2VtcHR5JyxcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiAnXHUyM0NFJyxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6ICdcXG4nLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBFaXRoZXIgd2F5LCBhZnRlciBhbGwgdGhlIGFnZ3JlZ2F0aW9ucyBhYm92ZSwgbmV2ZXIgc3VnZ2VzdCBtb3JlIHRoYW4gdGhlIG1heCBpdGVtc1xuICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuc2xpY2UoMCwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNYXhJdGVtcyk7XG5cbiAgICByZXR1cm4gc3VnZ2VzdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGhhc1ByaW9yaXR5KGxpbmU6IHN0cmluZykge1xuICAgIGlmIChPYmplY3QudmFsdWVzKHRhc2sucHJpb3JpdHlTeW1ib2xzKS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMCAmJiBsaW5lLmluY2x1ZGVzKHZhbHVlKSkpIHJldHVybiB0cnVlO1xufVxuXG4vKlxuICogR2V0IHN1Z2dlc3Rpb25zIGZvciBnZW5lcmljIHRhc2sgY29tcG9uZW50cywgZS5nLiBhIHByaW9yaXR5IG9yIGEgJ2R1ZScgc3ltYm9sXG4gKi9cbmZ1bmN0aW9uIGdldFBvc3NpYmxlQ29tcG9uZW50U3VnZ2VzdGlvbnMobGluZTogc3RyaW5nLCBfc2V0dGluZ3M6IFNldHRpbmdzKTogU3VnZ2VzdEluZm9bXSB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcblxuICAgIGlmICghbGluZS5pbmNsdWRlcyh0YXNrLmR1ZURhdGVTeW1ib2wpKVxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLmR1ZURhdGVTeW1ib2x9IGR1ZSBkYXRlYCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3Rhc2suZHVlRGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFsaW5lLmluY2x1ZGVzKHRhc2suc3RhcnREYXRlU3ltYm9sKSlcbiAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7dGFzay5zdGFydERhdGVTeW1ib2x9IHN0YXJ0IGRhdGVgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7dGFzay5zdGFydERhdGVTeW1ib2x9IGAsXG4gICAgICAgIH0pO1xuICAgIGlmICghbGluZS5pbmNsdWRlcyh0YXNrLnNjaGVkdWxlZERhdGVTeW1ib2wpKVxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnNjaGVkdWxlZERhdGVTeW1ib2x9IHNjaGVkdWxlZCBkYXRlYCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3Rhc2suc2NoZWR1bGVkRGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFoYXNQcmlvcml0eShsaW5lKSkge1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnByaW9yaXR5U3ltYm9scy5IaWdofSBoaWdoIHByaW9yaXR5YCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLkhpZ2h9IGAsXG4gICAgICAgIH0pO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnByaW9yaXR5U3ltYm9scy5NZWRpdW19IG1lZGl1bSBwcmlvcml0eWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHt0YXNrLnByaW9yaXR5U3ltYm9scy5NZWRpdW19IGAsXG4gICAgICAgIH0pO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnByaW9yaXR5U3ltYm9scy5Mb3d9IGxvdyBwcmlvcml0eWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHt0YXNrLnByaW9yaXR5U3ltYm9scy5Mb3d9IGAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxpbmUuaW5jbHVkZXModGFzay5yZWN1cnJlbmNlU3ltYm9sKSlcbiAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7dGFzay5yZWN1cnJlbmNlU3ltYm9sfSByZWN1cnJpbmcgKHJlcGVhdClgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7dGFzay5yZWN1cnJlbmNlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcblxuICAgIHJldHVybiBzdWdnZXN0aW9ucztcbn1cblxuLypcbiAqIElmIHRoZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiBhIHNlY3Rpb24gdGhhdCBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYSBkYXRlIChkdWUsIHN0YXJ0IGRhdGUgb3Igc2NoZWR1bGVkIGRhdGUpLFxuICogc3VnZ2VzdCBvcHRpb25zIGZvciB3aGF0IHRvIGVudGVyIGFzIGEgZGF0ZS5cbiAqIFRoaXMgaGFzIHR3byBwYXJ0czogZWl0aGVyIGdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgb3IgYSBzaW5nbGUgc3VnZ2VzdGlvbiB0aGF0IGlzIGEgcGFyc2VkIHJlc3VsdFxuICogb2Ygd2hhdCB0aGUgdXNlciBpcyB0eXBpbmcuXG4gKiBHZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMsIGluIHR1cm4sIGFsc28gaGF2ZSB0d28gb3B0aW9uczogZWl0aGVyIGZpbHRlcmVkIChpZiB0aGUgdXNlciBzdGFydGVkIHR5cGluZ1xuICogc29tZXRoaW5nIHdoZXJlIGEgZGF0ZSBpcyBleHBlY3RlZCkgb3IgdW5maWx0ZXJlZFxuICovXG5mdW5jdGlvbiBhZGREYXRlc1N1Z2dlc3Rpb25zKGxpbmU6IHN0cmluZywgY3Vyc29yUG9zOiBudW1iZXIsIHNldHRpbmdzOiBTZXR0aW5ncyk6IFN1Z2dlc3RJbmZvW10ge1xuICAgIGNvbnN0IGdlbmVyaWNTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgJ3RvZGF5JyxcbiAgICAgICAgJ3RvbW9ycm93JyxcbiAgICAgICAgJ1N1bmRheScsXG4gICAgICAgICdNb25kYXknLFxuICAgICAgICAnVHVlc2RheScsXG4gICAgICAgICdXZWRuZXNkYXknLFxuICAgICAgICAnVGh1cnNkYXknLFxuICAgICAgICAnRnJpZGF5JyxcbiAgICAgICAgJ1NhdHVyZGF5JyxcbiAgICAgICAgJ25leHQgd2VlaycsXG4gICAgICAgICduZXh0IG1vbnRoJyxcbiAgICAgICAgJ25leHQgeWVhcicsXG4gICAgXTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcbiAgICBjb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGAoWyR7ZGF0ZVByZWZpeENoYXJhY3RlcnN9XSlcXFxccyooWzAtOWEtekEtWiBdKilgLCAndWcnKTtcbiAgICBjb25zdCBkYXRlTWF0Y2ggPSBtYXRjaEJ5UG9zaXRpb24obGluZSwgZGF0ZVJlZ2V4LCBjdXJzb3JQb3MpO1xuICAgIGlmIChkYXRlTWF0Y2ggJiYgZGF0ZU1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IGRhdGVQcmVmaXggPSBkYXRlTWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkYXRlTWF0Y2hbMl07XG4gICAgICAgIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA8IHNldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGVudGVyZWQgdGV4dCBhcyBhIHZhbGlkIGRhdGUuXG4gICAgICAgIC8vIFdlIHBhc3MgZm9yd2FyZERhdGU9dHJ1ZSB0byBwYXJzZURhdGUgYmVjYXVzZSB3ZSBleHBlY3QgZHVlLCBzdGFydCBhbmQgc2NoZWR1bGVkIGRhdGVzIHRvXG4gICAgICAgIC8vIGJlIGluIHRoZSBmdXR1cmUsIGkuZS4gaWYgdG9kYXkgaXMgU3VuZGF5IGFuZCB0aGUgdXNlciB0eXBlZCBcImR1ZSA8RW50ZXI+IFNhdHVyZGF5XCIsIHNoZVxuICAgICAgICAvLyBtb3N0IGxpa2VseSBtZWFucyBTYXR1cmRheSAqaW4gdGhlIGZ1dHVyZSogYW5kIG5vdCB5ZXN0ZXJkYXkuXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRGF0ZSA9XG4gICAgICAgICAgICBkYXRlU3RyaW5nICYmIGRhdGVTdHJpbmcubGVuZ3RoID4gMSA/IERhdGVQYXJzZXIucGFyc2VEYXRlKGRvQXV0b2NvbXBsZXRlKGRhdGVTdHJpbmcpLCB0cnVlKSA6IG51bGw7XG4gICAgICAgIGlmIChwb3NzaWJsZURhdGUgJiYgcG9zc2libGVEYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlbXMgbGlrZSB0aGUgdGV4dCB0aGF0IHRoZSB1c2VyIHR5cGVkIGNhbiBiZSBwYXJzZWQgYXMgYSB2YWxpZCBkYXRlLlxuICAgICAgICAgICAgLy8gUHJlc2VudCBpdHMgY29tcGxldGVkIGZvcm0gYXMgYSAxc3Qgc3VnZ2VzdGlvblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7cG9zc2libGVEYXRlLmZvcm1hdCh0YXNrLlRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtkYXRlUHJlZml4fSAke3Bvc3NpYmxlRGF0ZS5mb3JtYXQodGFzay5UYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpfSBgLFxuICAgICAgICAgICAgICAgIGluc2VydEF0OiBkYXRlTWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgaW5zZXJ0U2tpcDogZGF0ZU1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHRvIGdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucy5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgcGFydGlhbCBtYXRjaCB3aXRoIHNvbWUgb2YgdGhlIHN1Z2dlc3Rpb25zIChlLmcuIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nIFwidG9cIiksXG4gICAgICAgIC8vIHdlIHVzZSB0aGF0IGZvciBtYXRjaGVzIChcInRvbW9ycm93XCIsIFwidG9kYXlcIiBldGMpLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGp1c3QgZGlzcGxheSB0aGUgbGlzdCBvZiBzdWdnZXN0aW9ucywgYW5kIGVpdGhlciB3YXksIHRydW5jYXRlIHRoZW0gZXZlbnR1YWxseSB0b1xuICAgICAgICAvLyBhIG1heCBudW1iZXIuIFdlIHdhbnQgdGhlIG1heCBudW1iZXIgdG8gYmUgYXJvdW5kIGhhbGYgdGhlIHRvdGFsIGFsbG93ZWQgbWF0Y2hlcywgdG8gYWxzbyBhbGxvd1xuICAgICAgICAvLyBzb21lIGdsb2JhbCBnZW5lcmljIG1hdGNoZXMgKGUuZy4gdGFzayBjb21wb25lbnRzKSB0byBmaW5kIHRoZWlyIHdheSB0byB0aGUgbWVudVxuICAgICAgICBjb25zdCBtaW5NYXRjaCA9IDE7XG4gICAgICAgIGNvbnN0IG1heEdlbmVyaWNTdWdnZXN0aW9ucyA9IDU7XG4gICAgICAgIGxldCBnZW5lcmljTWF0Y2hlcyA9IGdlbmVyaWNTdWdnZXN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cmluZy5sZW5ndGggPj0gbWluTWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhkYXRlU3RyaW5nLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnNsaWNlKDAsIG1heEdlbmVyaWNTdWdnZXN0aW9ucyk7XG4gICAgICAgIGlmIChnZW5lcmljTWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIERvIGNvbXBsZXRlbHkgZ2VuZXJpYyBkYXRlIHN1Z2dlc3Rpb25zXG4gICAgICAgICAgICBnZW5lcmljTWF0Y2hlcyA9IGdlbmVyaWNTdWdnZXN0aW9ucy5zbGljZSgwLCBtYXhHZW5lcmljU3VnZ2VzdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZ2VuZXJpY01hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBEYXRlUGFyc2VyLnBhcnNlRGF0ZShtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gYCR7cGFyc2VkRGF0ZS5mb3JtYXQodGFzay5UYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpfWA7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHttYXRjaH0gKCR7Zm9ybWF0dGVkRGF0ZX0pYCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtkYXRlUHJlZml4fSAke2Zvcm1hdHRlZERhdGV9IGAsXG4gICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IGRhdGVNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiBkYXRlTWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qXG4gKiBJZiB0aGUgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gYSBzZWN0aW9uIHRoYXQgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGEgcmVjdXJyZW5jZSBkZXNjcmlwdGlvbiwgc3VnZ2VzdCBvcHRpb25zXG4gKiBmb3Igd2hhdCB0byBlbnRlciBhcyBhIHJlY3VycmVuY2UuXG4gKiBUaGlzIGhhcyB0d28gcGFydHM6IGVpdGhlciBnZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMsIG9yIGEgc2luZ2xlIHN1Z2dlc3Rpb24gdGhhdCBpcyBhIHBhcnNlZCByZXN1bHRcbiAqIG9mIHdoYXQgdGhlIHVzZXIgaXMgdHlwaW5nLlxuICogR2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLCBpbiB0dXJuLCBhbHNvIGhhdmUgdHdvIG9wdGlvbnM6IGVpdGhlciBmaWx0ZXJlZCAoaWYgdGhlIHVzZXIgc3RhcnRlZCB0eXBpbmdcbiAqIHNvbWV0aGluZyB3aGVyZSBhIHJlY3VycmVuY2UgaXMgZXhwZWN0ZWQpIG9yIHVuZmlsdGVyZWRcbiAqL1xuZnVuY3Rpb24gYWRkUmVjdXJyZW5jZVN1Z2dlc3Rpb25zKGxpbmU6IHN0cmluZywgY3Vyc29yUG9zOiBudW1iZXIsIHNldHRpbmdzOiBTZXR0aW5ncykge1xuICAgIGNvbnN0IGdlbmVyaWNTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgJ2V2ZXJ5JyxcbiAgICAgICAgJ2V2ZXJ5IGRheScsXG4gICAgICAgICdldmVyeSB3ZWVrJyxcbiAgICAgICAgJ2V2ZXJ5IG1vbnRoJyxcbiAgICAgICAgJ2V2ZXJ5IG1vbnRoIG9uIHRoZScsXG4gICAgICAgICdldmVyeSB5ZWFyJyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gU3VuZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gTW9uZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gVHVlc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFdlZG5lc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFRodXJzZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gRnJpZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gU2F0dXJkYXknLFxuICAgIF07XG5cbiAgICBjb25zdCByZXN1bHRzOiBTdWdnZXN0SW5mb1tdID0gW107XG4gICAgY29uc3QgcmVjdXJyZW5jZVJlZ2V4ID0gbmV3IFJlZ0V4cChgKCR7dGFzay5yZWN1cnJlbmNlU3ltYm9sfSlcXFxccyooWzAtOWEtekEtWiBdKilgLCAndWcnKTtcbiAgICBjb25zdCByZWN1cnJlbmNlTWF0Y2ggPSBtYXRjaEJ5UG9zaXRpb24obGluZSwgcmVjdXJyZW5jZVJlZ2V4LCBjdXJzb3JQb3MpO1xuICAgIGlmIChyZWN1cnJlbmNlTWF0Y2ggJiYgcmVjdXJyZW5jZU1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHJlY3VycmVuY2VQcmVmaXggPSByZWN1cnJlbmNlTWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IHJlY3VycmVuY2VTdHJpbmcgPSByZWN1cnJlbmNlTWF0Y2hbMl07XG4gICAgICAgIGlmIChyZWN1cnJlbmNlU3RyaW5nLmxlbmd0aCA8IHNldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2gpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRleHQgbWF0Y2hlcyBhIHZhbGlkIHJlY3VyZW5jZSBkZXNjcmlwdGlvbiwgcHJlc2VudCBpdCBhcyBhIDFzdCBzdWdnZXN0aW9uLlxuICAgICAgICAgICAgLy8gV2UgYWxzbyBhZGQgYSBuaWNlIGNoZWNrbWFyayBpbiB0aGlzIGNhc2UgdG8gZGVub3RlIGl0J3MgYSBjb21wbGV0ZSB2YWxpZCByZWN1cnJlbmNlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZWN1cnJlbmNlID0gUmVjdXJyZW5jZS5mcm9tVGV4dCh7XG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZVJ1bGVUZXh0OiByZWN1cnJlbmNlU3RyaW5nLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgICAgICB9KT8udG9UZXh0KCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkUmVjdXJyZW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcGVuZGVkVGV4dCA9IGAke3JlY3VycmVuY2VQcmVmaXh9ICR7cGFyc2VkUmVjdXJyZW5jZX0gYDtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGBcdTI3MDUgJHtwYXJzZWRSZWN1cnJlbmNlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGFwcGVuZGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IHJlY3VycmVuY2VNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U2tpcDogcmVjdXJyZW5jZU1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZnVsbCBtYXRjaCBpbmNsdWRlcyBhIGNvbXBsZXRlIHZhbGlkIHN1Z2dlc3Rpb24gKmVuZGluZyB3aXRoIHNwYWNlKixcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWdnZXN0IGFueXRoaW5nLiBUaGUgdXNlciBpcyB0cnlpbmcgdG8gY29udGludWUgdG8gdHlwZSBzb21ldGhpbmcgdGhhdCBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAvLyBub3QgcmVsYXRlZCB0byByZWN1cnJlbmNlLiBXaGVuIHNoZSBzdGFydHMgYSBuZXcgd29yZCwgbWF5YmUgdGhlIHJlY3VycmVuY2UgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVsZXZhbnQgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAocmVjdXJyZW5jZU1hdGNoWzBdID09IGFwcGVuZGVkVGV4dCkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHRvIGdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucy5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgcGFydGlhbCBtYXRjaCB3aXRoIHNvbWUgb2YgdGhlIHN1Z2dlc3Rpb25zIChlLmcuIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nIFwiZXZlcnkgZFwiKSxcbiAgICAgICAgLy8gd2UgdXNlIHRoYXQgZm9yIG1hdGNoZXMgKFwiZXZlcnkgZGF5XCIpLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGp1c3QgZGlzcGxheSB0aGUgbGlzdCBvZiBzdWdnZXN0aW9ucywgYW5kIGVpdGhlciB3YXksIHRydW5jYXRlIHRoZW0gZXZlbnR1YWxseSB0b1xuICAgICAgICAvLyBhIG1heCBudW1iZXIuXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHJlY3VycmVuY2UgcnVsZXMsIHRoZSBtYXggbnVtYmVyIHNob3VsZCBiZSBzbWFsbCBlbm91Z2ggdG8gYWxsb3cgdXNlcnMgdG8gXCJlc2NhcGVcIlxuICAgICAgICAvLyB0aGUgbW9kZSBvZiB3cml0aW5nIGEgcmVjdXJyZW5jZSBydWxlLCBpLmUuIHdlIHNob3VsZCBsZWF2ZSBlbm91Z2ggc3BhY2UgZm9yIGNvbXBvbmVudCBzdWdnZXN0aW9uc1xuICAgICAgICBjb25zdCBtaW5NYXRjaCA9IDE7XG4gICAgICAgIGNvbnN0IG1heEdlbmVyaWNEYXRlU3VnZ2VzdGlvbnMgPSBzZXR0aW5ncy5hdXRvU3VnZ2VzdE1heEl0ZW1zIC8gMjtcbiAgICAgICAgbGV0IGdlbmVyaWNNYXRjaGVzID0gZ2VuZXJpY1N1Z2dlc3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgcmVjdXJyZW5jZVN0cmluZyAmJlxuICAgICAgICAgICAgICAgICAgICByZWN1cnJlbmNlU3RyaW5nLmxlbmd0aCA+PSBtaW5NYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHJlY3VycmVuY2VTdHJpbmcudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2xpY2UoMCwgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyk7XG4gICAgICAgIGlmIChnZW5lcmljTWF0Y2hlcy5sZW5ndGggPT09IDAgJiYgcmVjdXJyZW5jZVN0cmluZy50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIG5vIGFjdHVhbCBtYXRjaCBzbyBkbyBjb21wbGV0ZWx5IGdlbmVyaWMgcmVjdXJyZW5jZSBzdWdnZXN0aW9ucywgYnV0IG5vdCBpZlxuICAgICAgICAgICAgLy8gdGhlcmUgKndhcyogYSB0ZXh0IHRvIG1hdGNoIChiZWNhdXNlIGl0IG1lYW5zIHRoZSB1c2VyIGlzIGFjdHVhbGx5IHR5cGluZyBzb21ldGhpbmcgZWxzZSlcbiAgICAgICAgICAgIGdlbmVyaWNNYXRjaGVzID0gZ2VuZXJpY1N1Z2dlc3Rpb25zLnNsaWNlKDAsIG1heEdlbmVyaWNEYXRlU3VnZ2VzdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZ2VuZXJpY01hdGNoZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke21hdGNofWAsXG4gICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7cmVjdXJyZW5jZVByZWZpeH0gJHttYXRjaH0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogcmVjdXJyZW5jZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IHJlY3VycmVuY2VNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IGFjY29yZGluZyB0byBhIHBvc2l0aW9uICh0eXBpY2FsbHkgb2YgYSBjdXJzb3IpLlxuICogV2lsbCByZXR1cm4gYSByZXN1bHQgb25seSBpZiBhIG1hdGNoIGV4aXN0cyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHBhcnQgb2YgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaEJ5UG9zaXRpb24oczogc3RyaW5nLCByOiBSZWdFeHAsIHBvc2l0aW9uOiBudW1iZXIpOiBSZWdFeHBNYXRjaEFycmF5IHtcbiAgICBjb25zdCBtYXRjaGVzID0gcy5tYXRjaEFsbChyKTtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoPy5pbmRleCAmJiBtYXRjaC5pbmRleCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSx5Q0FBQUEsU0FBQTtBQWVBLFFBQUlDO0FBQ0osUUFBSUM7QUFD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LEdBQUVFLEtBQUUsS0FBSyxJQUFJRCxFQUFDLEdBQUVFLEtBQUUsS0FBSyxNQUFNRCxLQUFFLEVBQUUsR0FBRUUsS0FBRUYsS0FBRTtBQUFHLGdCQUFPRCxNQUFHLElBQUUsTUFBSSxPQUFLLEVBQUVFLElBQUUsR0FBRSxHQUFHLElBQUUsTUFBSSxFQUFFQyxJQUFFLEdBQUUsR0FBRztBQUFBLE1BQUMsR0FBRSxHQUFFLFNBQVNKLEdBQUVDLElBQUVDLElBQUU7QUFBQyxZQUFHRCxHQUFFLEtBQUssSUFBRUMsR0FBRSxLQUFLO0FBQUUsaUJBQU0sQ0FBQ0YsR0FBRUUsSUFBRUQsRUFBQztBQUFFLFlBQUlFLEtBQUUsTUFBSUQsR0FBRSxLQUFLLElBQUVELEdBQUUsS0FBSyxNQUFJQyxHQUFFLE1BQU0sSUFBRUQsR0FBRSxNQUFNLElBQUdHLEtBQUVILEdBQUUsTUFBTSxFQUFFLElBQUlFLElBQUUsQ0FBQyxHQUFFRSxLQUFFSCxLQUFFRSxLQUFFLEdBQUVFLEtBQUVMLEdBQUUsTUFBTSxFQUFFLElBQUlFLE1BQUdFLEtBQUUsS0FBRyxJQUFHLENBQUM7QUFBRSxlQUFNLEVBQUUsRUFBRUYsTUFBR0QsS0FBRUUsT0FBSUMsS0FBRUQsS0FBRUUsS0FBRUEsS0FBRUYsUUFBSztBQUFBLE1BQUUsR0FBRSxHQUFFLFNBQVNKLElBQUU7QUFBQyxlQUFPQSxLQUFFLElBQUUsS0FBSyxLQUFLQSxFQUFDLEtBQUcsSUFBRSxLQUFLLE1BQU1BLEVBQUM7QUFBQSxNQUFDLEdBQUUsR0FBRSxTQUFTQSxJQUFFO0FBQUMsZUFBTSxFQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsRUFBQyxFQUFFQSxPQUFJLE9BQU9BLE1BQUcsRUFBRSxFQUFFLFlBQVksRUFBRSxRQUFRLE1BQUssRUFBRTtBQUFBLE1BQUMsR0FBRSxHQUFFLFNBQVNBLElBQUU7QUFBQyxlQUFPLFdBQVNBO0FBQUEsTUFB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O01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsT0FBTztNQUNQLE9BQU87TUFDUCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsSUFBSTtNQUNKLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixPQUFP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Q0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLElBQUk7TUFDSixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01B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LGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLENBQUEsR0FDVCxPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLEdBQUcsRUFBRSxHQUFDLElBQUEsR0FDYixPQUFPLElBQUksRUFBRSxHQUFDLElBQUEsR0FDZCxPQUFPLElBQUksRUFBRSxHQUFDLElBQUEsR0FDZCxPQUFPLElBQUksRUFBRSxHQUFDLElBQUEsR0FDZCxPQUFPLEdBQUcsQ0FBQyxHQUFDLElBQUE7QUFHakIsSUFBTSxXQUFRLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsY0FBQSxjQUFBLGNBQUEsQ0FBQSxHQUNULE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sR0FBRyxFQUFFLEdBQUMsSUFBQSxHQUNiLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFBQSxHQUNkLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFBQSxHQUNkLE9BQU8sSUFBSSxFQUFFLEdBQUMsSUFB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O0FBdERmO0FBdURRLFlBQVEsSUFBSSwwQkFBMEI7QUFDdEMsZUFBSyxVQUFMLG1CQUFZO0FBQUEsRUFDaEI7QUFBQSxFQUVNLGVBQWU7QUFBQTtBQUNqQixZQUFNLGNBQWMsTUFBTSxLQUFLLFNBQVM7QUFDeEMscUJBQWUsV0FBVztBQUMxQixZQUFNLEtBQUssaUJBQWlCO0FBQUEsSUFDaEM7QUFBQTtBQUFBLEVBRU0sZUFBZTtBQUFBO0FBQ2pCLFlBQU0sS0FBSyxTQUFTLFlBQVksQ0FBQztBQUFBLElBQ3JDO0FBQUE7QUFBQSxFQUVPLFdBQStCO0FBckUxQztBQXNFUSxZQUFPLFVBQUssVUFBTCxtQkFBWTtBQUFBLEVBQ3ZCO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJfX2V4dGVuZHMiLCAiX19hc3NpZ24iLCAiX19yZXN0IiwgIl9fZGVjb3JhdGUiLCAiX19wYXJhbSIsICJfX21ldGFkYXRhIiwgIl9fYXdhaXRlciIsICJfX2dlbmVyYXRvciIsICJfX2V4cG9ydFN0YXIiLCAiX192YWx1ZXMiLCAiX19yZWFkIiwgIl9fc3ByZWFkIiwgIl9fc3ByZWFkQXJyYXlzIiwgIl9fc3ByZWFkQXJyYXkiLCAiX19hd2FpdCIsICJfX2FzeW5jR2VuZXJhdG9yIiwgIl9fYXN5bmNEZWxlZ2F0b3IiLCAiX19hc3luY1ZhbHVlcyIsICJfX21ha2VUZW1wbGF0ZU9iamVjdCIsICJfX2ltcG9ydFN0YXIiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkSW4iLCAiX19jcmVhdGVCaW5kaW5nIiwgImV4cG9ydHMiLCAidiIsICJtb2R1bGUiLCAidCIsICJlIiwgIm4iLCAiciIsICJpIiwgInMiLCAidSIsICJNIiwgIm0iLCAiaCIsICIkIiwgImwiLCAieSIsICJnIiwgIkQiLCAidiIsICJvIiwgImQiLCAiYSIsICJmIiwgImMiLCAiX19pbXBvcnREZWZhdWx0IiwgIm1vZHVsZSIsICJ0IiwgImUiLCAiaSIsICJyIiwgInMiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAidGV4dCIsICJGaWx0ZXIiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfYSIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAidGV4dCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAicGFyc2VEYXRlIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAicGFyc2VEYXRlIiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19leHBvcnRTdGFyIiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydFN0YXIiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnRTdGFyIiwgIk1lcmlkaWVtIiwgInRleHQiLCAicGFyc2VEYXRlIiwgIk9wZXJhdG9ycyIsICJTdHJ1Y3R1cmFsQ2hhcmFjdGVycyIsICJUb2tlbnMiLCAicmVxdWlyZV9jb25zdCIsICJfX2Fzc2lnbiIsICJyZXF1aXJlX3V0aWxzIiwgIl9fc3ByZWFkQXJyYXlzIiwgIl9fc3ByZWFkQXJyYXlzIiwgInJlcXVpcmVfdXRpbHMiLCAicmVxdWlyZV9jb25zdCIsICJfX3NwcmVhZEFycmF5cyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsZW1lbnQiLCAiV2Vla2RheSIsICJkYXRldXRpbCIsICJJdGVyUmVzdWx0IiwgInRzbGliIiwgIkNhbGxiYWNrSXRlclJlc3VsdCIsICJUb1RleHQiLCAiUGFyc2VyIiwgInRleHQiLCAiRnJlcXVlbmN5IiwgInRleHQiLCAiVGltZSIsICJEYXRlVGltZSIsICJhdHRyIiwgIkRhdGVXaXRoWm9uZSIsICJkZWZhdWx0S2V5cyIsICJrZXkiLCAidmFsdWUiLCAiQ2FjaGUiLCAiaXRlbSIsICJpIiwgIkl0ZXJpbmZvIiwgIlJSdWxlIiwgInRleHQiLCAiem9uZWREYXRlIiwgIkRFRkFVTFRfT1BUSU9OUyIsICJ2YWwiLCAiaW5pdGlhbGl6ZU9wdGlvbnMiLCAiZGVmYXVsdEtleXMiLCAiUlJ1bGVTZXQiLCAiY2hpbGRyZW4iLCAidGV4dCIsICJTdGF0dXNUeXBlIiwgImRlZmF1bHRTZXR0aW5ncyIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgInZhdWx0IiwgIm1ldGFkYXRhQ2FjaGUiLCAidGV4dCIsICJlbGVtZW50IiwgInBFbGVtZW50IiwgImVsZW1lbnQiLCAiQ2FjaGUiLCAibWV0YWRhdGFDYWNoZSIsICJ2YXVsdCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImVsZW1lbnQiLCAidGV4dCIsICJlbGVtZW50IiwgImluc3RhbmNlIiwgImNyZWF0ZV9mcmFnbWVudCIsICJhdHRyIiwgImN0eCIsICJwYXJzZURhdGUiLCAicGFyc2VkU3RhcnREYXRlIiwgInBhcnNlZFNjaGVkdWxlZERhdGUiLCAicGFyc2VkRHVlRGF0ZSIsICJ0YXNrIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0YXNrIiwgImVsZW1lbnQiLCAiX2EiLCAic2VjdGlvbkluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYm9vblBhcnNlIiwgImVsZW1lbnQiLCAidGV4dCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInRleHQiLCAidXBkYXRlIiwgInRleHQiLCAic2V0dGluZ3MiLCAiaW1wb3J0X29ic2lkaWFuIiwgInNldHRpbmdzIiwgInNldHRpbmdzIiwgIkNhY2hlIl0KfQo=
