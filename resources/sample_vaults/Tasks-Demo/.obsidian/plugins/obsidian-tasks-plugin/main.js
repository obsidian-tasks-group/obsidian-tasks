"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

/*
License obsidian-tasks:
MIT License

Copyright (c) 2021 Martin Schenck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
License rrule (included library):
rrule.js: Library for working with recurrence rules for calendar dates.
=======================================================================

Copyright 2010, Jakub Roztocil <jakub@roztocil.name> and Lars Schöning

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of The author nor the names of its contributors may
       be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



./rrule.js and ./test/tests.js is based on python-dateutil. LICENCE:

python-dateutil - Extensions to the standard Python datetime module.
====================================================================

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
License chrono-node (included library):
The MIT License

Copyright (c) 2014, Wanasit Tanakitrungruang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, g = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function(t2, e2, n2) {
        var r2;
        if (!t2)
          return D;
        if ("string" == typeof t2)
          v[t2] && (r2 = t2), e2 && (v[t2] = e2, r2 = t2);
        else {
          var i2 = t2.name;
          v[i2] = t2, r2 = i2;
        }
        return !n2 && r2 && (D = r2), r2 || !n2 && D;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match(l);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), $2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, l2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $2(1, 0) : $2(31, 11);
            case f:
              return r2 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
              return $2(r2 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $2 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y2 = function(t2) {
            var e2 = w($2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || $;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || l2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b = _.prototype;
      return w.prototype = b, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        b[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault2(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault2(require_quarterOfYear());
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference, knownComponents) {
        this.reference = reference;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        return new Date(date.getTime() + this.getSystemTimezoneAdjustmentMinute(date) * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      getSystemTimezoneAdjustmentMinute(date) {
        var _a, _b;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_b = (_a = this.get("timezoneOffset")) !== null && _a !== void 0 ? _a : this.reference.timezoneOffset) !== null && _b !== void 0 ? _b : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
      static createRelativeFromReference(reference, fragments) {
        let date = dayjs_1.default(reference.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference, index, text2, start, end) {
        this.reference = reference;
        this.refDate = reference.instant;
        this.index = index;
        this.text = text2;
        this.start = start || new ParsingComponents(reference);
        this.end = end;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context) {
        const innerPattern = this.innerPattern(context);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i = 2; i < match.length; i++) {
          match[i - 1] = match[i];
        }
        return this.innerExtract(context, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context, match) {
        const startComponents = this.extractPrimaryTimeComponents(context, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text2 = match[0].substring(match[1].length);
        const result = context.createParsingResult(index, text2, startComponents);
        match.index += match[0].length;
        const remainingText = context.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text2.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context, match, strict = false) {
        const components = context.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context, match, result) {
        const components = context.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter = class {
      refine(context, results) {
        return results.filter((r) => this.isValid(context, r));
      }
    };
    exports.Filter = Filter;
    var MergingRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i = 1; i < results.length; i++) {
          nextResult = results[i];
          const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left = curResult;
            const right = nextResult;
            const mergedResult = this.mergeResults(textBetween, left, right, context);
            context.debug(() => {
              console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context, results) {
        var _a;
        const timezoneOverrides = (_a = context.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i = 1; i < results.length; i++) {
          const result = results[i];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context, results) {
        if (!context.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
              result.start.imply("year", result.start.get("year") + 1);
              context.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context, result);
        }
        return true;
      }
      isStrictModeValid(context, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset = hourOffset * 60;
            if (offset < 0) {
              offset -= minuteOffset;
            } else {
              offset += minuteOffset;
            }
            components["timezoneOffset"] = offset;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault2(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault2(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault2(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault2(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault2(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference) {
      return theDayBefore(reference, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference, numDay) {
      return theDayAfter(reference, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference) {
      return theDayAfter(reference, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference, nDays) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference, implyHour = 22) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference, implyHour = 0) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference, implyHour = 20) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context.reference);
          case "today":
            return references.today(context.reference);
          case "yesterday":
            return references.yesterday(context.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context.reference);
          case "tonight":
            return references.tonight(context.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/calculation/weeks.js
var require_weeks = __commonJS({
  "node_modules/chrono-node/dist/calculation/weeks.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDayJSClosestWeekday = exports.toDayJSWeekday = void 0;
    var dayjs_1 = __importDefault2(require_dayjs_min());
    function toDayJSWeekday(refDate, offset, modifier) {
      if (!modifier) {
        return toDayJSClosestWeekday(refDate, offset);
      }
      let date = dayjs_1.default(refDate);
      switch (modifier) {
        case "this":
          date = date.day(offset);
          break;
        case "next":
          date = date.day(offset + 7);
          break;
        case "last":
          date = date.day(offset - 7);
          break;
      }
      return date;
    }
    exports.toDayJSWeekday = toDayJSWeekday;
    function toDayJSClosestWeekday(refDate, offset) {
      let date = dayjs_1.default(refDate);
      const refOffset = date.day();
      if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset - 7);
      } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset + 7);
      } else {
        date = date.day(offset);
      }
      return date;
    }
    exports.toDayJSClosestWeekday = toDayJSClosestWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text2, referenceDate, option) {
        const results = this.parse(text2, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text2, referenceDate, option) {
        const context = new ParsingContext(text2, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a, b) => {
          return a.index - b.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context, results);
        });
        return results;
      }
      static executeParser(context, parser) {
        const results = [];
        const pattern = parser.pattern(context);
        const originalText = context.text;
        let remainingText = context.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context.createParsingResult(match.index, match[0], result);
          }
          context.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text2, refDate, option) {
        this.text = text2;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text2 = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start = startComponents ? this.createParsingComponents(startComponents) : null;
        const end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text2, start, end);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text2 = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text2.match(/^\d\.\d$/) || text2.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context.createParsingResult(index, text2);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault2(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault2(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault2(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault2(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault2(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault2(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault2(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault2(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault2(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault2(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault2(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault2(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault2(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault2(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault2(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault2(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var references = __importStar2(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context.reference);
            break;
          case "heute":
            component = references.today(context.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault2(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault2(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault2(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault2(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault2(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault2(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault2(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault2(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault2(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault2(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar2(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context.reference);
          case "aujourd'hui":
            return references.today(context.reference);
          case "hier":
            return references.yesterday(context.reference);
          case "demain":
            return references.tomorrow(context.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault2(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault2(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault2(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault2(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault2(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault2(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault2(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault2(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault2(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault2(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault2(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text2) {
      return String(text2).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment = dayjs_1.default(context.refDate);
          components.assign("year", moment.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar2(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const text2 = match[0];
        const date = dayjs_1.default(context.refDate);
        const components = context.createParsingComponents();
        switch (text2) {
          case "\u6628\u65E5":
            return references.yesterday(context.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context.reference);
        }
        if (text2 == "\u4ECA\u591C" || text2 == "\u4ECA\u5915" || text2 == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text2.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault2(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault2(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault2(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context.reference);
          case "hoje":
            return references.today(context.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context.reference);
          case "ontem":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_2.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault2(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault2(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault2(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault2(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault2(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault2(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault2(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context.reference);
          case "vandaag":
            return references.today(context.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context.reference);
          case "gisteren":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context.refDate.getDate());
          component.assign("month", context.refDate.getMonth() + 1);
          component.assign("year", context.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = context.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context.createParsingComponents();
        const targetDate = dayjs_2.default(context.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault2(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault2(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault2(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault2(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault2(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault2(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault2(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault2(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault2(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault2(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault2(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault2(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault2(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault2(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault2(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u5E7E") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault2(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault2(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault2(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault2(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault2(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault2(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault2(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault2(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u51E0") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault2(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault2(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault2(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault2(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault2(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault2(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault2(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault2(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault2(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar2(require_hant(), exports);
    exports.hans = __importStar2(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u0435\u043C\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault2(require_AbstractMergeDateRangeRefiner());
    var xf = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = xf;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault2(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        const lowerText = match[1].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar2(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault2(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_2.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault2(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault2(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault2(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault2(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault2(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault2(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault2(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault2(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault2(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault2(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault2(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault2(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault2(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault2(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar2(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var de = __importStar2(require_de());
    exports.de = de;
    var fr = __importStar2(require_fr());
    exports.fr = fr;
    var ja = __importStar2(require_ja());
    exports.ja = ja;
    var pt = __importStar2(require_pt());
    exports.pt = pt;
    var nl = __importStar2(require_nl());
    exports.nl = nl;
    var zh = __importStar2(require_zh());
    exports.zh = zh;
    var ru = __importStar2(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
  }
});

// node_modules/boon-js/lib/types.js
var require_types = __commonJS({
  "node_modules/boon-js/lib/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var Operators;
    (function(Operators2) {
      Operators2["AND"] = "AND";
      Operators2["OR"] = "OR";
      Operators2["XOR"] = "XOR";
      Operators2["NOT"] = "NOT";
    })(Operators = exports.Operators || (exports.Operators = {}));
    var StructuralCharacters;
    (function(StructuralCharacters2) {
      StructuralCharacters2["OPEN_PARENTHESIS"] = "(";
      StructuralCharacters2["CLOSE_PARENTHESIS"] = ")";
    })(StructuralCharacters = exports.StructuralCharacters || (exports.StructuralCharacters = {}));
    var Tokens;
    (function(Tokens2) {
      Tokens2["IDENTIFIER"] = "IDENTIFIER";
      Tokens2["OPERATOR"] = "OPERATOR";
      Tokens2["STRUCTURAL_CHARACTER"] = "STRUCTURAL_CHARACTER";
      Tokens2["EOF"] = "EOF";
      Tokens2["COMMENT"] = "COMMENT";
    })(Tokens = exports.Tokens || (exports.Tokens = {}));
  }
});

// node_modules/boon-js/lib/parse/const.js
var require_const = __commonJS({
  "node_modules/boon-js/lib/parse/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.OPERATOR_PRECEDENCE = {
      NOT: 0,
      XOR: 1,
      AND: 2,
      OR: 3
    };
    exports.VALID_TOKENS = {
      identifierOnly: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        }
      ],
      identifierOrNot: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }
      ],
      binaryOperator: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR }
      ],
      binaryOperatorOrClose: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.CLOSE_PARENTHESIS
        }
      ]
    };
  }
});

// node_modules/boon-js/lib/lex/const.js
var require_const2 = __commonJS({
  "node_modules/boon-js/lib/lex/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.STRUCTURAL_CHARACTERS = {
      "(": types_1.StructuralCharacters.OPEN_PARENTHESIS,
      ")": types_1.StructuralCharacters.CLOSE_PARENTHESIS
    };
    exports.OPERATORS = {
      AND: types_1.Operators.AND,
      OR: types_1.Operators.OR,
      XOR: types_1.Operators.XOR,
      NOT: types_1.Operators.NOT
    };
    exports.SEPARATORS = new Set([
      32,
      9,
      10,
      13
    ].map(function(separator) {
      return String.fromCodePoint(separator);
    }));
    exports.QUOTED_IDENTIFIER_DELIMITER = String.fromCodePoint(34);
    exports.COMMENT_DELIMITER = String.fromCodePoint(35);
    exports.EOL = String.fromCodePoint(10);
    exports.ESCAPE_CHARACTER = String.fromCodePoint(92);
  }
});

// node_modules/boon-js/lib/lex/utils.js
var require_utils = __commonJS({
  "node_modules/boon-js/lib/lex/utils.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const2();
    exports.createResult = function(name, value, remainingString) {
      return {
        token: __assign2({ name }, value !== null ? { value } : {}),
        remainingString
      };
    };
    exports.getComment = function(expression) {
      var tokenEnd = expression.length;
      for (var i = 0; i < expression.length; i += 1) {
        var letter = expression[i];
        if (letter === const_1.EOL) {
          tokenEnd = i;
          break;
        }
      }
      return exports.createResult(types_1.Tokens.COMMENT, expression.slice(0, tokenEnd), expression.slice(tokenEnd + 1));
    };
    exports.getQuotedIdentifier = function(expression) {
      var escapeQuotation = false;
      var value = "";
      var tokenEnd = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenEnd === null) {
          if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
            if (escapeQuotation) {
              value = value.slice(-1) + const_1.QUOTED_IDENTIFIER_DELIMITER;
            } else {
              tokenEnd = i;
            }
          } else {
            if (char === const_1.ESCAPE_CHARACTER) {
              escapeQuotation = true;
            } else {
              escapeQuotation = false;
            }
            value = value += char;
          }
        } else {
          if (!const_1.SEPARATORS.has(char) && !const_1.STRUCTURAL_CHARACTERS[char]) {
            throw new Error("Unexpected character: " + char + " Expected ) character or separator");
          }
          break;
        }
      }
      if (tokenEnd === null) {
        throw new Error("Unexpected end of expression: expected " + const_1.QUOTED_IDENTIFIER_DELIMITER + " character");
      }
      return exports.createResult(types_1.Tokens.IDENTIFIER, value, expression.slice(tokenEnd + 1));
    };
  }
});

// node_modules/boon-js/lib/lex/lex.js
var require_lex = __commonJS({
  "node_modules/boon-js/lib/lex/lex.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const2();
    var utils_1 = require_utils();
    exports.lex = function(expression) {
      var tokenStart = null;
      var tokenEnd = null;
      var delimitingCharacter = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenStart === null) {
          if (!const_1.SEPARATORS.has(char)) {
            var structuralChar = const_1.STRUCTURAL_CHARACTERS[char];
            if (structuralChar) {
              var nextChar = expression[i + 1];
              if (structuralChar === types_1.StructuralCharacters.CLOSE_PARENTHESIS && nextChar && !const_1.SEPARATORS.has(nextChar) && nextChar !== types_1.StructuralCharacters.CLOSE_PARENTHESIS) {
                throw new Error("Unexpected character: " + nextChar + ". A closing parenthesis should be followed by another closing parenthesis or whitespace");
              }
              return utils_1.createResult(types_1.Tokens.STRUCTURAL_CHARACTER, const_1.STRUCTURAL_CHARACTERS[char], expression.slice(i + 1));
            }
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
              return utils_1.getQuotedIdentifier(expression.slice(i + 1));
            }
            if (char === const_1.COMMENT_DELIMITER) {
              return utils_1.getComment(expression.slice(i + 1));
            }
            tokenStart = i;
          }
        } else {
          if (const_1.SEPARATORS.has(char) || const_1.STRUCTURAL_CHARACTERS[char]) {
            tokenEnd = i;
            delimitingCharacter = char;
            break;
          } else {
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER || char === const_1.COMMENT_DELIMITER) {
              throw new Error("Unexpected character: " + char);
            }
          }
        }
      }
      if (tokenStart !== null) {
        tokenEnd = tokenEnd !== null && tokenEnd !== void 0 ? tokenEnd : expression.length;
        var value = expression.slice(tokenStart, tokenEnd);
        var remainingString = expression.slice(tokenEnd);
        if (const_1.OPERATORS[value]) {
          if (delimitingCharacter && !const_1.SEPARATORS.has(delimitingCharacter)) {
            throw new Error("Unexpected character: " + delimitingCharacter + ". Operators should be separated using whitespace");
          }
          return utils_1.createResult(types_1.Tokens.OPERATOR, const_1.OPERATORS[value], remainingString);
        } else {
          return utils_1.createResult(types_1.Tokens.IDENTIFIER, value, remainingString);
        }
      }
      return utils_1.createResult(types_1.Tokens.EOF, null, "");
    };
  }
});

// node_modules/boon-js/lib/parse/utils.js
var require_utils2 = __commonJS({
  "node_modules/boon-js/lib/parse/utils.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var lex_1 = require_lex();
    var types_1 = require_types();
    var const_1 = require_const();
    exports.newTokenGenerator = function(expression) {
      var remainingExpression = expression;
      return function(validTokens, endIsValid) {
        if (endIsValid === void 0) {
          endIsValid = false;
        }
        while (true) {
          var _a = lex_1.lex(remainingExpression), token = _a.token, remainingString = _a.remainingString;
          remainingExpression = remainingString;
          if (token.name !== types_1.Tokens.COMMENT) {
            exports.validateToken(token, validTokens, endIsValid);
            return token;
          }
        }
      };
    };
    exports.getValue = function(getNextToken, parser) {
      var nextToken = getNextToken(const_1.VALID_TOKENS.identifierOrNot);
      var negatedValue = nextToken.value === types_1.Operators.NOT;
      if (negatedValue) {
        nextToken = getNextToken(const_1.VALID_TOKENS.identifierOnly);
      }
      var value = nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER ? parser(getNextToken, true) : [nextToken];
      return negatedValue ? __spreadArrays2(value, [{ name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }]) : value;
    };
    exports.previousOperatorTakesPrecedent = function(previousOperator, nextOperator) {
      return const_1.OPERATOR_PRECEDENCE[previousOperator] <= const_1.OPERATOR_PRECEDENCE[nextOperator];
    };
    exports.validateToken = function(token, validTokens, endIsValid) {
      if (endIsValid === void 0) {
        endIsValid = false;
      }
      if (token.name === types_1.Tokens.EOF) {
        if (endIsValid) {
          return;
        }
        throw new Error("Unexpected end of expression");
      }
      for (var _i = 0, validTokens_1 = validTokens; _i < validTokens_1.length; _i++) {
        var validToken = validTokens_1[_i];
        if (validToken.name === token.name) {
          if (!validToken.value || validToken.value === token.value) {
            return;
          }
        }
      }
      throw new TypeError("Invalid token");
    };
  }
});

// node_modules/boon-js/lib/parse/parse.js
var require_parse = __commonJS({
  "node_modules/boon-js/lib/parse/parse.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var types_1 = require_types();
    var const_1 = require_const();
    var utils_1 = require_utils2();
    exports.parse = function(expression) {
      if (typeof expression !== "string") {
        throw new Error("Expected string but received " + typeof expression);
      }
      var getNextToken = utils_1.newTokenGenerator(expression);
      return parseInternal(getNextToken);
    };
    var parseInternal = function(getNextToken, nested) {
      if (nested === void 0) {
        nested = false;
      }
      var output = __spreadArrays2(utils_1.getValue(getNextToken, parseInternal));
      var operators = [];
      while (true) {
        var validTokens = nested ? const_1.VALID_TOKENS.binaryOperatorOrClose : const_1.VALID_TOKENS.binaryOperator;
        var nextToken = getNextToken(validTokens, !nested);
        if (nextToken.name === types_1.Tokens.EOF || nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER) {
          return __spreadArrays2(output, __spreadArrays2(operators).reverse());
        }
        while (operators.length) {
          var previousOperator = operators[operators.length - 1] || null;
          if (previousOperator && utils_1.previousOperatorTakesPrecedent(previousOperator.value, nextToken.value)) {
            output = __spreadArrays2(output, [previousOperator]);
            operators = operators.slice(0, -1);
          } else {
            break;
          }
        }
        operators = __spreadArrays2(operators, [nextToken]);
        output = __spreadArrays2(output, utils_1.getValue(getNextToken, parseInternal));
      }
    };
  }
});

// node_modules/boon-js/lib/evaluate/utils.js
var require_utils3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var types_1 = require_types();
    exports.andUtil = function(left, right) {
      return left && right;
    };
    exports.orUtil = function(left, right) {
      return left || right;
    };
    exports.xorUtil = function(left, right) {
      return !(left === right);
    };
    exports.notUtil = function(identifier) {
      return !identifier;
    };
    exports.isIdentifier = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.IDENTIFIER && typeof value === "string";
    };
    exports.isOperator = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.OPERATOR && typeof value === "string";
    };
    exports.throwInvalidExpression = function(message) {
      throw new TypeError("Invalid postfix expression: " + message);
    };
  }
});

// node_modules/boon-js/lib/evaluate/const.js
var require_const3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/const.js"(exports) {
    "use strict";
    var _a;
    exports.__esModule = true;
    var types_1 = require_types();
    var utils_1 = require_utils3();
    exports.OPERATOR_MAP = (_a = {}, _a[types_1.Operators.AND] = utils_1.andUtil, _a[types_1.Operators.OR] = utils_1.orUtil, _a[types_1.Operators.XOR] = utils_1.xorUtil, _a);
  }
});

// node_modules/boon-js/lib/evaluate/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/boon-js/lib/evaluate/evaluate.js"(exports) {
    "use strict";
    var __spreadArrays2 = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    exports.__esModule = true;
    var parse_1 = require_parse();
    var types_1 = require_types();
    var const_1 = require_const3();
    var utils_1 = require_utils3();
    exports.getEvaluator = function(expression) {
      var parsedExpression = parse_1.parse(expression);
      return function(booleanMap) {
        return exports.evaluate(parsedExpression, booleanMap);
      };
    };
    exports.evaluate = function(expression, booleanMap) {
      if (!Array.isArray(expression)) {
        throw new Error(expression + " should be an array. evaluate takes in a parsed expression. Use in combination with parse or use getEvaluator");
      }
      var evaluatedExpression = expression.reduce(function(stack, token, i) {
        if (!(token && (utils_1.isIdentifier(token) || utils_1.isOperator(token)))) {
          throw new Error("Invalid token: " + token + ". Found in parsed expression at index " + i);
        }
        if (token.name === types_1.Tokens.IDENTIFIER) {
          return __spreadArrays2(stack, [Boolean(booleanMap[token.value])]);
        }
        var secondLastItem = stack[stack.length - 2];
        var lastItem = stack[stack.length - 1];
        if (token.value === types_1.Operators.NOT) {
          if (lastItem === void 0) {
            utils_1.throwInvalidExpression("missing identifier");
          }
          return __spreadArrays2(stack.slice(0, -1), [utils_1.notUtil(lastItem)]);
        }
        if (lastItem === void 0 || secondLastItem === void 0) {
          utils_1.throwInvalidExpression("missing identifier");
        }
        var operatorUtil = const_1.OPERATOR_MAP[token.value];
        if (!operatorUtil) {
          utils_1.throwInvalidExpression("unknown operator");
        }
        return __spreadArrays2(stack.slice(0, -2), [operatorUtil(secondLastItem, lastItem)]);
      }, []);
      if (evaluatedExpression.length !== 1) {
        utils_1.throwInvalidExpression("too many identifiers after evaluation");
      }
      return evaluatedExpression[0];
    };
  }
});

// node_modules/boon-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/boon-js/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var evaluate_1 = require_evaluate();
    exports.getEvaluator = evaluate_1.getEvaluator;
    exports.evaluate = evaluate_1.evaluate;
    var parse_1 = require_parse();
    exports.parse = parse_1.parse;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TasksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/Cache.ts
var import_obsidian3 = require("obsidian");

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_maxConcurrency, _cancelError = E_CANCELED) {
    this._maxConcurrency = _maxConcurrency;
    this._cancelError = _cancelError;
    this._queue = [];
    this._waiters = [];
    if (_maxConcurrency <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
    this._value = _maxConcurrency;
  }
  acquire() {
    const locked = this.isLocked();
    const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));
    if (!locked)
      this._dispatch();
    return ticketPromise;
  }
  runExclusive(callback) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire();
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (!this.isLocked()) {
        return Promise.resolve();
      }
      const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));
      return waitPromise;
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  release() {
    if (this._maxConcurrency > 1) {
      throw new Error("this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
    }
    if (this._currentReleaser) {
      const releaser = this._currentReleaser;
      this._currentReleaser = void 0;
      releaser();
    }
  }
  cancel() {
    this._queue.forEach((ticket) => ticket.reject(this._cancelError));
    this._queue = [];
  }
  _dispatch() {
    const nextTicket = this._queue.shift();
    if (!nextTicket)
      return;
    let released = false;
    this._currentReleaser = () => {
      if (released)
        return;
      released = true;
      this._value++;
      this._resolveWaiters();
      this._dispatch();
    };
    nextTicket.resolve([this._value--, this._currentReleaser]);
  }
  _resolveWaiters() {
    this._waiters.forEach((waiter) => waiter.resolve());
    this._waiters = [];
  }
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/Task.ts
var import_obsidian2 = require("obsidian");

// src/File.ts
var import_obsidian = require("obsidian");

// src/config/Settings.ts
var defaultSettings = {
  globalFilter: "",
  removeGlobalFilter: false,
  setDoneDate: true,
  autoSuggestInEditor: true,
  autoSuggestMinMatch: 0,
  autoSuggestMaxItems: 6
};
var settings = __spreadValues({}, defaultSettings);
var getSettings = () => {
  return __spreadValues({}, settings);
};
var updateSettings = (newSettings) => {
  settings = __spreadValues(__spreadValues({}, settings), newSettings);
  return getSettings();
};

// src/File.ts
var metadataCache;
var vault;
var initializeFile = ({
  metadataCache: newMetadataCache,
  vault: newVault
}) => {
  metadataCache = newMetadataCache;
  vault = newVault;
};
var replaceTaskWithTasks = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks
}) {
  if (vault === void 0 || metadataCache === void 0) {
    console.error("Tasks: cannot use File before initializing it.");
    return;
  }
  if (!Array.isArray(newTasks)) {
    newTasks = [newTasks];
  }
  tryRepetitive({
    originalTask,
    newTasks,
    vault,
    metadataCache,
    previousTries: 0
  });
});
var tryRepetitive = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks,
  vault: vault2,
  metadataCache: metadataCache2,
  previousTries
}) {
  const retry = () => {
    if (previousTries > 10) {
      console.error(
        "Tasks: Too many retries. File update not possible ..."
      );
      return;
    }
    const timeout = Math.min(Math.pow(10, previousTries), 100);
    setTimeout(() => {
      tryRepetitive({
        originalTask,
        newTasks,
        vault: vault2,
        metadataCache: metadataCache2,
        previousTries: previousTries + 1
      });
    }, timeout);
  };
  const file = vault2.getAbstractFileByPath(originalTask.path);
  if (!(file instanceof import_obsidian.TFile)) {
    console.warn(
      `Tasks: No file found for task ${originalTask.description}. Retrying ...`
    );
    return retry();
  }
  if (file.extension !== "md") {
    console.error(
      "Tasks: Only supporting files with the .md file extension."
    );
    return;
  }
  const fileCache = metadataCache2.getFileCache(file);
  if (fileCache == void 0 || fileCache === null) {
    console.warn(
      `Tasks: No file cache found for file ${file.path}. Retrying ...`
    );
    return retry();
  }
  const listItemsCache = fileCache.listItems;
  if (listItemsCache === void 0 || listItemsCache.length === 0) {
    console.warn(
      `Tasks: No list items found in file cache of ${file.path}. Retrying ...`
    );
    return retry();
  }
  const fileContent = yield vault2.read(file);
  const fileLines = fileContent.split("\n");
  const { globalFilter } = getSettings();
  let listItem;
  let sectionIndex = 0;
  for (const listItemCache of listItemsCache) {
    if (listItemCache.position.start.line < originalTask.sectionStart) {
      continue;
    }
    if (listItemCache.task === void 0) {
      continue;
    }
    const line = fileLines[listItemCache.position.start.line];
    if (line.includes(globalFilter)) {
      if (sectionIndex === originalTask.sectionIndex) {
        listItem = listItemCache;
        break;
      }
      sectionIndex++;
    }
  }
  if (listItem === void 0) {
    console.error("Tasks: could not find task to toggle in the file.");
    return;
  }
  const updatedFileLines = [
    ...fileLines.slice(0, listItem.position.start.line),
    ...newTasks.map((task) => task.toFileLineString()),
    ...fileLines.slice(listItem.position.start.line + 1)
  ];
  yield vault2.modify(file, updatedFileLines.join("\n"));
});

// src/LayoutOptions.ts
var LayoutOptions = class {
  constructor() {
    this.hideTaskCount = false;
    this.hideBacklinks = false;
    this.hidePriority = false;
    this.hideStartDate = false;
    this.hideScheduledDate = false;
    this.hideDoneDate = false;
    this.hideDueDate = false;
    this.hideRecurrenceRule = false;
    this.hideEditButton = false;
    this.shortMode = false;
  }
};

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = function() {
  function Weekday2(weekday, n) {
    if (n === 0)
      throw new Error("Can't create weekday with n == 0");
    this.weekday = weekday;
    this.n = n;
  }
  Weekday2.fromStr = function(str) {
    return new Weekday2(ALL_WEEKDAYS.indexOf(str));
  };
  Weekday2.prototype.nth = function(n) {
    return this.n === n ? this : new Weekday2(this.weekday, n);
  };
  Weekday2.prototype.equals = function(other) {
    return this.weekday === other.weekday && this.n === other.n;
  };
  Weekday2.prototype.toString = function() {
    var s = ALL_WEEKDAYS[this.weekday];
    if (this.n)
      s = (this.n > 0 ? "+" : "") + String(this.n) + s;
    return s;
  };
  Weekday2.prototype.getJsWeekday = function() {
    return this.weekday === 6 ? 0 : this.weekday + 1;
  };
  return Weekday2;
}();

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var dateutil;
(function(dateutil2) {
  dateutil2.MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  dateutil2.ONE_DAY = 1e3 * 60 * 60 * 24;
  dateutil2.MAXYEAR = 9999;
  dateutil2.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1));
  dateutil2.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
  dateutil2.getYearDay = function(date) {
    var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    return Math.ceil((dateNoTime.valueOf() - new Date(date.getUTCFullYear(), 0, 1).valueOf()) / dateutil2.ONE_DAY) + 1;
  };
  dateutil2.isLeapYear = function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  };
  dateutil2.isDate = function(value) {
    return value instanceof Date;
  };
  dateutil2.isValidDate = function(value) {
    return dateutil2.isDate(value) && !isNaN(value.getTime());
  };
  dateutil2.tzOffset = function(date) {
    return date.getTimezoneOffset() * 60 * 1e3;
  };
  dateutil2.daysBetween = function(date1, date2) {
    var date1ms = date1.getTime() - dateutil2.tzOffset(date1);
    var date2ms = date2.getTime() - dateutil2.tzOffset(date2);
    var differencems = date1ms - date2ms;
    return Math.round(differencems / dateutil2.ONE_DAY);
  };
  dateutil2.toOrdinal = function(date) {
    return dateutil2.daysBetween(date, dateutil2.ORDINAL_BASE);
  };
  dateutil2.fromOrdinal = function(ordinal) {
    return new Date(dateutil2.ORDINAL_BASE.getTime() + ordinal * dateutil2.ONE_DAY);
  };
  dateutil2.getMonthDays = function(date) {
    var month = date.getUTCMonth();
    return month === 1 && dateutil2.isLeapYear(date.getUTCFullYear()) ? 29 : dateutil2.MONTH_DAYS[month];
  };
  dateutil2.getWeekday = function(date) {
    return dateutil2.PY_WEEKDAYS[date.getUTCDay()];
  };
  dateutil2.monthRange = function(year, month) {
    var date = new Date(Date.UTC(year, month, 1));
    return [dateutil2.getWeekday(date), dateutil2.getMonthDays(date)];
  };
  dateutil2.combine = function(date, time) {
    time = time || date;
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
  };
  dateutil2.clone = function(date) {
    var dolly = new Date(date.getTime());
    return dolly;
  };
  dateutil2.cloneDates = function(dates) {
    var clones = [];
    for (var i = 0; i < dates.length; i++) {
      clones.push(dateutil2.clone(dates[i]));
    }
    return clones;
  };
  dateutil2.sort = function(dates) {
    dates.sort(function(a, b) {
      return a.getTime() - b.getTime();
    });
  };
  dateutil2.timeToUntilString = function(time, utc) {
    if (utc === void 0) {
      utc = true;
    }
    var date = new Date(time);
    return [
      padStart(date.getUTCFullYear().toString(), 4, "0"),
      padStart(date.getUTCMonth() + 1, 2, "0"),
      padStart(date.getUTCDate(), 2, "0"),
      "T",
      padStart(date.getUTCHours(), 2, "0"),
      padStart(date.getUTCMinutes(), 2, "0"),
      padStart(date.getUTCSeconds(), 2, "0"),
      utc ? "Z" : ""
    ].join("");
  };
  dateutil2.untilStringToDate = function(until) {
    var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
    var bits = re.exec(until);
    if (!bits)
      throw new Error("Invalid UNTIL value: ".concat(until));
    return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
  };
})(dateutil || (dateutil = {}));
var dateutil_default = dateutil;

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = function() {
  function IterResult2(method, args) {
    this.minDate = null;
    this.maxDate = null;
    this._result = [];
    this.total = 0;
    this.method = method;
    this.args = args;
    if (method === "between") {
      this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
      this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
    } else if (method === "before") {
      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
    } else if (method === "after") {
      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
    }
  }
  IterResult2.prototype.accept = function(date) {
    ++this.total;
    var tooEarly = this.minDate && date < this.minDate;
    var tooLate = this.maxDate && date > this.maxDate;
    if (this.method === "between") {
      if (tooEarly)
        return true;
      if (tooLate)
        return false;
    } else if (this.method === "before") {
      if (tooLate)
        return false;
    } else if (this.method === "after") {
      if (tooEarly)
        return true;
      this.add(date);
      return false;
    }
    return this.add(date);
  };
  IterResult2.prototype.add = function(date) {
    this._result.push(date);
    return true;
  };
  IterResult2.prototype.getValue = function() {
    var res = this._result;
    switch (this.method) {
      case "all":
      case "between":
        return res;
      case "before":
      case "after":
      default:
        return res.length ? res[res.length - 1] : null;
    }
  };
  IterResult2.prototype.clone = function() {
    return new IterResult2(this.method, this.args);
  };
  return IterResult2;
}();
var iterresult_default = IterResult;

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = function(_super) {
  __extends(CallbackIterResult2, _super);
  function CallbackIterResult2(method, args, iterator) {
    var _this = _super.call(this, method, args) || this;
    _this.iterator = iterator;
    return _this;
  }
  CallbackIterResult2.prototype.add = function(date) {
    if (this.iterator(date, this._result.length)) {
      this._result.push(date);
      return true;
    }
    return false;
  };
  return CallbackIterResult2;
}(iterresult_default);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = function() {
  function ToText2(rrule, gettext, language, dateFormatter) {
    if (gettext === void 0) {
      gettext = defaultGetText;
    }
    if (language === void 0) {
      language = i18n_default;
    }
    if (dateFormatter === void 0) {
      dateFormatter = defaultDateFormatter;
    }
    this.text = [];
    this.language = language || i18n_default;
    this.gettext = gettext;
    this.dateFormatter = dateFormatter;
    this.rrule = rrule;
    this.options = rrule.options;
    this.origOptions = rrule.origOptions;
    if (this.origOptions.bymonthday) {
      var bymonthday = [].concat(this.options.bymonthday);
      var bynmonthday = [].concat(this.options.bynmonthday);
      bymonthday.sort(function(a, b) {
        return a - b;
      });
      bynmonthday.sort(function(a, b) {
        return b - a;
      });
      this.bymonthday = bymonthday.concat(bynmonthday);
      if (!this.bymonthday.length)
        this.bymonthday = null;
    }
    if (isPresent(this.origOptions.byweekday)) {
      var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
      var days = String(byweekday);
      this.byweekday = {
        allWeeks: byweekday.filter(function(weekday) {
          return !weekday.n;
        }),
        someWeeks: byweekday.filter(function(weekday) {
          return Boolean(weekday.n);
        }),
        isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
        isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
      };
      var sortWeekDays = function(a, b) {
        return a.weekday - b.weekday;
      };
      this.byweekday.allWeeks.sort(sortWeekDays);
      this.byweekday.someWeeks.sort(sortWeekDays);
      if (!this.byweekday.allWeeks.length)
        this.byweekday.allWeeks = null;
      if (!this.byweekday.someWeeks.length)
        this.byweekday.someWeeks = null;
    } else {
      this.byweekday = null;
    }
  }
  ToText2.isFullyConvertible = function(rrule) {
    var canConvert = true;
    if (!(rrule.options.freq in ToText2.IMPLEMENTED))
      return false;
    if (rrule.origOptions.until && rrule.origOptions.count)
      return false;
    for (var key in rrule.origOptions) {
      if (contains(["dtstart", "wkst", "freq"], key))
        return true;
      if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
        return false;
    }
    return canConvert;
  };
  ToText2.prototype.isFullyConvertible = function() {
    return ToText2.isFullyConvertible(this.rrule);
  };
  ToText2.prototype.toString = function() {
    var gettext = this.gettext;
    if (!(this.options.freq in ToText2.IMPLEMENTED)) {
      return gettext("RRule error: Unable to fully convert this rrule to text");
    }
    this.text = [gettext("every")];
    this[RRule.FREQUENCIES[this.options.freq]]();
    if (this.options.until) {
      this.add(gettext("until"));
      var until = this.options.until;
      this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
    } else if (this.options.count) {
      this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
    }
    if (!this.isFullyConvertible())
      this.add(gettext("(~ approximate)"));
    return this.text.join("");
  };
  ToText2.prototype.HOURLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
  };
  ToText2.prototype.MINUTELY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
  };
  ToText2.prototype.DAILY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
    } else {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    }
    if (this.origOptions.bymonth) {
      this.add(gettext("in"));
      this._bymonth();
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };
  ToText2.prototype.WEEKLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
    }
    if (this.byweekday && this.byweekday.isWeekdays) {
      if (this.options.interval === 1) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(gettext("on")).add(gettext("weekdays"));
      }
    } else if (this.byweekday && this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    } else {
      if (this.options.interval === 1)
        this.add(gettext("week"));
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
    }
  };
  ToText2.prototype.MONTHLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(gettext("months"));
        if (this.plural(this.options.interval))
          this.add(gettext("in"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(gettext("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };
  ToText2.prototype.YEARLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
        this.add(gettext("years"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }
    if (this.options.byyearday) {
      this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
    }
    if (this.options.byweekno) {
      this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
    }
  };
  ToText2.prototype._bymonthday = function() {
    var gettext = this.gettext;
    if (this.byweekday && this.byweekday.allWeeks) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
    } else {
      this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
    }
  };
  ToText2.prototype._byweekday = function() {
    var gettext = this.gettext;
    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
    }
    if (this.byweekday.someWeeks) {
      if (this.byweekday.allWeeks)
        this.add(gettext("and"));
      this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
    }
  };
  ToText2.prototype._byhour = function() {
    var gettext = this.gettext;
    this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
  };
  ToText2.prototype._bymonth = function() {
    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
  };
  ToText2.prototype.nth = function(n) {
    n = parseInt(n.toString(), 10);
    var nth;
    var gettext = this.gettext;
    if (n === -1)
      return gettext("last");
    var npos = Math.abs(n);
    switch (npos) {
      case 1:
      case 21:
      case 31:
        nth = npos + gettext("st");
        break;
      case 2:
      case 22:
        nth = npos + gettext("nd");
        break;
      case 3:
      case 23:
        nth = npos + gettext("rd");
        break;
      default:
        nth = npos + gettext("th");
    }
    return n < 0 ? nth + " " + gettext("last") : nth;
  };
  ToText2.prototype.monthtext = function(m) {
    return this.language.monthNames[m - 1];
  };
  ToText2.prototype.weekdaytext = function(wday) {
    var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
    return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
  };
  ToText2.prototype.plural = function(n) {
    return n % 100 !== 1;
  };
  ToText2.prototype.add = function(s) {
    this.text.push(" ");
    this.text.push(s);
    return this;
  };
  ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
    var _this = this;
    if (delim === void 0) {
      delim = ",";
    }
    if (!isArray(arr)) {
      arr = [arr];
    }
    var delimJoin = function(array, delimiter, finalDelimiter) {
      var list = "";
      for (var i = 0; i < array.length; i++) {
        if (i !== 0) {
          if (i === array.length - 1) {
            list += " " + finalDelimiter + " ";
          } else {
            list += delimiter + " ";
          }
        }
        list += array[i];
      }
      return list;
    };
    callback = callback || function(o) {
      return o.toString();
    };
    var realCallback = function(arg) {
      return callback && callback.call(_this, arg);
    };
    if (finalDelim) {
      return delimJoin(arr.map(realCallback), delim, finalDelim);
    } else {
      return arr.map(realCallback).join(delim + " ");
    }
  };
  return ToText2;
}();
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = function() {
  function Parser2(rules) {
    this.done = true;
    this.rules = rules;
  }
  Parser2.prototype.start = function(text2) {
    this.text = text2;
    this.done = false;
    return this.nextSymbol();
  };
  Parser2.prototype.isDone = function() {
    return this.done && this.symbol === null;
  };
  Parser2.prototype.nextSymbol = function() {
    var best;
    var bestSymbol;
    this.symbol = null;
    this.value = null;
    do {
      if (this.done)
        return false;
      var rule = void 0;
      best = null;
      for (var name_1 in this.rules) {
        rule = this.rules[name_1];
        var match = rule.exec(this.text);
        if (match) {
          if (best === null || match[0].length > best[0].length) {
            best = match;
            bestSymbol = name_1;
          }
        }
      }
      if (best != null) {
        this.text = this.text.substr(best[0].length);
        if (this.text === "")
          this.done = true;
      }
      if (best == null) {
        this.done = true;
        this.symbol = null;
        this.value = null;
        return;
      }
    } while (bestSymbol === "SKIP");
    this.symbol = bestSymbol;
    this.value = best;
    return true;
  };
  Parser2.prototype.accept = function(name) {
    if (this.symbol === name) {
      if (this.value) {
        var v = this.value;
        this.nextSymbol();
        return v;
      }
      this.nextSymbol();
      return true;
    }
    return false;
  };
  Parser2.prototype.acceptNumber = function() {
    return this.accept("number");
  };
  Parser2.prototype.expect = function(name) {
    if (this.accept(name))
      return true;
    throw new Error("expected " + name + " but found " + this.symbol);
  };
  return Parser2;
}();
function parseText(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text2))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text2, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = function() {
  function Time2(hour, minute, second, millisecond) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond || 0;
  }
  Time2.prototype.getHours = function() {
    return this.hour;
  };
  Time2.prototype.getMinutes = function() {
    return this.minute;
  };
  Time2.prototype.getSeconds = function() {
    return this.second;
  };
  Time2.prototype.getMilliseconds = function() {
    return this.millisecond;
  };
  Time2.prototype.getTime = function() {
    return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
  };
  return Time2;
}();
var DateTime = function(_super) {
  __extends(DateTime2, _super);
  function DateTime2(year, month, day, hour, minute, second, millisecond) {
    var _this = _super.call(this, hour, minute, second, millisecond) || this;
    _this.year = year;
    _this.month = month;
    _this.day = day;
    return _this;
  }
  DateTime2.fromDate = function(date) {
    return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
  };
  DateTime2.prototype.getWeekday = function() {
    return dateutil.getWeekday(new Date(this.getTime()));
  };
  DateTime2.prototype.getTime = function() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
  };
  DateTime2.prototype.getDay = function() {
    return this.day;
  };
  DateTime2.prototype.getMonth = function() {
    return this.month;
  };
  DateTime2.prototype.getYear = function() {
    return this.year;
  };
  DateTime2.prototype.addYears = function(years) {
    this.year += years;
  };
  DateTime2.prototype.addMonths = function(months) {
    this.month += months;
    if (this.month > 12) {
      var yearDiv = Math.floor(this.month / 12);
      var monthMod = pymod(this.month, 12);
      this.month = monthMod;
      this.year += yearDiv;
      if (this.month === 0) {
        this.month = 12;
        --this.year;
      }
    }
  };
  DateTime2.prototype.addWeekly = function(days, wkst) {
    if (wkst > this.getWeekday()) {
      this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
    } else {
      this.day += -(this.getWeekday() - wkst) + days * 7;
    }
    this.fixDay();
  };
  DateTime2.prototype.addDaily = function(days) {
    this.day += days;
    this.fixDay();
  };
  DateTime2.prototype.addHours = function(hours, filtered, byhour) {
    if (filtered) {
      this.hour += Math.floor((23 - this.hour) / hours) * hours;
    }
    for (; ; ) {
      this.hour += hours;
      var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
      if (dayDiv) {
        this.hour = hourMod;
        this.addDaily(dayDiv);
      }
      if (empty(byhour) || includes(byhour, this.hour))
        break;
    }
  };
  DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
    if (filtered) {
      this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
    }
    for (; ; ) {
      this.minute += minutes;
      var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
      if (hourDiv) {
        this.minute = minuteMod;
        this.addHours(hourDiv, false, byhour);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
        break;
      }
    }
  };
  DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
    if (filtered) {
      this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
    }
    for (; ; ) {
      this.second += seconds;
      var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
      if (minuteDiv) {
        this.second = secondMod;
        this.addMinutes(minuteDiv, false, byhour, byminute);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
        break;
      }
    }
  };
  DateTime2.prototype.fixDay = function() {
    if (this.day <= 28) {
      return;
    }
    var daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    if (this.day <= daysinmonth) {
      return;
    }
    while (this.day > daysinmonth) {
      this.day -= daysinmonth;
      ++this.month;
      if (this.month === 13) {
        this.month = 1;
        ++this.year;
        if (this.year > dateutil.MAXYEAR) {
          return;
        }
      }
      daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
    }
  };
  DateTime2.prototype.add = function(options, filtered) {
    var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
    switch (freq) {
      case Frequency.YEARLY:
        return this.addYears(interval);
      case Frequency.MONTHLY:
        return this.addMonths(interval);
      case Frequency.WEEKLY:
        return this.addWeekly(interval, wkst);
      case Frequency.DAILY:
        return this.addDaily(interval);
      case Frequency.HOURLY:
        return this.addHours(interval, filtered, byhour);
      case Frequency.MINUTELY:
        return this.addMinutes(interval, filtered, byhour, byminute);
      case Frequency.SECONDLY:
        return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
    }
  };
  return DateTime2;
}(Time);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (dateutil_default.isDate(options[key]) && !dateutil_default.isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [dateutil_default.getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = dateutil_default.untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr2) {
    var _a = attr2.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = dateutil_default.untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = function() {
  function DateWithZone2(date, tzid) {
    if (isNaN(date.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date = date;
    this.tzid = tzid;
  }
  Object.defineProperty(DateWithZone2.prototype, "isUTC", {
    get: function() {
      return !this.tzid || this.tzid.toUpperCase() === "UTC";
    },
    enumerable: false,
    configurable: true
  });
  DateWithZone2.prototype.toString = function() {
    var datestr = dateutil_default.timeToUntilString(this.date.getTime(), this.isUTC);
    if (!this.isUTC) {
      return ";TZID=".concat(this.tzid, ":").concat(datestr);
    }
    return ":".concat(datestr);
  };
  DateWithZone2.prototype.getTime = function() {
    return this.date.getTime();
  };
  DateWithZone2.prototype.rezonedDate = function() {
    var _a;
    if (this.isUTC) {
      return this.date;
    }
    var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    var dateInLocalTZ = new Date(this.date.toLocaleString(void 0, { timeZone: localTimeZone }));
    var dateInTargetTZ = new Date(this.date.toLocaleString(void 0, { timeZone: (_a = this.tzid) !== null && _a !== void 0 ? _a : "UTC" }));
    var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
    return new Date(this.date.getTime() - tzOffset);
  };
  return DateWithZone2;
}();

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value = options[keys[i]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = dateutil_default.timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = function() {
  function Cache3() {
    this.all = false;
    this.before = [];
    this.after = [];
    this.between = [];
  }
  Cache3.prototype._cacheAdd = function(what, value, args) {
    if (value) {
      value = value instanceof Date ? dateutil_default.clone(value) : dateutil_default.cloneDates(value);
    }
    if (what === "all") {
      this.all = value;
    } else {
      args._value = value;
      this[what].push(args);
    }
  };
  Cache3.prototype._cacheGet = function(what, args) {
    var cached = false;
    var argsKeys = args ? Object.keys(args) : [];
    var findCacheDiff = function(item2) {
      for (var i2 = 0; i2 < argsKeys.length; i2++) {
        var key = argsKeys[i2];
        if (!argsMatch(args[key], item2[key])) {
          return true;
        }
      }
      return false;
    };
    var cachedObject = this[what];
    if (what === "all") {
      cached = this.all;
    } else if (isArray(cachedObject)) {
      for (var i = 0; i < cachedObject.length; i++) {
        var item = cachedObject[i];
        if (argsKeys.length && findCacheDiff(item))
          continue;
        cached = item._value;
        break;
      }
    }
    if (!cached && this.all) {
      var iterResult = new iterresult_default(what, args);
      for (var i = 0; i < this.all.length; i++) {
        if (!iterResult.accept(this.all[i]))
          break;
      }
      cached = iterResult.getValue();
      this._cacheAdd(what, cached, args);
    }
    return isArray(cached) ? dateutil_default.cloneDates(cached) : cached instanceof Date ? dateutil_default.clone(cached) : cached;
  };
  return Cache3;
}();

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var nextyearlen = dateutil_default.isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = dateutil_default.toOrdinal(firstyday);
  var yearweekday = dateutil_default.getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = dateutil_default.getWeekday(new Date(Date.UTC(year - 1, 0, 1)));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = dateutil_default.isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = dateutil_default.isLeapYear(year) ? 366 : 365;
  var firstyday = new Date(Date.UTC(year, 0, 1));
  var wday = dateutil_default.getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = function() {
  function Iterinfo2(options) {
    this.options = options;
  }
  Iterinfo2.prototype.rebuild = function(year, month) {
    var options = this.options;
    if (year !== this.lastyear) {
      this.yearinfo = rebuildYear(year, options);
    }
    if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
      this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
    }
    if (isPresent(options.byeaster)) {
      this.eastermask = easter(year, options.byeaster);
    }
  };
  Object.defineProperty(Iterinfo2.prototype, "lastyear", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastyear : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastmonth : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearlen", {
    get: function() {
      return this.yearinfo.yearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
    get: function() {
      return this.yearinfo.yearordinal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mrange", {
    get: function() {
      return this.yearinfo.mrange;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
    get: function() {
      return this.yearinfo.wdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mmask", {
    get: function() {
      return this.yearinfo.mmask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wnomask", {
    get: function() {
      return this.yearinfo.wnomask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
    get: function() {
      return this.monthinfo ? this.monthinfo.nwdaymask : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
    get: function() {
      return this.yearinfo.nextyearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
    get: function() {
      return this.yearinfo.mdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
    get: function() {
      return this.yearinfo.nmdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Iterinfo2.prototype.ydayset = function() {
    return [range(this.yearlen), 0, this.yearlen];
  };
  Iterinfo2.prototype.mdayset = function(_, month) {
    var start = this.mrange[month - 1];
    var end = this.mrange[month];
    var set = repeat(null, this.yearlen);
    for (var i = start; i < end; i++)
      set[i] = i;
    return [set, start, end];
  };
  Iterinfo2.prototype.wdayset = function(year, month, day) {
    var set = repeat(null, this.yearlen + 7);
    var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    var start = i;
    for (var j = 0; j < 7; j++) {
      set[i] = i;
      ++i;
      if (this.wdaymask[i] === this.options.wkst)
        break;
    }
    return [set, start, i];
  };
  Iterinfo2.prototype.ddayset = function(year, month, day) {
    var set = repeat(null, this.yearlen);
    var i = dateutil_default.toOrdinal(new Date(Date.UTC(year, month - 1, day))) - this.yearordinal;
    set[i] = i;
    return [set, i, i + 1];
  };
  Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
    var _this = this;
    var set = [];
    this.options.byminute.forEach(function(minute) {
      set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
    });
    dateutil_default.sort(set);
    return set;
  };
  Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
    var set = this.options.bysecond.map(function(second) {
      return new Time(hour, minute, second, millisecond);
    });
    dateutil_default.sort(set);
    return set;
  };
  Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
    return [new Time(hour, minute, second, millisecond)];
  };
  Iterinfo2.prototype.getdayset = function(freq) {
    switch (freq) {
      case Frequency.YEARLY:
        return this.ydayset.bind(this);
      case Frequency.MONTHLY:
        return this.mdayset.bind(this);
      case Frequency.WEEKLY:
        return this.wdayset.bind(this);
      case Frequency.DAILY:
        return this.ddayset.bind(this);
      default:
        return this.ddayset.bind(this);
    }
  };
  Iterinfo2.prototype.gettimeset = function(freq) {
    switch (freq) {
      case Frequency.HOURLY:
        return this.htimeset.bind(this);
      case Frequency.MINUTELY:
        return this.mtimeset.bind(this);
      case Frequency.SECONDLY:
        return this.stimeset.bind(this);
    }
  };
  return Iterinfo2;
}();
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = dateutil_default.fromOrdinal(ii.yearordinal + i);
    var res = dateutil_default.combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  dateutil_default.sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = dateutil_default.fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = dateutil_default.combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > dateutil_default.MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = function() {
  function RRule2(options, noCache) {
    if (options === void 0) {
      options = {};
    }
    if (noCache === void 0) {
      noCache = false;
    }
    this._cache = noCache ? null : new Cache();
    this.origOptions = initializeOptions(options);
    var parsedOptions = parseOptions(options).parsedOptions;
    this.options = parsedOptions;
  }
  RRule2.parseText = function(text2, language) {
    return parseText(text2, language);
  };
  RRule2.fromText = function(text2, language) {
    return fromText(text2, language);
  };
  RRule2.fromString = function(str) {
    return new RRule2(RRule2.parseString(str) || void 0);
  };
  RRule2.prototype._iter = function(iterResult) {
    return iter(iterResult, this.options);
  };
  RRule2.prototype._cacheGet = function(what, args) {
    if (!this._cache)
      return false;
    return this._cache._cacheGet(what, args);
  };
  RRule2.prototype._cacheAdd = function(what, value, args) {
    if (!this._cache)
      return;
    return this._cache._cacheAdd(what, value, args);
  };
  RRule2.prototype.all = function(iterator) {
    if (iterator) {
      return this._iter(new callbackiterresult_default("all", {}, iterator));
    }
    var result = this._cacheGet("all");
    if (result === false) {
      result = this._iter(new iterresult_default("all", {}));
      this._cacheAdd("all", result);
    }
    return result;
  };
  RRule2.prototype.between = function(after, before, inc, iterator) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(after) || !dateutil_default.isValidDate(before)) {
      throw new Error("Invalid date passed in to RRule.between");
    }
    var args = {
      before,
      after,
      inc
    };
    if (iterator) {
      return this._iter(new callbackiterresult_default("between", args, iterator));
    }
    var result = this._cacheGet("between", args);
    if (result === false) {
      result = this._iter(new iterresult_default("between", args));
      this._cacheAdd("between", result, args);
    }
    return result;
  };
  RRule2.prototype.before = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.before");
    }
    var args = { dt, inc };
    var result = this._cacheGet("before", args);
    if (result === false) {
      result = this._iter(new iterresult_default("before", args));
      this._cacheAdd("before", result, args);
    }
    return result;
  };
  RRule2.prototype.after = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!dateutil_default.isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.after");
    }
    var args = { dt, inc };
    var result = this._cacheGet("after", args);
    if (result === false) {
      result = this._iter(new iterresult_default("after", args));
      this._cacheAdd("after", result, args);
    }
    return result;
  };
  RRule2.prototype.count = function() {
    return this.all().length;
  };
  RRule2.prototype.toString = function() {
    return optionsToString(this.origOptions);
  };
  RRule2.prototype.toText = function(gettext, language, dateFormatter) {
    return toText(this, gettext, language, dateFormatter);
  };
  RRule2.prototype.isFullyConvertibleToText = function() {
    return isFullyConvertible(this);
  };
  RRule2.prototype.clone = function() {
    return new RRule2(this.origOptions);
  };
  RRule2.FREQUENCIES = [
    "YEARLY",
    "MONTHLY",
    "WEEKLY",
    "DAILY",
    "HOURLY",
    "MINUTELY",
    "SECONDLY"
  ];
  RRule2.YEARLY = Frequency.YEARLY;
  RRule2.MONTHLY = Frequency.MONTHLY;
  RRule2.WEEKLY = Frequency.WEEKLY;
  RRule2.DAILY = Frequency.DAILY;
  RRule2.HOURLY = Frequency.HOURLY;
  RRule2.MINUTELY = Frequency.MINUTELY;
  RRule2.SECONDLY = Frequency.SECONDLY;
  RRule2.MO = Days.MO;
  RRule2.TU = Days.TU;
  RRule2.WE = Days.WE;
  RRule2.TH = Days.TH;
  RRule2.FR = Days.FR;
  RRule2.SA = Days.SA;
  RRule2.SU = Days.SU;
  RRule2.parseString = parseString;
  RRule2.optionsToString = optionsToString;
  return RRule2;
}();

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  dateutil_default.sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return dateutil_default.untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = function(_super) {
  __extends(RRuleSet2, _super);
  function RRuleSet2(noCache) {
    if (noCache === void 0) {
      noCache = false;
    }
    var _this = _super.call(this, {}, noCache) || this;
    _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
    _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
    _this._rrule = [];
    _this._rdate = [];
    _this._exrule = [];
    _this._exdate = [];
    return _this;
  }
  RRuleSet2.prototype._iter = function(iterResult) {
    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
  };
  RRuleSet2.prototype.rrule = function(rrule) {
    _addRule(rrule, this._rrule);
  };
  RRuleSet2.prototype.exrule = function(rrule) {
    _addRule(rrule, this._exrule);
  };
  RRuleSet2.prototype.rdate = function(date) {
    _addDate(date, this._rdate);
  };
  RRuleSet2.prototype.exdate = function(date) {
    _addDate(date, this._exdate);
  };
  RRuleSet2.prototype.rrules = function() {
    return this._rrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.exrules = function() {
    return this._exrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.rdates = function() {
    return this._rdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.exdates = function() {
    return this._exdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.valueOf = function() {
    var result = [];
    if (!this._rrule.length && this._dtstart) {
      result = result.concat(optionsToString({ dtstart: this._dtstart }));
    }
    this._rrule.forEach(function(rrule) {
      result = result.concat(rrule.toString().split("\n"));
    });
    this._exrule.forEach(function(exrule) {
      result = result.concat(exrule.toString().split("\n").map(function(line) {
        return line.replace(/^RRULE:/, "EXRULE:");
      }).filter(function(line) {
        return !/^DTSTART/.test(line);
      }));
    });
    if (this._rdate.length) {
      result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
    }
    if (this._exdate.length) {
      result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
    }
    return result;
  };
  RRuleSet2.prototype.toString = function() {
    return this.valueOf().join("\n");
  };
  RRuleSet2.prototype.clone = function() {
    var rrs = new RRuleSet2(!!this._cache);
    this._rrule.forEach(function(rule) {
      return rrs.rrule(rule.clone());
    });
    this._exrule.forEach(function(rule) {
      return rrs.exrule(rule.clone());
    });
    this._rdate.forEach(function(date) {
      return rrs.rdate(new Date(date.getTime()));
    });
    this._exdate.forEach(function(date) {
      return rrs.exdate(new Date(date.getTime()));
    });
    return rrs;
  };
  return RRuleSet2;
}(RRule);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    dateutil_default.sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return dateutil_default.timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// src/Sort.ts
var _Sort = class {
  static by(query, tasks) {
    const defaultComparators = [
      _Sort.compareByUrgency,
      _Sort.compareByStatus,
      _Sort.compareByDueDate,
      _Sort.compareByPriority,
      _Sort.compareByPath
    ];
    const userComparators = [];
    for (const { property, reverse, propertyInstance } of query.sorting) {
      const comparator = _Sort.comparators[property];
      userComparators.push(
        reverse ? _Sort.makeReversedComparator(comparator) : comparator
      );
      if (property === "tag") {
        _Sort.tagPropertyInstance = propertyInstance;
      }
    }
    return tasks.sort(
      _Sort.makeCompositeComparator([
        ...userComparators,
        ...defaultComparators
      ])
    );
  }
  static makeReversedComparator(comparator) {
    return (a, b) => comparator(a, b) * -1;
  }
  static makeCompositeComparator(comparators) {
    return (a, b) => {
      for (const comparator of comparators) {
        const result = comparator(a, b);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    };
  }
  static compareByUrgency(a, b) {
    return b.urgency - a.urgency;
  }
  static compareByStatus(a, b) {
    if (a.status < b.status) {
      return 1;
    } else if (a.status > b.status) {
      return -1;
    } else {
      return 0;
    }
  }
  static compareByPriority(a, b) {
    return a.priority.localeCompare(b.priority);
  }
  static compareByStartDate(a, b) {
    return _Sort.compareByDate(a.startDate, b.startDate);
  }
  static compareByScheduledDate(a, b) {
    return _Sort.compareByDate(a.scheduledDate, b.scheduledDate);
  }
  static compareByDueDate(a, b) {
    return _Sort.compareByDate(a.dueDate, b.dueDate);
  }
  static compareByDoneDate(a, b) {
    return _Sort.compareByDate(a.doneDate, b.doneDate);
  }
  static compareByTag(a, b) {
    if (a.tags.length === 0 && b.tags.length === 0) {
      return 0;
    } else if (a.tags.length === 0) {
      return 1;
    } else if (b.tags.length === 0) {
      return -1;
    }
    const tagInstanceToSortBy = _Sort.tagPropertyInstance - 1;
    if (a.tags.length < _Sort.tagPropertyInstance && b.tags.length >= _Sort.tagPropertyInstance) {
      return 1;
    } else if (b.tags.length < _Sort.tagPropertyInstance && a.tags.length >= _Sort.tagPropertyInstance) {
      return -1;
    } else if (a.tags.length < _Sort.tagPropertyInstance && b.tags.length < _Sort.tagPropertyInstance) {
      return 0;
    }
    if (a.tags[tagInstanceToSortBy] < b.tags[tagInstanceToSortBy]) {
      return -1;
    } else if (a.tags[tagInstanceToSortBy] > b.tags[tagInstanceToSortBy]) {
      return 1;
    } else {
      return 0;
    }
  }
  static compareByDate(a, b) {
    if (a !== null && b === null) {
      return -1;
    } else if (a === null && b !== null) {
      return 1;
    } else if (a !== null && b !== null) {
      if (a.isAfter(b)) {
        return 1;
      } else if (a.isBefore(b)) {
        return -1;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
  static compareByPath(a, b) {
    if (a.path < b.path) {
      return -1;
    } else if (a.path > b.path) {
      return 1;
    } else {
      return 0;
    }
  }
  static compareByDescription(a, b) {
    return _Sort.cleanDescription(a.description).localeCompare(
      _Sort.cleanDescription(b.description)
    );
  }
  static cleanDescription(description) {
    const globalFilter = getSettings().globalFilter;
    description = description.replace(globalFilter, "").trim();
    const startsWithLinkRegex = /^\[\[?([^\]]*)\]/;
    const linkRegexMatch = description.match(startsWithLinkRegex);
    if (linkRegexMatch !== null) {
      const innerLinkText = linkRegexMatch[1];
      description = innerLinkText.substring(innerLinkText.indexOf("|") + 1) + description.replace(startsWithLinkRegex, "");
    }
    const startsWithItalicOrBoldRegex = /^\*\*?([^*]*)\*/;
    const italicBoldRegexMatch = description.match(
      startsWithItalicOrBoldRegex
    );
    if (italicBoldRegexMatch !== null) {
      const innerItalicBoldText = italicBoldRegexMatch[1];
      description = innerItalicBoldText + description.replace(startsWithLinkRegex, "");
    }
    const startsWithHighlightRegex = /^==?([^=]*)==/;
    const highlightRegexMatch = description.match(startsWithHighlightRegex);
    if (highlightRegexMatch !== null) {
      const innerHighlightsText = highlightRegexMatch[1];
      description = innerHighlightsText + description.replace(startsWithHighlightRegex, "");
    }
    return description;
  }
};
var Sort = _Sort;
Sort.tagPropertyInstance = 1;
Sort.comparators = {
  urgency: _Sort.compareByUrgency,
  description: _Sort.compareByDescription,
  priority: _Sort.compareByPriority,
  start: _Sort.compareByStartDate,
  scheduled: _Sort.compareByScheduledDate,
  due: _Sort.compareByDueDate,
  done: _Sort.compareByDoneDate,
  path: _Sort.compareByPath,
  status: _Sort.compareByStatus,
  tag: _Sort.compareByTag
};

// src/Recurrence.ts
var Recurrence = class {
  constructor({
    rrule,
    baseOnToday,
    referenceDate,
    startDate,
    scheduledDate,
    dueDate
  }) {
    this.rrule = rrule;
    this.baseOnToday = baseOnToday;
    this.referenceDate = referenceDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
  }
  static fromText({
    recurrenceRuleText,
    startDate,
    scheduledDate,
    dueDate
  }) {
    try {
      const match = recurrenceRuleText.match(
        /^([a-zA-Z0-9, !]+?)( when done)?$/i
      );
      if (match == null) {
        return null;
      }
      const isolatedRuleText = match[1].trim();
      const baseOnToday = match[2] !== void 0;
      const options = RRule.parseText(isolatedRuleText);
      if (options !== null) {
        let referenceDate = null;
        if (dueDate) {
          referenceDate = window.moment(dueDate);
        } else if (scheduledDate) {
          referenceDate = window.moment(scheduledDate);
        } else if (startDate) {
          referenceDate = window.moment(startDate);
        }
        if (!baseOnToday && referenceDate !== null) {
          options.dtstart = window.moment(referenceDate).startOf("day").utc(true).toDate();
        } else {
          options.dtstart = window.moment().startOf("day").utc(true).toDate();
        }
        const rrule = new RRule(options);
        return new Recurrence({
          rrule,
          baseOnToday,
          referenceDate,
          startDate,
          scheduledDate,
          dueDate
        });
      }
    } catch (error) {
    }
    return null;
  }
  toText() {
    let text2 = this.rrule.toText();
    if (this.baseOnToday) {
      text2 += " when done";
    }
    return text2;
  }
  next() {
    var _a;
    let next;
    if (this.baseOnToday) {
      const today = window.moment();
      const ruleBasedOnToday = new RRule(__spreadProps(__spreadValues({}, this.rrule.origOptions), {
        dtstart: today.startOf("day").utc(true).toDate()
      }));
      next = ruleBasedOnToday.after(
        today.endOf("day").utc(true).toDate()
      );
    } else {
      const after = window.moment((_a = this.referenceDate) != null ? _a : void 0).endOf("day").utc(true);
      next = this.rrule.after(after.toDate());
    }
    if (next !== null) {
      const localTimeZone = window.moment.utc(next).local(true);
      const nextOccurrence = localTimeZone.startOf("day");
      let startDate = null;
      let scheduledDate = null;
      let dueDate = null;
      if (this.referenceDate) {
        if (this.startDate) {
          const originalDifference = window.moment.duration(
            this.startDate.diff(this.referenceDate)
          );
          startDate = window.moment(nextOccurrence);
          startDate.add(
            Math.round(originalDifference.asDays()),
            "days"
          );
        }
        if (this.scheduledDate) {
          const originalDifference = window.moment.duration(
            this.scheduledDate.diff(this.referenceDate)
          );
          scheduledDate = window.moment(nextOccurrence);
          scheduledDate.add(
            Math.round(originalDifference.asDays()),
            "days"
          );
        }
        if (this.dueDate) {
          const originalDifference = window.moment.duration(
            this.dueDate.diff(this.referenceDate)
          );
          dueDate = window.moment(nextOccurrence);
          dueDate.add(
            Math.round(originalDifference.asDays()),
            "days"
          );
        }
      }
      return {
        startDate,
        scheduledDate,
        dueDate
      };
    }
    return null;
  }
  identicalTo(other) {
    if (this.baseOnToday !== other.baseOnToday) {
      return false;
    }
    if (Sort.compareByDate(this.startDate, other.startDate) !== 0) {
      return false;
    }
    if (Sort.compareByDate(this.scheduledDate, other.scheduledDate) !== 0) {
      return false;
    }
    if (Sort.compareByDate(this.dueDate, other.dueDate) !== 0) {
      return false;
    }
    return this.toText() === other.toText();
  }
};

// src/Urgency.ts
var _Urgency = class {
  static calculate(task) {
    let urgency = 0;
    if (task.dueDate !== null) {
      const daysOverdue = Math.round(
        window.moment().diff(task.dueDate) / _Urgency.milliSecondsPerDay
      );
      let dueMultiplier;
      if (daysOverdue >= 7) {
        dueMultiplier = 1;
      } else if (daysOverdue >= -14) {
        dueMultiplier = (daysOverdue + 14) * 0.8 / 21 + 0.2;
      } else {
        dueMultiplier = 0.2;
      }
      urgency += dueMultiplier * _Urgency.dueCoefficient;
    }
    if (task.scheduledDate !== null) {
      if (window.moment().isSameOrAfter(task.scheduledDate)) {
        urgency += 1 * _Urgency.scheduledCoefficient;
      }
    }
    if (task.startDate !== null) {
      if (window.moment().isBefore(task.startDate)) {
        urgency += 1 * _Urgency.startedCoefficient;
      }
    }
    switch (task.priority) {
      case "1":
        urgency += 1 * _Urgency.priorityCoefficient;
        break;
      case "2":
        urgency += 0.65 * _Urgency.priorityCoefficient;
        break;
      case "3":
        urgency += 0.325 * _Urgency.priorityCoefficient;
        break;
    }
    return urgency;
  }
};
var Urgency = _Urgency;
Urgency.dueCoefficient = 12;
Urgency.scheduledCoefficient = 5;
Urgency.startedCoefficient = -3;
Urgency.priorityCoefficient = 6;
Urgency.milliSecondsPerDay = 1e3 * 60 * 60 * 24;

// src/Task.ts
var prioritySymbols = {
  High: "\u23EB",
  Medium: "\u{1F53C}",
  Low: "\u{1F53D}",
  None: ""
};
var recurrenceSymbol = "\u{1F501}";
var startDateSymbol = "\u{1F6EB}";
var scheduledDateSymbol = "\u23F3";
var dueDateSymbol = "\u{1F4C5}";
var doneDateSymbol = "\u2705";
var _Task = class {
  constructor({
    status,
    description,
    path,
    indentation,
    sectionStart,
    sectionIndex,
    originalStatusCharacter,
    precedingHeader,
    priority,
    startDate,
    scheduledDate,
    dueDate,
    doneDate,
    recurrence,
    blockLink,
    tags
  }) {
    this._urgency = null;
    this.status = status;
    this.description = description;
    this.path = path;
    this.indentation = indentation;
    this.sectionStart = sectionStart;
    this.sectionIndex = sectionIndex;
    this.originalStatusCharacter = originalStatusCharacter;
    this.precedingHeader = precedingHeader;
    this.tags = tags;
    this.priority = priority;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.doneDate = doneDate;
    this.recurrence = recurrence;
    this.blockLink = blockLink;
  }
  static fromLine({
    line,
    path,
    sectionStart,
    sectionIndex,
    precedingHeader
  }) {
    const regexMatch = line.match(_Task.taskRegex);
    if (regexMatch === null) {
      return null;
    }
    const body = regexMatch[3].trim();
    const { globalFilter } = getSettings();
    if (!body.includes(globalFilter)) {
      return null;
    }
    let description = body;
    const indentation = regexMatch[1];
    const statusString = regexMatch[2].toLowerCase();
    let status;
    switch (statusString) {
      case " ":
        status = "Todo" /* Todo */;
        break;
      default:
        status = "Done" /* Done */;
    }
    const blockLinkMatch = description.match(this.blockLinkRegex);
    const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
    if (blockLink !== "") {
      description = description.replace(this.blockLinkRegex, "").trim();
    }
    let matched;
    let priority = "3" /* None */;
    let startDate = null;
    let scheduledDate = null;
    let dueDate = null;
    let doneDate = null;
    let recurrenceRule = "";
    let recurrence = null;
    let tags = [];
    let trailingTags = "";
    const maxRuns = 20;
    let runs = 0;
    do {
      matched = false;
      const priorityMatch = description.match(_Task.priorityRegex);
      if (priorityMatch !== null) {
        switch (priorityMatch[1]) {
          case prioritySymbols.Low:
            priority = "4" /* Low */;
            break;
          case prioritySymbols.Medium:
            priority = "2" /* Medium */;
            break;
          case prioritySymbols.High:
            priority = "1" /* High */;
            break;
        }
        description = description.replace(_Task.priorityRegex, "").trim();
        matched = true;
      }
      const doneDateMatch = description.match(_Task.doneDateRegex);
      if (doneDateMatch !== null) {
        doneDate = window.moment(doneDateMatch[1], _Task.dateFormat);
        description = description.replace(_Task.doneDateRegex, "").trim();
        matched = true;
      }
      const dueDateMatch = description.match(_Task.dueDateRegex);
      if (dueDateMatch !== null) {
        dueDate = window.moment(dueDateMatch[1], _Task.dateFormat);
        description = description.replace(_Task.dueDateRegex, "").trim();
        matched = true;
      }
      const scheduledDateMatch = description.match(
        _Task.scheduledDateRegex
      );
      if (scheduledDateMatch !== null) {
        scheduledDate = window.moment(
          scheduledDateMatch[1],
          _Task.dateFormat
        );
        description = description.replace(_Task.scheduledDateRegex, "").trim();
        matched = true;
      }
      const startDateMatch = description.match(_Task.startDateRegex);
      if (startDateMatch !== null) {
        startDate = window.moment(startDateMatch[1], _Task.dateFormat);
        description = description.replace(_Task.startDateRegex, "").trim();
        matched = true;
      }
      const recurrenceMatch = description.match(_Task.recurrenceRegex);
      if (recurrenceMatch !== null) {
        recurrenceRule = recurrenceMatch[1].trim();
        description = description.replace(_Task.recurrenceRegex, "").trim();
        matched = true;
      }
      const tagsMatch = description.match(_Task.hashTagsFromEnd);
      if (tagsMatch != null) {
        description = description.replace(_Task.hashTagsFromEnd, "").trim();
        matched = true;
        const tagName = tagsMatch[0].trim();
        trailingTags = trailingTags.length > 0 ? [tagName, trailingTags].join(" ") : tagName;
      }
      runs++;
    } while (matched && runs <= maxRuns);
    if (recurrenceRule.length > 0) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    if (trailingTags.length > 0)
      description += " " + trailingTags;
    const hashTagMatch = description.match(this.hashTags);
    if (hashTagMatch !== null) {
      tags = hashTagMatch.filter((tag) => tag !== globalFilter).map((tag) => tag.trim());
    }
    return new _Task({
      status,
      description,
      path,
      indentation,
      sectionStart,
      sectionIndex,
      originalStatusCharacter: statusString,
      precedingHeader,
      priority,
      startDate,
      scheduledDate,
      dueDate,
      doneDate,
      recurrence,
      blockLink,
      tags
    });
  }
  toLi(_0) {
    return __async(this, arguments, function* ({
      parentUlElement,
      listIndex,
      layoutOptions,
      isFilenameUnique
    }) {
      const li = parentUlElement.createEl("li");
      li.addClasses(["task-list-item", "plugin-tasks-list-item"]);
      let taskAsString = this.toString(layoutOptions);
      const { globalFilter, removeGlobalFilter } = getSettings();
      if (removeGlobalFilter) {
        taskAsString = taskAsString.replace(globalFilter, "").trim();
      }
      const textSpan = li.createSpan();
      textSpan.addClass("tasks-list-text");
      yield import_obsidian2.MarkdownRenderer.renderMarkdown(
        taskAsString,
        textSpan,
        this.path,
        null
      );
      const blockQuote = textSpan.querySelector("blockquote");
      const directParentOfPTag = blockQuote != null ? blockQuote : textSpan;
      const pElement = directParentOfPTag.querySelector("p");
      if (pElement !== null) {
        while (pElement.firstChild) {
          directParentOfPTag.insertBefore(pElement.firstChild, pElement);
        }
        pElement.remove();
      }
      textSpan.findAll("p").forEach((pElement2) => {
        if (!pElement2.hasChildNodes()) {
          pElement2.remove();
        }
      });
      textSpan.findAll(".footnotes").forEach((footnoteElement) => {
        footnoteElement.remove();
      });
      const checkbox = li.createEl("input");
      checkbox.addClass("task-list-item-checkbox");
      checkbox.type = "checkbox";
      if (this.status !== "Todo" /* Todo */) {
        checkbox.checked = true;
        li.addClass("is-checked");
      }
      checkbox.onClickEvent((event) => {
        event.preventDefault();
        event.stopPropagation();
        checkbox.disabled = true;
        const toggledTasks = this.toggle();
        replaceTaskWithTasks({
          originalTask: this,
          newTasks: toggledTasks
        });
      });
      li.prepend(checkbox);
      li.setAttr("data-task", this.originalStatusCharacter.trim());
      li.setAttr("data-line", listIndex);
      checkbox.setAttr("data-line", listIndex);
      if (layoutOptions == null ? void 0 : layoutOptions.shortMode) {
        this.addTooltip({ element: textSpan, isFilenameUnique });
      }
      return li;
    });
  }
  toString(layoutOptions) {
    var _a;
    layoutOptions = layoutOptions != null ? layoutOptions : new LayoutOptions();
    let taskString = this.description;
    if (!layoutOptions.hidePriority) {
      let priority = "";
      if (this.priority === "1" /* High */) {
        priority = " " + prioritySymbols.High;
      } else if (this.priority === "2" /* Medium */) {
        priority = " " + prioritySymbols.Medium;
      } else if (this.priority === "4" /* Low */) {
        priority = " " + prioritySymbols.Low;
      }
      taskString += priority;
    }
    if (!layoutOptions.hideRecurrenceRule && this.recurrence) {
      const recurrenceRule = layoutOptions.shortMode ? " " + recurrenceSymbol : ` ${recurrenceSymbol} ${this.recurrence.toText()}`;
      taskString += recurrenceRule;
    }
    if (!layoutOptions.hideStartDate && this.startDate) {
      const startDate = layoutOptions.shortMode ? " " + startDateSymbol : ` ${startDateSymbol} ${this.startDate.format(
        _Task.dateFormat
      )}`;
      taskString += startDate;
    }
    if (!layoutOptions.hideScheduledDate && this.scheduledDate) {
      const scheduledDate = layoutOptions.shortMode ? " " + scheduledDateSymbol : ` ${scheduledDateSymbol} ${this.scheduledDate.format(
        _Task.dateFormat
      )}`;
      taskString += scheduledDate;
    }
    if (!layoutOptions.hideDueDate && this.dueDate) {
      const dueDate = layoutOptions.shortMode ? " " + dueDateSymbol : ` ${dueDateSymbol} ${this.dueDate.format(_Task.dateFormat)}`;
      taskString += dueDate;
    }
    if (!layoutOptions.hideDoneDate && this.doneDate) {
      const doneDate = layoutOptions.shortMode ? " " + doneDateSymbol : ` ${doneDateSymbol} ${this.doneDate.format(_Task.dateFormat)}`;
      taskString += doneDate;
    }
    const blockLink = (_a = this.blockLink) != null ? _a : "";
    taskString += blockLink;
    return taskString;
  }
  toFileLineString() {
    return `${this.indentation}- [${this.originalStatusCharacter}] ${this.toString()}`;
  }
  toggle() {
    const newStatus = this.status === "Todo" /* Todo */ ? "Done" /* Done */ : "Todo" /* Todo */;
    let newDoneDate = null;
    let nextOccurrence = null;
    if (newStatus !== "Todo" /* Todo */) {
      const { setDoneDate } = getSettings();
      if (setDoneDate) {
        newDoneDate = window.moment();
      }
      if (this.recurrence !== null) {
        nextOccurrence = this.recurrence.next();
      }
    }
    const toggledTask = new _Task(__spreadProps(__spreadValues({}, this), {
      status: newStatus,
      doneDate: newDoneDate,
      originalStatusCharacter: newStatus === "Done" /* Done */ ? "x" : " "
    }));
    const newTasks = [];
    if (nextOccurrence !== null) {
      const nextTask = new _Task(__spreadProps(__spreadValues(__spreadValues({}, this), nextOccurrence), {
        blockLink: ""
      }));
      newTasks.push(nextTask);
    }
    newTasks.push(toggledTask);
    return newTasks;
  }
  get urgency() {
    if (this._urgency === null) {
      this._urgency = Urgency.calculate(this);
    }
    return this._urgency;
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)\.md$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return null;
    }
  }
  getLinkText({
    isFilenameUnique
  }) {
    let linkText;
    if (isFilenameUnique) {
      linkText = this.filename;
    } else {
      linkText = "/" + this.path;
    }
    if (linkText === null) {
      return null;
    }
    if (this.precedingHeader !== null && this.precedingHeader !== linkText) {
      linkText = linkText + " > " + this.precedingHeader;
    }
    return linkText;
  }
  static tasksListsIdentical(oldTasks, newTasks) {
    if (oldTasks.length !== newTasks.length) {
      return false;
    }
    return oldTasks.every(
      (oldTask, index) => oldTask.identicalTo(newTasks[index])
    );
  }
  identicalTo(other) {
    let args = [
      "status",
      "description",
      "path",
      "indentation",
      "sectionStart",
      "sectionIndex",
      "originalStatusCharacter",
      "precedingHeader",
      "priority",
      "blockLink"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    if (this.tags.length !== other.tags.length) {
      return false;
    }
    if (!this.tags.every(function(element2, index) {
      return element2 === other.tags[index];
    })) {
      return false;
    }
    args = ["startDate", "scheduledDate", "dueDate", "doneDate"];
    for (const el of args) {
      const date1 = this[el];
      const date2 = other[el];
      if (Sort.compareByDate(date1, date2) !== 0) {
        return false;
      }
    }
    const recurrence1 = this.recurrence;
    const recurrence2 = other.recurrence;
    if (recurrence1 === null && recurrence2 !== null) {
      return false;
    } else if (recurrence1 !== null && recurrence2 === null) {
      return false;
    } else if (recurrence1 && recurrence2 && !recurrence1.identicalTo(recurrence2)) {
      return false;
    }
    return true;
  }
  addTooltip({
    element: element2,
    isFilenameUnique
  }) {
    element2.addEventListener("mouseenter", () => {
      const tooltip = element2.createDiv();
      tooltip.addClasses(["tooltip", "mod-right"]);
      if (this.recurrence) {
        const recurrenceDiv = tooltip.createDiv();
        recurrenceDiv.setText(
          `${recurrenceSymbol} ${this.recurrence.toText()}`
        );
      }
      if (this.startDate) {
        const startDateDiv = tooltip.createDiv();
        startDateDiv.setText(
          _Task.toTooltipDate({
            signifier: startDateSymbol,
            date: this.startDate
          })
        );
      }
      if (this.scheduledDate) {
        const scheduledDateDiv = tooltip.createDiv();
        scheduledDateDiv.setText(
          _Task.toTooltipDate({
            signifier: scheduledDateSymbol,
            date: this.scheduledDate
          })
        );
      }
      if (this.dueDate) {
        const dueDateDiv = tooltip.createDiv();
        dueDateDiv.setText(
          _Task.toTooltipDate({
            signifier: dueDateSymbol,
            date: this.dueDate
          })
        );
      }
      if (this.doneDate) {
        const doneDateDiv = tooltip.createDiv();
        doneDateDiv.setText(
          _Task.toTooltipDate({
            signifier: doneDateSymbol,
            date: this.doneDate
          })
        );
      }
      const linkText = this.getLinkText({ isFilenameUnique });
      if (linkText) {
        const backlinkDiv = tooltip.createDiv();
        backlinkDiv.setText(`\u{1F517} ${linkText}`);
      }
      element2.addEventListener("mouseleave", () => {
        tooltip.remove();
      });
    });
  }
  static toTooltipDate({
    signifier,
    date
  }) {
    return `${signifier} ${date.format(_Task.dateFormat)} (${date.from(
      window.moment().startOf("day")
    )})`;
  }
  escapeRegExp(s) {
    return s.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
  }
  getDescriptionWithoutGlobalFilter() {
    const { globalFilter } = getSettings();
    let description = this.description;
    if (globalFilter.length === 0)
      return description;
    const globalFilterRegex = RegExp(
      "(^|\\s)" + this.escapeRegExp(globalFilter) + "($|\\s)",
      "ug"
    );
    if (this.description.search(globalFilterRegex) > -1) {
      description = description.replace(globalFilterRegex, "$1$2").replace("  ", " ").trim();
    }
    return description;
  }
};
var Task = _Task;
Task.dateFormat = "YYYY-MM-DD";
Task.taskRegex = /^([\s\t>]*)[-*] +\[(.)\] *(.*)/u;
Task.blockLinkRegex = / \^[a-zA-Z0-9-]+$/u;
Task.priorityRegex = /([⏫🔼🔽])$/u;
Task.startDateRegex = /🛫 *(\d{4}-\d{2}-\d{2})$/u;
Task.scheduledDateRegex = /[⏳⌛] *(\d{4}-\d{2}-\d{2})$/u;
Task.dueDateRegex = /[📅📆🗓] *(\d{4}-\d{2}-\d{2})$/u;
Task.doneDateRegex = /✅ *(\d{4}-\d{2}-\d{2})$/u;
Task.recurrenceRegex = /🔁 ?([a-zA-Z0-9, !]+)$/iu;
Task.hashTags = /(^|\s)#[^ !@#$%^&*(),.?":{}|<>]*/g;
Task.hashTagsFromEnd = new RegExp(
  _Task.hashTags.source + "$"
);

// src/Cache.ts
var Cache2 = class {
  constructor({
    metadataCache: metadataCache2,
    vault: vault2,
    events
  }) {
    this.metadataCache = metadataCache2;
    this.metadataCacheEventReferences = [];
    this.vault = vault2;
    this.vaultEventReferences = [];
    this.events = events;
    this.eventsEventReferences = [];
    this.tasksMutex = new Mutex();
    this.state = "Cold" /* Cold */;
    this.tasks = [];
    this.loadedAfterFirstResolve = false;
    this.subscribeToCache();
    this.subscribeToVault();
    this.subscribeToEvents();
    this.loadVault();
  }
  unload() {
    for (const eventReference of this.metadataCacheEventReferences) {
      this.metadataCache.offref(eventReference);
    }
    for (const eventReference of this.vaultEventReferences) {
      this.vault.offref(eventReference);
    }
    for (const eventReference of this.eventsEventReferences) {
      this.events.off(eventReference);
    }
  }
  getTasks() {
    return this.tasks;
  }
  getState() {
    return this.state;
  }
  notifySubscribers() {
    this.events.triggerCacheUpdate({
      tasks: this.tasks,
      state: this.state
    });
  }
  subscribeToCache() {
    const resolvedEventeReference = this.metadataCache.on(
      "resolved",
      () => __async(this, null, function* () {
        if (!this.loadedAfterFirstResolve) {
          this.loadedAfterFirstResolve = true;
          this.loadVault();
        }
      })
    );
    this.metadataCacheEventReferences.push(resolvedEventeReference);
    const changedEventReference = this.metadataCache.on(
      "changed",
      (file) => {
        this.tasksMutex.runExclusive(() => {
          this.indexFile(file);
        });
      }
    );
    this.metadataCacheEventReferences.push(changedEventReference);
  }
  subscribeToVault() {
    const createdEventReference = this.vault.on(
      "create",
      (file) => {
        if (!(file instanceof import_obsidian3.TFile)) {
          return;
        }
        this.tasksMutex.runExclusive(() => {
          this.indexFile(file);
        });
      }
    );
    this.vaultEventReferences.push(createdEventReference);
    const deletedEventReference = this.vault.on(
      "delete",
      (file) => {
        if (!(file instanceof import_obsidian3.TFile)) {
          return;
        }
        this.tasksMutex.runExclusive(() => {
          this.tasks = this.tasks.filter((task) => {
            return task.path !== file.path;
          });
          this.notifySubscribers();
        });
      }
    );
    this.vaultEventReferences.push(deletedEventReference);
    const renamedEventReference = this.vault.on(
      "rename",
      (file, oldPath) => {
        if (!(file instanceof import_obsidian3.TFile)) {
          return;
        }
        this.tasksMutex.runExclusive(() => {
          this.tasks = this.tasks.map((task) => {
            if (task.path === oldPath) {
              return new Task(__spreadProps(__spreadValues({}, task), { path: file.path }));
            } else {
              return task;
            }
          });
          this.notifySubscribers();
        });
      }
    );
    this.vaultEventReferences.push(renamedEventReference);
  }
  subscribeToEvents() {
    const requestReference = this.events.onRequestCacheUpdate((handler) => {
      handler({ tasks: this.tasks, state: this.state });
    });
    this.eventsEventReferences.push(requestReference);
  }
  loadVault() {
    return this.tasksMutex.runExclusive(() => __async(this, null, function* () {
      this.state = "Initializing" /* Initializing */;
      yield Promise.all(
        this.vault.getMarkdownFiles().map((file) => {
          return this.indexFile(file);
        })
      );
      this.state = "Warm" /* Warm */;
      this.notifySubscribers();
    }));
  }
  indexFile(file) {
    return __async(this, null, function* () {
      const fileCache = this.metadataCache.getFileCache(file);
      if (fileCache === null || fileCache === void 0) {
        return;
      }
      let listItems = fileCache.listItems;
      if (listItems === void 0) {
        listItems = [];
      }
      const oldTasks = this.tasks.filter((task) => {
        return task.path === file.path;
      });
      const fileContent = yield this.vault.cachedRead(file);
      const newTasks = Cache2.getTasksFromFileContent(
        fileContent,
        listItems,
        fileCache,
        file
      );
      if (Task.tasksListsIdentical(oldTasks, newTasks)) {
        return;
      }
      if (this.getState() == "Warm" /* Warm */) {
        console.debug(
          `At least one task, its line number or its heading has changed in ${file.path}: triggering a refresh of all active Tasks blocks in Live Preview and Reading mode views.`
        );
      }
      this.tasks = this.tasks.filter((task) => {
        return task.path !== file.path;
      });
      this.tasks.push(...newTasks);
      this.notifySubscribers();
    });
  }
  static getTasksFromFileContent(fileContent, listItems, fileCache, file) {
    const tasks = [];
    const fileLines = fileContent.split("\n");
    let currentSection = null;
    let sectionIndex = 0;
    for (const listItem of listItems) {
      if (listItem.task !== void 0) {
        if (currentSection === null || currentSection.position.end.line < listItem.position.start.line) {
          currentSection = Cache2.getSection({
            lineNumberTask: listItem.position.start.line,
            sections: fileCache.sections
          });
          sectionIndex = 0;
        }
        if (currentSection === null) {
          continue;
        }
        const line = fileLines[listItem.position.start.line];
        const task = Task.fromLine({
          line,
          path: file.path,
          sectionStart: currentSection.position.start.line,
          sectionIndex,
          precedingHeader: Cache2.getPrecedingHeader({
            lineNumberTask: listItem.position.start.line,
            sections: fileCache.sections,
            fileLines
          })
        });
        if (task !== null) {
          sectionIndex++;
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  static getSection({
    lineNumberTask,
    sections
  }) {
    if (sections === void 0) {
      return null;
    }
    for (const section of sections) {
      if (section.position.start.line <= lineNumberTask && section.position.end.line >= lineNumberTask) {
        return section;
      }
    }
    return null;
  }
  static getPrecedingHeader({
    lineNumberTask,
    sections,
    fileLines
  }) {
    if (sections === void 0) {
      return null;
    }
    let precedingHeaderSection;
    for (const section of sections) {
      if (section.type === "heading") {
        if (section.position.start.line > lineNumberTask) {
          break;
        }
        precedingHeaderSection = section;
      }
    }
    if (precedingHeaderSection === void 0) {
      return null;
    }
    const lineNumberPrecedingHeader = precedingHeaderSection.position.start.line;
    const linePrecedingHeader = fileLines[lineNumberPrecedingHeader];
    const headerRegex = /^#+ +(.*)/u;
    const headerMatch = linePrecedingHeader.match(headerRegex);
    if (headerMatch === null) {
      return null;
    } else {
      return headerMatch[1];
    }
  }
};

// src/Commands/CreateOrEdit.ts
var import_obsidian5 = require("obsidian");

// src/TaskModal.ts
var import_obsidian4 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/EditTask.svelte
var chrono = __toESM(require_dist());

// src/DateAbbreviations.ts
var abbreviations = {
  td: "today",
  tm: "tomorrow",
  yd: "yesterday",
  tw: "this week",
  nw: "next week",
  weekend: "sat",
  we: "sat"
};
function doAutocomplete(date) {
  for (const [key, val] of Object.entries(abbreviations)) {
    date = date.replace(RegExp(`\\b${key}\\s`, "i"), val);
  }
  return date;
}

// src/ui/EditTask.svelte
function create_fragment(ctx) {
  let div12;
  let form;
  let div0;
  let label0;
  let t1;
  let input0;
  let t2;
  let hr0;
  let t3;
  let div1;
  let label1;
  let t5;
  let select;
  let option0;
  let option1;
  let option2;
  let option3;
  let t13;
  let hr1;
  let t14;
  let div2;
  let label2;
  let t16;
  let input1;
  let t17;
  let code0;
  let t18;
  let t19;
  let html_tag;
  let t20;
  let hr2;
  let t21;
  let div6;
  let div3;
  let label3;
  let t23;
  let input2;
  let t24;
  let code1;
  let t25;
  let t26;
  let html_tag_1;
  let t27;
  let div4;
  let label4;
  let t29;
  let input3;
  let t30;
  let code2;
  let t31;
  let t32;
  let html_tag_2;
  let t33;
  let div5;
  let label5;
  let t35;
  let input4;
  let t36;
  let code3;
  let t37;
  let t38;
  let html_tag_3;
  let t39;
  let hr3;
  let t40;
  let div9;
  let div7;
  let t41;
  let input5;
  let input5_checked_value;
  let t42;
  let code4;
  let t43_value = ctx[0].status + "";
  let t43;
  let t44;
  let div8;
  let t45;
  let code5;
  let t46;
  let hr4;
  let t47;
  let div10;
  let t48;
  let div11;
  let mounted;
  let dispose;
  return {
    c() {
      div12 = element("div");
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Description";
      t1 = space();
      input0 = element("input");
      t2 = space();
      hr0 = element("hr");
      t3 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Priority";
      t5 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = "None";
      option1 = element("option");
      option1.textContent = `${prioritySymbols.High} High`;
      option2 = element("option");
      option2.textContent = `${prioritySymbols.Medium} Medium`;
      option3 = element("option");
      option3.textContent = `${prioritySymbols.Low} Low`;
      t13 = space();
      hr1 = element("hr");
      t14 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = "Recurrence";
      t16 = space();
      input1 = element("input");
      t17 = space();
      code0 = element("code");
      t18 = text(recurrenceSymbol);
      t19 = space();
      html_tag = new HtmlTag(false);
      t20 = space();
      hr2 = element("hr");
      t21 = space();
      div6 = element("div");
      div3 = element("div");
      label3 = element("label");
      label3.textContent = "Due";
      t23 = space();
      input2 = element("input");
      t24 = space();
      code1 = element("code");
      t25 = text(dueDateSymbol);
      t26 = space();
      html_tag_1 = new HtmlTag(false);
      t27 = space();
      div4 = element("div");
      label4 = element("label");
      label4.textContent = "Scheduled";
      t29 = space();
      input3 = element("input");
      t30 = space();
      code2 = element("code");
      t31 = text(scheduledDateSymbol);
      t32 = space();
      html_tag_2 = new HtmlTag(false);
      t33 = space();
      div5 = element("div");
      label5 = element("label");
      label5.textContent = "Start";
      t35 = space();
      input4 = element("input");
      t36 = space();
      code3 = element("code");
      t37 = text(startDateSymbol);
      t38 = space();
      html_tag_3 = new HtmlTag(false);
      t39 = space();
      hr3 = element("hr");
      t40 = space();
      div9 = element("div");
      div7 = element("div");
      t41 = text("Status:\n                ");
      input5 = element("input");
      t42 = space();
      code4 = element("code");
      t43 = text(t43_value);
      t44 = space();
      div8 = element("div");
      t45 = text("Done on:\n                ");
      code5 = element("code");
      t46 = space();
      hr4 = element("hr");
      t47 = space();
      div10 = element("div");
      t48 = space();
      div11 = element("div");
      div11.innerHTML = `<button type="submit" class="mod-cta">Apply</button>`;
      attr(label0, "for", "description");
      attr(input0, "id", "description");
      attr(input0, "type", "text");
      attr(input0, "class", "tasks-modal-description");
      attr(input0, "placeholder", "Take out the trash");
      attr(div0, "class", "tasks-modal-section");
      attr(label1, "for", "priority");
      option0.__value = "none";
      option0.value = option0.__value;
      option1.__value = "high";
      option1.value = option1.__value;
      option2.__value = "medium";
      option2.value = option2.__value;
      option3.__value = "low";
      option3.value = option3.__value;
      attr(select, "id", "priority");
      attr(select, "class", "dropdown");
      if (ctx[0].priority === void 0)
        add_render_callback(() => ctx[14].call(select));
      attr(div1, "class", "tasks-modal-section");
      attr(label2, "for", "recurrence");
      attr(input1, "id", "description");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Try 'every 2 weeks on Thursday'.");
      html_tag.a = null;
      attr(div2, "class", "tasks-modal-section");
      attr(label3, "for", "due");
      attr(input2, "id", "due");
      attr(input2, "type", "text");
      attr(input2, "placeholder", datePlaceholder);
      html_tag_1.a = null;
      attr(div3, "class", "tasks-modal-date");
      attr(label4, "for", "scheduled");
      attr(input3, "id", "scheduled");
      attr(input3, "type", "text");
      attr(input3, "placeholder", datePlaceholder);
      html_tag_2.a = null;
      attr(div4, "class", "tasks-modal-date");
      attr(label5, "for", "start");
      attr(input4, "id", "start");
      attr(input4, "type", "text");
      attr(input4, "placeholder", datePlaceholder);
      html_tag_3.a = null;
      attr(div5, "class", "tasks-modal-date");
      attr(div6, "class", "tasks-modal-section");
      attr(input5, "type", "checkbox");
      attr(input5, "class", "task-list-item-checkbox tasks-modal-checkbox");
      input5.checked = input5_checked_value = ctx[0].status === "Done" /* Done */;
      input5.disabled = true;
      attr(div9, "class", "tasks-modal-section");
      attr(div10, "class", "tasks-modal-section");
      attr(div11, "class", "tasks-modal-section");
      attr(div12, "class", "tasks-modal");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(input0, ctx[0].description);
      ctx[13](input0);
      append(form, t2);
      append(form, hr0);
      append(form, t3);
      append(form, div1);
      append(div1, label1);
      append(div1, t5);
      append(div1, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      append(select, option3);
      select_option(select, ctx[0].priority);
      append(form, t13);
      append(form, hr1);
      append(form, t14);
      append(form, div2);
      append(div2, label2);
      append(div2, t16);
      append(div2, input1);
      set_input_value(input1, ctx[0].recurrenceRule);
      append(div2, t17);
      append(div2, code0);
      append(code0, t18);
      append(code0, t19);
      html_tag.m(ctx[5], code0);
      append(form, t20);
      append(form, hr2);
      append(form, t21);
      append(form, div6);
      append(div6, div3);
      append(div3, label3);
      append(div3, t23);
      append(div3, input2);
      set_input_value(input2, ctx[0].dueDate);
      append(div3, t24);
      append(div3, code1);
      append(code1, t25);
      append(code1, t26);
      html_tag_1.m(ctx[4], code1);
      append(div6, t27);
      append(div6, div4);
      append(div4, label4);
      append(div4, t29);
      append(div4, input3);
      set_input_value(input3, ctx[0].scheduledDate);
      append(div4, t30);
      append(div4, code2);
      append(code2, t31);
      append(code2, t32);
      html_tag_2.m(ctx[3], code2);
      append(div6, t33);
      append(div6, div5);
      append(div5, label5);
      append(div5, t35);
      append(div5, input4);
      set_input_value(input4, ctx[0].startDate);
      append(div5, t36);
      append(div5, code3);
      append(code3, t37);
      append(code3, t38);
      html_tag_3.m(ctx[2], code3);
      append(form, t39);
      append(form, hr3);
      append(form, t40);
      append(form, div9);
      append(div9, div7);
      append(div7, t41);
      append(div7, input5);
      append(div7, t42);
      append(div7, code4);
      append(code4, t43);
      append(div9, t44);
      append(div9, div8);
      append(div8, t45);
      append(div8, code5);
      code5.innerHTML = ctx[6];
      append(form, t46);
      append(form, hr4);
      append(form, t47);
      append(form, div10);
      append(form, t48);
      append(form, div11);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[12]),
          listen(select, "change", ctx[14]),
          listen(input1, "input", ctx[15]),
          listen(input2, "input", ctx[16]),
          listen(input3, "input", ctx[17]),
          listen(input4, "input", ctx[18]),
          listen(form, "submit", prevent_default(ctx[7]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].description) {
        set_input_value(input0, ctx2[0].description);
      }
      if (dirty & 1) {
        select_option(select, ctx2[0].priority);
      }
      if (dirty & 1 && input1.value !== ctx2[0].recurrenceRule) {
        set_input_value(input1, ctx2[0].recurrenceRule);
      }
      if (dirty & 32)
        html_tag.p(ctx2[5]);
      if (dirty & 1 && input2.value !== ctx2[0].dueDate) {
        set_input_value(input2, ctx2[0].dueDate);
      }
      if (dirty & 16)
        html_tag_1.p(ctx2[4]);
      if (dirty & 1 && input3.value !== ctx2[0].scheduledDate) {
        set_input_value(input3, ctx2[0].scheduledDate);
      }
      if (dirty & 8)
        html_tag_2.p(ctx2[3]);
      if (dirty & 1 && input4.value !== ctx2[0].startDate) {
        set_input_value(input4, ctx2[0].startDate);
      }
      if (dirty & 4)
        html_tag_3.p(ctx2[2]);
      if (dirty & 1 && input5_checked_value !== (input5_checked_value = ctx2[0].status === "Done" /* Done */)) {
        input5.checked = input5_checked_value;
      }
      if (dirty & 1 && t43_value !== (t43_value = ctx2[0].status + ""))
        set_data(t43, t43_value);
      if (dirty & 64)
        code5.innerHTML = ctx2[6];
      ;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div12);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var datePlaceholder = "Try 'Monday' or 'tomorrow', or [td|tm|yd|tw|nw|we] then space.";
function instance($$self, $$props, $$invalidate) {
  var _a, _b;
  let { task } = $$props;
  let { onSubmit } = $$props;
  let descriptionInput;
  let editableTask = {
    description: "",
    status: "Todo" /* Todo */,
    priority: "none",
    recurrenceRule: "",
    startDate: "",
    scheduledDate: "",
    dueDate: "",
    doneDate: ""
  };
  let parsedStartDate = "";
  let parsedScheduledDate = "";
  let parsedDueDate = "";
  let parsedRecurrence = "";
  let parsedDone = "";
  let addGlobalFilterOnSave = false;
  function parseDate3(type, date, forwardDate = void 0) {
    if (!date) {
      return `<i>no ${type} date</i>`;
    }
    const parsed = chrono.parseDate(date, forwardDate, { forwardDate: forwardDate != void 0 });
    if (parsed !== null) {
      return window.moment(parsed).format("YYYY-MM-DD");
    }
    return `<i>invalid ${type} date</i>`;
  }
  onMount(() => {
    const { globalFilter } = getSettings();
    const description = task.getDescriptionWithoutGlobalFilter();
    if (description != task.description || description.indexOf(globalFilter) == -1)
      addGlobalFilterOnSave = true;
    let priority = "none";
    if (task.priority === "4" /* Low */) {
      priority = "low";
    } else if (task.priority === "2" /* Medium */) {
      priority = "medium";
    } else if (task.priority === "1" /* High */) {
      priority = "high";
    }
    $$invalidate(0, editableTask = {
      description,
      status: task.status,
      priority,
      recurrenceRule: task.recurrence ? task.recurrence.toText() : "",
      startDate: task.startDate ? task.startDate.format("YYYY-MM-DD") : "",
      scheduledDate: task.scheduledDate ? task.scheduledDate.format("YYYY-MM-DD") : "",
      dueDate: task.dueDate ? task.dueDate.format("YYYY-MM-DD") : "",
      doneDate: task.doneDate ? task.doneDate.format("YYYY-MM-DD") : ""
    });
    setTimeout(
      () => {
        descriptionInput.focus();
      },
      10
    );
  });
  const _onSubmit = () => {
    const { globalFilter } = getSettings();
    let description = editableTask.description.trim();
    if (addGlobalFilterOnSave) {
      description = globalFilter + " " + description;
    }
    let startDate = null;
    const parsedStartDate2 = chrono.parseDate(editableTask.startDate, new Date(), { forwardDate: true });
    if (parsedStartDate2 !== null) {
      startDate = window.moment(parsedStartDate2);
    }
    let scheduledDate = null;
    const parsedScheduledDate2 = chrono.parseDate(editableTask.scheduledDate, new Date(), { forwardDate: true });
    if (parsedScheduledDate2 !== null) {
      scheduledDate = window.moment(parsedScheduledDate2);
    }
    let dueDate = null;
    const parsedDueDate2 = chrono.parseDate(editableTask.dueDate, new Date(), { forwardDate: true });
    if (parsedDueDate2 !== null) {
      dueDate = window.moment(parsedDueDate2);
    }
    let recurrence = null;
    if (editableTask.recurrenceRule) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: editableTask.recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    let parsedPriority;
    switch (editableTask.priority) {
      case "low":
        parsedPriority = "4" /* Low */;
        break;
      case "medium":
        parsedPriority = "2" /* Medium */;
        break;
      case "high":
        parsedPriority = "1" /* High */;
        break;
      default:
        parsedPriority = "3" /* None */;
    }
    const updatedTask = new Task(Object.assign(Object.assign({}, task), {
      description,
      status: editableTask.status,
      priority: parsedPriority,
      recurrence,
      startDate,
      scheduledDate,
      dueDate,
      doneDate: window.moment(editableTask.doneDate, "YYYY-MM-DD").isValid() ? window.moment(editableTask.doneDate, "YYYY-MM-DD") : null
    }));
    onSubmit([updatedTask]);
  };
  function input0_input_handler() {
    editableTask.description = this.value;
    $$invalidate(0, editableTask);
  }
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      descriptionInput = $$value;
      $$invalidate(1, descriptionInput);
    });
  }
  function select_change_handler() {
    editableTask.priority = select_value(this);
    $$invalidate(0, editableTask);
  }
  function input1_input_handler() {
    editableTask.recurrenceRule = this.value;
    $$invalidate(0, editableTask);
  }
  function input2_input_handler() {
    editableTask.dueDate = this.value;
    $$invalidate(0, editableTask);
  }
  function input3_input_handler() {
    editableTask.scheduledDate = this.value;
    $$invalidate(0, editableTask);
  }
  function input4_input_handler() {
    editableTask.startDate = this.value;
    $$invalidate(0, editableTask);
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(8, task = $$props2.task);
    if ("onSubmit" in $$props2)
      $$invalidate(9, onSubmit = $$props2.onSubmit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $: {
        $$invalidate(0, editableTask.startDate = doAutocomplete(editableTask.startDate), editableTask);
        $$invalidate(2, parsedStartDate = parseDate3("start", editableTask.startDate, new Date()));
      }
    }
    if ($$self.$$.dirty & 1) {
      $: {
        $$invalidate(0, editableTask.scheduledDate = doAutocomplete(editableTask.scheduledDate), editableTask);
        $$invalidate(3, parsedScheduledDate = parseDate3("scheduled", editableTask.scheduledDate, new Date()));
      }
    }
    if ($$self.$$.dirty & 1) {
      $: {
        $$invalidate(0, editableTask.dueDate = doAutocomplete(editableTask.dueDate), editableTask);
        $$invalidate(4, parsedDueDate = parseDate3("due", editableTask.dueDate, new Date()));
      }
    }
    if ($$self.$$.dirty & 3073) {
      $: {
        if (!editableTask.recurrenceRule) {
          $$invalidate(5, parsedRecurrence = "<i>not recurring</>");
        } else {
          $$invalidate(5, parsedRecurrence = $$invalidate(11, _b = $$invalidate(10, _a = Recurrence.fromText({
            recurrenceRuleText: editableTask.recurrenceRule,
            startDate: null,
            scheduledDate: null,
            dueDate: null
          })) === null || _a === void 0 ? void 0 : _a.toText()) !== null && _b !== void 0 ? _b : "<i>invalid recurrence rule</i>");
        }
      }
    }
    if ($$self.$$.dirty & 1) {
      $: {
        $$invalidate(6, parsedDone = parseDate3("done", editableTask.doneDate));
      }
    }
  };
  return [
    editableTask,
    descriptionInput,
    parsedStartDate,
    parsedScheduledDate,
    parsedDueDate,
    parsedRecurrence,
    parsedDone,
    _onSubmit,
    task,
    onSubmit,
    _a,
    _b,
    input0_input_handler,
    input0_binding,
    select_change_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler
  ];
}
var EditTask = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { task: 8, onSubmit: 9 });
  }
};
var EditTask_default = EditTask;

// src/TaskModal.ts
var TaskModal = class extends import_obsidian4.Modal {
  constructor({
    app,
    task,
    onSubmit
  }) {
    super(app);
    this.task = task;
    this.onSubmit = (updatedTasks) => {
      onSubmit(updatedTasks);
      this.close();
    };
  }
  onOpen() {
    this.titleEl.setText("Create or edit Task");
    const { contentEl } = this;
    new EditTask_default({
      target: contentEl,
      props: { task: this.task, onSubmit: this.onSubmit }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Commands/CreateOrEdit.ts
var createOrEdit = (checking, editor, view, app) => {
  var _a;
  if (checking) {
    return view instanceof import_obsidian5.MarkdownView;
  }
  if (!(view instanceof import_obsidian5.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const cursorPosition = editor.getCursor();
  const lineNumber = cursorPosition.line;
  const line = editor.getLine(lineNumber);
  const task = taskFromLine({ line, path });
  const onSubmit = (updatedTasks) => {
    const serialized = updatedTasks.map((task2) => task2.toFileLineString()).join("\n");
    editor.setLine(lineNumber, serialized);
  };
  const taskModal = new TaskModal({
    app,
    task,
    onSubmit
  });
  taskModal.open();
};
var taskFromLine = ({ line, path }) => {
  var _a;
  const task = Task.fromLine({
    line,
    path,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null
  });
  if (task !== null) {
    return task;
  }
  const nonTaskRegex = /^([\s\t>]*)[-*]? *(\[(.)\])? *(.*)/u;
  const nonTaskMatch = line.match(nonTaskRegex);
  if (nonTaskMatch === null) {
    console.error("Tasks: Cannot create task on line:", line);
    return new Task({
      status: "Todo" /* Todo */,
      description: "",
      path,
      indentation: "",
      originalStatusCharacter: " ",
      priority: "3" /* None */,
      startDate: null,
      scheduledDate: null,
      dueDate: null,
      doneDate: null,
      recurrence: null,
      sectionStart: 0,
      sectionIndex: 0,
      precedingHeader: null,
      blockLink: "",
      tags: []
    });
  }
  const indentation = nonTaskMatch[1];
  const statusString = (_a = nonTaskMatch[3]) != null ? _a : " ";
  const status = statusString === " " ? "Todo" /* Todo */ : "Done" /* Done */;
  let description = nonTaskMatch[4];
  const blockLinkMatch = line.match(Task.blockLinkRegex);
  const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
  if (blockLink !== "") {
    description = description.replace(Task.blockLinkRegex, "");
  }
  return new Task({
    status,
    description,
    path,
    indentation,
    originalStatusCharacter: statusString,
    blockLink,
    priority: "3" /* None */,
    startDate: null,
    scheduledDate: null,
    dueDate: null,
    doneDate: null,
    recurrence: null,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null,
    tags: []
  });
};

// src/Commands/ToggleDone.ts
var import_obsidian6 = require("obsidian");
var toggleDone = (checking, editor, view) => {
  var _a;
  if (checking) {
    if (!(view instanceof import_obsidian6.MarkdownView)) {
      return false;
    }
    return true;
  }
  if (!(view instanceof import_obsidian6.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const cursorPosition = editor.getCursor();
  const lineNumber = cursorPosition.line;
  const line = editor.getLine(lineNumber);
  const toggledLine = toggleLine({ line, path });
  editor.setLine(lineNumber, toggledLine);
  if (/[^ [\]*-]/.test(toggledLine)) {
    editor.setCursor({
      line: cursorPosition.line,
      ch: cursorPosition.ch + toggledLine.length - line.length
    });
  }
};
var toggleLine = ({ line, path }) => {
  let toggledLine = line;
  const task = Task.fromLine({
    line,
    path,
    sectionStart: 0,
    sectionIndex: 0,
    precedingHeader: null
  });
  if (task !== null) {
    toggledLine = toggleTask({ task });
  } else {
    const regexMatch = line.match(Task.taskRegex);
    if (regexMatch !== null) {
      toggledLine = toggleChecklistItem({ regexMatch });
    } else {
      const listItemRegex = /^([\s\t>]*)([-*])/;
      if (listItemRegex.test(line)) {
        toggledLine = line.replace(listItemRegex, "$1$2 [ ]");
      } else {
        toggledLine = line.replace(/^([\s\t>]*)/, "$1- ");
      }
    }
  }
  return toggledLine;
};
var toggleTask = ({ task }) => {
  const toggledTasks = task.toggle();
  const serialized = toggledTasks.map((task2) => task2.toFileLineString()).join("\n");
  return serialized;
};
var toggleChecklistItem = ({
  regexMatch
}) => {
  const indentation = regexMatch[1];
  const statusString = regexMatch[2].toLowerCase();
  const body = regexMatch[3];
  const toggledStatusString = statusString === " " ? "x" : " ";
  const toggledLine = `${indentation}- [${toggledStatusString}] ${body}`;
  return toggledLine;
};

// src/Commands/index.ts
var Commands = class {
  get app() {
    return this.plugin.app;
  }
  constructor({ plugin }) {
    this.plugin = plugin;
    plugin.addCommand({
      id: "edit-task",
      name: "Create or edit task",
      icon: "pencil",
      editorCheckCallback: (checking, editor, view) => {
        return createOrEdit(checking, editor, view, this.app);
      }
    });
    plugin.addCommand({
      id: "toggle-done",
      name: "Toggle task done",
      icon: "check-in-circle",
      editorCheckCallback: toggleDone
    });
  }
};

// src/Events.ts
var Events = class {
  constructor({ obsidianEvents }) {
    this.obsidianEvents = obsidianEvents;
  }
  onCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, handler);
  }
  triggerCacheUpdate(cacheData) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, cacheData);
  }
  onRequestCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, handler);
  }
  triggerRequestCacheUpdate(fn) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, fn);
  }
  off(eventRef) {
    this.obsidianEvents.offref(eventRef);
  }
};

// src/InlineRenderer.ts
var InlineRenderer = class {
  constructor({ plugin }) {
    this.markdownPostProcessor = this._markdownPostProcessor.bind(this);
    plugin.registerMarkdownPostProcessor(
      this._markdownPostProcessor.bind(this)
    );
  }
  _markdownPostProcessor(element2, context) {
    return __async(this, null, function* () {
      var _a;
      const { globalFilter } = getSettings();
      const renderedElements = element2.findAll(".task-list-item").filter((taskItem) => {
        var _a2;
        const linesText = (_a2 = taskItem.textContent) == null ? void 0 : _a2.split("\n");
        if (linesText === void 0) {
          return false;
        }
        let firstLineText = null;
        for (let i = 0; i < linesText.length; i = i + 1) {
          if (linesText[i] !== "") {
            firstLineText = linesText[i];
            break;
          }
        }
        if (firstLineText === null) {
          return false;
        }
        return firstLineText.includes(globalFilter);
      });
      if (renderedElements.length === 0) {
        return;
      }
      const path = context.sourcePath;
      const section = context.getSectionInfo(element2);
      if (section === null) {
        return;
      }
      const fileLines = section.text.split("\n");
      let sectionIndex = 0;
      const fileTasks = [];
      for (let lineNumber = section.lineStart; lineNumber <= section.lineEnd; lineNumber++) {
        const line = fileLines[lineNumber];
        if (line === void 0) {
          continue;
        }
        const task = Task.fromLine({
          line,
          path,
          sectionStart: section.lineStart,
          sectionIndex,
          precedingHeader: null
        });
        if (task !== null) {
          fileTasks.push(task);
          sectionIndex++;
        }
      }
      for (let sectionIndex2 = 0; sectionIndex2 < renderedElements.length; sectionIndex2++) {
        const task = fileTasks[sectionIndex2];
        const renderedElement = renderedElements[sectionIndex2];
        if (task === void 0 || renderedElement === void 0) {
          continue;
        }
        const dataLine = (_a = renderedElement.getAttr("data-line")) != null ? _a : "0";
        const listIndex = Number.parseInt(dataLine, 10);
        const taskElement = yield task.toLi({
          parentUlElement: element2,
          listIndex
        });
        const renderedChildren = renderedElement.childNodes;
        for (let i = 0; i < renderedChildren.length; i = i + 1) {
          const renderedChild = renderedChildren[i];
          if (renderedChild.nodeName.toLowerCase() === "div") {
            taskElement.prepend(renderedChild);
          } else if (renderedChild.nodeName.toLowerCase() === "ul") {
            taskElement.append(renderedChild);
          }
        }
        const originalFootnotes = renderedElement.querySelectorAll("[data-footnote-id]");
        const newFootnotes = taskElement.querySelectorAll("[data-footnote-id]");
        if (originalFootnotes.length === newFootnotes.length) {
          for (let i = 0; i < originalFootnotes.length; i++) {
            newFootnotes[i].replaceWith(originalFootnotes[i]);
          }
        }
        renderedElement.replaceWith(taskElement);
      }
    });
  }
};

// src/LivePreviewExtension.ts
var import_view = require("@codemirror/view");
var import_obsidian7 = require("obsidian");
var newLivePreviewExtension = () => {
  return import_view.ViewPlugin.fromClass(LivePreviewExtension);
};
var LivePreviewExtension = class {
  constructor(view) {
    this.view = view;
    this.handleClickEvent = this.handleClickEvent.bind(this);
    this.view.dom.addEventListener("click", this.handleClickEvent);
  }
  destroy() {
    this.view.dom.removeEventListener("click", this.handleClickEvent);
  }
  handleClickEvent(event) {
    const { target } = event;
    if (!target || !(target instanceof HTMLInputElement) || target.type !== "checkbox") {
      return false;
    }
    const ancestor = target.closest(
      "ul.plugin-tasks-query-result, div.callout-content"
    );
    if (ancestor) {
      if (ancestor.matches("div.callout-content")) {
        const msg = 'obsidian-tasks-plugin warning: Tasks cannot add or remove completion dates or make the next copy of a recurring task for tasks written inside a callout when you click their checkboxes in Live Preview. \nIf you wanted Tasks to do these things, please undo your change, then either click the line of the task and use the "Toggle Task Done" command, or switch to Reading View to click the checkbox.';
        console.warn(msg);
        new import_obsidian7.Notice(msg, 45e3);
      }
      return false;
    }
    const { state } = this.view;
    const position = this.view.posAtDOM(target);
    const line = state.doc.lineAt(position);
    const task = Task.fromLine({
      line: line.text,
      path: "",
      sectionStart: 0,
      sectionIndex: 0,
      precedingHeader: null
    });
    console.debug(
      `Live Preview Extension: toggle called. Position: ${position} Line: ${line.text}`
    );
    if (task === null) {
      return false;
    }
    event.preventDefault();
    const toggled = task.toggle();
    const toggledString = toggled.map((t) => t.toFileLineString()).join(state.lineBreak);
    const transaction = state.update({
      changes: {
        from: line.from,
        to: line.to,
        insert: toggledString
      }
    });
    this.view.dispatch(transaction);
    const desiredCheckedStatus = target.checked;
    setTimeout(() => {
      target.checked = desiredCheckedStatus;
    }, 1);
    return true;
  }
};

// src/QueryRenderer.ts
var import_obsidian8 = require("obsidian");

// src/Query/GroupHeading.ts
var GroupHeading = class {
  constructor(nestingLevel, name) {
    this.nestingLevel = nestingLevel;
    this.name = name;
  }
};

// src/Query/GroupHeadings.ts
var GroupHeadings = class {
  constructor(groupedTasks) {
    this.lastHeadingAtLevel = new Array();
    const firstGroup = groupedTasks.keys().next().value;
    const groupCount = firstGroup.length;
    for (let i = 0; i < groupCount; i++) {
      this.lastHeadingAtLevel.push("");
    }
  }
  getHeadingsForTaskGroup(groupNames) {
    const headingsForGroup = new Array();
    for (let level = 0; level < groupNames.length; level++) {
      const group = groupNames[level];
      if (group != this.lastHeadingAtLevel[level]) {
        headingsForGroup.push(new GroupHeading(level, group));
        for (let j = level; j < groupNames.length; j++) {
          this.lastHeadingAtLevel[j] = "";
        }
        this.lastHeadingAtLevel[level] = group;
      }
    }
    return headingsForGroup;
  }
};

// src/Query/GroupingTreeNode.ts
var GroupingTreeNode = class {
  constructor(values) {
    this.children = /* @__PURE__ */ new Map();
    this.values = [];
    this.values = values;
  }
  generateAllPaths(pathSoFar = []) {
    const resultMap = /* @__PURE__ */ new Map();
    if (this.children.size == 0) {
      resultMap.set([...pathSoFar], this.values);
      return resultMap;
    }
    for (const [property, child] of this.children) {
      pathSoFar.push(property);
      const childResult = child.generateAllPaths(pathSoFar);
      childResult.forEach((value, key) => resultMap.set(key, value));
      pathSoFar.pop();
    }
    return resultMap;
  }
};

// src/Query/IntermediateTaskGroups.ts
var IntermediateTaskGroupsStorage = class extends Map {
};
var TaskGroupingTreeNode = class extends GroupingTreeNode {
};
var IntermediateTaskGroups = class {
  constructor(groupings, tasks) {
    this.groups = new IntermediateTaskGroupsStorage();
    const tree = this.buildGroupingTree(groupings, tasks);
    this.groups = tree.generateAllPaths();
    this.groups = this.getSortedGroups();
  }
  buildGroupingTree(groupings, tasks) {
    const root = new TaskGroupingTreeNode(tasks);
    let currentTreeLevel = [root];
    for (const grouping of groupings) {
      const nextTreeLevel = [];
      for (const currentTreeNode of currentTreeLevel) {
        for (const task of currentTreeNode.values) {
          const groupNames = Group.getGroupNamesForTask(
            grouping.property,
            task
          );
          for (const groupName of groupNames) {
            let child = currentTreeNode.children.get(groupName);
            if (child === void 0) {
              child = new TaskGroupingTreeNode([]);
              currentTreeNode.children.set(groupName, child);
              nextTreeLevel.push(child);
            }
            child.values.push(task);
          }
        }
      }
      currentTreeLevel = nextTreeLevel;
    }
    return root;
  }
  getSortedGroups() {
    return new IntermediateTaskGroupsStorage(
      [...this.groups.entries()].sort()
    );
  }
};

// src/Query/TaskGroup.ts
var TaskGroup = class {
  constructor(groups, groupHeadings, tasks) {
    this.groups = groups;
    this.groupHeadings = groupHeadings;
    this.tasks = tasks;
  }
  tasksAsStringOfLines() {
    let output = "";
    for (const task of this.tasks) {
      output += task.toFileLineString() + "\n";
    }
    return output;
  }
  toString() {
    let output = "\n";
    output += `Group names: [${this.groups}]
`;
    for (const heading of this.groupHeadings) {
      const headingPrefix = "#".repeat(4 + heading.nestingLevel);
      output += `${headingPrefix} ${heading.name}
`;
    }
    output += this.tasksAsStringOfLines();
    return output;
  }
};

// src/Query/TaskGroups.ts
var TaskGroups = class {
  constructor(groups, tasks) {
    this._groups = new Array();
    this._totalTaskCount = 0;
    this._totalTaskCount = tasks.length;
    const initialGroups = new IntermediateTaskGroups(groups, tasks);
    this.addTasks(initialGroups);
  }
  get groups() {
    return this._groups;
  }
  totalTasksCount() {
    return this._totalTaskCount;
  }
  toString() {
    let output = "";
    for (const taskGroup of this.groups) {
      output += taskGroup.toString();
      output += "\n---\n";
    }
    const totalTasksCount = this.totalTasksCount();
    output += `
${totalTasksCount} tasks
`;
    return output;
  }
  addTasks(initialGroups) {
    const grouper = new GroupHeadings(initialGroups.groups);
    for (const [groups, tasks] of initialGroups.groups) {
      const groupHeadings = grouper.getHeadingsForTaskGroup(groups);
      const taskGroup = new TaskGroup(groups, groupHeadings, tasks);
      this.add(taskGroup);
    }
  }
  add(taskGroup) {
    this._groups.push(taskGroup);
  }
};

// src/Query/DateParser.ts
var chrono2 = __toESM(require_dist());
var DateParser = class {
  static parseDate(input, forwardDate = false) {
    return window.moment(
      chrono2.parseDate(input, void 0, {
        forwardDate
      })
    ).startOf("day");
  }
};

// src/Query/Filter/Field.ts
var Field = class {
  canCreateFilterForLine(line) {
    return Field.lineMatchesFilter(this.filterRegexp(), line);
  }
  static lineMatchesFilter(filter, line) {
    if (filter) {
      return filter.test(line);
    } else {
      return false;
    }
  }
  static getMatch(filterRegexp, line) {
    if (filterRegexp) {
      return line.match(filterRegexp);
    } else {
      return null;
    }
  }
};

// src/Query/Filter/Filter.ts
var FilterOrErrorMessage = class {
};

// src/Query/Filter/HappensDateField.ts
var _HappensDateField = class extends Field {
  canCreateFilterForLine(line) {
    if (line === _HappensDateField.instructionForFieldPresence) {
      return true;
    }
    if (line === _HappensDateField.instructionForFieldAbsence) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    if (line === _HappensDateField.instructionForFieldPresence) {
      const result2 = new FilterOrErrorMessage();
      result2.filter = (task) => this.dates(task).some((date) => date !== null);
      return result2;
    }
    if (line === _HappensDateField.instructionForFieldAbsence) {
      const result2 = new FilterOrErrorMessage();
      result2.filter = (task) => !this.dates(task).some((date) => date !== null);
      return result2;
    }
    const happensMatch = Field.getMatch(this.filterRegexp(), line);
    if (happensMatch !== null) {
      const filterDate = DateParser.parseDate(happensMatch[2]);
      if (!filterDate.isValid()) {
        result.error = "do not understand happens date";
      } else {
        if (happensMatch[1] === "before") {
          result.filter = (task) => {
            return this.dates(task).some(
              (date) => date && date.isBefore(filterDate)
            );
          };
        } else if (happensMatch[1] === "after") {
          result.filter = (task) => {
            return this.dates(task).some(
              (date) => date && date.isAfter(filterDate)
            );
          };
        } else {
          result.filter = (task) => {
            return this.dates(task).some(
              (date) => date && date.isSame(filterDate)
            );
          };
        }
      }
    } else {
      result.error = "do not understand query filter (happens date)";
    }
    return result;
  }
  earliestDate(task) {
    const happensDates = new _HappensDateField().dates(task);
    const sortedHappensDates = happensDates.sort(Sort.compareByDate);
    return sortedHappensDates[0];
  }
  filterRegexp() {
    return _HappensDateField.happensRegexp;
  }
  dates(task) {
    return Array.of(task.startDate, task.scheduledDate, task.dueDate);
  }
  fieldName() {
    return "happens";
  }
};
var HappensDateField = _HappensDateField;
HappensDateField.happensRegexp = /^happens (before|after|on)? ?(.*)/;
HappensDateField.instructionForFieldPresence = "has happens date";
HappensDateField.instructionForFieldAbsence = "no happens date";

// src/Query/Group.ts
var _Group = class {
  static by(grouping, tasks) {
    return new TaskGroups(grouping, tasks);
  }
  static getGroupNamesForTask(property, task) {
    const grouper = _Group.groupers[property];
    return grouper(task);
  }
  static groupByPriority(task) {
    let priorityName = "ERROR";
    switch (task.priority) {
      case "1" /* High */:
        priorityName = "High";
        break;
      case "2" /* Medium */:
        priorityName = "Medium";
        break;
      case "3" /* None */:
        priorityName = "None";
        break;
      case "4" /* Low */:
        priorityName = "Low";
        break;
    }
    return [`Priority ${task.priority}: ${priorityName}`];
  }
  static groupByRecurrence(task) {
    if (task.recurrence !== null) {
      return [task.recurrence.toText()];
    } else {
      return ["None"];
    }
  }
  static groupByRecurring(task) {
    if (task.recurrence !== null) {
      return ["Recurring"];
    } else {
      return ["Not Recurring"];
    }
  }
  static groupByStartDate(task) {
    return [_Group.stringFromDate(task.startDate, "start")];
  }
  static groupByScheduledDate(task) {
    return [_Group.stringFromDate(task.scheduledDate, "scheduled")];
  }
  static groupByDueDate(task) {
    return [_Group.stringFromDate(task.dueDate, "due")];
  }
  static groupByDoneDate(task) {
    return [_Group.stringFromDate(task.doneDate, "done")];
  }
  static groupByHappensDate(task) {
    const earliestDateIfAny = new HappensDateField().earliestDate(task);
    return [_Group.stringFromDate(earliestDateIfAny, "happens")];
  }
  static stringFromDate(date, field) {
    if (date === null) {
      return "No " + field + " date";
    }
    return date.format(_Group.groupDateFormat);
  }
  static groupByPath(task) {
    return [task.path.replace(".md", "")];
  }
  static groupByFolder(task) {
    const path = task.path;
    const fileNameWithExtension = task.filename + ".md";
    const folder = path.substring(
      0,
      path.lastIndexOf(fileNameWithExtension)
    );
    if (folder === "") {
      return ["/"];
    }
    return [folder];
  }
  static groupByFileName(task) {
    const filename = task.filename;
    if (filename === null) {
      return ["Unknown Location"];
    }
    return [filename];
  }
  static groupByRoot(task) {
    const path = task.path.replace(/\\/g, "/");
    const separatorIndex = path.indexOf("/");
    if (separatorIndex == -1) {
      return ["/"];
    }
    return [path.substring(0, separatorIndex + 1)];
  }
  static groupByBacklink(task) {
    const linkText = task.getLinkText({ isFilenameUnique: true });
    if (linkText === null) {
      return ["Unknown Location"];
    }
    return [linkText];
  }
  static groupByStatus(task) {
    return [task.status];
  }
  static groupByHeading(task) {
    if (task.precedingHeader === null || task.precedingHeader.length === 0) {
      return ["(No heading)"];
    }
    return [task.precedingHeader];
  }
  static groupByTags(task) {
    if (task.tags.length == 0) {
      return ["(No tags)"];
    }
    return task.tags;
  }
};
var Group = _Group;
Group.groupDateFormat = "YYYY-MM-DD dddd";
Group.groupers = {
  backlink: _Group.groupByBacklink,
  done: _Group.groupByDoneDate,
  due: _Group.groupByDueDate,
  filename: _Group.groupByFileName,
  folder: _Group.groupByFolder,
  happens: _Group.groupByHappensDate,
  heading: _Group.groupByHeading,
  path: _Group.groupByPath,
  priority: _Group.groupByPriority,
  recurrence: _Group.groupByRecurrence,
  recurring: _Group.groupByRecurring,
  root: _Group.groupByRoot,
  scheduled: _Group.groupByScheduledDate,
  start: _Group.groupByStartDate,
  status: _Group.groupByStatus,
  tags: _Group.groupByTags
};

// src/Query/Filter/TextField.ts
var TextField = class extends Field {
  maybeNegate(match, filterMethod) {
    return filterMethod.match(/not/) ? !match : match;
  }
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    const match = Field.getMatch(this.filterRegexp(), line);
    if (match !== null) {
      const filterMethod = match[1];
      if (["includes", "does not include"].includes(filterMethod)) {
        result.filter = (task) => this.maybeNegate(
          TextField.stringIncludesCaseInsensitive(
            this.value(task),
            match[2]
          ),
          filterMethod
        );
      } else if (["regex matches", "regex does not match"].includes(filterMethod)) {
        const regexPattern = /\/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/;
        const query = match[2].match(regexPattern);
        if (query !== null) {
          result.filter = (task) => this.maybeNegate(
            this.value(task).match(
              new RegExp(query[1], query[2])
            ) !== null,
            filterMethod
          );
        } else {
          result.error = `cannot parse regex (${this.fieldName()}); check your leading and trailing slashes for your query`;
        }
      } else {
        result.error = `do not understand query filter (${this.fieldName()})`;
      }
    } else {
      result.error = `do not understand query filter (${this.fieldName()})`;
    }
    return result;
  }
  static stringIncludesCaseInsensitive(haystack, needle) {
    return haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase());
  }
  filterRegexp() {
    return new RegExp(
      `^${this.fieldName()} (includes|does not include|regex matches|regex does not match) (.*)`
    );
  }
};

// src/Query/Filter/DescriptionField.ts
var DescriptionField = class extends TextField {
  fieldName() {
    return "description";
  }
  value(task) {
    const globalFilter = getSettings().globalFilter;
    return task.description.replace(globalFilter, "").trim();
  }
};

// src/Query/Filter/DateField.ts
var DateField = class extends Field {
  constructor() {
    super(...arguments);
    this.instructionForFieldPresence = `has ${this.fieldName()} date`;
    this.instructionForFieldAbsence = `no ${this.fieldName()} date`;
  }
  canCreateFilterForLine(line) {
    if (line === this.instructionForFieldPresence) {
      return true;
    }
    if (line === this.instructionForFieldAbsence) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    if (line === this.instructionForFieldPresence) {
      result.filter = (task) => this.date(task) !== null;
      return result;
    }
    if (line === this.instructionForFieldAbsence) {
      result.filter = (task) => this.date(task) === null;
      return result;
    }
    const match = Field.getMatch(this.filterRegexp(), line);
    if (match !== null) {
      const filterDate = DateParser.parseDate(match[2]);
      if (!filterDate.isValid()) {
        result.error = "do not understand " + this.fieldName() + " date";
      } else {
        if (match[1] === "before") {
          result.filter = (task) => {
            const date = this.date(task);
            return date ? date.isBefore(filterDate) : this.filterResultIfFieldMissing();
          };
        } else if (match[1] === "after") {
          result.filter = (task) => {
            const date = this.date(task);
            return date ? date.isAfter(filterDate) : this.filterResultIfFieldMissing();
          };
        } else {
          result.filter = (task) => {
            const date = this.date(task);
            return date ? date.isSame(filterDate) : this.filterResultIfFieldMissing();
          };
        }
      }
    } else {
      result.error = "do not understand query filter (" + this.fieldName() + " date)";
    }
    return result;
  }
};

// src/Query/Filter/DoneDateField.ts
var _DoneDateField = class extends DateField {
  filterRegexp() {
    return _DoneDateField.doneRegexp;
  }
  fieldName() {
    return "done";
  }
  date(task) {
    return task.doneDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var DoneDateField = _DoneDateField;
DoneDateField.doneRegexp = /^done (before|after|on)? ?(.*)/;

// src/Query/Filter/DueDateField.ts
var _DueDateField = class extends DateField {
  filterRegexp() {
    return _DueDateField.dueRegexp;
  }
  fieldName() {
    return "due";
  }
  date(task) {
    return task.dueDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var DueDateField = _DueDateField;
DueDateField.dueRegexp = /^due (before|after|on)? ?(.*)/;

// src/Query/Filter/FilterInstruction.ts
var FilterInstruction = class {
  constructor(instruction, filter) {
    this._instruction = instruction;
    this._filter = filter;
  }
  canCreateFilterForLine(line) {
    return line == this._instruction;
  }
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    if (line === this._instruction) {
      result.filter = this._filter;
      return result;
    }
    result.error = `do not understand filter: ${line}`;
    return result;
  }
};

// src/Query/Filter/FilterInstructions.ts
var FilterInstructions = class {
  constructor() {
    this._filters = [];
  }
  add(instruction, filter) {
    this._filters.push(new FilterInstruction(instruction, filter));
  }
  canCreateFilterForLine(line) {
    for (const filter of this._filters) {
      if (filter.canCreateFilterForLine(line)) {
        return true;
      }
    }
    return false;
  }
  createFilterOrErrorMessage(line) {
    for (const filter of this._filters) {
      const x = filter.createFilterOrErrorMessage(line);
      if (x.error === void 0) {
        return x;
      }
    }
    const result = new FilterOrErrorMessage();
    result.error = `do not understand filter: ${line}`;
    return result;
  }
};

// src/Query/Filter/FilterInstructionsBasedField.ts
var FilterInstructionsBasedField = class extends Field {
  constructor() {
    super(...arguments);
    this._filters = new FilterInstructions();
  }
  canCreateFilterForLine(line) {
    return this._filters.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    return this._filters.createFilterOrErrorMessage(line);
  }
  filterRegexp() {
    return null;
  }
};

// src/Query/Filter/ExcludeSubItemsField.ts
var ExcludeSubItemsField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("exclude sub-items", (task) => {
      if (task.indentation === "")
        return true;
      const lastBlockquoteMark = task.indentation.lastIndexOf(">");
      if (lastBlockquoteMark === -1)
        return false;
      return /^ ?$/.test(task.indentation.slice(lastBlockquoteMark + 1));
    });
  }
  fieldName() {
    return "exclude";
  }
};

// src/Query/Filter/HeadingField.ts
var HeadingField = class extends TextField {
  fieldName() {
    return "heading";
  }
  value(task) {
    if (task.precedingHeader) {
      return task.precedingHeader;
    } else {
      return "";
    }
  }
};

// src/Query/Filter/PathField.ts
var PathField = class extends TextField {
  fieldName() {
    return "path";
  }
  value(task) {
    return task.path;
  }
};

// src/Query/Filter/PriorityField.ts
var _PriorityField = class extends Field {
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    const priorityMatch = Field.getMatch(this.filterRegexp(), line);
    if (priorityMatch !== null) {
      const filterPriorityString = priorityMatch[3];
      let filterPriority = null;
      switch (filterPriorityString) {
        case "low":
          filterPriority = "4" /* Low */;
          break;
        case "none":
          filterPriority = "3" /* None */;
          break;
        case "medium":
          filterPriority = "2" /* Medium */;
          break;
        case "high":
          filterPriority = "1" /* High */;
          break;
      }
      if (filterPriority === null) {
        result.error = "do not understand priority";
        return result;
      }
      let filter;
      if (priorityMatch[2] === "above") {
        filter = (task) => task.priority ? task.priority.localeCompare(filterPriority) < 0 : false;
      } else if (priorityMatch[2] === "below") {
        filter = (task) => task.priority ? task.priority.localeCompare(filterPriority) > 0 : false;
      } else {
        filter = (task) => task.priority ? task.priority === filterPriority : false;
      }
      result.filter = filter;
    } else {
      result.error = "do not understand query filter (priority)";
    }
    return result;
  }
  fieldName() {
    return "priority";
  }
  filterRegexp() {
    return _PriorityField.priorityRegexp;
  }
};
var PriorityField = _PriorityField;
PriorityField.priorityRegexp = /^priority (is )?(above|below)? ?(low|none|medium|high)/;

// src/Query/Filter/ScheduledDateField.ts
var _ScheduledDateField = class extends DateField {
  filterRegexp() {
    return _ScheduledDateField.scheduledRegexp;
  }
  fieldName() {
    return "scheduled";
  }
  date(task) {
    return task.scheduledDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};
var ScheduledDateField = _ScheduledDateField;
ScheduledDateField.scheduledRegexp = /^scheduled (before|after|on)? ?(.*)/;

// src/Query/Filter/StartDateField.ts
var _StartDateField = class extends DateField {
  filterRegexp() {
    return _StartDateField.startRegexp;
  }
  fieldName() {
    return "start";
  }
  date(task) {
    return task.startDate;
  }
  filterResultIfFieldMissing() {
    return true;
  }
};
var StartDateField = _StartDateField;
StartDateField.startRegexp = /^starts (before|after|on)? ?(.*)/;

// src/Query/Filter/RecurringField.ts
var RecurringField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("is recurring", (task) => task.recurrence !== null);
    this._filters.add(
      "is not recurring",
      (task) => task.recurrence === null
    );
  }
  fieldName() {
    return "recurring";
  }
};

// src/Query/Filter/StatusField.ts
var StatusField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("done", (task) => task.status === "Done" /* Done */);
    this._filters.add(
      "not done",
      (task) => task.status !== "Done" /* Done */
    );
  }
  fieldName() {
    return "status";
  }
};

// src/Query/Filter/TagsField.ts
var _TagsField = class extends Field {
  createFilterOrErrorMessage(line) {
    const result = new FilterOrErrorMessage();
    const tagMatch = Field.getMatch(this.filterRegexp(), line);
    if (tagMatch !== null) {
      const filterMethod = tagMatch[2];
      const search = tagMatch[3].replace(/^#/, "");
      if (filterMethod === "include" || filterMethod === "includes") {
        result.filter = (task) => task.tags.find(
          (tag) => tag.toLowerCase().includes(search.toLowerCase())
        ) !== void 0;
      } else if (tagMatch[2] === "do not include" || tagMatch[2] === "does not include") {
        result.filter = (task) => task.tags.find(
          (tag) => tag.toLowerCase().includes(search.toLowerCase())
        ) == void 0;
      } else {
        result.error = "do not understand query filter (tag/tags)";
      }
    } else {
      result.error = "do not understand query filter (tag/tags)";
    }
    return result;
  }
  fieldName() {
    return "tag/tags";
  }
  filterRegexp() {
    return _TagsField.tagRegexp;
  }
};
var TagsField = _TagsField;
TagsField.tagRegexp = /^(tag|tags) (includes|does not include|include|do not include) (.*)/;

// src/Query/Filter/BooleanField.ts
var import_boon_js = __toESM(require_lib());
var BooleanField = class extends Field {
  constructor() {
    super(...arguments);
    this.basicBooleanRegexp = /.*(AND|OR|XOR|NOT)\s*[("].*/g;
    this.supportedOperators = ["AND", "OR", "XOR", "NOT"];
    this.subFields = {};
  }
  filterRegexp() {
    return this.basicBooleanRegexp;
  }
  createFilterOrErrorMessage(line) {
    return this.parseLine(line);
  }
  fieldName() {
    return "boolean query";
  }
  parseLine(line) {
    const result = new FilterOrErrorMessage();
    if (line.length === 0) {
      result.error = "empty line";
      return result;
    }
    const preprocessed = this.preprocessExpression(line);
    try {
      const postfixExpression = (0, import_boon_js.parse)(preprocessed);
      for (const token of postfixExpression) {
        if (token.name === "IDENTIFIER" && token.value) {
          const identifier = token.value.trim();
          if (!(identifier in this.subFields)) {
            const parsedField = parseFilter(identifier);
            if (parsedField === null) {
              result.error = `couldn't parse sub-expression '${identifier}'`;
              return result;
            }
            if (parsedField.error) {
              result.error = `couldn't parse sub-expression '${identifier}': ${parsedField.error}`;
              return result;
            } else if (parsedField.filter) {
              this.subFields[identifier] = parsedField.filter;
            }
          }
        } else if (token.name === "OPERATOR") {
          if (token.value == void 0) {
            result.error = "empty operator in boolean query";
            return result;
          }
          if (!this.supportedOperators.includes(token.value)) {
            result.error = `unknown boolean operator '${token.value}'`;
            return result;
          }
        }
      }
      result.filter = (task) => {
        return this.filterTaskWithParsedQuery(task, postfixExpression);
      };
      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error type";
      result.error = `malformed boolean query -- ${message} (check the documentation for guidelines)`;
      return result;
    }
    return result;
  }
  preprocessExpression(line) {
    return line.replace(/\(([^()]+)\)/g, '("$1")');
  }
  filterTaskWithParsedQuery(task, postfixExpression) {
    const toBool = (s) => {
      return s === "true";
    };
    const toString = (b) => {
      return b ? "true" : "false";
    };
    const booleanStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        const result = filter(task);
        booleanStack.push(toString(result));
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = toBool(booleanStack.pop());
          booleanStack.push(toString(!arg1));
        } else if (token.value === "OR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 || arg2));
        } else if (token.value === "AND") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && arg2));
        } else if (token.value === "XOR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(
            toString(arg1 && !arg2 || !arg1 && arg2)
          );
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token);
      }
    }
    return toBool(booleanStack[0]);
  }
};

// src/Query/FilterParser.ts
var fieldCreators = [
  () => new StatusField(),
  () => new RecurringField(),
  () => new PriorityField(),
  () => new HappensDateField(),
  () => new StartDateField(),
  () => new ScheduledDateField(),
  () => new DueDateField(),
  () => new DoneDateField(),
  () => new PathField(),
  () => new DescriptionField(),
  () => new TagsField(),
  () => new HeadingField(),
  () => new ExcludeSubItemsField(),
  () => new BooleanField()
];
function parseFilter(filterString) {
  for (const creator of fieldCreators) {
    const field = creator();
    if (field.canCreateFilterForLine(filterString))
      return field.createFilterOrErrorMessage(filterString);
  }
  return null;
}

// src/Query.ts
var Query = class {
  constructor({ source }) {
    this._limit = void 0;
    this._layoutOptions = new LayoutOptions();
    this._filters = [];
    this._error = void 0;
    this._sorting = [];
    this._grouping = [];
    this.sortByRegexp = /^sort by (urgency|status|priority|start|scheduled|due|done|path|description|tag)( reverse)?[\s]*(\d+)?/;
    this.groupByRegexp = /^group by (backlink|done|due|filename|folder|happens|heading|path|priority|recurrence|recurring|root|scheduled|start|status|tags)/;
    this.hideOptionsRegexp = /^hide (task count|backlink|priority|start date|scheduled date|done date|due date|recurrence rule|edit button)/;
    this.shortModeRegexp = /^short/;
    this.limitRegexp = /^limit (to )?(\d+)( tasks?)?/;
    this.commentRegexp = /^#.*/;
    this.source = source;
    source.split("\n").map((line) => line.trim()).forEach((line) => {
      switch (true) {
        case line === "":
          break;
        case this.shortModeRegexp.test(line):
          this._layoutOptions.shortMode = true;
          break;
        case this.limitRegexp.test(line):
          this.parseLimit({ line });
          break;
        case this.sortByRegexp.test(line):
          this.parseSortBy({ line });
          break;
        case this.groupByRegexp.test(line):
          this.parseGroupBy({ line });
          break;
        case this.hideOptionsRegexp.test(line):
          this.parseHideOptions({ line });
          break;
        case this.commentRegexp.test(line):
          break;
        case this.parseFilter(line):
          break;
        default:
          this._error = `do not understand query: ${line}`;
      }
    });
  }
  get limit() {
    return this._limit;
  }
  get layoutOptions() {
    return this._layoutOptions;
  }
  get filters() {
    return this._filters;
  }
  get sorting() {
    return this._sorting;
  }
  get grouping() {
    return this._grouping;
  }
  get error() {
    return this._error;
  }
  applyQueryToTasks(tasks) {
    this.filters.forEach((filter) => {
      tasks = tasks.filter(filter);
    });
    const tasksSortedLimited = Sort.by(this, tasks).slice(0, this.limit);
    return Group.by(this.grouping, tasksSortedLimited);
  }
  parseHideOptions({ line }) {
    const hideOptionsMatch = line.match(this.hideOptionsRegexp);
    if (hideOptionsMatch !== null) {
      const option = hideOptionsMatch[1].trim().toLowerCase();
      switch (option) {
        case "task count":
          this._layoutOptions.hideTaskCount = true;
          break;
        case "backlink":
          this._layoutOptions.hideBacklinks = true;
          break;
        case "priority":
          this._layoutOptions.hidePriority = true;
          break;
        case "start date":
          this._layoutOptions.hideStartDate = true;
          break;
        case "scheduled date":
          this._layoutOptions.hideScheduledDate = true;
          break;
        case "due date":
          this._layoutOptions.hideDueDate = true;
          break;
        case "done date":
          this._layoutOptions.hideDoneDate = true;
          break;
        case "recurrence rule":
          this._layoutOptions.hideRecurrenceRule = true;
          break;
        case "edit button":
          this._layoutOptions.hideEditButton = true;
          break;
        default:
          this._error = "do not understand hide option";
      }
    }
  }
  parseFilter(line) {
    const filterOrError = parseFilter(line);
    if (filterOrError != null) {
      if (filterOrError.filter)
        this._filters.push(filterOrError.filter);
      else
        this._error = filterOrError.error;
      return true;
    }
    return false;
  }
  parseLimit({ line }) {
    const limitMatch = line.match(this.limitRegexp);
    if (limitMatch !== null) {
      this._limit = Number.parseInt(limitMatch[2], 10);
    } else {
      this._error = "do not understand query limit";
    }
  }
  parseSortBy({ line }) {
    const fieldMatch = line.match(this.sortByRegexp);
    if (fieldMatch !== null) {
      this._sorting.push({
        property: fieldMatch[1],
        reverse: !!fieldMatch[2],
        propertyInstance: isNaN(+fieldMatch[3]) ? 1 : +fieldMatch[3]
      });
    } else {
      this._error = "do not understand query sorting";
    }
  }
  parseGroupBy({ line }) {
    const fieldMatch = line.match(this.groupByRegexp);
    if (fieldMatch !== null) {
      this._grouping.push({
        property: fieldMatch[1]
      });
    } else {
      this._error = "do not understand query grouping";
    }
  }
};

// src/QueryRenderer.ts
var QueryRenderer = class {
  constructor({ plugin, events }) {
    this.addQueryRenderChild = this._addQueryRenderChild.bind(this);
    this.app = plugin.app;
    this.events = events;
    plugin.registerMarkdownCodeBlockProcessor(
      "tasks",
      this._addQueryRenderChild.bind(this)
    );
  }
  _addQueryRenderChild(source, element2, context) {
    return __async(this, null, function* () {
      context.addChild(
        new QueryRenderChild({
          app: this.app,
          events: this.events,
          container: element2,
          source,
          filePath: context.sourcePath
        })
      );
    });
  }
};
var QueryRenderChild = class extends import_obsidian8.MarkdownRenderChild {
  constructor({
    app,
    events,
    container,
    source,
    filePath
  }) {
    super(container);
    this.app = app;
    this.events = events;
    this.source = source;
    this.filePath = filePath;
    switch (this.containerEl.className) {
      case "block-language-tasks":
        this.query = new Query({ source });
        this.queryType = "tasks";
        break;
      default:
        this.query = new Query({ source });
        this.queryType = "tasks";
        break;
    }
  }
  onload() {
    this.events.triggerRequestCacheUpdate(this.render.bind(this));
    this.renderEventRef = this.events.onCacheUpdate(this.render.bind(this));
    this.reloadQueryAtMidnight();
  }
  onunload() {
    if (this.renderEventRef !== void 0) {
      this.events.off(this.renderEventRef);
    }
    if (this.queryReloadTimeout !== void 0) {
      clearTimeout(this.queryReloadTimeout);
    }
  }
  reloadQueryAtMidnight() {
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    const now = new Date();
    const millisecondsToMidnight = midnight.getTime() - now.getTime();
    this.queryReloadTimeout = setTimeout(() => {
      this.query = new Query({ source: this.source });
      this.events.triggerRequestCacheUpdate(this.render.bind(this));
      this.reloadQueryAtMidnight();
    }, millisecondsToMidnight + 1e3);
  }
  render(_0) {
    return __async(this, arguments, function* ({ tasks, state }) {
      var _a;
      const content = this.containerEl.createEl("div");
      if (state === "Warm" /* Warm */ && this.query.error === void 0) {
        console.debug(
          `Render ${this.queryType} called for a block in active file "${this.filePath}", to select from ${tasks.length} tasks: plugin state: ${state}`
        );
        const tasksSortedLimitedGrouped = this.query.applyQueryToTasks(tasks);
        for (const group of tasksSortedLimitedGrouped.groups) {
          QueryRenderChild.addGroupHeadings(content, group.groupHeadings);
          const { taskList } = yield this.createTasksList({
            tasks: group.tasks,
            content
          });
          content.appendChild(taskList);
        }
        const totalTasksCount = tasksSortedLimitedGrouped.totalTasksCount();
        console.debug(
          `${totalTasksCount} of ${tasks.length} tasks displayed in a block in "${this.filePath}"`
        );
        this.addTaskCount(content, totalTasksCount);
      } else if (this.query.error !== void 0) {
        content.setText(`Tasks query: ${this.query.error}`);
      } else {
        content.setText("Loading Tasks ...");
      }
      (_a = this.containerEl.firstChild) == null ? void 0 : _a.replaceWith(content);
    });
  }
  createTasksList(_0) {
    return __async(this, arguments, function* ({
      tasks,
      content
    }) {
      const tasksCount = tasks.length;
      const taskList = content.createEl("ul");
      taskList.addClasses([
        "contains-task-list",
        "plugin-tasks-query-result"
      ]);
      for (let i = 0; i < tasksCount; i++) {
        const task = tasks[i];
        const isFilenameUnique = this.isFilenameUnique({ task });
        const listItem = yield task.toLi({
          parentUlElement: taskList,
          listIndex: i,
          layoutOptions: this.query.layoutOptions,
          isFilenameUnique
        });
        const footnotes = listItem.querySelectorAll("[data-footnote-id]");
        footnotes.forEach((footnote) => footnote.remove());
        const postInfo = listItem.createSpan();
        const shortMode = this.query.layoutOptions.shortMode;
        if (!this.query.layoutOptions.hideBacklinks) {
          this.addBacklinks(postInfo, task, shortMode, isFilenameUnique);
        }
        if (!this.query.layoutOptions.hideEditButton) {
          this.addEditButton(postInfo, task);
        }
        taskList.appendChild(listItem);
      }
      return { taskList, tasksCount };
    });
  }
  addEditButton(postInfo, task) {
    const editTaskPencil = postInfo.createEl("a", {
      cls: "tasks-edit"
    });
    editTaskPencil.onClickEvent((event) => {
      event.preventDefault();
      const onSubmit = (updatedTasks) => {
        replaceTaskWithTasks({
          originalTask: task,
          newTasks: updatedTasks
        });
      };
      const taskModal = new TaskModal({
        app: this.app,
        task,
        onSubmit
      });
      taskModal.open();
    });
  }
  static addGroupHeadings(content, groupHeadings) {
    for (const heading of groupHeadings) {
      QueryRenderChild.addGroupHeading(content, heading);
    }
  }
  static addGroupHeading(content, group) {
    let header;
    if (group.nestingLevel === 0) {
      header = content.createEl("h4", {
        cls: "tasks-group-heading"
      });
    } else if (group.nestingLevel === 1) {
      header = content.createEl("h5", {
        cls: "tasks-group-heading"
      });
    } else {
      header = content.createEl("h6", {
        cls: "tasks-group-heading"
      });
    }
    header.appendText(group.name);
  }
  addBacklinks(postInfo, task, shortMode, isFilenameUnique) {
    var _a;
    postInfo.addClass("tasks-backlink");
    if (!shortMode) {
      postInfo.append(" (");
    }
    const link = postInfo.createEl("a");
    link.href = task.path;
    link.setAttribute("data-href", task.path);
    link.rel = "noopener";
    link.target = "_blank";
    link.addClass("internal-link");
    if (shortMode) {
      link.addClass("internal-link-short-mode");
    }
    if (task.precedingHeader !== null) {
      const sanitisedHeading = task.precedingHeader.replace(/#/g, "");
      link.href = link.href + "#" + sanitisedHeading;
      link.setAttribute(
        "data-href",
        link.getAttribute("data-href") + "#" + sanitisedHeading
      );
    }
    let linkText;
    if (shortMode) {
      linkText = " \u{1F517}";
    } else {
      linkText = (_a = task.getLinkText({ isFilenameUnique })) != null ? _a : "";
    }
    link.setText(linkText);
    if (!shortMode) {
      postInfo.append(")");
    }
  }
  addTaskCount(content, tasksCount) {
    if (!this.query.layoutOptions.hideTaskCount) {
      content.createDiv({
        text: `${tasksCount} task${tasksCount !== 1 ? "s" : ""}`,
        cls: "tasks-count"
      });
    }
  }
  isFilenameUnique({ task }) {
    const filenameMatch = task.path.match(/([^/]*)\..+$/i);
    if (filenameMatch === null) {
      return void 0;
    }
    const filename = filenameMatch[1];
    const allFilesWithSameName = this.app.vault.getMarkdownFiles().filter((file) => {
      if (file.basename === filename) {
        return true;
      }
    });
    return allFilesWithSameName.length < 2;
  }
};

// src/config/SettingsTab.ts
var import_obsidian9 = require("obsidian");
var SettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor({ plugin }) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Tasks Settings" });
    containerEl.createEl("p", {
      cls: "tasks-setting-important",
      text: "Changing any settings requires a restart of obsidian."
    });
    new import_obsidian9.Setting(containerEl).setName("Global task filter").setDesc(
      "The global filter will be applied to all checklist items."
    ).addText((text2) => {
      const settings2 = getSettings();
      text2.setPlaceholder("#task").setValue(settings2.globalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ globalFilter: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("div", {
      cls: "setting-item-description",
      text: 'The global filter will be applied to all checklist items to filter out "non-task" checklist items.\nA checklist item must include the specified string in its description in order to be considered a task.\nFor example, if you set the global filter to `#task`, the Tasks plugin will only handle checklist items tagged with `#task`.\nOther checklist items will remain normal checklist items and not appear in queries or get a done date set.\nLeave empty if you want all checklist items from your vault to be tasks managed by this plugin.'
    });
    new import_obsidian9.Setting(containerEl).setName("Remove global filter from description").setDesc(
      "Enabling this removes the string that you set as global filter from the task description when displaying a task."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.removeGlobalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ removeGlobalFilter: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Set done date on every completed task").setDesc(
      "Enabling this will add a timestamp \u2705 YYYY-MM-DD at the end when a task is toggled to done"
    ).addToggle((toogle) => {
      const settings2 = getSettings();
      toogle.setValue(settings2.setDoneDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setDoneDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Auto-suggest task content").setDesc(
      "Enabling this will open an intelligent suggest menu while typing inside a recognized task line."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.autoSuggestInEditor).onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestInEditor: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Minimum match length for auto-suggest").setDesc(
      "If higher than 0, auto-suggest will be triggered only when the beginning of any supported keywords is recognized."
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(0, 3, 1).setValue(settings2.autoSuggestMinMatch).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMinMatch: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Maximum number of auto-suggestions to show").setDesc(
      'How many suggestions should be shown when an auto-suggest menu pops up (including the "\u23CE" option).'
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(3, 12, 1).setValue(settings2.autoSuggestMaxItems).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMaxItems: value });
        yield this.plugin.saveSettings();
      }));
    });
  }
};

// src/Suggestor/EditorSuggestorPopup.ts
var import_obsidian10 = require("obsidian");

// src/Suggestor/Suggestor.ts
var datePrefixCharacters = `${startDateSymbol}${scheduledDateSymbol}${dueDateSymbol}`;
function buildSuggestions(line, cursorPos, settings2) {
  let suggestions = [];
  suggestions = suggestions.concat(
    addDatesSuggestions(line, cursorPos, settings2)
  );
  suggestions = suggestions.concat(
    addRecurrenceSuggestions(line, cursorPos, settings2)
  );
  const morePossibleSuggestions = getPossibleComponentSuggestions(
    line,
    settings2
  );
  const wordMatch = matchByPosition(line, /([a-zA-Z'_-]*)/g, cursorPos);
  let addedSuggestions = false;
  if (wordMatch && wordMatch.length > 0) {
    const wordUnderCursor = wordMatch[0];
    if (wordUnderCursor.length >= Math.max(1, settings2.autoSuggestMinMatch)) {
      const filteredSuggestions = morePossibleSuggestions.filter(
        (suggestInfo) => suggestInfo.displayText.toLowerCase().includes(wordUnderCursor.toLowerCase())
      );
      for (const filtered of filteredSuggestions) {
        suggestions.push({
          suggestionType: "match",
          displayText: filtered.displayText,
          appendText: filtered.appendText,
          insertAt: wordMatch.index,
          insertSkip: wordUnderCursor.length
        });
        addedSuggestions = true;
      }
    }
  }
  if (!addedSuggestions && settings2.autoSuggestMinMatch === 0)
    suggestions = suggestions.concat(morePossibleSuggestions);
  if (suggestions.length > 0 && !suggestions.some((value) => value.suggestionType === "match")) {
    suggestions.unshift({
      suggestionType: "empty",
      displayText: "\u23CE",
      appendText: "\n"
    });
  }
  suggestions = suggestions.slice(0, settings2.autoSuggestMaxItems);
  return suggestions;
}
function hasPriority(line) {
  if (Object.values(prioritySymbols).some(
    (value) => value.length > 0 && line.includes(value)
  ))
    return true;
}
function getPossibleComponentSuggestions(line, _settings) {
  const suggestions = [];
  if (!line.includes(dueDateSymbol))
    suggestions.push({
      displayText: `${dueDateSymbol} due date`,
      appendText: `${dueDateSymbol} `
    });
  if (!line.includes(startDateSymbol))
    suggestions.push({
      displayText: `${startDateSymbol} start date`,
      appendText: `${startDateSymbol} `
    });
  if (!line.includes(scheduledDateSymbol))
    suggestions.push({
      displayText: `${scheduledDateSymbol} scheduled date`,
      appendText: `${scheduledDateSymbol} `
    });
  if (!hasPriority(line)) {
    suggestions.push({
      displayText: `${prioritySymbols.High} high priority`,
      appendText: `${prioritySymbols.High} `
    });
    suggestions.push({
      displayText: `${prioritySymbols.Medium} medium priority`,
      appendText: `${prioritySymbols.Medium} `
    });
    suggestions.push({
      displayText: `${prioritySymbols.Low} low priority`,
      appendText: `${prioritySymbols.Low} `
    });
  }
  if (!line.includes(recurrenceSymbol))
    suggestions.push({
      displayText: `${recurrenceSymbol} recurring (repeat)`,
      appendText: `${recurrenceSymbol} `
    });
  return suggestions;
}
function addDatesSuggestions(line, cursorPos, settings2) {
  const genericSuggestions = [
    "today",
    "tomorrow",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "next week",
    "next month",
    "next year"
  ];
  const results = [];
  const dateRegex = new RegExp(
    `([${datePrefixCharacters}])\\s*([0-9a-zA-Z ]*)`,
    "ug"
  );
  const dateMatch = matchByPosition(line, dateRegex, cursorPos);
  if (dateMatch && dateMatch.length >= 2) {
    const datePrefix = dateMatch[1];
    const dateString = dateMatch[2];
    if (dateString.length < settings2.autoSuggestMinMatch) {
      return [];
    }
    const possibleDate = dateString && dateString.length > 1 ? DateParser.parseDate(doAutocomplete(dateString), true) : null;
    if (possibleDate && possibleDate.isValid()) {
      results.push({
        displayText: `${possibleDate.format(Task.dateFormat)}`,
        appendText: `${datePrefix} ${possibleDate.format(
          Task.dateFormat
        )} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
    const minMatch = 1;
    const maxGenericSuggestions = 5;
    let genericMatches = genericSuggestions.filter(
      (value) => dateString && dateString.length >= minMatch && value.toLowerCase().includes(dateString.toLowerCase())
    ).slice(0, maxGenericSuggestions);
    if (genericMatches.length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericSuggestions);
    }
    for (const match of genericMatches) {
      const parsedDate = DateParser.parseDate(match, true);
      const formattedDate = `${parsedDate.format(Task.dateFormat)}`;
      results.push({
        suggestionType: "match",
        displayText: `${match} (${formattedDate})`,
        appendText: `${datePrefix} ${formattedDate} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
  }
  return results;
}
function addRecurrenceSuggestions(line, cursorPos, settings2) {
  var _a;
  const genericSuggestions = [
    "every",
    "every day",
    "every week",
    "every month",
    "every month on the",
    "every year",
    "every week on Sunday",
    "every week on Monday",
    "every week on Tuesday",
    "every week on Wednesday",
    "every week on Thursday",
    "every week on Friday",
    "every week on Saturday"
  ];
  const results = [];
  const recurrenceRegex = new RegExp(
    `(${recurrenceSymbol})\\s*([0-9a-zA-Z ]*)`,
    "ug"
  );
  const recurrenceMatch = matchByPosition(line, recurrenceRegex, cursorPos);
  if (recurrenceMatch && recurrenceMatch.length >= 2) {
    const recurrencePrefix = recurrenceMatch[1];
    const recurrenceString = recurrenceMatch[2];
    if (recurrenceString.length < settings2.autoSuggestMinMatch)
      return [];
    if (recurrenceString.length > 0) {
      const parsedRecurrence = (_a = Recurrence.fromText({
        recurrenceRuleText: recurrenceString,
        startDate: null,
        scheduledDate: null,
        dueDate: null
      })) == null ? void 0 : _a.toText();
      if (parsedRecurrence) {
        const appendedText = `${recurrencePrefix} ${parsedRecurrence} `;
        results.push({
          suggestionType: "match",
          displayText: `\u2705 ${parsedRecurrence}`,
          appendText: appendedText,
          insertAt: recurrenceMatch.index,
          insertSkip: recurrenceMatch[0].length
        });
        if (recurrenceMatch[0] == appendedText)
          return [];
      }
    }
    const minMatch = 1;
    const maxGenericDateSuggestions = settings2.autoSuggestMaxItems / 2;
    let genericMatches = genericSuggestions.filter(
      (value) => recurrenceString && recurrenceString.length >= minMatch && value.toLowerCase().includes(recurrenceString.toLowerCase())
    ).slice(0, maxGenericDateSuggestions);
    if (genericMatches.length === 0 && recurrenceString.trim().length === 0) {
      genericMatches = genericSuggestions.slice(
        0,
        maxGenericDateSuggestions
      );
    }
    for (const match of genericMatches) {
      results.push({
        suggestionType: "match",
        displayText: `${match}`,
        appendText: `${recurrencePrefix} ${match} `,
        insertAt: recurrenceMatch.index,
        insertSkip: recurrenceMatch[0].length
      });
    }
  }
  return results;
}
function matchByPosition(s, r, position) {
  const matches = s.matchAll(r);
  for (const match of matches) {
    if ((match == null ? void 0 : match.index) && match.index <= position && position <= match.index + match[0].length)
      return match;
  }
  return [];
}

// src/Suggestor/EditorSuggestorPopup.ts
var EditorSuggestor = class extends import_obsidian10.EditorSuggest {
  constructor(app, settings2) {
    super(app);
    this.settings = settings2;
  }
  onTrigger(cursor, editor, _file) {
    if (!this.settings.autoSuggestInEditor)
      return null;
    const line = editor.getLine(cursor.line);
    if (line.contains(this.settings.globalFilter) && line.match(Task.taskRegex)) {
      return {
        start: { line: cursor.line, ch: 0 },
        end: {
          line: cursor.line,
          ch: line.length
        },
        query: line
      };
    }
    return null;
  }
  getSuggestions(context) {
    const line = context.query;
    const currentCursor = context.editor.getCursor();
    const suggestions = buildSuggestions(
      line,
      currentCursor.ch,
      this.settings
    );
    const suggestionsWithContext = [];
    for (const suggestion of suggestions)
      suggestionsWithContext.push(__spreadProps(__spreadValues({}, suggestion), { context }));
    return suggestionsWithContext;
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    var _a, _b, _c;
    const editor = value.context.editor;
    if (value.suggestionType === "empty") {
      this.close();
      const eventClone = new KeyboardEvent("keydown", {
        code: "Enter",
        key: "Enter"
      });
      (_b = (_a = editor == null ? void 0 : editor.cm) == null ? void 0 : _a.contentDOM) == null ? void 0 : _b.dispatchEvent(eventClone);
      return;
    }
    const currentCursor = value.context.editor.getCursor();
    const replaceFrom = {
      line: currentCursor.line,
      ch: (_c = value.insertAt) != null ? _c : currentCursor.ch
    };
    const replaceTo = value.insertSkip ? {
      line: currentCursor.line,
      ch: replaceFrom.ch + value.insertSkip
    } : void 0;
    value.context.editor.replaceRange(
      value.appendText,
      replaceFrom,
      replaceTo
    );
    value.context.editor.setCursor({
      line: currentCursor.line,
      ch: replaceFrom.ch + value.appendText.length
    });
  }
};

// src/main.ts
var TasksPlugin = class extends import_obsidian11.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log('loading plugin "tasks"');
      yield this.loadSettings();
      this.addSettingTab(new SettingsTab({ plugin: this }));
      initializeFile({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault
      });
      const events = new Events({ obsidianEvents: this.app.workspace });
      this.cache = new Cache2({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        events
      });
      this.inlineRenderer = new InlineRenderer({ plugin: this });
      this.queryRenderer = new QueryRenderer({ plugin: this, events });
      this.registerEditorExtension(newLivePreviewExtension());
      this.registerEditorSuggest(
        new EditorSuggestor(this.app, getSettings())
      );
      new Commands({ plugin: this });
    });
  }
  onunload() {
    var _a;
    console.log('unloading plugin "tasks"');
    (_a = this.cache) == null ? void 0 : _a.unload();
  }
  loadSettings() {
    return __async(this, null, function* () {
      const newSettings = yield this.loadData();
      updateSettings(newSettings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(getSettings());
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdXRpbHMvcGF0dGVybi50cyIsICJub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24veWVhcnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3F1YXJ0ZXJPZlllYXIuanMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy91dGlscy9kYXlqcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3RpbWV6b25lLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvcmVzdWx0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0UGFyc2VyV2l0aFdvcmRCb3VuZGFyeS50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lTWlkZGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOTW9udGhOYW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOQ2FzdWFsWWVhck1vbnRoRGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOU2xhc2hNb250aEZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0Fic3RyYWN0VGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3V0aWxzL3RpbWV1bml0cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRMYXRlckZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9hYnN0cmFjdFJlZmluZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0Fic3RyYWN0TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NhbGN1bGF0aW9uL21lcmdpbmdDYWxjdWxhdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9BYnN0cmFjdE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZUFiYnJSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvT3ZlcmxhcFJlbW92YWxSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0ZvcndhcmREYXRlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9Vbmxpa2VseUZvcm1hdEZpbHRlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9wYXJzZXJzL0lTT0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9NZXJnZVdlZWtkYXlDb21wb25lbnRSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29uZmlndXJhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vY2FzdWFsUmVmZXJlbmNlcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTkNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5DYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24vd2Vla3MudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5XZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2hyb25vLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvU2xhc2hEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcmVmaW5lcnMvRU5NZXJnZVJlbGF0aXZlRGF0ZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVTcGVjaWZpY1RpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9yZWZpbmVycy9ERU1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcmVmaW5lcnMvREVNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERUNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFVGltZVVuaXRSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9yZWZpbmVycy9GUk1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9yZWZpbmVycy9GUk1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlNwZWNpZmljVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lVW5pdEFnb0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZVVuaXRSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvcGFyc2Vycy9KUFN0YW5kYXJkUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9yZWZpbmVycy9KUE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvcGFyc2Vycy9KUENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3JlZmluZXJzL1BUTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3JlZmluZXJzL1BUTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVENhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9yZWZpbmVycy9OTE1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcmVmaW5lcnMvTkxNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdFdpdGhpbkZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxNb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxNb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxTbGFzaE1vbnRoRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxZZWFyTW9udGhEYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxDYXN1YWxEYXRlVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0Q2FzdWFsUmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxSZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lVW5pdEFnb0Zvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0TGF0ZXJGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50Q2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnREYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50RGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRSZWxhdGlvbldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcmVmaW5lcnMvWkhIYW50TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3JlZmluZXJzL1pISGFudE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zRGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNSZWxhdGlvbldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1dlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcmVmaW5lcnMvWkhIYW5zTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3JlZmluZXJzL1pISGFuc01lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVNb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9yZWZpbmVycy9SVU1lcmdlRGF0ZVJhbmdlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcmVmaW5lcnMvUlVNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVUNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVVbml0Q2FzdWFsUmVsYXRpdmVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9jb25zdC5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvbGV4L2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9sZXgvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2xleC9sZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3BhcnNlL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvZXZhbHVhdGUvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2V2YWx1YXRlL2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9ldmFsdWF0ZS9ldmFsdWF0ZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvaW5kZXguanMiLCAic3JjL21haW4udHMiLCAic3JjL0NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy1tdXRleC9pbmRleC5tanMiLCAic3JjL1Rhc2sudHMiLCAic3JjL0ZpbGUudHMiLCAic3JjL2NvbmZpZy9TZXR0aW5ncy50cyIsICJzcmMvTGF5b3V0T3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3dlZWtkYXkudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9oZWxwZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvZGF0ZXV0aWwudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVycmVzdWx0LnRzIiwgIm5vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvY2FsbGJhY2tpdGVycmVzdWx0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL2kxOG4udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ubHAvdG90ZXh0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3BhcnNldGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvZGF0ZXRpbWUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9wYXJzZW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9wYXJzZXN0cmluZy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV3aXRoem9uZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL29wdGlvbnN0b3N0cmluZy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbWFza3MudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby95ZWFyaW5mby50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL21vbnRoaW5mby50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL2Vhc3Rlci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlci9wb3NsaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcnNldC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc3RyLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcnJ1bGVzZXQudHMiLCAic3JjL1NvcnQudHMiLCAic3JjL1JlY3VycmVuY2UudHMiLCAic3JjL1VyZ2VuY3kudHMiLCAic3JjL0NvbW1hbmRzL0NyZWF0ZU9yRWRpdC50cyIsICJzcmMvVGFza01vZGFsLnRzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUvaW50ZXJuYWwvaW5kZXgubWpzIiwgInNyYy91aS9FZGl0VGFzay5zdmVsdGUiLCAic3JjL0RhdGVBYmJyZXZpYXRpb25zLnRzIiwgInNyYy9Db21tYW5kcy9Ub2dnbGVEb25lLnRzIiwgInNyYy9Db21tYW5kcy9pbmRleC50cyIsICJzcmMvRXZlbnRzLnRzIiwgInNyYy9JbmxpbmVSZW5kZXJlci50cyIsICJzcmMvTGl2ZVByZXZpZXdFeHRlbnNpb24udHMiLCAic3JjL1F1ZXJ5UmVuZGVyZXIudHMiLCAic3JjL1F1ZXJ5L0dyb3VwSGVhZGluZy50cyIsICJzcmMvUXVlcnkvR3JvdXBIZWFkaW5ncy50cyIsICJzcmMvUXVlcnkvR3JvdXBpbmdUcmVlTm9kZS50cyIsICJzcmMvUXVlcnkvSW50ZXJtZWRpYXRlVGFza0dyb3Vwcy50cyIsICJzcmMvUXVlcnkvVGFza0dyb3VwLnRzIiwgInNyYy9RdWVyeS9UYXNrR3JvdXBzLnRzIiwgInNyYy9RdWVyeS9EYXRlUGFyc2VyLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXIudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9IYXBwZW5zRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9Hcm91cC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1RleHRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0Rlc2NyaXB0aW9uRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9EYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Eb25lRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRHVlRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVySW5zdHJ1Y3Rpb24udHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJJbnN0cnVjdGlvbnMudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRXhjbHVkZVN1Ykl0ZW1zRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9IZWFkaW5nRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9QYXRoRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9Qcmlvcml0eUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvU2NoZWR1bGVkRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvU3RhcnREYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9SZWN1cnJpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvVGFnc0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQm9vbGVhbkZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXJQYXJzZXIudHMiLCAic3JjL1F1ZXJ5LnRzIiwgInNyYy9jb25maWcvU2V0dGluZ3NUYWIudHMiLCAic3JjL1N1Z2dlc3Rvci9FZGl0b3JTdWdnZXN0b3JQb3B1cC50cyIsICJzcmMvU3VnZ2VzdG9yL1N1Z2dlc3Rvci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19zcHJlYWRBcnJheTtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEluO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG4gICAgfSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbiA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19jcmVhdGVCaW5kaW5nXCIsIF9fY3JlYXRlQmluZGluZyk7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEluXCIsIF9fY2xhc3NQcml2YXRlRmllbGRJbik7XHJcbn0pO1xyXG4iLCBudWxsLCAiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSxEPVwiZW5cIix2PXt9O3ZbRF09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24odCxlLG4pe3ZhciByO2lmKCF0KXJldHVybiBEO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXZbdF0mJihyPXQpLGUmJih2W3RdPWUscj10KTtlbHNle3ZhciBpPXQubmFtZTt2W2ldPXQscj1pfXJldHVybiFuJiZyJiYoRD1yKSxyfHwhbiYmRH0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIEQ9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLHY9KHk8RD95Kzc6eSktRDtyZXR1cm4gJChyP20tdjptKyg2LXYpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zdWJzdHIoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sRD1PLm0odGhpcyxNKTtyZXR1cm4gRD0obD17fSxsW2NdPUQvMTIsbFtmXT1ELGxbaF09RC8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD9EOk8uYShEKX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdlt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxiPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1iLFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtiW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj12W0RdLHcuTHM9dix3LnA9e30sd30pKTsiLCBudWxsLCBudWxsLCAiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUobik6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fcXVhcnRlck9mWWVhcj1uKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9XCJtb250aFwiLG49XCJxdWFydGVyXCI7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHI9aS5wcm90b3R5cGU7ci5xdWFydGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiR1dGlscygpLnUodCk/TWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkrMSkvMyk6dGhpcy5tb250aCh0aGlzLm1vbnRoKCklMyszKih0LTEpKX07dmFyIHM9ci5hZGQ7ci5hZGQ9ZnVuY3Rpb24oZSxpKXtyZXR1cm4gZT1OdW1iZXIoZSksdGhpcy4kdXRpbHMoKS5wKGkpPT09bj90aGlzLmFkZCgzKmUsdCk6cy5iaW5kKHRoaXMpKGUsaSl9O3ZhciB1PXIuc3RhcnRPZjtyLnN0YXJ0T2Y9ZnVuY3Rpb24oZSxpKXt2YXIgcj10aGlzLiR1dGlscygpLHM9ISFyLnUoaSl8fGk7aWYoci5wKGUpPT09bil7dmFyIG89dGhpcy5xdWFydGVyKCktMTtyZXR1cm4gcz90aGlzLm1vbnRoKDMqbykuc3RhcnRPZih0KS5zdGFydE9mKFwiZGF5XCIpOnRoaXMubW9udGgoMypvKzIpLmVuZE9mKHQpLmVuZE9mKFwiZGF5XCIpfXJldHVybiB1LmJpbmQodGhpcykoZSxpKX19fSkpOyIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgT3BlcmF0b3JzO1xuKGZ1bmN0aW9uIChPcGVyYXRvcnMpIHtcbiAgICBPcGVyYXRvcnNbXCJBTkRcIl0gPSBcIkFORFwiO1xuICAgIE9wZXJhdG9yc1tcIk9SXCJdID0gXCJPUlwiO1xuICAgIE9wZXJhdG9yc1tcIlhPUlwiXSA9IFwiWE9SXCI7XG4gICAgT3BlcmF0b3JzW1wiTk9UXCJdID0gXCJOT1RcIjtcbn0pKE9wZXJhdG9ycyA9IGV4cG9ydHMuT3BlcmF0b3JzIHx8IChleHBvcnRzLk9wZXJhdG9ycyA9IHt9KSk7XG52YXIgU3RydWN0dXJhbENoYXJhY3RlcnM7XG4oZnVuY3Rpb24gKFN0cnVjdHVyYWxDaGFyYWN0ZXJzKSB7XG4gICAgU3RydWN0dXJhbENoYXJhY3RlcnNbXCJPUEVOX1BBUkVOVEhFU0lTXCJdID0gXCIoXCI7XG4gICAgU3RydWN0dXJhbENoYXJhY3RlcnNbXCJDTE9TRV9QQVJFTlRIRVNJU1wiXSA9IFwiKVwiO1xufSkoU3RydWN0dXJhbENoYXJhY3RlcnMgPSBleHBvcnRzLlN0cnVjdHVyYWxDaGFyYWN0ZXJzIHx8IChleHBvcnRzLlN0cnVjdHVyYWxDaGFyYWN0ZXJzID0ge30pKTtcbnZhciBUb2tlbnM7XG4oZnVuY3Rpb24gKFRva2Vucykge1xuICAgIFRva2Vuc1tcIklERU5USUZJRVJcIl0gPSBcIklERU5USUZJRVJcIjtcbiAgICBUb2tlbnNbXCJPUEVSQVRPUlwiXSA9IFwiT1BFUkFUT1JcIjtcbiAgICBUb2tlbnNbXCJTVFJVQ1RVUkFMX0NIQVJBQ1RFUlwiXSA9IFwiU1RSVUNUVVJBTF9DSEFSQUNURVJcIjtcbiAgICBUb2tlbnNbXCJFT0ZcIl0gPSBcIkVPRlwiO1xuICAgIFRva2Vuc1tcIkNPTU1FTlRcIl0gPSBcIkNPTU1FTlRcIjtcbn0pKFRva2VucyA9IGV4cG9ydHMuVG9rZW5zIHx8IChleHBvcnRzLlRva2VucyA9IHt9KSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5leHBvcnRzLk9QRVJBVE9SX1BSRUNFREVOQ0UgPSB7XG4gICAgTk9UOiAwLFxuICAgIFhPUjogMSxcbiAgICBBTkQ6IDIsXG4gICAgT1I6IDNcbn07XG5leHBvcnRzLlZBTElEX1RPS0VOUyA9IHtcbiAgICBpZGVudGlmaWVyT25seTogW1xuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5PUEVOX1BBUkVOVEhFU0lTXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBpZGVudGlmaWVyT3JOb3Q6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSLFxuICAgICAgICAgICAgdmFsdWU6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuTk9UIH0sXG4gICAgXSxcbiAgICBiaW5hcnlPcGVyYXRvcjogW1xuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuQU5EIH0sXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5PUiB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuWE9SIH0sXG4gICAgXSxcbiAgICBiaW5hcnlPcGVyYXRvck9yQ2xvc2U6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuT1IgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUiB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUixcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLkNMT1NFX1BBUkVOVEhFU0lTXG4gICAgICAgIH0sXG4gICAgXVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmV4cG9ydHMuU1RSVUNUVVJBTF9DSEFSQUNURVJTID0ge1xuICAgICcoJzogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5PUEVOX1BBUkVOVEhFU0lTLFxuICAgICcpJzogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJU1xufTtcbmV4cG9ydHMuT1BFUkFUT1JTID0ge1xuICAgIEFORDogdHlwZXNfMS5PcGVyYXRvcnMuQU5ELFxuICAgIE9SOiB0eXBlc18xLk9wZXJhdG9ycy5PUixcbiAgICBYT1I6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUixcbiAgICBOT1Q6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVFxufTtcbmV4cG9ydHMuU0VQQVJBVE9SUyA9IG5ldyBTZXQoW1xuICAgIDB4MDAyMCxcbiAgICAweDAwMDksXG4gICAgMHgwMDBhLFxuICAgIDB4MDAwZCxcbl0ubWFwKGZ1bmN0aW9uIChzZXBhcmF0b3IpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHNlcGFyYXRvcik7IH0pKTtcbmV4cG9ydHMuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDIyKTtcbmV4cG9ydHMuQ09NTUVOVF9ERUxJTUlURVIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDAwMjMpO1xuZXhwb3J0cy5FT0wgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDAwMGEpO1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgwMDVjKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuZXhwb3J0cy5jcmVhdGVSZXN1bHQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHJlbWFpbmluZ1N0cmluZykgeyByZXR1cm4gKHtcbiAgICB0b2tlbjogX19hc3NpZ24oeyBuYW1lOiBuYW1lIH0sICh2YWx1ZSAhPT0gbnVsbCA/IHsgdmFsdWU6IHZhbHVlIH0gOiB7fSkpLFxuICAgIHJlbWFpbmluZ1N0cmluZzogcmVtYWluaW5nU3RyaW5nXG59KTsgfTtcbmV4cG9ydHMuZ2V0Q29tbWVudCA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHRva2VuRW5kID0gZXhwcmVzc2lvbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZXR0ZXIgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICBpZiAobGV0dGVyID09PSBjb25zdF8xLkVPTCkge1xuICAgICAgICAgICAgdG9rZW5FbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuY3JlYXRlUmVzdWx0KHR5cGVzXzEuVG9rZW5zLkNPTU1FTlQsIGV4cHJlc3Npb24uc2xpY2UoMCwgdG9rZW5FbmQpLCBleHByZXNzaW9uLnNsaWNlKHRva2VuRW5kICsgMSkpO1xufTtcbmV4cG9ydHMuZ2V0UXVvdGVkSWRlbnRpZmllciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIGVzY2FwZVF1b3RhdGlvbiA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgIHZhciB0b2tlbkVuZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgaWYgKHRva2VuRW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlUXVvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoLTEpICsgY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuRVNDQVBFX0NIQVJBQ1RFUikge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVRdW90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlUXVvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSAmJiAhY29uc3RfMS5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlNbY2hhcl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIgKyBjaGFyICsgXCIgRXhwZWN0ZWQgKSBjaGFyYWN0ZXIgb3Igc2VwYXJhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2VuRW5kID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246IGV4cGVjdGVkIFwiICsgY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIgKyBcIiBjaGFyYWN0ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZVJlc3VsdCh0eXBlc18xLlRva2Vucy5JREVOVElGSUVSLCB2YWx1ZSwgZXhwcmVzc2lvbi5zbGljZSh0b2tlbkVuZCArIDEpKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMubGV4ID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgdG9rZW5TdGFydCA9IG51bGw7XG4gICAgdmFyIHRva2VuRW5kID0gbnVsbDtcbiAgICB2YXIgZGVsaW1pdGluZ0NoYXJhY3RlciA9IG51bGw7XG4gICAgLy8gTG9vcHMgdGhyb3VnaCBjaGFyYWN0ZXJzIGluIHRoZSBleHByZXNzaW9uIHVudGlsIHRoZSBuZXh0IHRva2VuIGlzIGZvdW5kXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgLy8gRmluZHMgdG9rZW0gc3RhcnQgYW5kIHJldHVybnMgaW1tZWRpYXRlbHkgcmV0dXJucyBhbnkgaWRlbnRpZmlhYmxlIHRva2Vuc1xuICAgICAgICBpZiAodG9rZW5TdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cnVjdHVyYWxDaGFyID0gY29uc3RfMS5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlNbY2hhcl07XG4gICAgICAgICAgICAgICAgaWYgKHN0cnVjdHVyYWxDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGV4cHJlc3Npb25baSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RydWN0dXJhbENoYXIgPT09IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuQ0xPU0VfUEFSRU5USEVTSVMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhuZXh0Q2hhcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyICE9PSB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLkNMT1NFX1BBUkVOVEhFU0lTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIgKyBuZXh0Q2hhciArIFwiLiBBIGNsb3NpbmcgcGFyZW50aGVzaXMgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGFub3RoZXIgY2xvc2luZyBwYXJlbnRoZXNpcyBvciB3aGl0ZXNwYWNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmNyZWF0ZVJlc3VsdCh0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUiwgY29uc3RfMS5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlNbY2hhcl0sIGV4cHJlc3Npb24uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT25jZSBhIHF1b3RlZCBpZGVudGlmaWVyIGhhcyBiZWVuIGlkZW50aWZpZWQgaXQgaXMgcmV0cmlldmVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0UXVvdGVkSWRlbnRpZmllcihleHByZXNzaW9uLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9uY2UgYSBjb21tZW50IGhhcyBiZWVuIGlkZW50aWZpZWQgaXQgaXMgcmV0cmlldmVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5DT01NRU5UX0RFTElNSVRFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRDb21tZW50KGV4cHJlc3Npb24uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5TdGFydCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCcmVha3Mgb24gdGhlIGVuZCBvZiB0aGUgdG9rZW4gYW5kIHRocm93cyBvbiBpbnZhbGlkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmIChjb25zdF8xLlNFUEFSQVRPUlMuaGFzKGNoYXIpIHx8IGNvbnN0XzEuU1RSVUNUVVJBTF9DSEFSQUNURVJTW2NoYXJdKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5FbmQgPSBpO1xuICAgICAgICAgICAgICAgIGRlbGltaXRpbmdDaGFyYWN0ZXIgPSBjaGFyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09IGNvbnN0XzEuQ09NTUVOVF9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiICsgY2hhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNlcGFyYXRlcyBvcGVyYXRvcnMgZnJvbSBpZGVudGlmaWVycyBhbmQgcmV0dXJucyB0aGUgY29ycmVjdCB0b2tlblxuICAgIGlmICh0b2tlblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRva2VuRW5kID0gKHRva2VuRW5kICE9PSBudWxsICYmIHRva2VuRW5kICE9PSB2b2lkIDAgPyB0b2tlbkVuZCA6IGV4cHJlc3Npb24ubGVuZ3RoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwcmVzc2lvbi5zbGljZSh0b2tlblN0YXJ0LCB0b2tlbkVuZCk7XG4gICAgICAgIHZhciByZW1haW5pbmdTdHJpbmcgPSBleHByZXNzaW9uLnNsaWNlKHRva2VuRW5kKTtcbiAgICAgICAgaWYgKGNvbnN0XzEuT1BFUkFUT1JTW3ZhbHVlXSkge1xuICAgICAgICAgICAgaWYgKGRlbGltaXRpbmdDaGFyYWN0ZXIgJiYgIWNvbnN0XzEuU0VQQVJBVE9SUy5oYXMoZGVsaW1pdGluZ0NoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIgKyBkZWxpbWl0aW5nQ2hhcmFjdGVyICsgXCIuIE9wZXJhdG9ycyBzaG91bGQgYmUgc2VwYXJhdGVkIHVzaW5nIHdoaXRlc3BhY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5jcmVhdGVSZXN1bHQodHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIGNvbnN0XzEuT1BFUkFUT1JTW3ZhbHVlXSwgcmVtYWluaW5nU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmNyZWF0ZVJlc3VsdCh0eXBlc18xLlRva2Vucy5JREVOVElGSUVSLCB2YWx1ZSwgcmVtYWluaW5nU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGlzIGlzIHJlYWNoZWQgbm8gdG9rZW5zIHdlcmUgZm91bmQgc28gRU9GIGlzIHJldHVybmVkXG4gICAgcmV0dXJuIHV0aWxzXzEuY3JlYXRlUmVzdWx0KHR5cGVzXzEuVG9rZW5zLkVPRiwgbnVsbCwgJycpO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsZXhfMSA9IHJlcXVpcmUoXCIuLi9sZXgvbGV4XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuZXhwb3J0cy5uZXdUb2tlbkdlbmVyYXRvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHJlbWFpbmluZ0V4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsaWRUb2tlbnMsIGVuZElzVmFsaWQpIHtcbiAgICAgICAgaWYgKGVuZElzVmFsaWQgPT09IHZvaWQgMCkgeyBlbmRJc1ZhbGlkID0gZmFsc2U7IH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGxleF8xLmxleChyZW1haW5pbmdFeHByZXNzaW9uKSwgdG9rZW4gPSBfYS50b2tlbiwgcmVtYWluaW5nU3RyaW5nID0gX2EucmVtYWluaW5nU3RyaW5nO1xuICAgICAgICAgICAgcmVtYWluaW5nRXhwcmVzc2lvbiA9IHJlbWFpbmluZ1N0cmluZztcbiAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lICE9PSB0eXBlc18xLlRva2Vucy5DT01NRU5UKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy52YWxpZGF0ZVRva2VuKHRva2VuLCB2YWxpZFRva2VucywgZW5kSXNWYWxpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLmdldFZhbHVlID0gZnVuY3Rpb24gKGdldE5leHRUb2tlbiwgcGFyc2VyKSB7XG4gICAgdmFyIG5leHRUb2tlbiA9IGdldE5leHRUb2tlbihjb25zdF8xLlZBTElEX1RPS0VOUy5pZGVudGlmaWVyT3JOb3QpO1xuICAgIHZhciBuZWdhdGVkVmFsdWUgPSBuZXh0VG9rZW4udmFsdWUgPT09IHR5cGVzXzEuT3BlcmF0b3JzLk5PVDtcbiAgICBpZiAobmVnYXRlZFZhbHVlKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IGdldE5leHRUb2tlbihjb25zdF8xLlZBTElEX1RPS0VOUy5pZGVudGlmaWVyT25seSk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5leHRUb2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlxuICAgICAgICA/IHBhcnNlcihnZXROZXh0VG9rZW4sIHRydWUpXG4gICAgICAgIDogW25leHRUb2tlbl07XG4gICAgcmV0dXJuIG5lZ2F0ZWRWYWx1ZVxuICAgICAgICA/IF9fc3ByZWFkQXJyYXlzKHZhbHVlLCBbeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCB9XSkgOiB2YWx1ZTtcbn07XG5leHBvcnRzLnByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudCA9IGZ1bmN0aW9uIChwcmV2aW91c09wZXJhdG9yLCBuZXh0T3BlcmF0b3IpIHtcbiAgICByZXR1cm4gY29uc3RfMS5PUEVSQVRPUl9QUkVDRURFTkNFW3ByZXZpb3VzT3BlcmF0b3JdIDw9IGNvbnN0XzEuT1BFUkFUT1JfUFJFQ0VERU5DRVtuZXh0T3BlcmF0b3JdO1xufTtcbmV4cG9ydHMudmFsaWRhdGVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsaWRUb2tlbnMsIGVuZElzVmFsaWQpIHtcbiAgICBpZiAoZW5kSXNWYWxpZCA9PT0gdm9pZCAwKSB7IGVuZElzVmFsaWQgPSBmYWxzZTsgfVxuICAgIGlmICh0b2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5FT0YpIHtcbiAgICAgICAgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCB2YWxpZFRva2Vuc18xID0gdmFsaWRUb2tlbnM7IF9pIDwgdmFsaWRUb2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHZhbGlkVG9rZW4gPSB2YWxpZFRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHZhbGlkVG9rZW4ubmFtZSA9PT0gdG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgaWYgKCF2YWxpZFRva2VuLnZhbHVlIHx8IHZhbGlkVG9rZW4udmFsdWUgPT09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gUmV0dXJucyB0aGUgdG9rZW5zIHVzaW5nIHBvc3RmaXggbm90YXRpb25cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCBcIiArIHR5cGVvZiBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgLy8gZ2V0TmV4dFRva2VuIGtlZXBzIHRyYWNrIG9mIHRoZSByZW1haW5pbmcgZXhwcmVzc2lvblxuICAgIC8vIGFuZCByZXR1cm4gdGhlIG5leHQgdG9rZW4gZWFjaCB0aW1lIGl0IGlzIGNhbGxlZFxuICAgIHZhciBnZXROZXh0VG9rZW4gPSB1dGlsc18xLm5ld1Rva2VuR2VuZXJhdG9yKGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBwYXJzZUludGVybmFsKGdldE5leHRUb2tlbik7XG59O1xuLy8gcGFyc2VJbnRlcm5hbCB3aWxsIHJlY3Vyc2Ugb3ZlciBicmFja2V0ZWQgZXhwcmVzc2lvbnNcbnZhciBwYXJzZUludGVybmFsID0gZnVuY3Rpb24gKGdldE5leHRUb2tlbiwgbmVzdGVkKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7IG5lc3RlZCA9IGZhbHNlOyB9XG4gICAgLy8gVGhpcyBpbml0aWFsaXNlcyB0aGUgb3V0cHV0IHdpdGggZXZlcnl0aGluZyB1cCB0aGUgZmlyc3QgdW5uZXN0ZWQgb3BlcmF0b3JcbiAgICB2YXIgb3V0cHV0ID0gX19zcHJlYWRBcnJheXModXRpbHNfMS5nZXRWYWx1ZShnZXROZXh0VG9rZW4sIHBhcnNlSW50ZXJuYWwpKTtcbiAgICB2YXIgb3BlcmF0b3JzID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHZhbGlkVG9rZW5zID0gbmVzdGVkXG4gICAgICAgICAgICA/IGNvbnN0XzEuVkFMSURfVE9LRU5TLmJpbmFyeU9wZXJhdG9yT3JDbG9zZVxuICAgICAgICAgICAgOiBjb25zdF8xLlZBTElEX1RPS0VOUy5iaW5hcnlPcGVyYXRvcjtcbiAgICAgICAgLy8gUmV0cmlldmVzIHRoZSBuZXh0IFRva2VuXG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSBnZXROZXh0VG9rZW4odmFsaWRUb2tlbnMsICFuZXN0ZWQpO1xuICAgICAgICBpZiAobmV4dFRva2VuLm5hbWUgPT09IHR5cGVzXzEuVG9rZW5zLkVPRiB8fCAvLyBJZiB0aGUgZW5kIG9mIGZpbGUgaXMgZm91bmQgaGVyZSB0aGVuIHJldHVybiB3aGF0IHdlIGhhdmVcbiAgICAgICAgICAgIG5leHRUb2tlbi5uYW1lID09PSB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUiAvLyBUaGUgZXhwcmVzc2lvbiB3aWxsIGJlIHJldHVybmVkIGFuZCBpbmNvcnBvcmF0ZWQgaW50byB0aGUgZmluYWwgZXhwcmVzc2lvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyhvdXRwdXQsIF9fc3ByZWFkQXJyYXlzKG9wZXJhdG9ycykucmV2ZXJzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBwb3N0Zml4IG5vdGF0aW9uIG9wZXJhdG9yIG9yZGVyIGlzIGRldGVybWluZWQgYnkgcHJlY2VkZW5jZVxuICAgICAgICB3aGlsZSAob3BlcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0b3JzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRvciAmJlxuICAgICAgICAgICAgICAgIHV0aWxzXzEucHJldmlvdXNPcGVyYXRvclRha2VzUHJlY2VkZW50KHByZXZpb3VzT3BlcmF0b3IudmFsdWUsIG5leHRUb2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBfX3NwcmVhZEFycmF5cyhvdXRwdXQsIFtwcmV2aW91c09wZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzID0gb3BlcmF0b3JzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBuZXcgb3BlcmF0b3IgaXMgbm93IGFkZGVkIHRvIHRoZSBzdGFja1xuICAgICAgICBvcGVyYXRvcnMgPSBfX3NwcmVhZEFycmF5cyhvcGVyYXRvcnMsIFtuZXh0VG9rZW5dKTtcbiAgICAgICAgLy8gT25jZSB0aGlzIGlzIGRvbmUgd2UgY2FuIGdldCBldmVyeXRoaW5nIHVudGlsIHRoZSBuZXh0IHVubmVzdGVkXG4gICAgICAgIC8vIG9wZXJhdG9yIGFuZCBhZGQgaXQgdG8gdGhlIG91dHB1dFxuICAgICAgICBvdXRwdXQgPSBfX3NwcmVhZEFycmF5cyhvdXRwdXQsIHV0aWxzXzEuZ2V0VmFsdWUoZ2V0TmV4dFRva2VuLCBwYXJzZUludGVybmFsKSk7XG4gICAgfVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmV4cG9ydHMuYW5kVXRpbCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkgeyByZXR1cm4gbGVmdCAmJiByaWdodDsgfTtcbmV4cG9ydHMub3JVdGlsID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0IHx8IHJpZ2h0OyB9O1xuZXhwb3J0cy54b3JVdGlsID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiAhKGxlZnQgPT09IHJpZ2h0KTsgfTtcbmV4cG9ydHMubm90VXRpbCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7IHJldHVybiAhaWRlbnRpZmllcjsgfTtcbmV4cG9ydHMuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBuYW1lID09PSB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59O1xuZXhwb3J0cy5pc09wZXJhdG9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBuYW1lID09PSB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcbmV4cG9ydHMudGhyb3dJbnZhbGlkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcG9zdGZpeCBleHByZXNzaW9uOiBcIiArIG1lc3NhZ2UpO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLk9QRVJBVE9SX01BUCA9IChfYSA9IHt9LFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLkFORF0gPSB1dGlsc18xLmFuZFV0aWwsXG4gICAgX2FbdHlwZXNfMS5PcGVyYXRvcnMuT1JdID0gdXRpbHNfMS5vclV0aWwsXG4gICAgX2FbdHlwZXNfMS5PcGVyYXRvcnMuWE9SXSA9IHV0aWxzXzEueG9yVXRpbCxcbiAgICBfYSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcGFyc2VfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZS9wYXJzZVwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmdldEV2YWx1YXRvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHBhcnNlZEV4cHJlc3Npb24gPSBwYXJzZV8xLnBhcnNlKGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoYm9vbGVhbk1hcCkgeyByZXR1cm4gZXhwb3J0cy5ldmFsdWF0ZShwYXJzZWRFeHByZXNzaW9uLCBib29sZWFuTWFwKTsgfTtcbn07XG5leHBvcnRzLmV2YWx1YXRlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGJvb2xlYW5NYXApIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cHJlc3Npb24gKyBcIiBzaG91bGQgYmUgYW4gYXJyYXkuIGV2YWx1YXRlIHRha2VzIGluIGEgcGFyc2VkIGV4cHJlc3Npb24uIFVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHBhcnNlIG9yIHVzZSBnZXRFdmFsdWF0b3JcIik7XG4gICAgfVxuICAgIC8vIFJlc29sdmVzIGVhY2ggaWRlbnRpZmllciBhbmQgYWRkcyBpdCB0byBhIHN0YWNrXG4gICAgLy8gV2hlbiBvcGVyYXRvciBpcyBmb3VuZCBpdCBvcGVyYXRlcyBvbiB0aGUgdG9wIHZhbHVlKHMpXG4gICAgLy8gb24gdGhlIHN0YWNrLCByZW1vdmVzIHRoZW0gYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCB0aGVcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgZXZhbHVhdGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVkdWNlKGZ1bmN0aW9uIChzdGFjaywgdG9rZW4sIGkpIHtcbiAgICAgICAgaWYgKCEodG9rZW4gJiYgKHV0aWxzXzEuaXNJZGVudGlmaWVyKHRva2VuKSB8fCB1dGlsc18xLmlzT3BlcmF0b3IodG9rZW4pKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG9rZW46IFwiICsgdG9rZW4gKyBcIi4gRm91bmQgaW4gcGFyc2VkIGV4cHJlc3Npb24gYXQgaW5kZXggXCIgKyBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUikge1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKHN0YWNrLCBbQm9vbGVhbihib29sZWFuTWFwW3Rva2VuLnZhbHVlXSldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vjb25kTGFzdEl0ZW0gPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGxhc3RJdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gdHlwZXNfMS5PcGVyYXRvcnMuTk9UKSB7XG4gICAgICAgICAgICBpZiAobGFzdEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbignbWlzc2luZyBpZGVudGlmaWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXMoc3RhY2suc2xpY2UoMCwgLTEpLCBbdXRpbHNfMS5ub3RVdGlsKGxhc3RJdGVtKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SXRlbSA9PT0gdW5kZWZpbmVkIHx8IHNlY29uZExhc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbignbWlzc2luZyBpZGVudGlmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdG9yVXRpbCA9IGNvbnN0XzEuT1BFUkFUT1JfTUFQW3Rva2VuLnZhbHVlXTtcbiAgICAgICAgaWYgKCFvcGVyYXRvclV0aWwpIHtcbiAgICAgICAgICAgIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbigndW5rbm93biBvcGVyYXRvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyhzdGFjay5zbGljZSgwLCAtMiksIFtvcGVyYXRvclV0aWwoc2Vjb25kTGFzdEl0ZW0sIGxhc3RJdGVtKV0pO1xuICAgIH0sIFtdKTtcbiAgICBpZiAoZXZhbHVhdGVkRXhwcmVzc2lvbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdXRpbHNfMS50aHJvd0ludmFsaWRFeHByZXNzaW9uKCd0b28gbWFueSBpZGVudGlmaWVycyBhZnRlciBldmFsdWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0ZWRFeHByZXNzaW9uWzBdO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgZXZhbHVhdGVfMSA9IHJlcXVpcmUoXCIuL2V2YWx1YXRlL2V2YWx1YXRlXCIpO1xuZXhwb3J0cy5nZXRFdmFsdWF0b3IgPSBldmFsdWF0ZV8xLmdldEV2YWx1YXRvcjtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZV8xLmV2YWx1YXRlO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi9wYXJzZS9wYXJzZVwiKTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZV8xLnBhcnNlO1xuIiwgImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlJztcbmltcG9ydCB7IENvbW1hbmRzIH0gZnJvbSAnLi9Db21tYW5kcyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQgeyBpbml0aWFsaXplRmlsZSB9IGZyb20gJy4vRmlsZSc7XG5pbXBvcnQgeyBJbmxpbmVSZW5kZXJlciB9IGZyb20gJy4vSW5saW5lUmVuZGVyZXInO1xuaW1wb3J0IHsgbmV3TGl2ZVByZXZpZXdFeHRlbnNpb24gfSBmcm9tICcuL0xpdmVQcmV2aWV3RXh0ZW5zaW9uJztcbmltcG9ydCB7IFF1ZXJ5UmVuZGVyZXIgfSBmcm9tICcuL1F1ZXJ5UmVuZGVyZXInO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIHVwZGF0ZVNldHRpbmdzIH0gZnJvbSAnLi9jb25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgU2V0dGluZ3NUYWIgfSBmcm9tICcuL2NvbmZpZy9TZXR0aW5nc1RhYic7XG5pbXBvcnQgeyBFZGl0b3JTdWdnZXN0b3IgfSBmcm9tICcuL1N1Z2dlc3Rvci9FZGl0b3JTdWdnZXN0b3JQb3B1cCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBwcml2YXRlIGNhY2hlOiBDYWNoZSB8IHVuZGVmaW5lZDtcbiAgICBwdWJsaWMgaW5saW5lUmVuZGVyZXI6IElubGluZVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBxdWVyeVJlbmRlcmVyOiBRdWVyeVJlbmRlcmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbG9hZGluZyBwbHVnaW4gXCJ0YXNrc1wiJyk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nc1RhYih7IHBsdWdpbjogdGhpcyB9KSk7XG5cbiAgICAgICAgaW5pdGlhbGl6ZUZpbGUoe1xuICAgICAgICAgICAgbWV0YWRhdGFDYWNoZTogdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgIHZhdWx0OiB0aGlzLmFwcC52YXVsdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IEV2ZW50cyh7IG9ic2lkaWFuRXZlbnRzOiB0aGlzLmFwcC53b3Jrc3BhY2UgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoe1xuICAgICAgICAgICAgbWV0YWRhdGFDYWNoZTogdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgIHZhdWx0OiB0aGlzLmFwcC52YXVsdCxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5saW5lUmVuZGVyZXIgPSBuZXcgSW5saW5lUmVuZGVyZXIoeyBwbHVnaW46IHRoaXMgfSk7XG4gICAgICAgIHRoaXMucXVlcnlSZW5kZXJlciA9IG5ldyBRdWVyeVJlbmRlcmVyKHsgcGx1Z2luOiB0aGlzLCBldmVudHMgfSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihuZXdMaXZlUHJldmlld0V4dGVuc2lvbigpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvclN1Z2dlc3QoXG4gICAgICAgICAgICBuZXcgRWRpdG9yU3VnZ2VzdG9yKHRoaXMuYXBwLCBnZXRTZXR0aW5ncygpKSxcbiAgICAgICAgKTtcbiAgICAgICAgbmV3IENvbW1hbmRzKHsgcGx1Z2luOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygndW5sb2FkaW5nIHBsdWdpbiBcInRhc2tzXCInKTtcbiAgICAgICAgdGhpcy5jYWNoZT8udW5sb2FkKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IHRoaXMubG9hZERhdGEoKTtcbiAgICAgICAgdXBkYXRlU2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YShnZXRTZXR0aW5ncygpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgTWV0YWRhdGFDYWNoZSwgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBDYWNoZWRNZXRhZGF0YSwgRXZlbnRSZWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IExpc3RJdGVtQ2FjaGUsIFNlY3Rpb25DYWNoZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IE11dGV4IH0gZnJvbSAnYXN5bmMtbXV0ZXgnO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgRXZlbnRzIH0gZnJvbSAnLi9FdmVudHMnO1xuXG5leHBvcnQgZW51bSBTdGF0ZSB7XG4gICAgQ29sZCA9ICdDb2xkJyxcbiAgICBJbml0aWFsaXppbmcgPSAnSW5pdGlhbGl6aW5nJyxcbiAgICBXYXJtID0gJ1dhcm0nLFxufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXM6IEV2ZW50UmVmW107XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdDogVmF1bHQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdEV2ZW50UmVmZXJlbmNlczogRXZlbnRSZWZbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogRXZlbnRzO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzRXZlbnRSZWZlcmVuY2VzOiBFdmVudFJlZltdO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSB0YXNrc011dGV4OiBNdXRleDtcbiAgICBwcml2YXRlIHN0YXRlOiBTdGF0ZTtcbiAgICBwcml2YXRlIHRhc2tzOiBUYXNrW107XG5cbiAgICAvKipcbiAgICAgKiBXZSBjYW5ub3Qga25vdyBpZiB0aGlzIGNsYXNzIHdpbGwgYmUgaW5zdGFudGlhdGVkIGJlY2F1c2Ugb2JzaWRpYW4gc3RhcnRlZFxuICAgICAqIG9yIGJlY2F1c2UgdGhlIHBsdWdpbiB3YXMgYWN0aXZhdGVkIGxhdGVyLiBUaGlzIG1lYW5zIHdlIGhhdmUgdG8gbG9hZCB0aGVcbiAgICAgKiB3aG9sZSB2YXVsdCBvbmNlIGFmdGVyIHRoZSBmaXJzdCBtZXRhZGF0YSBjYWNoZSByZXNvbHZlIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICogbG9hZCB0aGUgZW50aXJlIHZhdWx0IGluIGNhc2Ugb2JzaWRpYW4gaXMgc3RhcnRpbmcgdXAuIEluIHRoZSBjYXNlIG9mXG4gICAgICogb2JzaWRpYW4gc3RhcnRpbmcsIHRoZSB0YXNrIGNhY2hlJ3MgaW5pdGlhbCBsb2FkIHdvdWxkIGVuZCB1cCB3aXRoIDAgdGFza3MsXG4gICAgICogYXMgdGhlIG1ldGFkYXRhIGNhY2hlIHdvdWxkIHN0aWxsIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmU6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIG1ldGFkYXRhQ2FjaGUsXG4gICAgICAgIHZhdWx0LFxuICAgICAgICBldmVudHMsXG4gICAgfToge1xuICAgICAgICBtZXRhZGF0YUNhY2hlOiBNZXRhZGF0YUNhY2hlO1xuICAgICAgICB2YXVsdDogVmF1bHQ7XG4gICAgICAgIGV2ZW50czogRXZlbnRzO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlID0gbWV0YWRhdGFDYWNoZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlRXZlbnRSZWZlcmVuY2VzID0gW107XG4gICAgICAgIHRoaXMudmF1bHQgPSB2YXVsdDtcbiAgICAgICAgdGhpcy52YXVsdEV2ZW50UmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgdGhpcy5ldmVudHNFdmVudFJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnRhc2tzTXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkNvbGQ7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcblxuICAgICAgICB0aGlzLmxvYWRlZEFmdGVyRmlyc3RSZXNvbHZlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NhY2hlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9WYXVsdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKCk7XG5cbiAgICAgICAgdGhpcy5sb2FkVmF1bHQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdW5sb2FkKCk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50UmVmZXJlbmNlIG9mIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlLm9mZnJlZihldmVudFJlZmVyZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50UmVmZXJlbmNlIG9mIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmF1bHQub2ZmcmVmKGV2ZW50UmVmZXJlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRSZWZlcmVuY2Ugb2YgdGhpcy5ldmVudHNFdmVudFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9mZihldmVudFJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VGFza3MoKTogVGFza1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza3M7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFN0YXRlKCk6IFN0YXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBub3RpZnlTdWJzY3JpYmVycygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckNhY2hlVXBkYXRlKHtcbiAgICAgICAgICAgIHRhc2tzOiB0aGlzLnRhc2tzLFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9DYWNoZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRFdmVudGVSZWZlcmVuY2UgPSB0aGlzLm1ldGFkYXRhQ2FjaGUub24oXG4gICAgICAgICAgICAncmVzb2x2ZWQnLFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlc29sdmVkIGZpcmVzIG9uIGV2ZXJ5IGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gaW5pdGlhbGl6ZSBpZiB3ZSBoYXZlbid0IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZEFmdGVyRmlyc3RSZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRWYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcy5wdXNoKHJlc29sdmVkRXZlbnRlUmVmZXJlbmNlKTtcblxuICAgICAgICAvLyBEb2VzIG5vdCBmaXJlIHdoZW4gc3RhcnRpbmcgdXAgb2JzaWRpYW4gYW5kIG9ubHkgd29ya3MgZm9yIGNoYW5nZXMuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRFdmVudFJlZmVyZW5jZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5vbihcbiAgICAgICAgICAgICdjaGFuZ2VkJyxcbiAgICAgICAgICAgIChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4RmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcy5wdXNoKGNoYW5nZWRFdmVudFJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb1ZhdWx0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjcmVhdGVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKFxuICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4RmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMucHVzaChjcmVhdGVkRXZlbnRSZWZlcmVuY2UpO1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRFdmVudFJlZmVyZW5jZSA9IHRoaXMudmF1bHQub24oXG4gICAgICAgICAgICAnZGVsZXRlJyxcbiAgICAgICAgICAgIChmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50YXNrc011dGV4LnJ1bkV4Y2x1c2l2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFza3MgPSB0aGlzLnRhc2tzLmZpbHRlcigodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCAhPT0gZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2goZGVsZXRlZEV2ZW50UmVmZXJlbmNlKTtcblxuICAgICAgICBjb25zdCByZW5hbWVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKFxuICAgICAgICAgICAgJ3JlbmFtZScsXG4gICAgICAgICAgICAoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50YXNrc011dGV4LnJ1bkV4Y2x1c2l2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFza3MgPSB0aGlzLnRhc2tzLm1hcCgodGFzazogVGFzayk6IFRhc2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sucGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayh7IC4uLnRhc2ssIHBhdGg6IGZpbGUucGF0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMucHVzaChyZW5hbWVkRXZlbnRSZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9FdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RSZWZlcmVuY2UgPSB0aGlzLmV2ZW50cy5vblJlcXVlc3RDYWNoZVVwZGF0ZSgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaGFuZGxlcih7IHRhc2tzOiB0aGlzLnRhc2tzLCBzdGF0ZTogdGhpcy5zdGF0ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzLnB1c2gocmVxdWVzdFJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkVmF1bHQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5Jbml0aWFsaXppbmc7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICB0aGlzLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5tYXAoKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4RmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV2FybTtcbiAgICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IHRoZSBjYWNoZSBpcyBub3cgd2FybTpcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBpbmRleEZpbGUoZmlsZTogVEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgZmlsZUNhY2hlID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgaWYgKGZpbGVDYWNoZSA9PT0gbnVsbCB8fCBmaWxlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpc3RJdGVtcyA9IGZpbGVDYWNoZS5saXN0SXRlbXM7XG4gICAgICAgIGlmIChsaXN0SXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBsaXN0IGl0ZW1zIGNhY2hlLCB0aGVyZSBhcmUgbm8gdGFza3MuXG4gICAgICAgICAgICAvLyBTdGlsbCBjb250aW51ZSB0byBub3RpZnkgd2F0Y2hlcnMgb2YgcmVtb3ZhbC5cbiAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkVGFza3MgPSB0aGlzLnRhc2tzLmZpbHRlcigodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCA9PT0gZmlsZS5wYXRoO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcbiAgICAgICAgY29uc3QgbmV3VGFza3MgPSBDYWNoZS5nZXRUYXNrc0Zyb21GaWxlQ29udGVudChcbiAgICAgICAgICAgIGZpbGVDb250ZW50LFxuICAgICAgICAgICAgbGlzdEl0ZW1zLFxuICAgICAgICAgICAgZmlsZUNhY2hlLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBpbiBhbnkgb2YgdGhlIHRhc2tzLCB0aGVyZSdzXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIHNvIGp1c3QgcmV0dXJuLlxuICAgICAgICBpZiAoVGFzay50YXNrc0xpc3RzSWRlbnRpY2FsKG9sZFRhc2tzLCBuZXdUYXNrcykpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSBrZXB0IGZvciBub3csIHRvIGFsbG93IGZvciBkZWJ1Z2dpbmcgZHVyaW5nIGRldmVsb3BtZW50LlxuICAgICAgICAgICAgLy8gSXQgaXMgdG9vIHZlcmJvc2UgdG8gcmVsZWFzZSB0byB1c2Vycy5cbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmdldFN0YXRlKCkgPT0gU3RhdGUuV2FybSkge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuZGVidWcoYFRhc2tzIHVuY2hhbmdlZCBpbiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldFN0YXRlKCkgPT0gU3RhdGUuV2FybSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgQXQgbGVhc3Qgb25lIHRhc2ssIGl0cyBsaW5lIG51bWJlciBvciBpdHMgaGVhZGluZyBoYXMgY2hhbmdlZCBpbiAke2ZpbGUucGF0aH06IHRyaWdnZXJpbmcgYSByZWZyZXNoIG9mIGFsbCBhY3RpdmUgVGFza3MgYmxvY2tzIGluIExpdmUgUHJldmlldyBhbmQgUmVhZGluZyBtb2RlIHZpZXdzLmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0YXNrcyBmcm9tIHRoaXMgZmlsZSBmcm9tIHRoZSBjYWNoZSBiZWZvcmVcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBvbmVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGUgZmlsZS5cbiAgICAgICAgdGhpcy50YXNrcyA9IHRoaXMudGFza3MuZmlsdGVyKCh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wYXRoICE9PSBmaWxlLnBhdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudGFza3MucHVzaCguLi5uZXdUYXNrcyk7XG5cbiAgICAgICAgLy8gQWxsIHVwZGF0ZWQsIGluZm9ybSBvdXIgc3Vic2NyaWJlcnMuXG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUYXNrc0Zyb21GaWxlQ29udGVudChcbiAgICAgICAgZmlsZUNvbnRlbnQ6IHN0cmluZyxcbiAgICAgICAgbGlzdEl0ZW1zOiBMaXN0SXRlbUNhY2hlW10sXG4gICAgICAgIGZpbGVDYWNoZTogQ2FjaGVkTWV0YWRhdGEsXG4gICAgICAgIGZpbGU6IFRGaWxlLFxuICAgICk6IFRhc2tbXSB7XG4gICAgICAgIGNvbnN0IHRhc2tzOiBUYXNrW10gPSBbXTtcbiAgICAgICAgY29uc3QgZmlsZUxpbmVzID0gZmlsZUNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc3RvcmUgc2VjdGlvbiBpbmZvcm1hdGlvbiB3aXRoIGV2ZXJ5IHRhc2sgc29cbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gdXNlIHRoYXQgd2hlbiB3ZSBwb3N0IHByb2Nlc3MgdGhlIG1hcmtkb3duXG4gICAgICAgIC8vIHJlbmRlcmVkIGxpc3RzLlxuICAgICAgICBsZXQgY3VycmVudFNlY3Rpb246IFNlY3Rpb25DYWNoZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbS50YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lIDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VudCBwYXN0IHRoZSBjdXJyZW50IHNlY3Rpb24gKG9yIHRoaXMgaXMgdGhlIGZpcnN0IHRhc2spLlxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIHRoYXQgaXMgcmVsZXZhbnQgZm9yIHRoaXMgdGFzayBhbmQgdGhlIGZvbGxvd2luZyBvZiB0aGUgc2FtZSBzZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IENhY2hlLmdldFNlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlclRhc2s6IGxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uczogZmlsZUNhY2hlLnNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHByb2Nlc3MgYSB0YXNrIHdpdGhvdXQgYSBzZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gZmlsZUxpbmVzW2xpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBUYXNrLmZyb21MaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uU3RhcnQ6IGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBDYWNoZS5nZXRQcmVjZWRpbmdIZWFkZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlclRhc2s6IGxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uczogZmlsZUNhY2hlLnNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUxpbmVzLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXNrcztcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTZWN0aW9uKHtcbiAgICAgICAgbGluZU51bWJlclRhc2ssXG4gICAgICAgIHNlY3Rpb25zLFxuICAgIH06IHtcbiAgICAgICAgbGluZU51bWJlclRhc2s6IG51bWJlcjtcbiAgICAgICAgc2VjdGlvbnM6IFNlY3Rpb25DYWNoZVtdIHwgdW5kZWZpbmVkO1xuICAgIH0pOiBTZWN0aW9uQ2FjaGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHNlY3Rpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5wb3NpdGlvbi5zdGFydC5saW5lIDw9IGxpbmVOdW1iZXJUYXNrICYmXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5wb3NpdGlvbi5lbmQubGluZSA+PSBsaW5lTnVtYmVyVGFza1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRQcmVjZWRpbmdIZWFkZXIoe1xuICAgICAgICBsaW5lTnVtYmVyVGFzayxcbiAgICAgICAgc2VjdGlvbnMsXG4gICAgICAgIGZpbGVMaW5lcyxcbiAgICB9OiB7XG4gICAgICAgIGxpbmVOdW1iZXJUYXNrOiBudW1iZXI7XG4gICAgICAgIHNlY3Rpb25zOiBTZWN0aW9uQ2FjaGVbXSB8IHVuZGVmaW5lZDtcbiAgICAgICAgZmlsZUxpbmVzOiBzdHJpbmdbXTtcbiAgICB9KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmVjZWRpbmdIZWFkZXJTZWN0aW9uOiBTZWN0aW9uQ2FjaGUgfCB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24udHlwZSA9PT0gJ2hlYWRpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZSA+IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJyZWFrIG91dCBvZiB0aGUgbG9vcCBhcyB0aGUgbGFzdCBoZWFkZXIgd2FzIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyU2VjdGlvbiA9IHNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWNlZGluZ0hlYWRlclNlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5lTnVtYmVyUHJlY2VkaW5nSGVhZGVyID1cbiAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlclNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZTtcblxuICAgICAgICBjb25zdCBsaW5lUHJlY2VkaW5nSGVhZGVyID0gZmlsZUxpbmVzW2xpbmVOdW1iZXJQcmVjZWRpbmdIZWFkZXJdO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4ID0gL14jKyArKC4qKS91O1xuICAgICAgICBjb25zdCBoZWFkZXJNYXRjaCA9IGxpbmVQcmVjZWRpbmdIZWFkZXIubWF0Y2goaGVhZGVyUmVnZXgpO1xuICAgICAgICBpZiAoaGVhZGVyTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlck1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImNvbnN0IEVfVElNRU9VVCA9IG5ldyBFcnJvcigndGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBtdXRleCB0byBiZWNvbWUgYXZhaWxhYmxlJyk7XG5jb25zdCBFX0FMUkVBRFlfTE9DS0VEID0gbmV3IEVycm9yKCdtdXRleCBhbHJlYWR5IGxvY2tlZCcpO1xuY29uc3QgRV9DQU5DRUxFRCA9IG5ldyBFcnJvcigncmVxdWVzdCBmb3IgbG9jayBjYW5jZWxlZCcpO1xuXG52YXIgX19hd2FpdGVyJDIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoX21heENvbmN1cnJlbmN5LCBfY2FuY2VsRXJyb3IgPSBFX0NBTkNFTEVEKSB7XG4gICAgICAgIHRoaXMuX21heENvbmN1cnJlbmN5ID0gX21heENvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLl9jYW5jZWxFcnJvciA9IF9jYW5jZWxFcnJvcjtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fd2FpdGVycyA9IFtdO1xuICAgICAgICBpZiAoX21heENvbmN1cnJlbmN5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VtYXBob3JlIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gYSBwb3NpdGl2ZSB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX21heENvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICBjb25zdCBsb2NrZWQgPSB0aGlzLmlzTG9ja2VkKCk7XG4gICAgICAgIGNvbnN0IHRpY2tldFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB0aGlzLl9xdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pKTtcbiAgICAgICAgaWYgKCFsb2NrZWQpXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgICAgICByZXR1cm4gdGlja2V0UHJvbWlzZTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgcmVsZWFzZV0gPSB5aWVsZCB0aGlzLmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FpdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gdGhpcy5fd2FpdGVycy5wdXNoKHsgcmVzb2x2ZSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlIDw9IDA7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIDAuMy4wLCB3aWxsIGJlIHJlbW92ZWQgaW4gMC40LjAuIFVzZSBydW5FeGNsdXNpdmUgaW5zdGVhZC4gKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5fbWF4Q29uY3VycmVuY3kgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgbWV0aG9kIGlzIHVuYXZhaWxhYmxlIG9uIHNlbWFwaG9yZXMgd2l0aCBjb25jdXJyZW5jeSA+IDE7IHVzZSB0aGUgc2NvcGVkIHJlbGVhc2UgcmV0dXJuZWQgYnkgYWNxdWlyZSBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRSZWxlYXNlcikge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZXIgPSB0aGlzLl9jdXJyZW50UmVsZWFzZXI7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UmVsZWFzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaCgodGlja2V0KSA9PiB0aWNrZXQucmVqZWN0KHRoaXMuX2NhbmNlbEVycm9yKSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgfVxuICAgIF9kaXNwYXRjaCgpIHtcbiAgICAgICAgY29uc3QgbmV4dFRpY2tldCA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICghbmV4dFRpY2tldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHJlbGVhc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWxlYXNlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSsrO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVdhaXRlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIG5leHRUaWNrZXQucmVzb2x2ZShbdGhpcy5fdmFsdWUtLSwgdGhpcy5fY3VycmVudFJlbGVhc2VyXSk7XG4gICAgfVxuICAgIF9yZXNvbHZlV2FpdGVycygpIHtcbiAgICAgICAgdGhpcy5fd2FpdGVycy5mb3JFYWNoKCh3YWl0ZXIpID0+IHdhaXRlci5yZXNvbHZlKCkpO1xuICAgICAgICB0aGlzLl93YWl0ZXJzID0gW107XG4gICAgfVxufVxuXG52YXIgX19hd2FpdGVyJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIE11dGV4IHtcbiAgICBjb25zdHJ1Y3RvcihjYW5jZWxFcnJvcikge1xuICAgICAgICB0aGlzLl9zZW1hcGhvcmUgPSBuZXcgU2VtYXBob3JlKDEsIGNhbmNlbEVycm9yKTtcbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgWywgcmVsZWFzZXJdID0geWllbGQgdGhpcy5fc2VtYXBob3JlLmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLnJ1bkV4Y2x1c2l2ZSgoKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS53YWl0Rm9yVW5sb2NrKCk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIDAuMy4wLCB3aWxsIGJlIHJlbW92ZWQgaW4gMC40LjAuIFVzZSBydW5FeGNsdXNpdmUgaW5zdGVhZC4gKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuY2FuY2VsKCk7XG4gICAgfVxufVxuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gd2l0aFRpbWVvdXQoc3luYywgdGltZW91dCwgdGltZW91dEVycm9yID0gRV9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNxdWlyZTogKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCBzeW5jLmFjcXVpcmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBBcnJheS5pc0FycmF5KHRpY2tldCkgPyB0aWNrZXRbMV0gOiB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRpY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpLFxuICAgICAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgdGhpcy5hY3F1aXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRpY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodGlja2V0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiAwLjMuMCwgd2lsbCBiZSByZW1vdmVkIGluIDAuNC4wLiBVc2UgcnVuRXhjbHVzaXZlIGluc3RlYWQuICovXG4gICAgICAgIHJlbGVhc2UoKSB7XG4gICAgICAgICAgICBzeW5jLnJlbGVhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN5bmMuY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3JVbmxvY2s6ICgpID0+IHN5bmMud2FpdEZvclVubG9jaygpLFxuICAgICAgICBpc0xvY2tlZDogKCkgPT4gc3luYy5pc0xvY2tlZCgpLFxuICAgIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGlzbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gdHJ5QWNxdWlyZShzeW5jLCBhbHJlYWR5QWNxdWlyZWRFcnJvciA9IEVfQUxSRUFEWV9MT0NLRUQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiB3aXRoVGltZW91dChzeW5jLCAwLCBhbHJlYWR5QWNxdWlyZWRFcnJvcik7XG59XG5cbmV4cG9ydCB7IEVfQUxSRUFEWV9MT0NLRUQsIEVfQ0FOQ0VMRUQsIEVfVElNRU9VVCwgTXV0ZXgsIFNlbWFwaG9yZSwgdHJ5QWNxdWlyZSwgd2l0aFRpbWVvdXQgfTtcbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIE1hcmtkb3duUmVuZGVyZXIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyByZXBsYWNlVGFza1dpdGhUYXNrcyB9IGZyb20gJy4vRmlsZSc7XG5pbXBvcnQgeyBMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi9MYXlvdXRPcHRpb25zJztcbmltcG9ydCB7IFJlY3VycmVuY2UgfSBmcm9tICcuL1JlY3VycmVuY2UnO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuL2NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBVcmdlbmN5IH0gZnJvbSAnLi9VcmdlbmN5JztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL1NvcnQnO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2Ygc3RhdHVzIHR5cGVzIHN1cHBvcnRlZCBieSB0aGUgcGx1Z2luLlxuICogVE9ETzogTWFrZSB0aGlzIGEgY2xhc3Mgc28gaXQgY2FuIHN1cHBvcnQgb3RoZXIgdHlwZXMgYW5kIGVhc2llciBtYXBwaW5nIHRvIHN0YXR1cyBjaGFyYWN0ZXIuXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZW51bSBTdGF0dXMge1xuICAgIFRvZG8gPSAnVG9kbycsXG4gICAgRG9uZSA9ICdEb25lJyxcbn1cblxuLyoqXG4gKiBXaGVuIHNvcnRpbmcsIG1ha2Ugc3VyZSBsb3cgYWx3YXlzIGNvbWVzIGFmdGVyIG5vbmUuIFRoaXMgd2F5IGFueSB0YXNrcyB3aXRoIGxvdyB3aWxsIGJlIGJlbG93IGFueSBleGl0aW5nXG4gKiB0YXNrcyB0aGF0IGhhdmUgbm8gcHJpb3JpdHkgd2hpY2ggd291bGQgYmUgdGhlIGRlZmF1bHQuXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGVudW0gUHJpb3JpdHkge1xuICAgIEhpZ2ggPSAnMScsXG4gICAgTWVkaXVtID0gJzInLFxuICAgIE5vbmUgPSAnMycsXG4gICAgTG93ID0gJzQnLFxufVxuXG5leHBvcnQgY29uc3QgcHJpb3JpdHlTeW1ib2xzID0ge1xuICAgIEhpZ2g6ICdcdTIzRUInLFxuICAgIE1lZGl1bTogJ1x1RDgzRFx1REQzQycsXG4gICAgTG93OiAnXHVEODNEXHVERDNEJyxcbiAgICBOb25lOiAnJyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWN1cnJlbmNlU3ltYm9sID0gJ1x1RDgzRFx1REQwMSc7XG5leHBvcnQgY29uc3Qgc3RhcnREYXRlU3ltYm9sID0gJ1x1RDgzRFx1REVFQic7XG5leHBvcnQgY29uc3Qgc2NoZWR1bGVkRGF0ZVN5bWJvbCA9ICdcdTIzRjMnO1xuZXhwb3J0IGNvbnN0IGR1ZURhdGVTeW1ib2wgPSAnXHVEODNEXHVEQ0M1JztcbmV4cG9ydCBjb25zdCBkb25lRGF0ZVN5bWJvbCA9ICdcdTI3MDUnO1xuXG4vKipcbiAqIFRhc2sgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBNYXJrRG93biB0YXNrIGFsb25nIHdpdGhcbiAqIHRoZSBleHRlbnNpb25zIHByb3ZpZGVkIGJ5IHRoaXMgcGx1Z2luLiBUaGlzIGlzIHVzZWQgdG8gcGFyc2UgYW5kXG4gKiBnZW5lcmF0ZSB0aGUgbWFya2Rvd24gdGFzayBmb3IgYWxsIHVwZGF0ZXMgYW5kIHJlcGxhY2VtZW50cy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVGFza1xuICovXG5leHBvcnQgY2xhc3MgVGFzayB7XG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXR1czogU3RhdHVzO1xuICAgIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBwYXRoOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGluZGVudGF0aW9uOiBzdHJpbmc7XG4gICAgLyoqIExpbmUgbnVtYmVyIHdoZXJlIHRoZSBzZWN0aW9uIHN0YXJ0cyB0aGF0IGNvbnRhaW5zIHRoaXMgdGFzay4gKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VjdGlvblN0YXJ0OiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgbnRoIHRhc2sgaW4gaXRzIHNlY3Rpb24uICovXG4gICAgcHVibGljIHJlYWRvbmx5IHNlY3Rpb25JbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBjaGFyYWN0ZXIgZnJvbSB3aXRoaW4gYFtdYCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICogUmVxdWlyZWQgdG8gYmUgYWRkZWQgdG8gdGhlIExJIHRoZSBzYW1lIHdheSBvYnNpZGlhbiBkb2VzIGFzIGEgYGRhdGEtdGFza2AgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBvcmlnaW5hbFN0YXR1c0NoYXJhY3Rlcjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBwcmVjZWRpbmdIZWFkZXI6IHN0cmluZyB8IG51bGw7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgdGFnczogc3RyaW5nW107XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJpb3JpdHk6IFByaW9yaXR5O1xuXG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9uZURhdGU6IE1vbWVudCB8IG51bGw7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGw7XG4gICAgLyoqIFRoZSBibG9ja0xpbmsgaXMgYSBcIl5cIiBhbm5vdGF0aW9uIGFmdGVyIHRoZSBkYXRlcy9yZWN1cnJlbmNlIHJ1bGVzLiAqL1xuICAgIHB1YmxpYyByZWFkb25seSBibG9ja0xpbms6IHN0cmluZztcblxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREJztcblxuICAgIC8vIE1haW4gcmVnZXggZm9yIHBhcnNpbmcgYSBsaW5lLiBJdCBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gLSBJbmRlbnRhdGlvbiAoaW5jbHVkaW5nID4gZm9yIHBvdGVudGlhbGx5IG5lc3RlZCBibG9ja3F1b3RlcyBvciBPYnNpZGlhbiBjYWxsb3V0cylcbiAgICAvLyAtIFN0YXR1cyBjaGFyYWN0ZXJcbiAgICAvLyAtIFJlc3Qgb2YgdGFzayBhZnRlciBjaGVja2JveCBtYXJrZG93blxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdGFza1JlZ2V4ID0gL14oW1xcc1xcdD5dKilbLSpdICtcXFsoLilcXF0gKiguKikvdTtcblxuICAgIC8vIE1hdGNoIG9uIGJsb2NrIGxpbmsgYXQgZW5kLlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmxvY2tMaW5rUmVnZXggPSAvIFxcXlthLXpBLVowLTktXSskL3U7XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHJlZ2V4J3MgZW5kIHdpdGggYCRgIGJlY2F1c2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgYW5kXG4gICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBlbmQgdW50aWwgbm9uZSBhcmUgbGVmdC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHByaW9yaXR5UmVnZXggPSAvKFtcdTIzRUJcdUQ4M0RcdUREM0NcdUQ4M0RcdUREM0RdKSQvdTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN0YXJ0RGF0ZVJlZ2V4ID0gL1x1RDgzRFx1REVFQiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHNjaGVkdWxlZERhdGVSZWdleCA9IC9bXHUyM0YzXHUyMzFCXSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGR1ZURhdGVSZWdleCA9IC9bXHVEODNEXHVEQ0M1XHVEODNEXHVEQ0M2XHVEODNEXHVEREQzXSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRvbmVEYXRlUmVnZXggPSAvXHUyNzA1ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pJC91O1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgcmVjdXJyZW5jZVJlZ2V4ID0gL1x1RDgzRFx1REQwMSA/KFthLXpBLVowLTksICFdKykkL2l1O1xuXG4gICAgLy8gUmVnZXggdG8gbWF0Y2ggYWxsIGhhc2ggdGFncywgYmFzaWNhbGx5IGhhc2ggZm9sbG93ZWQgYnkgYW55dGhpbmcgYnV0IHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBuZWdhdGlvbi5cbiAgICAvLyBUbyBlbnN1cmUgVVJMcyBhcmUgbm90IGNhdWdodCBpdCBpcyBsb29raW5nIG9mIGJlZ2lubmluZyBvZiBzdHJpbmcgdGFnIGFuZCBhbnlcbiAgICAvLyB0YWcgdGhhdCBoYXMgYSBzcGFjZSBpbiBmcm9udCBvZiBpdC4gQW55ICMgdGhhdCBoYXMgYSBjaGFyYWN0ZXIgaW4gZnJvbnRcbiAgICAvLyBvZiBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgLy8gRVhBTVBMRTpcbiAgICAvLyBkZXNjcmlwdGlvbjogJyNkb2cgI2NhciBodHRwOi8vd3d3L2RkZCNlcmUgI2hvdXNlJ1xuICAgIC8vIG1hdGNoZXM6ICNkb2csICNjYXIsICNob3VzZVxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaGFzaFRhZ3MgPSAvKF58XFxzKSNbXiAhQCMkJV4mKigpLC4/XCI6e318PD5dKi9nO1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaGFzaFRhZ3NGcm9tRW5kID0gbmV3IFJlZ0V4cChcbiAgICAgICAgdGhpcy5oYXNoVGFncy5zb3VyY2UgKyAnJCcsXG4gICAgKTtcblxuICAgIHByaXZhdGUgX3VyZ2VuY3k6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpbmRlbnRhdGlvbixcbiAgICAgICAgc2VjdGlvblN0YXJ0LFxuICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsU3RhdHVzQ2hhcmFjdGVyLFxuICAgICAgICBwcmVjZWRpbmdIZWFkZXIsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgICAgIGRvbmVEYXRlLFxuICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICBibG9ja0xpbmssXG4gICAgICAgIHRhZ3MsXG4gICAgfToge1xuICAgICAgICBzdGF0dXM6IFN0YXR1cztcbiAgICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgcGF0aDogc3RyaW5nO1xuICAgICAgICBpbmRlbnRhdGlvbjogc3RyaW5nO1xuICAgICAgICBzZWN0aW9uU3RhcnQ6IG51bWJlcjtcbiAgICAgICAgc2VjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgICAgIG9yaWdpbmFsU3RhdHVzQ2hhcmFjdGVyOiBzdHJpbmc7XG4gICAgICAgIHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5O1xuICAgICAgICBzdGFydERhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIGRvbmVEYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGw7XG4gICAgICAgIGJsb2NrTGluazogc3RyaW5nO1xuICAgICAgICB0YWdzOiBzdHJpbmdbXSB8IFtdO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHNlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWN0aW9uSW5kZXggPSBzZWN0aW9uSW5kZXg7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGF0dXNDaGFyYWN0ZXIgPSBvcmlnaW5hbFN0YXR1c0NoYXJhY3RlcjtcbiAgICAgICAgdGhpcy5wcmVjZWRpbmdIZWFkZXIgPSBwcmVjZWRpbmdIZWFkZXI7XG5cbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcblxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cbiAgICAgICAgdGhpcy5zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkRGF0ZSA9IHNjaGVkdWxlZERhdGU7XG4gICAgICAgIHRoaXMuZHVlRGF0ZSA9IGR1ZURhdGU7XG4gICAgICAgIHRoaXMuZG9uZURhdGUgPSBkb25lRGF0ZTtcblxuICAgICAgICB0aGlzLnJlY3VycmVuY2UgPSByZWN1cnJlbmNlO1xuICAgICAgICB0aGlzLmJsb2NrTGluayA9IGJsb2NrTGluaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZ2l2ZW4gbGluZSBmcm9tIGEgb2JzaWRpYW4gbm90ZSBhbmQgcmV0dXJucyBhIFRhc2sgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIC0gVGhlIGZ1bGwgbGluZSBpbiB0aGUgbm90ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIG5vdGUgaW4gb2JzaWRpYW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlY3Rpb25TdGFydCAtIExpbmUgbnVtYmVyIHdoZXJlIHRoZSBzZWN0aW9uIHN0YXJ0cyB0aGF0IGNvbnRhaW5zIHRoaXMgdGFzay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VjdGlvbkluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBudGggdGFzayBpbiBpdHMgc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmcgfCBudWxsKX0gcHJlY2VkaW5nSGVhZGVyIC0gVGhlIGhlYWRlciBiZWZvcmUgdGhpcyB0YXNrLlxuICAgICAqIEByZXR1cm4geyp9ICB7KFRhc2sgfCBudWxsKX1cbiAgICAgKiBAbWVtYmVyb2YgVGFza1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUxpbmUoe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBzZWN0aW9uU3RhcnQsXG4gICAgICAgIHNlY3Rpb25JbmRleCxcbiAgICAgICAgcHJlY2VkaW5nSGVhZGVyLFxuICAgIH06IHtcbiAgICAgICAgbGluZTogc3RyaW5nO1xuICAgICAgICBwYXRoOiBzdHJpbmc7XG4gICAgICAgIHNlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgICAgICBzZWN0aW9uSW5kZXg6IG51bWJlcjtcbiAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBzdHJpbmcgfCBudWxsO1xuICAgIH0pOiBUYXNrIHwgbnVsbCB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBsaW5lIHRvIHNlZSBpZiBpdCBpcyBhIG1hcmtkb3duIHRhc2suXG4gICAgICAgIGNvbnN0IHJlZ2V4TWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2sudGFza1JlZ2V4KTtcbiAgICAgICAgaWYgKHJlZ2V4TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2hbM10gaW5jbHVkZXMgdGhlIHdob2xlIGJvZHkgb2YgdGhlIHRhc2sgYWZ0ZXIgdGhlIGJyYWNrZXRzLlxuICAgICAgICBjb25zdCBib2R5ID0gcmVnZXhNYXRjaFszXS50cmltKCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGlmIHRhc2sgZG9lcyBub3QgaGF2ZSB0aGUgZ2xvYmFsIGZpbHRlci4gRG8gdGhpcyBiZWZvcmUgcHJvY2Vzc2luZ1xuICAgICAgICAvLyByZXN0IG9mIG1hdGNoIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAoIWJvZHkuaW5jbHVkZXMoZ2xvYmFsRmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBib2R5O1xuICAgICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IHJlZ2V4TWF0Y2hbMV07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzdGF0dXMgb2YgdGhlIHRhc2ssIG9ubHkgdG9kbyBhbmQgZG9uZSBzdXBwb3J0ZWQuXG4gICAgICAgIGNvbnN0IHN0YXR1c1N0cmluZyA9IHJlZ2V4TWF0Y2hbMl0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHN0YXR1czogU3RhdHVzO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1c1N0cmluZykge1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gU3RhdHVzLlRvZG87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFN0YXR1cy5Eb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggZm9yIGJsb2NrIGxpbmsgYW5kIHJlbW92ZSBpZiBmb3VuZC4gQWx3YXlzIGV4cGVjdGVkIHRvIGJlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgIGNvbnN0IGJsb2NrTGlua01hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2godGhpcy5ibG9ja0xpbmtSZWdleCk7XG4gICAgICAgIGNvbnN0IGJsb2NrTGluayA9IGJsb2NrTGlua01hdGNoICE9PSBudWxsID8gYmxvY2tMaW5rTWF0Y2hbMF0gOiAnJztcblxuICAgICAgICBpZiAoYmxvY2tMaW5rICE9PSAnJykge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKHRoaXMuYmxvY2tMaW5rUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIG1hdGNoaW5nIGFuZCByZW1vdmluZyBzcGVjaWFsIHN0cmluZ3MgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBkZXNjcmlwdGlvbiBpbiBhbnkgb3JkZXIuIFRoZSBsb29wIHNob3VsZCBvbmx5IHJ1biBvbmNlIGlmIHRoZVxuICAgICAgICAvLyBzdHJpbmdzIGFyZSBpbiB0aGUgZXhwZWN0ZWQgb3JkZXIgYWZ0ZXIgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAgICBsZXQgbWF0Y2hlZDogYm9vbGVhbjtcbiAgICAgICAgbGV0IHByaW9yaXR5OiBQcmlvcml0eSA9IFByaW9yaXR5Lk5vbmU7XG4gICAgICAgIGxldCBzdGFydERhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBkdWVEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGRvbmVEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY3VycmVuY2VSdWxlOiBzdHJpbmcgPSAnJztcbiAgICAgICAgbGV0IHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHRhZ3M6IGFueSA9IFtdO1xuICAgICAgICAvLyBUYWdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSB0aGUgZW5kIHdoaWxlIHBhcnNpbmcsIGJ1dCB3ZSB3YW50IHRvIGFkZCB0aGVtIGJhY2sgZm9yIGJlaW5nIHBhcnQgb2YgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAgICAvLyBJbiB0aGUgb3JpZ2luYWwgdGFzayBkZXNjcmlwdGlvbiB0aGV5IGFyZSBwb3NzaWJseSBtaXhlZCB3aXRoIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgLy8gKGUuZy4gI3RhZzEgPGR1ZSBkYXRlPiAjdGFnMiksIHRoZXkgZG8gbm90IGhhdmUgdG8gYWxsIHRyYWlsIGFsbCB0YXNrIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIGJ1dCBldmVudHVhbGx5IHdlIHdhbnQgdG8gcGFzdGUgdGhlbSBiYWNrIHRvIHRoZSB0YXNrIGRlc2NyaXB0aW9uIGF0IHRoZSBlbmRcbiAgICAgICAgbGV0IHRyYWlsaW5nVGFncyA9ICcnO1xuICAgICAgICAvLyBBZGQgYSBcIm1heCBydW5zXCIgZmFpbHNhZmUgdG8gbmV2ZXIgZW5kIGluIGFuIGVuZGxlc3MgbG9vcDpcbiAgICAgICAgY29uc3QgbWF4UnVucyA9IDIwO1xuICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5TWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrLnByaW9yaXR5UmVnZXgpO1xuICAgICAgICAgICAgaWYgKHByaW9yaXR5TWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByaW9yaXR5TWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuTG93OlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuTWVkaXVtOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBQcmlvcml0eS5NZWRpdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuSGlnaDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gUHJpb3JpdHkuSGlnaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoVGFzay5wcmlvcml0eVJlZ2V4LCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZG9uZURhdGVNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFRhc2suZG9uZURhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoZG9uZURhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRvbmVEYXRlID0gd2luZG93Lm1vbWVudChkb25lRGF0ZU1hdGNoWzFdLCBUYXNrLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoVGFzay5kb25lRGF0ZVJlZ2V4LCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHVlRGF0ZU1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2goVGFzay5kdWVEYXRlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKGR1ZURhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGR1ZURhdGUgPSB3aW5kb3cubW9tZW50KGR1ZURhdGVNYXRjaFsxXSwgVGFzay5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnJlcGxhY2UoVGFzay5kdWVEYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZERhdGVNYXRjaCA9IGRlc2NyaXB0aW9uLm1hdGNoKFxuICAgICAgICAgICAgICAgIFRhc2suc2NoZWR1bGVkRGF0ZVJlZ2V4LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWREYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gd2luZG93Lm1vbWVudChcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZU1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBUYXNrLmRhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFRhc2suc2NoZWR1bGVkRGF0ZVJlZ2V4LCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhcnREYXRlTWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrLnN0YXJ0RGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChzdGFydERhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQoc3RhcnREYXRlTWF0Y2hbMV0sIFRhc2suZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShUYXNrLnN0YXJ0RGF0ZVJlZ2V4LCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVjdXJyZW5jZU1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2goVGFzay5yZWN1cnJlbmNlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHJlY3VycmVuY2VNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJlY3VycmVuY2UgcnVsZSwgYnV0ICpkbyBub3QgcGFyc2UgaXQgeWV0Ki5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyB0aGUgUmVjdXJyZW5jZSBvYmplY3QgcmVxdWlyZXMgYSByZWZlcmVuY2UgZGF0ZSAoZS5nLiBhIGR1ZSBkYXRlKSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXQgbWlnaHQgYXBwZWFyIGluIHRoZSBuZXh0IChlYXJsaWVyIGluIHRoZSBsaW5lKSB0b2tlbnMgdG8gcGFyc2VcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZSA9IHJlY3VycmVuY2VNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShUYXNrLnJlY3VycmVuY2VSZWdleCwgJycpXG4gICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIHRhZ3MgZnJvbSB0aGUgZW5kIHRvIGFsbG93IHVzZXJzIHRvIG1peCB0aGUgdmFyaW91cyB0YXNrIGNvbXBvbmVudHMgd2l0aFxuICAgICAgICAgICAgLy8gdGFncy4gVGhlc2UgdGFncyB3aWxsIGJlIGFkZGVkIGJhY2sgdG8gdGhlIGRlc2NyaXB0aW9uIGJlbG93XG4gICAgICAgICAgICBjb25zdCB0YWdzTWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChUYXNrLmhhc2hUYWdzRnJvbUVuZCk7XG4gICAgICAgICAgICBpZiAodGFnc01hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFRhc2suaGFzaFRhZ3NGcm9tRW5kLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFnc01hdGNoWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIGxlZnQgYmVjYXVzZSB0aGUgbWF0Y2hpbmcgaXMgZG9uZSByaWdodC10by1sZWZ0XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdUYWdzID1cbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdUYWdzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW3RhZ05hbWUsIHRyYWlsaW5nVGFnc10uam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRhZ05hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJ1bnMrKztcbiAgICAgICAgfSB3aGlsZSAobWF0Y2hlZCAmJiBydW5zIDw9IG1heFJ1bnMpO1xuXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgYWxsIHRoZSB0YXNrIGRldGFpbHMsIHBhcnNlIHRoZSByZWN1cnJlbmNlIHJ1bGUgaWYgd2UgZm91bmQgYW55XG4gICAgICAgIGlmIChyZWN1cnJlbmNlUnVsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZWN1cnJlbmNlID0gUmVjdXJyZW5jZS5mcm9tVGV4dCh7XG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZVJ1bGVUZXh0OiByZWN1cnJlbmNlUnVsZSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYmFjayBhbnkgdHJhaWxpbmcgdGFncyB0byB0aGUgZGVzY3JpcHRpb24uIFdlIHJlbW92ZWQgdGhlbSBzbyB3ZSBjYW4gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgYnV0IG5vdyB3ZSB3YW50IHRoZW0gYmFjay5cbiAgICAgICAgLy8gVGhlIGdvYWwgaXMgZm9yIGEgdGFzayBvZiB0aGVtIGZvcm0gJ0RvIHNvbWV0aGluZyAjdGFnMSAoZHVlKSB0b21vcnJvdyAjdGFnMiAoc3RhcnQpIHRvZGF5J1xuICAgICAgICAvLyB0byBhY3R1YWxseSBoYXZlIHRoZSBkZXNjcmlwdGlvbiAnRG8gc29tZXRoaW5nICN0YWcxICN0YWcyJ1xuICAgICAgICBpZiAodHJhaWxpbmdUYWdzLmxlbmd0aCA+IDApIGRlc2NyaXB0aW9uICs9ICcgJyArIHRyYWlsaW5nVGFncztcblxuICAgICAgICAvLyBUYWdzIGFyZSBmb3VuZCBpbiB0aGUgc3RyaW5nIGFuZCBwdWxsZWQgb3V0IGJ1dCBub3QgcmVtb3ZlZCxcbiAgICAgICAgLy8gc28gd2hlbiByZXR1cm5pbmcgdGhlIGVudGlyZSB0YXNrIGl0IHdpbGwgbWF0Y2ggd2hhdCB0aGUgdXNlclxuICAgICAgICAvLyBlbnRlcmVkLlxuICAgICAgICAvLyBUaGUgZ2xvYmFsIGZpbHRlciB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgY29uc3QgaGFzaFRhZ01hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2godGhpcy5oYXNoVGFncyk7XG4gICAgICAgIGlmIChoYXNoVGFnTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRhZ3MgPSBoYXNoVGFnTWF0Y2hcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0YWcpID0+IHRhZyAhPT0gZ2xvYmFsRmlsdGVyKVxuICAgICAgICAgICAgICAgIC5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgICAgICBzZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXR1c0NoYXJhY3Rlcjogc3RhdHVzU3RyaW5nLFxuICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIGRvbmVEYXRlLFxuICAgICAgICAgICAgcmVjdXJyZW5jZSxcbiAgICAgICAgICAgIGJsb2NrTGluayxcbiAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyB0b0xpKHtcbiAgICAgICAgcGFyZW50VWxFbGVtZW50LFxuICAgICAgICBsaXN0SW5kZXgsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIGlzRmlsZW5hbWVVbmlxdWUsXG4gICAgfToge1xuICAgICAgICBwYXJlbnRVbEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgICAgICAvKiogVGhlIG50aCBpdGVtIGluIHRoaXMgbGlzdCAoaW5jbHVkaW5nIG5vbi10YXNrcykuICovXG4gICAgICAgIGxpc3RJbmRleDogbnVtYmVyO1xuICAgICAgICBsYXlvdXRPcHRpb25zPzogTGF5b3V0T3B0aW9ucztcbiAgICAgICAgaXNGaWxlbmFtZVVuaXF1ZT86IGJvb2xlYW47XG4gICAgfSk6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgICAgICBjb25zdCBsaTogSFRNTExJRWxlbWVudCA9IHBhcmVudFVsRWxlbWVudC5jcmVhdGVFbCgnbGknKTtcbiAgICAgICAgbGkuYWRkQ2xhc3NlcyhbJ3Rhc2stbGlzdC1pdGVtJywgJ3BsdWdpbi10YXNrcy1saXN0LWl0ZW0nXSk7XG5cbiAgICAgICAgbGV0IHRhc2tBc1N0cmluZyA9IHRoaXMudG9TdHJpbmcobGF5b3V0T3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyLCByZW1vdmVHbG9iYWxGaWx0ZXIgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChyZW1vdmVHbG9iYWxGaWx0ZXIpIHtcbiAgICAgICAgICAgIHRhc2tBc1N0cmluZyA9IHRhc2tBc1N0cmluZy5yZXBsYWNlKGdsb2JhbEZpbHRlciwgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleHRTcGFuID0gbGkuY3JlYXRlU3BhbigpO1xuICAgICAgICB0ZXh0U3Bhbi5hZGRDbGFzcygndGFza3MtbGlzdC10ZXh0Jyk7XG5cbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXJNYXJrZG93bihcbiAgICAgICAgICAgIHRhc2tBc1N0cmluZyxcbiAgICAgICAgICAgIHRleHRTcGFuLFxuICAgICAgICAgICAgdGhpcy5wYXRoLFxuICAgICAgICAgICAgbnVsbCBhcyB1bmtub3duIGFzIENvbXBvbmVudCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB0aGUgdGFzayBpcyBhIGJsb2NrIHF1b3RlLCB0aGUgYmxvY2sgcXVvdGUgd3JhcHMgdGhlIHAtdGFnIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB1bndyYXAgdGhlIHAtdGFnICppbnNpZGUqIHRoZSBzdXJyb3VuZGluZyBibG9jayBxdW90ZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB1bndyYXAgdGhlIHAtdGFnIGFzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIHRleHRTcGFuLlxuICAgICAgICBjb25zdCBibG9ja1F1b3RlID0gdGV4dFNwYW4ucXVlcnlTZWxlY3RvcignYmxvY2txdW90ZScpO1xuICAgICAgICBjb25zdCBkaXJlY3RQYXJlbnRPZlBUYWcgPSBibG9ja1F1b3RlID8/IHRleHRTcGFuO1xuXG4gICAgICAgIC8vIFVud3JhcCB0aGUgcC10YWcgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgTWFya2Rvd25SZW5kZXJlcjpcbiAgICAgICAgY29uc3QgcEVsZW1lbnQgPSBkaXJlY3RQYXJlbnRPZlBUYWcucXVlcnlTZWxlY3RvcigncCcpO1xuICAgICAgICBpZiAocEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlIChwRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0UGFyZW50T2ZQVGFnLmluc2VydEJlZm9yZShwRWxlbWVudC5maXJzdENoaWxkLCBwRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbiBlbXB0eSB0cmFpbGluZyBwLXRhZyB0aGF0IHRoZSBNYXJrZG93blJlbmRlcmVyIGFwcGVuZHMgd2hlbiB0aGVyZSBpcyBhIGJsb2NrIGxpbms6XG4gICAgICAgIHRleHRTcGFuLmZpbmRBbGwoJ3AnKS5mb3JFYWNoKChwRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwRWxlbWVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICBwRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmb290bm90ZSB0aGF0IHRoZSBNYXJrZG93blJlbmRlcmVyIGFwcGVuZHMgd2hlbiB0aGVyZSBpcyBhIGZvb3Rub3RlIGluIHRoZSB0YXNrOlxuICAgICAgICB0ZXh0U3Bhbi5maW5kQWxsKCcuZm9vdG5vdGVzJykuZm9yRWFjaCgoZm9vdG5vdGVFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBmb290bm90ZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gbGkuY3JlYXRlRWwoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LmFkZENsYXNzKCd0YXNrLWxpc3QtaXRlbS1jaGVja2JveCcpO1xuICAgICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBTdGF0dXMuVG9kbykge1xuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBsaS5hZGRDbGFzcygnaXMtY2hlY2tlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrYm94Lm9uQ2xpY2tFdmVudCgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBJdCBpcyByZXF1aXJlZCB0byBzdG9wIHByb3BhZ2F0aW9uIHNvIHRoYXQgb2JzaWRpYW4gd29uJ3Qgd3JpdGUgdGhlIGZpbGUgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGNoZWNrYm94ICh1biljaGVja2VkLiBPYnNpZGlhbiB3b3VsZCB3cml0ZSBhZnRlciB1cyBhbmQgb3ZlcndyaXRlIG91ciBjaGFuZ2UuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlLXJlbmRlcmVkIGFzIGVuYWJsZWQgYWZ0ZXIgdXBkYXRlIGluIGZpbGUuXG4gICAgICAgICAgICBjaGVja2JveC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0b2dnbGVkVGFza3MgPSB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgcmVwbGFjZVRhc2tXaXRoVGFza3Moe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzazogdGhpcyxcbiAgICAgICAgICAgICAgICBuZXdUYXNrczogdG9nZ2xlZFRhc2tzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpLnByZXBlbmQoY2hlY2tib3gpO1xuXG4gICAgICAgIC8vIFNldCB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGggc3RvY2sgb2JzaWRpYW4gbGlzdHM6XG4gICAgICAgIGxpLnNldEF0dHIoJ2RhdGEtdGFzaycsIHRoaXMub3JpZ2luYWxTdGF0dXNDaGFyYWN0ZXIudHJpbSgpKTsgLy8gVHJpbSB0byBlbnN1cmUgZW1wdHkgYXR0cmlidXRlIGZvciBzcGFjZS4gU2FtZSB3YXkgYXMgb2JzaWRpYW4uXG4gICAgICAgIGxpLnNldEF0dHIoJ2RhdGEtbGluZScsIGxpc3RJbmRleCk7XG4gICAgICAgIGNoZWNrYm94LnNldEF0dHIoJ2RhdGEtbGluZScsIGxpc3RJbmRleCk7XG5cbiAgICAgICAgaWYgKGxheW91dE9wdGlvbnM/LnNob3J0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUb29sdGlwKHsgZWxlbWVudDogdGV4dFNwYW4sIGlzRmlsZW5hbWVVbmlxdWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGF5b3V0T3B0aW9uc30gW2xheW91dE9wdGlvbnNdXG4gICAgICogQHJldHVybiB7Kn0gIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcobGF5b3V0T3B0aW9ucz86IExheW91dE9wdGlvbnMpOiBzdHJpbmcge1xuICAgICAgICBsYXlvdXRPcHRpb25zID0gbGF5b3V0T3B0aW9ucyA/PyBuZXcgTGF5b3V0T3B0aW9ucygpO1xuICAgICAgICBsZXQgdGFza1N0cmluZyA9IHRoaXMuZGVzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKCFsYXlvdXRPcHRpb25zLmhpZGVQcmlvcml0eSkge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5OiBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJpb3JpdHkgPT09IFByaW9yaXR5LkhpZ2gpIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICcgJyArIHByaW9yaXR5U3ltYm9scy5IaWdoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByaW9yaXR5ID09PSBQcmlvcml0eS5NZWRpdW0pIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICcgJyArIHByaW9yaXR5U3ltYm9scy5NZWRpdW07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJpb3JpdHkgPT09IFByaW9yaXR5Lkxvdykge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkxvdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFza1N0cmluZyArPSBwcmlvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGF5b3V0T3B0aW9ucy5oaWRlUmVjdXJyZW5jZVJ1bGUgJiYgdGhpcy5yZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCByZWN1cnJlbmNlUnVsZTogc3RyaW5nID0gbGF5b3V0T3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICA/ICcgJyArIHJlY3VycmVuY2VTeW1ib2xcbiAgICAgICAgICAgICAgICA6IGAgJHtyZWN1cnJlbmNlU3ltYm9sfSAke3RoaXMucmVjdXJyZW5jZS50b1RleHQoKX1gO1xuICAgICAgICAgICAgdGFza1N0cmluZyArPSByZWN1cnJlbmNlUnVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGF5b3V0T3B0aW9ucy5oaWRlU3RhcnREYXRlICYmIHRoaXMuc3RhcnREYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydERhdGU6IHN0cmluZyA9IGxheW91dE9wdGlvbnMuc2hvcnRNb2RlXG4gICAgICAgICAgICAgICAgPyAnICcgKyBzdGFydERhdGVTeW1ib2xcbiAgICAgICAgICAgICAgICA6IGAgJHtzdGFydERhdGVTeW1ib2x9ICR7dGhpcy5zdGFydERhdGUuZm9ybWF0KFxuICAgICAgICAgICAgICAgICAgICAgIFRhc2suZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICl9YDtcbiAgICAgICAgICAgIHRhc2tTdHJpbmcgKz0gc3RhcnREYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXlvdXRPcHRpb25zLmhpZGVTY2hlZHVsZWREYXRlICYmIHRoaXMuc2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVkRGF0ZTogc3RyaW5nID0gbGF5b3V0T3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICA/ICcgJyArIHNjaGVkdWxlZERhdGVTeW1ib2xcbiAgICAgICAgICAgICAgICA6IGAgJHtzY2hlZHVsZWREYXRlU3ltYm9sfSAke3RoaXMuc2NoZWR1bGVkRGF0ZS5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgVGFzay5kYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgKX1gO1xuICAgICAgICAgICAgdGFza1N0cmluZyArPSBzY2hlZHVsZWREYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXlvdXRPcHRpb25zLmhpZGVEdWVEYXRlICYmIHRoaXMuZHVlRGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgZHVlRGF0ZTogc3RyaW5nID0gbGF5b3V0T3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICA/ICcgJyArIGR1ZURhdGVTeW1ib2xcbiAgICAgICAgICAgICAgICA6IGAgJHtkdWVEYXRlU3ltYm9sfSAke3RoaXMuZHVlRGF0ZS5mb3JtYXQoVGFzay5kYXRlRm9ybWF0KX1gO1xuICAgICAgICAgICAgdGFza1N0cmluZyArPSBkdWVEYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXlvdXRPcHRpb25zLmhpZGVEb25lRGF0ZSAmJiB0aGlzLmRvbmVEYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lRGF0ZTogc3RyaW5nID0gbGF5b3V0T3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICA/ICcgJyArIGRvbmVEYXRlU3ltYm9sXG4gICAgICAgICAgICAgICAgOiBgICR7ZG9uZURhdGVTeW1ib2x9ICR7dGhpcy5kb25lRGF0ZS5mb3JtYXQoVGFzay5kYXRlRm9ybWF0KX1gO1xuICAgICAgICAgICAgdGFza1N0cmluZyArPSBkb25lRGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2NrTGluazogc3RyaW5nID0gdGhpcy5ibG9ja0xpbmsgPz8gJyc7XG4gICAgICAgIHRhc2tTdHJpbmcgKz0gYmxvY2tMaW5rO1xuXG4gICAgICAgIHJldHVybiB0YXNrU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRhc2sgYXMgYSBsaXN0IGl0ZW0gd2l0aCBhIGNoZWNrYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9GaWxlTGluZVN0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pbmRlbnRhdGlvbn0tIFske1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXR1c0NoYXJhY3RlclxuICAgICAgICB9XSAke3RoaXMudG9TdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhpcyB0YXNrIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdGFza3MuXG4gICAgICpcbiAgICAgKiBUb2dnbGluZyBjYW4gcmVzdWx0IGluIG1vcmUgdGhhbiBvbmUgcmV0dXJuZWQgdGFzayBpbiB0aGUgY2FzZSBvZlxuICAgICAqIHJlY3VycmVuY2UuIElmIGl0IGlzIGEgcmVjdXJyaW5nIHRhc2ssIHRoZSB0b2dnbGVkIHRhc2sgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIHRvZ2V0aGVyIHdpdGggdGhlIG5leHQgb2NjdXJyZW5jZSBpbiB0aGUgb3JkZXIgYFtuZXh0LCB0b2dnbGVkXWAuIElmIHRoZVxuICAgICAqIHRhc2sgaXMgbm90IHJlY3VycmluZywgaXQgd2lsbCByZXR1cm4gYFt0b2dnbGVkXWAuXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBuZXdTdGF0dXM6IFN0YXR1cyA9XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gU3RhdHVzLlRvZG8gPyBTdGF0dXMuRG9uZSA6IFN0YXR1cy5Ub2RvO1xuXG4gICAgICAgIGxldCBuZXdEb25lRGF0ZSA9IG51bGw7XG5cbiAgICAgICAgbGV0IG5leHRPY2N1cnJlbmNlOiB7XG4gICAgICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXdTdGF0dXMgIT09IFN0YXR1cy5Ub2RvKSB7XG4gICAgICAgICAgICAvLyBTZXQgZG9uZSBkYXRlIG9ubHkgaWYgc2V0dGluZyB2YWx1ZSBpcyB0cnVlXG4gICAgICAgICAgICBjb25zdCB7IHNldERvbmVEYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgaWYgKHNldERvbmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgbmV3RG9uZURhdGUgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgdGFzayBpcyBubyBsb25nZXIgdG9kbywgd2UgbmVlZCB0byBjaGVjayBpZiBpdCBpcyByZWN1cnJpbmc6XG4gICAgICAgICAgICBpZiAodGhpcy5yZWN1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV4dE9jY3VycmVuY2UgPSB0aGlzLnJlY3VycmVuY2UubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9nZ2xlZFRhc2sgPSBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgc3RhdHVzOiBuZXdTdGF0dXMsXG4gICAgICAgICAgICBkb25lRGF0ZTogbmV3RG9uZURhdGUsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXR1c0NoYXJhY3RlcjogbmV3U3RhdHVzID09PSBTdGF0dXMuRG9uZSA/ICd4JyA6ICcgJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbmV3VGFza3M6IFRhc2tbXSA9IFtdO1xuXG4gICAgICAgIGlmIChuZXh0T2NjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRhc2sgPSBuZXcgVGFzayh7XG4gICAgICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgICAgICAuLi5uZXh0T2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICAvLyBOZXcgb2NjdXJyZW5jZXMgY2Fubm90IGhhdmUgdGhlIHNhbWUgYmxvY2sgbGluay5cbiAgICAgICAgICAgICAgICAvLyBBbmQgcmFuZG9tIGJsb2NrIGxpbmtzIGRvbid0IGhlbHAuXG4gICAgICAgICAgICAgICAgYmxvY2tMaW5rOiAnJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3VGFza3MucHVzaChuZXh0VGFzayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBuZXh0IG9jY3VycmVuY2UgYmVmb3JlIHByZXZpb3VzIG9jY3VycmVuY2UuXG4gICAgICAgIG5ld1Rhc2tzLnB1c2godG9nZ2xlZFRhc2spO1xuXG4gICAgICAgIHJldHVybiBuZXdUYXNrcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHVyZ2VuY3koKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3VyZ2VuY3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VyZ2VuY3kgPSBVcmdlbmN5LmNhbGN1bGF0ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl91cmdlbmN5O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlsZW5hbWUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lTWF0Y2ggPSB0aGlzLnBhdGgubWF0Y2goLyhbXi9dKylcXC5tZCQvKTtcbiAgICAgICAgaWYgKGZpbGVOYW1lTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZU1hdGNoWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciB3aGVuIGxpbmtpbmcgdG8gdGhlIG9yaWdpbiBvZiB0aGUgdGFza1xuICAgICAqXG4gICAgICogQHBhcmFtIGlzRmlsZW5hbWVVbmlxdWUge2Jvb2xlYW58bnVsbH0gV2hldGhlciB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSB0YXNrIGlzIHVuaXF1ZSBpbiB0aGUgdmF1bHQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgaXQgaXMgdW5kZWZpbmVkLCB0aGUgb3V0Y29tZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHdpdGggYSB1bmlxdWUgZmlsZSBuYW1lOiB0aGUgZmlsZSBuYW1lIG9ubHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bGwgcGF0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMaW5rVGV4dCh7XG4gICAgICAgIGlzRmlsZW5hbWVVbmlxdWUsXG4gICAgfToge1xuICAgICAgICBpc0ZpbGVuYW1lVW5pcXVlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIH0pOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgbGV0IGxpbmtUZXh0OiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBpZiAoaXNGaWxlbmFtZVVuaXF1ZSkge1xuICAgICAgICAgICAgbGlua1RleHQgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQSBzbGFzaCBhdCB0aGUgYmVnaW5uaW5nIGluZGljYXRlcyB0aGlzIGlzIGEgcGF0aCwgbm90IGEgZmlsZW5hbWUuXG4gICAgICAgICAgICBsaW5rVGV4dCA9ICcvJyArIHRoaXMucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5rVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgd291bGRuJ3QgcHJvdmlkZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFuZCBvbmx5IHRha2UgdXAgc3BhY2UuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMucHJlY2VkaW5nSGVhZGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLnByZWNlZGluZ0hlYWRlciAhPT0gbGlua1RleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IGxpbmtUZXh0ICsgJyA+ICcgKyB0aGlzLnByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBsaXN0cyBvZiBUYXNrIG9iamVjdHMsIGFuZCByZXBvcnQgd2hldGhlciB0aGVpclxuICAgICAqIHRhc2tzIGFyZSBpZGVudGljYWwgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIG9wdGltaXNpbmcgY29kZSBpZiBpdCBpcyBndWFyYW50ZWVkIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gcG9zc2libGUgZGlmZmVyZW5jZXMgaW4gdGhlIHRhc2tzIGluIGEgZmlsZVxuICAgICAqIGFmdGVyIGFuIGVkaXQsIGZvciBleGFtcGxlLlxuICAgICAqXG4gICAgICogSWYgYW55IGZpZWxkIGlzIGRpZmZlcmVudCBpbiBhbnkgdGFzaywgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2xkVGFza3NcbiAgICAgKiBAcGFyYW0gbmV3VGFza3NcbiAgICAgKi9cbiAgICBzdGF0aWMgdGFza3NMaXN0c0lkZW50aWNhbChvbGRUYXNrczogVGFza1tdLCBuZXdUYXNrczogVGFza1tdKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvbGRUYXNrcy5sZW5ndGggIT09IG5ld1Rhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRUYXNrcy5ldmVyeSgob2xkVGFzaywgaW5kZXgpID0+XG4gICAgICAgICAgICBvbGRUYXNrLmlkZW50aWNhbFRvKG5ld1Rhc2tzW2luZGV4XSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBhbGwgdGhlIGZpZWxkcyBpbiBhbm90aGVyIFRhc2ssIHRvIGRldGVjdCBhbnkgZGlmZmVyZW5jZXMgZnJvbSB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIElmIGFueSBmaWVsZCBpcyBkaWZmZXJlbnQgaW4gYW55IHdheSwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgaW4gc29tZSBvcHRpbWlzYXRpb25zLCB0byBhdm9pZCB3b3JrIGlmIGFuIGVkaXQgdG8gZmlsZVxuICAgICAqIGRvZXMgbm90IGNoYW5nZSBhbnkgdGFza3MsIHNvIGl0IGlzIHZpdGFsIHRoYXQgaXRzIGRlZmluaXRpb25cbiAgICAgKiBvZiBpZGVudGljYWwgaXMgdmVyeSBzdHJpY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgaWRlbnRpY2FsVG8ob3RoZXI6IFRhc2spIHtcbiAgICAgICAgLy8gQmFzZWQgb24gaWRlYXMgZnJvbSBrb2FsYS4gQXF1YUNhdCBhbmQgamF2YWxlbnQgaW4gRGlzY29yZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82ODYwNTM3MDgyNjEyMjg1NzcvODQwMjg2MjY0OTY0MDIyMzAyLzk5NjczNTIwMDM4ODE4NjE4MlxuICAgICAgICAvLyBhbmQgbGF0ZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IHNlY3Rpb25TdGFydCBjaGFuZ2VzIGV2ZXJ5IHRpbWUgYSBsaW5lIGlzIGFkZGVkIG9yIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAgIC8vICAgICAgIGFueSBvZiB0aGUgdGFza3MgaW4gYSBmaWxlLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHJlZHJhd2luZyBvZiB0YXNrcyBibG9ja3NcbiAgICAgICAgLy8gICAgICAgaGFwcGVucyBtb3JlIG9mdGVuIHRoYW4gaXMgaWRlYWwuXG4gICAgICAgIGxldCBhcmdzOiBBcnJheTxrZXlvZiBUYXNrPiA9IFtcbiAgICAgICAgICAgICdzdGF0dXMnLFxuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwYXRoJyxcbiAgICAgICAgICAgICdpbmRlbnRhdGlvbicsXG4gICAgICAgICAgICAnc2VjdGlvblN0YXJ0JyxcbiAgICAgICAgICAgICdzZWN0aW9uSW5kZXgnLFxuICAgICAgICAgICAgJ29yaWdpbmFsU3RhdHVzQ2hhcmFjdGVyJyxcbiAgICAgICAgICAgICdwcmVjZWRpbmdIZWFkZXInLFxuICAgICAgICAgICAgJ3ByaW9yaXR5JyxcbiAgICAgICAgICAgICdibG9ja0xpbmsnLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2VsXSAhPT0gb3RoZXJbZWxdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIHRhZ3NcbiAgICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggIT09IG90aGVyLnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFncyBhcmUgdGhlIHNhbWUgb25seSBpZiB0aGUgdmFsdWVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGhpcy50YWdzLmV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09PSBvdGhlci50YWdzW2luZGV4XTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBhcmdzID0gWydzdGFydERhdGUnLCAnc2NoZWR1bGVkRGF0ZScsICdkdWVEYXRlJywgJ2RvbmVEYXRlJ107XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgYXJncykge1xuICAgICAgICAgICAgY29uc3QgZGF0ZTEgPSB0aGlzW2VsXSBhcyBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0ZTIgPSBvdGhlcltlbF0gYXMgTW9tZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChTb3J0LmNvbXBhcmVCeURhdGUoZGF0ZTEsIGRhdGUyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY3VycmVuY2UxID0gdGhpcy5yZWN1cnJlbmNlO1xuICAgICAgICBjb25zdCByZWN1cnJlbmNlMiA9IG90aGVyLnJlY3VycmVuY2U7XG4gICAgICAgIGlmIChyZWN1cnJlbmNlMSA9PT0gbnVsbCAmJiByZWN1cnJlbmNlMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY3VycmVuY2UxICE9PSBudWxsICYmIHJlY3VycmVuY2UyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICByZWN1cnJlbmNlMSAmJlxuICAgICAgICAgICAgcmVjdXJyZW5jZTIgJiZcbiAgICAgICAgICAgICFyZWN1cnJlbmNlMS5pZGVudGljYWxUbyhyZWN1cnJlbmNlMilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRvb2x0aXAoe1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBpc0ZpbGVuYW1lVW5pcXVlLFxuICAgIH06IHtcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlzRmlsZW5hbWVVbmlxdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgfSk6IHZvaWQge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b29sdGlwID0gZWxlbWVudC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgIHRvb2x0aXAuYWRkQ2xhc3NlcyhbJ3Rvb2x0aXAnLCAnbW9kLXJpZ2h0J10pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdXJyZW5jZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgICAgICBgJHtyZWN1cnJlbmNlU3ltYm9sfSAke3RoaXMucmVjdXJyZW5jZS50b1RleHQoKX1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGF0ZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlRGl2LnNldFRleHQoXG4gICAgICAgICAgICAgICAgICAgIFRhc2sudG9Ub29sdGlwRGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduaWZpZXI6IHN0YXJ0RGF0ZVN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zY2hlZHVsZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVkRGF0ZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgICAgICBUYXNrLnRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWVyOiBzY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5zY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kdWVEYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVlRGF0ZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgZHVlRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgICAgICBUYXNrLnRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWVyOiBkdWVEYXRlU3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5kdWVEYXRlLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kb25lRGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmVEYXRlRGl2ID0gdG9vbHRpcC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgICAgICBkb25lRGF0ZURpdi5zZXRUZXh0KFxuICAgICAgICAgICAgICAgICAgICBUYXNrLnRvVG9vbHRpcERhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWVyOiBkb25lRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMuZG9uZURhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmtUZXh0ID0gdGhpcy5nZXRMaW5rVGV4dCh7IGlzRmlsZW5hbWVVbmlxdWUgfSk7XG4gICAgICAgICAgICBpZiAobGlua1RleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrbGlua0RpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgYmFja2xpbmtEaXYuc2V0VGV4dChgXHVEODNEXHVERDE3ICR7bGlua1RleHR9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHRvVG9vbHRpcERhdGUoe1xuICAgICAgICBzaWduaWZpZXIsXG4gICAgICAgIGRhdGUsXG4gICAgfToge1xuICAgICAgICBzaWduaWZpZXI6IHN0cmluZztcbiAgICAgICAgZGF0ZTogTW9tZW50O1xuICAgIH0pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c2lnbmlmaWVyfSAke2RhdGUuZm9ybWF0KFRhc2suZGF0ZUZvcm1hdCl9ICgke2RhdGUuZnJvbShcbiAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgKX0pYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgYXMgcGFydCBvZiBhIFJlZ0V4cCBsaXRlcmFsbHkuXG4gICAgICogVGFrZW4gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMjZXNjYXBpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGVzY2FwZVJlZ0V4cChzOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gTk9URTogPSBpcyBub3QgZXNjYXBlZCwgYXMgZG9pbmcgc28gZ2l2ZXMgZXJyb3I6XG4gICAgICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXD13b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgICAgICAvLyBOT1RFOiAhIGlzIG5vdCBlc2NhcGVkLCBhcyBkb2luZyBzbyBnaXZlcyBlcnJvcjpcbiAgICAgICAgLy8gICAgICAgICBJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogLyhefFxccyloZWxsb1xcIXdvcmxkKCR8XFxzKS86IEludmFsaWQgZXNjYXBlXG4gICAgICAgIC8vIE5PVEU6IDogaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgICAgICAvLyAgICAgICAgIEludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvKF58XFxzKWhlbGxvXFw6d29ybGQoJHxcXHMpLzogSW52YWxpZCBlc2NhcGVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXhwbGFuYXRpb24gZnJvbSBAQW5uYUtvcm5mZWxkU2ltcHNvbiBpbjpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzbTcvb2JzaWRpYW4tdGFza3MvcHVsbC8xOCNpc3N1ZWNvbW1lbnQtMTE5NjExNTQwN1xuICAgICAgICAvLyBGcm9tIHdoYXQgSSBjYW4gdGVsbCwgdGhlIHRocmVlIG1pc3NpbmcgY2hhcmFjdGVycyBmcm9tIHRoZSBvcmlnaW5hbCByZWdleCAtIDogISA9XG4gICAgICAgIC8vIGFyZSBhbGwgb25seSBjb25zaWRlcmVkIHRvIGhhdmUgc3BlY2lhbCBtZWFuaW5ncyBpZiB0aGV5IGRpcmVjdGx5IGZvbGxvd1xuICAgICAgICAvLyBhID8gKGFsbCAzKSBvciBhID88ICghIGFuZCA9KS5cbiAgICAgICAgLy8gU28gdGhlb3JldGljYWxseSBpZiB0aGUgPyBhcmUgYWxsIGVzY2FwZWQsIHRob3NlIHRocmVlIGNoYXJhY3RlcnMgZG8gbm90IGhhdmUgdG8gYmUuXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxdL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciB0aGUgZ2xvYmFsIGZpbHRlciBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgZGVzY3JpcHRpb24sIGJ1dCBkbyBzbyBvbmx5XG4gICAgICogaWYgaXQgaXMgYSBzZXBhcmF0ZSB3b3JkIChwcmVjZWRpbmcgdGhlIGJlZ2lubmluZyBvZiBsaW5lIG9yIGEgc3BhY2UgYW5kIGZvbGxvd2VkIGJ5IHRoZSBlbmQgb2YgbGluZVxuICAgICAqIG9yIGEgc3BhY2UpLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gY3V0LW9mZiBuZXN0ZWQgdGFncyBsaWtlICN0YXNrL3N1YnRhZy5cbiAgICAgKiBJZiB0aGUgZ2xvYmFsIGZpbHRlciBleGlzdHMgYXMgcGFydCBvZiBhIG5lc3RlZCB0YWcsIHdlIGtlZXAgaXQgdW50b3VjaGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXREZXNjcmlwdGlvbldpdGhvdXRHbG9iYWxGaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSB0aGlzLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoZ2xvYmFsRmlsdGVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIGdsb2JhbCBmaWx0ZXIgKGFmdGVyIGVzY2FwaW5nIGl0KSBvbmx5IHdoZW4gaXQncyBhIGNvbXBsZXRlIHdvcmRcbiAgICAgICAgY29uc3QgZ2xvYmFsRmlsdGVyUmVnZXggPSBSZWdFeHAoXG4gICAgICAgICAgICAnKF58XFxcXHMpJyArIHRoaXMuZXNjYXBlUmVnRXhwKGdsb2JhbEZpbHRlcikgKyAnKCR8XFxcXHMpJyxcbiAgICAgICAgICAgICd1ZycsXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLnNlYXJjaChnbG9iYWxGaWx0ZXJSZWdleCkgPiAtMSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGdsb2JhbEZpbHRlclJlZ2V4LCAnJDEkMicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJyAgJywgJyAnKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBNZXRhZGF0YUNhY2hlLCBURmlsZSwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IExpc3RJdGVtQ2FjaGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi9jb25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxubGV0IG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGUgfCB1bmRlZmluZWQ7XG5sZXQgdmF1bHQ6IFZhdWx0IHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUZpbGUgPSAoe1xuICAgIG1ldGFkYXRhQ2FjaGU6IG5ld01ldGFkYXRhQ2FjaGUsXG4gICAgdmF1bHQ6IG5ld1ZhdWx0LFxufToge1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgdmF1bHQ6IFZhdWx0O1xufSkgPT4ge1xuICAgIG1ldGFkYXRhQ2FjaGUgPSBuZXdNZXRhZGF0YUNhY2hlO1xuICAgIHZhdWx0ID0gbmV3VmF1bHQ7XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBvcmlnaW5hbCB0YXNrIHdpdGggb25lIG9yIG1vcmUgbmV3IHRhc3NrLlxuICpcbiAqIElmIHlvdSBwYXNzIG1vcmUgdGhhbiBvbmUgcmVwbGFjZW1lbnQgdGFzaywgYWxsIHN1YnNlcXVlbnQgdGFza3MgaW4gdGhlIHNhbWVcbiAqIHNlY3Rpb24gbXVzdCBiZSByZS1yZW5kZXJlZCwgYXMgdGhlaXIgc2VjdGlvbiBpbmRleGVzIGNoYW5nZS4gQXNzdW1pbmcgdGhhdFxuICogdGhpcyBpcyBkb25lIGZhc3RlciB0aGFuIHVzZXIgaW50ZXJhY3Rpb24gaW4gcHJhY3RpY2UuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlVGFza1dpdGhUYXNrcyA9IGFzeW5jICh7XG4gICAgb3JpZ2luYWxUYXNrLFxuICAgIG5ld1Rhc2tzLFxufToge1xuICAgIG9yaWdpbmFsVGFzazogVGFzaztcbiAgICBuZXdUYXNrczogVGFzayB8IFRhc2tbXTtcbn0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAodmF1bHQgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza3M6IGNhbm5vdCB1c2UgRmlsZSBiZWZvcmUgaW5pdGlhbGl6aW5nIGl0LicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld1Rhc2tzKSkge1xuICAgICAgICBuZXdUYXNrcyA9IFtuZXdUYXNrc107XG4gICAgfVxuXG4gICAgdHJ5UmVwZXRpdGl2ZSh7XG4gICAgICAgIG9yaWdpbmFsVGFzayxcbiAgICAgICAgbmV3VGFza3MsXG4gICAgICAgIHZhdWx0LFxuICAgICAgICBtZXRhZGF0YUNhY2hlLFxuICAgICAgICBwcmV2aW91c1RyaWVzOiAwLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0byByZS10cnkgd2hlbiB0aGUgcmV0dXJuZWQgZmlsZSBjYWNoZSBpcyBgdW5kZWZpbmVkYC5cbiAqIFJldHJ5aW5nIGFmdGVyIGEgd2hpbGUgbWF5IHJldHVybiBhIHZhbGlkIGZpbGUgY2FjaGUuXG4gKiBSZXBvcnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzg3XG4gKi9cbmNvbnN0IHRyeVJlcGV0aXRpdmUgPSBhc3luYyAoe1xuICAgIG9yaWdpbmFsVGFzayxcbiAgICBuZXdUYXNrcyxcbiAgICB2YXVsdCxcbiAgICBtZXRhZGF0YUNhY2hlLFxuICAgIHByZXZpb3VzVHJpZXMsXG59OiB7XG4gICAgb3JpZ2luYWxUYXNrOiBUYXNrO1xuICAgIG5ld1Rhc2tzOiBUYXNrW107XG4gICAgdmF1bHQ6IFZhdWx0O1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgcHJldmlvdXNUcmllczogbnVtYmVyO1xufSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXNUcmllcyA+IDEwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdUYXNrczogVG9vIG1hbnkgcmV0cmllcy4gRmlsZSB1cGRhdGUgbm90IHBvc3NpYmxlIC4uLicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZW91dCA9IE1hdGgubWluKE1hdGgucG93KDEwLCBwcmV2aW91c1RyaWVzKSwgMTAwKTsgLy8gMSwgMTAsIDEwMCwgMTAwLCAxMDAsIC4uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRyeVJlcGV0aXRpdmUoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzayxcbiAgICAgICAgICAgICAgICBuZXdUYXNrcyxcbiAgICAgICAgICAgICAgICB2YXVsdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVHJpZXM6IHByZXZpb3VzVHJpZXMgKyAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9yaWdpbmFsVGFzay5wYXRoKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBUYXNrczogTm8gZmlsZSBmb3VuZCBmb3IgdGFzayAke29yaWdpbmFsVGFzay5kZXNjcmlwdGlvbn0uIFJldHJ5aW5nIC4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXRyeSgpO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmV4dGVuc2lvbiAhPT0gJ21kJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1Rhc2tzOiBPbmx5IHN1cHBvcnRpbmcgZmlsZXMgd2l0aCB0aGUgLm1kIGZpbGUgZXh0ZW5zaW9uLicsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlQ2FjaGUgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICBpZiAoZmlsZUNhY2hlID09IHVuZGVmaW5lZCB8fCBmaWxlQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFRhc2tzOiBObyBmaWxlIGNhY2hlIGZvdW5kIGZvciBmaWxlICR7ZmlsZS5wYXRofS4gUmV0cnlpbmcgLi4uYCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdEl0ZW1zQ2FjaGUgPSBmaWxlQ2FjaGUubGlzdEl0ZW1zO1xuICAgIGlmIChsaXN0SXRlbXNDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IGxpc3RJdGVtc0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVGFza3M6IE5vIGxpc3QgaXRlbXMgZm91bmQgaW4gZmlsZSBjYWNoZSBvZiAke2ZpbGUucGF0aH0uIFJldHJ5aW5nIC4uLmAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXRyeSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdmF1bHQucmVhZChmaWxlKTtcbiAgICBjb25zdCBmaWxlTGluZXMgPSBmaWxlQ29udGVudC5zcGxpdCgnXFxuJyk7XG5cbiAgICBjb25zdCB7IGdsb2JhbEZpbHRlciB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICBsZXQgbGlzdEl0ZW06IExpc3RJdGVtQ2FjaGUgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHNlY3Rpb25JbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBsaXN0SXRlbUNhY2hlIG9mIGxpc3RJdGVtc0NhY2hlKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbUNhY2hlLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPCBvcmlnaW5hbFRhc2suc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0SXRlbUNhY2hlLnRhc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5lID0gZmlsZUxpbmVzW2xpc3RJdGVtQ2FjaGUucG9zaXRpb24uc3RhcnQubGluZV07XG5cbiAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoZ2xvYmFsRmlsdGVyKSkge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb25JbmRleCA9PT0gb3JpZ2luYWxUYXNrLnNlY3Rpb25JbmRleCkge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbGlzdEl0ZW1DYWNoZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VjdGlvbkluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza3M6IGNvdWxkIG5vdCBmaW5kIHRhc2sgdG8gdG9nZ2xlIGluIHRoZSBmaWxlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZEZpbGVMaW5lcyA9IFtcbiAgICAgICAgLi4uZmlsZUxpbmVzLnNsaWNlKDAsIGxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmUpLFxuICAgICAgICAuLi5uZXdUYXNrcy5tYXAoKHRhc2s6IFRhc2spID0+IHRhc2sudG9GaWxlTGluZVN0cmluZygpKSxcbiAgICAgICAgLi4uZmlsZUxpbmVzLnNsaWNlKGxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmUgKyAxKSwgLy8gT25seSBzdXBwb3J0cyBzaW5nbGUtbGluZSB0YXNrcy5cbiAgICBdO1xuXG4gICAgYXdhaXQgdmF1bHQubW9kaWZ5KGZpbGUsIHVwZGF0ZWRGaWxlTGluZXMuam9pbignXFxuJykpO1xufTtcbiIsICJleHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgICBnbG9iYWxGaWx0ZXI6IHN0cmluZztcbiAgICByZW1vdmVHbG9iYWxGaWx0ZXI6IGJvb2xlYW47XG4gICAgc2V0RG9uZURhdGU6IGJvb2xlYW47XG4gICAgYXV0b1N1Z2dlc3RJbkVkaXRvcjogYm9vbGVhbjtcbiAgICBhdXRvU3VnZ2VzdE1pbk1hdGNoOiBudW1iZXI7XG4gICAgYXV0b1N1Z2dlc3RNYXhJdGVtczogbnVtYmVyO1xufVxuXG5jb25zdCBkZWZhdWx0U2V0dGluZ3M6IFNldHRpbmdzID0ge1xuICAgIGdsb2JhbEZpbHRlcjogJycsXG4gICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiBmYWxzZSxcbiAgICBzZXREb25lRGF0ZTogdHJ1ZSxcbiAgICBhdXRvU3VnZ2VzdEluRWRpdG9yOiB0cnVlLFxuICAgIGF1dG9TdWdnZXN0TWluTWF0Y2g6IDAsXG4gICAgYXV0b1N1Z2dlc3RNYXhJdGVtczogNixcbn07XG5cbmxldCBzZXR0aW5nczogU2V0dGluZ3MgPSB7IC4uLmRlZmF1bHRTZXR0aW5ncyB9O1xuXG5leHBvcnQgY29uc3QgZ2V0U2V0dGluZ3MgPSAoKTogU2V0dGluZ3MgPT4ge1xuICAgIHJldHVybiB7IC4uLnNldHRpbmdzIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSAobmV3U2V0dGluZ3M6IFBhcnRpYWw8U2V0dGluZ3M+KTogU2V0dGluZ3MgPT4ge1xuICAgIHNldHRpbmdzID0geyAuLi5zZXR0aW5ncywgLi4ubmV3U2V0dGluZ3MgfTtcblxuICAgIHJldHVybiBnZXRTZXR0aW5ncygpO1xufTtcbiIsICJleHBvcnQgY2xhc3MgTGF5b3V0T3B0aW9ucyB7XG4gICAgaGlkZVRhc2tDb3VudDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVCYWNrbGlua3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlUHJpb3JpdHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlU3RhcnREYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZVNjaGVkdWxlZERhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlRG9uZURhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlRHVlRGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVSZWN1cnJlbmNlUnVsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVFZGl0QnV0dG9uOiBib29sZWFuID0gZmFsc2U7XG4gICAgc2hvcnRNb2RlOiBib29sZWFuID0gZmFsc2U7XG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IHRzbGliIGZyb20gJy4uL3RzbGliLmpzJztcclxuY29uc3Qge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbixcclxufSA9IHRzbGliO1xyXG5leHBvcnQge1xyXG4gICAgX19leHRlbmRzLFxyXG4gICAgX19hc3NpZ24sXHJcbiAgICBfX3Jlc3QsXHJcbiAgICBfX2RlY29yYXRlLFxyXG4gICAgX19wYXJhbSxcclxuICAgIF9fbWV0YWRhdGEsXHJcbiAgICBfX2F3YWl0ZXIsXHJcbiAgICBfX2dlbmVyYXRvcixcclxuICAgIF9fZXhwb3J0U3RhcixcclxuICAgIF9fY3JlYXRlQmluZGluZyxcclxuICAgIF9fdmFsdWVzLFxyXG4gICAgX19yZWFkLFxyXG4gICAgX19zcHJlYWQsXHJcbiAgICBfX3NwcmVhZEFycmF5cyxcclxuICAgIF9fc3ByZWFkQXJyYXksXHJcbiAgICBfX2F3YWl0LFxyXG4gICAgX19hc3luY0dlbmVyYXRvcixcclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IsXHJcbiAgICBfX2FzeW5jVmFsdWVzLFxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QsXHJcbiAgICBfX2ltcG9ydFN0YXIsXHJcbiAgICBfX2ltcG9ydERlZmF1bHQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbixcclxufTtcclxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImltcG9ydCB0eXBlIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgUXVlcnksIFNvcnRpbmdQcm9wZXJ0eSB9IGZyb20gJy4vUXVlcnknO1xuXG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4vY29uZmlnL1NldHRpbmdzJztcblxudHlwZSBDb21wYXJhdG9yID0gKGE6IFRhc2ssIGI6IFRhc2spID0+IG51bWJlcjtcblxuZXhwb3J0IGNsYXNzIFNvcnQge1xuICAgIHN0YXRpYyB0YWdQcm9wZXJ0eUluc3RhbmNlOiBudW1iZXIgPSAxO1xuXG4gICAgcHVibGljIHN0YXRpYyBieShxdWVyeTogUGljazxRdWVyeSwgJ3NvcnRpbmcnPiwgdGFza3M6IFRhc2tbXSk6IFRhc2tbXSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb21wYXJhdG9yczogQ29tcGFyYXRvcltdID0gW1xuICAgICAgICAgICAgU29ydC5jb21wYXJlQnlVcmdlbmN5LFxuICAgICAgICAgICAgU29ydC5jb21wYXJlQnlTdGF0dXMsXG4gICAgICAgICAgICBTb3J0LmNvbXBhcmVCeUR1ZURhdGUsXG4gICAgICAgICAgICBTb3J0LmNvbXBhcmVCeVByaW9yaXR5LFxuICAgICAgICAgICAgU29ydC5jb21wYXJlQnlQYXRoLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHVzZXJDb21wYXJhdG9yczogQ29tcGFyYXRvcltdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB7IHByb3BlcnR5LCByZXZlcnNlLCBwcm9wZXJ0eUluc3RhbmNlIH0gb2YgcXVlcnkuc29ydGluZykge1xuICAgICAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IFNvcnQuY29tcGFyYXRvcnNbcHJvcGVydHldO1xuICAgICAgICAgICAgdXNlckNvbXBhcmF0b3JzLnB1c2goXG4gICAgICAgICAgICAgICAgcmV2ZXJzZSA/IFNvcnQubWFrZVJldmVyc2VkQ29tcGFyYXRvcihjb21wYXJhdG9yKSA6IGNvbXBhcmF0b3IsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAndGFnJykge1xuICAgICAgICAgICAgICAgIFNvcnQudGFnUHJvcGVydHlJbnN0YW5jZSA9IHByb3BlcnR5SW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFza3Muc29ydChcbiAgICAgICAgICAgIFNvcnQubWFrZUNvbXBvc2l0ZUNvbXBhcmF0b3IoW1xuICAgICAgICAgICAgICAgIC4uLnVzZXJDb21wYXJhdG9ycyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29tcGFyYXRvcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJhdG9yczogUmVjb3JkPFNvcnRpbmdQcm9wZXJ0eSwgQ29tcGFyYXRvcj4gPSB7XG4gICAgICAgIHVyZ2VuY3k6IFNvcnQuY29tcGFyZUJ5VXJnZW5jeSxcbiAgICAgICAgZGVzY3JpcHRpb246IFNvcnQuY29tcGFyZUJ5RGVzY3JpcHRpb24sXG4gICAgICAgIHByaW9yaXR5OiBTb3J0LmNvbXBhcmVCeVByaW9yaXR5LFxuICAgICAgICBzdGFydDogU29ydC5jb21wYXJlQnlTdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZDogU29ydC5jb21wYXJlQnlTY2hlZHVsZWREYXRlLFxuICAgICAgICBkdWU6IFNvcnQuY29tcGFyZUJ5RHVlRGF0ZSxcbiAgICAgICAgZG9uZTogU29ydC5jb21wYXJlQnlEb25lRGF0ZSxcbiAgICAgICAgcGF0aDogU29ydC5jb21wYXJlQnlQYXRoLFxuICAgICAgICBzdGF0dXM6IFNvcnQuY29tcGFyZUJ5U3RhdHVzLFxuICAgICAgICB0YWc6IFNvcnQuY29tcGFyZUJ5VGFnLFxuICAgIH07XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYWtlUmV2ZXJzZWRDb21wYXJhdG9yKGNvbXBhcmF0b3I6IENvbXBhcmF0b3IpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhLCBiKSA9PiAoY29tcGFyYXRvcihhLCBiKSAqIC0xKSBhcyAtMSB8IDAgfCAxO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG1ha2VDb21wb3NpdGVDb21wYXJhdG9yKFxuICAgICAgICBjb21wYXJhdG9yczogQ29tcGFyYXRvcltdLFxuICAgICk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYSwgYik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNvbXBhcmVCeVVyZ2VuY3koYTogVGFzaywgYjogVGFzayk6IG51bWJlciB7XG4gICAgICAgIC8vIEhpZ2hlciB1cmdlbmN5IHNob3VsZCBiZSBzb3J0ZWQgZWFybGllci5cbiAgICAgICAgcmV0dXJuIGIudXJnZW5jeSAtIGEudXJnZW5jeTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlTdGF0dXMoYTogVGFzaywgYjogVGFzayk6IC0xIHwgMCB8IDEge1xuICAgICAgICBpZiAoYS5zdGF0dXMgPCBiLnN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5zdGF0dXMgPiBiLnN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlQcmlvcml0eShhOiBUYXNrLCBiOiBUYXNrKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkubG9jYWxlQ29tcGFyZShiLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlTdGFydERhdGUoYTogVGFzaywgYjogVGFzayk6IC0xIHwgMCB8IDEge1xuICAgICAgICByZXR1cm4gU29ydC5jb21wYXJlQnlEYXRlKGEuc3RhcnREYXRlLCBiLnN0YXJ0RGF0ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29tcGFyZUJ5U2NoZWR1bGVkRGF0ZShhOiBUYXNrLCBiOiBUYXNrKTogLTEgfCAwIHwgMSB7XG4gICAgICAgIHJldHVybiBTb3J0LmNvbXBhcmVCeURhdGUoYS5zY2hlZHVsZWREYXRlLCBiLnNjaGVkdWxlZERhdGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNvbXBhcmVCeUR1ZURhdGUoYTogVGFzaywgYjogVGFzayk6IC0xIHwgMCB8IDEge1xuICAgICAgICByZXR1cm4gU29ydC5jb21wYXJlQnlEYXRlKGEuZHVlRGF0ZSwgYi5kdWVEYXRlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlEb25lRGF0ZShhOiBUYXNrLCBiOiBUYXNrKTogLTEgfCAwIHwgMSB7XG4gICAgICAgIHJldHVybiBTb3J0LmNvbXBhcmVCeURhdGUoYS5kb25lRGF0ZSwgYi5kb25lRGF0ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29tcGFyZUJ5VGFnKGE6IFRhc2ssIGI6IFRhc2spOiAtMSB8IDAgfCAxIHtcbiAgICAgICAgLy8gSWYgbm8gdGFncyB0aGVuIGFzc3VtZSB0aGV5IGFyZSBlcXVhbC5cbiAgICAgICAgaWYgKGEudGFncy5sZW5ndGggPT09IDAgJiYgYi50YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYS50YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYSBpcyBsZXNzIHRoYW4gYlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYi50YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYiBpcyBsZXNzIHRoYW4gYVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlzIHN0YXJ0IGF0IDAgYnV0IHRoZSB1c2VycyBzcGVjaWZ5IGEgdGFnIHN0YXJ0aW5nIGF0IDEuXG4gICAgICAgIGNvbnN0IHRhZ0luc3RhbmNlVG9Tb3J0QnkgPSBTb3J0LnRhZ1Byb3BlcnR5SW5zdGFuY2UgLSAxO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGEudGFncy5sZW5ndGggPCBTb3J0LnRhZ1Byb3BlcnR5SW5zdGFuY2UgJiZcbiAgICAgICAgICAgIGIudGFncy5sZW5ndGggPj0gU29ydC50YWdQcm9wZXJ0eUluc3RhbmNlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBiLnRhZ3MubGVuZ3RoIDwgU29ydC50YWdQcm9wZXJ0eUluc3RhbmNlICYmXG4gICAgICAgICAgICBhLnRhZ3MubGVuZ3RoID49IFNvcnQudGFnUHJvcGVydHlJbnN0YW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGEudGFncy5sZW5ndGggPCBTb3J0LnRhZ1Byb3BlcnR5SW5zdGFuY2UgJiZcbiAgICAgICAgICAgIGIudGFncy5sZW5ndGggPCBTb3J0LnRhZ1Byb3BlcnR5SW5zdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV0gPCBiLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV0pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV0gPiBiLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV0pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNvbXBhcmVCeURhdGUoXG4gICAgICAgIGE6IG1vbWVudC5Nb21lbnQgfCBudWxsLFxuICAgICAgICBiOiBtb21lbnQuTW9tZW50IHwgbnVsbCxcbiAgICApOiAtMSB8IDAgfCAxIHtcbiAgICAgICAgaWYgKGEgIT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYS5pc0FmdGVyKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEuaXNCZWZvcmUoYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlQYXRoKGE6IFRhc2ssIGI6IFRhc2spOiAtMSB8IDAgfCAxIHtcbiAgICAgICAgaWYgKGEucGF0aCA8IGIucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEucGF0aCA+IGIucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhlIGRlc2NyaXB0aW9uIGJ5IGhvdyBpdCBpcyByZW5kZXJlZCBpbiBtYXJrZG93bi5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHVzZSB0aGUgTWFya2Rvd25SZW5kZXJlciwgYnV0IHRyaWVzIHRvIG1hdGNoIHJlZ2V4ZXMgaW5zdGVhZFxuICAgICAqIGluIG9yZGVyIHRvIGJlIHNpbXBsZXIsIGZhc3RlciwgYW5kIG5vdCBhc3luYy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBjb21wYXJlQnlEZXNjcmlwdGlvbihhOiBUYXNrLCBiOiBUYXNrKSB7XG4gICAgICAgIHJldHVybiBTb3J0LmNsZWFuRGVzY3JpcHRpb24oYS5kZXNjcmlwdGlvbikubG9jYWxlQ29tcGFyZShcbiAgICAgICAgICAgIFNvcnQuY2xlYW5EZXNjcmlwdGlvbihiLmRlc2NyaXB0aW9uKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGAqYCwgYD1gLCBhbmQgYFtgIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBXaWxsIHJlbW92ZSB0aGVtIG9ubHkgaWYgdGhleSBhcmUgY2xvc2luZy5cbiAgICAgKiBQcm9wZXJseSByZWFkcyBsaW5rcyBbW2xpa2UgdGhpc3xvbmVdXSAobm90ZSBwaXBlKS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBjbGVhbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBnbG9iYWxGaWx0ZXIgPSBnZXRTZXR0aW5ncygpLmdsb2JhbEZpbHRlcjtcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKGdsb2JhbEZpbHRlciwgJycpLnRyaW0oKTtcblxuICAgICAgICBjb25zdCBzdGFydHNXaXRoTGlua1JlZ2V4ID0gL15cXFtcXFs/KFteXFxdXSopXFxdLztcbiAgICAgICAgY29uc3QgbGlua1JlZ2V4TWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChzdGFydHNXaXRoTGlua1JlZ2V4KTtcbiAgICAgICAgaWYgKGxpbmtSZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckxpbmtUZXh0ID0gbGlua1JlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICAvLyBGb3IgYSBsaW5rLCB3ZSBoYXZlIHRvIGNoZWNrIHdoZXRoZXIgaXQgaGFzIGFub3RoZXIgdmlzaWJsZSBuYW1lIHNldC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlIGBbW3RoaXMgaXMgdGhlIGxpbmt8YnV0IHRoaXMgaXMgYWN0dWFsbHkgc2hvd25dXWAuXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgaW5uZXJMaW5rVGV4dC5zdWJzdHJpbmcoaW5uZXJMaW5rVGV4dC5pbmRleE9mKCd8JykgKyAxKSArXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24ucmVwbGFjZShzdGFydHNXaXRoTGlua1JlZ2V4LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydHNXaXRoSXRhbGljT3JCb2xkUmVnZXggPSAvXlxcKlxcKj8oW14qXSopXFwqLztcbiAgICAgICAgY29uc3QgaXRhbGljQm9sZFJlZ2V4TWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChcbiAgICAgICAgICAgIHN0YXJ0c1dpdGhJdGFsaWNPckJvbGRSZWdleCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGl0YWxpY0JvbGRSZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckl0YWxpY0JvbGRUZXh0ID0gaXRhbGljQm9sZFJlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgaW5uZXJJdGFsaWNCb2xkVGV4dCArXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24ucmVwbGFjZShzdGFydHNXaXRoTGlua1JlZ2V4LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydHNXaXRoSGlnaGxpZ2h0UmVnZXggPSAvXj09PyhbXj1dKik9PS87XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodFJlZ2V4TWF0Y2ggPSBkZXNjcmlwdGlvbi5tYXRjaChzdGFydHNXaXRoSGlnaGxpZ2h0UmVnZXgpO1xuICAgICAgICBpZiAoaGlnaGxpZ2h0UmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXJIaWdobGlnaHRzVGV4dCA9IGhpZ2hsaWdodFJlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgaW5uZXJIaWdobGlnaHRzVGV4dCArXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24ucmVwbGFjZShzdGFydHNXaXRoSGlnaGxpZ2h0UmVnZXgsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgUlJ1bGUgfSBmcm9tICdycnVsZSc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9Tb3J0JztcblxuZXhwb3J0IGNsYXNzIFJlY3VycmVuY2Uge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcnJ1bGU6IFJSdWxlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFzZU9uVG9kYXk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSByZWFkb25seSBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWZlcmVuY2UgZGF0ZSBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBmdXR1cmUgb2NjdXJyZW5jZXMuXG4gICAgICpcbiAgICAgKiBGdXR1cmUgb2NjdXJyZW5jZXMgd2lsbCByZWN1ciBiYXNlZCBvbiB0aGUgcmVmZXJlbmNlIGRhdGUuXG4gICAgICogVGhlIHJlZmVyZW5jZSBkYXRlIGlzIHRoZSBkdWUgZGF0ZSwgaWYgaXQgaXMgZ2l2ZW4uXG4gICAgICogT3RoZXJ3aXNlIHRoZSBzY2hlZHVsZWQgZGF0ZSwgaWYgaXQgaXMgZ2l2ZW4uIEFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIFJlY3VycmVuY2Ugb2YgYWxsIGRhdGVzIHdpbGwgYmUga2VwdCByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIGRhdGUuXG4gICAgICogRm9yIGV4YW1wbGU6IGlmIHRoZSBkdWUgZGF0ZSBhbmQgdGhlIHN0YXJ0IGRhdGUgYXJlIGdpdmVuLCB0aGUgZHVlIGRhdGVcbiAgICAgKiBpcyB0aGUgcmVmZXJlbmNlIGRhdGUuIEZ1dHVyZSBvY2N1cnJlbmNlcyB3aWxsIGhhdmUgYSBzdGFydCBkYXRlIHdpdGggdGhlXG4gICAgICogc2FtZSByZWxhdGl2ZSBkaXN0YW5jZSB0byB0aGUgZHVlIGRhdGUgYXMgdGhlIG9yaWdpbmFsIHRhc2suIEZvciBleGFtcGxlXG4gICAgICogXCJzdGFydHMgb25lIHdlZWsgYmVmb3JlIGl0IGlzIGR1ZVwiLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVmZXJlbmNlRGF0ZTogTW9tZW50IHwgbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgcnJ1bGUsXG4gICAgICAgIGJhc2VPblRvZGF5LFxuICAgICAgICByZWZlcmVuY2VEYXRlLFxuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgfToge1xuICAgICAgICBycnVsZTogUlJ1bGU7XG4gICAgICAgIGJhc2VPblRvZGF5OiBib29sZWFuO1xuICAgICAgICByZWZlcmVuY2VEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSkge1xuICAgICAgICB0aGlzLnJydWxlID0gcnJ1bGU7XG4gICAgICAgIHRoaXMuYmFzZU9uVG9kYXkgPSBiYXNlT25Ub2RheTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEYXRlID0gcmVmZXJlbmNlRGF0ZTtcbiAgICAgICAgdGhpcy5zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkRGF0ZSA9IHNjaGVkdWxlZERhdGU7XG4gICAgICAgIHRoaXMuZHVlRGF0ZSA9IGR1ZURhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVGV4dCh7XG4gICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dCxcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICBkdWVEYXRlLFxuICAgIH06IHtcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGVUZXh0OiBzdHJpbmc7XG4gICAgICAgIHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICB9KTogUmVjdXJyZW5jZSB8IG51bGwge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWN1cnJlbmNlUnVsZVRleHQubWF0Y2goXG4gICAgICAgICAgICAgICAgL14oW2EtekEtWjAtOSwgIV0rPykoIHdoZW4gZG9uZSk/JC9pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzb2xhdGVkUnVsZVRleHQgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBiYXNlT25Ub2RheSA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBSUnVsZS5wYXJzZVRleHQoaXNvbGF0ZWRSdWxlVGV4dCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFBpY2sgdGhlIHJlZmVyZW5jZSBkYXRlIGZvciByZWN1cnJlbmNlIGJhc2VkIG9uIGltcG9ydGFuY2UuXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1pbmcgZHVlIGRhdGUgaGFzIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgIGxldCByZWZlcmVuY2VEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgbW9tZW50IG9iamVjdHMuXG4gICAgICAgICAgICAgICAgaWYgKGR1ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSA9IHdpbmRvdy5tb21lbnQoZHVlRGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlZHVsZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZURhdGUgPSB3aW5kb3cubW9tZW50KHNjaGVkdWxlZERhdGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZURhdGUgPSB3aW5kb3cubW9tZW50KHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlT25Ub2RheSAmJiByZWZlcmVuY2VEYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZHRzdGFydCA9IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1vbWVudChyZWZlcmVuY2VEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0YXJ0T2YoJ2RheScpXG4gICAgICAgICAgICAgICAgICAgICAgICAudXRjKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kdHN0YXJ0ID0gd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICAubW9tZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdGFydE9mKCdkYXknKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnV0Yyh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJydWxlID0gbmV3IFJSdWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdXJyZW5jZSh7XG4gICAgICAgICAgICAgICAgICAgIHJydWxlLFxuICAgICAgICAgICAgICAgICAgICBiYXNlT25Ub2RheSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ291bGQgbm90IHJlYWQgcmVjdXJyZW5jZSBydWxlLiBVc2VyIHBvc3NpYmx5IG5vdCBkb25lIHR5cGluZy5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1RleHQoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLnJydWxlLnRvVGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgdGV4dCArPSAnIHdoZW4gZG9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlcyBvZiB0aGUgbmV4dCBvY2N1cnJlbmNlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0KCk6IHtcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0gfCBudWxsIHtcbiAgICAgICAgbGV0IG5leHQ6IERhdGU7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5KSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV4dCBvY2N1cnJlbmNlIHNob3VsZCBoYXBwZW4gYmFzZWQgb2ZmIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICAgICAgICBjb25zdCB0b2RheSA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVCYXNlZE9uVG9kYXkgPSBuZXcgUlJ1bGUoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucnJ1bGUub3JpZ09wdGlvbnMsXG4gICAgICAgICAgICAgICAgZHRzdGFydDogdG9kYXkuc3RhcnRPZignZGF5JykudXRjKHRydWUpLnRvRGF0ZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXh0ID0gcnVsZUJhc2VkT25Ub2RheS5hZnRlcihcbiAgICAgICAgICAgICAgICB0b2RheS5lbmRPZignZGF5JykudXRjKHRydWUpLnRvRGF0ZSgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9jY3VycmVuY2Ugc2hvdWxkIGhhcHBlbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBkYXRlIGlmIHBvc3NpYmxlLiBPdGhlcndpc2UsIGJhc2UgaXQgb24gdG9kYXkgaWYgd2UgZG8gbm90IGhhdmUgYVxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGRhdGUuXG4gICAgICAgICAgICBjb25zdCBhZnRlciA9IHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBkYXRlIGNhbiBiZSBgbnVsbGAgdG8gbWVhbiBcInRvZGF5XCIuXG4gICAgICAgICAgICAgICAgLy8gTW9tZW50IG9ubHkgYWNjZXB0cyBgdW5kZWZpbmVkYCwgbm90IGBudWxsYC5cbiAgICAgICAgICAgICAgICAubW9tZW50KHRoaXMucmVmZXJlbmNlRGF0ZSA/PyB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgLmVuZE9mKCdkYXknKVxuICAgICAgICAgICAgICAgIC51dGModHJ1ZSk7XG5cbiAgICAgICAgICAgIG5leHQgPSB0aGlzLnJydWxlLmFmdGVyKGFmdGVyLnRvRGF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZS1hZGQgdGhlIHRpbWV6b25lIHRoYXQgUlJ1bGUgZGlzcmVnYXJkZWQ6XG4gICAgICAgICAgICBjb25zdCBsb2NhbFRpbWVab25lID0gd2luZG93Lm1vbWVudC51dGMobmV4dCkubG9jYWwodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0T2NjdXJyZW5jZSA9IGxvY2FsVGltZVpvbmUuc3RhcnRPZignZGF5Jyk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGRhdGUgYW5kXG4gICAgICAgICAgICAvLyBzdGFydC9zY2hlZHVsZWQvZHVlLlxuICAgICAgICAgICAgbGV0IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZHVlRGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgaWYgYSByZWZlcmVuY2UgZGF0ZSBpcyBnaXZlbi4gQSByZWZlcmVuY2UgZGF0ZSB3aWxsIGV4aXN0IGlmIGF0XG4gICAgICAgICAgICAvLyBsZWFzdCBvbmUgb2YgdGhlIG90aGVyIGRhdGVzIGlzIHNldC5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlLmRpZmYodGhpcy5yZWZlcmVuY2VEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uaW5nIHNvIHRoYXQgb3JpZ2luYWwgd29uJ3QgYmUgbWFuaXB1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQobmV4dE9jY3VycmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyBkYXlzIHRvIGhhbmRsZSBjcm9zcyBkYXlsaWdodC1zYXZpbmdzLXRpbWUgcmVjdXJyZW5jZXMuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjaGVkdWxlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVkRGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBzbyB0aGF0IG9yaWdpbmFsIHdvbid0IGJlIG1hbmlwdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gd2luZG93Lm1vbWVudChuZXh0T2NjdXJyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIGRheXMgdG8gaGFuZGxlIGNyb3NzIGRheWxpZ2h0LXNhdmluZ3MtdGltZSByZWN1cnJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR1ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHVlRGF0ZS5kaWZmKHRoaXMucmVmZXJlbmNlRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBzbyB0aGF0IG9yaWdpbmFsIHdvbid0IGJlIG1hbmlwdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlID0gd2luZG93Lm1vbWVudChuZXh0T2NjdXJyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIGRheXMgdG8gaGFuZGxlIGNyb3NzIGRheWxpZ2h0LXNhdmluZ3MtdGltZSByZWN1cnJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgZHVlRGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGlkZW50aWNhbFRvKG90aGVyOiBSZWN1cnJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5ICE9PSBvdGhlci5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBpZiAoU29ydC5jb21wYXJlQnlEYXRlKHRoaXMuc3RhcnREYXRlLCBvdGhlci5zdGFydERhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNvcnQuY29tcGFyZUJ5RGF0ZSh0aGlzLnNjaGVkdWxlZERhdGUsIG90aGVyLnNjaGVkdWxlZERhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNvcnQuY29tcGFyZUJ5RGF0ZSh0aGlzLmR1ZURhdGUsIG90aGVyLmR1ZURhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b1RleHQoKSA9PT0gb3RoZXIudG9UZXh0KCk7IC8vIHRoaXMgYWxzbyBjaGVja3MgYmFzZU9uVG9kYXlcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxuZXhwb3J0IGNsYXNzIFVyZ2VuY3kge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGR1ZUNvZWZmaWNpZW50ID0gMTIuMDtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBzY2hlZHVsZWRDb2VmZmljaWVudCA9IDUuMDtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBzdGFydGVkQ29lZmZpY2llbnQgPSAtMy4wO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHByaW9yaXR5Q29lZmZpY2llbnQgPSA2LjA7XG5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBtaWxsaVNlY29uZHNQZXJEYXkgPSAxMDAwICogNjAgKiA2MCAqIDI0O1xuXG4gICAgcHVibGljIHN0YXRpYyBjYWxjdWxhdGUodGFzazogVGFzayk6IG51bWJlciB7XG4gICAgICAgIGxldCB1cmdlbmN5ID0gMC4wO1xuXG4gICAgICAgIGlmICh0YXNrLmR1ZURhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1hcCBhIHJhbmdlIG9mIDIxIGRheXMgdG8gdGhlIHZhbHVlIDAuMiAtIDEuMFxuICAgICAgICAgICAgY29uc3QgZGF5c092ZXJkdWUgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoKS5kaWZmKHRhc2suZHVlRGF0ZSkgLyBVcmdlbmN5Lm1pbGxpU2Vjb25kc1BlckRheSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCBkdWVNdWx0aXBsaWVyOiBudW1iZXI7XG4gICAgICAgICAgICBpZiAoZGF5c092ZXJkdWUgPj0gNy4wKSB7XG4gICAgICAgICAgICAgICAgZHVlTXVsdGlwbGllciA9IDEuMDsgLy8gPCAxIHdrIGFnb1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXlzT3ZlcmR1ZSA+PSAtMTQuMCkge1xuICAgICAgICAgICAgICAgIC8vIER1ZSBiZXR3ZWVuIDcgZGF5cyAoKzcpIGFnbyBhbmQgaW4gMTQgZGF5cyAoLTE0KVxuICAgICAgICAgICAgICAgIGR1ZU11bHRpcGxpZXIgPSAoKGRheXNPdmVyZHVlICsgMTQuMCkgKiAwLjgpIC8gMjEuMCArIDAuMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVlTXVsdGlwbGllciA9IDAuMjsgLy8gPiAyIHdrc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmdlbmN5ICs9IGR1ZU11bHRpcGxpZXIgKiBVcmdlbmN5LmR1ZUNvZWZmaWNpZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2suc2NoZWR1bGVkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tb21lbnQoKS5pc1NhbWVPckFmdGVyKHRhc2suc2NoZWR1bGVkRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDEgKiBVcmdlbmN5LnNjaGVkdWxlZENvZWZmaWNpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2suc3RhcnREYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lm1vbWVudCgpLmlzQmVmb3JlKHRhc2suc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgIHVyZ2VuY3kgKz0gMSAqIFVyZ2VuY3kuc3RhcnRlZENvZWZmaWNpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0YXNrLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAvLyBIaWdoXG4gICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDEuMCAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIE1lZGl1bVxuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAwLjY1ICogVXJnZW5jeS5wcmlvcml0eUNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gTm9uZVxuICAgICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAwLjMyNSAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmdlbmN5O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGFza01vZGFsIH0gZnJvbSAnLi4vVGFza01vZGFsJztcbmltcG9ydCB7IFByaW9yaXR5LCBTdGF0dXMsIFRhc2sgfSBmcm9tICcuLi9UYXNrJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9yRWRpdCA9IChcbiAgICBjaGVja2luZzogYm9vbGVhbixcbiAgICBlZGl0b3I6IEVkaXRvcixcbiAgICB2aWV3OiBWaWV3LFxuICAgIGFwcDogQXBwLFxuKSA9PiB7XG4gICAgaWYgKGNoZWNraW5nKSB7XG4gICAgICAgIHJldHVybiB2aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3O1xuICAgIH1cblxuICAgIGlmICghKHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpKSB7XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gZHVlIHRvIGNoZWNrIGFib3ZlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9IHZpZXcuZmlsZT8ucGF0aDtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICBjb25zdCBsaW5lTnVtYmVyID0gY3Vyc29yUG9zaXRpb24ubGluZTtcbiAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG4gICAgY29uc3QgdGFzayA9IHRhc2tGcm9tTGluZSh7IGxpbmUsIHBhdGggfSk7XG5cbiAgICBjb25zdCBvblN1Ym1pdCA9ICh1cGRhdGVkVGFza3M6IFRhc2tbXSk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gdXBkYXRlZFRhc2tzXG4gICAgICAgICAgICAubWFwKCh0YXNrOiBUYXNrKSA9PiB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgc2VyaWFsaXplZCk7XG4gICAgfTtcblxuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUsIGFzIGN1cnNvci90YXNrIGNhbiBjaGFuZ2UuXG4gICAgY29uc3QgdGFza01vZGFsID0gbmV3IFRhc2tNb2RhbCh7XG4gICAgICAgIGFwcCxcbiAgICAgICAgdGFzayxcbiAgICAgICAgb25TdWJtaXQsXG4gICAgfSk7XG4gICAgdGFza01vZGFsLm9wZW4oKTtcbn07XG5cbmNvbnN0IHRhc2tGcm9tTGluZSA9ICh7IGxpbmUsIHBhdGggfTogeyBsaW5lOiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KTogVGFzayA9PiB7XG4gICAgY29uc3QgdGFzayA9IFRhc2suZnJvbUxpbmUoe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBzZWN0aW9uU3RhcnQ6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBzZWN0aW9uSW5kZXg6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG51bGwsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgIH0pO1xuXG4gICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIG5vdCBvbiBhIGxpbmUgb2YgYSB0YXNrLCB3ZSB0YWtlIHdoYXQgd2UgaGF2ZS5cbiAgICAvLyBUaGUgbm9uLXRhc2sgbGluZSBjYW4gc3RpbGwgYmUgYSBjaGVja2xpc3QsIGZvciBleGFtcGxlIGlmIGl0IGlzIGxhY2tpbmcgdGhlIGdsb2JhbCBmaWx0ZXIuXG4gICAgY29uc3Qgbm9uVGFza1JlZ2V4OiBSZWdFeHAgPSAvXihbXFxzXFx0Pl0qKVstKl0/ICooXFxbKC4pXFxdKT8gKiguKikvdTtcbiAgICBjb25zdCBub25UYXNrTWF0Y2ggPSBsaW5lLm1hdGNoKG5vblRhc2tSZWdleCk7XG4gICAgaWYgKG5vblRhc2tNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeXRoaW5nIGluIHRoZSByZWdleCBpcyBvcHRpb25hbC5cbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza3M6IENhbm5vdCBjcmVhdGUgdGFzayBvbiBsaW5lOicsIGxpbmUpO1xuICAgICAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICAgICAgc3RhdHVzOiBTdGF0dXMuVG9kbyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbmRlbnRhdGlvbjogJycsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXR1c0NoYXJhY3RlcjogJyAnLFxuICAgICAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5Lk5vbmUsXG4gICAgICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBudWxsLFxuICAgICAgICAgICAgZHVlRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGRvbmVEYXRlOiBudWxsLFxuICAgICAgICAgICAgcmVjdXJyZW5jZTogbnVsbCxcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGZvbGxvd2luZyBmaWVsZHMgdG8gZWRpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBzZWN0aW9uU3RhcnQ6IDAsXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXg6IDAsXG4gICAgICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG51bGwsXG4gICAgICAgICAgICBibG9ja0xpbms6ICcnLFxuICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGVudGF0aW9uOiBzdHJpbmcgPSBub25UYXNrTWF0Y2hbMV07XG4gICAgY29uc3Qgc3RhdHVzU3RyaW5nOiBzdHJpbmcgPSBub25UYXNrTWF0Y2hbM10gPz8gJyAnO1xuICAgIGNvbnN0IHN0YXR1cyA9IHN0YXR1c1N0cmluZyA9PT0gJyAnID8gU3RhdHVzLlRvZG8gOiBTdGF0dXMuRG9uZTtcbiAgICBsZXQgZGVzY3JpcHRpb246IHN0cmluZyA9IG5vblRhc2tNYXRjaFs0XTtcblxuICAgIGNvbnN0IGJsb2NrTGlua01hdGNoID0gbGluZS5tYXRjaChUYXNrLmJsb2NrTGlua1JlZ2V4KTtcbiAgICBjb25zdCBibG9ja0xpbmsgPSBibG9ja0xpbmtNYXRjaCAhPT0gbnVsbCA/IGJsb2NrTGlua01hdGNoWzBdIDogJyc7XG5cbiAgICBpZiAoYmxvY2tMaW5rICE9PSAnJykge1xuICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnJlcGxhY2UoVGFzay5ibG9ja0xpbmtSZWdleCwgJycpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICBvcmlnaW5hbFN0YXR1c0NoYXJhY3Rlcjogc3RhdHVzU3RyaW5nLFxuICAgICAgICBibG9ja0xpbmssXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5Ob25lLFxuICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgIGRvbmVEYXRlOiBudWxsLFxuICAgICAgICByZWN1cnJlbmNlOiBudWxsLFxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBmb2xsb3dpbmcgZmllbGRzIHRvIGVkaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBzZWN0aW9uU3RhcnQ6IDAsXG4gICAgICAgIHNlY3Rpb25JbmRleDogMCxcbiAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBudWxsLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICB9KTtcbn07XG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBFZGl0VGFzayBmcm9tICcuL3VpL0VkaXRUYXNrLnN2ZWx0ZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG5leHBvcnQgY2xhc3MgVGFza01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHB1YmxpYyByZWFkb25seSB0YXNrOiBUYXNrO1xuICAgIHB1YmxpYyByZWFkb25seSBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBhcHAsXG4gICAgICAgIHRhc2ssXG4gICAgICAgIG9uU3VibWl0LFxuICAgIH06IHtcbiAgICAgICAgYXBwOiBBcHA7XG4gICAgICAgIHRhc2s6IFRhc2s7XG4gICAgICAgIG9uU3VibWl0OiAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHZvaWQ7XG4gICAgfSkge1xuICAgICAgICBzdXBlcihhcHApO1xuXG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHtcbiAgICAgICAgICAgIG9uU3VibWl0KHVwZGF0ZWRUYXNrcyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIG9uT3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aXRsZUVsLnNldFRleHQoJ0NyZWF0ZSBvciBlZGl0IFRhc2snKTtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIG5ldyBFZGl0VGFzayh7XG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRlbnRFbCxcbiAgICAgICAgICAgIHByb3BzOiB7IHRhc2s6IHRoaXMudGFzaywgb25TdWJtaXQ6IHRoaXMub25TdWJtaXQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG9uQ2xvc2UoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG4iLCAiZnVuY3Rpb24gbm9vcCgpIHsgfVxuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgdGFyW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiB0YXI7XG59XG5mdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuICAgIGlmIChpc19oeWRyYXRpbmcpIHtcbiAgICAgICAgaW5pdF9oeWRyYXRlKHRhcmdldCk7XG4gICAgICAgIGlmICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCkgfHwgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudEVsZW1lbnQgIT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG4gICAgICAgIHdoaWxlICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG4gICAgICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zW2ldKVxuICAgICAgICAgICAgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5mdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzX3Byb3Aob2JqLCBrKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0W2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHRleHQoZGF0YSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cbmZ1bmN0aW9uIHNwYWNlKCkge1xuICAgIHJldHVybiB0ZXh0KCcgJyk7XG59XG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGV4dCgnJyk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzTm9kZSwgY3JlYXRlTm9kZSwgZG9udFVwZGF0ZUxhc3RJbmRleCA9IGZhbHNlKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSAoKCkgPT4ge1xuICAgICAgICAvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZSgpO1xuICAgIH0pKCk7XG4gICAgcmVzdWx0Tm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUuZm9yRWFjaCh2ID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKSk7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhU3RyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB0ZXh0KGRhdGEpLCB0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuICAgICk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuICAgIC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuICAgIGNvbnN0IHN0YXJ0X2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcbiAgICBjb25zdCBlbmRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCk7XG4gICAgaWYgKHN0YXJ0X2luZGV4ID09PSBlbmRfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKHVuZGVmaW5lZCwgaXNfc3ZnKTtcbiAgICB9XG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG4gICAgY29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oY2xhaW1lZF9ub2RlcywgaXNfc3ZnKTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCAhPT0gZGF0YSlcbiAgICAgICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuICAgIGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpIHx8IHNlbGVjdC5vcHRpb25zWzBdO1xuICAgIHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5mdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG4gICAgcmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCBvcHRpb24gPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5sZXQgY3Jvc3NvcmlnaW47XG5mdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcbiAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjcm9zc29yaWdpbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjcm9zc29yaWdpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuZnVuY3Rpb24gYWRkX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGlzX3N2ZztcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX3N2ZylcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBzdmdfZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBmb3IgbXVsdGlwbGUgZG9jdW1lbnRzIGJlY2F1c2UgYSBTdmVsdGUgYXBwbGljYXRpb24gY291bGQgYWxzbyBjb250YWluIGlmcmFtZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzM2MjRcbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuICAgIGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcbiAgICBtYW5hZ2VkX3N0eWxlcy5zZXQoZG9jLCBpbmZvKTtcbiAgICByZXR1cm4gaW5mbztcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuICAgIGlmICghcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiAnJ30ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHN0eWxlc2hlZXQgfSA9IGluZm87XG4gICAgICAgICAgICBsZXQgaSA9IHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gICAgICAgICAgICBpbmZvLnJ1bGVzID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5jbGVhcigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmIGZyb20ucmlnaHQgPT09IHRvLnJpZ2h0ICYmIGZyb20udG9wID09PSB0by50b3AgJiYgZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cbiAgICBzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzpcbiAgICBlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sIHRpY2sgPSBub29wLCBjc3MgfSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbmFtZTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBuYW1lKTtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQgJiYgbm93ID49IGVuZCkge1xuICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgICBjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHN0YXJ0KCk7XG4gICAgdGljaygwLCAxKTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbmZ1bmN0aW9uIGZpeF9wb3NpdGlvbihub2RlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuICAgIH1cbn1cblxubGV0IGN1cnJlbnRfY29tcG9uZW50O1xuZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5jb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5jb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG4gICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IChwcm9ncmFtLmIgLSB0KTtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyBcdTIwMTQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyBcdTIwMTQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG4gICAgY29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbmNvbnN0IHZvaWRfZWxlbWVudF9uYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC87XG5mdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcbiAgICByZXR1cm4gdm9pZF9lbGVtZW50X25hbWVzLnRlc3QobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBhdHRyc190b19hZGQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uYXJncyk7XG4gICAgaWYgKGF0dHJzX3RvX2FkZCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5jbGFzc2VzO1xuICAgICAgICBjb25zdCBzdHlsZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLnN0eWxlcztcbiAgICAgICAgaWYgKGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuc3R5bGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlc190b19hZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcobWVyZ2Vfc3NyX3N0eWxlcyhhdHRyaWJ1dGVzLnN0eWxlLCBzdHlsZXNfdG9fYWRkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICBlbHNlIGlmIChib29sZWFuX2F0dHJpYnV0ZXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHt2YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gbWVyZ2Vfc3NyX3N0eWxlcyhzdHlsZV9hdHRyaWJ1dGUsIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgIGNvbnN0IHN0eWxlX29iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgaW5kaXZpZHVhbF9zdHlsZSBvZiBzdHlsZV9hdHRyaWJ1dGUuc3BsaXQoJzsnKSkge1xuICAgICAgICBjb25zdCBjb2xvbl9pbmRleCA9IGluZGl2aWR1YWxfc3R5bGUuaW5kZXhPZignOicpO1xuICAgICAgICBjb25zdCBuYW1lID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZSgwLCBjb2xvbl9pbmRleCkudHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoY29sb25faW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlX2RpcmVjdGl2ZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZV9vYmplY3RbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlX29iamVjdDtcbn1cbmNvbnN0IEFUVFJfUkVHRVggPSAvWyZcIl0vZztcbmNvbnN0IENPTlRFTlRfUkVHRVggPSAvWyY8XS9nO1xuLyoqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUgYW5kIGhhcyBiZWVuIG9wdGltaXplZFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzU3MDFcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBpc19hdHRyID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBpc19hdHRyID8gQVRUUl9SRUdFWCA6IENPTlRFTlRfUkVHRVg7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIGxldCBlc2NhcGVkID0gJyc7XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBpID0gcGF0dGVybi5sYXN0SW5kZXggLSAxO1xuICAgICAgICBjb25zdCBjaCA9IHN0cltpXTtcbiAgICAgICAgZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogKGNoID09PSAnXCInID8gJyZxdW90OycgOiAnJmx0OycpKTtcbiAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlZCArIHN0ci5zdWJzdHJpbmcobGFzdCk7XG59XG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHZhbHVlKSB7XG4gICAgLy8ga2VlcCBib29sZWFucywgbnVsbCwgYW5kIHVuZGVmaW5lZCBmb3IgdGhlIHNha2Ugb2YgYHNwcmVhZGBcbiAgICBjb25zdCBzaG91bGRfZXNjYXBlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNob3VsZF9lc2NhcGUgPyBlc2NhcGUodmFsdWUsIHRydWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZWFjaChpdGVtcywgZm4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG4gICAgJCRyZW5kZXI6ICgpID0+ICcnXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJCRyZW5kZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JylcbiAgICAgICAgICAgIG5hbWUgKz0gJyB0aGlzPXsuLi59JztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlc2ApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gKGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUpID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcbiAgICByZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5mdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuZnVuY3Rpb24gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuICAgICAgICAuZmlsdGVyKGtleSA9PiBzdHlsZV9vYmplY3Rba2V5XSlcbiAgICAgICAgLm1hcChrZXkgPT4gYCR7a2V5fTogJHtzdHlsZV9vYmplY3Rba2V5XX07YClcbiAgICAgICAgLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuICAgIHJldHVybiBzdHlsZXMgPyBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjQ5LjAnIH0sIGRldGFpbCksIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgY29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuICAgIGVsc2VcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcbiAgICBpZiAodGFnICYmICFpc19zdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIEh0bWxUYWdIeWRyYXRpb24sIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVDb21wb25lbnRUeXBlZCwgU3ZlbHRlRWxlbWVudCwgYWN0aW9uX2Rlc3Ryb3llciwgYWRkX2F0dHJpYnV0ZSwgYWRkX2NsYXNzZXMsIGFkZF9mbHVzaF9jYWxsYmFjaywgYWRkX2xvY2F0aW9uLCBhZGRfcmVuZGVyX2NhbGxiYWNrLCBhZGRfcmVzaXplX2xpc3RlbmVyLCBhZGRfc3R5bGVzLCBhZGRfdHJhbnNmb3JtLCBhZnRlclVwZGF0ZSwgYXBwZW5kLCBhcHBlbmRfZGV2LCBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldCwgYXBwZW5kX2h5ZHJhdGlvbiwgYXBwZW5kX2h5ZHJhdGlvbl9kZXYsIGFwcGVuZF9zdHlsZXMsIGFzc2lnbiwgYXR0ciwgYXR0cl9kZXYsIGF0dHJpYnV0ZV90b19vYmplY3QsIGJlZm9yZVVwZGF0ZSwgYmluZCwgYmluZGluZ19jYWxsYmFja3MsIGJsYW5rX29iamVjdCwgYnViYmxlLCBjaGVja19vdXRyb3MsIGNoaWxkcmVuLCBjbGFpbV9jb21wb25lbnQsIGNsYWltX2VsZW1lbnQsIGNsYWltX2h0bWxfdGFnLCBjbGFpbV9zcGFjZSwgY2xhaW1fc3ZnX2VsZW1lbnQsIGNsYWltX3RleHQsIGNsZWFyX2xvb3BzLCBjb21wb25lbnRfc3Vic2NyaWJlLCBjb21wdXRlX3Jlc3RfcHJvcHMsIGNvbXB1dGVfc2xvdHMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZW5kX2h5ZHJhdGluZywgZXNjYXBlLCBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlLCBlc2NhcGVfb2JqZWN0LCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGdldEFsbENvbnRleHRzLCBnZXRDb250ZXh0LCBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9yb290X2Zvcl9zdHlsZSwgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBpZGVudGl0eSwgaW5pdCwgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnNlcnRfaHlkcmF0aW9uLCBpbnNlcnRfaHlkcmF0aW9uX2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBpc192b2lkLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1lcmdlX3Nzcl9zdHlsZXMsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfZGF0YSwgc2V0X2RhdGFfZGV2LCBzZXRfaW5wdXRfdHlwZSwgc2V0X2lucHV0X3ZhbHVlLCBzZXRfbm93LCBzZXRfcmFmLCBzZXRfc3RvcmVfdmFsdWUsIHNldF9zdHlsZSwgc2V0X3N2Z19hdHRyaWJ1dGVzLCBzcGFjZSwgc3ByZWFkLCBzcmNfdXJsX2VxdWFsLCBzdGFydF9oeWRyYXRpbmcsIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHRydXN0ZWQsIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2gsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3RfYmFzZSwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCwgeGxpbmtfYXR0ciB9O1xuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0ICogYXMgY2hyb25vIGZyb20gJ2Nocm9uby1ub2RlJztcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vUmVjdXJyZW5jZSc7XG4gICAgaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi9jb25maWcvU2V0dGluZ3MnO1xuICAgIGltcG9ydCB7IFByaW9yaXR5LCBTdGF0dXMsIFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbiAgICBpbXBvcnQge1xuICAgICAgICBwcmlvcml0eVN5bWJvbHMsXG4gICAgICAgIHJlY3VycmVuY2VTeW1ib2wsXG4gICAgICAgIHN0YXJ0RGF0ZVN5bWJvbCxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZVN5bWJvbCxcbiAgICAgICAgZHVlRGF0ZVN5bWJvbCxcbiAgICB9IGZyb20gJy4uL1Rhc2snO1xuICAgIGltcG9ydCB7IGRvQXV0b2NvbXBsZXRlIH0gZnJvbSAnLi4vRGF0ZUFiYnJldmlhdGlvbnMnO1xuXG4gICAgZXhwb3J0IGxldCB0YXNrOiBUYXNrO1xuICAgIGV4cG9ydCBsZXQgb25TdWJtaXQ6ICh1cGRhdGVkVGFza3M6IFRhc2tbXSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG5cbiAgICBsZXQgZGVzY3JpcHRpb25JbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICBsZXQgZWRpdGFibGVUYXNrOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICAgIHN0YXR1czogU3RhdHVzO1xuICAgICAgICBwcmlvcml0eTogJ25vbmUnIHwgJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6IHN0cmluZztcbiAgICAgICAgc3RhcnREYXRlOiBzdHJpbmc7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IHN0cmluZztcbiAgICAgICAgZHVlRGF0ZTogc3RyaW5nO1xuICAgICAgICBkb25lRGF0ZTogc3RyaW5nO1xuICAgIH0gPSB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgc3RhdHVzOiBTdGF0dXMuVG9kbyxcbiAgICAgICAgcHJpb3JpdHk6ICdub25lJyxcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6ICcnLFxuICAgICAgICBzdGFydERhdGU6ICcnLFxuICAgICAgICBzY2hlZHVsZWREYXRlOiAnJyxcbiAgICAgICAgZHVlRGF0ZTogJycsXG4gICAgICAgIGRvbmVEYXRlOiAnJyxcbiAgICB9O1xuXG4gICAgbGV0IHBhcnNlZFN0YXJ0RGF0ZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IHBhcnNlZFNjaGVkdWxlZERhdGU6IHN0cmluZyA9ICcnO1xuICAgIGxldCBwYXJzZWREdWVEYXRlOiBzdHJpbmcgPSAnJztcbiAgICBsZXQgcGFyc2VkUmVjdXJyZW5jZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IHBhcnNlZERvbmU6IHN0cmluZyA9ICcnO1xuICAgIGxldCBhZGRHbG9iYWxGaWx0ZXJPblNhdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8vICd3ZWVrZW5kJyBhYmJyZXZpYXRpb24gb21taXR0ZWQgZHVlIHRvIGxhY2sgb2Ygc3BhY2UuXG4gICAgbGV0IGRhdGVQbGFjZWhvbGRlciA9XG4gICAgICAgIFwiVHJ5ICdNb25kYXknIG9yICd0b21vcnJvdycsIG9yIFt0ZHx0bXx5ZHx0d3xud3x3ZV0gdGhlbiBzcGFjZS5cIjtcblxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZShcbiAgICAgICAgdHlwZTogJ3N0YXJ0JyB8ICdzY2hlZHVsZWQnIHwgJ2R1ZScgfCAnZG9uZScsXG4gICAgICAgIGRhdGU6IHN0cmluZyxcbiAgICAgICAgZm9yd2FyZERhdGU6IERhdGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxpPm5vICR7dHlwZX0gZGF0ZTwvaT5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IGNocm9uby5wYXJzZURhdGUoZGF0ZSwgZm9yd2FyZERhdGUsIHtcbiAgICAgICAgICAgIGZvcndhcmREYXRlOiBmb3J3YXJkRGF0ZSAhPSB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lm1vbWVudChwYXJzZWQpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPGk+aW52YWxpZCAke3R5cGV9IGRhdGU8L2k+YDtcbiAgICB9XG5cbiAgICAkOiB7XG4gICAgICAgIGVkaXRhYmxlVGFzay5zdGFydERhdGUgPSBkb0F1dG9jb21wbGV0ZShlZGl0YWJsZVRhc2suc3RhcnREYXRlKTtcbiAgICAgICAgcGFyc2VkU3RhcnREYXRlID0gcGFyc2VEYXRlKFxuICAgICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5zdGFydERhdGUsXG4gICAgICAgICAgICBuZXcgRGF0ZSgpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgICQ6IHtcbiAgICAgICAgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUgPSBkb0F1dG9jb21wbGV0ZShlZGl0YWJsZVRhc2suc2NoZWR1bGVkRGF0ZSk7XG4gICAgICAgIHBhcnNlZFNjaGVkdWxlZERhdGUgPSBwYXJzZURhdGUoXG4gICAgICAgICAgICAnc2NoZWR1bGVkJyxcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgbmV3IERhdGUoKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAkOiB7XG4gICAgICAgIGVkaXRhYmxlVGFzay5kdWVEYXRlID0gZG9BdXRvY29tcGxldGUoZWRpdGFibGVUYXNrLmR1ZURhdGUpO1xuICAgICAgICBwYXJzZWREdWVEYXRlID0gcGFyc2VEYXRlKCdkdWUnLCBlZGl0YWJsZVRhc2suZHVlRGF0ZSwgbmV3IERhdGUoKSk7XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBpZiAoIWVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSkge1xuICAgICAgICAgICAgcGFyc2VkUmVjdXJyZW5jZSA9ICc8aT5ub3QgcmVjdXJyaW5nPC8+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFJlY3VycmVuY2UgPVxuICAgICAgICAgICAgICAgIFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IGVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBmb3IgcmVwcmVzZW50YXRpb24gaW4gdGhlIG1vZGFsLCBubyBkYXRlcyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pPy50b1RleHQoKSA/PyAnPGk+aW52YWxpZCByZWN1cnJlbmNlIHJ1bGU8L2k+JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQ6IHtcbiAgICAgICAgcGFyc2VkRG9uZSA9IHBhcnNlRGF0ZSgnZG9uZScsIGVkaXRhYmxlVGFzay5kb25lRGF0ZSk7XG4gICAgfVxuXG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBnbG9iYWxGaWx0ZXIgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGFzay5nZXREZXNjcmlwdGlvbldpdGhvdXRHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgLy8gSWYgd2UncmUgZGlzcGxheWluZyB0byB0aGUgdXNlciB0aGUgZGVzY3JpcHRpb24gd2l0aG91dCB0aGUgZ2xvYmFsIGZpbHRlciAoaS5lLiBpdCB3YXMgcmVtb3ZlZCBpbiB0aGUgbWV0aG9kXG4gICAgICAgIC8vIGFib3ZlKSwgb3IgaWYgdGhlIGRlc2NyaXB0aW9uIGRpZCBub3QgaW5jbHVkZSBhIGdsb2JhbCBmaWx0ZXIgaW4gdGhlIGZpcnN0IHBsYWNlLCB3ZSdsbCBhZGQgdGhlIGdsb2JhbCBmaWx0ZXJcbiAgICAgICAgLy8gd2hlbiBzYXZpbmcgdGhlIHRhc2suXG4gICAgICAgIC8vIEFub3RoZXIgc3BlY2lhbCBjYXNlIGlzIHdoZW4gdGhlIGdsb2JhbCBmaWx0ZXIgaXMgZW1wdHk6IGluIHRoaXMgY2FzZSB0aGVyZSdzIGFuIFwiZW1wdHlcIiBtYXRjaCBpbiB0aGUgYGluZGV4T2ZgXG4gICAgICAgIC8vIChpdCByZXR1cm5zIDApLCBhbmQgdGh1cyB3ZSAqZG9uJ3QqIHNldCBhZGRHbG9iYWxGaWx0ZXJPblNhdmUuXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPSB0YXNrLmRlc2NyaXB0aW9uIHx8IGRlc2NyaXB0aW9uLmluZGV4T2YoZ2xvYmFsRmlsdGVyKSA9PSAtMSlcbiAgICAgICAgICAgIGFkZEdsb2JhbEZpbHRlck9uU2F2ZSA9IHRydWU7XG4gICAgICAgIGxldCBwcmlvcml0eTogJ25vbmUnIHwgJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyA9ICdub25lJztcbiAgICAgICAgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5Lkxvdykge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnbG93JztcbiAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5NZWRpdW0pIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gJ21lZGl1bSc7XG4gICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuSGlnaCkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnaGlnaCc7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0YWJsZVRhc2sgPSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHN0YXR1czogdGFzay5zdGF0dXMsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlOiB0YXNrLnJlY3VycmVuY2UgPyB0YXNrLnJlY3VycmVuY2UudG9UZXh0KCkgOiAnJyxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogdGFzay5zdGFydERhdGVcbiAgICAgICAgICAgICAgICA/IHRhc2suc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IHRhc2suc2NoZWR1bGVkRGF0ZVxuICAgICAgICAgICAgICAgID8gdGFzay5zY2hlZHVsZWREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGR1ZURhdGU6IHRhc2suZHVlRGF0ZSA/IHRhc2suZHVlRGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSA6ICcnLFxuICAgICAgICAgICAgZG9uZURhdGU6IHRhc2suZG9uZURhdGUgPyB0YXNrLmRvbmVEYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpIDogJycsXG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbnB1dC5mb2N1cygpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBfb25TdWJtaXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBlZGl0YWJsZVRhc2suZGVzY3JpcHRpb24udHJpbSgpO1xuICAgICAgICBpZiAoYWRkR2xvYmFsRmlsdGVyT25TYXZlKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGdsb2JhbEZpbHRlciArICcgJyArIGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0RGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBwYXJzZWRTdGFydERhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIG5ldyBEYXRlKCksXG4gICAgICAgICAgICB7IGZvcndhcmREYXRlOiB0cnVlIH0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJzZWRTdGFydERhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHdpbmRvdy5tb21lbnQocGFyc2VkU3RhcnREYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNjaGVkdWxlZERhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKFxuICAgICAgICAgICAgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgeyBmb3J3YXJkRGF0ZTogdHJ1ZSB9LFxuICAgICAgICApO1xuICAgICAgICBpZiAocGFyc2VkU2NoZWR1bGVkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IHdpbmRvdy5tb21lbnQocGFyc2VkU2NoZWR1bGVkRGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHVlRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBwYXJzZWREdWVEYXRlID0gY2hyb25vLnBhcnNlRGF0ZShcbiAgICAgICAgICAgIGVkaXRhYmxlVGFzay5kdWVEYXRlLFxuICAgICAgICAgICAgbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHsgZm9yd2FyZERhdGU6IHRydWUgfSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBhcnNlZER1ZURhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGR1ZURhdGUgPSB3aW5kb3cubW9tZW50KHBhcnNlZER1ZURhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSkge1xuICAgICAgICAgICAgcmVjdXJyZW5jZSA9IFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWRQcmlvcml0eTogUHJpb3JpdHk7XG4gICAgICAgIHN3aXRjaCAoZWRpdGFibGVUYXNrLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgICAgICAgIHBhcnNlZFByaW9yaXR5ID0gUHJpb3JpdHkuTG93O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgICAgICAgIHBhcnNlZFByaW9yaXR5ID0gUHJpb3JpdHkuSGlnaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5Ob25lO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFRhc2sgPSBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50YXNrLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBzdGF0dXM6IGVkaXRhYmxlVGFzay5zdGF0dXMsXG4gICAgICAgICAgICBwcmlvcml0eTogcGFyc2VkUHJpb3JpdHksXG4gICAgICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgIGR1ZURhdGUsXG4gICAgICAgICAgICBkb25lRGF0ZTogd2luZG93XG4gICAgICAgICAgICAgICAgLm1vbWVudChlZGl0YWJsZVRhc2suZG9uZURhdGUsICdZWVlZLU1NLUREJylcbiAgICAgICAgICAgICAgICAuaXNWYWxpZCgpXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cubW9tZW50KGVkaXRhYmxlVGFzay5kb25lRGF0ZSwgJ1lZWVktTU0tREQnKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb25TdWJtaXQoW3VwZGF0ZWRUYXNrXSk7XG4gICAgfTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGFza3MtbW9kYWxcIj5cbiAgICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9e19vblN1Ym1pdH0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1zZWN0aW9uXCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZGVzY3JpcHRpb25cIj5EZXNjcmlwdGlvbjwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtlZGl0YWJsZVRhc2suZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgYmluZDp0aGlzPXtkZXNjcmlwdGlvbklucHV0fVxuICAgICAgICAgICAgICAgIGlkPVwiZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhc2tzLW1vZGFsLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRha2Ugb3V0IHRoZSB0cmFzaFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1zZWN0aW9uXCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwicHJpb3JpdHlcIj5Qcmlvcml0eTwvbGFiZWw+XG4gICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVxuICAgICAgICAgICAgICAgIGlkPVwicHJpb3JpdHlcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZHJvcGRvd25cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub25lXCI+Tm9uZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJoaWdoXCI+e3ByaW9yaXR5U3ltYm9scy5IaWdofSBIaWdoPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1lZGl1bVwiPntwcmlvcml0eVN5bWJvbHMuTWVkaXVtfSBNZWRpdW08L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibG93XCI+e3ByaW9yaXR5U3ltYm9scy5Mb3d9IExvdzwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZWN1cnJlbmNlXCI+UmVjdXJyZW5jZTwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtlZGl0YWJsZVRhc2sucmVjdXJyZW5jZVJ1bGV9XG4gICAgICAgICAgICAgICAgaWQ9XCJkZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHJ5ICdldmVyeSAyIHdlZWtzIG9uIFRodXJzZGF5Jy5cIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjb2RlPntyZWN1cnJlbmNlU3ltYm9sfSB7QGh0bWwgcGFyc2VkUmVjdXJyZW5jZX08L2NvZGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1kYXRlXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImR1ZVwiPkR1ZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2VkaXRhYmxlVGFzay5kdWVEYXRlfVxuICAgICAgICAgICAgICAgICAgICBpZD1cImR1ZVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2RhdGVQbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxjb2RlPntkdWVEYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkRHVlRGF0ZX08L2NvZGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1kYXRlXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInNjaGVkdWxlZFwiPlNjaGVkdWxlZDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2VkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlfVxuICAgICAgICAgICAgICAgICAgICBpZD1cInNjaGVkdWxlZFwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2RhdGVQbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxjb2RlPntzY2hlZHVsZWREYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkU2NoZWR1bGVkRGF0ZX08L2NvZGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1kYXRlXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInN0YXJ0XCI+U3RhcnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtlZGl0YWJsZVRhc2suc3RhcnREYXRlfVxuICAgICAgICAgICAgICAgICAgICBpZD1cInN0YXJ0XCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17ZGF0ZVBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPGNvZGU+e3N0YXJ0RGF0ZVN5bWJvbH0ge0BodG1sIHBhcnNlZFN0YXJ0RGF0ZX08L2NvZGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFza3MtbW9kYWwtc2VjdGlvblwiPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICBTdGF0dXM6XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGFzay1saXN0LWl0ZW0tY2hlY2tib3ggdGFza3MtbW9kYWwtY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtlZGl0YWJsZVRhc2suc3RhdHVzID09PSBTdGF0dXMuRG9uZX1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxjb2RlPntlZGl0YWJsZVRhc2suc3RhdHVzfTwvY29kZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICBEb25lIG9uOlxuICAgICAgICAgICAgICAgIDxjb2RlPntAaHRtbCBwYXJzZWREb25lfTwvY29kZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1zZWN0aW9uXCIgLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwibW9kLWN0YVwiPkFwcGx5PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuIiwgIi8vIEFiYnJldmlhdGlvbnMgZm9yIGVudGVyaW5nIGRhdGVzIHdpdGggY2hyb25vXG4vLyBNQUlOVEVOQU5DRSBOT1RFOlxuLy8gICAgICBJZiBhZGRpbmcgbW9yZSBhYmJyZXZpYXRpb25zLCBwbGVhc2UgcmV2aWV3IGRhdGVQbGFjZWhvbGRlciBpbiBzcmMvdWkvRWRpdFRhc2suc3ZlbHRlXG5jb25zdCBhYmJyZXZpYXRpb25zID0ge1xuICAgIHRkOiAndG9kYXknLFxuICAgIHRtOiAndG9tb3Jyb3cnLFxuICAgIHlkOiAneWVzdGVyZGF5JyxcbiAgICB0dzogJ3RoaXMgd2VlaycsXG4gICAgbnc6ICduZXh0IHdlZWsnLFxuICAgIHdlZWtlbmQ6ICdzYXQnLFxuICAgIHdlOiAnc2F0Jyxcbn07XG5cbi8qKlxuICogRXhwYW5kIGFueSByZWNvZ25pc2VkIGFiYnJldmlhdGlvbnMgZm9yIGRhdGVzLlxuICpcbiAqIEltcG9ydGFudDogdGhlIGFiYnJldmlhdGlvbiBpcyBvbmx5IGV4cGFuZGVkIGlmIGl0IGlzIGZvb2xvd2VkIGJ5IGEgc3BhY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsICd0ZCAnIGlzIGV4cGFuZGVkIHRvICd0b2RheSdcbiAqIEBwYXJhbSBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb0F1dG9jb21wbGV0ZShkYXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhhYmJyZXZpYXRpb25zKSkge1xuICAgICAgICBkYXRlID0gZGF0ZS5yZXBsYWNlKFJlZ0V4cChgXFxcXGIke2tleX1cXFxcc2AsICdpJyksIHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuIiwgImltcG9ydCB7IEVkaXRvciwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVEb25lID0gKGNoZWNraW5nOiBib29sZWFuLCBlZGl0b3I6IEVkaXRvciwgdmlldzogVmlldykgPT4ge1xuICAgIGlmIChjaGVja2luZykge1xuICAgICAgICBpZiAoISh2aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIG1hcmtkb3duIHZpZXcsIHRoZSBjb21tYW5kIHNob3VsZG4ndCBiZSBzaG93bi5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBjb21tYW5kIHNob3VsZCBhbHdheXMgdHJpZ2dlciBpbiBhIG1hcmtkb3duIHZpZXc6XG4gICAgICAgIC8vIC0gQ29udmVydCBsaW5lcyB0byBsaXN0IGl0ZW1zLlxuICAgICAgICAvLyAtIENvbnZlcnQgbGlzdCBpdGVtcyB0byB0YXNrcy5cbiAgICAgICAgLy8gLSBUb2dnbGUgdGFza3MnIHN0YXR1cy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCEodmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykpIHtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbiBkdWUgdG8gY2hlY2sgYWJvdmUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBhcmUgY2VydGFpbiB3ZSBhcmUgaW4gdGhlIGVkaXRvciBkdWUgdG8gdGhlIGNoZWNrIGFib3ZlLlxuICAgIGNvbnN0IHBhdGggPSB2aWV3LmZpbGU/LnBhdGg7XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgY29uc3QgbGluZU51bWJlciA9IGN1cnNvclBvc2l0aW9uLmxpbmU7XG4gICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXG4gICAgY29uc3QgdG9nZ2xlZExpbmUgPSB0b2dnbGVMaW5lKHsgbGluZSwgcGF0aCB9KTtcbiAgICBlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCB0b2dnbGVkTGluZSk7XG5cbiAgICAvLyBUaGUgY3Vyc29yIGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAvLyBJZiB0aGVyZSBpcyB0ZXh0IG9uIHRoZSBsaW5lLCBwdXQgdGhlIGN1cnNvciBiYWNrIHdoZXJlIGl0IHdhcyBvbiB0aGUgbGluZS5cbiAgICBpZiAoL1teIFtcXF0qLV0vLnRlc3QodG9nZ2xlZExpbmUpKSB7XG4gICAgICAgIGVkaXRvci5zZXRDdXJzb3Ioe1xuICAgICAgICAgICAgbGluZTogY3Vyc29yUG9zaXRpb24ubGluZSxcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gbW92ZSB0aGUgY3Vyc29yIGJ5IHRoZSBkaXN0YW5jZSB3ZSBhZGRlZCB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgY2g6IGN1cnNvclBvc2l0aW9uLmNoICsgdG9nZ2xlZExpbmUubGVuZ3RoIC0gbGluZS5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IHRvZ2dsZUxpbmUgPSAoeyBsaW5lLCBwYXRoIH06IHsgbGluZTogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSk6IHN0cmluZyA9PiB7XG4gICAgbGV0IHRvZ2dsZWRMaW5lOiBzdHJpbmcgPSBsaW5lO1xuXG4gICAgY29uc3QgdGFzayA9IFRhc2suZnJvbUxpbmUoe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBzZWN0aW9uU3RhcnQ6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBzZWN0aW9uSW5kZXg6IDAsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBwcmVjZWRpbmdIZWFkZXI6IG51bGwsIC8vIFdlIGRvbid0IG5lZWQgdGhpcyB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgIH0pO1xuICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgIHRvZ2dsZWRMaW5lID0gdG9nZ2xlVGFzayh7IHRhc2sgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhc2sgaXMgbnVsbCB0aGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgb2Y6XG4gICAgICAgIC8vIDEuIGEgcmVndWxhciBjaGVja2xpc3QgaXRlbVxuICAgICAgICAvLyAyLiBhIGxpc3QgaXRlbVxuICAgICAgICAvLyAzLiBhIHNpbXBsZSB0ZXh0IGxpbmVcblxuICAgICAgICAvLyBUaGUgdGFzayByZWdleCB3aWxsIG1hdGNoIGNoZWNrbGlzdCBpdGVtcy5cbiAgICAgICAgY29uc3QgcmVnZXhNYXRjaCA9IGxpbmUubWF0Y2goVGFzay50YXNrUmVnZXgpO1xuICAgICAgICBpZiAocmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9nZ2xlZExpbmUgPSB0b2dnbGVDaGVja2xpc3RJdGVtKHsgcmVnZXhNYXRjaCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgY2hlY2tsaXN0IGl0ZW0uIEl0IGlzIG9uZSBvZjpcbiAgICAgICAgICAgIC8vIDEuIGEgbGlzdCBpdGVtXG4gICAgICAgICAgICAvLyAyLiBhIHNpbXBsZSB0ZXh0IGxpbmVcblxuICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW1SZWdleCA9IC9eKFtcXHNcXHQ+XSopKFstKl0pLztcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbVJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXQncyBjb252ZXJ0IHRoZSBsaXN0IGl0ZW0gdG8gYSBjaGVja2xpc3QgaXRlbS5cbiAgICAgICAgICAgICAgICB0b2dnbGVkTGluZSA9IGxpbmUucmVwbGFjZShsaXN0SXRlbVJlZ2V4LCAnJDEkMiBbIF0nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgY29udmVydCB0aGUgbGluZSB0byBhIGxpc3QgaXRlbS5cbiAgICAgICAgICAgICAgICB0b2dnbGVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihbXFxzXFx0Pl0qKS8sICckMS0gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9nZ2xlZExpbmU7XG59O1xuXG5jb25zdCB0b2dnbGVUYXNrID0gKHsgdGFzayB9OiB7IHRhc2s6IFRhc2sgfSk6IHN0cmluZyA9PiB7XG4gICAgLy8gVG9nZ2xlIGEgcmVndWxhciB0YXNrLlxuICAgIGNvbnN0IHRvZ2dsZWRUYXNrcyA9IHRhc2sudG9nZ2xlKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHRvZ2dsZWRUYXNrc1xuICAgICAgICAubWFwKCh0YXNrOiBUYXNrKSA9PiB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG5jb25zdCB0b2dnbGVDaGVja2xpc3RJdGVtID0gKHtcbiAgICByZWdleE1hdGNoLFxufToge1xuICAgIHJlZ2V4TWF0Y2g6IFJlZ0V4cE1hdGNoQXJyYXk7XG59KTogc3RyaW5nID0+IHtcbiAgICAvLyBJdCdzIGEgY2hlY2tsaXN0IGl0ZW0sIGxldCdzIHRvZ2dsZSBpdC5cbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9IHJlZ2V4TWF0Y2hbMV07XG4gICAgY29uc3Qgc3RhdHVzU3RyaW5nID0gcmVnZXhNYXRjaFsyXS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGJvZHkgPSByZWdleE1hdGNoWzNdO1xuXG4gICAgY29uc3QgdG9nZ2xlZFN0YXR1c1N0cmluZyA9IHN0YXR1c1N0cmluZyA9PT0gJyAnID8gJ3gnIDogJyAnO1xuXG4gICAgY29uc3QgdG9nZ2xlZExpbmUgPSBgJHtpbmRlbnRhdGlvbn0tIFske3RvZ2dsZWRTdGF0dXNTdHJpbmd9XSAke2JvZHl9YDtcblxuICAgIHJldHVybiB0b2dnbGVkTGluZTtcbn07XG4iLCAiaW1wb3J0IHR5cGUgeyBBcHAsIEVkaXRvciwgUGx1Z2luLCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgY3JlYXRlT3JFZGl0IH0gZnJvbSAnLi9DcmVhdGVPckVkaXQnO1xuXG5pbXBvcnQgeyB0b2dnbGVEb25lIH0gZnJvbSAnLi9Ub2dnbGVEb25lJztcblxuZXhwb3J0IGNsYXNzIENvbW1hbmRzIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBsdWdpbjogUGx1Z2luO1xuXG4gICAgcHJpdmF0ZSBnZXQgYXBwKCk6IEFwcCB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5hcHA7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoeyBwbHVnaW4gfTogeyBwbHVnaW46IFBsdWdpbiB9KSB7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXG4gICAgICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnZWRpdC10YXNrJyxcbiAgICAgICAgICAgIG5hbWU6ICdDcmVhdGUgb3IgZWRpdCB0YXNrJyxcbiAgICAgICAgICAgIGljb246ICdwZW5jaWwnLFxuICAgICAgICAgICAgZWRpdG9yQ2hlY2tDYWxsYmFjazogKFxuICAgICAgICAgICAgICAgIGNoZWNraW5nOiBib29sZWFuLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yLFxuICAgICAgICAgICAgICAgIHZpZXc6IFZpZXcsXG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlT3JFZGl0KGNoZWNraW5nLCBlZGl0b3IsIHZpZXcsIHRoaXMuYXBwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAndG9nZ2xlLWRvbmUnLFxuICAgICAgICAgICAgbmFtZTogJ1RvZ2dsZSB0YXNrIGRvbmUnLFxuICAgICAgICAgICAgaWNvbjogJ2NoZWNrLWluLWNpcmNsZScsXG4gICAgICAgICAgICBlZGl0b3JDaGVja0NhbGxiYWNrOiB0b2dnbGVEb25lLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFdmVudFJlZiwgRXZlbnRzIGFzIE9ic2lkaWFuRXZlbnRzIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgdHlwZSB7IFN0YXRlIH0gZnJvbSAnLi9DYWNoZSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG5lbnVtIEV2ZW50IHtcbiAgICBDYWNoZVVwZGF0ZSA9ICdvYnNpZGlhbi10YXNrcy1wbHVnaW46Y2FjaGUtdXBkYXRlJyxcbiAgICBSZXF1ZXN0Q2FjaGVVcGRhdGUgPSAnb2JzaWRpYW4tdGFza3MtcGx1Z2luOnJlcXVlc3QtY2FjaGUtdXBkYXRlJyxcbn1cblxuaW50ZXJmYWNlIENhY2hlVXBkYXRlRGF0YSB7XG4gICAgdGFza3M6IFRhc2tbXTtcbiAgICBzdGF0ZTogU3RhdGU7XG59XG5cbmV4cG9ydCBjbGFzcyBFdmVudHMge1xuICAgIHByaXZhdGUgb2JzaWRpYW5FdmVudHM6IE9ic2lkaWFuRXZlbnRzO1xuXG4gICAgY29uc3RydWN0b3IoeyBvYnNpZGlhbkV2ZW50cyB9OiB7IG9ic2lkaWFuRXZlbnRzOiBPYnNpZGlhbkV2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMgPSBvYnNpZGlhbkV2ZW50cztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DYWNoZVVwZGF0ZShcbiAgICAgICAgaGFuZGxlcjogKGNhY2hlRGF0YTogQ2FjaGVVcGRhdGVEYXRhKSA9PiB2b2lkLFxuICAgICk6IEV2ZW50UmVmIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzaWRpYW5FdmVudHMub24oRXZlbnQuQ2FjaGVVcGRhdGUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyQ2FjaGVVcGRhdGUoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vYnNpZGlhbkV2ZW50cy50cmlnZ2VyKEV2ZW50LkNhY2hlVXBkYXRlLCBjYWNoZURhdGEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvblJlcXVlc3RDYWNoZVVwZGF0ZShcbiAgICAgICAgaGFuZGxlcjogKGZuOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpID0+IHZvaWQsXG4gICAgKTogRXZlbnRSZWYge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNpZGlhbkV2ZW50cy5vbihFdmVudC5SZXF1ZXN0Q2FjaGVVcGRhdGUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmlnZ2VyUmVxdWVzdENhY2hlVXBkYXRlKFxuICAgICAgICBmbjogKGNhY2hlRGF0YTogQ2FjaGVVcGRhdGVEYXRhKSA9PiB2b2lkLFxuICAgICk6IHZvaWQge1xuICAgICAgICB0aGlzLm9ic2lkaWFuRXZlbnRzLnRyaWdnZXIoRXZlbnQuUmVxdWVzdENhY2hlVXBkYXRlLCBmbik7XG4gICAgfVxuXG4gICAgcHVibGljIG9mZihldmVudFJlZjogRXZlbnRSZWYpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vYnNpZGlhbkV2ZW50cy5vZmZyZWYoZXZlbnRSZWYpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJ2NvbmZpZy9TZXR0aW5ncyc7XG5cbmltcG9ydCB0eXBlIHsgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBjbGFzcyBJbmxpbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoeyBwbHVnaW4gfTogeyBwbHVnaW46IFBsdWdpbiB9KSB7XG4gICAgICAgIHBsdWdpbi5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3NvcihcbiAgICAgICAgICAgIHRoaXMuX21hcmtkb3duUG9zdFByb2Nlc3Nvci5iaW5kKHRoaXMpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBtYXJrZG93blBvc3RQcm9jZXNzb3IgPSB0aGlzLl9tYXJrZG93blBvc3RQcm9jZXNzb3IuYmluZCh0aGlzKTtcblxuICAgIHByaXZhdGUgYXN5bmMgX21hcmtkb3duUG9zdFByb2Nlc3NvcihcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIGNvbnRleHQ6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsRmlsdGVyIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zdCByZW5kZXJlZEVsZW1lbnRzID0gZWxlbWVudFxuICAgICAgICAgICAgLmZpbmRBbGwoJy50YXNrLWxpc3QtaXRlbScpXG4gICAgICAgICAgICAuZmlsdGVyKCh0YXNrSXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzVGV4dCA9IHRhc2tJdGVtLnRleHRDb250ZW50Py5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBsaW5lLiBDYW4gYmUgbXVsdGlwbGUgbGluZXMgaWYgYW4gTEkgZWxlbWVudCBjb250YWlucyBhbiBVTC5cbiAgICAgICAgICAgICAgICAvLyBXYW50IHRvIG1hdGNoIHRoZSB0b3AgbGV2ZWwgTEkgaW5kZXBlbmRlbnRseSBmcm9tIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSB3YXMgYSBmYWxzZSBwb3NpdGl2ZSwgd2hlbiB0aGUgTEkgd2Fzbid0IGEgdGFzayBpdHNlbGYsIGJ1dCBjb250YWluZWQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGZpbHRlciBpbiBjaGlsZCBMSXMuXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0TGluZVRleHQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGxpbmUgaXMgdGhlIGZpcnN0IGxpbmUgdGhhdCBpcyBub3QgZW1wdHkuIEVtcHR5IGxpbmVzIGNhbiBleGlzdCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNoZWNrbGlzdCBpbiBtYXJrZG93biBpbmNsdWRlcyBibGFuayBsaW5lcyAoc2VlICMzMTMpLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNUZXh0Lmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lc1RleHRbaV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmVUZXh0ID0gbGluZXNUZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMaW5lVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0TGluZVRleHQuaW5jbHVkZXMoZ2xvYmFsRmlsdGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAocmVuZGVyZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIHRhc2tzIG1lYW5zIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoID0gY29udGV4dC5zb3VyY2VQYXRoO1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gY29udGV4dC5nZXRTZWN0aW9uSW5mbyhlbGVtZW50KTtcblxuICAgICAgICBpZiAoc2VjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UgY2Fubm90IHByb2Nlc3MgdGhlIHJlbmRlciB3aXRob3V0IHRoZSBzZWN0aW9uIGluZm8uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlTGluZXMgPSBzZWN0aW9uLnRleHQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGxldCBzZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBjb25zdCBmaWxlVGFza3M6IFRhc2tbXSA9IFtdO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSBzZWN0aW9uLmxpbmVTdGFydDtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPD0gc2VjdGlvbi5saW5lRW5kO1xuICAgICAgICAgICAgbGluZU51bWJlcisrXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGZpbGVMaW5lc1tsaW5lTnVtYmVyXTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlbmQgdXAgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgdGhlIGZpbGUsXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHByb2Nlc3MgdGhpcyB0YXNrLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25TdGFydDogc2VjdGlvbi5saW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlcjogbnVsbCwgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgcHJlY2VkaW5nIGhlYWRlciBmb3IgaW4tbGluZSByZW5kZXJpbmcuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmlsZVRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc2VjdGlvbiBpbmRleCBpcyB0aGUgbnRoIHRhc2sgd2l0aGluIHRoaXMgc2VjdGlvbi5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGxldCBzZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgc2VjdGlvbkluZGV4IDwgcmVuZGVyZWRFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBmaWxlVGFza3Nbc2VjdGlvbkluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkRWxlbWVudCA9IHJlbmRlcmVkRWxlbWVudHNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgICAgICAgaWYgKHRhc2sgPT09IHVuZGVmaW5lZCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIG1hdGNoIG9mIHRhc2tzIGluIGZpbGUgYW5kIHJlbmRlciBwcmV2aWV3LlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbWlzLW1hdGNoIGluIHRoZSBudW1iZXJzLCB3ZSBzdGlsbCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gd2hhdCB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFMaW5lOiBzdHJpbmcgPVxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5nZXRBdHRyKCdkYXRhLWxpbmUnKSA/PyAnMCc7XG4gICAgICAgICAgICBjb25zdCBsaXN0SW5kZXg6IG51bWJlciA9IE51bWJlci5wYXJzZUludChkYXRhTGluZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgdGFza0VsZW1lbnQgPSBhd2FpdCB0YXNrLnRvTGkoe1xuICAgICAgICAgICAgICAgIHBhcmVudFVsRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0SW5kZXgsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgYSBzdWItbGlzdCBvciBzdWItZGl2IChlLmcuIHRoZVxuICAgICAgICAgICAgLy8gZm9sZGluZyBhcnJvdyksIHdlIG5lZWQgdG8ga2VlcCBpdC5cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGRyZW4gPSByZW5kZXJlZEVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tFbGVtZW50LnByZXBlbmQocmVuZGVyZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJlZENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza0VsZW1lbnQuYXBwZW5kKHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmUtc2V0IHRoZSBvcmlnaW5hbCBmb290bm90ZXMuXG4gICAgICAgICAgICAvLyBUaGUgbmV3bHkgcmVuZGVyZWQgSFRNTCB3b24ndCBoYXZlIHRoZSBjb3JyZWN0IGluZGV4ZXMgYW5kIGxpbmtzXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBkb2N1bWVudC5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRm9vdG5vdGVzID1cbiAgICAgICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZm9vdG5vdGUtaWRdJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdGb290bm90ZXMgPVxuICAgICAgICAgICAgICAgIHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvb3Rub3RlLWlkXScpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRm9vdG5vdGVzLmxlbmd0aCA9PT0gbmV3Rm9vdG5vdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxGb290bm90ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Rm9vdG5vdGVzW2ldLnJlcGxhY2VXaXRoKG9yaWdpbmFsRm9vdG5vdGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5yZXBsYWNlV2l0aCh0YXNrRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yVmlldywgVmlld1BsdWdpbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHR5cGUgeyBQbHVnaW5WYWx1ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxuZXhwb3J0IGNvbnN0IG5ld0xpdmVQcmV2aWV3RXh0ZW5zaW9uID0gKCkgPT4ge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhMaXZlUHJldmlld0V4dGVuc2lvbik7XG59O1xuXG5jbGFzcyBMaXZlUHJldmlld0V4dGVuc2lvbiBpbXBsZW1lbnRzIFBsdWdpblZhbHVlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXc6IEVkaXRvclZpZXc7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVDbGlja0V2ZW50ID0gdGhpcy5oYW5kbGVDbGlja0V2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNsaWNrRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50O1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94IGNsaWNrcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRhcmdldCB8fFxuICAgICAgICAgICAgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB8fFxuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgIT09ICdjaGVja2JveCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBSaWdodCBub3cgT2JzaWRpYW4gQVBJIGRvZXMgbm90IGdpdmUgdXMgYSB3YXkgdG8gaGFuZGxlIGNoZWNrYm94IGNsaWNrcyBpbnNpZGUgcmVuZGVyZWQtd2lkZ2V0cy1pbi1MUCBzdWNoIGFzXG4gICAgICAgICAqIGNhbGxvdXRzLCB0YWJsZXMsIGFuZCB0cmFuc2NsdXNpb25zIGJlY2F1c2UgYHRoaXMudmlldy5wb3NBdERPTWAgd2lsbCByZXR1cm4gdGhlIGJlZ2lubmluZyBvZiB0aGUgd2lkZ2V0XG4gICAgICAgICAqIGFzIHRoZSBwb3NpdGlvbiBmb3IgYW55IGNsaWNrIGluc2lkZSB0aGUgd2lkZ2V0LlxuICAgICAgICAgKiBGb3IgY2FsbG91dHMsIHRoaXMgbWVhbnMgdGhhdCB0aGUgdGFzayB3aWxsIG5ldmVyIGJlIGZvdW5kLCBzaW5jZSB0aGUgYGxpbmVBdGAgd2lsbCBiZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjYWxsb3V0LlxuICAgICAgICAgKiBUaGVyZWZvcmUsIHByb2R1Y2UgYW4gZXJyb3IgbWVzc2FnZSBwb3AtdXAgdXNpbmcgT2JzaWRpYW4ncyBcIk5vdGljZVwiIGZlYXR1cmUsIGxvZyBhIGNvbnNvbGUgd2FybmluZywgdGhlbiByZXR1cm4uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIFRhc2tzIGZyb20gXCJ0YXNrXCIgcXVlcnkgY29kZWJsb2NrcyBoYW5kbGUgdGhlbXNlbHZlcyB0aGFua3MgdG8gYHRvTGlgLCBzbyBiZSBzcGVjaWZpYyBhYm91dCBlcnJvciBtZXNzYWdpbmcsIGJ1dCBzdGlsbCByZXR1cm4uXG4gICAgICAgIGNvbnN0IGFuY2VzdG9yID0gdGFyZ2V0LmNsb3Nlc3QoXG4gICAgICAgICAgICAndWwucGx1Z2luLXRhc2tzLXF1ZXJ5LXJlc3VsdCwgZGl2LmNhbGxvdXQtY29udGVudCcsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLm1hdGNoZXMoJ2Rpdi5jYWxsb3V0LWNvbnRlbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICAgICAgICAgICAnb2JzaWRpYW4tdGFza3MtcGx1Z2luIHdhcm5pbmc6IFRhc2tzIGNhbm5vdCBhZGQgb3IgcmVtb3ZlIGNvbXBsZXRpb24gZGF0ZXMgb3IgbWFrZSB0aGUgbmV4dCBjb3B5IG9mIGEgcmVjdXJyaW5nIHRhc2sgZm9yIHRhc2tzIHdyaXR0ZW4gaW5zaWRlIGEgY2FsbG91dCB3aGVuIHlvdSBjbGljayB0aGVpciBjaGVja2JveGVzIGluIExpdmUgUHJldmlldy4gXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdJZiB5b3Ugd2FudGVkIFRhc2tzIHRvIGRvIHRoZXNlIHRoaW5ncywgcGxlYXNlIHVuZG8geW91ciBjaGFuZ2UsIHRoZW4gZWl0aGVyIGNsaWNrIHRoZSBsaW5lIG9mIHRoZSB0YXNrIGFuZCB1c2UgdGhlIFwiVG9nZ2xlIFRhc2sgRG9uZVwiIGNvbW1hbmQsIG9yIHN3aXRjaCB0byBSZWFkaW5nIFZpZXcgdG8gY2xpY2sgdGhlIGNoZWNrYm94Lic7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShtc2csIDQ1MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMudmlldztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnZpZXcucG9zQXRET00odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLnRleHQsXG4gICAgICAgICAgICAvLyBOb25lIG9mIHRoaXMgZGF0YSBpcyByZWxldmFudCBoZXJlLlxuICAgICAgICAgICAgLy8gVGhlIHRhc2sgaXMgY3JlYXRlZCwgdG9nZ2xlZCwgYW5kIHdyaXR0ZW4gYmFjayB0byB0aGUgQ002IGRvY3VtZW50LFxuICAgICAgICAgICAgLy8gcmVwbGFjaW5nIHRoZSBvbGQgdGFzayBpbi1wbGFjZS5cbiAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgc2VjdGlvblN0YXJ0OiAwLFxuICAgICAgICAgICAgc2VjdGlvbkluZGV4OiAwLFxuICAgICAgICAgICAgcHJlY2VkaW5nSGVhZGVyOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgYExpdmUgUHJldmlldyBFeHRlbnNpb246IHRvZ2dsZSBjYWxsZWQuIFBvc2l0aW9uOiAke3Bvc2l0aW9ufSBMaW5lOiAke2xpbmUudGV4dH1gLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94ZXMgb2YgdGFza3MuXG4gICAgICAgIGlmICh0YXNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXZlbnQgZGVmYXVsdCBzbyB0aGF0IHRoZSBjaGVja2JveCBpcyBvbmx5IGhhbmRsZWQgYnkgdXMgYW5kIG5vdCBvYnNpZGlhbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBDbGlja2VkIG9uIGEgdGFzaydzIGNoZWNrYm94LiBUb2dnbGUgdGhlIHRhc2sgYW5kIHNldCBpdC5cbiAgICAgICAgY29uc3QgdG9nZ2xlZCA9IHRhc2sudG9nZ2xlKCk7XG4gICAgICAgIGNvbnN0IHRvZ2dsZWRTdHJpbmcgPSB0b2dnbGVkXG4gICAgICAgICAgICAubWFwKCh0KSA9PiB0LnRvRmlsZUxpbmVTdHJpbmcoKSlcbiAgICAgICAgICAgIC5qb2luKHN0YXRlLmxpbmVCcmVhayk7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIENvZGVNaXJyb3IgdHJhbnNhY3Rpb24gaW4gb3JkZXIgdG8gdXBkYXRlIHRoZSBkb2N1bWVudC5cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgICAgIGZyb206IGxpbmUuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogbGluZS50byxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IHRvZ2dsZWRTdHJpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcblxuICAgICAgICAvLyBEaXJ0eSB3b3JrYXJvdW5kLlxuICAgICAgICAvLyBXaGlsZSB0aGUgY29kZSBpbiB0aGlzIG1ldGhvZCBwcm9wZXJseSB1cGRhdGVzIHRoZSBgY2hlY2tlZGAgc3RhdGVcbiAgICAgICAgLy8gb2YgdGhlIHRhcmdldCBjaGVja2JveCwgc29tZSBPYnNpZGlhbiBpbnRlcm5hbHMgcmV2ZXJ0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBjaGVja2JveCB3b3VsZCByZW1haW4gaW4gaXRzIG9yaWdpbmFsIGBjaGVja2VkYFxuICAgICAgICAvLyBzdGF0ZSAoYHRydWVgIG9yIGBmYWxzZWApLCBldmVuIHRob3VnaCB0aGUgdW5kZXJseWluZyBkb2N1bWVudFxuICAgICAgICAvLyB1cGRhdGVzIGNvcnJlY3RseS5cbiAgICAgICAgLy8gQXMgYSBcImZpeFwiLCB3ZSBzZXQgdGhlIGNoZWNrYm94J3MgYGNoZWNrZWRgIHN0YXRlICphZ2FpbiogYWZ0ZXIgYVxuICAgICAgICAvLyB0aW1lb3V0IHRvIHJldmVydCBPYnNpZGlhbidzIHdyb25nZnVsIHJldmVyc2FsLlxuICAgICAgICBjb25zdCBkZXNpcmVkQ2hlY2tlZFN0YXR1cyA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5jaGVja2VkID0gZGVzaXJlZENoZWNrZWRTdGF0dXM7XG4gICAgICAgIH0sIDEpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE1hcmtkb3duUmVuZGVyQ2hpbGQsIFBsdWdpbiwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEV2ZW50UmVmLCBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgdHlwZSB7IElRdWVyeSB9IGZyb20gJy4vSVF1ZXJ5JztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9DYWNoZSc7XG5pbXBvcnQgeyByZXBsYWNlVGFza1dpdGhUYXNrcyB9IGZyb20gJy4vRmlsZSc7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4vUXVlcnknO1xuaW1wb3J0IHR5cGUgeyBHcm91cEhlYWRpbmcgfSBmcm9tICcuL1F1ZXJ5L0dyb3VwSGVhZGluZyc7XG5pbXBvcnQgeyBUYXNrTW9kYWwgfSBmcm9tICcuL1Rhc2tNb2RhbCc7XG5pbXBvcnQgdHlwZSB7IEV2ZW50cyB9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVJlbmRlcmVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBFdmVudHM7XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiwgZXZlbnRzIH06IHsgcGx1Z2luOiBQbHVnaW47IGV2ZW50czogRXZlbnRzIH0pIHtcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcblxuICAgICAgICBwbHVnaW4ucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcihcbiAgICAgICAgICAgICd0YXNrcycsXG4gICAgICAgICAgICB0aGlzLl9hZGRRdWVyeVJlbmRlckNoaWxkLmJpbmQodGhpcyksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFF1ZXJ5UmVuZGVyQ2hpbGQgPSB0aGlzLl9hZGRRdWVyeVJlbmRlckNoaWxkLmJpbmQodGhpcyk7XG5cbiAgICBwcml2YXRlIGFzeW5jIF9hZGRRdWVyeVJlbmRlckNoaWxkKFxuICAgICAgICBzb3VyY2U6IHN0cmluZyxcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIGNvbnRleHQ6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsXG4gICAgKSB7XG4gICAgICAgIGNvbnRleHQuYWRkQ2hpbGQoXG4gICAgICAgICAgICBuZXcgUXVlcnlSZW5kZXJDaGlsZCh7XG4gICAgICAgICAgICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGNvbnRleHQuc291cmNlUGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgIH1cbn1cblxuY2xhc3MgUXVlcnlSZW5kZXJDaGlsZCBleHRlbmRzIE1hcmtkb3duUmVuZGVyQ2hpbGQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBwOiBBcHA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudHM6IEV2ZW50cztcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nOyAvLyBUaGUgY29tcGxldGUgdGV4dCBpbiB0aGUgaW5zdHJ1Y3Rpb24gYmxvY2ssIHN1Y2ggYXMgJ25vdCBkb25lXFxuc2hvcnQgbW9kZSdcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbGVQYXRoOiBzdHJpbmc7IC8vIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIGluc3RydWN0aW9uIGJsb2NrXG4gICAgcHJpdmF0ZSBxdWVyeTogSVF1ZXJ5O1xuICAgIHByaXZhdGUgcXVlcnlUeXBlOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIHJlbmRlckV2ZW50UmVmOiBFdmVudFJlZiB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIHF1ZXJ5UmVsb2FkVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIGFwcCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZmlsZVBhdGgsXG4gICAgfToge1xuICAgICAgICBhcHA6IEFwcDtcbiAgICAgICAgZXZlbnRzOiBFdmVudHM7XG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgICAgIHNvdXJjZTogc3RyaW5nO1xuICAgICAgICBmaWxlUGF0aDogc3RyaW5nO1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG5cbiAgICAgICAgLy8gVGhlIGVuZ2luZSBpcyBjaG9zZW4gb24gdGhlIGJhc2lzIG9mIHRoZSBjb2RlIGJsb2NrIGxhbmd1YWdlLiBDdXJyZW50bHlcbiAgICAgICAgLy8gdGhlcmUgaXMgb25seSB0aGUgbWFpbiBlbmdpbmUgZm9yIHRoZSBwbHVnaW4sIHRoaXMgYWxsb3dzIG90aGVycyB0byBiZVxuICAgICAgICAvLyBhZGRlZCBsYXRlci5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRhaW5lckVsLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbGFuZ3VhZ2UtdGFza3MnOlxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBuZXcgUXVlcnkoeyBzb3VyY2UgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAndGFza3MnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBuZXcgUXVlcnkoeyBzb3VyY2UgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAndGFza3MnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25sb2FkKCkge1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjdXJyZW50IGNhY2hlIHN0YXRlOlxuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyUmVxdWVzdENhY2hlVXBkYXRlKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBMaXN0ZW4gdG8gZnV0dXJlIGNhY2hlIGNoYW5nZXM6XG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRSZWYgPSB0aGlzLmV2ZW50cy5vbkNhY2hlVXBkYXRlKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMucmVsb2FkUXVlcnlBdE1pZG5pZ2h0KCk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlckV2ZW50UmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9mZih0aGlzLnJlbmRlckV2ZW50UmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UmVsb2FkVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5xdWVyeVJlbG9hZFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgcXVlcnkgYWZ0ZXIgbWlkbmlnaHQgdG8gdXBkYXRlIHJlc3VsdHMgZnJvbSByZWxhdGl2ZSBkYXRlIHF1ZXJpZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhlIHF1ZXJ5IGBkdWUgdG9kYXlgIGNoYW5nZXMgZXZlcnkgZGF5LiBUaGlzIG1ha2VzIHN1cmUgdGhhdCBhbGwgcXVlcnkgcmVzdWx0c1xuICAgICAqIGFyZSByZS1yZW5kZXJlZCBhZnRlciBtaWRuaWdodCBldmVyeSBkYXkgdG8gZW5zdXJlIHVwLXRvLWRhdGUgcmVzdWx0cyB3aXRob3V0IGhhdmluZyB0b1xuICAgICAqIHJlbG9hZCBvYnNpZGlhbi4gQ3JlYXRpbmcgYSBuZXcgcXVlcnkgb2JqZWN0IGZyb20gdGhlIHNvdXJjZSByZS1hcHBsaWVzIHRoZSByZWxhdGl2ZSBkYXRlc1xuICAgICAqIHRvIFwibm93XCIuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWxvYWRRdWVyeUF0TWlkbmlnaHQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1pZG5pZ2h0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWlkbmlnaHQuc2V0SG91cnMoMjQsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kc1RvTWlkbmlnaHQgPSBtaWRuaWdodC5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpO1xuXG4gICAgICAgIHRoaXMucXVlcnlSZWxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gbmV3IFF1ZXJ5KHsgc291cmNlOiB0aGlzLnNvdXJjZSB9KTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGN1cnJlbnQgY2FjaGUgc3RhdGU6XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyUmVxdWVzdENhY2hlVXBkYXRlKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRRdWVyeUF0TWlkbmlnaHQoKTtcbiAgICAgICAgfSwgbWlsbGlzZWNvbmRzVG9NaWRuaWdodCArIDEwMDApOyAvLyBBZGQgYnVmZmVyIHRvIGJlIHN1cmUgdG8gcnVuIGFmdGVyIG1pZG5pZ2h0LlxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyKHsgdGFza3MsIHN0YXRlIH06IHsgdGFza3M6IFRhc2tbXTsgc3RhdGU6IFN0YXRlIH0pIHtcbiAgICAgICAgLy8gRG9uJ3QgbG9nIGFueXRoaW5nIGhlcmUsIGZvciBhbnkgc3RhdGUsIGFzIGl0IGdlbmVyYXRlcyBodWdlIGFtb3VudHMgb2ZcbiAgICAgICAgLy8gY29uc29sZSBtZXNzYWdlcyBpbiBsYXJnZSB2YXVsdHMsIGlmIE9ic2lkaWFuIHdhcyBvcGVuZWQgd2l0aCBhbnlcbiAgICAgICAgLy8gbm90ZXMgd2l0aCB0YXNrcyBjb2RlIGJsb2NrcyBpbiBSZWFkaW5nIG9yIExpdmUgUHJldmlldyBtb2RlLlxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5XYXJtICYmIHRoaXMucXVlcnkuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgUmVuZGVyICR7dGhpcy5xdWVyeVR5cGV9IGNhbGxlZCBmb3IgYSBibG9jayBpbiBhY3RpdmUgZmlsZSBcIiR7dGhpcy5maWxlUGF0aH1cIiwgdG8gc2VsZWN0IGZyb20gJHt0YXNrcy5sZW5ndGh9IHRhc2tzOiBwbHVnaW4gc3RhdGU6ICR7c3RhdGV9YCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhc2tzU29ydGVkTGltaXRlZEdyb3VwZWQgPVxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkuYXBwbHlRdWVyeVRvVGFza3ModGFza3MpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0YXNrc1NvcnRlZExpbWl0ZWRHcm91cGVkLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbnMsIGdyb3VwLmdyb3VwSGVhZGluZ3NcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGVtcHR5LCBhbmQgbm8gaGVhZGluZ3Mgd2lsbCBiZSBhZGRlZC5cbiAgICAgICAgICAgICAgICBRdWVyeVJlbmRlckNoaWxkLmFkZEdyb3VwSGVhZGluZ3MoY29udGVudCwgZ3JvdXAuZ3JvdXBIZWFkaW5ncyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhc2tMaXN0IH0gPSBhd2FpdCB0aGlzLmNyZWF0ZVRhc2tzTGlzdCh7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzOiBncm91cC50YXNrcyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRhc2tMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsVGFza3NDb3VudCA9IHRhc2tzU29ydGVkTGltaXRlZEdyb3VwZWQudG90YWxUYXNrc0NvdW50KCk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgIGAke3RvdGFsVGFza3NDb3VudH0gb2YgJHt0YXNrcy5sZW5ndGh9IHRhc2tzIGRpc3BsYXllZCBpbiBhIGJsb2NrIGluIFwiJHt0aGlzLmZpbGVQYXRofVwiYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZFRhc2tDb3VudChjb250ZW50LCB0b3RhbFRhc2tzQ291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVlcnkuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudC5zZXRUZXh0KGBUYXNrcyBxdWVyeTogJHt0aGlzLnF1ZXJ5LmVycm9yfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudC5zZXRUZXh0KCdMb2FkaW5nIFRhc2tzIC4uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5maXJzdENoaWxkPy5yZXBsYWNlV2l0aChjb250ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRhc2tzTGlzdCh7XG4gICAgICAgIHRhc2tzLFxuICAgICAgICBjb250ZW50LFxuICAgIH06IHtcbiAgICAgICAgdGFza3M6IFRhc2tbXTtcbiAgICAgICAgY29udGVudDogSFRNTERpdkVsZW1lbnQ7XG4gICAgfSk6IFByb21pc2U8eyB0YXNrTGlzdDogSFRNTFVMaXN0RWxlbWVudDsgdGFza3NDb3VudDogbnVtYmVyIH0+IHtcbiAgICAgICAgY29uc3QgdGFza3NDb3VudCA9IHRhc2tzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCB0YXNrTGlzdCA9IGNvbnRlbnQuY3JlYXRlRWwoJ3VsJyk7XG4gICAgICAgIHRhc2tMaXN0LmFkZENsYXNzZXMoW1xuICAgICAgICAgICAgJ2NvbnRhaW5zLXRhc2stbGlzdCcsXG4gICAgICAgICAgICAncGx1Z2luLXRhc2tzLXF1ZXJ5LXJlc3VsdCcsXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhc2tzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHRhc2tzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNGaWxlbmFtZVVuaXF1ZSA9IHRoaXMuaXNGaWxlbmFtZVVuaXF1ZSh7IHRhc2sgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gYXdhaXQgdGFzay50b0xpKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRVbEVsZW1lbnQ6IHRhc2tMaXN0LFxuICAgICAgICAgICAgICAgIGxpc3RJbmRleDogaSxcbiAgICAgICAgICAgICAgICBsYXlvdXRPcHRpb25zOiB0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNGaWxlbmFtZVVuaXF1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZvb3Rub3Rlcy4gVGhleSBkb24ndCByZS1hcHBlYXIgaW4gYW5vdGhlciBkb2N1bWVudC5cbiAgICAgICAgICAgIGNvbnN0IGZvb3Rub3RlcyA9IGxpc3RJdGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvb3Rub3RlLWlkXScpO1xuICAgICAgICAgICAgZm9vdG5vdGVzLmZvckVhY2goKGZvb3Rub3RlKSA9PiBmb290bm90ZS5yZW1vdmUoKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBvc3RJbmZvID0gbGlzdEl0ZW0uY3JlYXRlU3BhbigpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnRNb2RlID0gdGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLnNob3J0TW9kZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMuaGlkZUJhY2tsaW5rcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmFja2xpbmtzKHBvc3RJbmZvLCB0YXNrLCBzaG9ydE1vZGUsIGlzRmlsZW5hbWVVbmlxdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucXVlcnkubGF5b3V0T3B0aW9ucy5oaWRlRWRpdEJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWRpdEJ1dHRvbihwb3N0SW5mbywgdGFzayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhc2tMaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHRhc2tMaXN0LCB0YXNrc0NvdW50IH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRFZGl0QnV0dG9uKHBvc3RJbmZvOiBIVE1MU3BhbkVsZW1lbnQsIHRhc2s6IFRhc2spIHtcbiAgICAgICAgY29uc3QgZWRpdFRhc2tQZW5jaWwgPSBwb3N0SW5mby5jcmVhdGVFbCgnYScsIHtcbiAgICAgICAgICAgIGNsczogJ3Rhc2tzLWVkaXQnLFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdFRhc2tQZW5jaWwub25DbGlja0V2ZW50KChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgY29uc3Qgb25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICByZXBsYWNlVGFza1dpdGhUYXNrcyh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzazogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFza3M6IHVwZGF0ZWRUYXNrcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUsIGFzIGN1cnNvci90YXNrIGNhbiBjaGFuZ2UuXG4gICAgICAgICAgICBjb25zdCB0YXNrTW9kYWwgPSBuZXcgVGFza01vZGFsKHtcbiAgICAgICAgICAgICAgICBhcHA6IHRoaXMuYXBwLFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgb25TdWJtaXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhc2tNb2RhbC5vcGVuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgaGVhZGluZ3MgZm9yIGEgZ3JvdXAgb2YgdGFza3MuXG4gICAgICogQHBhcmFtIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gZ3JvdXBIZWFkaW5ncyAtIFRoZSBoZWFkaW5ncyB0byBkaXNwbGF5LiBUaGlzIGNhbiBiZSBhbiBlbXB0eSBhcnJheSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGluIHdoaWNoIGNhc2Ugbm8gaGVhZGluZ3Mgd2lsbCBiZSBhZGRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGFkZEdyb3VwSGVhZGluZ3MoXG4gICAgICAgIGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LFxuICAgICAgICBncm91cEhlYWRpbmdzOiBHcm91cEhlYWRpbmdbXSxcbiAgICApIHtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkaW5nIG9mIGdyb3VwSGVhZGluZ3MpIHtcbiAgICAgICAgICAgIFF1ZXJ5UmVuZGVyQ2hpbGQuYWRkR3JvdXBIZWFkaW5nKGNvbnRlbnQsIGhlYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYWRkR3JvdXBIZWFkaW5nKFxuICAgICAgICBjb250ZW50OiBIVE1MRGl2RWxlbWVudCxcbiAgICAgICAgZ3JvdXA6IEdyb3VwSGVhZGluZyxcbiAgICApIHtcbiAgICAgICAgbGV0IGhlYWRlcjogYW55O1xuICAgICAgICAvLyBJcyBpdCBwb3NzaWJsZSB0byByZW1vdmUgdGhlIHJlcGV0aXRpb24gaGVyZT9cbiAgICAgICAgLy8gSWRlYWxseSwgYnkgY3JlYXRpbmcgYSB2YXJpYWJsZSB0aGF0IGNvbnRhaW5zIGg0LCBoNSBvciBoNlxuICAgICAgICAvLyBhbmQgdGhlbiBvbmx5IGhhdmluZyBvbmUgY2FsbCB0byBjb250ZW50LmNyZWF0ZUVsKCkuXG4gICAgICAgIGlmIChncm91cC5uZXN0aW5nTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGhlYWRlciA9IGNvbnRlbnQuY3JlYXRlRWwoJ2g0Jywge1xuICAgICAgICAgICAgICAgIGNsczogJ3Rhc2tzLWdyb3VwLWhlYWRpbmcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubmVzdGluZ0xldmVsID09PSAxKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSBjb250ZW50LmNyZWF0ZUVsKCdoNScsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICd0YXNrcy1ncm91cC1oZWFkaW5nJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVhZGluZ3MgbmVzdGVkIHRvIDIgb3IgbW9yZSBsZXZlbHMgYXJlIGFsbCBkaXNwbGF5ZWQgd2l0aCAnaDY6XG4gICAgICAgICAgICBoZWFkZXIgPSBjb250ZW50LmNyZWF0ZUVsKCdoNicsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICd0YXNrcy1ncm91cC1oZWFkaW5nJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlci5hcHBlbmRUZXh0KGdyb3VwLm5hbWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQmFja2xpbmtzKFxuICAgICAgICBwb3N0SW5mbzogSFRNTFNwYW5FbGVtZW50LFxuICAgICAgICB0YXNrOiBUYXNrLFxuICAgICAgICBzaG9ydE1vZGU6IGJvb2xlYW4sXG4gICAgICAgIGlzRmlsZW5hbWVVbmlxdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gICAgKSB7XG4gICAgICAgIHBvc3RJbmZvLmFkZENsYXNzKCd0YXNrcy1iYWNrbGluaycpO1xuICAgICAgICBpZiAoIXNob3J0TW9kZSkge1xuICAgICAgICAgICAgcG9zdEluZm8uYXBwZW5kKCcgKCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmsgPSBwb3N0SW5mby5jcmVhdGVFbCgnYScpO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9IHRhc2sucGF0aDtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicsIHRhc2sucGF0aCk7XG4gICAgICAgIGxpbmsucmVsID0gJ25vb3BlbmVyJztcbiAgICAgICAgbGluay50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgbGluay5hZGRDbGFzcygnaW50ZXJuYWwtbGluaycpO1xuICAgICAgICBpZiAoc2hvcnRNb2RlKSB7XG4gICAgICAgICAgICBsaW5rLmFkZENsYXNzKCdpbnRlcm5hbC1saW5rLXNob3J0LW1vZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLnByZWNlZGluZ0hlYWRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2FuaXRpc2VkSGVhZGluZyA9IHRhc2sucHJlY2VkaW5nSGVhZGVyLnJlcGxhY2UoLyMvZywgJycpO1xuICAgICAgICAgICAgbGluay5ocmVmID0gbGluay5ocmVmICsgJyMnICsgc2FuaXRpc2VkSGVhZGluZztcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICdkYXRhLWhyZWYnLFxuICAgICAgICAgICAgICAgIGxpbmsuZ2V0QXR0cmlidXRlKCdkYXRhLWhyZWYnKSArICcjJyArIHNhbml0aXNlZEhlYWRpbmcsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmtUZXh0OiBzdHJpbmc7XG4gICAgICAgIGlmIChzaG9ydE1vZGUpIHtcbiAgICAgICAgICAgIGxpbmtUZXh0ID0gJyBcdUQ4M0RcdUREMTcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlua1RleHQgPSB0YXNrLmdldExpbmtUZXh0KHsgaXNGaWxlbmFtZVVuaXF1ZSB9KSA/PyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmsuc2V0VGV4dChsaW5rVGV4dCk7XG4gICAgICAgIGlmICghc2hvcnRNb2RlKSB7XG4gICAgICAgICAgICBwb3N0SW5mby5hcHBlbmQoJyknKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVGFza0NvdW50KGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LCB0YXNrc0NvdW50OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMuaGlkZVRhc2tDb3VudCkge1xuICAgICAgICAgICAgY29udGVudC5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgICAgIHRleHQ6IGAke3Rhc2tzQ291bnR9IHRhc2ske3Rhc2tzQ291bnQgIT09IDEgPyAncycgOiAnJ31gLFxuICAgICAgICAgICAgICAgIGNsczogJ3Rhc2tzLWNvdW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0ZpbGVuYW1lVW5pcXVlKHsgdGFzayB9OiB7IHRhc2s6IFRhc2sgfSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgICAgICAvLyBXaWxsIG1hdGNoIHRoZSBmaWxlbmFtZSB3aXRob3V0IGV4dGVuc2lvbiAodGhlIGZpbGUncyBcImJhc2VuYW1lXCIpLlxuICAgICAgICBjb25zdCBmaWxlbmFtZU1hdGNoID0gdGFzay5wYXRoLm1hdGNoKC8oW14vXSopXFwuLiskL2kpO1xuICAgICAgICBpZiAoZmlsZW5hbWVNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZmlsZW5hbWVNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgYWxsRmlsZXNXaXRoU2FtZU5hbWUgPSB0aGlzLmFwcC52YXVsdFxuICAgICAgICAgICAgLmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICAgICAgLmZpbHRlcigoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5iYXNlbmFtZSA9PT0gZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSBmaWxlIHdpdGggdGhlIHNhbWUgbmFtZSAoaXQgbWlnaHQgYWN0dWFsbHkgYmUgdGhlIHNhbWUgZmlsZSwgYnV0IHdlJ2xsIHRha2UgdGhhdCBpbnRvIGFjY291bnQgbGF0ZXIuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYWxsRmlsZXNXaXRoU2FtZU5hbWUubGVuZ3RoIDwgMjtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBHcm91cEhlYWRpbmcgY29udGFpbnMgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBvbmUgaGVhZGluZyBmb3IgYSBncm91cCBvZiB0YXNrc1xuICovXG5leHBvcnQgY2xhc3MgR3JvdXBIZWFkaW5nIHtcbiAgICAvKipcbiAgICAgKiBIb3cgbmVzdGVkIHRoZSBoZWFkaW5nIGlzLlxuICAgICAqIDAgaXMgdGhlIGZpcnN0IGdyb3VwLCBtZWFuaW5nIHRoaXMgaGVhZGluZyB3YXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogdGhlIGZpcnN0ICdncm91cCBieScgaW5zdHJ1Y3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IG5lc3RpbmdMZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIGZvciB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIEdyb3VwSGVhZGluZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZ0xldmVsIC0gU2VlIHRoaXMubmVzdGluZ0xldmVsIGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBncm91cFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5lc3RpbmdMZXZlbDogbnVtYmVyLCBuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEdyb3VwSGVhZGluZyB9IGZyb20gJy4vR3JvdXBIZWFkaW5nJztcbmltcG9ydCB0eXBlIHsgSW50ZXJtZWRpYXRlVGFza0dyb3Vwc1N0b3JhZ2UgfSBmcm9tICcuL0ludGVybWVkaWF0ZVRhc2tHcm91cHMnO1xuXG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb2YgR3JvdXAudHNcbiAqL1xuXG4vKipcbiAqIEV4cGxhbmF0aW9uIG9mIHRoZSBhbGdvcml0aG1zIHVzZWQgaGVyZS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHRleHQgaXMgdGFrZW4gZnJvbVxuICogaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82ODYwNTM3MDgyNjEyMjg1NzcvODQwMjg2MjY0OTY0MDIyMzAyLzk1NTI0MDgxMjk3MzgwOTY3NFxuICpcbiAqIFRoZSBQcm9ibGVtXG4gKiA9PT09PT09PT09PVxuICpcbiAqIEltYWdpbmUgdGhhdCB0aGUgdXNlciBoYXMgc3VwcGxpZWQgMyAnZ3JvdXAgYnknIGluc3RydWN0aW9ucywgYW5kIGluIG9yZGVyXG4gKiB0byBwcmVzZW50IHRoZSByZXN1bHRzLCB3ZSBzaW1wbHkgY29uY2F0ZW5hdGUgdGhlIGdyb3VwIG5hbWVzIHRvZ2V0aGVyXG4gKiB3aXRoICc+Jy5cbiAqXG4gKiBTbyB0aGUgZGlzcGxheSBtaWdodCBsb29rIHNvbWV0aGluZyBsaWtlOlxuICogICAgICAjIyMjIDEwLjAgPiAyMDIyLTAzLTIwID4gU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDFcbiAqICAgICAgLSB0YXNrIDJcbiAqICAgICAgIyMjIyAxMC4wID4gMjAyMi0wMy0yMiA+IFNvbWUgaGVhZGluZyBuYW1lXG4gKiAgICAgIC0gdGFzayA3XG4gKiAgICAgIC0gdGFzayA5XG4gKlxuICogVGhlIGhlYWRpbmdzIGdldCB2ZXJ5IGhhcmQgdG8gcmVhZCwgdmVyeSBxdWlja2x5LlxuICpcbiAqIFdoYXQgd2Ugd2FudCBpbnN0ZWFkIGlzOlxuICogICAgICAjIyMjIDEwLjBcbiAqICAgICAgIyMjIyMgMjAyMi0wMy0yMFxuICogICAgICAjIyMjIyMgU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDFcbiAqICAgICAgLSB0YXNrIDJcbiAqICAgICAgIyMjIyMgMjAyMi0wMy0yMlxuICogICAgICAjIyMjIyMgU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDdcbiAqICAgICAgLSB0YXNrIDlcbiAqXG4gKiBJJ20gc3RydWdnbGluZyB0byBnZXQgbXkgaGVhZCBhcm91bmQgaG93LCBpbiBUUywgSSBjYW4gc3RvcmUgc29tZXRoaW5nIGxpa2UgYSB0cmVlIHN0cnVjdHVyZSxcbiAqIG9mIGFyYml0cmFyeSBkZXB0aCAtIHRvIHJlcHJlc2VudCB0aGUgZ3JvdXBlZCB0YXNrcy5cbiAqXG4gKiBwamVieSdzIGFuc3dlclxuICogPT09PT09PT09PT09PT1cbiAqXG4gKiBVc2VyIHBqZWJ5IHJlcGxpZWQ6XG4gKiBodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY4NjA1MzcwODI2MTIyODU3Ny84NDAyODYyNjQ5NjQwMjIzMDIvOTU1NTc5NTYwMDM0OTgzOTQ2XG4gKlxuICogSWYgYWxsIHlvdSdyZSBkb2luZyBpcyBnZW5lcmF0aW5nIGhlYWRpbmdzLCB0aGUgc2ltcGxlIGFsZ29yaXRobSB3b3VsZCBiZSB0byBzb3J0IGV2ZXJ5dGhpbmcgYnkgYSBtdWx0aS12YWx1ZSBrZXkgLVxuICogaS5lLiwgW2xldmVsIDEsIGxldmVsIDIsIC4uLiwgaXRlbSBzb3J0IGtleV0gLS0gdGhlbiBpdGVyYXRlIHRoZSB3aG9sZSBsaXN0IGFuZCBvdXRwdXQgYSBoZWFkaW5nIGZvciBlYWNoIGxldmVsXG4gKiB3aGVyZSB0aGUgdmFsdWUgY2hhbmdlZC5cbiAqXG4gKiBpLmUuLCB5b3Ugc3RhcnQgd2l0aCBhIFtudWxsLCBudWxsLCBudWxsLCBudWxsLi4uLl0gXCJsYXN0IHNlZW5cIiBhcnJheSBhbmQgY29tcGFyZSBpdCBpdGVtIGJ5IGl0ZW0gdG8gdGhlIGN1cnJlbnRcbiAqIGl0ZW0ncyBkYXRhLCBhbmQgb3V0cHV0IGEgaGVhZGluZyBvZiB0aGUgY29ycmVjdCBsZXZlbCBpZiB0aGVyZSdzIGEgY2hhbmdlLCB1cGRhdGluZyB0aGUgaXRlbSBpbiB5b3VyXG4gKiBcImxhc3Qgc2VlblwiIGFycmF5LlxuICpcbiAqIGkuZS4gaWYgdGhlIGZpcnN0IGl0ZW0gaXMgZGlmZmVyZW50LCBvdXRwdXQgYW4gSDEgZm9yIHRoZSBuZXcgdmFsdWUgYW5kIHNldCB0aGUgcmVzdCBvZiB0aGUgYXJyYXkgdG8gbnVsbC5cbiAqIElmIHRoZSBzZWNvbmQgaXRlbSBpcyBhbHNvIGRpZmZlcmVudCwgb3V0cHV0IGFuIEgyLCBzYXZlIHRoZSB2YWx1ZSwgc2V0IHRoZSByZXN0IHRvIG51bGwsIGFuZCBzbyBvbi5cbiAqIEFmdGVyIGFsbCB0aGUgbGV2ZWxzIGFyZSBjaGVja2VkLCBvdXRwdXQgdGhlIGFjdHVhbCBpdGVtLlxuICogSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMsIHRoZW4gYmFzaWNhbGx5IHlvdSdsbCBqdXN0IGJlIG91dHB1dHRpbmcgdGhlIGl0ZW0uXG4gKiBObyB0cmVlcyBvciBncmFwaHMgb3Igd2hhdG5vdCBuZWVkZWQuXG4gKlxuICogWW91IGNvdWxkIGFsc28ganVzdCBrZWVwIHRoZSBsYXN0IGl0ZW0gYW5kIHNldCBhIGZsYWcgYXMgc29vbiBhcyBzb21ldGhpbmcgZG9lc24ndCBtYXRjaCwgYW5kIGtlZXAgb3V0cHV0dGluZ1xuICogaGVhZGluZ3MgYXMgc29vbiBhcyB0aGUgZmxhZyBpcyBzZXQuXG4gKlxuICogV2hhdCB0aGUgY29kZSBkb2VzXG4gKiA9PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgSW50ZXJtZWRpYXRlVGFza0dyb3VwcyBjbGFzcyBiZWxvdyBkb2VzIHRoZSBpbml0aWFsIGdyb3VwaW5nIGFuZCBzb3J0aW5nLlxuICpcbiAqIFRoZSBHcm91cEhlYWRpbmdzIGNsYXNzIGJlbG93IGltcGxlbWVudHMgcGplYnkncyBoZWFkaW5nIGRldGVjdGlvbiBhbGdvcml0aG0sIGJ1dCBpbnN0ZWFkIG9mIGRvaW5nIHRoZSBwcmludGluZyBkaXJlY3RseSxcbiAqIGl0IHJldHVybnMgdGhlIGNhbGN1bGF0ZWQgaGVhZGluZyBsZXZlbHMgaW4gYW4gYXJyYXkgb2YgR3JvdXBIZWFkaW5nIG9iamVjdHMsIGZvciBsYXRlciB1c2UgaW4gUXVlcnlSZW5kZXJlci50cy5cbiAqL1xuXG4vKipcbiAqIEdyb3VwSGVhZGluZ3MgY2FsY3VsYXRlcyB3aGljaCBoZWFkaW5ncyBuZWVkIHRvIGJlIGRpc3BsYXllZCwgZm9yXG4gKiBhIGdpdmVuIGdyb3VwIG9mIHRhc2tzLlxuICpcbiAqIFNlZSB0aGUgZXhwbGFuYXRpb24gaW4gR3JvdXBIZWFkaW5ncy50cyBmb3IgaG93IGl0IHdvcmtzLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBIZWFkaW5ncyB7XG4gICAgcHJpdmF0ZSBsYXN0SGVhZGluZ0F0TGV2ZWwgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IoZ3JvdXBlZFRhc2tzOiBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzU3RvcmFnZSkge1xuICAgICAgICBjb25zdCBmaXJzdEdyb3VwID0gZ3JvdXBlZFRhc2tzLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IGdyb3VwQ291bnQgPSBmaXJzdEdyb3VwLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNldCBvZiBoZWFkaW5ncyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAgKiBiZWZvcmUgdGhlIHRhc2tzIHdpdGggdGhlIGdpdmVuIGdyb3VwIG5hbWVzLlxuICAgICAqXG4gICAgICogRGF0YSBmb3IgZWFjaCByZXF1aXJlZCBoZWFkaW5nIGlzIHN0b3JlZCBpbiBhIEdyb3VwSGVhZGluZyBvYmplY3QuXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZXMgMCBvciBtb3JlIGdyb3VwIG5hbWVzLCBvbmUgcGVyICdncm91cCBieScgbGluZVxuICAgICAqL1xuICAgIGdldEhlYWRpbmdzRm9yVGFza0dyb3VwKGdyb3VwTmFtZXM6IHN0cmluZ1tdKTogR3JvdXBIZWFkaW5nW10ge1xuICAgICAgICAvLyBTZWUgJ3BqZWJ5J3MgYW5zd2VyJyBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgdGhpcyBhbGdvcml0aG0uXG4gICAgICAgIGNvbnN0IGhlYWRpbmdzRm9yR3JvdXAgPSBuZXcgQXJyYXk8R3JvdXBIZWFkaW5nPigpO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZ3JvdXBOYW1lcy5sZW5ndGg7IGxldmVsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBOYW1lc1tsZXZlbF07XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gdGhpcy5sYXN0SGVhZGluZ0F0TGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZ3NGb3JHcm91cC5wdXNoKG5ldyBHcm91cEhlYWRpbmcobGV2ZWwsIGdyb3VwKSk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIHRoZSBsb3dlciBoZWFkaW5nIGxldmVscyB0byB1bi1zZWVuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGxldmVsOyBqIDwgZ3JvdXBOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RIZWFkaW5nQXRMZXZlbFtqXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RIZWFkaW5nQXRMZXZlbFtsZXZlbF0gPSBncm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGluZ3NGb3JHcm91cDtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBBIG5vZGUgaW4gdGhlIGdyb3VwaW5nIHRyZWUuIFRoZSBub2RlIGNvbnRhaW5zIHRoZVxuICogbGlzdCBvZiB2YWx1ZXMgbWF0Y2hpbmcgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBzbyBmYXIsIGFuZCBpdHMgY2hpbGRyZW5cbiAqIGFyZSB0aGUgZnVydGhlciBncm91cGluZyBvZiB0aG9zZSB2YWx1ZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBpbmdUcmVlTm9kZTxUPiB7XG4gICAgY2hpbGRyZW46IE1hcDxzdHJpbmcsIEdyb3VwaW5nVHJlZU5vZGU8VD4+ID0gbmV3IE1hcCgpO1xuICAgIHZhbHVlczogVFtdID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXM6IFRbXSkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGUgdHJlZSB0byBnZW5lcmF0ZSBhbGwgdGhlIHBhdGhzIHRvIHRoZSBsZWF2ZXMuXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbWFwIGZyb20gZXZlcnkgbGVhZiBwYXRoLCB0byB0aGUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgKiBtYXRjaGluZyB0aGlzIHBhdGguXG4gICAgICogTk9URTogVGhlIG5vZGUgaXRzZWxmIGRvZXNuJ3QgZ2V0IGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgcGF0aHMuXG4gICAgICovXG4gICAgZ2VuZXJhdGVBbGxQYXRocyhwYXRoU29GYXI6IHN0cmluZ1tdID0gW10pOiBNYXA8c3RyaW5nW10sIFRbXT4ge1xuICAgICAgICBjb25zdCByZXN1bHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLnNpemUgPT0gMCkge1xuICAgICAgICAgICAgLy8gQmFzZSBjYXNlOiBMZWFmIG5vZGUuIFBvcHVsYXRlIHRoZSByZXN1bHRzIG1hcCB3aXRoIHRoZSBwYXRoIHRvXG4gICAgICAgICAgICAvLyB0aGlzIG5vZGUsIGFuZCB0aGUgdmFsdWVzIHRoYXQgbWF0Y2ggdGhpcyBwYXRoLlxuICAgICAgICAgICAgcmVzdWx0TWFwLnNldChbLi4ucGF0aFNvRmFyXSwgdGhpcy52YWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcGF0aFNvRmFyLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRSZXN1bHQgPSBjaGlsZC5nZW5lcmF0ZUFsbFBhdGhzKHBhdGhTb0Zhcik7XG4gICAgICAgICAgICBjaGlsZFJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiByZXN1bHRNYXAuc2V0KGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgIHBhdGhTb0Zhci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEdyb3VwaW5nIH0gZnJvbSAnLi4vUXVlcnknO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJy4vR3JvdXAnO1xuaW1wb3J0IHsgR3JvdXBpbmdUcmVlTm9kZSB9IGZyb20gJy4vR3JvdXBpbmdUcmVlTm9kZSc7XG5cbi8qKlxuICogU3RvcmFnZSB1c2VkIGZvciB0aGUgaW5pdGlhbCBncm91cGluZyB0b2dldGhlciBvZiB0YXNrcy5cbiAqXG4gKiBUaGUga2V5cyBvZiB0aGUgbWFwIGFyZSB0aGUgbmFtZXMgb2YgdGhlIGdyb3Vwcy5cbiAqIEZvciBleGFtcGxlLCBvbmUgc2V0IG9mIGtleXMgbWlnaHQgYmUgWydGb2xkZXIgTmFtZS8nLCAnRmlsZSBOYW1lJ11cbiAqIGFuZCB0aGUgdmFsdWVzIHdvdWxkIGJlIGFsbCB0aGUgbWF0Y2hpbmcgVGFza3MgZnJvbSB0aGF0IGZpbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzU3RvcmFnZSBleHRlbmRzIE1hcDxzdHJpbmdbXSwgVGFza1tdPiB7fVxuXG4vKlxuICogQSB0cmVlIG9mIHRhc2tzIHdoZXJlIGV2ZXJ5IGxldmVsIGluIHRoZSB0cmVlIGNvcnJlc3BvbmRzIHRvIGEgZ3JvdXBpbmcgcHJvcGVydHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmU6XG4gKiAjIEhlYWRpbmcgMVxuICogLSBbIF0gVGFzayAxXG4gKiAjIEhlYWRpbmcgMlxuICogLSBbIF0gVGFzayAyXG4gKiAtIFtYXSBUYXNrIDNcbiAqXG4gKiBBbmQgd2UgZ3JvdXAgYnkgaGVhZGluZyB0aGVuIHN0YXR1cywgdGhlIHRyZWUgd2lsbCBsb29rIGxpa2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgUm9vdCBbVDEsIFQyLCBUM11cbiAqICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgXFxcbiAqICAgICAgICAgICAgICBIZWFkaW5nIDEgW1QxXSAgICAgSGVhZGluZyBbVDIsIFQzXVxuICogICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgIC8gICAgICAgIFxcXG4gKiAgICAgICAgICAgICAgIFRPRE8gW1QxXSAgICAgVE9ETyBbVDJdICAgIERvbmUgW1QzXVxuICpcbiAqIFRoZSBuaWNlIHByb3BlcnR5IG9mIHRoaXMgdHJlZSBpcyB0aGF0IGV2ZXJ5IHBhdGggZnJvbSB0aGUgcm9vdCB0byBhIGxlYWYsIG1hcHNcbiAqIHRvIGhvdyB0aGUgdGFza3Mgd2lsbCBiZSByZW5kZXJlZC5cbiAqXG4gKiBOT1RFOiBUaGUgc2FtZSB0YXNrIGNhbiBhcHBlYXIgaW4gbXVsdGlwbGUgbGVhZiBub2RlcywgaWYgaXQgbWF0Y2hlcyBtdWx0aXBsZSBwYXRocy5cbiAqL1xuY2xhc3MgVGFza0dyb3VwaW5nVHJlZU5vZGUgZXh0ZW5kcyBHcm91cGluZ1RyZWVOb2RlPFRhc2s+IHt9XG5cbi8qKlxuICogSW50ZXJtZWRpYXRlVGFza0dyb3VwcyBkb2VzIHRoZSBpbml0aWFsIGdyb3VwaW5nIHRvZ2V0aGVyIG9mIHRhc2tzLFxuICogaW4gYWxwaGFiZXRpY2FsIG9yZGVyIGJ5IGdyb3VwIG5hbWVzLlxuICpcbiAqIEl0IGlzIGVzc2VudGlhbGx5IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBNYXAgLSBzZWUgSW50ZXJtZWRpYXRlVGFza0dyb3Vwc1N0b3JhZ2UuXG4gKlxuICogSXQgaXMgbmFtZWQgXCJJbnRlcm1lZGlhdGVcIiBiZWNhdXNlIGl0cyByZXN1bHRzIGFyZSBvbmx5IHRlbXBvcmFyeS5cbiAqIFRoZXkgd2lsbCBiZSBkaXNjYXJkZWQgb25jZSB0aGUgZmluYWwgVGFza0dyb3VwcyBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBJZGVhbGx5LCB0aGlzIGNvZGUgd291bGQgYmUgc2ltcGxpZmllZCBhbmQgbW92ZWQgaW4gdG8gVGFza0dyb3Vwcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVybWVkaWF0ZVRhc2tHcm91cHMge1xuICAgIHB1YmxpYyBncm91cHMgPSBuZXcgSW50ZXJtZWRpYXRlVGFza0dyb3Vwc1N0b3JhZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIEdyb3VwIGEgbGlzdCBvZiB0YXNrcywgYWNjb3JkaW5nIHRvIG9uZSBvciBtb3JlIHRhc2sgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSBncm91cGluZ3MgMCBvciBtb3JlIEdyb3VwaW5nIHZhbHVlcywgb25lIHBlciAnZ3JvdXAgYnknIGxpbmVcbiAgICAgKiBAcGFyYW0gdGFza3MgVGhlIHRhc2tzIHRoYXQgbWF0Y2ggdGhlIHRhc2sgYmxvY2sncyBRdWVyeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwaW5nczogR3JvdXBpbmdbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy5idWlsZEdyb3VwaW5nVHJlZShncm91cGluZ3MsIHRhc2tzKTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB0cmVlLmdlbmVyYXRlQWxsUGF0aHMoKTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB0aGlzLmdldFNvcnRlZEdyb3VwcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBncm91cGluZyB0cmVlIHRoYXQgZ3JvdXBzIHRoZSBwYXNzZWQgQHRhc2tzIGJ5IHRoZSBwYXNzZWQgQGdyb3VwaW5ncy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJ1aWxkR3JvdXBpbmdUcmVlKFxuICAgICAgICBncm91cGluZ3M6IEdyb3VwaW5nW10sXG4gICAgICAgIHRhc2tzOiBUYXNrW10sXG4gICAgKTogVGFza0dyb3VwaW5nVHJlZU5vZGUge1xuICAgICAgICAvLyBUaGUgdHJlZSBpcyBidWlsZCBsYXllciBieSBsYXllciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgICAgLy8gQXQgZXZlcnkgbGV2ZWwsIHdlIGl0ZXJhdGUgb24gdGhlIG5vZGVzIG9mIHRoYXQgbGV2ZWwgdG8gZ2VuZXJhdGVcbiAgICAgICAgLy8gdGhlIG5leHQgb25lIHVzaW5nIHRoZSBuZXh0IGdyb3VwaW5nLlxuXG4gICAgICAgIC8vIFRoZSByb290IG9mIHRoZSB0cmVlIGNvbnRhaW5zIGFsbCB0aGUgdGFza3MuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgVGFza0dyb3VwaW5nVHJlZU5vZGUodGFza3MpO1xuXG4gICAgICAgIGxldCBjdXJyZW50VHJlZUxldmVsID0gW3Jvb3RdO1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwaW5nIG9mIGdyb3VwaW5ncykge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRyZWVMZXZlbCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VHJlZU5vZGUgb2YgY3VycmVudFRyZWVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiBjdXJyZW50VHJlZU5vZGUudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZXMgPSBHcm91cC5nZXRHcm91cE5hbWVzRm9yVGFzayhcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBncm91cE5hbWUgb2YgZ3JvdXBOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLmdldChncm91cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlTm9kZShbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLnNldChncm91cE5hbWUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VHJlZUxldmVsLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudmFsdWVzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VHJlZUxldmVsID0gbmV4dFRyZWVMZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U29ydGVkR3JvdXBzKCkge1xuICAgICAgICAvLyBncm91cHMua2V5cygpIHdpbGwgaW5pdGlhbGx5IGJlIGluIHRoZSBvcmRlciB0aGUgZW50cmllcyB3ZXJlIGFkZGVkLFxuICAgICAgICAvLyBzbyBlZmZlY3RpdmVseSByYW5kb20uXG4gICAgICAgIC8vIFJldHVybiBhIGR1cGxpY2F0ZSBtYXAsIHdpdGggdGhlIGtleXMgKHRoYXQgaXMsIGdyb3VwIG5hbWVzKSBzb3J0ZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyOlxuICAgICAgICByZXR1cm4gbmV3IEludGVybWVkaWF0ZVRhc2tHcm91cHNTdG9yYWdlKFxuICAgICAgICAgICAgWy4uLnRoaXMuZ3JvdXBzLmVudHJpZXMoKV0uc29ydCgpLFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBIZWFkaW5nIH0gZnJvbSAnLi9Hcm91cEhlYWRpbmcnO1xuXG4vKipcbiAqIFRhc2tHcm91cCBzdG9yZXMgYSBzaW5nbGUgZ3JvdXAgb2YgdGFza3MsIHRoYXQgYWxsIHNoYXJlIHRoZSBzYW1lIGdyb3VwIG5hbWVzLlxuICogVGFza0dyb3VwIG9iamVjdHMgYXJlIHN0b3JlZCBpbiBhIFRhc2tHcm91cHMgb2JqZWN0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgdXNlciBzdXBwbGllZCB0aGVzZSAnZ3JvdXAgYnknIGxpbmVzOlxuICogICBncm91cCBieSBmb2xkZXJcbiAqICAgZ3JvdXAgYnkgZmlsZW5hbWVcbiAqICAgZ3JvdXAgYnkgaGVhZGluZ1xuICogVGhlbiB0aGUgbmFtZXMgb2Ygb25lIFRhc2tHcm91cCBtaWdodCBiZSB0aGlzOlxuICogICBTb21lL0ZvbGRlci9Jbi9UaGUvVmF1bHRcbiAqICAgQSBQYXJ0aWN1bGFyIEZpbGUgTmFtZVxuICogICBNeSBsb3ZlbHkgaGVhZGluZ1xuICogQW5kIHRoZSBUYXNrR3JvdXAgd291bGQgc3RvcmUgYWxsIHRoZSB0YXNrcyBmcm9tIHRoYXQgbG9jYXRpb25cbiAqIHRoYXQgbWF0Y2ggdGhlIHRhc2sgYmxvY2sncyBmaWx0ZXJzLCBpbiB0aGUgdGFzayBibG9jaydzIHNvcnQgb3JkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tHcm91cCB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWVzIG9mIHRoZSBncm91cCBwcm9wZXJ0aWVzIGZvciB0aGlzIHNldCBvZiB0YXNrcyxcbiAgICAgKiBpbiB0aGUgb3JkZXIgb2YgdGhlICdncm91cCBieScgbGluZXMgdGhlIHVzZXIgc3BlY2lmaWVkXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGdyb3Vwczogc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVhZGluZ3MgdG8gYmUgZGlzcGxheWVkIGluIGZyb250IG9mIHRoaXMgc2V0IG9mIHRhc2tzLFxuICAgICAqIHdoZW4gcmVuZGVyaW5nIHRoZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogSXQgb25seSBjb250YWlucyB0aGUgbWluaW1hbCBzZXQgb2YgaGVhZGluZ3MgcmVxdWlyZWQgdG8gc2VwYXJhdGVcbiAgICAgKiB0aGlzIGdyb3VwIG9mIHRhc2tzIGZyb20gdGhlIHByZXZpb3VzIGdyb3VwIG9mIHRhc2tzLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgd2VyZSBubyAnZ3JvdXAgYnknIGluc3RydWN0aW9ucyBpbiB0aGUgdGFza3MgY29kZSBibG9jayxcbiAgICAgKiB0aGlzIHdpbGwgYmUgZW1wdHkuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGdyb3VwSGVhZGluZ3M6IEdyb3VwSGVhZGluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSB0YXNrcyB0aGF0IG1hdGNoIHRoZSB1c2VyJ3MgZmlsdGVycyBhbmQgdGhhdCBoYXZlIHRoZVxuICAgICAqIGdyb3VwIG5hbWVzIGV4YWN0bHkgbWF0Y2hpbmcgZ3JvdXBzKCkuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHRhc2tzOiBUYXNrW107XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgVGFza0dyb3VwXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZ3JvdXBzIC0gU2VlIHRoaXMuZ3JvdXBzIGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtHcm91cEhlYWRpbmdbXX0gZ3JvdXBIZWFkaW5ncyAtIFNlZSB0aGlzLmdyb3VwSGVhZGluZ3MgZm9yIGRldGFpbHNcbiAgICAgKiBAcGFyYW0gdGFza3Mge1Rhc2tbXX0gLSBTZWUgdGhpcy50YXNrcyBmb3IgZGV0YWlsc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBncm91cHM6IHN0cmluZ1tdLFxuICAgICAgICBncm91cEhlYWRpbmdzOiBHcm91cEhlYWRpbmdbXSxcbiAgICAgICAgdGFza3M6IFRhc2tbXSxcbiAgICApIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG4gICAgICAgIHRoaXMuZ3JvdXBIZWFkaW5ncyA9IGdyb3VwSGVhZGluZ3M7XG4gICAgICAgIHRoaXMudGFza3MgPSB0YXNrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcmtkb3duLWZvcm1hdCByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIHRhc2tzIGluIHRoaXMgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgZm9yIHRlc3RpbmcuXG4gICAgICovXG4gICAgcHVibGljIHRhc2tzQXNTdHJpbmdPZkxpbmVzKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRoaXMudGFza3MpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRhc2sgZ3JvdXAsIGluY2x1ZGluZyBuYW1lc1xuICAgICAqIGFuZCBoZWFkaW5ncyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyB1c2VkIGluIHNuYXBzaG90IHRlc3RpbmcsIHNvIGlmIHRoZSBmb3JtYXQgaXNcbiAgICAgKiBjaGFuZ2VkLCB0aGUgc25hcHNob3RzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJ1xcbic7XG4gICAgICAgIG91dHB1dCArPSBgR3JvdXAgbmFtZXM6IFske3RoaXMuZ3JvdXBzfV1cXG5gO1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiB0aGlzLmdyb3VwSGVhZGluZ3MpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIGhlYWRpbmdzIG1pbWljIHRoZSBiZWhhdmlvdXIgb2YgUXVlcnlSZW5kZXJlcixcbiAgICAgICAgICAgIC8vIHdoaWNoIHVzZXMgJ2g0JywgJ2g1JyBhbmQgJ2g2JyBmb3IgbmVzdGVkIGdyb3Vwcy5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdQcmVmaXggPSAnIycucmVwZWF0KDQgKyBoZWFkaW5nLm5lc3RpbmdMZXZlbCk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYCR7aGVhZGluZ1ByZWZpeH0gJHtoZWFkaW5nLm5hbWV9XFxuYDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCArPSB0aGlzLnRhc2tzQXNTdHJpbmdPZkxpbmVzKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgR3JvdXBpbmcgfSBmcm9tICcuLi9RdWVyeSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IEdyb3VwSGVhZGluZ3MgfSBmcm9tICcuL0dyb3VwSGVhZGluZ3MnO1xuaW1wb3J0IHsgSW50ZXJtZWRpYXRlVGFza0dyb3VwcyB9IGZyb20gJy4vSW50ZXJtZWRpYXRlVGFza0dyb3Vwcyc7XG5pbXBvcnQgeyBUYXNrR3JvdXAgfSBmcm9tICcuL1Rhc2tHcm91cCc7XG5cbi8qKlxuICogVGFza0dyb3VwIHN0b3JlcyBhbGwgdGhlIGdyb3VwcyBvZiB0YXNrcyBnZW5lcmF0ZWQgYnkgYW55ICdncm91cCBieSdcbiAqIGluc3RydWN0aW9ucyBpbiB0aGUgdGFzayBibG9jay5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tHcm91cHMge1xuICAgIHByaXZhdGUgX2dyb3VwczogVGFza0dyb3VwW10gPSBuZXcgQXJyYXk8VGFza0dyb3VwPigpO1xuICAgIHByaXZhdGUgX3RvdGFsVGFza0NvdW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBUYXNrR3JvdXBzXG4gICAgICogQHBhcmFtIHtHcm91cGluZ1tdfSBncm91cHMgLSAwIG9yIG1vcmUgR3JvdXBpbmcgdmFsdWVzLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSBwZXIgJ2dyb3VwIGJ5JyBsaW5lIGluIHRoZSB0YXNrIHF1ZXJ5IGJsb2NrXG4gICAgICogQHBhcmFtIHtUYXNrW119IHRhc2tzIC0gMCBtb3JlIG1vcmUgVGFzayBvYmplY3RzLCB3aXRoIGFsbCB0aGUgdGFza3NcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZyB0aGUgcXVlcnksIGFscmVhZHkgaW4gc29ydCBvcmRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwczogR3JvdXBpbmdbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICAvLyBHcm91cGluZyBkb2Vzbid0IGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRhc2tzLCBhbmQgYWxsIHRoZSB0YXNrc1xuICAgICAgICAvLyB3aWxsIGJlIHNob3duIGluIGF0IGxlYXN0IG9uZSBncm91cC5cbiAgICAgICAgdGhpcy5fdG90YWxUYXNrQ291bnQgPSB0YXNrcy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbEdyb3VwcyA9IG5ldyBJbnRlcm1lZGlhdGVUYXNrR3JvdXBzKGdyb3VwcywgdGFza3MpO1xuICAgICAgICB0aGlzLmFkZFRhc2tzKGluaXRpYWxHcm91cHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBncm91cGVkIHRvZ2V0aGVyLCBhbmQgaW4gdGhlIG9yZGVyXG4gICAgICogdGhhdCB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHMoKTogVGFza0dyb3VwW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LlxuICAgICAqL1xuICAgIHB1YmxpYyB0b3RhbFRhc2tzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRhc2tDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgdGFzayBncm91cHMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyB1c2VkIGluIHNuYXBzaG90IHRlc3RpbmcsIHNvIGlmIHRoZSBmb3JtYXQgaXNcbiAgICAgKiBjaGFuZ2VkLCB0aGUgc25hcHNob3RzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdGFza0dyb3VwIG9mIHRoaXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gdGFza0dyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbi0tLVxcbic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxUYXNrc0NvdW50ID0gdGhpcy50b3RhbFRhc2tzQ291bnQoKTtcbiAgICAgICAgb3V0cHV0ICs9IGBcXG4ke3RvdGFsVGFza3NDb3VudH0gdGFza3NcXG5gO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVGFza3MoaW5pdGlhbEdyb3VwczogSW50ZXJtZWRpYXRlVGFza0dyb3Vwcykge1xuICAgICAgICAvLyBHZXQgdGhlIGhlYWRpbmdzXG4gICAgICAgIGNvbnN0IGdyb3VwZXIgPSBuZXcgR3JvdXBIZWFkaW5ncyhpbml0aWFsR3JvdXBzLmdyb3Vwcyk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBjb250YWluZXIgb2YgYWxsIHRoZSBncm91cHNcbiAgICAgICAgZm9yIChjb25zdCBbZ3JvdXBzLCB0YXNrc10gb2YgaW5pdGlhbEdyb3Vwcy5ncm91cHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSGVhZGluZ3MgPSBncm91cGVyLmdldEhlYWRpbmdzRm9yVGFza0dyb3VwKGdyb3Vwcyk7XG4gICAgICAgICAgICBjb25zdCB0YXNrR3JvdXAgPSBuZXcgVGFza0dyb3VwKGdyb3VwcywgZ3JvdXBIZWFkaW5ncywgdGFza3MpO1xuICAgICAgICAgICAgdGhpcy5hZGQodGFza0dyb3VwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkKHRhc2tHcm91cDogVGFza0dyb3VwKSB7XG4gICAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKHRhc2tHcm91cCk7XG4gICAgfVxufVxuIiwgImltcG9ydCAqIGFzIGNocm9ubyBmcm9tICdjaHJvbm8tbm9kZSc7XG5cbmV4cG9ydCBjbGFzcyBEYXRlUGFyc2VyIHtcbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlRGF0ZShcbiAgICAgICAgaW5wdXQ6IHN0cmluZyxcbiAgICAgICAgZm9yd2FyZERhdGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICApOiBtb21lbnQuTW9tZW50IHtcbiAgICAgICAgLy8gVXNpbmcgc3RhcnQgb2YgZGF5IHRvIGNvcnJlY3RseSBtYXRjaCBvbiBjb21wYXJpc29uIHdpdGggb3RoZXIgZGF0ZXMgKGxpa2UgZXF1YWxpdHkpLlxuICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgICAubW9tZW50KFxuICAgICAgICAgICAgICAgIGNocm9uby5wYXJzZURhdGUoaW5wdXQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkRGF0ZTogZm9yd2FyZERhdGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3RhcnRPZignZGF5Jyk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZWFjaCB0eXBlIG9mIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZGVyaXZlZCBjbGFzcyBTdGFydERhdGVGaWVsZCBpbXBsZW1lbnRzIHRoZSBwYXJzaW5nXG4gKiBvZiAnc3RhcnRzJyBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGhlIG5hbWUgJ0ZpZWxkJyBtYXkgc2VlbSBjb25mdXNpbmcsIGFzIGl0IG1pZ2h0IGN1cnJlbnRseSBiZVxuICogZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgd29yZCAnRmlsdGVyJyBpbiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBDdXJyZW50IHRoaW5raW5nIGlzIHRoYXQgaXQgbWF5IHdlbGwgZXZvbHZlIGxhdGVyIHRvIGFsc28gaW1wbGVtZW50XG4gKiB0aGUgcHJlc2VuY2UgYW5kIGFic2VuY2Ugc2VhcmNoZXMgYXMgd2VsbFxuICogKHN1Y2ggJ25vIHN0YXJ0IGRhdGUnIGFuZCAnaGFzIHN0YXJ0IGRhdGUnKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZpZWxkIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNsYXNzIGNhbiBwYXJzZSB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNoZWNrcyB3aGV0aGVyIHRoZSBsaW5lIG1hdGNoZXNcbiAgICAgKiB0aGlzLmZpbHRlclJlZ2V4cCgpLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSBgYGB0YXNrc2BgYCBibG9jay5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHRoaXMuZmlsdGVyUmVnZXhwKCksIGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIEZpbHRlciBmdW5jdGlvbiBvciBhbiBlcnJvciBzdHJpbmcsXG4gICAgICogd2hpY2ggYXJlIGJvdGggd3JhcHBlZCBpbiBhIEZpbHRlck9yRXJyb3JNZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKFxuICAgICAgICBsaW5lOiBzdHJpbmcsXG4gICAgKTogRmlsdGVyT3JFcnJvck1lc3NhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBnaXZlbiBsaW5lIG1hdGNoIHRoZSBnaXZlbiBmaWx0ZXI/XG4gICAgICogQHBhcmFtIGZpbHRlciAtIEEgUmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhhdCBzcGVjaWZpZXMgb25lIHF1ZXJ5IGluc3RydWN0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICBPciBudWxsLCBpZiB0aGUgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCByZWdleHAtYmFzZWQgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrIHF1ZXJ5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGxpbmVNYXRjaGVzRmlsdGVyKFxuICAgICAgICBmaWx0ZXI6IFJlZ0V4cCB8IG51bGwsXG4gICAgICAgIGxpbmU6IHN0cmluZyxcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci50ZXN0KGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtYXRjaCBmb3IgdGhlIGdpdmVuIGZpbHRlciwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBwYXJhbSBmaWx0ZXJSZWdleHAgLSBBIFJlZ0V4cCByZWd1bGFyIGV4cHJlc3Npb24sIHRoYXQgc3BlY2lmaWVzIG9uZSBxdWVyeSBpbnN0cnVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgT3IgbnVsbCwgaWYgdGhlIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgcmVnZXhwLWJhc2VkIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgdGFza3MgY29kZSBibG9jayBxdWVyeS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRNYXRjaChcbiAgICAgICAgZmlsdGVyUmVnZXhwOiBSZWdFeHAgfCBudWxsLFxuICAgICAgICBsaW5lOiBzdHJpbmcsXG4gICAgKTogUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwge1xuICAgICAgICBpZiAoZmlsdGVyUmVnZXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5tYXRjaChmaWx0ZXJSZWdleHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGZpbHRlcmluZyBUYXNrcyBieSBpbnNwZWN0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLlxuICAgICAqIE9yIG51bGwsIGlmIHRoaXMgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHJlZ2V4LWJhc2VkIGluc3RydWN0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsdGVyUmVnZXhwKCk6IFJlZ0V4cCB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhpcyBmaWVsZCwgdG8gYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBUaGlzIHVzdWFsbHkgbWF0Y2hlcyB0aGUgaW5zdHJ1Y3Rpb24gbmFtZSwgYnV0IGRvZXMgbm90IGFsd2F5c1xuICAgICAqIChzZWUgc3RhcnQgYW5kIHN0YXJ0cykuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBmaWVsZE5hbWUoKTogc3RyaW5nO1xufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuXG4vKipcbiAqIEEgZmlsdGVyaW5nIGZ1bmN0aW9uLCB0aGF0IHRha2VzIGEgVGFzayBvYmplY3QgYW5kIHJldHVybnNcbiAqIHdoZXRoZXIgaXQgbWF0Y2hlcyBhIHBhcnRpY3VsYXIgZmlsdGVyaW5nIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgdHlwZSBGaWx0ZXIgPSAodGFzazogVGFzaykgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBBIGNsYXNzIHdoaWNoIHN0b3JlcyBvbmUgb2Y6XG4gKiAtIEEgRmlsdGVyXG4gKiAtIEFuIGVycm9yIG1lc3NhZ2VcbiAqXG4gKiBUaGlzIGlzIHJlYWxseSBjdXJyZW50bHkgYSBjb252ZW5pZW5jZSBmb3IgcmV0dXJuaW5nIGRhdGUgZnJvbVxuICogRmllbGQuY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UoKSBhbmQgZGVyaXZlZCBjbGFzc2VzLlxuICpcbiAqIExhdGVyLCBpdCBtYXkgZ2FpbiBoZWxwZXIgZnVuY3Rpb25zIGZvciBjb25zdHJ1Y3RpbmcgcGFyc2VyIGVycm9yIG1lc3NhZ2VzLFxuICogYXMgY3VycmVudGx5IHRoZXNlIGFyZSBjcmVhdGVkIGJ5IHNvbWUgcmF0aGVyIHJlcGV0aXRpb3VzIGNvZGUsIGFuZCBhbHNvXG4gKiB0aGVyZSBpcyBzY29wZSBmb3IgbWFraW5nIHRoZXNlIG1lc3NhZ2VzIG1vcmUgaW5mb3JtYXRpdmUgKGluY2x1ZGluZyB0aGVcbiAqIHByb2JsZW0gbGluZSwgYW5kIHBlcmhhcHMgbGlzdGluZyBhbGxvd2VkIG9wdGlvbnMpLlxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgIGZpbHRlcjogRmlsdGVyIHwgdW5kZWZpbmVkO1xuICAgIGVycm9yOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlUGFyc2VyIH0gZnJvbSAnLi4vRGF0ZVBhcnNlcic7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi4vLi4vU29ydCc7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2hhcHBlbnMnIHNlYXJjaCBpbnN0cnVjdGlvbiwgd2hpY2ggc2VhcmNoZXMgYWxsIG9mXG4gKiBzdGFydCwgc2NoZWR1bGVkIGFuZCBkdWUgZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXBwZW5zRGF0ZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGhhcHBlbnNSZWdleHAgPSAvXmhhcHBlbnMgKGJlZm9yZXxhZnRlcnxvbik/ID8oLiopLztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBpbnN0cnVjdGlvbkZvckZpZWxkUHJlc2VuY2UgPSAnaGFzIGhhcHBlbnMgZGF0ZSc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgaW5zdHJ1Y3Rpb25Gb3JGaWVsZEFic2VuY2UgPSAnbm8gaGFwcGVucyBkYXRlJztcblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGluZSA9PT0gSGFwcGVuc0RhdGVGaWVsZC5pbnN0cnVjdGlvbkZvckZpZWxkUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lID09PSBIYXBwZW5zRGF0ZUZpZWxkLmluc3RydWN0aW9uRm9yRmllbGRBYnNlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoKTtcblxuICAgICAgICBpZiAobGluZSA9PT0gSGFwcGVuc0RhdGVGaWVsZC5pbnN0cnVjdGlvbkZvckZpZWxkUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZXModGFzaykuc29tZSgoZGF0ZSkgPT4gZGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUgPT09IEhhcHBlbnNEYXRlRmllbGQuaW5zdHJ1Y3Rpb25Gb3JGaWVsZEFic2VuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PlxuICAgICAgICAgICAgICAgICF0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhcHBlbnNNYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnZXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAoaGFwcGVuc01hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJEYXRlID0gRGF0ZVBhcnNlci5wYXJzZURhdGUoaGFwcGVuc01hdGNoWzJdKTtcbiAgICAgICAgICAgIGlmICghZmlsdGVyRGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgaGFwcGVucyBkYXRlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhcHBlbnNNYXRjaFsxXSA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlcyh0YXNrKS5zb21lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRlKSA9PiBkYXRlICYmIGRhdGUuaXNCZWZvcmUoZmlsdGVyRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFwcGVuc01hdGNoWzFdID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZXModGFzaykuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0ZSkgPT4gZGF0ZSAmJiBkYXRlLmlzQWZ0ZXIoZmlsdGVyRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZXModGFzaykuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0ZSkgPT4gZGF0ZSAmJiBkYXRlLmlzU2FtZShmaWx0ZXJEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAoaGFwcGVucyBkYXRlKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVhcmxpZXN0IG9mIHRoZSBkYXRlcyB1c2VkIGJ5ICdoYXBwZW5zJyBpbiB0aGUgZ2l2ZW4gdGFzaywgb3IgbnVsbCBpZiBub25lIHNldC5cbiAgICAgKlxuICAgICAqIEdlbmVyYWxseSBzcGVha2luZywgdGhlIGVhcmxpZXN0IGRhdGUgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgaGlnaGVzdCBwcmlvcml0eSxcbiAgICAgKiBhcyBpdCBpcyB0aGUgZmlyc3QgcG9pbnQgYXQgd2hpY2ggdGhlIHVzZXIgbWlnaHQgd2lzaCB0byBhY3Qgb24gdGhlIHRhc2suXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZWFybGllc3REYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaGFwcGVuc0RhdGVzID0gbmV3IEhhcHBlbnNEYXRlRmllbGQoKS5kYXRlcyh0YXNrKTtcbiAgICAgICAgY29uc3Qgc29ydGVkSGFwcGVuc0RhdGVzID0gaGFwcGVuc0RhdGVzLnNvcnQoU29ydC5jb21wYXJlQnlEYXRlKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEhhcHBlbnNEYXRlc1swXTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnZXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiBIYXBwZW5zRGF0ZUZpZWxkLmhhcHBlbnNSZWdleHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrJ3Mgc3RhcnQsIHNjaGVkdWxlZCBhbmQgZHVlIGRhdGVzLCBhbnkgb3IgYWxsIG9mIHdoaWNoIG1heSBiZSBudWxsLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkYXRlcyh0YXNrOiBUYXNrKTogKE1vbWVudCB8IG51bGwpW10ge1xuICAgICAgICByZXR1cm4gQXJyYXkub2YodGFzay5zdGFydERhdGUsIHRhc2suc2NoZWR1bGVkRGF0ZSwgdGFzay5kdWVEYXRlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnaGFwcGVucyc7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgR3JvdXBpbmcsIEdyb3VwaW5nUHJvcGVydHkgfSBmcm9tICcuLi9RdWVyeSc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IFByaW9yaXR5IH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBUYXNrR3JvdXBzIH0gZnJvbSAnLi9UYXNrR3JvdXBzJztcbmltcG9ydCB7IEhhcHBlbnNEYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9IYXBwZW5zRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBBIG5hbWluZyBmdW5jdGlvbiwgdGhhdCB0YWtlcyBhIFRhc2sgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdyb3VwIHByb3BlcnR5IG5hbWVcbiAqL1xudHlwZSBHcm91cGVyID0gKHRhc2s6IFRhc2spID0+IHN0cmluZ1tdO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSAnZ3JvdXAgYnknIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXAge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGdyb3VwRGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREIGRkZGQnO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYSBsaXN0IG9mIHRhc2tzLCBhY2NvcmRpbmcgdG8gb25lIG9yIG1vcmUgdGFzayBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIGdyb3VwaW5nIDAgb3IgbW9yZSBHcm91cGluZyB2YWx1ZXMsIG9uZSBwZXIgJ2dyb3VwIGJ5JyBsaW5lXG4gICAgICogQHBhcmFtIHRhc2tzIFRoZSB0YXNrcyB0aGF0IG1hdGNoIHRoZSB0YXNrIGJsb2NrJ3MgUXVlcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJ5KGdyb3VwaW5nOiBHcm91cGluZ1tdLCB0YXNrczogVGFza1tdKTogVGFza0dyb3VwcyB7XG4gICAgICAgIHJldHVybiBuZXcgVGFza0dyb3Vwcyhncm91cGluZywgdGFza3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJvcGVydGllcyBvZiBhIHNpbmdsZSB0YXNrIGZvciB0aGUgcGFzc2VkIGdyb3VwaW5nIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEdyb3VwTmFtZXNGb3JUYXNrKFxuICAgICAgICBwcm9wZXJ0eTogR3JvdXBpbmdQcm9wZXJ0eSxcbiAgICAgICAgdGFzazogVGFzayxcbiAgICApOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGdyb3VwZXIgPSBHcm91cC5ncm91cGVyc1twcm9wZXJ0eV07XG4gICAgICAgIHJldHVybiBncm91cGVyKHRhc2spO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwZXJzOiBSZWNvcmQ8R3JvdXBpbmdQcm9wZXJ0eSwgR3JvdXBlcj4gPSB7XG4gICAgICAgIGJhY2tsaW5rOiBHcm91cC5ncm91cEJ5QmFja2xpbmssXG4gICAgICAgIGRvbmU6IEdyb3VwLmdyb3VwQnlEb25lRGF0ZSxcbiAgICAgICAgZHVlOiBHcm91cC5ncm91cEJ5RHVlRGF0ZSxcbiAgICAgICAgZmlsZW5hbWU6IEdyb3VwLmdyb3VwQnlGaWxlTmFtZSxcbiAgICAgICAgZm9sZGVyOiBHcm91cC5ncm91cEJ5Rm9sZGVyLFxuICAgICAgICBoYXBwZW5zOiBHcm91cC5ncm91cEJ5SGFwcGVuc0RhdGUsXG4gICAgICAgIGhlYWRpbmc6IEdyb3VwLmdyb3VwQnlIZWFkaW5nLFxuICAgICAgICBwYXRoOiBHcm91cC5ncm91cEJ5UGF0aCxcbiAgICAgICAgcHJpb3JpdHk6IEdyb3VwLmdyb3VwQnlQcmlvcml0eSxcbiAgICAgICAgcmVjdXJyZW5jZTogR3JvdXAuZ3JvdXBCeVJlY3VycmVuY2UsXG4gICAgICAgIHJlY3VycmluZzogR3JvdXAuZ3JvdXBCeVJlY3VycmluZyxcbiAgICAgICAgcm9vdDogR3JvdXAuZ3JvdXBCeVJvb3QsXG4gICAgICAgIHNjaGVkdWxlZDogR3JvdXAuZ3JvdXBCeVNjaGVkdWxlZERhdGUsXG4gICAgICAgIHN0YXJ0OiBHcm91cC5ncm91cEJ5U3RhcnREYXRlLFxuICAgICAgICBzdGF0dXM6IEdyb3VwLmdyb3VwQnlTdGF0dXMsXG4gICAgICAgIHRhZ3M6IEdyb3VwLmdyb3VwQnlUYWdzLFxuICAgIH07XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cEJ5UHJpb3JpdHkodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgbGV0IHByaW9yaXR5TmFtZSA9ICdFUlJPUic7XG4gICAgICAgIHN3aXRjaCAodGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5IaWdoOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdIaWdoJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuTWVkaXVtOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdNZWRpdW0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5Ob25lOlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdOb25lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuTG93OlxuICAgICAgICAgICAgICAgIHByaW9yaXR5TmFtZSA9ICdMb3cnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYFByaW9yaXR5ICR7dGFzay5wcmlvcml0eX06ICR7cHJpb3JpdHlOYW1lfWBdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlSZWN1cnJlbmNlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFzay5yZWN1cnJlbmNlIS50b1RleHQoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWydOb25lJ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cEJ5UmVjdXJyaW5nKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ1JlY3VycmluZyddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsnTm90IFJlY3VycmluZyddO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeVN0YXJ0RGF0ZSh0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gW0dyb3VwLnN0cmluZ0Zyb21EYXRlKHRhc2suc3RhcnREYXRlLCAnc3RhcnQnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeVNjaGVkdWxlZERhdGUodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtHcm91cC5zdHJpbmdGcm9tRGF0ZSh0YXNrLnNjaGVkdWxlZERhdGUsICdzY2hlZHVsZWQnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUR1ZURhdGUodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFtHcm91cC5zdHJpbmdGcm9tRGF0ZSh0YXNrLmR1ZURhdGUsICdkdWUnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeURvbmVEYXRlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbR3JvdXAuc3RyaW5nRnJvbURhdGUodGFzay5kb25lRGF0ZSwgJ2RvbmUnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUhhcHBlbnNEYXRlKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0RGF0ZUlmQW55ID0gbmV3IEhhcHBlbnNEYXRlRmllbGQoKS5lYXJsaWVzdERhdGUodGFzayk7XG4gICAgICAgIHJldHVybiBbR3JvdXAuc3RyaW5nRnJvbURhdGUoZWFybGllc3REYXRlSWZBbnksICdoYXBwZW5zJyldO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHN0cmluZ0Zyb21EYXRlKFxuICAgICAgICBkYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCxcbiAgICAgICAgZmllbGQ6IHN0cmluZyxcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBpZiAoZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdObyAnICsgZmllbGQgKyAnIGRhdGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlLmZvcm1hdChHcm91cC5ncm91cERhdGVGb3JtYXQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlQYXRoKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIG1hZGUgc3RyaWN0ZXI/XG4gICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSBvZiBnZXR0aW5nIHRoZSBmaWxlIG5hbWU/XG4gICAgICAgIHJldHVybiBbdGFzay5wYXRoLnJlcGxhY2UoJy5tZCcsICcnKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUZvbGRlcih0YXNrOiBUYXNrKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBwYXRoID0gdGFzay5wYXRoO1xuICAgICAgICBjb25zdCBmaWxlTmFtZVdpdGhFeHRlbnNpb24gPSB0YXNrLmZpbGVuYW1lICsgJy5tZCc7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHBhdGguc3Vic3RyaW5nKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHBhdGgubGFzdEluZGV4T2YoZmlsZU5hbWVXaXRoRXh0ZW5zaW9uKSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZvbGRlciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBbJy8nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZvbGRlcl07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUZpbGVOYW1lKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIC8vIE5vdGUgY3VycmVudCBsaW1pdGF0aW9uOiBUYXNrcyBmcm9tIGRpZmZlcmVudCBub3RlcyB3aXRoIHRoZVxuICAgICAgICAvLyBzYW1lIG5hbWUgd2lsbCBiZSBncm91cGVkIHRvZ2V0aGVyLCBldmVuIHRob3VnaCB0aGV5IGFyZSBpblxuICAgICAgICAvLyBkaWZmZXJlbnQgZmlsZXMgYW5kIHRoZWlyIGxpbmtzIHdpbGwgbG9vayBkaWZmZXJlbnQuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGFzay5maWxlbmFtZTtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gWydVbmtub3duIExvY2F0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmaWxlbmFtZV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeVJvb3QodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRhc2sucGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gcGF0aC5pbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChzZXBhcmF0b3JJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnLyddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXggKyAxKV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUJhY2tsaW5rKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGxpbmtUZXh0ID0gdGFzay5nZXRMaW5rVGV4dCh7IGlzRmlsZW5hbWVVbmlxdWU6IHRydWUgfSk7XG4gICAgICAgIGlmIChsaW5rVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnVW5rbm93biBMb2NhdGlvbiddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGlua1RleHRdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlTdGF0dXModGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFt0YXNrLnN0YXR1c107XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBCeUhlYWRpbmcodGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGFzay5wcmVjZWRpbmdIZWFkZXIgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRhc2sucHJlY2VkaW5nSGVhZGVyLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbJyhObyBoZWFkaW5nKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFzay5wcmVjZWRpbmdIZWFkZXJdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3VwQnlUYWdzKHRhc2s6IFRhc2spOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmICh0YXNrLnRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbJyhObyB0YWdzKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrLnRhZ3M7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIFRleHRGaWVsZCBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRvIGhlbHAgaW1wbGVtZW50XG4gKiBhbGwgdGhlIGZpbHRlciBpbnN0cnVjdGlvbnMgdGhhdCBhY3Qgb24gYSBzaW5nbGUgdHlwZSBvZiBzdHJpbmdcbiAqIHZhbHVlLCBzdWNoIGFzIHRoZSBkZXNjcmlwdGlvbiBvciBmaWxlIHBhdGguXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUZXh0RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgcHJpdmF0ZSBtYXliZU5lZ2F0ZShtYXRjaDogYm9vbGVhbiwgZmlsdGVyTWV0aG9kOiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlck1ldGhvZC5tYXRjaCgvbm90LykgPyAhbWF0Y2ggOiBtYXRjaDtcbiAgICB9XG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZpbHRlck9yRXJyb3JNZXNzYWdlKCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5maWx0ZXJSZWdleHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyTWV0aG9kID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBpZiAoWydpbmNsdWRlcycsICdkb2VzIG5vdCBpbmNsdWRlJ10uaW5jbHVkZXMoZmlsdGVyTWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZU5lZ2F0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFRleHRGaWVsZC5zdHJpbmdJbmNsdWRlc0Nhc2VJbnNlbnNpdGl2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlKHRhc2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlck1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgWydyZWdleCBtYXRjaGVzJywgJ3JlZ2V4IGRvZXMgbm90IG1hdGNoJ10uaW5jbHVkZXMoZmlsdGVyTWV0aG9kKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ291cnRlc3kgb2YgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDM2OTEvamF2YXNjcmlwdC1yZWdleC10by1tYXRjaC1hLXJlZ2V4XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXhQYXR0ZXJuID1cbiAgICAgICAgICAgICAgICAgICAgL1xcLygoPyFbKis/XSkoPzpbXlxcclxcblsvXFxcXF18XFxcXC58XFxbKD86W15cXHJcXG5cXF1cXFxcXXxcXFxcLikqXSkrKVxcLygoPzpnKD86aW0/fG1pPyk/fGkoPzpnbT98bWc/KT98bSg/OmdpP3xpZz8pPyk/KS87XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBtYXRjaFsyXS5tYXRjaChyZWdleFBhdHRlcm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVOZWdhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSh0YXNrKS5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChxdWVyeVsxXSwgcXVlcnlbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgIT09IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgY2Fubm90IHBhcnNlIHJlZ2V4ICgke3RoaXMuZmllbGROYW1lKCl9KTsgY2hlY2sgeW91ciBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIGZvciB5b3VyIHF1ZXJ5YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5nSW5jbHVkZXNDYXNlSW5zZW5zaXRpdmUoXG4gICAgICAgIGhheXN0YWNrOiBzdHJpbmcsXG4gICAgICAgIG5lZWRsZTogc3RyaW5nLFxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2tcbiAgICAgICAgICAgIC50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICAgICAgICAuaW5jbHVkZXMobmVlZGxlLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBgXiR7dGhpcy5maWVsZE5hbWUoKX0gKGluY2x1ZGVzfGRvZXMgbm90IGluY2x1ZGV8cmVnZXggbWF0Y2hlc3xyZWdleCBkb2VzIG5vdCBtYXRjaCkgKC4qKWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGZpZWxkTmFtZSgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWVsZCdzIHZhbHVlLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIHZhbHVlIGlzIG51bGxcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgdmFsdWUodGFzazogVGFzayk6IHN0cmluZztcbn1cbiIsICJpbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IFRleHRGaWVsZCB9IGZyb20gJy4vVGV4dEZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAnZGVzY3JpcHRpb24nIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgRGVzY3JpcHRpb25GaWVsZC52YWx1ZSgpIHJldHVybnMgdGhlIGRlc2NyaXB0aW9uXG4gKiB3aXRoIHRoZSBnbG9iYWwgZmlsdGVyIChpZiBhbnkpIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXNjcmlwdGlvbkZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBwcm90ZWN0ZWQgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZGVzY3JpcHRpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGFzaydzIGRlc2NyaXB0aW9uLCB3aXRoIGFueSBnbG9iYWwgdGFnIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIC8vIFJlbW92ZSBnbG9iYWwgZmlsdGVyIGZyb20gZGVzY3JpcHRpb24gbWF0Y2ggaWYgcHJlc2VudC5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWF0Y2ggb25seSBvbiB0aGUgY29udGVudCBvZiB0aGUgdGFzaywgbm90XG4gICAgICAgIC8vIHRoZSBnbG9iYWwgZmlsdGVyLlxuICAgICAgICBjb25zdCBnbG9iYWxGaWx0ZXIgPSBnZXRTZXR0aW5ncygpLmdsb2JhbEZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHRhc2suZGVzY3JpcHRpb24ucmVwbGFjZShnbG9iYWxGaWx0ZXIsICcnKS50cmltKCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIERhdGVGaWVsZCBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRvIGhlbHAgaW1wbGVtZW50XG4gKiBhbGwgdGhlIGZpbHRlciBpbnN0cnVjdGlvbnMgdGhhdCBhY3Qgb24gYSBzaW5nbGUgdHlwZSBvZiBkYXRlXG4gKiB2YWx1ZSwgc3VjaCBhcyB0aGUgZG9uZSBkYXRlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5zdHJ1Y3Rpb25Gb3JGaWVsZFByZXNlbmNlID0gYGhhcyAke3RoaXMuZmllbGROYW1lKCl9IGRhdGVgO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5zdHJ1Y3Rpb25Gb3JGaWVsZEFic2VuY2UgPSBgbm8gJHt0aGlzLmZpZWxkTmFtZSgpfSBkYXRlYDtcblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGluZSA9PT0gdGhpcy5pbnN0cnVjdGlvbkZvckZpZWxkUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lID09PSB0aGlzLmluc3RydWN0aW9uRm9yRmllbGRBYnNlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoKTtcblxuICAgICAgICBpZiAobGluZSA9PT0gdGhpcy5pbnN0cnVjdGlvbkZvckZpZWxkUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT4gdGhpcy5kYXRlKHRhc2spICE9PSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lID09PSB0aGlzLmluc3RydWN0aW9uRm9yRmllbGRBYnNlbmNlKSB7XG4gICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRoaXMuZGF0ZSh0YXNrKSA9PT0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnZXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckRhdGUgPSBEYXRlUGFyc2VyLnBhcnNlRGF0ZShtYXRjaFsyXSk7XG4gICAgICAgICAgICBpZiAoIWZpbHRlckRhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID1cbiAgICAgICAgICAgICAgICAgICAgJ2RvIG5vdCB1bmRlcnN0YW5kICcgKyB0aGlzLmZpZWxkTmFtZSgpICsgJyBkYXRlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnYmVmb3JlJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGUodGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0ZS5pc0JlZm9yZShmaWx0ZXJEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0gPT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGUuaXNBZnRlcihmaWx0ZXJEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZSh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRlLmlzU2FtZShmaWx0ZXJEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9XG4gICAgICAgICAgICAgICAgJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAoJyArXG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZE5hbWUoKSArXG4gICAgICAgICAgICAgICAgJyBkYXRlKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRhc2sncyB2YWx1ZSBmb3IgdGhpcyBkYXRlIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHRhc2sgLSBhIFRhc2sgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB0YXNrIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgcGFydGljdWxhciBkYXRlIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBtYXRjaC4gRm9yIGV4YW1wbGUsICdzdGFydHMnIHNlYXJjaGVzIG1hdGNoIGFsbCB0YXNrc1xuICAgICAqIHRoYXQgaGF2ZSBubyBzdGFydCBkYXRlLCB3aGljaCBiZWhhdmVzIGRpZmZlcmVudGx5IGZyb20gJ2R1ZScsICdkb25lJyBhbmRcbiAgICAgKiAnc2NoZWR1bGVkJyBzZWFyY2hlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCk6IGJvb2xlYW47XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2RvbmUnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIERvbmVEYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRvbmVSZWdleHAgPSAvXmRvbmUgKGJlZm9yZXxhZnRlcnxvbik/ID8oLiopLztcblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIERvbmVEYXRlRmllbGQuZG9uZVJlZ2V4cDtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2RvbmUnO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0YXNrLmRvbmVEYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2R1ZScgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRHVlRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBkdWVSZWdleHAgPSAvXmR1ZSAoYmVmb3JlfGFmdGVyfG9uKT8gPyguKikvO1xuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ2V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gRHVlRGF0ZUZpZWxkLmR1ZVJlZ2V4cDtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2R1ZSc7XG4gICAgfVxuICAgIHByb3RlY3RlZCBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suZHVlRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBzaW5nbGUgaW5zdHJ1Y3Rpb24gZm9yIGZpbHRlcmluZyB0YXNrcywgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHByZWRpY2F0ZS5cbiAqXG4gKiBUaGlzIGlzIHJlYWxseSBhIGhlbHBlciB0byBzaW1wbGlmeSB0aGUgaW1wbGVtZW50YXRpb24gb2YgaW5kaXZpZHVhbCBmaWx0ZXJcbiAqIGluc3RydWN0aW9ucywgaGlkaW5nIGF3YXkgdGhlIGRldGFpbHMgb2YgcGFyc2luZyBpbmRpdmlkdWFsIGluc3RydWN0aW9uIGxpbmVzLlxuICpcbiAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIGFjY2Vzc2VkIHZpYSB7QGxpbmsgRmlsdGVySW5zdHJ1Y3Rpb25zLmFkZH1cbiAqXG4gKiBAc2VlIEZpbHRlckluc3RydWN0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySW5zdHJ1Y3Rpb24ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2luc3RydWN0aW9uOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZmlsdGVyOiBGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvcjpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gLSBGdWxsIHRleHQgb2YgdGhlIGluc3RydWN0aW9uIGZvciB0aGUgZmlsdGVyOiBtdXN0IGJlIG1hdGNoZWQgZXhhY3RseVxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXI6IEZpbHRlcikge1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBsaW5lID09IHRoaXMuX2luc3RydWN0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZSgpO1xuXG4gICAgICAgIGlmIChsaW5lID09PSB0aGlzLl9pbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IHRoaXMuX2ZpbHRlcjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZXJyb3IgPSBgZG8gbm90IHVuZGVyc3RhbmQgZmlsdGVyOiAke2xpbmV9YDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb24gfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9uJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBjb2xsZWN0aW9uIG9mIGluc3RydWN0aW9ucyBmb3IgZmlsdGVyaW5nIHRhc2tzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgcHJpdmF0ZSByZWFkb25seSBfZmlsdGVycyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcbiAqICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCk7XG4gKlxuICogQHNlZSBGaWx0ZXJJbnN0cnVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySW5zdHJ1Y3Rpb25zIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9maWx0ZXJzOiBGaWx0ZXJJbnN0cnVjdGlvbltdID0gW107XG5cbiAgICBwdWJsaWMgYWRkKGluc3RydWN0aW9uOiBzdHJpbmcsIGZpbHRlcjogRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaChuZXcgRmlsdGVySW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGZpbHRlcikpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGZpbHRlci5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgICAgIGlmICh4LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZSgpO1xuICAgICAgICByZXN1bHQuZXJyb3IgPSBgZG8gbm90IHVuZGVyc3RhbmQgZmlsdGVyOiAke2xpbmV9YDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9ucyB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgaW1wbGVtZW50cyBvZiB7QGxpbmsgRmllbGR9XG4gKlxuICogVGhlIG5hbWVkIG9mIHRoZSBjbGFzcyBpcyB3ZWFrLiBJdCBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGZhY3QgdGhhdCB0aGVcbiAqIGNsYXNzIGlzIGVudGlyZWx5IGltcGxlbWVudGVkIHZpYSB0aGUge0BsaW5rIEZpbHRlckluc3RydWN0aW9uc30gY2xhc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfZmlsdGVycyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycy5jYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzICdleGNsdWRlIHN1Yi1pdGVtcycgZmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBFeGNsdWRlU3ViSXRlbXNGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdleGNsdWRlIHN1Yi1pdGVtcycsICh0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5pbmRlbnRhdGlvbiA9PT0gJycpIHJldHVybiB0cnVlOyAvLyBubyBpbmRlbnRhdGlvbiwgbm90IGEgc3ViaXRlbVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0QmxvY2txdW90ZU1hcmsgPSB0YXNrLmluZGVudGF0aW9uLmxhc3RJbmRleE9mKCc+Jyk7XG4gICAgICAgICAgICBpZiAobGFzdEJsb2NrcXVvdGVNYXJrID09PSAtMSkgcmV0dXJuIGZhbHNlOyAvLyBpbmRlbnRhdGlvbiBwcmVzZW50LCBub3QgaW4gYSBibG9ja3F1b3RlLCBzdWJpdGVtXG5cbiAgICAgICAgICAgIC8vIFVwIHRvIG9uZSBzcGFjZSBhbGxvd2VkIGFmdGVyIGxhc3QgPiBpbiBibG9ja3F1b3RlL2NhbGxvdXQsIG90aGVyd2lzZSBzdWJpdGVtXG4gICAgICAgICAgICByZXR1cm4gL14gPyQvLnRlc3QodGFzay5pbmRlbnRhdGlvbi5zbGljZShsYXN0QmxvY2txdW90ZU1hcmsgKyAxKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdleGNsdWRlJztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKiBTdXBwb3J0IHRoZSAnaGVhZGluZycgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEhlYWRpbmdGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByZWNlZGluZyBoZWFkaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGhlYWRpbmcgaXMgbnVsbFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRhc2sucHJlY2VkaW5nSGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wcmVjZWRpbmdIZWFkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKiBTdXBwb3J0IHRoZSAncGF0aCcgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbHNvIHNlYXJjaGVzIHRoZSBmaWxlIGV4dGVuc2lvbixcbiAqIHNvICdwYXRoIGluY2x1ZGVzIC5tZCcgd2lsbCB0eXBpY2FsbHkgbWF0Y2ggYWxsIHRhc2tzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3BhdGgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgcGF0aCBpbmNsdWRpbmcgZmlsZSBleHRlbnNpb24sIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgcGF0aCBpcyBudWxsXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5wYXRoO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQcmlvcml0eSwgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG5leHBvcnQgY2xhc3MgUHJpb3JpdHlGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBwcmlvcml0eVJlZ2V4cCA9XG4gICAgICAgIC9ecHJpb3JpdHkgKGlzICk/KGFib3ZlfGJlbG93KT8gPyhsb3d8bm9uZXxtZWRpdW18aGlnaCkvO1xuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlNYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnZXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAocHJpb3JpdHlNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyUHJpb3JpdHlTdHJpbmcgPSBwcmlvcml0eU1hdGNoWzNdO1xuICAgICAgICAgICAgbGV0IGZpbHRlclByaW9yaXR5OiBQcmlvcml0eSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpbHRlclByaW9yaXR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQcmlvcml0eSA9IFByaW9yaXR5Lk5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuTWVkaXVtO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbHRlclByaW9yaXR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIHByaW9yaXR5JztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHByaW9yaXR5TWF0Y2hbMl0gPT09ICdhYm92ZScpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrLnByaW9yaXR5LmxvY2FsZUNvbXBhcmUoZmlsdGVyUHJpb3JpdHkhKSA8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByaW9yaXR5TWF0Y2hbMl0gPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrLnByaW9yaXR5LmxvY2FsZUNvbXBhcmUoZmlsdGVyUHJpb3JpdHkhKSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PlxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByaW9yaXR5ID8gdGFzay5wcmlvcml0eSA9PT0gZmlsdGVyUHJpb3JpdHkgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKHByaW9yaXR5KSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAncHJpb3JpdHknO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIFByaW9yaXR5RmllbGQucHJpb3JpdHlSZWdleHA7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdzY2hlZHVsZWQnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlZERhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgc2NoZWR1bGVkUmVnZXhwID1cbiAgICAgICAgL15zY2hlZHVsZWQgKGJlZm9yZXxhZnRlcnxvbik/ID8oLiopLztcblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIFNjaGVkdWxlZERhdGVGaWVsZC5zY2hlZHVsZWRSZWdleHA7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzY2hlZHVsZWQnO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0YXNrLnNjaGVkdWxlZERhdGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAnc3RhcnRzJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFydERhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgc3RhcnRSZWdleHAgPSAvXnN0YXJ0cyAoYmVmb3JlfGFmdGVyfG9uKT8gPyguKikvO1xuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ2V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gU3RhcnREYXRlRmllbGQuc3RhcnRSZWdleHA7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHByb3RlY3RlZCBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suc3RhcnREYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIC8vIHJlZmVyZW5jZTogaHR0cHM6Ly9vYnNpZGlhbi10YXNrcy1ncm91cC5naXRodWIuaW8vb2JzaWRpYW4tdGFza3MvcXVlcmllcy9maWx0ZXJzLyNzdGFydC1kYXRlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkJztcblxuZXhwb3J0IGNsYXNzIFJlY3VycmluZ0ZpZWxkIGV4dGVuZHMgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdpcyByZWN1cnJpbmcnLCAodGFzaykgPT4gdGFzay5yZWN1cnJlbmNlICE9PSBudWxsKTtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5hZGQoXG4gICAgICAgICAgICAnaXMgbm90IHJlY3VycmluZycsXG4gICAgICAgICAgICAodGFzaykgPT4gdGFzay5yZWN1cnJlbmNlID09PSBudWxsLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdyZWN1cnJpbmcnO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXMsIFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQnO1xuXG5leHBvcnQgY2xhc3MgU3RhdHVzRmllbGQgZXh0ZW5kcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnZG9uZScsICh0YXNrOiBUYXNrKSA9PiB0YXNrLnN0YXR1cyA9PT0gU3RhdHVzLkRvbmUpO1xuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZChcbiAgICAgICAgICAgICdub3QgZG9uZScsXG4gICAgICAgICAgICAodGFzazogVGFzaykgPT4gdGFzay5zdGF0dXMgIT09IFN0YXR1cy5Eb25lLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGF0dXMnO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAndGFnJyBhbmQgJ3RhZ3MnIHNlYXJjaCBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGFncyBjYW4gYmUgc2VhcmNoZWQgZm9yIHdpdGggYW5kIHdpdGhvdXQgdGhlIGhhc2ggdGFnIGF0IHRoZSBzdGFydC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhZ3NGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICAvLyBIYW5kbGVzIGJvdGggd2F5cyBvZiByZWZlcmVuY2luZyB0aGUgdGFncyBxdWVyeS5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSB0YWdSZWdleHAgPVxuICAgICAgICAvXih0YWd8dGFncykgKGluY2x1ZGVzfGRvZXMgbm90IGluY2x1ZGV8aW5jbHVkZXxkbyBub3QgaW5jbHVkZSkgKC4qKS87XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgY29uc3QgdGFnTWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmZpbHRlclJlZ2V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKHRhZ01hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJNZXRob2QgPSB0YWdNYXRjaFsyXTtcblxuICAgICAgICAgICAgLy8gU2VhcmNoIGlzIGRvbmUgc2FucyB0aGUgaGFzaC4gSWYgaXQgaXMgcHJvdmlkZWQgdGhlbiBzdHJpcCBpdCBvZmYuXG4gICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB0YWdNYXRjaFszXS5yZXBsYWNlKC9eIy8sICcnKTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlck1ldGhvZCA9PT0gJ2luY2x1ZGUnIHx8IGZpbHRlck1ldGhvZCA9PT0gJ2luY2x1ZGVzJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgdGFzay50YWdzLmZpbmQoKHRhZykgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaC50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICB0YWdNYXRjaFsyXSA9PT0gJ2RvIG5vdCBpbmNsdWRlJyB8fFxuICAgICAgICAgICAgICAgIHRhZ01hdGNoWzJdID09PSAnZG9lcyBub3QgaW5jbHVkZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSAodGFzazogVGFzaykgPT5cbiAgICAgICAgICAgICAgICAgICAgdGFzay50YWdzLmZpbmQoKHRhZykgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaC50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgKSA9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKHRhZy90YWdzKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZmlsdGVyICh0YWcvdGFncyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBib3RoIGZvcm1zIG9mIHRoZSBmaWVsZCBuYW1lLCBzaW5ndWxhciBhbmQgcGx1cmFsLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAndGFnL3RhZ3MnO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdleHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIFRhZ3NGaWVsZC50YWdSZWdleHA7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IHBhcnNlIGFzIGJvb25QYXJzZSB9IGZyb20gJ2Jvb24tanMnO1xuaW1wb3J0IHR5cGUgeyBQb3N0Zml4RXhwcmVzc2lvbiB9IGZyb20gJ2Jvb24tanMnO1xuXG5pbXBvcnQgeyBwYXJzZUZpbHRlciB9IGZyb20gJy4uL0ZpbHRlclBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIEJvb2xlYW5GaWVsZCBpcyBhICdjb250YWluZXInIGZpZWxkIHR5cGUgdGhhdCBwYXJzZXMgYSBoaWdoLWxldmVsIGZpbHRlcmluZyBxdWVyeSBvZlxuICogdGhlIGZvcm1hdCAtLVxuICogICAgKGZpbHRlcjEpIEFORCAoKGZpbHRlcjIpIE9SIChmaWx0ZXIzKSlcbiAqIFRoZSBmaWx0ZXJzIGNhbiBiZSBtaXhlZCBhbmQgbWF0Y2hlZCB3aXRoIGFueSBib29sZWFuIG9wZXJhdG9ycyBhcyBsb25nIGFzIHRoZSBpbmRpdmlkdWFsIGZpbHRlcnMgYXJlXG4gKiB3cmFwcGVkIGluIGVpdGhlciBwYXJhbnRoZXNpcyBvciBxdW90ZXMgLS0gKGZpbHRlcjEpIG9yIFwiZmlsdGVyMVwiLlxuICogV2hhdCBoYXBwZW5zIGludGVybmFsbHkgaXMgdGhhdCB3aGVuIHRoZSBib29sZWFuIGZpZWxkIGlzIGFza2VkIHRvIGNyZWF0ZSBhIGZpbHRlciwgaXQgcGFyc2VzIHRoZSBib29sZWFuXG4gKiBxdWVyeSBpbnRvIGEgbG9naWNhbCBwb3N0Zml4IGV4cHJlc3Npb24gKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JldmVyc2VfUG9saXNoX25vdGF0aW9uKSxcbiAqIHdpdGggdGhlIGluZGl2aWR1YWwgZmlsdGVyIGNvbXBvbmVudHMgYXMgXCJpZGVudGlmaWVyXCIgdG9rZW5zLlxuICogVGhlc2UgaWRlbnRpZmllcnMgaGF2ZSBhbiBhc3NvY2lhdGVkIGFjdHVhbCBGaWx0ZXIgKHdoaWNoIGlzIGNhY2hlZCBkdXJpbmcgdGhlIHF1ZXJ5IHBhcnNpbmcpLlxuICogVGhlIHJldHVybmVkIEZpbHRlciBvZiB0aGUgd2hvbGUgYm9vbGVhbiBxdWVyeSBpcyBldmVudHVhbGx5IGEgZnVuY3Rpb24gdGhhdCBmb3IgZWFjaCBUYXNrIG9iamVjdCxcbiAqIGV2YWx1YXRlcyB0aGUgY29tcGxldGUgcG9zdGZpeCBleHByZXNzaW9uIGJ5IGdvaW5nIHRocm91Z2ggdGhlIGluZGl2aWR1YWwgZmlsdGVycyBhbmQgdGhlbiByZXNvbHZpbmdcbiAqIHRoZSBleHByZXNzaW9uIGludG8gYSBzaW5nbGUgYm9vbGVhbiBlbnRpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBiYXNpY0Jvb2xlYW5SZWdleHAgPSAvLiooQU5EfE9SfFhPUnxOT1QpXFxzKlsoXCJdLiovZztcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1cHBvcnRlZE9wZXJhdG9ycyA9IFsnQU5EJywgJ09SJywgJ1hPUicsICdOT1QnXTtcbiAgICBwcml2YXRlIHN1YkZpZWxkczogUmVjb3JkPHN0cmluZywgRmlsdGVyPiA9IHt9O1xuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ2V4cCgpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNpY0Jvb2xlYW5SZWdleHA7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lKGxpbmUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdib29sZWFuIHF1ZXJ5JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJ1aWxkcyBhIEZpbHRlciBmb3IgYSBjb21wbGV0ZSBib29sZWFuIHF1ZXJ5IGJ5OlxuICAgICAqIDEuIFByZXByb2Nlc3NpbmcgdGhlIGV4cHJlc3Npb24gaW50byBzb21ldGhpbmcgb3VyIGhlbHBlciBwYWNrYWdlLCBib29uLWpzLCBrbm93cyBob3cgdG8gYnVpbGQgYW4gZXhwcmVzc2lvbiBmb3IuXG4gICAgICogMi4gQ3JlYXRpbmcgYSBwb3N0Zml4IGxvZ2ljYWwgZXhwcmVzc2lvbiB1c2luZyBib29uLWpzLCB3aGljaCBoYXMgLVxuICAgICAqICAgIGEuIElkZW50aWZpZXJzIChsZWF2ZXMpLCB3aGljaCBhcmUgcmVndWxhciBGaWVsZCBmaWx0ZXJzIHJlcHJlc2VudGVkIGFzIHRoZWlyIHN0cmluZy5cbiAgICAgKiAgICBiLiBPcGVyYXRvcnMsIHdoaWNoIGFyZSBsb2dpY2FsIG9wZXJhdG9ycyBiZXR3ZWVuIGlkZW50aWZpZXJzIG9yIGJldHdlZW4gcGFyZW50aGVzaXMuXG4gICAgICogMy4gQ3JlYXRpbmcgdGhlIGZpbHRlciBmdW5jdGlvbnMgZm9yIGFsbCB0aGUgSWRlbnRpZmllcnMgaW4gdGhlIGV4cHJlc3Npb24gYW5kIGNhY2hpbmcgdGhlbSBpbiB0aGlzLnN1YkZpZWxkcy5cbiAgICAgKiA0LiBSZXR1cm5pbmcgYSBmaW5hbCBmdW5jdGlvbiBmaWx0ZXIsIHdoaWNoIGZvciBlYWNoIFRhc2sgY2FuIHJ1biB0aGUgY29tcGxldGUgcXVlcnkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYXJzZUxpbmUobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSAnZW1wdHkgbGluZSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXByb2Nlc3NlZCA9IHRoaXMucHJlcHJvY2Vzc0V4cHJlc3Npb24obGluZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSAocHJlcHJvY2Vzc2VkKSBsaW5lIGludG8gYSBwb3N0Zml4IGxvZ2ljYWwgZXhwcmVzc2lvblxuICAgICAgICAgICAgY29uc3QgcG9zdGZpeEV4cHJlc3Npb24gPSBib29uUGFyc2UocHJlcHJvY2Vzc2VkKTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBzdWItZmllbGQgbWFwLCBpLmUuIGhhdmUgc3ViRmllbGRzIGluY2x1ZGUgYSBmaWx0ZXIgZnVuY3Rpb24gZm9yIGV2ZXJ5XG4gICAgICAgICAgICAvLyBmaW5hbCB0b2tlbiBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBwb3N0Zml4RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnSURFTlRJRklFUicgJiYgdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRva2VuLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaWRlbnRpZmllciBpbiB0aGlzLnN1YkZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEZpZWxkID0gcGFyc2VGaWx0ZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgY291bGRuJ3QgcGFyc2Ugc3ViLWV4cHJlc3Npb24gJyR7aWRlbnRpZmllcn0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZEZpZWxkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYGNvdWxkbid0IHBhcnNlIHN1Yi1leHByZXNzaW9uICcke2lkZW50aWZpZXJ9JzogJHtwYXJzZWRGaWVsZC5lcnJvcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZEZpZWxkLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViRmllbGRzW2lkZW50aWZpZXJdID0gcGFyc2VkRmllbGQuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIHdlJ3JlIGFscmVhZHkgaXRlcmF0aW5nIG92ZXIgdGhlIGV4cHJlc3Npb24sIGFsdGhvdWdoIHdlIGRvbid0IG5lZWQgdGhlIG9wZXJhdG9ycyBhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHN0YWdlIGJ1dCBvbmx5IGluIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkgYmVsb3csIHdlJ3JlIHVzaW5nIHRoZSBvcHBvcnR1bml0eSB0byB2ZXJpZnlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgdmFsaWQuIElmIHdlIHdvbid0LCB0aGVuIGFuIGludmFsaWQgb3BlcmF0b3Igd2lsbCBvbmx5IGJlIGRldGVjdGVkIHdoZW4gdGhlIHF1ZXJ5IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBvbiBhIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gJ2VtcHR5IG9wZXJhdG9yIGluIGJvb2xlYW4gcXVlcnknO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkT3BlcmF0b3JzLmluY2x1ZGVzKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYHVua25vd24gYm9vbGVhbiBvcGVyYXRvciAnJHt0b2tlbi52YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpbHRlciBmdW5jdGlvbiB0aGF0IGNhbiBydW4gdGhlIGNvbXBsZXRlIHF1ZXJ5XG4gICAgICAgICAgICByZXN1bHQuZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJUYXNrV2l0aFBhcnNlZFF1ZXJ5KHRhc2ssIHBvc3RmaXhFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93biBlcnJvciB0eXBlJztcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBtYWxmb3JtZWQgYm9vbGVhbiBxdWVyeSAtLSAke21lc3NhZ2V9IChjaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZ3VpZGVsaW5lcylgO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJlcHJvY2Vzc0V4cHJlc3Npb24obGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgcXVlcnkgdG8gYmUgcHJvY2Vzc2VkIGJ5IGJvb24tanMuXG4gICAgICAgIC8vIEJvb24gZG9lc24ndCBwcm9jZXNzIGV4cHJlc3Npb24gd2l0aCBzcGFjZXMgdW5sZXNzIHRoZXkgYXJlIHN1cnJvdW5kZWQgYnkgcXVvdGVzLCBzbyByZXBsYWNlXG4gICAgICAgIC8vIChkdWUgdG9kYXkpIGJ5IChcImR1ZSB0b2RheVwiKS5cbiAgICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvXFwoKFteKCldKylcXCkvZywgJyhcIiQxXCIpJyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGlzIHJ1biBhIFRhc2sgb2JqZWN0IHRocm91Z2ggYSBjb21wbGV0ZSBib29sZWFuIGV4cHJlc3Npb24uXG4gICAgICogSXQgYmFzaWNhbGx5IHJlc29sdmVzIHRoZSBwb3N0Zml4IGV4cHJlc3Npb24gdW50aWwgaXQgaXMgcmVkdWNlZCBpbnRvIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWUsXG4gICAgICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiB0aGUgY29tcGxldGUgZXhwcmVzc2lvbi5cbiAgICAgKiBTZWUgaGVyZSBob3cgaXQgd29ya3M6IGh0dHA6Ly93d3cuYnRlY2hzbWFydGNsYXNzLmNvbS9kYXRhX3N0cnVjdHVyZXMvcG9zdGZpeC1ldmFsdWF0aW9uLmh0bWxcbiAgICAgKiBBbm90aGVyIHJlZmVyZW5jZTogaHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL0V2YWx1YXRlLVBvc3RmaXgtRXhwcmVzc2lvblxuICAgICAqL1xuICAgIHByaXZhdGUgZmlsdGVyVGFza1dpdGhQYXJzZWRRdWVyeShcbiAgICAgICAgdGFzazogVGFzayxcbiAgICAgICAgcG9zdGZpeEV4cHJlc3Npb246IFBvc3RmaXhFeHByZXNzaW9uLFxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0b0Jvb2wgPSAoczogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcyA9PT0gJ3RydWUnO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b1N0cmluZyA9IChiOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYiA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvb2xlYW5TdGFjazogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBwb3N0Zml4RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09ICdJREVOVElGSUVSJykge1xuICAgICAgICAgICAgICAgIC8vIElkZW50aWZpZXJzIGFyZSB0aGUgc3ViLWZpZWxkcyBvZiB0aGUgZXhwcmVzc2lvbiwgdGhlIGFjdHVhbCBmaWx0ZXJzLCBlLmcuICdkZXNjcmlwdGlvbiBpbmNsdWRlcyBmb28nLlxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGlkZW50aWZpZXIgd2UgY3JlYXRlZCBlYXJsaWVyIHRoZSBjb3JyZXNwb25kaW5nIEZpbHRlciwgc28gbm93IHdlIGNhbiBqdXN0IGV2YWx1YXRlIHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHRhc2sgZm9yIGVhY2ggaWRlbnRpZmllciB0aGF0IHdlIGZpbmQgaW4gdGhlIHBvc3RmaXggZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT0gbnVsbCkgdGhyb3cgRXJyb3IoJ251bGwgdG9rZW4gdmFsdWUnKTsgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuc3ViRmllbGRzW3Rva2VuLnZhbHVlLnRyaW0oKV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsdGVyKHRhc2spO1xuICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKHJlc3VsdCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgLy8gVG8gZXZhbHVhdGUgYW4gb3BlcmF0b3Igd2UgbmVlZCB0byBwb3AgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBib29sZWFuIHN0YWNrLFxuICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBsb2dpY2FsIGV2YWx1YXRpb24gYW5kIHB1c2ggYmFjayB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnTk9UJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKCFhcmcxKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ09SJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoYXJnMSB8fCBhcmcyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ0FORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMSA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcyID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKGFyZzEgJiYgYXJnMikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdYT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nKChhcmcxICYmICFhcmcyKSB8fCAoIWFyZzEgJiYgYXJnMikpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJyArIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCB0b2tlbiB0eXBlOiAnICsgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW50dWFsbHkgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbiBmb3IgdGhpcyBUYXNrIGlzIHRoZSBvbmx5IGl0ZW0gbGVmdCBpbiB0aGUgYm9vbGVhbiBzdGFja1xuICAgICAgICByZXR1cm4gdG9Cb29sKGJvb2xlYW5TdGFja1swXSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IERlc2NyaXB0aW9uRmllbGQgfSBmcm9tICcuL0ZpbHRlci9EZXNjcmlwdGlvbkZpZWxkJztcbmltcG9ydCB7IERvbmVEYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9Eb25lRGF0ZUZpZWxkJztcbmltcG9ydCB7IER1ZURhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0R1ZURhdGVGaWVsZCc7XG5pbXBvcnQgeyBFeGNsdWRlU3ViSXRlbXNGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0V4Y2x1ZGVTdWJJdGVtc0ZpZWxkJztcbmltcG9ydCB7IEhlYWRpbmdGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0hlYWRpbmdGaWVsZCc7XG5pbXBvcnQgeyBQYXRoRmllbGQgfSBmcm9tICcuL0ZpbHRlci9QYXRoRmllbGQnO1xuaW1wb3J0IHsgUHJpb3JpdHlGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1ByaW9yaXR5RmllbGQnO1xuaW1wb3J0IHsgU2NoZWR1bGVkRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU2NoZWR1bGVkRGF0ZUZpZWxkJztcbmltcG9ydCB7IFN0YXJ0RGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhcnREYXRlRmllbGQnO1xuaW1wb3J0IHsgSGFwcGVuc0RhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0hhcHBlbnNEYXRlRmllbGQnO1xuaW1wb3J0IHsgUmVjdXJyaW5nRmllbGQgfSBmcm9tICcuL0ZpbHRlci9SZWN1cnJpbmdGaWVsZCc7XG5pbXBvcnQgeyBTdGF0dXNGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1N0YXR1c0ZpZWxkJztcbmltcG9ydCB7IFRhZ3NGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1RhZ3NGaWVsZCc7XG5pbXBvcnQgeyBCb29sZWFuRmllbGQgfSBmcm9tICcuL0ZpbHRlci9Cb29sZWFuRmllbGQnO1xuXG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXIvRmlsdGVyJztcblxuY29uc3QgZmllbGRDcmVhdG9ycyA9IFtcbiAgICAoKSA9PiBuZXcgU3RhdHVzRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUmVjdXJyaW5nRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUHJpb3JpdHlGaWVsZCgpLFxuICAgICgpID0+IG5ldyBIYXBwZW5zRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFN0YXJ0RGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFNjaGVkdWxlZERhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEdWVEYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRG9uZURhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBQYXRoRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRGVzY3JpcHRpb25GaWVsZCgpLFxuICAgICgpID0+IG5ldyBUYWdzRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgSGVhZGluZ0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEV4Y2x1ZGVTdWJJdGVtc0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEJvb2xlYW5GaWVsZCgpLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmlsdGVyKGZpbHRlclN0cmluZzogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2UgfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IGNyZWF0b3Igb2YgZmllbGRDcmVhdG9ycykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNyZWF0b3IoKTtcbiAgICAgICAgaWYgKGZpZWxkLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUoZmlsdGVyU3RyaW5nKSlcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShmaWx0ZXJTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbiIsICJpbXBvcnQgeyBHcm91cCB9IGZyb20gJy4vUXVlcnkvR3JvdXAnO1xuaW1wb3J0IHsgcGFyc2VGaWx0ZXIgfSBmcm9tICcuL1F1ZXJ5L0ZpbHRlclBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2tHcm91cHMgfSBmcm9tICcuL1F1ZXJ5L1Rhc2tHcm91cHMnO1xuXG5pbXBvcnQgeyBMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi9MYXlvdXRPcHRpb25zJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL1NvcnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgSVF1ZXJ5IH0gZnJvbSAnLi9JUXVlcnknO1xuXG5leHBvcnQgdHlwZSBTb3J0aW5nUHJvcGVydHkgPVxuICAgIHwgJ3VyZ2VuY3knXG4gICAgfCAnc3RhdHVzJ1xuICAgIHwgJ3ByaW9yaXR5J1xuICAgIHwgJ3N0YXJ0J1xuICAgIHwgJ3NjaGVkdWxlZCdcbiAgICB8ICdkdWUnXG4gICAgfCAnZG9uZSdcbiAgICB8ICdwYXRoJ1xuICAgIHwgJ2Rlc2NyaXB0aW9uJ1xuICAgIHwgJ3RhZyc7XG50eXBlIFNvcnRpbmcgPSB7XG4gICAgcHJvcGVydHk6IFNvcnRpbmdQcm9wZXJ0eTtcbiAgICByZXZlcnNlOiBib29sZWFuO1xuICAgIHByb3BlcnR5SW5zdGFuY2U6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEdyb3VwaW5nUHJvcGVydHkgPVxuICAgIHwgJ2JhY2tsaW5rJ1xuICAgIHwgJ2RvbmUnXG4gICAgfCAnZHVlJ1xuICAgIHwgJ2ZpbGVuYW1lJ1xuICAgIHwgJ2ZvbGRlcidcbiAgICB8ICdoYXBwZW5zJ1xuICAgIHwgJ2hlYWRpbmcnXG4gICAgfCAncGF0aCdcbiAgICB8ICdwcmlvcml0eSdcbiAgICB8ICdyZWN1cnJlbmNlJ1xuICAgIHwgJ3JlY3VycmluZydcbiAgICB8ICdyb290J1xuICAgIHwgJ3NjaGVkdWxlZCdcbiAgICB8ICdzdGFydCdcbiAgICB8ICdzdGF0dXMnXG4gICAgfCAndGFncyc7XG5leHBvcnQgdHlwZSBHcm91cGluZyA9IHsgcHJvcGVydHk6IEdyb3VwaW5nUHJvcGVydHkgfTtcblxuZXhwb3J0IGNsYXNzIFF1ZXJ5IGltcGxlbWVudHMgSVF1ZXJ5IHtcbiAgICBwdWJsaWMgc291cmNlOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF9saW1pdDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX2xheW91dE9wdGlvbnM6IExheW91dE9wdGlvbnMgPSBuZXcgTGF5b3V0T3B0aW9ucygpO1xuICAgIHByaXZhdGUgX2ZpbHRlcnM6ICgodGFzazogVGFzaykgPT4gYm9vbGVhbilbXSA9IFtdO1xuICAgIHByaXZhdGUgX2Vycm9yOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfc29ydGluZzogU29ydGluZ1tdID0gW107XG4gICAgcHJpdmF0ZSBfZ3JvdXBpbmc6IEdyb3VwaW5nW10gPSBbXTtcblxuICAgIC8vIElmIGEgdGFnIGlzIHNwZWNpZmllZCB0aGUgdXNlciBjYW4gYWxzbyBhZGQgYSBudW1iZXIgdG8gc3BlY2lmeVxuICAgIC8vIHdoaWNoIG9uZSB0byBzb3J0IGJ5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUuXG4gICAgcHJpdmF0ZSByZWFkb25seSBzb3J0QnlSZWdleHAgPVxuICAgICAgICAvXnNvcnQgYnkgKHVyZ2VuY3l8c3RhdHVzfHByaW9yaXR5fHN0YXJ0fHNjaGVkdWxlZHxkdWV8ZG9uZXxwYXRofGRlc2NyaXB0aW9ufHRhZykoIHJldmVyc2UpP1tcXHNdKihcXGQrKT8vO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBncm91cEJ5UmVnZXhwID1cbiAgICAgICAgL15ncm91cCBieSAoYmFja2xpbmt8ZG9uZXxkdWV8ZmlsZW5hbWV8Zm9sZGVyfGhhcHBlbnN8aGVhZGluZ3xwYXRofHByaW9yaXR5fHJlY3VycmVuY2V8cmVjdXJyaW5nfHJvb3R8c2NoZWR1bGVkfHN0YXJ0fHN0YXR1c3x0YWdzKS87XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGhpZGVPcHRpb25zUmVnZXhwID1cbiAgICAgICAgL15oaWRlICh0YXNrIGNvdW50fGJhY2tsaW5rfHByaW9yaXR5fHN0YXJ0IGRhdGV8c2NoZWR1bGVkIGRhdGV8ZG9uZSBkYXRlfGR1ZSBkYXRlfHJlY3VycmVuY2UgcnVsZXxlZGl0IGJ1dHRvbikvO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hvcnRNb2RlUmVnZXhwID0gL15zaG9ydC87XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGxpbWl0UmVnZXhwID0gL15saW1pdCAodG8gKT8oXFxkKykoIHRhc2tzPyk/LztcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29tbWVudFJlZ2V4cCA9IC9eIy4qLztcblxuICAgIGNvbnN0cnVjdG9yKHsgc291cmNlIH06IHsgc291cmNlOiBzdHJpbmcgfSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlXG4gICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAubWFwKChsaW5lOiBzdHJpbmcpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAgICAgLmZvckVhY2goKGxpbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxpbmUgPT09ICcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5zaG9ydE1vZGVSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuc2hvcnRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMubGltaXRSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaW1pdCh7IGxpbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnNvcnRCeVJlZ2V4cC50ZXN0KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVNvcnRCeSh7IGxpbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmdyb3VwQnlSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VHcm91cEJ5KHsgbGluZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuaGlkZU9wdGlvbnNSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VIaWRlT3B0aW9ucyh7IGxpbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmNvbW1lbnRSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgbGluZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMucGFyc2VGaWx0ZXIobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gYGRvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5OiAke2xpbmV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGxpbWl0KCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW1pdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGxheW91dE9wdGlvbnMoKTogTGF5b3V0T3B0aW9ucyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRPcHRpb25zO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiAoKHRhc2s6IFRhc2spID0+IGJvb2xlYW4pW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHNvcnRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0aW5nO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ3JvdXBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGVycm9yKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXBwbHlRdWVyeVRvVGFza3ModGFza3M6IFRhc2tbXSk6IFRhc2tHcm91cHMge1xuICAgICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICB0YXNrcyA9IHRhc2tzLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0YXNrc1NvcnRlZExpbWl0ZWQgPSBTb3J0LmJ5KHRoaXMsIHRhc2tzKS5zbGljZSgwLCB0aGlzLmxpbWl0KTtcbiAgICAgICAgcmV0dXJuIEdyb3VwLmJ5KHRoaXMuZ3JvdXBpbmcsIHRhc2tzU29ydGVkTGltaXRlZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUhpZGVPcHRpb25zKHsgbGluZSB9OiB7IGxpbmU6IHN0cmluZyB9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGhpZGVPcHRpb25zTWF0Y2ggPSBsaW5lLm1hdGNoKHRoaXMuaGlkZU9wdGlvbnNSZWdleHApO1xuICAgICAgICBpZiAoaGlkZU9wdGlvbnNNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gaGlkZU9wdGlvbnNNYXRjaFsxXS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YXNrIGNvdW50JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlVGFza0NvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmFja2xpbmsnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVCYWNrbGlua3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwcmlvcml0eSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVByaW9yaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVN0YXJ0RGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NjaGVkdWxlZCBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlU2NoZWR1bGVkRGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2R1ZSBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlRHVlRGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvbmUgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZURvbmVEYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVjdXJyZW5jZSBydWxlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlUmVjdXJyZW5jZVJ1bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0IGJ1dHRvbic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZUVkaXRCdXR0b24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9ICdkbyBub3QgdW5kZXJzdGFuZCBoaWRlIG9wdGlvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlRmlsdGVyKGxpbmU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBmaWx0ZXJPckVycm9yID0gcGFyc2VGaWx0ZXIobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJPckVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJPckVycm9yLmZpbHRlcikgdGhpcy5fZmlsdGVycy5wdXNoKGZpbHRlck9yRXJyb3IuZmlsdGVyKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fZXJyb3IgPSBmaWx0ZXJPckVycm9yLmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VMaW1pdCh7IGxpbmUgfTogeyBsaW5lOiBzdHJpbmcgfSk6IHZvaWQge1xuICAgICAgICBjb25zdCBsaW1pdE1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmxpbWl0UmVnZXhwKTtcbiAgICAgICAgaWYgKGxpbWl0TWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxpbWl0TWF0Y2hbMl0gaXMgcGVyIHJlZ2V4IGFsd2F5cyBkaWdpdHMgYW5kIHRoZXJlZm9yZSBwYXJzYWJsZS5cbiAgICAgICAgICAgIHRoaXMuX2xpbWl0ID0gTnVtYmVyLnBhcnNlSW50KGxpbWl0TWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGxpbWl0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VTb3J0QnkoeyBsaW5lIH06IHsgbGluZTogc3RyaW5nIH0pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmllbGRNYXRjaCA9IGxpbmUubWF0Y2godGhpcy5zb3J0QnlSZWdleHApO1xuICAgICAgICBpZiAoZmllbGRNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc29ydGluZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogZmllbGRNYXRjaFsxXSBhcyBTb3J0aW5nUHJvcGVydHksXG4gICAgICAgICAgICAgICAgcmV2ZXJzZTogISFmaWVsZE1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5SW5zdGFuY2U6IGlzTmFOKCtmaWVsZE1hdGNoWzNdKSA/IDEgOiArZmllbGRNYXRjaFszXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgc29ydGluZyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlR3JvdXBCeSh7IGxpbmUgfTogeyBsaW5lOiBzdHJpbmcgfSk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaWVsZE1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmdyb3VwQnlSZWdleHApO1xuICAgICAgICBpZiAoZmllbGRNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGZpZWxkTWF0Y2hbMV0gYXMgR3JvdXBpbmdQcm9wZXJ0eSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAnZG8gbm90IHVuZGVyc3RhbmQgcXVlcnkgZ3JvdXBpbmcnO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSBUYXNrc1BsdWdpbiBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IGdldFNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9IGZyb20gJy4vU2V0dGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBsdWdpbjogVGFza3NQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiB9OiB7IHBsdWdpbjogVGFza3NQbHVnaW4gfSkge1xuICAgICAgICBzdXBlcihwbHVnaW4uYXBwLCBwbHVnaW4pO1xuXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIHB1YmxpYyBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Rhc2tzIFNldHRpbmdzJyB9KTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICBjbHM6ICd0YXNrcy1zZXR0aW5nLWltcG9ydGFudCcsXG4gICAgICAgICAgICB0ZXh0OiAnQ2hhbmdpbmcgYW55IHNldHRpbmdzIHJlcXVpcmVzIGEgcmVzdGFydCBvZiBvYnNpZGlhbi4nLFxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdHbG9iYWwgdGFzayBmaWx0ZXInKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ1RoZSBnbG9iYWwgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgY2hlY2tsaXN0IGl0ZW1zLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJyN0YXNrJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmdsb2JhbEZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBnbG9iYWxGaWx0ZXI6IHZhbHVlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbicsXG4gICAgICAgICAgICB0ZXh0OlxuICAgICAgICAgICAgICAgICdUaGUgZ2xvYmFsIGZpbHRlciB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGNoZWNrbGlzdCBpdGVtcyB0byBmaWx0ZXIgb3V0IFwibm9uLXRhc2tcIiBjaGVja2xpc3QgaXRlbXMuXFxuJyArXG4gICAgICAgICAgICAgICAgJ0EgY2hlY2tsaXN0IGl0ZW0gbXVzdCBpbmNsdWRlIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGluIGl0cyBkZXNjcmlwdGlvbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGEgdGFzay5cXG4nICtcbiAgICAgICAgICAgICAgICAnRm9yIGV4YW1wbGUsIGlmIHlvdSBzZXQgdGhlIGdsb2JhbCBmaWx0ZXIgdG8gYCN0YXNrYCwgdGhlIFRhc2tzIHBsdWdpbiB3aWxsIG9ubHkgaGFuZGxlIGNoZWNrbGlzdCBpdGVtcyB0YWdnZWQgd2l0aCBgI3Rhc2tgLlxcbicgK1xuICAgICAgICAgICAgICAgICdPdGhlciBjaGVja2xpc3QgaXRlbXMgd2lsbCByZW1haW4gbm9ybWFsIGNoZWNrbGlzdCBpdGVtcyBhbmQgbm90IGFwcGVhciBpbiBxdWVyaWVzIG9yIGdldCBhIGRvbmUgZGF0ZSBzZXQuXFxuJyArXG4gICAgICAgICAgICAgICAgJ0xlYXZlIGVtcHR5IGlmIHlvdSB3YW50IGFsbCBjaGVja2xpc3QgaXRlbXMgZnJvbSB5b3VyIHZhdWx0IHRvIGJlIHRhc2tzIG1hbmFnZWQgYnkgdGhpcyBwbHVnaW4uJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVtb3ZlIGdsb2JhbCBmaWx0ZXIgZnJvbSBkZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnRW5hYmxpbmcgdGhpcyByZW1vdmVzIHRoZSBzdHJpbmcgdGhhdCB5b3Ugc2V0IGFzIGdsb2JhbCBmaWx0ZXIgZnJvbSB0aGUgdGFzayBkZXNjcmlwdGlvbiB3aGVuIGRpc3BsYXlpbmcgYSB0YXNrLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLnJlbW92ZUdsb2JhbEZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyByZW1vdmVHbG9iYWxGaWx0ZXI6IHZhbHVlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdTZXQgZG9uZSBkYXRlIG9uIGV2ZXJ5IGNvbXBsZXRlZCB0YXNrJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdFbmFibGluZyB0aGlzIHdpbGwgYWRkIGEgdGltZXN0YW1wIFx1MjcwNSBZWVlZLU1NLUREIGF0IHRoZSBlbmQgd2hlbiBhIHRhc2sgaXMgdG9nZ2xlZCB0byBkb25lJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvb2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b29nbGVcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLnNldERvbmVEYXRlKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IHNldERvbmVEYXRlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dG8tc3VnZ2VzdCB0YXNrIGNvbnRlbnQnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0VuYWJsaW5nIHRoaXMgd2lsbCBvcGVuIGFuIGludGVsbGlnZW50IHN1Z2dlc3QgbWVudSB3aGlsZSB0eXBpbmcgaW5zaWRlIGEgcmVjb2duaXplZCB0YXNrIGxpbmUuJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmF1dG9TdWdnZXN0SW5FZGl0b3IpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgYXV0b1N1Z2dlc3RJbkVkaXRvcjogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNaW5pbXVtIG1hdGNoIGxlbmd0aCBmb3IgYXV0by1zdWdnZXN0JylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdJZiBoaWdoZXIgdGhhbiAwLCBhdXRvLXN1Z2dlc3Qgd2lsbCBiZSB0cmlnZ2VyZWQgb25seSB3aGVuIHRoZSBiZWdpbm5pbmcgb2YgYW55IHN1cHBvcnRlZCBrZXl3b3JkcyBpcyByZWNvZ25pemVkLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkU2xpZGVyKChzbGlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMCwgMywgMSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgYXV0b1N1Z2dlc3RNaW5NYXRjaDogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNYXhpbXVtIG51bWJlciBvZiBhdXRvLXN1Z2dlc3Rpb25zIHRvIHNob3cnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ0hvdyBtYW55IHN1Z2dlc3Rpb25zIHNob3VsZCBiZSBzaG93biB3aGVuIGFuIGF1dG8tc3VnZ2VzdCBtZW51IHBvcHMgdXAgKGluY2x1ZGluZyB0aGUgXCJcdTIzQ0VcIiBvcHRpb24pLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkU2xpZGVyKChzbGlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMywgMTIsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5hdXRvU3VnZ2VzdE1heEl0ZW1zKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGF1dG9TdWdnZXN0TWF4SXRlbXM6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBFZGl0b3JTdWdnZXN0LCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHtcbiAgICBFZGl0b3JQb3NpdGlvbixcbiAgICBFZGl0b3JTdWdnZXN0Q29udGV4dCxcbiAgICBFZGl0b3JTdWdnZXN0VHJpZ2dlckluZm8sXG59IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHR5cGUgeyBTZXR0aW5ncyB9IGZyb20gJy4uL2NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgKiBhcyB0YXNrIGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgYnVpbGRTdWdnZXN0aW9ucyB9IGZyb20gJy4vU3VnZ2VzdG9yJztcbmltcG9ydCB0eXBlIHsgU3VnZ2VzdEluZm8gfSBmcm9tICcuL1N1Z2dlc3Rvcic7XG5cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvV2l0aENvbnRleHQgPSBTdWdnZXN0SW5mbyAmIHtcbiAgICBjb250ZXh0OiBFZGl0b3JTdWdnZXN0Q29udGV4dDtcbn07XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JTdWdnZXN0b3IgZXh0ZW5kcyBFZGl0b3JTdWdnZXN0PFN1Z2dlc3RJbmZvV2l0aENvbnRleHQ+IHtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBTZXR0aW5ncztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogU2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cblxuICAgIG9uVHJpZ2dlcihcbiAgICAgICAgY3Vyc29yOiBFZGl0b3JQb3NpdGlvbixcbiAgICAgICAgZWRpdG9yOiBFZGl0b3IsXG4gICAgICAgIF9maWxlOiBURmlsZSxcbiAgICApOiBFZGl0b3JTdWdnZXN0VHJpZ2dlckluZm8gfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9TdWdnZXN0SW5FZGl0b3IpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoY3Vyc29yLmxpbmUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsaW5lLmNvbnRhaW5zKHRoaXMuc2V0dGluZ3MuZ2xvYmFsRmlsdGVyKSAmJlxuICAgICAgICAgICAgbGluZS5tYXRjaCh0YXNrLlRhc2sudGFza1JlZ2V4KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogY3Vyc29yLmxpbmUsIGNoOiAwIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnNvci5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjaDogbGluZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeTogbGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoY29udGV4dDogRWRpdG9yU3VnZ2VzdENvbnRleHQpOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0W10ge1xuICAgICAgICBjb25zdCBsaW5lID0gY29udGV4dC5xdWVyeTtcbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IGNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gYnVpbGRTdWdnZXN0aW9ucyhcbiAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICBjdXJyZW50Q3Vyc29yLmNoLFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGVkaXRvciBjb250ZXh0IHRvIGFsbCB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnNXaXRoQ29udGV4dDogU3VnZ2VzdEluZm9XaXRoQ29udGV4dFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3VnZ2VzdGlvbiBvZiBzdWdnZXN0aW9ucylcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zV2l0aENvbnRleHQucHVzaCh7IC4uLnN1Z2dlc3Rpb24sIGNvbnRleHQ6IGNvbnRleHQgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb25zV2l0aENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogU3VnZ2VzdEluZm9XaXRoQ29udGV4dCwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGVsLnNldFRleHQodmFsdWUuZGlzcGxheVRleHQpO1xuICAgIH1cblxuICAgIHNlbGVjdFN1Z2dlc3Rpb24oXG4gICAgICAgIHZhbHVlOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0LFxuICAgICAgICBfZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCxcbiAgICApIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdmFsdWUuY29udGV4dC5lZGl0b3I7XG4gICAgICAgIGlmICh2YWx1ZS5zdWdnZXN0aW9uVHlwZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIHN1Z2dlc3Rpb24gZGlhbG9nIGFuZCBzaW11bGF0ZSBhbiBFbnRlciBwcmVzcyB0byB0aGUgZWRpdG9yXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBldmVudENsb25lID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAgY29kZTogJ0VudGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdFbnRlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChlZGl0b3IgYXMgYW55KT8uY20/LmNvbnRlbnRET00/LmRpc3BhdGNoRXZlbnQoZXZlbnRDbG9uZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IHZhbHVlLmNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBjb25zdCByZXBsYWNlRnJvbSA9IHtcbiAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgIGNoOiB2YWx1ZS5pbnNlcnRBdCA/PyBjdXJyZW50Q3Vyc29yLmNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXBsYWNlVG8gPSB2YWx1ZS5pbnNlcnRTa2lwXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgICAgICAgIGNoOiByZXBsYWNlRnJvbS5jaCArIHZhbHVlLmluc2VydFNraXAsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB2YWx1ZS5jb250ZXh0LmVkaXRvci5yZXBsYWNlUmFuZ2UoXG4gICAgICAgICAgICB2YWx1ZS5hcHBlbmRUZXh0LFxuICAgICAgICAgICAgcmVwbGFjZUZyb20sXG4gICAgICAgICAgICByZXBsYWNlVG8sXG4gICAgICAgICk7XG4gICAgICAgIHZhbHVlLmNvbnRleHQuZWRpdG9yLnNldEN1cnNvcih7XG4gICAgICAgICAgICBsaW5lOiBjdXJyZW50Q3Vyc29yLmxpbmUsXG4gICAgICAgICAgICBjaDogcmVwbGFjZUZyb20uY2ggKyB2YWx1ZS5hcHBlbmRUZXh0Lmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2V0dGluZ3MgfSBmcm9tICcuLi9jb25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgRGF0ZVBhcnNlciB9IGZyb20gJy4uL1F1ZXJ5L0RhdGVQYXJzZXInO1xuaW1wb3J0IHsgZG9BdXRvY29tcGxldGUgfSBmcm9tICcuLi9EYXRlQWJicmV2aWF0aW9ucyc7XG5pbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vUmVjdXJyZW5jZSc7XG5cbmltcG9ydCAqIGFzIHRhc2sgZnJvbSAnLi4vVGFzayc7XG5cbmNvbnN0IGRhdGVQcmVmaXhDaGFyYWN0ZXJzID0gYCR7dGFzay5zdGFydERhdGVTeW1ib2x9JHt0YXNrLnNjaGVkdWxlZERhdGVTeW1ib2x9JHt0YXNrLmR1ZURhdGVTeW1ib2x9YDtcblxuLypcbiAqIEEgc3VnZ2VzdGlvbiBwcmVzZW50ZWQgdG8gdGhlIHVzZXIgYW5kIHNvbWUgbWV0YWRhdGEgYWJvdXQgaXQuXG4gKi9cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvID0ge1xuICAgIHN1Z2dlc3Rpb25UeXBlPzogJ21hdGNoJyB8ICdkZWZhdWx0JyB8ICdlbXB0eSc7XG4gICAgLy8gV2hhdCB0byBkaXNwbGF5IHRvIHRoZSB1c2VyXG4gICAgZGlzcGxheVRleHQ6IHN0cmluZztcbiAgICAvLyBXaGF0IHRvIGFwcGVuZCB0byB0aGUgbm90ZVxuICAgIGFwcGVuZFRleHQ6IHN0cmluZztcbiAgICAvLyBBdCB3aGF0IGluZGV4IGluIHRoZSBsaW5lIHRvIGRvIHRoZSBpbnNlcnRpb24gKGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJzb3IgbG9jYXRpb24gaXMgdXNlZClcbiAgICBpbnNlcnRBdD86IG51bWJlcjtcbiAgICAvLyBIb3cgbWFueSBjaGFyYWN0ZXJzIHRvIHNraXAgZnJvbSB0aGUgb3JpZ2luYWwgbGluZSAoZS5nLiBpZiByZXBsYWNpbmcgZXhpc3RpbmcgdGV4dClcbiAgICBpbnNlcnRTa2lwPzogbnVtYmVyO1xufTtcblxuLypcbiAqIFJldHVybiBhIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMsIGVpdGhlciBnZW5lcmljIG9yIG1vcmUgZmluZS1ncmFpbmVkIHRvIHRoZSB3b3JkcyBhdCB0aGUgY3Vyc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTdWdnZXN0aW9ucyhcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgY3Vyc29yUG9zOiBudW1iZXIsXG4gICAgc2V0dGluZ3M6IFNldHRpbmdzLFxuKTogU3VnZ2VzdEluZm9bXSB7XG4gICAgbGV0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gW107XG5cbiAgICAvLyBTdGVwIDE6IGFkZCBkYXRlIHN1Z2dlc3Rpb25zIGlmIHJlbGV2YW50XG4gICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucy5jb25jYXQoXG4gICAgICAgIGFkZERhdGVzU3VnZ2VzdGlvbnMobGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncyksXG4gICAgKTtcblxuICAgIC8vIFN0ZXAgMjogYWRkIHJlY3VycmVuY2Ugc3VnZ2VzdGlvbnMgaWYgcmVsZXZhbnRcbiAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChcbiAgICAgICAgYWRkUmVjdXJyZW5jZVN1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MpLFxuICAgICk7XG5cbiAgICAvLyBTdGVwIDM6IGFkZCBtb3JlIGdlbmVyYWwgc3VnZ2VzdGlvbnMgKCdkdWUnLCAncmVjdXJyZW5jZScgZXRjKVxuICAgIGNvbnN0IG1vcmVQb3NzaWJsZVN1Z2dlc3Rpb25zID0gZ2V0UG9zc2libGVDb21wb25lbnRTdWdnZXN0aW9ucyhcbiAgICAgICAgbGluZSxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgKTtcbiAgICAvLyBXZSBub3cgZmlsdGVyIHRoZSBnZW5lcmFsIHN1Z2dlc3Rpb25zIGFjY29yZGluZyB0byB0aGUgd29yZCBhdCB0aGUgY3Vyc29yLiBJZiB0aGVyZSdzXG4gICAgLy8gc29tZXRoaW5nIHRvIG1hdGNoLCB3ZSBmaWx0ZXIgdGhlIHN1Z2dlc3Rpb25zIGFjY29yZGluZ2x5LCBzbyB0aGUgdXNlciBjYW4gZ2V0IG1vcmUgc3BlY2lmaWNcbiAgICAvLyByZXN1bHRzIGFjY29yZGluZyB0byB3aGF0IHNoZSdzIHR5cGluZy5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGdvb2QgbWF0Y2gsIHByZXNlbnQgdGhlIHN1Z2dlc3Rpb25zIGFzIHRoZXkgYXJlXG4gICAgY29uc3Qgd29yZE1hdGNoID0gbWF0Y2hCeVBvc2l0aW9uKGxpbmUsIC8oW2EtekEtWidfLV0qKS9nLCBjdXJzb3JQb3MpO1xuICAgIGxldCBhZGRlZFN1Z2dlc3Rpb25zID0gZmFsc2U7XG4gICAgaWYgKHdvcmRNYXRjaCAmJiB3b3JkTWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3b3JkVW5kZXJDdXJzb3IgPSB3b3JkTWF0Y2hbMF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmRVbmRlckN1cnNvci5sZW5ndGggPj0gTWF0aC5tYXgoMSwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN1Z2dlc3Rpb25zID0gbW9yZVBvc3NpYmxlU3VnZ2VzdGlvbnMuZmlsdGVyKFxuICAgICAgICAgICAgICAgIChzdWdnZXN0SW5mbykgPT5cbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdEluZm8uZGlzcGxheVRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5jbHVkZXMod29yZFVuZGVyQ3Vyc29yLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyZWQgb2YgZmlsdGVyZWRTdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGZpbHRlcmVkLmRpc3BsYXlUZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBmaWx0ZXJlZC5hcHBlbmRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBdDogd29yZE1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiB3b3JkVW5kZXJDdXJzb3IubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZGVkU3VnZ2VzdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoYXQncyB3aGVyZSB3ZSdyZSBhZGRpbmcgYWxsIHRoZSBzdWdnZXN0aW9ucyBpbiBjYXNlIHRoZXJlJ3Mgbm90aGluZyBzcGVjaWZpYyB0byBtYXRjaFxuICAgIC8vIChhbmQgd2UncmUgYWxsb3dlZCBieSB0aGUgc2V0dGluZ3MgdG8gYnJpbmcgYmFjayBhIHplcm8tc2l6ZWQgbWF0Y2gpXG4gICAgaWYgKCFhZGRlZFN1Z2dlc3Rpb25zICYmIHNldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2ggPT09IDApXG4gICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KG1vcmVQb3NzaWJsZVN1Z2dlc3Rpb25zKTtcblxuICAgIC8vIFVubGVzcyB3ZSBoYXZlIGEgc3VnZ2VzdGlvbiB0aGF0IGlzIGEgbWF0Y2ggZm9yIHNvbWV0aGluZyB0aGUgdXNlciBpcyBjdXJyZW50bHkgdHlwaW5nLCBhZGRcbiAgICAvLyBhbiAnRW50ZXInIGVudHJ5IGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1lbnUsIHNvIGFuIEVudGVyIHByZXNzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCBsaW5lXG4gICAgLy8gcmF0aGVyIHRoYW4gaW5zZXJ0IGEgc3VnZ2VzdGlvblxuICAgIGlmIChcbiAgICAgICAgc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhc3VnZ2VzdGlvbnMuc29tZSgodmFsdWUpID0+IHZhbHVlLnN1Z2dlc3Rpb25UeXBlID09PSAnbWF0Y2gnKVxuICAgICkge1xuICAgICAgICAvLyBObyBhY3R1YWwgbWF0Y2gsIG9ubHkgZGVmYXVsdCBvbmVzXG4gICAgICAgIHN1Z2dlc3Rpb25zLnVuc2hpZnQoe1xuICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdlbXB0eScsXG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogJ1x1MjNDRScsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiAnXFxuJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRWl0aGVyIHdheSwgYWZ0ZXIgYWxsIHRoZSBhZ2dyZWdhdGlvbnMgYWJvdmUsIG5ldmVyIHN1Z2dlc3QgbW9yZSB0aGFuIHRoZSBtYXggaXRlbXNcbiAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLnNsaWNlKDAsIHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMpO1xuXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xufVxuXG5mdW5jdGlvbiBoYXNQcmlvcml0eShsaW5lOiBzdHJpbmcpIHtcbiAgICBpZiAoXG4gICAgICAgIE9iamVjdC52YWx1ZXModGFzay5wcmlvcml0eVN5bWJvbHMpLnNvbWUoXG4gICAgICAgICAgICAodmFsdWUpID0+IHZhbHVlLmxlbmd0aCA+IDAgJiYgbGluZS5pbmNsdWRlcyh2YWx1ZSksXG4gICAgICAgIClcbiAgICApXG4gICAgICAgIHJldHVybiB0cnVlO1xufVxuXG4vKlxuICogR2V0IHN1Z2dlc3Rpb25zIGZvciBnZW5lcmljIHRhc2sgY29tcG9uZW50cywgZS5nLiBhIHByaW9yaXR5IG9yIGEgJ2R1ZScgc3ltYm9sXG4gKi9cbmZ1bmN0aW9uIGdldFBvc3NpYmxlQ29tcG9uZW50U3VnZ2VzdGlvbnMoXG4gICAgbGluZTogc3RyaW5nLFxuICAgIF9zZXR0aW5nczogU2V0dGluZ3MsXG4pOiBTdWdnZXN0SW5mb1tdIHtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogU3VnZ2VzdEluZm9bXSA9IFtdO1xuXG4gICAgaWYgKCFsaW5lLmluY2x1ZGVzKHRhc2suZHVlRGF0ZVN5bWJvbCkpXG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2suZHVlRGF0ZVN5bWJvbH0gZHVlIGRhdGVgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7dGFzay5kdWVEYXRlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcbiAgICBpZiAoIWxpbmUuaW5jbHVkZXModGFzay5zdGFydERhdGVTeW1ib2wpKVxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnN0YXJ0RGF0ZVN5bWJvbH0gc3RhcnQgZGF0ZWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHt0YXNrLnN0YXJ0RGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFsaW5lLmluY2x1ZGVzKHRhc2suc2NoZWR1bGVkRGF0ZVN5bWJvbCkpXG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2suc2NoZWR1bGVkRGF0ZVN5bWJvbH0gc2NoZWR1bGVkIGRhdGVgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7dGFzay5zY2hlZHVsZWREYXRlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcbiAgICBpZiAoIWhhc1ByaW9yaXR5KGxpbmUpKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLkhpZ2h9IGhpZ2ggcHJpb3JpdHlgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7dGFzay5wcmlvcml0eVN5bWJvbHMuSGlnaH0gYCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLk1lZGl1bX0gbWVkaXVtIHByaW9yaXR5YCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLk1lZGl1bX0gYCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLkxvd30gbG93IHByaW9yaXR5YCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3Rhc2sucHJpb3JpdHlTeW1ib2xzLkxvd30gYCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGluZS5pbmNsdWRlcyh0YXNrLnJlY3VycmVuY2VTeW1ib2wpKVxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHt0YXNrLnJlY3VycmVuY2VTeW1ib2x9IHJlY3VycmluZyAocmVwZWF0KWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHt0YXNrLnJlY3VycmVuY2VTeW1ib2x9IGAsXG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xufVxuXG4vKlxuICogSWYgdGhlIGN1cnNvciBpcyBsb2NhdGVkIGluIGEgc2VjdGlvbiB0aGF0IHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGRhdGUgKGR1ZSwgc3RhcnQgZGF0ZSBvciBzY2hlZHVsZWQgZGF0ZSksXG4gKiBzdWdnZXN0IG9wdGlvbnMgZm9yIHdoYXQgdG8gZW50ZXIgYXMgYSBkYXRlLlxuICogVGhpcyBoYXMgdHdvIHBhcnRzOiBlaXRoZXIgZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLCBvciBhIHNpbmdsZSBzdWdnZXN0aW9uIHRoYXQgaXMgYSBwYXJzZWQgcmVzdWx0XG4gKiBvZiB3aGF0IHRoZSB1c2VyIGlzIHR5cGluZy5cbiAqIEdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgaW4gdHVybiwgYWxzbyBoYXZlIHR3byBvcHRpb25zOiBlaXRoZXIgZmlsdGVyZWQgKGlmIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nXG4gKiBzb21ldGhpbmcgd2hlcmUgYSBkYXRlIGlzIGV4cGVjdGVkKSBvciB1bmZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGVzU3VnZ2VzdGlvbnMoXG4gICAgbGluZTogc3RyaW5nLFxuICAgIGN1cnNvclBvczogbnVtYmVyLFxuICAgIHNldHRpbmdzOiBTZXR0aW5ncyxcbik6IFN1Z2dlc3RJbmZvW10ge1xuICAgIGNvbnN0IGdlbmVyaWNTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgJ3RvZGF5JyxcbiAgICAgICAgJ3RvbW9ycm93JyxcbiAgICAgICAgJ1N1bmRheScsXG4gICAgICAgICdNb25kYXknLFxuICAgICAgICAnVHVlc2RheScsXG4gICAgICAgICdXZWRuZXNkYXknLFxuICAgICAgICAnVGh1cnNkYXknLFxuICAgICAgICAnRnJpZGF5JyxcbiAgICAgICAgJ1NhdHVyZGF5JyxcbiAgICAgICAgJ25leHQgd2VlaycsXG4gICAgICAgICduZXh0IG1vbnRoJyxcbiAgICAgICAgJ25leHQgeWVhcicsXG4gICAgXTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcbiAgICBjb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICBgKFske2RhdGVQcmVmaXhDaGFyYWN0ZXJzfV0pXFxcXHMqKFswLTlhLXpBLVogXSopYCxcbiAgICAgICAgJ3VnJyxcbiAgICApO1xuICAgIGNvbnN0IGRhdGVNYXRjaCA9IG1hdGNoQnlQb3NpdGlvbihsaW5lLCBkYXRlUmVnZXgsIGN1cnNvclBvcyk7XG4gICAgaWYgKGRhdGVNYXRjaCAmJiBkYXRlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgZGF0ZVByZWZpeCA9IGRhdGVNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGRhdGVNYXRjaFsyXTtcbiAgICAgICAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoIDwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZW50ZXJlZCB0ZXh0IGFzIGEgdmFsaWQgZGF0ZS5cbiAgICAgICAgLy8gV2UgcGFzcyBmb3J3YXJkRGF0ZT10cnVlIHRvIHBhcnNlRGF0ZSBiZWNhdXNlIHdlIGV4cGVjdCBkdWUsIHN0YXJ0IGFuZCBzY2hlZHVsZWQgZGF0ZXMgdG9cbiAgICAgICAgLy8gYmUgaW4gdGhlIGZ1dHVyZSwgaS5lLiBpZiB0b2RheSBpcyBTdW5kYXkgYW5kIHRoZSB1c2VyIHR5cGVkIFwiZHVlIDxFbnRlcj4gU2F0dXJkYXlcIiwgc2hlXG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IG1lYW5zIFNhdHVyZGF5ICppbiB0aGUgZnV0dXJlKiBhbmQgbm90IHllc3RlcmRheS5cbiAgICAgICAgY29uc3QgcG9zc2libGVEYXRlID1cbiAgICAgICAgICAgIGRhdGVTdHJpbmcgJiYgZGF0ZVN0cmluZy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgPyBEYXRlUGFyc2VyLnBhcnNlRGF0ZShkb0F1dG9jb21wbGV0ZShkYXRlU3RyaW5nKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChwb3NzaWJsZURhdGUgJiYgcG9zc2libGVEYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlbXMgbGlrZSB0aGUgdGV4dCB0aGF0IHRoZSB1c2VyIHR5cGVkIGNhbiBiZSBwYXJzZWQgYXMgYSB2YWxpZCBkYXRlLlxuICAgICAgICAgICAgLy8gUHJlc2VudCBpdHMgY29tcGxldGVkIGZvcm0gYXMgYSAxc3Qgc3VnZ2VzdGlvblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7cG9zc2libGVEYXRlLmZvcm1hdCh0YXNrLlRhc2suZGF0ZUZvcm1hdCl9YCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtkYXRlUHJlZml4fSAke3Bvc3NpYmxlRGF0ZS5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgIHRhc2suVGFzay5kYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICl9IGAsXG4gICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IGRhdGVNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiBkYXRlTWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdG8gZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLlxuICAgICAgICAvLyBJZiB3ZSBnZXQgYSBwYXJ0aWFsIG1hdGNoIHdpdGggc29tZSBvZiB0aGUgc3VnZ2VzdGlvbnMgKGUuZy4gdGhlIHVzZXIgc3RhcnRlZCB0eXBpbmcgXCJ0b1wiKSxcbiAgICAgICAgLy8gd2UgdXNlIHRoYXQgZm9yIG1hdGNoZXMgKFwidG9tb3Jyb3dcIiwgXCJ0b2RheVwiIGV0YykuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIHN1Z2dlc3Rpb25zLCBhbmQgZWl0aGVyIHdheSwgdHJ1bmNhdGUgdGhlbSBldmVudHVhbGx5IHRvXG4gICAgICAgIC8vIGEgbWF4IG51bWJlci4gV2Ugd2FudCB0aGUgbWF4IG51bWJlciB0byBiZSBhcm91bmQgaGFsZiB0aGUgdG90YWwgYWxsb3dlZCBtYXRjaGVzLCB0byBhbHNvIGFsbG93XG4gICAgICAgIC8vIHNvbWUgZ2xvYmFsIGdlbmVyaWMgbWF0Y2hlcyAoZS5nLiB0YXNrIGNvbXBvbmVudHMpIHRvIGZpbmQgdGhlaXIgd2F5IHRvIHRoZSBtZW51XG4gICAgICAgIGNvbnN0IG1pbk1hdGNoID0gMTtcbiAgICAgICAgY29uc3QgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zID0gNTtcbiAgICAgICAgbGV0IGdlbmVyaWNNYXRjaGVzID0gZ2VuZXJpY1N1Z2dlc3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cmluZyAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlU3RyaW5nLmxlbmd0aCA+PSBtaW5NYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGRhdGVTdHJpbmcudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2xpY2UoMCwgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zKTtcbiAgICAgICAgaWYgKGdlbmVyaWNNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRG8gY29tcGxldGVseSBnZW5lcmljIGRhdGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGdlbmVyaWNNYXRjaGVzID0gZ2VuZXJpY1N1Z2dlc3Rpb25zLnNsaWNlKDAsIG1heEdlbmVyaWNTdWdnZXN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBnZW5lcmljTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IERhdGVQYXJzZXIucGFyc2VEYXRlKG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBgJHtwYXJzZWREYXRlLmZvcm1hdCh0YXNrLlRhc2suZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke21hdGNofSAoJHtmb3JtYXR0ZWREYXRlfSlgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke2RhdGVQcmVmaXh9ICR7Zm9ybWF0dGVkRGF0ZX0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogZGF0ZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGRhdGVNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLypcbiAqIElmIHRoZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiBhIHNlY3Rpb24gdGhhdCBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYSByZWN1cnJlbmNlIGRlc2NyaXB0aW9uLCBzdWdnZXN0IG9wdGlvbnNcbiAqIGZvciB3aGF0IHRvIGVudGVyIGFzIGEgcmVjdXJyZW5jZS5cbiAqIFRoaXMgaGFzIHR3byBwYXJ0czogZWl0aGVyIGdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgb3IgYSBzaW5nbGUgc3VnZ2VzdGlvbiB0aGF0IGlzIGEgcGFyc2VkIHJlc3VsdFxuICogb2Ygd2hhdCB0aGUgdXNlciBpcyB0eXBpbmcuXG4gKiBHZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMsIGluIHR1cm4sIGFsc28gaGF2ZSB0d28gb3B0aW9uczogZWl0aGVyIGZpbHRlcmVkIChpZiB0aGUgdXNlciBzdGFydGVkIHR5cGluZ1xuICogc29tZXRoaW5nIHdoZXJlIGEgcmVjdXJyZW5jZSBpcyBleHBlY3RlZCkgb3IgdW5maWx0ZXJlZFxuICovXG5mdW5jdGlvbiBhZGRSZWN1cnJlbmNlU3VnZ2VzdGlvbnMoXG4gICAgbGluZTogc3RyaW5nLFxuICAgIGN1cnNvclBvczogbnVtYmVyLFxuICAgIHNldHRpbmdzOiBTZXR0aW5ncyxcbikge1xuICAgIGNvbnN0IGdlbmVyaWNTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgJ2V2ZXJ5JyxcbiAgICAgICAgJ2V2ZXJ5IGRheScsXG4gICAgICAgICdldmVyeSB3ZWVrJyxcbiAgICAgICAgJ2V2ZXJ5IG1vbnRoJyxcbiAgICAgICAgJ2V2ZXJ5IG1vbnRoIG9uIHRoZScsXG4gICAgICAgICdldmVyeSB5ZWFyJyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gU3VuZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gTW9uZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gVHVlc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFdlZG5lc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFRodXJzZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gRnJpZGF5JyxcbiAgICAgICAgJ2V2ZXJ5IHdlZWsgb24gU2F0dXJkYXknLFxuICAgIF07XG5cbiAgICBjb25zdCByZXN1bHRzOiBTdWdnZXN0SW5mb1tdID0gW107XG4gICAgY29uc3QgcmVjdXJyZW5jZVJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgYCgke3Rhc2sucmVjdXJyZW5jZVN5bWJvbH0pXFxcXHMqKFswLTlhLXpBLVogXSopYCxcbiAgICAgICAgJ3VnJyxcbiAgICApO1xuICAgIGNvbnN0IHJlY3VycmVuY2VNYXRjaCA9IG1hdGNoQnlQb3NpdGlvbihsaW5lLCByZWN1cnJlbmNlUmVnZXgsIGN1cnNvclBvcyk7XG4gICAgaWYgKHJlY3VycmVuY2VNYXRjaCAmJiByZWN1cnJlbmNlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZVByZWZpeCA9IHJlY3VycmVuY2VNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZVN0cmluZyA9IHJlY3VycmVuY2VNYXRjaFsyXTtcbiAgICAgICAgaWYgKHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoIDwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAocmVjdXJyZW5jZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBtYXRjaGVzIGEgdmFsaWQgcmVjdXJlbmNlIGRlc2NyaXB0aW9uLCBwcmVzZW50IGl0IGFzIGEgMXN0IHN1Z2dlc3Rpb24uXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGFkZCBhIG5pY2UgY2hlY2ttYXJrIGluIHRoaXMgY2FzZSB0byBkZW5vdGUgaXQncyBhIGNvbXBsZXRlIHZhbGlkIHJlY3VycmVuY2UgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlY3VycmVuY2UgPSBSZWN1cnJlbmNlLmZyb21UZXh0KHtcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IHJlY3VycmVuY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIH0pPy50b1RleHQoKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRSZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwZW5kZWRUZXh0ID0gYCR7cmVjdXJyZW5jZVByZWZpeH0gJHtwYXJzZWRSZWN1cnJlbmNlfSBgO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogYFx1MjcwNSAke3BhcnNlZFJlY3VycmVuY2V9YCxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogYXBwZW5kZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBdDogcmVjdXJyZW5jZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiByZWN1cnJlbmNlTWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdWxsIG1hdGNoIGluY2x1ZGVzIGEgY29tcGxldGUgdmFsaWQgc3VnZ2VzdGlvbiAqZW5kaW5nIHdpdGggc3BhY2UqLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3QgYW55dGhpbmcuIFRoZSB1c2VyIGlzIHRyeWluZyB0byBjb250aW51ZSB0byB0eXBlIHNvbWV0aGluZyB0aGF0IGlzIGxpa2VseVxuICAgICAgICAgICAgICAgIC8vIG5vdCByZWxhdGVkIHRvIHJlY3VycmVuY2UuIFdoZW4gc2hlIHN0YXJ0cyBhIG5ldyB3b3JkLCBtYXliZSB0aGUgcmVjdXJyZW5jZSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZWxldmFudCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnJlbmNlTWF0Y2hbMF0gPT0gYXBwZW5kZWRUZXh0KSByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdG8gZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLlxuICAgICAgICAvLyBJZiB3ZSBnZXQgYSBwYXJ0aWFsIG1hdGNoIHdpdGggc29tZSBvZiB0aGUgc3VnZ2VzdGlvbnMgKGUuZy4gdGhlIHVzZXIgc3RhcnRlZCB0eXBpbmcgXCJldmVyeSBkXCIpLFxuICAgICAgICAvLyB3ZSB1c2UgdGhhdCBmb3IgbWF0Y2hlcyAoXCJldmVyeSBkYXlcIikuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIHN1Z2dlc3Rpb25zLCBhbmQgZWl0aGVyIHdheSwgdHJ1bmNhdGUgdGhlbSBldmVudHVhbGx5IHRvXG4gICAgICAgIC8vIGEgbWF4IG51bWJlci5cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgcmVjdXJyZW5jZSBydWxlcywgdGhlIG1heCBudW1iZXIgc2hvdWxkIGJlIHNtYWxsIGVub3VnaCB0byBhbGxvdyB1c2VycyB0byBcImVzY2FwZVwiXG4gICAgICAgIC8vIHRoZSBtb2RlIG9mIHdyaXRpbmcgYSByZWN1cnJlbmNlIHJ1bGUsIGkuZS4gd2Ugc2hvdWxkIGxlYXZlIGVub3VnaCBzcGFjZSBmb3IgY29tcG9uZW50IHN1Z2dlc3Rpb25zXG4gICAgICAgIGNvbnN0IG1pbk1hdGNoID0gMTtcbiAgICAgICAgY29uc3QgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyA9IHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMgLyAyO1xuICAgICAgICBsZXQgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICByZWN1cnJlbmNlU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoID49IG1pbk1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKHJlY3VycmVuY2VTdHJpbmcudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2xpY2UoMCwgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdlbmVyaWNNYXRjaGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgcmVjdXJyZW5jZVN0cmluZy50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBubyBhY3R1YWwgbWF0Y2ggc28gZG8gY29tcGxldGVseSBnZW5lcmljIHJlY3VycmVuY2Ugc3VnZ2VzdGlvbnMsIGJ1dCBub3QgaWZcbiAgICAgICAgICAgIC8vIHRoZXJlICp3YXMqIGEgdGV4dCB0byBtYXRjaCAoYmVjYXVzZSBpdCBtZWFucyB0aGUgdXNlciBpcyBhY3R1YWxseSB0eXBpbmcgc29tZXRoaW5nIGVsc2UpXG4gICAgICAgICAgICBnZW5lcmljTWF0Y2hlcyA9IGdlbmVyaWNTdWdnZXN0aW9ucy5zbGljZShcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIG1heEdlbmVyaWNEYXRlU3VnZ2VzdGlvbnMsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZ2VuZXJpY01hdGNoZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke21hdGNofWAsXG4gICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7cmVjdXJyZW5jZVByZWZpeH0gJHttYXRjaH0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogcmVjdXJyZW5jZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IHJlY3VycmVuY2VNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IGFjY29yZGluZyB0byBhIHBvc2l0aW9uICh0eXBpY2FsbHkgb2YgYSBjdXJzb3IpLlxuICogV2lsbCByZXR1cm4gYSByZXN1bHQgb25seSBpZiBhIG1hdGNoIGV4aXN0cyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHBhcnQgb2YgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaEJ5UG9zaXRpb24oXG4gICAgczogc3RyaW5nLFxuICAgIHI6IFJlZ0V4cCxcbiAgICBwb3NpdGlvbjogbnVtYmVyLFxuKTogUmVnRXhwTWF0Y2hBcnJheSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHMubWF0Y2hBbGwocik7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1hdGNoPy5pbmRleCAmJlxuICAgICAgICAgICAgbWF0Y2guaW5kZXggPD0gcG9zaXRpb24gJiZcbiAgICAgICAgICAgIHBvc2l0aW9uIDw9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEseUNBQUFBLFNBQUE7QUFlQSxRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLFFBQUlDO0FBQ0osUUFBSUM7QUFDSixRQUFJQztBQUNKLEtBQUMsU0FBVSxTQUFTO0FBQ2hCLFVBQUksT0FBTyxPQUFPLFdBQVcsV0FBVyxTQUFTLE9BQU8sU0FBUyxXQUFXLE9BQU8sT0FBTyxTQUFTLFdBQVcsT0FBTyxDQUFDO0FBQ3RILFVBQUksT0FBTyxXQUFXLGNBQWMsT0FBTyxLQUFLO0FBQzVDLGVBQU8sU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFVQyxVQUFTO0FBQUUsa0JBQVEsZUFBZSxNQUFNLGVBQWVB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O0FBQUEsUUFBQyxHQUFFQSxHQUFFLFNBQU8sV0FBVTtBQUFDLGlCQUFPLEtBQUssUUFBUSxJQUFFLEtBQUssWUFBWSxJQUFFO0FBQUEsUUFBSSxHQUFFQSxHQUFFLGNBQVksV0FBVTtBQUFDLGlCQUFPLEtBQUssR0FBRyxZQUFZO0FBQUEsUUFBQyxHQUFFQSxHQUFFLFdBQVMsV0FBVTtBQUFDLGlCQUFPLEtBQUssR0FBRyxZQUFZO0FBQUEsUUFBQyxHQUFFRDtBQUFBLE1BQUMsRUFBRSxHQUFFLElBQUUsRUFBRTtBQUFVLGFBQU8sRUFBRSxZQUFVLEdBQUUsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxHQUFFLENBQUMsTUFBSyxDQUFDLEdBQUUsQ0FBQyxNQUFLLENBQUMsR0FBRSxDQUFDLE1BQUssQ0FBQyxHQUFFLENBQUMsTUFBSyxDQUFDLEdBQUUsQ0FBQyxNQUFLLENBQUMsR0FBRSxDQUFDLE1BQUssQ0FBQyxHQUFFLENBQUMsTUFBSyxDQUFDLENBQUMsRUFBRSxRQUFTLFNBQVNQLElBQUU7QUFBQyxVQUFFQSxHQUFFLE1BQUksU0FBU0MsSUFBRTtBQUFDLGlCQUFPLEtBQUssR0FBR0EsSUFBRUQsR0FBRSxJQUFHQSxHQUFFLEVBQUU7QUFBQSxRQUFDO0FBQUEsTUFBQyxDQUFFLEdBQUUsRUFBRSxTQUFPLFNBQVNBLElBQUVDLElBQUU7QUFBQyxlQUFPRCxHQUFFLE9BQUtBLEdBQUVDLElBQUUsR0FBRSxDQUFDLEdBQUVELEdBQUUsS0FBRyxPQUFJO0FBQUEsTUFBQyxHQUFFLEVBQUUsU0FBTyxHQUFFLEVBQUUsVUFBUSxHQUFFLEVBQUUsT0FBSyxTQUFTQSxJQUFFO0FBQUMsZUFBTyxFQUFFLE1BQUlBLEVBQUM7QUFBQSxNQUFDLEdBQUUsRUFBRSxLQUFHLEVBQUUsSUFBRyxFQUFFLEtBQUcsR0FBRSxFQUFFLElBQUUsQ0FBQyxHQUFFO0FBQUEsSUFBQyxDQUFFO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUNBNTFNLFFBQUEsVUFBQXFCLGlCQUFBLG1CQUFBO0FBUUEsYUFBZ0IscUJBQXFCLFlBQWtCO0FB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LE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsSUFBSTtNQUNKLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxJQUFJO01BQ0osT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07O0FBR1YsYUFBZ0IsaUJBQWlCLGVBQStCOztBQUM1RCxVQUFJLGtCQUFrQixRQUFRLGtCQUFrQixRQUFXO0FBQ3ZELGVBQU87O0FBR1gsVUFBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ25DLGVBQU87O0FBR1gsY0FBTyxLQUFBLFFBQUEsa0JBQWtCLG9CQUFjLFFBQUEsT0FBQSxTQUFBLEtBQUk7SUFDL0M7QUFWQSxZQUFBLG1CQUFBOzs7Ozs7Ozs7Ozs7O0FDaE1BLFFBQUEsa0JBQUFHLGlCQUFBLHVCQUFBO0FBQ0EsUUFBQSxVQUFBQSxpQkFBQSxtQkFBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsYUFBQTtBQUNBLFlBQUEsUUFBTSxPQUFPLGdCQUFBLE9BQWE7QUFFMUIsUUFBYSx3QkFBYixNQUFrQztNQUk5QixZQUFZLE9BQStCOztBQUN2QyxnQkFBUSxVQUFLLFFBQUwsVUFBSyxTQUFMLFFBQVMsSUFBSSxLQUFJO0FBQ3pCLFlBQUksaUJBQWlCLE1BQU07QUFDdkIsZUFBSyxVQUFVO2VBQ1o7QUFDSCxlQUFLLFdBQVUsS0FBQSxNQUFNLGFBQU8sUUFBQSxPQUFBLFNBQUEsS0FBSSxJQUFJLEtBQUk7QUFDeEMsZUFBSyxpQkFBaUIsV0FBQSxpQkFBaUIsTUFBTSxRQUFROztNQUU3RDs7QUFaSixZQUFBLHdCQUFBO0FBZUEsUUFBYSxvQkFBYixNQUE4QjtNQUsxQixZQUFZLFdBQWtDLGlCQUErQztBQUN6RixhQUFLLFlBQVk7QUFDakIsYUFBSyxjQUFjLENBQUE7QUFDbkIsYUFBSyxnQkFBZ0IsQ0FBQTtBQUNyQixZQUFJLGlCQUFpQjtBQUNqQixxQkFBVyxPQUFPLGlCQUFpQjtBQUMvQixpQkFBSyxZQUFZLE9BQW9CLGdCQUFnQjs7O0FBSTdELGNBQU0sV0FBVyxRQUFBLFFBQU0sVUFBVSxPQUFPO0FBQ3hDLGFBQUssTUFBTSxPQUFPLFNBQVMsS0FBSSxDQUFFO0FBQ2pDLGFBQUssTUFBTSxTQUFTLFNBQVMsTUFBSyxJQUFLLENBQUM7QUFDeEMsYUFBSyxNQUFNLFFBQVEsU0FBUyxLQUFJLENBQUU7QUFDbEMsYUFBSyxNQUFNLFFBQVEsRUFBRTtBQUNyQixhQUFLLE1BQU0sVUFBVSxDQUFDO0FBQ3RCLGFBQUssTUFBTSxVQUFVLENBQUM7QUFDdEIsYUFBSyxNQUFNLGVBQWUsQ0FBQztNQUMvQjtNQUVBLElBQUksV0FBb0I7QUFDcEIsWUFBSSxhQUFhLEtBQUssYUFBYTtBQUMvQixpQkFBTyxLQUFLLFlBQVk7O0FBRzVCLFlBQUksYUFBYSxLQUFLLGVBQWU7QUFDakMsaUJBQU8sS0FBSyxjQUFjOztBQUc5QixlQUFPO01BQ1g7TUFFQSxVQUFVLFdBQW9CO0FBQzFCLGVBQU8sYUFBYSxLQUFLO01BQzdCO01BRUEsdUJBQW9CO0FBQ2hCLGVBQU8sT0FBTyxLQUFLLEtBQUssV0FBVztNQUN2QztNQUVBLE1BQU0sV0FBc0IsT0FBYTtBQUNyQyxZQUFJLGFBQWEsS0FBSyxhQUFhO0FBQy9CLGlCQUFPOztBQUVYLGFBQUssY0FBYyxhQUFhO0FBQ2hDLGVBQU87TUFDWDtNQUVBLE9BQU8sV0FBc0IsT0FBYTtBQUN0QyxhQUFLLFlBQVksYUFBYTtBQUM5QixlQUFPLEtBQUssY0FBYztBQUMxQixlQUFPO01BQ1g7TUFFQSxPQUFPLFdBQW9CO0FBQ3ZCLGVBQU8sS0FBSyxZQUFZO0FBQ3hCLGVBQU8sS0FBSyxjQUFjO01BQzlCO01BRUEsUUFBSztBQUNELGNBQU0sWUFBWSxJQUFJLGtCQUFrQixLQUFLLFNBQVM7QUFDdEQsa0JBQVUsY0FBYyxDQUFBO0FBQ3hCLGtCQUFVLGdCQUFnQixDQUFBO0FBRTFCLG1CQUFXLE9BQU8sS0FBSyxhQUFhO0FBQ2hDLG9CQUFVLFlBQVksT0FBb0IsS0FBSyxZQUFZOztBQUcvRCxtQkFBVyxPQUFPLEtBQUssZUFBZTtBQUNsQyxvQkFBVSxjQUFjLE9BQW9CLEtBQUssY0FBYzs7QUFHbkUsZUFBTztNQUNYO01BRUEsYUFBVTtBQUNOLGVBQU8sQ0FBQyxLQUFLLFVBQVUsTUFBTSxLQUFLLENBQUMsS0FBSyxVQUFVLFFBQVEsS0FBSyxDQUFDLEtBQUssVUFBVSxRQUFRO01BQzNGO01BRUEsYUFBVTtBQUNOLGVBQU8sQ0FBQyxLQUFLLFVBQVUsU0FBUyxLQUFLLENBQUMsS0FBSyxVQUFVLEtBQUssS0FBSyxDQUFDLEtBQUssVUFBVSxPQUFPO01BQzFGO01BRUEseUJBQXNCO0FBQ2xCLGVBQU8sS0FBSyxVQUFVLFNBQVMsS0FBSyxDQUFDLEtBQUssVUFBVSxLQUFLLEtBQUssQ0FBQyxLQUFLLFVBQVUsT0FBTztNQUN6RjtNQUVBLDBCQUF1QjtBQUNuQixlQUFPLEtBQUssVUFBVSxLQUFLLEtBQUssS0FBSyxVQUFVLE9BQU8sS0FBSyxDQUFDLEtBQUssVUFBVSxNQUFNO01BQ3JGO01BRUEsY0FBVztBQUNQLGNBQU0sT0FBTyxLQUFLLDhCQUE2QjtBQUUvQyxZQUFJLEtBQUssWUFBVyxNQUFPLEtBQUssSUFBSSxNQUFNO0FBQUcsaUJBQU87QUFDcEQsWUFBSSxLQUFLLFNBQVEsTUFBTyxLQUFLLElBQUksT0FBTyxJQUFJO0FBQUcsaUJBQU87QUFDdEQsWUFBSSxLQUFLLFFBQU8sTUFBTyxLQUFLLElBQUksS0FBSztBQUFHLGlCQUFPO0FBQy9DLFlBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxRQUFRLEtBQUssU0FBUSxLQUFNLEtBQUssSUFBSSxNQUFNO0FBQUcsaUJBQU87QUFDNUUsWUFBSSxLQUFLLElBQUksUUFBUSxLQUFLLFFBQVEsS0FBSyxXQUFVLEtBQU0sS0FBSyxJQUFJLFFBQVE7QUFBRyxpQkFBTztBQUVsRixlQUFPO01BQ1g7TUFFQSxXQUFRO0FBQ0osZUFBTyxvQ0FBb0MsS0FBSyxVQUFVLEtBQUssV0FBVyxxQkFBcUIsS0FBSyxVQUNoRyxLQUFLLGFBQWEsa0JBQ0osS0FBSyxVQUFVLEtBQUssU0FBUztNQUNuRDtNQUVBLFFBQUs7QUFDRCxlQUFPLFFBQUEsUUFBTSxLQUFLLEtBQUksQ0FBRTtNQUM1QjtNQUVBLE9BQUk7QUFDQSxjQUFNLE9BQU8sS0FBSyw4QkFBNkI7QUFDL0MsZUFBTyxJQUFJLEtBQUssS0FBSyxRQUFPLElBQUssS0FBSyxrQ0FBa0MsSUFBSSxJQUFJLEdBQUs7TUFDekY7TUFFUSxnQ0FBNkI7QUFDakMsY0FBTSxPQUFPLElBQUksS0FDYixLQUFLLElBQUksTUFBTSxHQUNmLEtBQUssSUFBSSxPQUFPLElBQUksR0FDcEIsS0FBSyxJQUFJLEtBQUssR0FDZCxLQUFLLElBQUksTUFBTSxHQUNmLEtBQUssSUFBSSxRQUFRLEdBQ2pCLEtBQUssSUFBSSxRQUFRLEdBQ2pCLEtBQUssSUFBSSxhQUFhLENBQUM7QUFHM0IsYUFBSyxZQUFZLEtBQUssSUFBSSxNQUFNLENBQUM7QUFDakMsZUFBTztNQUNYO01BRVEsa0NBQWtDLE1BQVc7O0FBQ2pELFlBQUksQ0FBQyxRQUFRLEtBQUssUUFBTyxJQUFLLEdBQUc7QUFHN0IsaUJBQU8sSUFBSSxLQUFJOztBQUduQixjQUFNLHdCQUF3QixDQUFDLEtBQUssa0JBQWlCO0FBQ3JELGNBQU0sd0JBQ0YsTUFBQSxLQUFBLEtBQUssSUFBSSxnQkFBZ0IsT0FBQyxRQUFBLE9BQUEsU0FBQSxLQUFJLEtBQUssVUFBVSxvQkFBYyxRQUFBLE9BQUEsU0FBQSxLQUFJO0FBRW5FLGVBQU8sd0JBQXdCO01BQ25DO01BRUEsT0FBTyw0QkFDSCxXQUNBLFdBQXdDO0FBRXhDLFlBQUksT0FBTyxRQUFBLFFBQU0sVUFBVSxPQUFPO0FBQ2xDLG1CQUFXLE9BQU8sV0FBVztBQUN6QixpQkFBTyxLQUFLLElBQUksVUFBVSxNQUFtQixHQUFnQjs7QUFHakUsY0FBTSxhQUFhLElBQUksa0JBQWtCLFNBQVM7QUFDbEQsWUFBSSxVQUFVLFdBQVcsVUFBVSxhQUFhLFVBQVUsV0FBVztBQUNqRSxrQkFBQSxrQkFBa0IsWUFBWSxJQUFJO0FBQ2xDLGtCQUFBLGtCQUFrQixZQUFZLElBQUk7QUFDbEMsY0FBSSxVQUFVLG1CQUFtQixNQUFNO0FBQ25DLHVCQUFXLE9BQU8sa0JBQWtCLENBQUMsVUFBVSxRQUFRLGtCQUFpQixDQUFFOztlQUUzRTtBQUNILGtCQUFBLGlCQUFpQixZQUFZLElBQUk7QUFDakMsY0FBSSxVQUFVLG1CQUFtQixNQUFNO0FBQ25DLHVCQUFXLE1BQU0sa0JBQWtCLENBQUMsVUFBVSxRQUFRLGtCQUFpQixDQUFFOztBQUc3RSxjQUFJLFVBQVUsTUFBTTtBQUNoQix1QkFBVyxPQUFPLE9BQU8sS0FBSyxLQUFJLENBQUU7QUFDcEMsdUJBQVcsT0FBTyxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDM0MsdUJBQVcsT0FBTyxRQUFRLEtBQUssS0FBSSxDQUFFO2lCQUNsQztBQUNILGdCQUFJLFVBQVUsU0FBUztBQUNuQix5QkFBVyxNQUFNLFdBQVcsS0FBSyxJQUFHLENBQUU7O0FBRzFDLHVCQUFXLE1BQU0sT0FBTyxLQUFLLEtBQUksQ0FBRTtBQUNuQyxnQkFBSSxVQUFVLFVBQVU7QUFDcEIseUJBQVcsT0FBTyxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDM0MseUJBQVcsT0FBTyxRQUFRLEtBQUssS0FBSSxDQUFFO21CQUNsQztBQUNILHlCQUFXLE1BQU0sU0FBUyxLQUFLLE1BQUssSUFBSyxDQUFDO0FBQzFDLGtCQUFJLFVBQVUsU0FBUztBQUNuQiwyQkFBVyxPQUFPLFFBQVEsS0FBSyxLQUFJLENBQUU7cUJBQ2xDO0FBQ0gsMkJBQVcsTUFBTSxRQUFRLEtBQUssS0FBSSxDQUFFOzs7OztBQU1wRCxlQUFPO01BQ1g7O0FBdk1KLFlBQUEsb0JBQUE7QUEwTUEsUUFBYSxnQkFBYixNQUEwQjtNQVV0QixZQUNJLFdBQ0EsT0FDQUMsT0FDQSxPQUNBLEtBQXVCO0FBRXZCLGFBQUssWUFBWTtBQUNqQixhQUFLLFVBQVUsVUFBVTtBQUN6QixhQUFLLFFBQVE7QUFDYixhQUFLLE9BQU9BO0FBQ1osYUFBSyxRQUFRLFNBQVMsSUFBSSxrQkFBa0IsU0FBUztBQUNyRCxhQUFLLE1BQU07TUFDZjtNQUVBLFFBQUs7QUFDRCxjQUFNLFNBQVMsSUFBSSxjQUFjLEtBQUssV0FBVyxLQUFLLE9BQU8sS0FBSyxJQUFJO0FBQ3RFLGVBQU8sUUFBUSxLQUFLLFFBQVEsS0FBSyxNQUFNLE1BQUssSUFBSztBQUNqRCxlQUFPLE1BQU0sS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFLLElBQUs7QUFDM0MsZUFBTztNQUNYO01BRUEsT0FBSTtBQUNBLGVBQU8sS0FBSyxNQUFNLEtBQUk7TUFDMUI7TUFFQSxXQUFRO0FBQ0osZUFBTywwQkFBMEIsS0FBSyxpQkFBaUIsS0FBSztNQUNoRTs7QUF0Q0osWUFBQSxnQkFBQTs7Ozs7Ozs7OztBQzFOQSxRQUFzQix5Q0FBdEIsTUFBNEQ7TUFBNUQsY0FBQTtBQU9ZLGFBQUEscUJBQThCO0FBQzlCLGFBQUEsZ0JBQXlCO01BMkJyQztNQXpCSSxzQkFBbUI7QUFDZixlQUFPO01BQ1g7TUFFQSxRQUFRLFNBQXVCO0FBQzNCLGNBQU0sZUFBZSxLQUFLLGFBQWEsT0FBTztBQUM5QyxZQUFJLGdCQUFnQixLQUFLLG9CQUFvQjtBQUN6QyxpQkFBTyxLQUFLOztBQUdoQixhQUFLLGdCQUFnQixJQUFJLE9BQU8sR0FBRyxLQUFLLG9CQUFtQixJQUFLLGFBQWEsVUFBVSxhQUFhLEtBQUs7QUFDekcsYUFBSyxxQkFBcUI7QUFDMUIsZUFBTyxLQUFLO01BQ2hCO01BRUEsUUFBUSxTQUF5QixPQUF1Qjs7QUFDcEQsY0FBTSxVQUFTLEtBQUEsTUFBTSxRQUFFLFFBQUEsT0FBQSxTQUFBLEtBQUk7QUFDM0IsY0FBTSxRQUFRLE1BQU0sUUFBUSxPQUFPO0FBQ25DLGNBQU0sS0FBSyxNQUFNLEdBQUcsVUFBVSxPQUFPLE1BQU07QUFDM0MsaUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDbkMsZ0JBQU0sSUFBSSxLQUFLLE1BQU07O0FBR3pCLGVBQU8sS0FBSyxhQUFhLFNBQVMsS0FBSztNQUMzQzs7QUFsQ0osWUFBQSx5Q0FBQTs7Ozs7Ozs7O0FDUEEsUUFBQSxjQUFBO0FBRUEsUUFBQSxZQUFBO0FBQ0EsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sc0JBQXNCLElBQUksT0FDNUIsdUZBQ3NFLFlBQUEsZ0NBQ3RFLEdBQUc7QUFHUCxRQUFNLHlCQUF5QixJQUFJLE9BQy9CLGtFQUFrRSxZQUFBLGdDQUNsRSxHQUFHO0FBR1AsUUFBcUIsK0JBQXJCLGNBQTBELGlDQUFBLHVDQUFzQztNQUM1RixhQUFhLFNBQXVCO0FBQ2hDLGVBQU8sUUFBUSxPQUFPLGNBQWMseUJBQXlCO01BQ2pFO01BRUEsYUFBYSxTQUF5QixPQUF1QjtBQUN6RCxjQUFNLFlBQVksWUFBQSxlQUFlLE1BQU0sRUFBRTtBQUN6QyxlQUFPLFVBQUEsa0JBQWtCLDRCQUE0QixRQUFRLFdBQVcsU0FBUztNQUNyRjs7QUFSSixZQUFBLFVBQUE7Ozs7Ozs7OztBQ2RBLFFBQUEsVUFBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsbUNBQUE7QUFHQSxRQUFNLFVBQVUsSUFBSSxPQUNoQixtQkFDUSxZQUFBLHFGQUdJLFlBQUEsNERBR0osVUFBQSxnQkFBZ0IsWUFBQSxnQkFBZ0IsMkJBRzVCLFlBQUEseUNBR1osR0FBRztBQUdQLFFBQU0sYUFBYTtBQUNuQixRQUFNLGdCQUFnQjtBQUN0QixRQUFNLG1CQUFtQjtBQUN6QixRQUFNLGFBQWE7QUFFbkIsUUFBcUIsZ0NBQXJCLGNBQTJELGlDQUFBLHVDQUFzQztNQUM3RixlQUFZO0FBQ1IsZUFBTztNQUNYO01BRUEsYUFBYSxTQUF5QixPQUF1QjtBQUN6RCxjQUFNLFNBQVMsUUFBUSxvQkFBb0IsTUFBTSxPQUFPLE1BQU0sRUFBRTtBQUVoRSxjQUFNLFFBQVEsWUFBQSxpQkFBaUIsTUFBTSxrQkFBa0IsWUFBVztBQUNsRSxjQUFNLE1BQU0sWUFBQSwwQkFBMEIsTUFBTSxXQUFXO0FBQ3ZELFlBQUksTUFBTSxJQUFJO0FBRVYsZ0JBQU0sUUFBUSxNQUFNLFFBQVEsTUFBTSxZQUFZO0FBQzlDLGlCQUFPOztBQUdYLGVBQU8sTUFBTSxPQUFPLFNBQVMsS0FBSztBQUNsQyxlQUFPLE1BQU0sT0FBTyxPQUFPLEdBQUc7QUFFOUIsWUFBSSxNQUFNLGFBQWE7QUFDbkIsZ0JBQU0sYUFBYSxZQUFBLFVBQVUsTUFBTSxXQUFXO0FBQzlDLGlCQUFPLE1BQU0sT0FBTyxRQUFRLFVBQVU7ZUFDbkM7QUFDSCxnQkFBTSxPQUFPLFFBQUEscUJBQXFCLFFBQVEsU0FBUyxLQUFLLEtBQUs7QUFDN0QsaUJBQU8sTUFBTSxNQUFNLFFBQVEsSUFBSTs7QUFHbkMsWUFBSSxNQUFNLGdCQUFnQjtBQUN0QixnQkFBTSxVQUFVLFlBQUEsMEJBQTBCLE1BQU0sY0FBYztBQUU5RCxpQkFBTyxNQUFNLE9BQU8sTUFBTSxNQUFLO0FBQy9CLGlCQUFPLElBQUksT0FBTyxPQUFPLE9BQU87O0FBR3BDLGVBQU87TUFDWDs7QUFuQ0osWUFBQSxVQUFBOzs7Ozs7Ozs7QUMvQkEsUUFBQSxVQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sVUFBVSxJQUFJLE9BQ2hCLElBQUksVUFBQSxnQkFBZ0IsWUFBQSxnQkFBZ0Isd0JBRTVCLFlBQUEsaUVBR0EsWUFBQSxzREFJQSxZQUFBLHNDQUdSLEdBQUc7QUFHUCxRQUFNLG1CQUFtQjtBQUN6QixRQUFNLGFBQWE7QUFDbkIsUUFBTSxnQkFBZ0I7QUFDdEIsUUFBTSxhQUFhO0FBWW5CLFFBQXFCLGdDQUFyQixjQUEyRCxpQ0FBQSx1Q0FBc0M7TUFDN0YsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLGFBQWEsU0FBeUIsT0FBdUI7QUFDekQsY0FBTSxRQUFRLFlBQUEsaUJBQWlCLE1BQU0sa0JBQWtCLFlBQVc7QUFDbEUsY0FBTSxNQUFNLFlBQUEsMEJBQTBCLE1BQU0sV0FBVztBQUN2RCxZQUFJLE1BQU0sSUFBSTtBQUNWLGlCQUFPOztBQUdYLGNBQU0sYUFBYSxRQUFRLHdCQUF3QjtVQUMvQztVQUNBO1NBQ0g7QUFFRCxZQUFJLE1BQU0sYUFBYTtBQUNuQixnQkFBTSxPQUFPLFlBQUEsVUFBVSxNQUFNLFdBQVc7QUFDeEMscUJBQVcsT0FBTyxRQUFRLElBQUk7ZUFDM0I7QUFDSCxnQkFBTSxPQUFPLFFBQUEscUJBQXFCLFFBQVEsU0FBUyxLQUFLLEtBQUs7QUFDN0QscUJBQVcsTUFBTSxRQUFRLElBQUk7O0FBR2pDLFlBQUksQ0FBQyxNQUFNLGdCQUFnQjtBQUN2QixpQkFBTzs7QUFJWCxjQUFNLFVBQVUsWUFBQSwwQkFBMEIsTUFBTSxjQUFjO0FBQzlELGNBQU0sU0FBUyxRQUFRLG9CQUFvQixNQUFNLE9BQU8sTUFBTSxFQUFFO0FBQ2hFLGVBQU8sUUFBUTtBQUNmLGVBQU8sTUFBTSxXQUFXLE1BQUs7QUFDN0IsZUFBTyxJQUFJLE9BQU8sT0FBTyxPQUFPO0FBRWhDLGVBQU87TUFDWDs7QUFyQ0osWUFBQSxVQUFBOzs7Ozs7Ozs7QUN2Q0EsUUFBQSxjQUFBO0FBRUEsUUFBQSxVQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sVUFBVSxJQUFJLE9BQ2hCLGlCQUNRLFVBQUEsZ0JBQWdCLFlBQUEsZ0JBQWdCLHNCQUd2QixZQUFBLG9EQUdqQixHQUFHO0FBR1AsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sYUFBYTtBQVNuQixRQUFxQixvQkFBckIsY0FBK0MsaUNBQUEsdUNBQXNDO01BQ2pGLGVBQVk7QUFDUixlQUFPO01BQ1g7TUFFQSxhQUFhLFNBQXlCLE9BQXVCO0FBQ3pELGNBQU0sWUFBWSxNQUFNLGtCQUFrQixZQUFXO0FBR3JELFlBQUksTUFBTSxHQUFHLFVBQVUsS0FBSyxDQUFDLFlBQUEsMkJBQTJCLFlBQVk7QUFDaEUsaUJBQU87O0FBR1gsY0FBTSxTQUFTLFFBQVEsb0JBQ25CLE1BQU0sU0FBUyxNQUFNLGlCQUFpQixJQUFJLFFBQzFDLE1BQU0sUUFBUSxNQUFNLEdBQUcsTUFBTTtBQUVqQyxlQUFPLE1BQU0sTUFBTSxPQUFPLENBQUM7QUFFM0IsY0FBTSxRQUFRLFlBQUEsaUJBQWlCO0FBQy9CLGVBQU8sTUFBTSxPQUFPLFNBQVMsS0FBSztBQUVsQyxZQUFJLE1BQU0sYUFBYTtBQUNuQixnQkFBTSxPQUFPLFlBQUEsVUFBVSxNQUFNLFdBQVc7QUFDeEMsaUJBQU8sTUFBTSxPQUFPLFFBQVEsSUFBSTtlQUM3QjtBQUNILGdCQUFNLE9BQU8sUUFBQSxxQkFBcUIsUUFBUSxTQUFTLEdBQUcsS0FBSztBQUMzRCxpQkFBTyxNQUFNLE1BQU0sUUFBUSxJQUFJOztBQUduQyxlQUFPO01BQ1g7O0FBL0JKLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDNUJBLFFBQUEsY0FBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsbUNBQUE7QUFTQSxRQUFNLFVBQVUsSUFBSSxPQUNoQiw0QkFDVyxVQUFBLGdCQUFnQixZQUFBLGdCQUFnQixvREFHM0MsR0FBRztBQUdQLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0sb0JBQW9CO0FBRTFCLFFBQXFCLDZCQUFyQixjQUF3RCxpQ0FBQSx1Q0FBc0M7TUFDMUYsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLGFBQWEsU0FBeUIsT0FBdUI7QUFDekQsY0FBTSxRQUFRLE1BQU0sc0JBQ2QsU0FBUyxNQUFNLG1CQUFtQixJQUNsQyxZQUFBLGlCQUFpQixNQUFNLGtCQUFrQixZQUFXO0FBRTFELFlBQUksUUFBUSxLQUFLLFFBQVEsSUFBSTtBQUN6QixpQkFBTzs7QUFHWCxjQUFNLE9BQU8sU0FBUyxNQUFNLGtCQUFrQjtBQUM5QyxjQUFNLE1BQU0sU0FBUyxNQUFNLGtCQUFrQjtBQUU3QyxlQUFPO1VBQ0g7VUFDQTtVQUNBOztNQUVSOztBQXRCSixZQUFBLFVBQUE7Ozs7Ozs7OztBQ3ZCQSxRQUFBLG1DQUFBO0FBRUEsUUFBTSxVQUFVLElBQUksT0FBTyxvQ0FBeUMsR0FBRztBQUV2RSxRQUFNLGNBQWM7QUFDcEIsUUFBTSxhQUFhO0FBT25CLFFBQXFCLDJCQUFyQixjQUFzRCxpQ0FBQSx1Q0FBc0M7TUFDeEYsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLGFBQWEsU0FBeUIsT0FBdUI7QUFDekQsY0FBTSxPQUFPLFNBQVMsTUFBTSxXQUFXO0FBQ3ZDLGNBQU0sUUFBUSxTQUFTLE1BQU0sWUFBWTtBQUV6QyxlQUFPLFFBQVEsd0JBQXVCLEVBQUcsTUFBTSxPQUFPLENBQUMsRUFBRSxPQUFPLFNBQVMsS0FBSyxFQUFFLE9BQU8sUUFBUSxJQUFJO01BQ3ZHOztBQVZKLFlBQUEsVUFBQTs7Ozs7Ozs7OztBQ1pBLFFBQUEsVUFBQTtBQUdBLGFBQVMsbUJBQW1CLGNBQXNCLGVBQXVCLGVBQXVCLE9BQWE7QUFDekcsYUFBTyxJQUFJLE9BQ0gsR0FBRyxlQUNBLHdJQVlBLGlCQUNQLEtBQUs7SUFFYjtBQUdBLGFBQVMsb0JBQW9CLGdCQUF3QixpQkFBdUI7QUFDeEUsYUFBTyxJQUFJLE9BQ1AsS0FBSyx3SkFXRSxtQkFDUCxHQUFHO0lBRVg7QUFFQSxRQUFNLGFBQWE7QUFDbkIsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZUFBZTtBQUNyQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLG1CQUFtQjtBQUV6QixRQUFzQiwrQkFBdEIsTUFBa0Q7TUFLOUMsWUFBWSxhQUFhLE9BQUs7QUFpVnRCLGFBQUEsc0JBQXNCO0FBQ3RCLGFBQUEsc0JBQXNCO0FBQ3RCLGFBQUEsMkJBQTJCO0FBcUIzQixhQUFBLHVCQUF1QjtBQUN2QixhQUFBLHdCQUF3QjtBQUN4QixhQUFBLDRCQUE0QjtBQXpXaEMsYUFBSyxhQUFhO01BQ3RCO01BRUEsZUFBWTtBQUNSLGVBQU87TUFDWDtNQUVBLDZCQUEwQjtBQUN0QixlQUFPO01BQ1g7TUFFQSxnQkFBYTtBQUNULGVBQU87TUFDWDtNQUVBLGtCQUFlO0FBQ1gsZUFBTztNQUNYO01BRUEsUUFBUSxTQUF1QjtBQUMzQixlQUFPLEtBQUssa0NBQWlDO01BQ2pEO01BRUEsUUFBUSxTQUF5QixPQUF1QjtBQUNwRCxjQUFNLGtCQUFrQixLQUFLLDZCQUE2QixTQUFTLEtBQUs7QUFDeEUsWUFBSSxDQUFDLGlCQUFpQjtBQUNsQixnQkFBTSxTQUFTLE1BQU0sR0FBRztBQUN4QixpQkFBTzs7QUFHWCxjQUFNLFFBQVEsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNyQyxjQUFNQyxRQUFPLE1BQU0sR0FBRyxVQUFVLE1BQU0sR0FBRyxNQUFNO0FBQy9DLGNBQU0sU0FBUyxRQUFRLG9CQUFvQixPQUFPQSxPQUFNLGVBQWU7QUFDdkUsY0FBTSxTQUFTLE1BQU0sR0FBRztBQUV4QixjQUFNLGdCQUFnQixRQUFRLEtBQUssVUFBVSxNQUFNLEtBQUs7QUFDeEQsY0FBTSxtQkFBbUIsS0FBSyxvQ0FBbUM7QUFDakUsY0FBTSxpQkFBaUIsaUJBQWlCLEtBQUssYUFBYTtBQUcxRCxZQUFJQSxNQUFLLE1BQU0sVUFBVSxLQUFLLGtCQUFrQixlQUFlLEdBQUcsTUFBTSx1QkFBdUIsR0FBRztBQUM5RixpQkFBTzs7QUFHWCxZQUNJLENBQUMsa0JBRUQsZUFBZSxHQUFHLE1BQU0sdUJBQXVCLEdBQ2pEO0FBQ0UsaUJBQU8sS0FBSyxzQ0FBc0MsTUFBTTs7QUFHNUQsZUFBTyxNQUFNLEtBQUssK0JBQStCLFNBQVMsZ0JBQWdCLE1BQU07QUFDaEYsWUFBSSxPQUFPLEtBQUs7QUFDWixpQkFBTyxRQUFRLGVBQWU7O0FBR2xDLGVBQU8sS0FBSyxtQ0FBbUMsTUFBTTtNQUN6RDtNQUVBLDZCQUNJLFNBQ0EsT0FDQSxTQUFTLE9BQUs7QUFFZCxjQUFNLGFBQWEsUUFBUSx3QkFBdUI7QUFDbEQsWUFBSSxTQUFTO0FBQ2IsWUFBSSxXQUFXO0FBR2YsWUFBSSxPQUFPLFNBQVMsTUFBTSxXQUFXO0FBQ3JDLFlBQUksT0FBTyxLQUFLO0FBQ1osY0FBSSxLQUFLLGNBQWMsTUFBTSxpQkFBaUIsTUFBTTtBQUNoRCxtQkFBTzs7QUFHWCxtQkFBUyxPQUFPO0FBQ2hCLGlCQUFPLEtBQUssTUFBTSxPQUFPLEdBQUc7O0FBR2hDLFlBQUksT0FBTyxJQUFJO0FBQ1gsaUJBQU87O0FBSVgsWUFBSSxNQUFNLGlCQUFpQixNQUFNO0FBQzdCLGNBQUksTUFBTSxjQUFjLFVBQVUsS0FBSyxDQUFDLE1BQU0sbUJBQW1CO0FBRTdELG1CQUFPOztBQUdYLG1CQUFTLFNBQVMsTUFBTSxhQUFhOztBQUd6QyxZQUFJLFVBQVUsSUFBSTtBQUNkLGlCQUFPOztBQUdYLFlBQUksT0FBTyxJQUFJO0FBQ1gscUJBQVcsUUFBQSxTQUFTOztBQUl4QixZQUFJLE1BQU0scUJBQXFCLE1BQU07QUFDakMsY0FBSSxPQUFPO0FBQUksbUJBQU87QUFDdEIsZ0JBQU0sT0FBTyxNQUFNLGtCQUFrQixHQUFHLFlBQVc7QUFDbkQsY0FBSSxRQUFRLEtBQUs7QUFDYix1QkFBVyxRQUFBLFNBQVM7QUFDcEIsZ0JBQUksUUFBUSxJQUFJO0FBQ1oscUJBQU87OztBQUlmLGNBQUksUUFBUSxLQUFLO0FBQ2IsdUJBQVcsUUFBQSxTQUFTO0FBQ3BCLGdCQUFJLFFBQVEsSUFBSTtBQUNaLHNCQUFROzs7O0FBS3BCLG1CQUFXLE9BQU8sUUFBUSxJQUFJO0FBQzlCLG1CQUFXLE9BQU8sVUFBVSxNQUFNO0FBRWxDLFlBQUksYUFBYSxNQUFNO0FBQ25CLHFCQUFXLE9BQU8sWUFBWSxRQUFRO2VBQ25DO0FBQ0gsY0FBSSxPQUFPLElBQUk7QUFDWCx1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7aUJBQ3JDO0FBQ0gsdUJBQVcsTUFBTSxZQUFZLFFBQUEsU0FBUyxFQUFFOzs7QUFLaEQsWUFBSSxNQUFNLHVCQUF1QixNQUFNO0FBQ25DLGdCQUFNLGNBQWMsU0FBUyxNQUFNLG9CQUFvQixVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ3RFLGNBQUksZUFBZTtBQUFNLG1CQUFPO0FBRWhDLHFCQUFXLE9BQU8sZUFBZSxXQUFXOztBQUloRCxZQUFJLE1BQU0saUJBQWlCLE1BQU07QUFDN0IsZ0JBQU0sU0FBUyxTQUFTLE1BQU0sYUFBYTtBQUMzQyxjQUFJLFVBQVU7QUFBSSxtQkFBTztBQUV6QixxQkFBVyxPQUFPLFVBQVUsTUFBTTs7QUFHdEMsZUFBTztNQUNYO01BRUEsK0JBQ0ksU0FDQSxPQUNBLFFBQXFCO0FBRXJCLGNBQU0sYUFBYSxRQUFRLHdCQUF1QjtBQUdsRCxZQUFJLE1BQU0sdUJBQXVCLE1BQU07QUFDbkMsZ0JBQU0sY0FBYyxTQUFTLE1BQU0sb0JBQW9CLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDdEUsY0FBSSxlQUFlO0FBQU0sbUJBQU87QUFFaEMscUJBQVcsT0FBTyxlQUFlLFdBQVc7O0FBSWhELFlBQUksTUFBTSxpQkFBaUIsTUFBTTtBQUM3QixnQkFBTSxTQUFTLFNBQVMsTUFBTSxhQUFhO0FBQzNDLGNBQUksVUFBVTtBQUFJLG1CQUFPO0FBRXpCLHFCQUFXLE9BQU8sVUFBVSxNQUFNOztBQUd0QyxZQUFJLE9BQU8sU0FBUyxNQUFNLFdBQVc7QUFDckMsWUFBSSxTQUFTO0FBQ2IsWUFBSSxXQUFXO0FBR2YsWUFBSSxNQUFNLGlCQUFpQixNQUFNO0FBQzdCLG1CQUFTLFNBQVMsTUFBTSxhQUFhO21CQUM5QixPQUFPLEtBQUs7QUFDbkIsbUJBQVMsT0FBTztBQUNoQixpQkFBTyxLQUFLLE1BQU0sT0FBTyxHQUFHOztBQUdoQyxZQUFJLFVBQVUsTUFBTSxPQUFPLElBQUk7QUFDM0IsaUJBQU87O0FBR1gsWUFBSSxRQUFRLElBQUk7QUFDWixxQkFBVyxRQUFBLFNBQVM7O0FBSXhCLFlBQUksTUFBTSxxQkFBcUIsTUFBTTtBQUNqQyxjQUFJLE9BQU8sSUFBSTtBQUNYLG1CQUFPOztBQUdYLGdCQUFNLE9BQU8sTUFBTSxrQkFBa0IsR0FBRyxZQUFXO0FBQ25ELGNBQUksUUFBUSxLQUFLO0FBQ2IsdUJBQVcsUUFBQSxTQUFTO0FBQ3BCLGdCQUFJLFFBQVEsSUFBSTtBQUNaLHFCQUFPO0FBQ1Asa0JBQUksQ0FBQyxXQUFXLFVBQVUsS0FBSyxHQUFHO0FBQzlCLDJCQUFXLE1BQU0sT0FBTyxXQUFXLElBQUksS0FBSyxJQUFJLENBQUM7Ozs7QUFLN0QsY0FBSSxRQUFRLEtBQUs7QUFDYix1QkFBVyxRQUFBLFNBQVM7QUFDcEIsZ0JBQUksUUFBUTtBQUFJLHNCQUFROztBQUc1QixjQUFJLENBQUMsT0FBTyxNQUFNLFVBQVUsVUFBVSxHQUFHO0FBQ3JDLGdCQUFJLFlBQVksUUFBQSxTQUFTLElBQUk7QUFDekIscUJBQU8sTUFBTSxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7QUFFMUMsa0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxLQUFLLElBQUk7QUFDaEMsdUJBQU8sTUFBTSxPQUFPLFFBQVEsQ0FBQzs7bUJBRTlCO0FBQ0gscUJBQU8sTUFBTSxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7QUFFMUMsa0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxLQUFLLElBQUk7QUFDaEMsdUJBQU8sTUFBTSxPQUFPLFFBQVEsT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLEVBQUU7Ozs7O0FBTXpFLG1CQUFXLE9BQU8sUUFBUSxJQUFJO0FBQzlCLG1CQUFXLE9BQU8sVUFBVSxNQUFNO0FBRWxDLFlBQUksWUFBWSxHQUFHO0FBQ2YscUJBQVcsT0FBTyxZQUFZLFFBQVE7ZUFDbkM7QUFDSCxnQkFBTSxZQUFZLE9BQU8sTUFBTSxVQUFVLFVBQVUsS0FBSyxPQUFPLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDbkYsY0FBSSxXQUFXO0FBQ1gsZ0JBQUksT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLEtBQUssTUFBTTtBQUV0Qyx5QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7dUJBQ2pDLFFBQVEsSUFBSTtBQUNuQix5QkFBVyxPQUFPLFFBQVEsT0FBTyxFQUFFO0FBQ25DLHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTs7cUJBRXRDLE9BQU8sSUFBSTtBQUNsQix1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7cUJBQ2pDLFFBQVEsSUFBSTtBQUNuQix1QkFBVyxNQUFNLFlBQVksUUFBQSxTQUFTLEVBQUU7OztBQUloRCxZQUFJLFdBQVcsS0FBSSxFQUFHLFFBQU8sSUFBSyxPQUFPLE1BQU0sS0FBSSxFQUFHLFFBQU8sR0FBSTtBQUM3RCxxQkFBVyxNQUFNLE9BQU8sV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDOztBQUdyRCxlQUFPO01BQ1g7TUFFUSxzQ0FBc0MsUUFBTTtBQUVoRCxZQUFJLE9BQU8sS0FBSyxNQUFNLE1BQU0sR0FBRztBQUMzQixpQkFBTzs7QUFJWCxZQUFJLE9BQU8sS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNoQyxpQkFBTzs7QUFJWCxZQUFJLE9BQU8sS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNoQyxpQkFBTzs7QUFJWCxjQUFNLG9CQUFvQixPQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFDaEUsWUFBSSxtQkFBbUI7QUFDbkIsZ0JBQU0sZ0JBQXdCLGtCQUFrQjtBQUdoRCxjQUFJLEtBQUssWUFBWTtBQUNqQixtQkFBTzs7QUFJWCxjQUFJLGNBQWMsU0FBUyxHQUFHLEtBQUssQ0FBQyxjQUFjLE1BQU0sZUFBZSxHQUFHO0FBQ3RFLG1CQUFPOztBQUlYLGdCQUFNLGtCQUFrQixTQUFTLGFBQWE7QUFDOUMsY0FBSSxrQkFBa0IsSUFBSTtBQUN0QixtQkFBTzs7O0FBSWYsZUFBTztNQUNYO01BRVEsbUNBQW1DLFFBQU07QUFDN0MsWUFBSSxPQUFPLEtBQUssTUFBTSxXQUFXLEdBQUc7QUFDaEMsaUJBQU87O0FBSVgsY0FBTSxvQkFBb0IsT0FBTyxLQUFLLE1BQU0scUNBQXFDO0FBQ2pGLFlBQUksbUJBQW1CO0FBRW5CLGNBQUksS0FBSyxZQUFZO0FBQ2pCLG1CQUFPOztBQUdYLGdCQUFNLGtCQUEwQixrQkFBa0I7QUFDbEQsZ0JBQU0sZ0JBQXdCLGtCQUFrQjtBQUVoRCxjQUFJLGNBQWMsU0FBUyxHQUFHLEtBQUssQ0FBQyxjQUFjLE1BQU0sZUFBZSxHQUFHO0FBQ3RFLG1CQUFPOztBQUlYLGdCQUFNLGtCQUFrQixTQUFTLGFBQWE7QUFDOUMsZ0JBQU0sb0JBQW9CLFNBQVMsZUFBZTtBQUNsRCxjQUFJLGtCQUFrQixNQUFNLG9CQUFvQixJQUFJO0FBQ2hELG1CQUFPOzs7QUFJZixlQUFPO01BQ1g7TUFNQSxvQ0FBaUM7QUFDN0IsY0FBTSxnQkFBZ0IsS0FBSyxjQUFhO0FBQ3hDLGNBQU0sZ0JBQWdCLEtBQUssY0FBYTtBQUV4QyxZQUFJLEtBQUssd0JBQXdCLGlCQUFpQixLQUFLLHdCQUF3QixlQUFlO0FBQzFGLGlCQUFPLEtBQUs7O0FBR2hCLGFBQUssMkJBQTJCLG1CQUM1QixLQUFLLDJCQUEwQixHQUMvQixlQUNBLGVBQ0EsS0FBSyxhQUFZLENBQUU7QUFFdkIsYUFBSyxzQkFBc0I7QUFDM0IsYUFBSyxzQkFBc0I7QUFDM0IsZUFBTyxLQUFLO01BQ2hCO01BTUEsc0NBQW1DO0FBQy9CLGNBQU0saUJBQWlCLEtBQUssZUFBYztBQUMxQyxjQUFNLGtCQUFrQixLQUFLLGdCQUFlO0FBRTVDLFlBQUksS0FBSyx5QkFBeUIsa0JBQWtCLEtBQUssMEJBQTBCLGlCQUFpQjtBQUNoRyxpQkFBTyxLQUFLOztBQUdoQixhQUFLLDRCQUE0QixvQkFBb0IsZ0JBQWdCLGVBQWU7QUFDcEYsYUFBSyx1QkFBdUI7QUFDNUIsYUFBSyx3QkFBd0I7QUFDN0IsZUFBTyxLQUFLO01BQ2hCOztBQTdYSixZQUFBLCtCQUFBOzs7Ozs7Ozs7QUNoREEsUUFBQSxVQUFBO0FBQ0EsUUFBQSxpQ0FBQTtBQUVBLFFBQXFCLHlCQUFyQixjQUFvRCwrQkFBQSw2QkFBNEI7TUFDNUUsWUFBWSxZQUFVO0FBQ2xCLGNBQU0sVUFBVTtNQUNwQjtNQUVBLGlCQUFjO0FBQ1YsZUFBTztNQUNYO01BRUEsZ0JBQWE7QUFDVCxlQUFPO01BQ1g7TUFFQSxnQkFBYTtBQUNULGVBQU87TUFDWDtNQUVBLDZCQUE2QixTQUF5QixPQUF1QjtBQUN6RSxjQUFNLGFBQWEsTUFBTSw2QkFBNkIsU0FBUyxLQUFLO0FBQ3BFLFlBQUksWUFBWTtBQUNaLGNBQUksTUFBTSxHQUFHLFNBQVMsT0FBTyxHQUFHO0FBQzVCLGtCQUFNLE9BQU8sV0FBVyxJQUFJLE1BQU07QUFDbEMsZ0JBQUksUUFBUSxLQUFLLE9BQU8sSUFBSTtBQUN4Qix5QkFBVyxPQUFPLFFBQVEsV0FBVyxJQUFJLE1BQU0sSUFBSSxFQUFFO0FBQ3JELHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTt1QkFDbEMsT0FBTyxHQUFHO0FBQ2pCLHlCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTs7O0FBSWpELGNBQUksTUFBTSxHQUFHLFNBQVMsV0FBVyxHQUFHO0FBQ2hDLHVCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN6QyxrQkFBTSxPQUFPLFdBQVcsSUFBSSxNQUFNO0FBQ2xDLGdCQUFJLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDeEIseUJBQVcsT0FBTyxRQUFRLFdBQVcsSUFBSSxNQUFNLElBQUksRUFBRTs7O0FBSTdELGNBQUksTUFBTSxHQUFHLFNBQVMsU0FBUyxHQUFHO0FBQzlCLHVCQUFXLE9BQU8sWUFBWSxRQUFBLFNBQVMsRUFBRTtBQUN6QyxrQkFBTSxPQUFPLFdBQVcsSUFBSSxNQUFNO0FBQ2xDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHlCQUFXLE9BQU8sUUFBUSxXQUFXLElBQUksTUFBTSxDQUFDOzs7O0FBSzVELGVBQU87TUFDWDs7QUFoREosWUFBQSxVQUFBOzs7Ozs7Ozs7O0FDQUEsYUFBZ0IsaUJBQWlCLFdBQW9CO0FBQ2pELFlBQU0sV0FBVyxDQUFBO0FBQ2pCLGlCQUFXLE9BQU8sV0FBVztBQUV6QixpQkFBUyxPQUFPLENBQUMsVUFBVTs7QUFHL0IsYUFBTztJQUNYO0FBUkEsWUFBQSxtQkFBQTtBQVVBLGFBQWdCLG9CQUFvQixZQUErQixXQUFvQjtBQUNuRixZQUFNLFNBQVMsV0FBVyxNQUFLO0FBRS9CLFVBQUksT0FBTyxXQUFXLE1BQUs7QUFDM0IsaUJBQVcsT0FBTyxXQUFXO0FBRXpCLGVBQU8sS0FBSyxJQUFJLFVBQVUsTUFBTSxHQUFnQjs7QUFHcEQsVUFBSSxTQUFTLGFBQWEsT0FBTyxhQUFhLFVBQVUsYUFBYSxXQUFXLGFBQWEsVUFBVSxXQUFXO0FBQzlHLGVBQU8sTUFBTSxPQUFPLEtBQUssS0FBSSxDQUFFO0FBQy9CLGVBQU8sTUFBTSxTQUFTLEtBQUssTUFBSyxJQUFLLENBQUM7QUFDdEMsZUFBTyxNQUFNLFFBQVEsS0FBSyxLQUFJLENBQUU7O0FBR3BDLFVBQUksWUFBWSxhQUFhLFlBQVksYUFBYSxVQUFVLFdBQVc7QUFDdkUsZUFBTyxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUU7QUFDcEMsZUFBTyxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUU7QUFDcEMsZUFBTyxNQUFNLFFBQVEsS0FBSyxLQUFJLENBQUU7O0FBR3BDLGFBQU87SUFDWDtBQXRCQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7QUNkQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLG1DQUFBO0FBQ0EsUUFBQSxjQUFBO0FBRUEsUUFBTSxVQUFVLElBQUksT0FBTyxJQUFJLFlBQUEsa0VBQWtFLEdBQUc7QUFDcEcsUUFBTSxpQkFBaUIsSUFBSSxPQUFPLElBQUksWUFBQSwrQ0FBK0MsR0FBRztBQUV4RixRQUFxQiw0QkFBckIsY0FBdUQsaUNBQUEsdUNBQXNDO01BQ3pGLFlBQW9CLFlBQW1CO0FBQ25DLGNBQUs7QUFEVyxhQUFBLGFBQUE7TUFFcEI7TUFFQSxlQUFZO0FBQ1IsZUFBTyxLQUFLLGFBQWEsaUJBQWlCO01BQzlDO01BRUEsYUFBYSxTQUF5QixPQUF1QjtBQUN6RCxjQUFNLFlBQVksWUFBQSxlQUFlLE1BQU0sRUFBRTtBQUN6QyxjQUFNLGtCQUFrQixZQUFBLGlCQUFpQixTQUFTO0FBRWxELGVBQU8sVUFBQSxrQkFBa0IsNEJBQTRCLFFBQVEsV0FBVyxlQUFlO01BQzNGOztBQWRKLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDUkEsUUFBQSxjQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxtQ0FBQTtBQUVBLFFBQU0sVUFBVSxJQUFJLE9BQ2hCLElBQUksWUFBQSwyRkFDSixHQUFHO0FBR1AsUUFBTSxpQkFBaUIsSUFBSSxPQUFPLE1BQVcsWUFBQSxxQkFBcUIsa0NBQTRDLEdBQUc7QUFDakgsUUFBTSxzQkFBc0I7QUFFNUIsUUFBcUIsOEJBQXJCLGNBQXlELGlDQUFBLHVDQUFzQztNQUMzRixZQUFvQixZQUFtQjtBQUNuQyxjQUFLO0FBRFcsYUFBQSxhQUFBO01BRXBCO01BRUEsZUFBWTtBQUNSLGVBQU8sS0FBSyxhQUFhLGlCQUFpQjtNQUM5QztNQUVBLGFBQWEsU0FBeUIsT0FBdUI7QUFDekQsY0FBTSxZQUFZLFlBQUEsZUFBZSxNQUFNLG9CQUFvQjtBQUMzRCxlQUFPLFVBQUEsa0JBQWtCLDRCQUE0QixRQUFRLFdBQVcsU0FBUztNQUNyRjs7QUFaSixZQUFBLFVBQUE7Ozs7Ozs7Ozs7QUNQQSxRQUFzQixTQUF0QixNQUE0QjtNQUd4QixPQUFPLFNBQXlCLFNBQXdCO0FBQ3BELGVBQU8sUUFBUSxPQUFPLENBQUMsTUFBTSxLQUFLLFFBQVEsU0FBUyxDQUFDLENBQUM7TUFDekQ7O0FBTEosWUFBQSxTQUFBO0FBV0EsUUFBc0IsaUJBQXRCLE1BQW9DO01BZWhDLE9BQU8sU0FBeUIsU0FBd0I7QUFDcEQsWUFBSSxRQUFRLFNBQVMsR0FBRztBQUNwQixpQkFBTzs7QUFHWCxjQUFNLGdCQUFpQyxDQUFBO0FBQ3ZDLFlBQUksWUFBWSxRQUFRO0FBQ3hCLFlBQUksYUFBYTtBQUVqQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBSztBQUNyQyx1QkFBYSxRQUFRO0FBRXJCLGdCQUFNLGNBQWMsUUFBUSxLQUFLLFVBQVUsVUFBVSxRQUFRLFVBQVUsS0FBSyxRQUFRLFdBQVcsS0FBSztBQUNwRyxjQUFJLENBQUMsS0FBSyxtQkFBbUIsYUFBYSxXQUFXLFlBQVksT0FBTyxHQUFHO0FBQ3ZFLDBCQUFjLEtBQUssU0FBUztBQUM1Qix3QkFBWTtpQkFDVDtBQUNILGtCQUFNLE9BQU87QUFDYixrQkFBTSxRQUFRO0FBQ2Qsa0JBQU0sZUFBZSxLQUFLLGFBQWEsYUFBYSxNQUFNLE9BQU8sT0FBTztBQUN4RSxvQkFBUSxNQUFNLE1BQUs7QUFDZixzQkFBUSxJQUFJLEdBQUcsS0FBSyxZQUFZLGVBQWUsWUFBWSxjQUFjLGNBQWM7WUFDM0YsQ0FBQztBQUVELHdCQUFZOzs7QUFJcEIsWUFBSSxhQUFhLE1BQU07QUFDbkIsd0JBQWMsS0FBSyxTQUFTOztBQUdoQyxlQUFPO01BQ1g7O0FBaERKLFlBQUEsaUJBQUE7Ozs7Ozs7OztBQ1pBLFFBQUEscUJBQUE7QUFFQSxRQUE4QixnQ0FBOUIsY0FBb0UsbUJBQUEsZUFBYztNQUc5RSxtQkFBbUIsYUFBYSxlQUFlLFlBQVU7QUFDckQsZUFBTyxDQUFDLGNBQWMsT0FBTyxDQUFDLFdBQVcsT0FBTyxZQUFZLE1BQU0sS0FBSyxlQUFjLENBQUUsS0FBSztNQUNoRztNQUVBLGFBQWEsYUFBYSxZQUFZLFVBQVE7QUFDMUMsWUFBSSxDQUFDLFdBQVcsTUFBTSx1QkFBc0IsS0FBTSxDQUFDLFNBQVMsTUFBTSx1QkFBc0IsR0FBSTtBQUN4RixtQkFBUyxNQUFNLHFCQUFvQixFQUFHLFFBQVEsQ0FBQyxRQUFPO0FBQ2xELGdCQUFJLENBQUMsV0FBVyxNQUFNLFVBQVUsR0FBRyxHQUFHO0FBQ2xDLHlCQUFXLE1BQU0sT0FBTyxLQUFLLFNBQVMsTUFBTSxJQUFJLEdBQUcsQ0FBQzs7VUFFNUQsQ0FBQztBQUVELHFCQUFXLE1BQU0scUJBQW9CLEVBQUcsUUFBUSxDQUFDLFFBQU87QUFDcEQsZ0JBQUksQ0FBQyxTQUFTLE1BQU0sVUFBVSxHQUFHLEdBQUc7QUFDaEMsdUJBQVMsTUFBTSxPQUFPLEtBQUssV0FBVyxNQUFNLElBQUksR0FBRyxDQUFDOztVQUU1RCxDQUFDOztBQUdMLFlBQUksV0FBVyxNQUFNLEtBQUksRUFBRyxRQUFPLElBQUssU0FBUyxNQUFNLEtBQUksRUFBRyxRQUFPLEdBQUk7QUFDckUsY0FBSSxhQUFhLFdBQVcsTUFBTSxNQUFLO0FBQ3ZDLGNBQUksV0FBVyxTQUFTLE1BQU0sTUFBSztBQUVuQyxjQUFJLFdBQVcsTUFBTSx1QkFBc0IsS0FBTSxXQUFXLElBQUksSUFBSSxNQUFNLEVBQUUsU0FBUyxRQUFRLEdBQUc7QUFDNUYseUJBQWEsV0FBVyxJQUFJLElBQUksTUFBTTtBQUN0Qyx1QkFBVyxNQUFNLE1BQU0sT0FBTyxXQUFXLEtBQUksQ0FBRTtBQUMvQyx1QkFBVyxNQUFNLE1BQU0sU0FBUyxXQUFXLE1BQUssSUFBSyxDQUFDO0FBQ3RELHVCQUFXLE1BQU0sTUFBTSxRQUFRLFdBQVcsS0FBSSxDQUFFO3FCQUN6QyxTQUFTLE1BQU0sdUJBQXNCLEtBQU0sU0FBUyxJQUFJLEdBQUcsTUFBTSxFQUFFLFFBQVEsVUFBVSxHQUFHO0FBQy9GLHVCQUFXLFNBQVMsSUFBSSxHQUFHLE1BQU07QUFDakMscUJBQVMsTUFBTSxNQUFNLE9BQU8sU0FBUyxLQUFJLENBQUU7QUFDM0MscUJBQVMsTUFBTSxNQUFNLFNBQVMsU0FBUyxNQUFLLElBQUssQ0FBQztBQUNsRCxxQkFBUyxNQUFNLE1BQU0sUUFBUSxTQUFTLEtBQUksQ0FBRTtpQkFDekM7QUFDSCxhQUFDLFVBQVUsVUFBVSxJQUFJLENBQUMsWUFBWSxRQUFROzs7QUFJdEQsY0FBTSxTQUFTLFdBQVcsTUFBSztBQUMvQixlQUFPLFFBQVEsV0FBVztBQUMxQixlQUFPLE1BQU0sU0FBUztBQUN0QixlQUFPLFFBQVEsS0FBSyxJQUFJLFdBQVcsT0FBTyxTQUFTLEtBQUs7QUFDeEQsWUFBSSxXQUFXLFFBQVEsU0FBUyxPQUFPO0FBQ25DLGlCQUFPLE9BQU8sV0FBVyxPQUFPLGNBQWMsU0FBUztlQUNwRDtBQUNILGlCQUFPLE9BQU8sU0FBUyxPQUFPLGNBQWMsV0FBVzs7QUFHM0QsZUFBTztNQUNYOztBQXBESixZQUFBLFVBQUE7Ozs7Ozs7Ozs7OztBQ0hBLFFBQUEsa0NBQUFDLGlCQUFBLHVDQUFBO0FBUUEsUUFBcUIsMEJBQXJCLGNBQXFELGdDQUFBLFFBQTZCO01BQzlFLGlCQUFjO0FBQ1YsZUFBTztNQUNYOztBQUhKLFlBQUEsVUFBQTs7Ozs7Ozs7OztBQ1hBLFFBQUEsVUFBQTtBQUVBLGFBQWdCLG9CQUFvQixZQUEyQixZQUF5QjtBQUNwRixZQUFNLFNBQVMsV0FBVyxNQUFLO0FBQy9CLFlBQU0sWUFBWSxXQUFXO0FBQzdCLFlBQU0sWUFBWSxXQUFXO0FBRTdCLGFBQU8sUUFBUSx1QkFBdUIsV0FBVyxTQUFTO0FBQzFELFVBQUksV0FBVyxPQUFPLFFBQVEsV0FBVyxPQUFPLE1BQU07QUFDbEQsY0FBTSxVQUFVLFdBQVcsT0FBTyxPQUFPLFdBQVcsUUFBUSxXQUFXO0FBQ3ZFLGNBQU0sVUFBVSxXQUFXLE9BQU8sT0FBTyxXQUFXLFFBQVEsV0FBVztBQUN2RSxjQUFNLGNBQWMsdUJBQXVCLFNBQVMsT0FBTztBQUUzRCxZQUFJLFdBQVcsT0FBTyxRQUFRLFlBQVksS0FBSSxFQUFHLFFBQU8sSUFBSyxPQUFPLE1BQU0sS0FBSSxFQUFHLFFBQU8sR0FBSTtBQUV4RixjQUFJLFlBQVksVUFBVSxLQUFLLEdBQUc7QUFDOUIsd0JBQVksT0FBTyxPQUFPLFlBQVksSUFBSSxLQUFLLElBQUksQ0FBQztpQkFDakQ7QUFDSCx3QkFBWSxNQUFNLE9BQU8sWUFBWSxJQUFJLEtBQUssSUFBSSxDQUFDOzs7QUFJM0QsZUFBTyxNQUFNOztBQUdqQixhQUFPO0lBQ1g7QUF4QkEsWUFBQSxzQkFBQTtBQTBCQSxhQUFnQix1QkFDWixlQUNBLGVBQWdDO0FBRWhDLFlBQU0sb0JBQW9CLGNBQWMsTUFBSztBQUU3QyxVQUFJLGNBQWMsVUFBVSxNQUFNLEdBQUc7QUFDakMsMEJBQWtCLE9BQU8sUUFBUSxjQUFjLElBQUksTUFBTSxDQUFDO0FBQzFELDBCQUFrQixPQUFPLFVBQVUsY0FBYyxJQUFJLFFBQVEsQ0FBQztBQUU5RCxZQUFJLGNBQWMsVUFBVSxRQUFRLEdBQUc7QUFDbkMsNEJBQWtCLE9BQU8sVUFBVSxjQUFjLElBQUksUUFBUSxDQUFDO0FBRTlELGNBQUksY0FBYyxVQUFVLGFBQWEsR0FBRztBQUN4Qyw4QkFBa0IsT0FBTyxlQUFlLGNBQWMsSUFBSSxhQUFhLENBQUM7aUJBQ3JFO0FBQ0gsOEJBQWtCLE1BQU0sZUFBZSxjQUFjLElBQUksYUFBYSxDQUFDOztlQUV4RTtBQUNILDRCQUFrQixNQUFNLFVBQVUsY0FBYyxJQUFJLFFBQVEsQ0FBQztBQUM3RCw0QkFBa0IsTUFBTSxlQUFlLGNBQWMsSUFBSSxhQUFhLENBQUM7O2FBRXhFO0FBQ0gsMEJBQWtCLE1BQU0sUUFBUSxjQUFjLElBQUksTUFBTSxDQUFDO0FBQ3pELDBCQUFrQixNQUFNLFVBQVUsY0FBYyxJQUFJLFFBQVEsQ0FBQztBQUM3RCwwQkFBa0IsTUFBTSxVQUFVLGNBQWMsSUFBSSxRQUFRLENBQUM7QUFDN0QsMEJBQWtCLE1BQU0sZUFBZSxjQUFjLElBQUksYUFBYSxDQUFDOztBQUczRSxVQUFJLGNBQWMsVUFBVSxnQkFBZ0IsR0FBRztBQUMzQywwQkFBa0IsT0FBTyxrQkFBa0IsY0FBYyxJQUFJLGdCQUFnQixDQUFDOztBQUdsRixVQUFJLGNBQWMsVUFBVSxVQUFVLEdBQUc7QUFDckMsMEJBQWtCLE9BQU8sWUFBWSxjQUFjLElBQUksVUFBVSxDQUFDO2lCQUMzRCxjQUFjLElBQUksVUFBVSxLQUFLLFFBQVEsa0JBQWtCLElBQUksVUFBVSxLQUFLLE1BQU07QUFDM0YsMEJBQWtCLE1BQU0sWUFBWSxjQUFjLElBQUksVUFBVSxDQUFDOztBQUdyRSxVQUFJLGtCQUFrQixJQUFJLFVBQVUsS0FBSyxRQUFBLFNBQVMsTUFBTSxrQkFBa0IsSUFBSSxNQUFNLElBQUksSUFBSTtBQUN4RixZQUFJLGNBQWMsVUFBVSxNQUFNLEdBQUc7QUFDakMsNEJBQWtCLE9BQU8sUUFBUSxrQkFBa0IsSUFBSSxNQUFNLElBQUksRUFBRTtlQUNoRTtBQUNILDRCQUFrQixNQUFNLFFBQVEsa0JBQWtCLElBQUksTUFBTSxJQUFJLEVBQUU7OztBQUkxRSxhQUFPO0lBQ1g7QUFoREEsWUFBQSx5QkFBQTs7Ozs7Ozs7O0FDekJBLFFBQUEscUJBQUE7QUFFQSxRQUFBLHVCQUFBO0FBRUEsUUFBOEIseUJBQTlCLGNBQTZELG1CQUFBLGVBQWM7TUFHdkUsbUJBQW1CLGFBQXFCLGVBQThCLFlBQXlCO0FBQzNGLGdCQUNNLGNBQWMsTUFBTSxXQUFVLEtBQU0sV0FBVyxNQUFNLFdBQVUsS0FDNUQsV0FBVyxNQUFNLFdBQVUsS0FBTSxjQUFjLE1BQU0sV0FBVSxNQUNwRSxZQUFZLE1BQU0sS0FBSyxlQUFjLENBQUUsS0FBSztNQUVwRDtNQUVBLGFBQWEsYUFBcUIsZUFBOEIsWUFBeUI7QUFDckYsY0FBTSxTQUFTLGNBQWMsTUFBTSxXQUFVLElBQ3ZDLHFCQUFBLG9CQUFvQixlQUFlLFVBQVUsSUFDN0MscUJBQUEsb0JBQW9CLFlBQVksYUFBYTtBQUVuRCxlQUFPLFFBQVEsY0FBYztBQUM3QixlQUFPLE9BQU8sY0FBYyxPQUFPLGNBQWMsV0FBVztBQUM1RCxlQUFPO01BQ1g7O0FBbkJKLFlBQUEsVUFBQTs7Ozs7Ozs7Ozs7O0FDUkEsUUFBQSxpQ0FBQUMsaUJBQUEsc0NBQUE7QUFRQSxRQUFxQix5QkFBckIsY0FBb0QsK0JBQUEsUUFBNEI7TUFDNUUsaUJBQWM7QUFDVixlQUFPLElBQUksT0FBTywwQ0FBMEM7TUFDaEU7O0FBSEosWUFBQSxVQUFBOzs7Ozs7Ozs7QUNKQSxRQUFNLHdCQUF3QixJQUFJLE9BQU8sNENBQTRDLEdBQUc7QUFDeEYsUUFBTSw0QkFBNEI7TUFDOUIsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLE9BQU87TUFDUCxPQUFPO01BQ1AsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLElBQUk7TUFDSixNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFN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QUFBQSxRQUN4QixPQUFPLEtBQUssSUFBSTtBQUFBLE1BQ3BCLENBQUM7QUFFRCxZQUFNLFNBQVMsSUFBSSxPQUFPLEVBQUUsZ0JBQWdCLEtBQUssSUFBSSxVQUFVLENBQUM7QUFDaEUsV0FBSyxRQUFRLElBQUlDLE9BQU07QUFBQSxRQUNuQixlQUFlLEtBQUssSUFBSTtBQUFBLFFBQ3hCLE9BQU8sS0FBSyxJQUFJO0FBQUEsUUFDaEI7QUFBQSxNQUNKLENBQUM7QUFDRCxXQUFLLGlCQUFpQixJQUFJLGVBQWUsRUFBRSxRQUFRLEtBQUssQ0FBQztBQUN6RCxXQUFLLGdCQUFnQixJQUFJLGNBQWMsRUFBRSxRQUFRLE1BQU0sT0FBTyxDQUFDO0FBRS9ELFdBQUssd0JBQXdCLHdCQUF3QixDQUFDO0FBQ3RELFdBQUs7QUFBQSxRQUNELElBQUksZ0JBQWdCLEtBQUssS0FBSyxZQUFZLENBQUM7QUFBQSxNQUMvQztBQUNBLFVBQUksU0FBUyxFQUFFLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDakM7QUFBQTtBQUFBLEVBRUEsV0FBVztBQTdDZjtBQThDUSxZQUFRLElBQUksMEJBQTBCO0FBQ3RDLGVBQUssVUFBTCxtQkFBWTtBQUFBLEVBQ2hCO0FBQUEsRUFFTSxlQUFlO0FBQUE7QUFDakIsWUFBTSxjQUFjLE1BQU0sS0FBSyxTQUFTO0FBQ3hDLHFCQUFlLFdBQVc7QUFBQSxJQUM5QjtBQUFBO0FBQUEsRUFFTSxlQUFlO0FBQUE7QUFDakIsWUFBTSxLQUFLLFNBQVMsWUFBWSxDQUFDO0FBQUEsSUFDckM7QUFBQTtBQUNKOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAiX19leHRlbmRzIiwgIl9fYXNzaWduIiwgIl9fcmVzdCIsICJfX2RlY29yYXRlIiwgIl9fcGFyYW0iLCAiX19tZXRhZGF0YSIsICJfX2F3YWl0ZXIiLCAiX19nZW5lcmF0b3IiLCAiX19leHBvcnRTdGFyIiwgIl9fdmFsdWVzIiwgIl9fcmVhZCIsICJfX3NwcmVhZCIsICJfX3NwcmVhZEFycmF5cyIsICJfX3NwcmVhZEFycmF5IiwgIl9fYXdhaXQiLCAiX19hc3luY0dlbmVyYXRvciIsICJfX2FzeW5jRGVsZWdhdG9yIiwgIl9fYXN5bmNWYWx1ZXMiLCAiX19tYWtlVGVtcGxhdGVPYmplY3QiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEluIiwgIl9fY3JlYXRlQmluZGluZyIsICJleHBvcnRzIiwgInYiLCAibW9kdWxlIiwgInQiLCAiZSIsICJuIiwgInIiLCAiaSIsICJzIiwgInUiLCAiTSIsICJtIiwgImgiLCAiJCIsICJsIiwgInkiLCAiZyIsICJEIiwgInYiLCAibyIsICJkIiwgImEiLCAiZiIsICJjIiwgIl9faW1wb3J0RGVmYXVsdCIsICJtb2R1bGUiLCAidCIsICJlIiwgImkiLCAiciIsICJzIiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInRleHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfYSIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAidGV4dCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAicGFyc2VEYXRlIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgInRleHQiLCAicGFyc2VEYXRlIiwgIl9faW1wb3J0RGVmYXVsdCIsICJ0ZXh0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19leHBvcnRTdGFyIiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydFN0YXIiLCAiX19pbXBvcnREZWZhdWx0IiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2ltcG9ydERlZmF1bHQiLCAidGV4dCIsICJwYXJzZURhdGUiLCAiX19pbXBvcnRTdGFyIiwgIk1lcmlkaWVtIiwgInRleHQiLCAicGFyc2VEYXRlIiwgIk9wZXJhdG9ycyIsICJTdHJ1Y3R1cmFsQ2hhcmFjdGVycyIsICJUb2tlbnMiLCAicmVxdWlyZV9jb25zdCIsICJfX2Fzc2lnbiIsICJyZXF1aXJlX3V0aWxzIiwgIl9fc3ByZWFkQXJyYXlzIiwgIl9fc3ByZWFkQXJyYXlzIiwgInJlcXVpcmVfdXRpbHMiLCAicmVxdWlyZV9jb25zdCIsICJfX3NwcmVhZEFycmF5cyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJ2YXVsdCIsICJtZXRhZGF0YUNhY2hlIiwgIldlZWtkYXkiLCAiZGF0ZXV0aWwiLCAiSXRlclJlc3VsdCIsICJ0c2xpYiIsICJDYWxsYmFja0l0ZXJSZXN1bHQiLCAiVG9UZXh0IiwgIlBhcnNlciIsICJ0ZXh0IiwgIkZyZXF1ZW5jeSIsICJ0ZXh0IiwgIlRpbWUiLCAiRGF0ZVRpbWUiLCAiYXR0ciIsICJEYXRlV2l0aFpvbmUiLCAiZGVmYXVsdEtleXMiLCAia2V5IiwgInZhbHVlIiwgIkNhY2hlIiwgIml0ZW0iLCAiaSIsICJJdGVyaW5mbyIsICJSUnVsZSIsICJ0ZXh0IiwgInpvbmVkRGF0ZSIsICJERUZBVUxUX09QVElPTlMiLCAidmFsIiwgImluaXRpYWxpemVPcHRpb25zIiwgImRlZmF1bHRLZXlzIiwgIlJSdWxlU2V0IiwgInRleHQiLCAicEVsZW1lbnQiLCAiZWxlbWVudCIsICJDYWNoZSIsICJtZXRhZGF0YUNhY2hlIiwgInZhdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZWxlbWVudCIsICJ0ZXh0IiwgImluc3RhbmNlIiwgImNyZWF0ZV9mcmFnbWVudCIsICJhdHRyIiwgImN0eCIsICJwYXJzZURhdGUiLCAicGFyc2VkU3RhcnREYXRlIiwgInBhcnNlZFNjaGVkdWxlZERhdGUiLCAicGFyc2VkRHVlRGF0ZSIsICJ0YXNrIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0YXNrIiwgImVsZW1lbnQiLCAiX2EiLCAic2VjdGlvbkluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiY2hyb25vIiwgInJlc3VsdCIsICJib29uUGFyc2UiLCAiZWxlbWVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAidGV4dCIsICJzZXR0aW5ncyIsICJpbXBvcnRfb2JzaWRpYW4iLCAic2V0dGluZ3MiLCAic2V0dGluZ3MiLCAiQ2FjaGUiXQp9Cg==
