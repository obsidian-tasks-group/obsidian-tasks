/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

/*
License obsidian-tasks:
MIT License

Copyright (c) 2021 Martin Schenck and Clare Macrae

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*
License rrule (included library):
rrule.js: Library for working with recurrence rules for calendar dates.
=======================================================================

Copyright 2010, Jakub Roztocil <jakub@roztocil.name> and Lars Schöning

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of The author nor the names of its contributors may
       be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



./rrule.js and ./test/tests.js is based on python-dateutil. LICENCE:

python-dateutil - Extensions to the standard Python datetime module.
====================================================================

Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
License chrono-node (included library):
The MIT License

Copyright (c) 2014, Wanasit Tanakitrungruang

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/chrono-node/dist/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/chrono-node/dist/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAnyPattern = exports.extractTerms = exports.repeatedTimeunitPattern = void 0;
    function repeatedTimeunitPattern(prefix, singleTimeunitPattern) {
      const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
      return `${prefix}${singleTimeunitPatternNoCapture}\\s{0,5}(?:,?\\s{0,5}${singleTimeunitPatternNoCapture}){0,10}`;
    }
    exports.repeatedTimeunitPattern = repeatedTimeunitPattern;
    function extractTerms(dictionary) {
      let keys;
      if (dictionary instanceof Array) {
        keys = [...dictionary];
      } else if (dictionary instanceof Map) {
        keys = Array.from(dictionary.keys());
      } else {
        keys = Object.keys(dictionary);
      }
      return keys;
    }
    exports.extractTerms = extractTerms;
    function matchAnyPattern(dictionary) {
      const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
      return `(?:${joinedTerms})`;
    }
    exports.matchAnyPattern = matchAnyPattern;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, g = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function(t2, e2, n2) {
        var r2;
        if (!t2)
          return D;
        if ("string" == typeof t2)
          v[t2] && (r2 = t2), e2 && (v[t2] = e2, r2 = t2);
        else {
          var i2 = t2.name;
          v[i2] = t2, r2 = i2;
        }
        return !n2 && r2 && (D = r2), r2 || !n2 && D;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match(l);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), $2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, l2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $2(1, 0) : $2(31, 11);
            case f:
              return r2 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
              return $2(r2 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $2 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y2 = function(t2) {
            var e2 = w($2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || $;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || l2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b = _.prototype;
      return w.prototype = b, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        b[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  }
});

// node_modules/chrono-node/dist/calculation/years.js
var require_years = __commonJS({
  "node_modules/chrono-node/dist/calculation/years.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findYearClosestToRef = exports.findMostLikelyADYear = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function findMostLikelyADYear(yearNumber) {
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.findMostLikelyADYear = findMostLikelyADYear;
    function findYearClosestToRef(refDate, day, month) {
      const refMoment = dayjs_1.default(refDate);
      let dateMoment = refMoment;
      dateMoment = dateMoment.month(month - 1);
      dateMoment = dateMoment.date(day);
      dateMoment = dateMoment.year(refMoment.year());
      const nextYear = dateMoment.add(1, "y");
      const lastYear = dateMoment.add(-1, "y");
      if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = nextYear;
      } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
        dateMoment = lastYear;
      }
      return dateMoment.year();
    }
    exports.findYearClosestToRef = findYearClosestToRef;
  }
});

// node_modules/chrono-node/dist/locales/en/constants.js
var require_constants = __commonJS({
  "node_modules/chrono-node/dist/locales/en/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      sunday: 0,
      sun: 0,
      "sun.": 0,
      monday: 1,
      mon: 1,
      "mon.": 1,
      tuesday: 2,
      tue: 2,
      "tue.": 2,
      wednesday: 3,
      wed: 3,
      "wed.": 3,
      thursday: 4,
      thurs: 4,
      "thurs.": 4,
      thur: 4,
      "thur.": 4,
      thu: 4,
      "thu.": 4,
      friday: 5,
      fri: 5,
      "fri.": 5,
      saturday: 6,
      sat: 6,
      "sat.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      january: 1,
      february: 2,
      march: 3,
      april: 4,
      may: 5,
      june: 6,
      july: 7,
      august: 8,
      september: 9,
      october: 10,
      november: 11,
      december: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10,
      eleven: 11,
      twelve: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      first: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12,
      thirteenth: 13,
      fourteenth: 14,
      fifteenth: 15,
      sixteenth: 16,
      seventeenth: 17,
      eighteenth: 18,
      nineteenth: 19,
      twentieth: 20,
      "twenty first": 21,
      "twenty-first": 21,
      "twenty second": 22,
      "twenty-second": 22,
      "twenty third": 23,
      "twenty-third": 23,
      "twenty fourth": 24,
      "twenty-fourth": 24,
      "twenty fifth": 25,
      "twenty-fifth": 25,
      "twenty sixth": 26,
      "twenty-sixth": 26,
      "twenty seventh": 27,
      "twenty-seventh": 27,
      "twenty eighth": 28,
      "twenty-eighth": 28,
      "twenty ninth": 29,
      "twenty-ninth": 29,
      "thirtieth": 30,
      "thirty first": 31,
      "thirty-first": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconds: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minutes: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      hour: "hour",
      hours: "hour",
      day: "d",
      days: "d",
      week: "week",
      weeks: "week",
      month: "month",
      months: "month",
      qtr: "quarter",
      quarter: "quarter",
      quarters: "quarter",
      y: "year",
      yr: "year",
      year: "year",
      years: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/BE/i.test(match)) {
        match = match.replace(/BE/i, "");
        return parseInt(match) - 543;
      }
      if (/BCE?/i.test(match)) {
        match = match.replace(/BCE?/i, "");
        return -parseInt(match);
      }
      if (/(AD|CE)/i.test(match)) {
        match = match.replace(/(AD|CE)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// node_modules/chrono-node/dist/utils/dayjs.js
var require_dayjs = __commonJS({
  "node_modules/chrono-node/dist/utils/dayjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implySimilarTime = exports.assignSimilarTime = exports.assignSimilarDate = exports.assignTheNextDay = void 0;
    var index_1 = require_dist();
    function assignTheNextDay(component, targetDayJs) {
      targetDayJs = targetDayJs.add(1, "day");
      assignSimilarDate(component, targetDayJs);
      implySimilarTime(component, targetDayJs);
    }
    exports.assignTheNextDay = assignTheNextDay;
    function assignSimilarDate(component, targetDayJs) {
      component.assign("day", targetDayJs.date());
      component.assign("month", targetDayJs.month() + 1);
      component.assign("year", targetDayJs.year());
    }
    exports.assignSimilarDate = assignSimilarDate;
    function assignSimilarTime(component, targetDayJs) {
      component.assign("hour", targetDayJs.hour());
      component.assign("minute", targetDayJs.minute());
      component.assign("second", targetDayJs.second());
      component.assign("millisecond", targetDayJs.millisecond());
      if (component.get("hour") < 12) {
        component.assign("meridiem", index_1.Meridiem.AM);
      } else {
        component.assign("meridiem", index_1.Meridiem.PM);
      }
    }
    exports.assignSimilarTime = assignSimilarTime;
    function implySimilarTime(component, targetDayJs) {
      component.imply("hour", targetDayJs.hour());
      component.imply("minute", targetDayJs.minute());
      component.imply("second", targetDayJs.second());
      component.imply("millisecond", targetDayJs.millisecond());
    }
    exports.implySimilarTime = implySimilarTime;
  }
});

// node_modules/chrono-node/dist/timezone.js
var require_timezone = __commonJS({
  "node_modules/chrono-node/dist/timezone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTimezoneOffset = exports.TIMEZONE_ABBR_MAP = void 0;
    exports.TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 180,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    function toTimezoneOffset(timezoneInput) {
      var _a;
      if (timezoneInput === null || timezoneInput === void 0) {
        return null;
      }
      if (typeof timezoneInput === "number") {
        return timezoneInput;
      }
      return (_a = exports.TIMEZONE_ABBR_MAP[timezoneInput]) !== null && _a !== void 0 ? _a : null;
    }
    exports.toTimezoneOffset = toTimezoneOffset;
  }
});

// node_modules/chrono-node/dist/results.js
var require_results = __commonJS({
  "node_modules/chrono-node/dist/results.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingResult = exports.ParsingComponents = exports.ReferenceWithTimezone = void 0;
    var quarterOfYear_1 = __importDefault(require_quarterOfYear());
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var timezone_1 = require_timezone();
    dayjs_1.default.extend(quarterOfYear_1.default);
    var ReferenceWithTimezone = class {
      constructor(input) {
        var _a;
        input = input !== null && input !== void 0 ? input : new Date();
        if (input instanceof Date) {
          this.instant = input;
        } else {
          this.instant = (_a = input.instant) !== null && _a !== void 0 ? _a : new Date();
          this.timezoneOffset = timezone_1.toTimezoneOffset(input.timezone);
        }
      }
    };
    exports.ReferenceWithTimezone = ReferenceWithTimezone;
    var ParsingComponents = class {
      constructor(reference, knownComponents) {
        this.reference = reference;
        this.knownValues = {};
        this.impliedValues = {};
        if (knownComponents) {
          for (const key in knownComponents) {
            this.knownValues[key] = knownComponents[key];
          }
        }
        const refDayJs = dayjs_1.default(reference.instant);
        this.imply("day", refDayJs.date());
        this.imply("month", refDayJs.month() + 1);
        this.imply("year", refDayJs.year());
        this.imply("hour", 12);
        this.imply("minute", 0);
        this.imply("second", 0);
        this.imply("millisecond", 0);
      }
      get(component) {
        if (component in this.knownValues) {
          return this.knownValues[component];
        }
        if (component in this.impliedValues) {
          return this.impliedValues[component];
        }
        return null;
      }
      isCertain(component) {
        return component in this.knownValues;
      }
      getCertainComponents() {
        return Object.keys(this.knownValues);
      }
      imply(component, value) {
        if (component in this.knownValues) {
          return this;
        }
        this.impliedValues[component] = value;
        return this;
      }
      assign(component, value) {
        this.knownValues[component] = value;
        delete this.impliedValues[component];
        return this;
      }
      delete(component) {
        delete this.knownValues[component];
        delete this.impliedValues[component];
      }
      clone() {
        const component = new ParsingComponents(this.reference);
        component.knownValues = {};
        component.impliedValues = {};
        for (const key in this.knownValues) {
          component.knownValues[key] = this.knownValues[key];
        }
        for (const key in this.impliedValues) {
          component.impliedValues[key] = this.impliedValues[key];
        }
        return component;
      }
      isOnlyDate() {
        return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
      }
      isOnlyTime() {
        return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyWeekdayComponent() {
        return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
      }
      isOnlyDayMonthComponent() {
        return this.isCertain("day") && this.isCertain("month") && !this.isCertain("year");
      }
      isValidDate() {
        const date = this.dateWithoutTimezoneAdjustment();
        if (date.getFullYear() !== this.get("year"))
          return false;
        if (date.getMonth() !== this.get("month") - 1)
          return false;
        if (date.getDate() !== this.get("day"))
          return false;
        if (this.get("hour") != null && date.getHours() != this.get("hour"))
          return false;
        if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
          return false;
        return true;
      }
      toString() {
        return `[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}, reference: ${JSON.stringify(this.reference)}]`;
      }
      dayjs() {
        return dayjs_1.default(this.date());
      }
      date() {
        const date = this.dateWithoutTimezoneAdjustment();
        return new Date(date.getTime() + this.getSystemTimezoneAdjustmentMinute(date) * 6e4);
      }
      dateWithoutTimezoneAdjustment() {
        const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
        date.setFullYear(this.get("year"));
        return date;
      }
      getSystemTimezoneAdjustmentMinute(date) {
        var _a, _b;
        if (!date || date.getTime() < 0) {
          date = new Date();
        }
        const currentTimezoneOffset = -date.getTimezoneOffset();
        const targetTimezoneOffset = (_b = (_a = this.get("timezoneOffset")) !== null && _a !== void 0 ? _a : this.reference.timezoneOffset) !== null && _b !== void 0 ? _b : currentTimezoneOffset;
        return currentTimezoneOffset - targetTimezoneOffset;
      }
      static createRelativeFromReference(reference, fragments) {
        let date = dayjs_1.default(reference.instant);
        for (const key in fragments) {
          date = date.add(fragments[key], key);
        }
        const components = new ParsingComponents(reference);
        if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
          dayjs_2.assignSimilarTime(components, date);
          dayjs_2.assignSimilarDate(components, date);
          if (reference.timezoneOffset !== null) {
            components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
        } else {
          dayjs_2.implySimilarTime(components, date);
          if (reference.timezoneOffset !== null) {
            components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
          }
          if (fragments["d"]) {
            components.assign("day", date.date());
            components.assign("month", date.month() + 1);
            components.assign("year", date.year());
          } else {
            if (fragments["week"]) {
              components.imply("weekday", date.day());
            }
            components.imply("day", date.date());
            if (fragments["month"]) {
              components.assign("month", date.month() + 1);
              components.assign("year", date.year());
            } else {
              components.imply("month", date.month() + 1);
              if (fragments["year"]) {
                components.assign("year", date.year());
              } else {
                components.imply("year", date.year());
              }
            }
          }
        }
        return components;
      }
    };
    exports.ParsingComponents = ParsingComponents;
    var ParsingResult = class {
      constructor(reference, index, text2, start, end) {
        this.reference = reference;
        this.refDate = reference.instant;
        this.index = index;
        this.text = text2;
        this.start = start || new ParsingComponents(reference);
        this.end = end;
      }
      clone() {
        const result = new ParsingResult(this.reference, this.index, this.text);
        result.start = this.start ? this.start.clone() : null;
        result.end = this.end ? this.end.clone() : null;
        return result;
      }
      date() {
        return this.start.date();
      }
      toString() {
        return `[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`;
      }
    };
    exports.ParsingResult = ParsingResult;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js
var require_AbstractParserWithWordBoundary = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractParserWithWordBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParserWithWordBoundaryChecking = void 0;
    var AbstractParserWithWordBoundaryChecking = class {
      constructor() {
        this.cachedInnerPattern = null;
        this.cachedPattern = null;
      }
      patternLeftBoundary() {
        return `(\\W|^)`;
      }
      pattern(context) {
        const innerPattern = this.innerPattern(context);
        if (innerPattern == this.cachedInnerPattern) {
          return this.cachedPattern;
        }
        this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${innerPattern.source}`, innerPattern.flags);
        this.cachedInnerPattern = innerPattern;
        return this.cachedPattern;
      }
      extract(context, match) {
        var _a;
        const header = (_a = match[1]) !== null && _a !== void 0 ? _a : "";
        match.index = match.index + header.length;
        match[0] = match[0].substring(header.length);
        for (let i = 2; i < match.length; i++) {
          match[i - 1] = match[i];
        }
        return this.innerExtract(context, match);
      }
    };
    exports.AbstractParserWithWordBoundaryChecking = AbstractParserWithWordBoundaryChecking;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var require_ENTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js
var require_ENMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s{0,3})?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = ENMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var require_ENMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants();
    var constants_2 = require_constants();
    var constants_3 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${constants_2.ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${constants_3.YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
    var MONTH_NAME_GROUP = 1;
    var DATE_GROUP = 2;
    var DATE_TO_GROUP = 3;
    var YEAR_GROUP = 4;
    var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = ENMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js
var require_ENMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:in)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var PREFIX_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var ENMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = ENMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js
var require_ENCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = ENCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js
var require_ENSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = ENSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js
var require_AbstractTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/AbstractTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractTimeExpressionParser = void 0;
    var index_1 = require_dist();
    function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
      return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
    }
    function followingTimePatten(followingPhase, followingSuffix) {
      return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
    }
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var MILLI_SECOND_GROUP = 5;
    var AM_PM_HOUR_GROUP = 6;
    var AbstractTimeExpressionParser = class {
      constructor(strictMode = false) {
        this.cachedPrimaryPrefix = null;
        this.cachedPrimarySuffix = null;
        this.cachedPrimaryTimePattern = null;
        this.cachedFollowingPhase = null;
        this.cachedFollowingSuffix = null;
        this.cachedFollowingTimePatten = null;
        this.strictMode = strictMode;
      }
      patternFlags() {
        return "i";
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|\\b)`;
      }
      primarySuffix() {
        return `(?=\\W|$)`;
      }
      followingSuffix() {
        return `(?=\\W|$)`;
      }
      pattern(context) {
        return this.getPrimaryTimePatternThroughCache();
      }
      extract(context, match) {
        const startComponents = this.extractPrimaryTimeComponents(context, match);
        if (!startComponents) {
          match.index += match[0].length;
          return null;
        }
        const index = match.index + match[1].length;
        const text2 = match[0].substring(match[1].length);
        const result = context.createParsingResult(index, text2, startComponents);
        match.index += match[0].length;
        const remainingText = context.text.substring(match.index);
        const followingPattern = this.getFollowingTimePatternThroughCache();
        const followingMatch = followingPattern.exec(remainingText);
        if (text2.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
          return null;
        }
        if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
          return this.checkAndReturnWithoutFollowingPattern(result);
        }
        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
        if (result.end) {
          result.text += followingMatch[0];
        }
        return this.checkAndReturnWithFollowingPattern(result);
      }
      extractPrimaryTimeComponents(context, match, strict = false) {
        const components = context.createParsingComponents();
        let minute = 0;
        let meridiem = null;
        let hour = parseInt(match[HOUR_GROUP]);
        if (hour > 100) {
          if (this.strictMode || match[MINUTE_GROUP] != null) {
            return null;
          }
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (hour > 24) {
          return null;
        }
        if (match[MINUTE_GROUP] != null) {
          if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
            return null;
          }
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem !== null) {
          components.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          } else {
            components.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        return components;
      }
      extractFollowingTimeComponents(context, match, result) {
        const components = context.createParsingComponents();
        if (match[MILLI_SECOND_GROUP] != null) {
          const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
          if (millisecond >= 1e3)
            return null;
          components.assign("millisecond", millisecond);
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          components.assign("second", second);
        }
        let hour = parseInt(match[HOUR_GROUP]);
        let minute = 0;
        let meridiem = -1;
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12) {
            return null;
          }
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
              if (!components.isCertain("day")) {
                components.imply("day", components.get("day") + 1);
              }
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == index_1.Meridiem.AM) {
              result.start.imply("meridiem", index_1.Meridiem.AM);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", index_1.Meridiem.PM);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        }
        components.assign("hour", hour);
        components.assign("minute", minute);
        if (meridiem >= 0) {
          components.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
          if (startAtPM) {
            if (result.start.get("hour") - 12 > hour) {
              components.imply("meridiem", index_1.Meridiem.AM);
            } else if (hour <= 12) {
              components.assign("hour", hour + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            }
          } else if (hour > 12) {
            components.imply("meridiem", index_1.Meridiem.PM);
          } else if (hour <= 12) {
            components.imply("meridiem", index_1.Meridiem.AM);
          }
        }
        if (components.date().getTime() < result.start.date().getTime()) {
          components.imply("day", components.get("day") + 1);
        }
        return components;
      }
      checkAndReturnWithoutFollowingPattern(result) {
        if (result.text.match(/^\d$/)) {
          return null;
        }
        if (result.text.match(/^\d\d\d+$/)) {
          return null;
        }
        if (result.text.match(/\d[apAP]$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
        if (endingWithNumbers) {
          const endingNumbers = endingWithNumbers[1];
          if (this.strictMode) {
            return null;
          }
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          if (endingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      checkAndReturnWithFollowingPattern(result) {
        if (result.text.match(/^\d+-\d+$/)) {
          return null;
        }
        const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
        if (endingWithNumbers) {
          if (this.strictMode) {
            return null;
          }
          const startingNumbers = endingWithNumbers[1];
          const endingNumbers = endingWithNumbers[2];
          if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
            return null;
          }
          const endingNumberVal = parseInt(endingNumbers);
          const startingNumberVal = parseInt(startingNumbers);
          if (endingNumberVal > 24 || startingNumberVal > 24) {
            return null;
          }
        }
        return result;
      }
      getPrimaryTimePatternThroughCache() {
        const primaryPrefix = this.primaryPrefix();
        const primarySuffix = this.primarySuffix();
        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
          return this.cachedPrimaryTimePattern;
        }
        this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
        this.cachedPrimaryPrefix = primaryPrefix;
        this.cachedPrimarySuffix = primarySuffix;
        return this.cachedPrimaryTimePattern;
      }
      getFollowingTimePatternThroughCache() {
        const followingPhase = this.followingPhase();
        const followingSuffix = this.followingSuffix();
        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
          return this.cachedFollowingTimePatten;
        }
        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
        this.cachedFollowingPhase = followingPhase;
        this.cachedFollowingSuffix = followingSuffix;
        return this.cachedFollowingTimePatten;
      }
    };
    exports.AbstractTimeExpressionParser = AbstractTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js
var require_ENTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var ENTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|\\?)\\s*";
      }
      primaryPrefix() {
        return "(?:(?:at|from)\\s*)??";
      }
      primarySuffix() {
        return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("night")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("afternoon")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("morning")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = ENTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/utils/timeunits.js
var require_timeunits = __commonJS({
  "node_modules/chrono-node/dist/utils/timeunits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addImpliedTimeUnits = exports.reverseTimeUnits = void 0;
    function reverseTimeUnits(timeUnits) {
      const reversed = {};
      for (const key in timeUnits) {
        reversed[key] = -timeUnits[key];
      }
      return reversed;
    }
    exports.reverseTimeUnits = reverseTimeUnits;
    function addImpliedTimeUnits(components, timeUnits) {
      const output = components.clone();
      let date = components.dayjs();
      for (const key in timeUnits) {
        date = date.add(timeUnits[key], key);
      }
      if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
        output.imply("day", date.date());
        output.imply("month", date.month() + 1);
        output.imply("year", date.year());
      }
      if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
        output.imply("second", date.second());
        output.imply("minute", date.minute());
        output.imply("hour", date.hour());
      }
      return output;
    }
    exports.addImpliedTimeUnits = addImpliedTimeUnits;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var require_ENTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}ago(?=(?:\\W|$))`, "i");
    var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = ENTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var require_ENTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|from now)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = ENTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/common/abstractRefiners.js
var require_abstractRefiners = __commonJS({
  "node_modules/chrono-node/dist/common/abstractRefiners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergingRefiner = exports.Filter = void 0;
    var Filter2 = class {
      refine(context, results) {
        return results.filter((r) => this.isValid(context, r));
      }
    };
    exports.Filter = Filter2;
    var MergingRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const mergedResults = [];
        let curResult = results[0];
        let nextResult = null;
        for (let i = 1; i < results.length; i++) {
          nextResult = results[i];
          const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
          if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
            mergedResults.push(curResult);
            curResult = nextResult;
          } else {
            const left = curResult;
            const right = nextResult;
            const mergedResult = this.mergeResults(textBetween, left, right, context);
            context.debug(() => {
              console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
            });
            curResult = mergedResult;
          }
        }
        if (curResult != null) {
          mergedResults.push(curResult);
        }
        return mergedResults;
      }
    };
    exports.MergingRefiner = MergingRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js
var require_AbstractMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateRangeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var AbstractMergeDateRangeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, fromResult, toResult) {
        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
          toResult.start.getCertainComponents().forEach((key) => {
            if (!fromResult.start.isCertain(key)) {
              fromResult.start.assign(key, toResult.start.get(key));
            }
          });
          fromResult.start.getCertainComponents().forEach((key) => {
            if (!toResult.start.isCertain(key)) {
              toResult.start.assign(key, fromResult.start.get(key));
            }
          });
        }
        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
          let fromMoment = fromResult.start.dayjs();
          let toMoment = toResult.start.dayjs();
          if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
            fromMoment = fromMoment.add(-7, "days");
            fromResult.start.imply("day", fromMoment.date());
            fromResult.start.imply("month", fromMoment.month() + 1);
            fromResult.start.imply("year", fromMoment.year());
          } else if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
            toMoment = toMoment.add(7, "days");
            toResult.start.imply("day", toMoment.date());
            toResult.start.imply("month", toMoment.month() + 1);
            toResult.start.imply("year", toMoment.year());
          } else {
            [toResult, fromResult] = [fromResult, toResult];
          }
        }
        const result = fromResult.clone();
        result.start = fromResult.start;
        result.end = toResult.start;
        result.index = Math.min(fromResult.index, toResult.index);
        if (fromResult.index < toResult.index) {
          result.text = fromResult.text + textBetween + toResult.text;
        } else {
          result.text = toResult.text + textBetween + fromResult.text;
        }
        return result;
      }
    };
    exports.default = AbstractMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js
var require_ENMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(to|-)\s*$/i;
      }
    };
    exports.default = ENMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/calculation/mergingCalculation.js
var require_mergingCalculation = __commonJS({
  "node_modules/chrono-node/dist/calculation/mergingCalculation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDateTimeComponent = exports.mergeDateTimeResult = void 0;
    var index_1 = require_dist();
    function mergeDateTimeResult(dateResult, timeResult) {
      const result = dateResult.clone();
      const beginDate = dateResult.start;
      const beginTime = timeResult.start;
      result.start = mergeDateTimeComponent(beginDate, beginTime);
      if (dateResult.end != null || timeResult.end != null) {
        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
        const endDateTime = mergeDateTimeComponent(endDate, endTime);
        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
          if (endDateTime.isCertain("day")) {
            endDateTime.assign("day", endDateTime.get("day") + 1);
          } else {
            endDateTime.imply("day", endDateTime.get("day") + 1);
          }
        }
        result.end = endDateTime;
      }
      return result;
    }
    exports.mergeDateTimeResult = mergeDateTimeResult;
    function mergeDateTimeComponent(dateComponent, timeComponent) {
      const dateTimeComponent = dateComponent.clone();
      if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));
        if (timeComponent.isCertain("second")) {
          dateTimeComponent.assign("second", timeComponent.get("second"));
          if (timeComponent.isCertain("millisecond")) {
            dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
          } else {
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
          }
        } else {
          dateTimeComponent.imply("second", timeComponent.get("second"));
          dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
      } else {
        dateTimeComponent.imply("hour", timeComponent.get("hour"));
        dateTimeComponent.imply("minute", timeComponent.get("minute"));
        dateTimeComponent.imply("second", timeComponent.get("second"));
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
      if (timeComponent.isCertain("timezoneOffset")) {
        dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
      }
      if (timeComponent.isCertain("meridiem")) {
        dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
      } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
        dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
      }
      if (dateTimeComponent.get("meridiem") == index_1.Meridiem.PM && dateTimeComponent.get("hour") < 12) {
        if (timeComponent.isCertain("hour")) {
          dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
        } else {
          dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
        }
      }
      return dateTimeComponent;
    }
    exports.mergeDateTimeComponent = mergeDateTimeComponent;
  }
});

// node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js
var require_AbstractMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/AbstractMergeDateTimeRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var mergingCalculation_1 = require_mergingCalculation();
    var ENMergeDateTimeRefiner = class extends abstractRefiners_1.MergingRefiner {
      shouldMergeResults(textBetween, currentResult, nextResult) {
        return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
      }
      mergeResults(textBetween, currentResult, nextResult) {
        const result = currentResult.start.isOnlyDate() ? mergingCalculation_1.mergeDateTimeResult(currentResult, nextResult) : mergingCalculation_1.mergeDateTimeResult(nextResult, currentResult);
        result.index = currentResult.index;
        result.text = currentResult.text + textBetween + nextResult.text;
        return result;
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js
var require_ENMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
      }
    };
    exports.default = ENMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js
var require_ExtractTimezoneAbbrRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneAbbrRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
    var DEFAULT_TIMEZONE_ABBR_MAP = {
      ACDT: 630,
      ACST: 570,
      ADT: -180,
      AEDT: 660,
      AEST: 600,
      AFT: 270,
      AKDT: -480,
      AKST: -540,
      ALMT: 360,
      AMST: -180,
      AMT: -240,
      ANAST: 720,
      ANAT: 720,
      AQTT: 300,
      ART: -180,
      AST: -240,
      AWDT: 540,
      AWST: 480,
      AZOST: 0,
      AZOT: -60,
      AZST: 300,
      AZT: 240,
      BNT: 480,
      BOT: -240,
      BRST: -120,
      BRT: -180,
      BST: 60,
      BTT: 360,
      CAST: 480,
      CAT: 120,
      CCT: 390,
      CDT: -300,
      CEST: 120,
      CET: 60,
      CHADT: 825,
      CHAST: 765,
      CKT: -600,
      CLST: -180,
      CLT: -240,
      COT: -300,
      CST: -360,
      CVT: -60,
      CXT: 420,
      ChST: 600,
      DAVT: 420,
      EASST: -300,
      EAST: -360,
      EAT: 180,
      ECT: -300,
      EDT: -240,
      EEST: 180,
      EET: 120,
      EGST: 0,
      EGT: -60,
      EST: -300,
      ET: -300,
      FJST: 780,
      FJT: 720,
      FKST: -180,
      FKT: -240,
      FNT: -120,
      GALT: -360,
      GAMT: -540,
      GET: 240,
      GFT: -180,
      GILT: 720,
      GMT: 0,
      GST: 240,
      GYT: -240,
      HAA: -180,
      HAC: -300,
      HADT: -540,
      HAE: -240,
      HAP: -420,
      HAR: -360,
      HAST: -600,
      HAT: -90,
      HAY: -480,
      HKT: 480,
      HLV: -210,
      HNA: -240,
      HNC: -360,
      HNE: -300,
      HNP: -480,
      HNR: -420,
      HNT: -150,
      HNY: -540,
      HOVT: 420,
      ICT: 420,
      IDT: 180,
      IOT: 360,
      IRDT: 270,
      IRKST: 540,
      IRKT: 540,
      IRST: 210,
      IST: 330,
      JST: 540,
      KGT: 360,
      KRAST: 480,
      KRAT: 480,
      KST: 540,
      KUYT: 240,
      LHDT: 660,
      LHST: 630,
      LINT: 840,
      MAGST: 720,
      MAGT: 720,
      MART: -510,
      MAWT: 300,
      MDT: -360,
      MESZ: 120,
      MEZ: 60,
      MHT: 720,
      MMT: 390,
      MSD: 240,
      MSK: 240,
      MST: -420,
      MUT: 240,
      MVT: 300,
      MYT: 480,
      NCT: 660,
      NDT: -90,
      NFT: 690,
      NOVST: 420,
      NOVT: 360,
      NPT: 345,
      NST: -150,
      NUT: -660,
      NZDT: 780,
      NZST: 720,
      OMSST: 420,
      OMST: 420,
      PDT: -420,
      PET: -300,
      PETST: 720,
      PETT: 720,
      PGT: 600,
      PHOT: 780,
      PHT: 480,
      PKT: 300,
      PMDT: -120,
      PMST: -180,
      PONT: 660,
      PST: -480,
      PT: -480,
      PWT: 540,
      PYST: -180,
      PYT: -240,
      RET: 240,
      SAMT: 240,
      SAST: 120,
      SBT: 660,
      SCT: 240,
      SGT: 480,
      SRT: -180,
      SST: -660,
      TAHT: -600,
      TFT: 300,
      TJT: 300,
      TKT: 780,
      TLT: 540,
      TMT: 300,
      TVT: 720,
      ULAT: 480,
      UTC: 0,
      UYST: -120,
      UYT: -180,
      UZT: 300,
      VET: -210,
      VLAST: 660,
      VLAT: 660,
      VUT: 660,
      WAST: 120,
      WAT: 60,
      WEST: 60,
      WESZ: 60,
      WET: 0,
      WEZ: 0,
      WFT: 720,
      WGST: -120,
      WGT: -180,
      WIB: 420,
      WIT: 540,
      WITA: 480,
      WST: 780,
      WT: 0,
      YAKST: 600,
      YAKT: 600,
      YAPT: 600,
      YEKST: 360,
      YEKT: 360
    };
    var ExtractTimezoneAbbrRefiner = class {
      constructor(timezoneOverrides) {
        this.timezone = Object.assign(Object.assign({}, DEFAULT_TIMEZONE_ABBR_MAP), timezoneOverrides);
      }
      refine(context, results) {
        var _a;
        const timezoneOverrides = (_a = context.option.timezones) !== null && _a !== void 0 ? _a : {};
        results.forEach((result) => {
          var _a2, _b;
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_NAME_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          const timezoneAbbr = match[1].toUpperCase();
          const extractedTimezoneOffset = (_b = (_a2 = timezoneOverrides[timezoneAbbr]) !== null && _a2 !== void 0 ? _a2 : this.timezone[timezoneAbbr]) !== null && _b !== void 0 ? _b : null;
          if (extractedTimezoneOffset === null) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
          });
          const currentTimezoneOffset = result.start.get("timezoneOffset");
          if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
            if (result.start.isCertain("timezoneOffset")) {
              return;
            }
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          if (result.start.isOnlyDate()) {
            if (timezoneAbbr != match[1]) {
              return;
            }
          }
          result.text += match[0];
          if (!result.start.isCertain("timezoneOffset")) {
            result.start.assign("timezoneOffset", extractedTimezoneOffset);
          }
          if (result.end != null && !result.end.isCertain("timezoneOffset")) {
            result.end.assign("timezoneOffset", extractedTimezoneOffset);
          }
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneAbbrRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js
var require_ExtractTimezoneOffsetRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ExtractTimezoneOffsetRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
    var TIMEZONE_OFFSET_SIGN_GROUP = 1;
    var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
    var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
    var ExtractTimezoneOffsetRefiner = class {
      refine(context, results) {
        results.forEach(function(result) {
          if (result.start.isCertain("timezoneOffset")) {
            return;
          }
          const suffix = context.text.substring(result.index + result.text.length);
          const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
          if (!match) {
            return;
          }
          context.debug(() => {
            console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
          });
          const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
          const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
          let timezoneOffset = hourOffset * 60 + minuteOffset;
          if (timezoneOffset > 14 * 60) {
            return;
          }
          if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
            timezoneOffset = -timezoneOffset;
          }
          if (result.end != null) {
            result.end.assign("timezoneOffset", timezoneOffset);
          }
          result.start.assign("timezoneOffset", timezoneOffset);
          result.text += match[0];
        });
        return results;
      }
    };
    exports.default = ExtractTimezoneOffsetRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js
var require_OverlapRemovalRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/OverlapRemovalRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OverlapRemovalRefiner = class {
      refine(context, results) {
        if (results.length < 2) {
          return results;
        }
        const filteredResults = [];
        let prevResult = results[0];
        for (let i = 1; i < results.length; i++) {
          const result = results[i];
          if (result.index < prevResult.index + prevResult.text.length) {
            if (result.text.length > prevResult.text.length) {
              prevResult = result;
            }
          } else {
            filteredResults.push(prevResult);
            prevResult = result;
          }
        }
        if (prevResult != null) {
          filteredResults.push(prevResult);
        }
        return filteredResults;
      }
    };
    exports.default = OverlapRemovalRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js
var require_ForwardDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/ForwardDateRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var ForwardDateRefiner = class {
      refine(context, results) {
        if (!context.option.forwardDate) {
          return results;
        }
        results.forEach(function(result) {
          let refMoment = dayjs_1.default(context.refDate);
          if (result.start.isOnlyDayMonthComponent() && refMoment.isAfter(result.start.dayjs())) {
            for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {
              result.start.imply("year", result.start.get("year") + 1);
              context.debug(() => {
                console.log(`Forward yearly adjusted for ${result} (${result.start})`);
              });
              if (result.end && !result.end.isCertain("year")) {
                result.end.imply("year", result.end.get("year") + 1);
                context.debug(() => {
                  console.log(`Forward yearly adjusted for ${result} (${result.end})`);
                });
              }
            }
          }
          if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
            if (refMoment.day() >= result.start.get("weekday")) {
              refMoment = refMoment.day(result.start.get("weekday") + 7);
            } else {
              refMoment = refMoment.day(result.start.get("weekday"));
            }
            result.start.imply("day", refMoment.date());
            result.start.imply("month", refMoment.month() + 1);
            result.start.imply("year", refMoment.year());
            context.debug(() => {
              console.log(`Forward weekly adjusted for ${result} (${result.start})`);
            });
            if (result.end && result.end.isOnlyWeekdayComponent()) {
              if (refMoment.day() > result.end.get("weekday")) {
                refMoment = refMoment.day(result.end.get("weekday") + 7);
              } else {
                refMoment = refMoment.day(result.end.get("weekday"));
              }
              result.end.imply("day", refMoment.date());
              result.end.imply("month", refMoment.month() + 1);
              result.end.imply("year", refMoment.year());
              context.debug(() => {
                console.log(`Forward weekly adjusted for ${result} (${result.end})`);
              });
            }
          }
        });
        return results;
      }
    };
    exports.default = ForwardDateRefiner;
  }
});

// node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js
var require_UnlikelyFormatFilter = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/UnlikelyFormatFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var UnlikelyFormatFilter = class extends abstractRefiners_1.Filter {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      isValid(context, result) {
        if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
          context.debug(() => {
            console.log(`Removing unlikely result '${result.text}'`);
          });
          return false;
        }
        if (!result.start.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.start})`);
          });
          return false;
        }
        if (result.end && !result.end.isValidDate()) {
          context.debug(() => {
            console.log(`Removing invalid result: ${result} (${result.end})`);
          });
          return false;
        }
        if (this.strictMode) {
          return this.isStrictModeValid(context, result);
        }
        return true;
      }
      isStrictModeValid(context, result) {
        if (result.start.isOnlyWeekdayComponent()) {
          context.debug(() => {
            console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
          });
          return false;
        }
        if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
          context.debug(() => {
            console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
          });
          return false;
        }
        return true;
      }
    };
    exports.default = UnlikelyFormatFilter;
  }
});

// node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js
var require_ISOFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/ISOFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NUMBER_GROUP = 2;
    var DATE_NUMBER_GROUP = 3;
    var HOUR_NUMBER_GROUP = 4;
    var MINUTE_NUMBER_GROUP = 5;
    var SECOND_NUMBER_GROUP = 6;
    var MILLISECOND_NUMBER_GROUP = 7;
    var TZD_HOUR_OFFSET_GROUP = 8;
    var TZD_MINUTE_OFFSET_GROUP = 9;
    var ISOFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = {};
        components["year"] = parseInt(match[YEAR_NUMBER_GROUP]);
        components["month"] = parseInt(match[MONTH_NUMBER_GROUP]);
        components["day"] = parseInt(match[DATE_NUMBER_GROUP]);
        if (match[HOUR_NUMBER_GROUP] != null) {
          components["hour"] = parseInt(match[HOUR_NUMBER_GROUP]);
          components["minute"] = parseInt(match[MINUTE_NUMBER_GROUP]);
          if (match[SECOND_NUMBER_GROUP] != null) {
            components["second"] = parseInt(match[SECOND_NUMBER_GROUP]);
          }
          if (match[MILLISECOND_NUMBER_GROUP] != null) {
            components["millisecond"] = parseInt(match[MILLISECOND_NUMBER_GROUP]);
          }
          if (match[TZD_HOUR_OFFSET_GROUP] == null) {
            components["timezoneOffset"] = 0;
          } else {
            const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
            let minuteOffset = 0;
            if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
              minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
            }
            let offset = hourOffset * 60;
            if (offset < 0) {
              offset -= minuteOffset;
            } else {
              offset += minuteOffset;
            }
            components["timezoneOffset"] = offset;
          }
        }
        return components;
      }
    };
    exports.default = ISOFormatParser;
  }
});

// node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js
var require_MergeWeekdayComponentRefiner = __commonJS({
  "node_modules/chrono-node/dist/common/refiners/MergeWeekdayComponentRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var MergeWeekdayComponentRefiner = class extends abstractRefiners_1.MergingRefiner {
      mergeResults(textBetween, currentResult, nextResult) {
        const newResult = nextResult.clone();
        newResult.index = currentResult.index;
        newResult.text = currentResult.text + textBetween + newResult.text;
        newResult.start.assign("weekday", currentResult.start.get("weekday"));
        if (newResult.end) {
          newResult.end.assign("weekday", currentResult.start.get("weekday"));
        }
        return newResult;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
        return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
      }
    };
    exports.default = MergeWeekdayComponentRefiner;
  }
});

// node_modules/chrono-node/dist/configurations.js
var require_configurations = __commonJS({
  "node_modules/chrono-node/dist/configurations.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.includeCommonConfiguration = void 0;
    var ExtractTimezoneAbbrRefiner_1 = __importDefault(require_ExtractTimezoneAbbrRefiner());
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var OverlapRemovalRefiner_1 = __importDefault(require_OverlapRemovalRefiner());
    var ForwardDateRefiner_1 = __importDefault(require_ForwardDateRefiner());
    var UnlikelyFormatFilter_1 = __importDefault(require_UnlikelyFormatFilter());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var MergeWeekdayComponentRefiner_1 = __importDefault(require_MergeWeekdayComponentRefiner());
    function includeCommonConfiguration(configuration, strictMode = false) {
      configuration.parsers.unshift(new ISOFormatParser_1.default());
      configuration.refiners.unshift(new MergeWeekdayComponentRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneAbbrRefiner_1.default());
      configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner_1.default());
      configuration.refiners.unshift(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new OverlapRemovalRefiner_1.default());
      configuration.refiners.push(new ForwardDateRefiner_1.default());
      configuration.refiners.push(new UnlikelyFormatFilter_1.default(strictMode));
      return configuration;
    }
    exports.includeCommonConfiguration = includeCommonConfiguration;
  }
});

// node_modules/chrono-node/dist/common/casualReferences.js
var require_casualReferences = __commonJS({
  "node_modules/chrono-node/dist/common/casualReferences.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noon = exports.morning = exports.midnight = exports.yesterdayEvening = exports.evening = exports.lastNight = exports.tonight = exports.theDayAfter = exports.tomorrow = exports.theDayBefore = exports.yesterday = exports.today = exports.now = void 0;
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var index_1 = require_dist();
    function now(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.assignSimilarTime(component, targetDate);
      if (reference.timezoneOffset !== null) {
        component.assign("timezoneOffset", targetDate.utcOffset());
      }
      return component;
    }
    exports.now = now;
    function today(reference) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.today = today;
    function yesterday(reference) {
      return theDayBefore(reference, 1);
    }
    exports.yesterday = yesterday;
    function theDayBefore(reference, numDay) {
      return theDayAfter(reference, -numDay);
    }
    exports.theDayBefore = theDayBefore;
    function tomorrow(reference) {
      return theDayAfter(reference, 1);
    }
    exports.tomorrow = tomorrow;
    function theDayAfter(reference, nDays) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(nDays, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      dayjs_2.implySimilarTime(component, targetDate);
      return component;
    }
    exports.theDayAfter = theDayAfter;
    function tonight(reference, implyHour = 22) {
      const targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      dayjs_2.assignSimilarDate(component, targetDate);
      return component;
    }
    exports.tonight = tonight;
    function lastNight(reference, implyHour = 0) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      if (targetDate.hour() < 6) {
        targetDate = targetDate.add(-1, "day");
      }
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      return component;
    }
    exports.lastNight = lastNight;
    function evening(reference, implyHour = 20) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.PM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.evening = evening;
    function yesterdayEvening(reference, implyHour = 20) {
      let targetDate = dayjs_1.default(reference.instant);
      const component = new results_1.ParsingComponents(reference, {});
      targetDate = targetDate.add(-1, "day");
      dayjs_2.assignSimilarDate(component, targetDate);
      component.imply("hour", implyHour);
      component.imply("meridiem", index_1.Meridiem.PM);
      return component;
    }
    exports.yesterdayEvening = yesterdayEvening;
    function midnight(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("hour", 0);
      component.imply("minute", 0);
      component.imply("second", 0);
      return component;
    }
    exports.midnight = midnight;
    function morning(reference, implyHour = 6) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", implyHour);
      return component;
    }
    exports.morning = morning;
    function noon(reference) {
      const component = new results_1.ParsingComponents(reference, {});
      component.imply("meridiem", index_1.Meridiem.AM);
      component.imply("hour", 12);
      return component;
    }
    exports.noon = noon;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js
var require_ENCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var PATTERN = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
    var ENCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "now":
            return references.now(context.reference);
          case "today":
            return references.today(context.reference);
          case "yesterday":
            return references.yesterday(context.reference);
          case "tomorrow":
          case "tmr":
          case "tmrw":
            return references.tomorrow(context.reference);
          case "tonight":
            return references.tonight(context.reference);
          default:
            if (lowerText.match(/last\s*night/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js
var require_ENCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var PATTERN = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|noon)(?=\W|$)/i;
    var ENCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "afternoon":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "evening":
          case "night":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "midnight":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "morning":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "noon":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = ENCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/calculation/weeks.js
var require_weeks = __commonJS({
  "node_modules/chrono-node/dist/calculation/weeks.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toDayJSClosestWeekday = exports.toDayJSWeekday = void 0;
    var dayjs_1 = __importDefault(require_dayjs_min());
    function toDayJSWeekday(refDate, offset, modifier) {
      if (!modifier) {
        return toDayJSClosestWeekday(refDate, offset);
      }
      let date = dayjs_1.default(refDate);
      switch (modifier) {
        case "this":
          date = date.day(offset);
          break;
        case "next":
          date = date.day(offset + 7);
          break;
        case "last":
          date = date.day(offset - 7);
          break;
      }
      return date;
    }
    exports.toDayJSWeekday = toDayJSWeekday;
    function toDayJSClosestWeekday(refDate, offset) {
      let date = dayjs_1.default(refDate);
      const refOffset = date.day();
      if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset - 7);
      } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
        date = date.day(offset + 7);
      } else {
        date = date.day(offset);
      }
      return date;
    }
    exports.toDayJSClosestWeekday = toDayJSClosestWeekday;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js
var require_ENWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var ENWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "last" || modifierWord == "past") {
          modifier = "last";
        } else if (modifierWord == "next") {
          modifier = "next";
        } else if (modifierWord == "this") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = ENWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js
var require_ENRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "next" || modifier.startsWith("after")) {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "last" || modifier == "past") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = ENRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/chrono.js
var require_chrono = __commonJS({
  "node_modules/chrono-node/dist/chrono.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingContext = exports.Chrono = void 0;
    var results_1 = require_results();
    var en_1 = require_en();
    var Chrono = class {
      constructor(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = [...configuration.parsers];
        this.refiners = [...configuration.refiners];
      }
      clone() {
        return new Chrono({
          parsers: [...this.parsers],
          refiners: [...this.refiners]
        });
      }
      parseDate(text2, referenceDate, option) {
        const results = this.parse(text2, referenceDate, option);
        return results.length > 0 ? results[0].start.date() : null;
      }
      parse(text2, referenceDate, option) {
        const context = new ParsingContext(text2, referenceDate, option);
        let results = [];
        this.parsers.forEach((parser) => {
          const parsedResults = Chrono.executeParser(context, parser);
          results = results.concat(parsedResults);
        });
        results.sort((a, b) => {
          return a.index - b.index;
        });
        this.refiners.forEach(function(refiner) {
          results = refiner.refine(context, results);
        });
        return results;
      }
      static executeParser(context, parser) {
        const results = [];
        const pattern = parser.pattern(context);
        const originalText = context.text;
        let remainingText = context.text;
        let match = pattern.exec(remainingText);
        while (match) {
          const index = match.index + originalText.length - remainingText.length;
          match.index = index;
          const result = parser.extract(context, match);
          if (!result) {
            remainingText = originalText.substring(match.index + 1);
            match = pattern.exec(remainingText);
            continue;
          }
          let parsedResult = null;
          if (result instanceof results_1.ParsingResult) {
            parsedResult = result;
          } else if (result instanceof results_1.ParsingComponents) {
            parsedResult = context.createParsingResult(match.index, match[0]);
            parsedResult.start = result;
          } else {
            parsedResult = context.createParsingResult(match.index, match[0], result);
          }
          context.debug(() => console.log(`${parser.constructor.name} extracted result ${parsedResult}`));
          results.push(parsedResult);
          remainingText = originalText.substring(index + parsedResult.text.length);
          match = pattern.exec(remainingText);
        }
        return results;
      }
    };
    exports.Chrono = Chrono;
    var ParsingContext = class {
      constructor(text2, refDate, option) {
        this.text = text2;
        this.reference = new results_1.ReferenceWithTimezone(refDate);
        this.option = option !== null && option !== void 0 ? option : {};
        this.refDate = this.reference.instant;
      }
      createParsingComponents(components) {
        if (components instanceof results_1.ParsingComponents) {
          return components;
        }
        return new results_1.ParsingComponents(this.reference, components);
      }
      createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
        const text2 = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
        const start = startComponents ? this.createParsingComponents(startComponents) : null;
        const end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.reference, index, text2, start, end);
      }
      debug(block) {
        if (this.option.debug) {
          if (this.option.debug instanceof Function) {
            this.option.debug(block);
          } else {
            const handler = this.option.debug;
            handler.debug(block);
          }
        }
      }
    };
    exports.ParsingContext = ParsingContext;
  }
});

// node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js
var require_SlashDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/common/parsers/SlashDateFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var PATTERN = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
    var OPENING_GROUP = 1;
    var ENDING_GROUP = 5;
    var FIRST_NUMBERS_GROUP = 2;
    var SECOND_NUMBERS_GROUP = 3;
    var YEAR_GROUP = 4;
    var SlashDateFormatParser = class {
      constructor(littleEndian) {
        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
      }
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        if (match[OPENING_GROUP] == "/" || match[ENDING_GROUP] == "/") {
          match.index += match[0].length;
          return;
        }
        const index = match.index + match[OPENING_GROUP].length;
        const text2 = match[0].substr(match[OPENING_GROUP].length, match[0].length - match[OPENING_GROUP].length - match[ENDING_GROUP].length);
        if (text2.match(/^\d\.\d$/) || text2.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
          return;
        }
        if (!match[YEAR_GROUP] && match[0].indexOf("/") < 0) {
          return;
        }
        const result = context.createParsingResult(index, text2);
        let month = parseInt(match[this.groupNumberMonth]);
        let day = parseInt(match[this.groupNumberDay]);
        if (month < 1 || month > 12) {
          if (month > 12) {
            if (day >= 1 && day <= 12 && month <= 31) {
              [day, month] = [month, day];
            } else {
              return null;
            }
          }
        }
        if (day < 1 || day > 31) {
          return null;
        }
        result.start.assign("day", day);
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const rawYearNumber = parseInt(match[YEAR_GROUP]);
          const year = years_1.findMostLikelyADYear(rawYearNumber);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = SlashDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var require_ENTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "last":
          case "past":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = ENTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js
var require_ENMergeRelativeDateRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/en/refiners/ENMergeRelativeDateRefiner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstractRefiners_1 = require_abstractRefiners();
    var results_1 = require_results();
    var constants_1 = require_constants();
    var timeunits_1 = require_timeunits();
    function hasImpliedEarlierReferenceDate(result) {
      return result.text.match(/\s+(before|from)$/i) != null;
    }
    function hasImpliedLaterReferenceDate(result) {
      return result.text.match(/\s+(after|since)$/i) != null;
    }
    var ENMergeRelativeDateRefiner = class extends abstractRefiners_1.MergingRefiner {
      patternBetween() {
        return /^\s*$/i;
      }
      shouldMergeResults(textBetween, currentResult, nextResult) {
        if (!textBetween.match(this.patternBetween())) {
          return false;
        }
        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
          return false;
        }
        return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
      }
      mergeResults(textBetween, currentResult, nextResult) {
        let timeUnits = constants_1.parseTimeUnits(currentResult.text);
        if (hasImpliedEarlierReferenceDate(currentResult)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        const components = results_1.ParsingComponents.createRelativeFromReference(new results_1.ReferenceWithTimezone(nextResult.start.date()), timeUnits);
        return new results_1.ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
      }
    };
    exports.default = ENMergeRelativeDateRefiner;
  }
});

// node_modules/chrono-node/dist/locales/en/index.js
var require_en = __commonJS({
  "node_modules/chrono-node/dist/locales/en/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.GB = exports.strict = exports.casual = void 0;
    var ENTimeUnitWithinFormatParser_1 = __importDefault(require_ENTimeUnitWithinFormatParser());
    var ENMonthNameLittleEndianParser_1 = __importDefault(require_ENMonthNameLittleEndianParser());
    var ENMonthNameMiddleEndianParser_1 = __importDefault(require_ENMonthNameMiddleEndianParser());
    var ENMonthNameParser_1 = __importDefault(require_ENMonthNameParser());
    var ENCasualYearMonthDayParser_1 = __importDefault(require_ENCasualYearMonthDayParser());
    var ENSlashMonthFormatParser_1 = __importDefault(require_ENSlashMonthFormatParser());
    var ENTimeExpressionParser_1 = __importDefault(require_ENTimeExpressionParser());
    var ENTimeUnitAgoFormatParser_1 = __importDefault(require_ENTimeUnitAgoFormatParser());
    var ENTimeUnitLaterFormatParser_1 = __importDefault(require_ENTimeUnitLaterFormatParser());
    var ENMergeDateRangeRefiner_1 = __importDefault(require_ENMergeDateRangeRefiner());
    var ENMergeDateTimeRefiner_1 = __importDefault(require_ENMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var ENCasualDateParser_1 = __importDefault(require_ENCasualDateParser());
    var ENCasualTimeParser_1 = __importDefault(require_ENCasualTimeParser());
    var ENWeekdayParser_1 = __importDefault(require_ENWeekdayParser());
    var ENRelativeDateFormatParser_1 = __importDefault(require_ENRelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ENTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_ENTimeUnitCasualRelativeFormatParser());
    var ENMergeRelativeDateRefiner_1 = __importDefault(require_ENMergeRelativeDateRefiner());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration(false));
    exports.strict = new chrono_1.Chrono(createConfiguration(true, false));
    exports.GB = new chrono_1.Chrono(createConfiguration(false, true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = false) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new ENCasualDateParser_1.default());
      option.parsers.unshift(new ENCasualTimeParser_1.default());
      option.parsers.unshift(new ENMonthNameParser_1.default());
      option.parsers.unshift(new ENRelativeDateFormatParser_1.default());
      option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = false) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new ENTimeUnitWithinFormatParser_1.default(),
          new ENMonthNameLittleEndianParser_1.default(),
          new ENMonthNameMiddleEndianParser_1.default(),
          new ENWeekdayParser_1.default(),
          new ENCasualYearMonthDayParser_1.default(),
          new ENSlashMonthFormatParser_1.default(),
          new ENTimeExpressionParser_1.default(strictMode),
          new ENTimeUnitAgoFormatParser_1.default(strictMode),
          new ENTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new ENMergeRelativeDateRefiner_1.default(), new ENMergeDateTimeRefiner_1.default(), new ENMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js
var require_DETimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var DETimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:um|von)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = DETimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/constants.js
var require_constants2 = __commonJS({
  "node_modules/chrono-node/dist/locales/de/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      "sonntag": 0,
      "so": 0,
      "montag": 1,
      "mo": 1,
      "dienstag": 2,
      "di": 2,
      "mittwoch": 3,
      "mi": 3,
      "donnerstag": 4,
      "do": 4,
      "freitag": 5,
      "fr": 5,
      "samstag": 6,
      "sa": 6
    };
    exports.MONTH_DICTIONARY = {
      "januar": 1,
      "j\xE4nner": 1,
      "janner": 1,
      "jan": 1,
      "jan.": 1,
      "februar": 2,
      "feber": 2,
      "feb": 2,
      "feb.": 2,
      "m\xE4rz": 3,
      "maerz": 3,
      "m\xE4r": 3,
      "m\xE4r.": 3,
      "mrz": 3,
      "mrz.": 3,
      "april": 4,
      "apr": 4,
      "apr.": 4,
      "mai": 5,
      "juni": 6,
      "jun": 6,
      "jun.": 6,
      "juli": 7,
      "jul": 7,
      "jul.": 7,
      "august": 8,
      "aug": 8,
      "aug.": 8,
      "september": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "oktober": 10,
      "okt": 10,
      "okt.": 10,
      "november": 11,
      "nov": 11,
      "nov.": 11,
      "dezember": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "eins": 1,
      "eine": 1,
      "einem": 1,
      "einen": 1,
      "einer": 1,
      "zwei": 2,
      "drei": 3,
      "vier": 4,
      "f\xFCnf": 5,
      "fuenf": 5,
      "sechs": 6,
      "sieben": 7,
      "acht": 8,
      "neun": 9,
      "zehn": 10,
      "elf": 11,
      "zw\xF6lf": 12,
      "zwoelf": 12
    };
    exports.TIME_UNIT_DICTIONARY = {
      sek: "second",
      sekunde: "second",
      sekunden: "second",
      min: "minute",
      minute: "minute",
      minuten: "minute",
      h: "hour",
      std: "hour",
      stunde: "hour",
      stunden: "hour",
      tag: "d",
      tage: "d",
      tagen: "d",
      woche: "week",
      wochen: "week",
      monat: "month",
      monate: "month",
      monaten: "month",
      monats: "month",
      quartal: "quarter",
      quartals: "quarter",
      quartale: "quarter",
      quartalen: "quarter",
      a: "year",
      j: "year",
      jr: "year",
      jahr: "year",
      jahre: "year",
      jahren: "year",
      jahres: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s*an?)?|an?\\b(?:\\s*few)?|few|several|a?\\s*couple\\s*(?:of)?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "a" || num === "an") {
        return 1;
      } else if (num.match(/few/)) {
        return 3;
      } else if (num.match(/half/)) {
        return 0.5;
      } else if (num.match(/couple/)) {
        return 2;
      } else if (num.match(/several/)) {
        return 7;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
    function parseYear(match) {
      if (/v/i.test(match)) {
        return -parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/n/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      if (/z/i.test(match)) {
        return parseInt(match.replace(/[^0-9]+/gi, ""));
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js
var require_DEWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var SUFFIX_GROUP = 3;
    var WEEKDAY_GROUP = 2;
    var DEWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[SUFFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord.match(/letzte/)) {
          modifier = "last";
        } else if (modifierWord.match(/chste/)) {
          modifier = "next";
        } else if (modifierWord.match(/diese/)) {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = DEWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js
var require_DESpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DESpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var DESpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();
          if (ampm.match(/morgen|vormittag/)) {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm.match(/nachmittag|abend/)) {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
          if (ampm.match(/nacht/)) {
            if (hour == 12) {
              meridiem = index_1.Meridiem.AM;
              hour = 0;
            } else if (hour < 6) {
              meridiem = index_1.Meridiem.AM;
            } else {
              meridiem = index_1.Meridiem.PM;
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = DESpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js
var require_DEMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
      }
    };
    exports.default = DEMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js
var require_DEMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/de/refiners/DEMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
      }
    };
    exports.default = DEMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js
var require_DECasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var timeunits_1 = require_timeunits();
    var DECasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const timeKeywordPattern = match[2].toLowerCase();
        const component = context.createParsingComponents();
        dayjs_2.implySimilarTime(component, targetDate);
        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
      }
      static extractTimeComponents(component, timeKeywordPattern) {
        switch (timeKeywordPattern) {
          case "morgen":
            component.imply("hour", 6);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "vormittag":
            component.imply("hour", 9);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "mittag":
          case "mittags":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "nachmittag":
            component.imply("hour", 15);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "abend":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "nacht":
            component.imply("hour", 22);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "mitternacht":
            if (component.get("hour") > 1) {
              component = timeunits_1.addImpliedTimeUnits(component, { "day": 1 });
            }
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = DECasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js
var require_DECasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DECasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var references = __importStar(require_casualReferences());
    var PATTERN = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var TIME_GROUP = 2;
    var DECasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const dateKeyword = (match[DATE_GROUP] || "").toLowerCase();
        const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
        let component = context.createParsingComponents();
        switch (dateKeyword) {
          case "jetzt":
            component = references.now(context.reference);
            break;
          case "heute":
            component = references.today(context.reference);
            break;
          case "morgen":
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "\xFCbermorgen":
          case "uebermorgen":
            targetDate = targetDate.add(1, "day");
            dayjs_2.assignTheNextDay(component, targetDate);
            break;
          case "gestern":
            targetDate = targetDate.add(-1, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          case "vorgestern":
            targetDate = targetDate.add(-2, "day");
            dayjs_2.assignSimilarDate(component, targetDate);
            dayjs_2.implySimilarTime(component, targetDate);
            break;
          default:
            if (dateKeyword.match(/letzte\s*nacht/)) {
              if (targetDate.hour() > 6) {
                targetDate = targetDate.add(-1, "day");
              }
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
            break;
        }
        if (timeKeyword) {
          component = DECasualTimeParser_1.default.extractTimeComponents(component, timeKeyword);
        }
        return component;
      }
    };
    exports.default = DECasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js
var require_DEMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DEMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants2();
    var constants_2 = require_constants2();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = DEMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var require_DETimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/de/parsers/DETimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${constants_1.NUMBER_PATTERN})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})`, "i");
      }
      innerExtract(context, match) {
        const num = match[2] ? constants_1.parseNumberPattern(match[2]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[4].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[1] || match[3] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = DETimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/de/index.js
var require_de = __commonJS({
  "node_modules/chrono-node/dist/locales/de/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var ISOFormatParser_1 = __importDefault(require_ISOFormatParser());
    var DETimeExpressionParser_1 = __importDefault(require_DETimeExpressionParser());
    var DEWeekdayParser_1 = __importDefault(require_DEWeekdayParser());
    var DESpecificTimeExpressionParser_1 = __importDefault(require_DESpecificTimeExpressionParser());
    var DEMergeDateRangeRefiner_1 = __importDefault(require_DEMergeDateRangeRefiner());
    var DEMergeDateTimeRefiner_1 = __importDefault(require_DEMergeDateTimeRefiner());
    var DECasualDateParser_1 = __importDefault(require_DECasualDateParser());
    var DECasualTimeParser_1 = __importDefault(require_DECasualTimeParser());
    var DEMonthNameLittleEndianParser_1 = __importDefault(require_DEMonthNameLittleEndianParser());
    var DETimeUnitRelativeFormatParser_1 = __importDefault(require_DETimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new DECasualTimeParser_1.default());
      option.parsers.unshift(new DECasualDateParser_1.default());
      option.parsers.unshift(new DETimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new ISOFormatParser_1.default(),
          new SlashDateFormatParser_1.default(littleEndian),
          new DETimeExpressionParser_1.default(),
          new DESpecificTimeExpressionParser_1.default(),
          new DEMonthNameLittleEndianParser_1.default(),
          new DEWeekdayParser_1.default()
        ],
        refiners: [new DEMergeDateRangeRefiner_1.default(), new DEMergeDateTimeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js
var require_FRCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_2 = require_dayjs();
    var references = __importStar(require_casualReferences());
    var FRCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_1.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "maintenant":
            return references.now(context.reference);
          case "aujourd'hui":
            return references.today(context.reference);
          case "hier":
            return references.yesterday(context.reference);
          case "demain":
            return references.tomorrow(context.reference);
          default:
            if (lowerText.match(/cette\s*nuit/)) {
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 22);
              component.imply("meridiem", index_1.Meridiem.PM);
            } else if (lowerText.match(/la\s*veille/)) {
              targetDate = targetDate.add(-1, "day");
              dayjs_2.assignSimilarDate(component, targetDate);
              component.imply("hour", 0);
            }
        }
        return component;
      }
    };
    exports.default = FRCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js
var require_FRCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRCasualTimeParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const suffixLower = match[2].toLowerCase();
        const component = context.createParsingComponents();
        switch (suffixLower) {
          case "apr\xE8s-midi":
          case "aprem":
            component.imply("hour", 14);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "soir":
            component.imply("hour", 18);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.PM);
            break;
          case "matin":
            component.imply("hour", 8);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "a midi":
            component.imply("hour", 12);
            component.imply("minute", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
          case "\xE0 minuit":
            component.imply("hour", 0);
            component.imply("meridiem", index_1.Meridiem.AM);
            break;
        }
        return component;
      }
    };
    exports.default = FRCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js
var require_FRTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var FRTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:[\xE0a])\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = FRTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js
var require_FRMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(T|\xE0|a|vers|de|,|-)?\\s*$");
      }
    };
    exports.default = FRMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js
var require_FRMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/refiners/FRMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(à|a|-)\s*$/i;
      }
    };
    exports.default = FRMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/fr/constants.js
var require_constants3 = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    exports.WEEKDAY_DICTIONARY = {
      "dimanche": 0,
      "dim": 0,
      "lundi": 1,
      "lun": 1,
      "mardi": 2,
      "mar": 2,
      "mercredi": 3,
      "mer": 3,
      "jeudi": 4,
      "jeu": 4,
      "vendredi": 5,
      "ven": 5,
      "samedi": 6,
      "sam": 6
    };
    exports.MONTH_DICTIONARY = {
      "janvier": 1,
      "jan": 1,
      "jan.": 1,
      "f\xE9vrier": 2,
      "f\xE9v": 2,
      "f\xE9v.": 2,
      "fevrier": 2,
      "fev": 2,
      "fev.": 2,
      "mars": 3,
      "mar": 3,
      "mar.": 3,
      "avril": 4,
      "avr": 4,
      "avr.": 4,
      "mai": 5,
      "juin": 6,
      "jun": 6,
      "juillet": 7,
      "juil": 7,
      "jul": 7,
      "jul.": 7,
      "ao\xFBt": 8,
      "aout": 8,
      "septembre": 9,
      "sep": 9,
      "sep.": 9,
      "sept": 9,
      "sept.": 9,
      "octobre": 10,
      "oct": 10,
      "oct.": 10,
      "novembre": 11,
      "nov": 11,
      "nov.": 11,
      "d\xE9cembre": 12,
      "decembre": 12,
      "dec": 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      "un": 1,
      "deux": 2,
      "trois": 3,
      "quatre": 4,
      "cinq": 5,
      "six": 6,
      "sept": 7,
      "huit": 8,
      "neuf": 9,
      "dix": 10,
      "onze": 11,
      "douze": 12,
      "treize": 13
    };
    exports.TIME_UNIT_DICTIONARY = {
      "sec": "second",
      "seconde": "second",
      "secondes": "second",
      "min": "minute",
      "mins": "minute",
      "minute": "minute",
      "minutes": "minute",
      "h": "hour",
      "hr": "hour",
      "hrs": "hour",
      "heure": "hour",
      "heures": "hour",
      "jour": "d",
      "jours": "d",
      "semaine": "week",
      "semaines": "week",
      "mois": "month",
      "trimestre": "quarter",
      "trimestres": "quarter",
      "ans": "year",
      "ann\xE9e": "year",
      "ann\xE9es": "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "une" || num === "un") {
        return 1;
      } else if (num.match(/quelques?/)) {
        return 3;
      } else if (num.match(/demi-?/)) {
        return 0.5;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      num = num.replace(/(?:er)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/AC/i.test(match)) {
        match = match.replace(/BC/i, "");
        return -parseInt(match);
      }
      if (/AD/i.test(match) || /C/i.test(match)) {
        match = match.replace(/[^\d]+/i, "");
        return parseInt(match);
      }
      let yearNumber = parseInt(match);
      if (yearNumber < 100) {
        if (yearNumber > 50) {
          yearNumber = yearNumber + 1900;
        } else {
          yearNumber = yearNumber + 2e3;
        }
      }
      return yearNumber;
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js
var require_FRWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
    var WEEKDAY_GROUP = 1;
    var POSTFIX_GROUP = 2;
    var FRWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        let suffix = match[POSTFIX_GROUP];
        suffix = suffix || "";
        suffix = suffix.toLowerCase();
        let modifier = null;
        if (suffix == "dernier") {
          modifier = "last";
        } else if (suffix == "prochain") {
          modifier = "next";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = FRWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var require_FRSpecificTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRSpecificTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
    var HOUR_GROUP = 2;
    var MINUTE_GROUP = 3;
    var SECOND_GROUP = 4;
    var AM_PM_HOUR_GROUP = 5;
    var FRSpecificTimeExpressionParser = class {
      pattern(context) {
        return FIRST_REG_PATTERN;
      }
      extract(context, match) {
        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
        if (result.text.match(/^\d{4}$/)) {
          match.index += match[0].length;
          return null;
        }
        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
        if (!result.start) {
          match.index += match[0].length;
          return null;
        }
        const remainingText = context.text.substring(match.index + match[0].length);
        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
        if (secondMatch) {
          result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
          if (result.end) {
            result.text += secondMatch[0];
          }
        }
        return result;
      }
      static extractTimeComponent(extractingComponents, match) {
        let hour = 0;
        let minute = 0;
        let meridiem = null;
        hour = parseInt(match[HOUR_GROUP]);
        if (match[MINUTE_GROUP] != null) {
          minute = parseInt(match[MINUTE_GROUP]);
        }
        if (minute >= 60 || hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = index_1.Meridiem.PM;
        }
        if (match[AM_PM_HOUR_GROUP] != null) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = index_1.Meridiem.AM;
            if (hour == 12) {
              hour = 0;
            }
          }
          if (ampm == "p") {
            meridiem = index_1.Meridiem.PM;
            if (hour != 12) {
              hour += 12;
            }
          }
        }
        extractingComponents.assign("hour", hour);
        extractingComponents.assign("minute", minute);
        if (meridiem !== null) {
          extractingComponents.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            extractingComponents.imply("meridiem", index_1.Meridiem.AM);
          } else {
            extractingComponents.imply("meridiem", index_1.Meridiem.PM);
          }
        }
        if (match[SECOND_GROUP] != null) {
          const second = parseInt(match[SECOND_GROUP]);
          if (second >= 60)
            return null;
          extractingComponents.assign("second", second);
        }
        return extractingComponents;
      }
    };
    exports.default = FRSpecificTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var require_FRMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants3();
    var constants_2 = require_constants3();
    var constants_3 = require_constants3();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:de)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = FRMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var require_FRTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`il y a\\s*(${constants_1.TIME_UNITS_PATTERN})(?=(?:\\W|$))`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var require_FRTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var require_FRTimeUnitRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants3();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var pattern_1 = require_pattern();
    var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor() {
        super();
      }
      innerPattern() {
        return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${constants_1.NUMBER_PATTERN})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
      }
      innerExtract(context, match) {
        const num = match[1] ? constants_1.parseNumberPattern(match[1]) : 1;
        const unit = constants_1.TIME_UNIT_DICTIONARY[match[3].toLowerCase()];
        let timeUnits = {};
        timeUnits[unit] = num;
        let modifier = match[2] || match[4] || "";
        modifier = modifier.toLowerCase();
        if (!modifier) {
          return;
        }
        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
          timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = FRTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/fr/index.js
var require_fr = __commonJS({
  "node_modules/chrono-node/dist/locales/fr/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var FRCasualDateParser_1 = __importDefault(require_FRCasualDateParser());
    var FRCasualTimeParser_1 = __importDefault(require_FRCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var FRTimeExpressionParser_1 = __importDefault(require_FRTimeExpressionParser());
    var FRMergeDateTimeRefiner_1 = __importDefault(require_FRMergeDateTimeRefiner());
    var FRMergeDateRangeRefiner_1 = __importDefault(require_FRMergeDateRangeRefiner());
    var FRWeekdayParser_1 = __importDefault(require_FRWeekdayParser());
    var FRSpecificTimeExpressionParser_1 = __importDefault(require_FRSpecificTimeExpressionParser());
    var FRMonthNameLittleEndianParser_1 = __importDefault(require_FRMonthNameLittleEndianParser());
    var FRTimeUnitAgoFormatParser_1 = __importDefault(require_FRTimeUnitAgoFormatParser());
    var FRTimeUnitWithinFormatParser_1 = __importDefault(require_FRTimeUnitWithinFormatParser());
    var FRTimeUnitRelativeFormatParser_1 = __importDefault(require_FRTimeUnitRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new FRCasualDateParser_1.default());
      option.parsers.unshift(new FRCasualTimeParser_1.default());
      option.parsers.unshift(new FRTimeUnitRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new FRMonthNameLittleEndianParser_1.default(),
          new FRTimeExpressionParser_1.default(),
          new FRSpecificTimeExpressionParser_1.default(),
          new FRTimeUnitAgoFormatParser_1.default(),
          new FRTimeUnitWithinFormatParser_1.default(),
          new FRWeekdayParser_1.default()
        ],
        refiners: [new FRMergeDateTimeRefiner_1.default(), new FRMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/ja/constants.js
var require_constants4 = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHankaku = void 0;
    function toHankaku(text2) {
      return String(text2).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    }
    exports.toHankaku = toHankaku;
    function alphaNum(token) {
      return String.fromCharCode(token.charCodeAt(0) - 65248);
    }
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js
var require_JPStandardParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPStandardParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants4();
    var years_1 = require_years();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
    var SPECIAL_YEAR_GROUP = 1;
    var TYPICAL_YEAR_GROUP = 2;
    var ERA_GROUP = 3;
    var YEAR_NUMBER_GROUP = 4;
    var MONTH_GROUP = 5;
    var DAY_GROUP = 6;
    var JPStandardParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const month = parseInt(constants_1.toHankaku(match[MONTH_GROUP]));
        const day = parseInt(constants_1.toHankaku(match[DAY_GROUP]));
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
          const moment = dayjs_1.default(context.refDate);
          components.assign("year", moment.year());
        }
        if (match[TYPICAL_YEAR_GROUP]) {
          const yearNumText = match[YEAR_NUMBER_GROUP];
          let year = yearNumText == "\u5143" ? 1 : parseInt(constants_1.toHankaku(yearNumText));
          if (match[ERA_GROUP] == "\u4EE4\u548C") {
            year += 2018;
          } else if (match[ERA_GROUP] == "\u5E73\u6210") {
            year += 1988;
          } else if (match[ERA_GROUP] == "\u662D\u548C") {
            year += 1925;
          }
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = JPStandardParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js
var require_JPMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/refiners/JPMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(から|ー|-)\s*$/i;
      }
    };
    exports.default = JPMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js
var require_JPCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/parsers/JPCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var index_1 = require_dist();
    var references = __importStar(require_casualReferences());
    var PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
    var JPCasualDateParser = class {
      pattern() {
        return PATTERN;
      }
      extract(context, match) {
        const text2 = match[0];
        const date = dayjs_1.default(context.refDate);
        const components = context.createParsingComponents();
        switch (text2) {
          case "\u6628\u65E5":
            return references.yesterday(context.reference);
          case "\u660E\u65E5":
            return references.tomorrow(context.reference);
          case "\u4ECA\u65E5":
          case "\u5F53\u65E5":
            return references.today(context.reference);
        }
        if (text2 == "\u4ECA\u591C" || text2 == "\u4ECA\u5915" || text2 == "\u4ECA\u6669") {
          components.imply("hour", 22);
          components.assign("meridiem", index_1.Meridiem.PM);
        } else if (text2.match("\u4ECA\u671D")) {
          components.imply("hour", 6);
          components.assign("meridiem", index_1.Meridiem.AM);
        }
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
        return components;
      }
    };
    exports.default = JPCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ja/index.js
var require_ja = __commonJS({
  "node_modules/chrono-node/dist/locales/ja/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var JPStandardParser_1 = __importDefault(require_JPStandardParser());
    var JPMergeDateRangeRefiner_1 = __importDefault(require_JPMergeDateRangeRefiner());
    var JPCasualDateParser_1 = __importDefault(require_JPCasualDateParser());
    var chrono_1 = require_chrono();
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new JPCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      return {
        parsers: [new JPStandardParser_1.default()],
        refiners: [new JPMergeDateRangeRefiner_1.default()]
      };
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/pt/constants.js
var require_constants5 = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseYear = exports.YEAR_PATTERN = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    exports.WEEKDAY_DICTIONARY = {
      "domingo": 0,
      "dom": 0,
      "segunda": 1,
      "segunda-feira": 1,
      "seg": 1,
      "ter\xE7a": 2,
      "ter\xE7a-feira": 2,
      "ter": 2,
      "quarta": 3,
      "quarta-feira": 3,
      "qua": 3,
      "quinta": 4,
      "quinta-feira": 4,
      "qui": 4,
      "sexta": 5,
      "sexta-feira": 5,
      "sex": 5,
      "s\xE1bado": 6,
      "sabado": 6,
      "sab": 6
    };
    exports.MONTH_DICTIONARY = {
      "janeiro": 1,
      "jan": 1,
      "jan.": 1,
      "fevereiro": 2,
      "fev": 2,
      "fev.": 2,
      "mar\xE7o": 3,
      "mar": 3,
      "mar.": 3,
      "abril": 4,
      "abr": 4,
      "abr.": 4,
      "maio": 5,
      "mai": 5,
      "mai.": 5,
      "junho": 6,
      "jun": 6,
      "jun.": 6,
      "julho": 7,
      "jul": 7,
      "jul.": 7,
      "agosto": 8,
      "ago": 8,
      "ago.": 8,
      "setembro": 9,
      "set": 9,
      "set.": 9,
      "outubro": 10,
      "out": 10,
      "out.": 10,
      "novembro": 11,
      "nov": 11,
      "nov.": 11,
      "dezembro": 12,
      "dez": 12,
      "dez.": 12
    };
    exports.YEAR_PATTERN = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
    function parseYear(match) {
      if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
          if (yearNumber > 50) {
            yearNumber = yearNumber + 1900;
          } else {
            yearNumber = yearNumber + 2e3;
          }
        }
        return yearNumber;
      }
      if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
      }
      return parseInt(match);
    }
    exports.parseYear = parseYear;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js
var require_PTWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var PTWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        if (offset === void 0) {
          return null;
        }
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let norm = prefix || postfix || "";
        norm = norm.toLowerCase();
        let modifier = null;
        if (norm == "passado") {
          modifier = "this";
        } else if (norm == "pr\xF3ximo" || norm == "proximo") {
          modifier = "next";
        } else if (norm == "este") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = PTWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js
var require_PTTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var PTTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
      }
    };
    exports.default = PTTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js
var require_PTMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
      }
    };
    exports.default = PTMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js
var require_PTMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/refiners/PTMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(?:-)\s*$/i;
      }
    };
    exports.default = PTMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var require_PTMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants5();
    var constants_2 = require_constants5();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?(?=\\W|$)`, "i");
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = parseInt(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = parseInt(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = PTMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js
var require_PTCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var PTCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "agora":
            return references.now(context.reference);
          case "hoje":
            return references.today(context.reference);
          case "amanha":
          case "amanh\xE3":
            return references.tomorrow(context.reference);
          case "ontem":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = PTCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js
var require_PTCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/parsers/PTCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var PTCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_2.default(context.refDate);
        const component = context.createParsingComponents();
        switch (match[1].toLowerCase()) {
          case "tarde":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "noite":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 22);
            break;
          case "manha":
          case "manh\xE3":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "meia-noite":
            dayjs_1.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "meio-dia":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = PTCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/pt/index.js
var require_pt = __commonJS({
  "node_modules/chrono-node/dist/locales/pt/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var PTWeekdayParser_1 = __importDefault(require_PTWeekdayParser());
    var PTTimeExpressionParser_1 = __importDefault(require_PTTimeExpressionParser());
    var PTMergeDateTimeRefiner_1 = __importDefault(require_PTMergeDateTimeRefiner());
    var PTMergeDateRangeRefiner_1 = __importDefault(require_PTMergeDateRangeRefiner());
    var PTMonthNameLittleEndianParser_1 = __importDefault(require_PTMonthNameLittleEndianParser());
    var PTCasualDateParser_1 = __importDefault(require_PTCasualDateParser());
    var PTCasualTimeParser_1 = __importDefault(require_PTCasualTimeParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.push(new PTCasualDateParser_1.default());
      option.parsers.push(new PTCasualTimeParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new PTWeekdayParser_1.default(),
          new PTTimeExpressionParser_1.default(),
          new PTMonthNameLittleEndianParser_1.default()
        ],
        refiners: [new PTMergeDateTimeRefiner_1.default(), new PTMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js
var require_NLMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(tot|-)\s*$/i;
      }
    };
    exports.default = NLMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js
var require_NLMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/refiners/NLMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
      }
    };
    exports.default = NLMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js
var require_NLCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var NLCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "nu":
            return references.now(context.reference);
          case "vandaag":
            return references.today(context.reference);
          case "morgen":
          case "morgend":
            return references.tomorrow(context.reference);
          case "gisteren":
            return references.yesterday(context.reference);
        }
        return component;
      }
    };
    exports.default = NLCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js
var require_NLCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var dayjs_2 = require_dayjs();
    var DAY_GROUP = 1;
    var MOMENT_GROUP = 2;
    var NLCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const targetDate = dayjs_1.default(context.refDate);
        const component = context.createParsingComponents();
        if (match[DAY_GROUP] === "deze") {
          component.assign("day", context.refDate.getDate());
          component.assign("month", context.refDate.getMonth() + 1);
          component.assign("year", context.refDate.getFullYear());
        }
        switch (match[MOMENT_GROUP].toLowerCase()) {
          case "namiddag":
          case "'s namiddags":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
          case "'s avonds'":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
          case "middernacht":
            dayjs_2.assignTheNextDay(component, targetDate);
            component.imply("hour", 0);
            component.imply("minute", 0);
            component.imply("second", 0);
            break;
          case "ochtend":
          case "'s ochtends":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
          case "'s middags":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/constants.js
var require_constants6 = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.WEEKDAY_DICTIONARY = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.WEEKDAY_DICTIONARY = {
      zondag: 0,
      zon: 0,
      "zon.": 0,
      zo: 0,
      "zo.": 0,
      maandag: 1,
      ma: 1,
      "ma.": 1,
      dinsdag: 2,
      din: 2,
      "din.": 2,
      di: 2,
      "di.": 2,
      woensdag: 3,
      woe: 3,
      "woe.": 3,
      wo: 3,
      "wo.": 3,
      donderdag: 4,
      dond: 4,
      "dond.": 4,
      do: 4,
      "do.": 4,
      vrijdag: 5,
      vrij: 5,
      "vrij.": 5,
      vr: 5,
      "vr.": 5,
      zaterdag: 6,
      zat: 6,
      "zat.": 6,
      "za": 6,
      "za.": 6
    };
    exports.MONTH_DICTIONARY = {
      januari: 1,
      jan: 1,
      "jan.": 1,
      februari: 2,
      feb: 2,
      "feb.": 2,
      maart: 3,
      mar: 3,
      "mar.": 3,
      april: 4,
      apr: 4,
      "apr.": 4,
      mei: 5,
      juni: 6,
      jun: 6,
      "jun.": 6,
      juli: 7,
      jul: 7,
      "jul.": 7,
      augustus: 8,
      aug: 8,
      "aug.": 8,
      september: 9,
      sep: 9,
      "sep.": 9,
      sept: 9,
      "sept.": 9,
      oktober: 10,
      okt: 10,
      "okt.": 10,
      november: 11,
      nov: 11,
      "nov.": 11,
      december: 12,
      dec: 12,
      "dec.": 12
    };
    exports.INTEGER_WORD_DICTIONARY = {
      een: 1,
      twee: 2,
      drie: 3,
      vier: 4,
      vijf: 5,
      zes: 6,
      zeven: 7,
      acht: 8,
      negen: 9,
      tien: 10,
      elf: 11,
      twaalf: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      eerste: 1,
      tweede: 2,
      derde: 3,
      vierde: 4,
      vijfde: 5,
      zesde: 6,
      zevende: 7,
      achtste: 8,
      negende: 9,
      tiende: 10,
      elfde: 11,
      twaalfde: 12,
      dertiende: 13,
      veertiende: 14,
      vijftiende: 15,
      zestiende: 16,
      zeventiende: 17,
      achttiende: 18,
      negentiende: 19,
      twintigste: 20,
      "eenentwintigste": 21,
      "twee\xEBntwintigste": 22,
      "drieentwintigste": 23,
      "vierentwintigste": 24,
      "vijfentwintigste": 25,
      "zesentwintigste": 26,
      "zevenentwintigste": 27,
      "achtentwintig": 28,
      "negenentwintig": 29,
      "dertigste": 30,
      "eenendertigste": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      sec: "second",
      second: "second",
      seconden: "second",
      min: "minute",
      mins: "minute",
      minute: "minute",
      minuut: "minute",
      minuten: "minute",
      minuutje: "minute",
      h: "hour",
      hr: "hour",
      hrs: "hour",
      uur: "hour",
      u: "hour",
      uren: "hour",
      dag: "d",
      dagen: "d",
      week: "week",
      weken: "week",
      maand: "month",
      maanden: "month",
      jaar: "year",
      jr: "year",
      jaren: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      } else if (num === "paar") {
        return 2;
      } else if (num === "half" || num.match(/halve?/)) {
        return 0.5;
      }
      return parseFloat(num.replace(",", "."));
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:ste|de)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
    function parseYear(match) {
      if (/voor Christus/i.test(match)) {
        match = match.replace(/voor Christus/i, "");
        return -parseInt(match);
      }
      if (/na Christus/i.test(match)) {
        match = match.replace(/na Christus/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,5}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})\\s{0,5}`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length);
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var require_NLTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + constants_1.TIME_UNITS_PATTERN + `)(?=\\W|$)`, "i");
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js
var require_NLWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?=\\W|$)`, "i");
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var NLWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "vorige") {
          modifier = "last";
        } else if (modifierWord == "volgende") {
          modifier = "next";
        } else if (modifierWord == "deze") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = NLWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var require_NLMonthNameMiddleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameMiddleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants6();
    var constants_2 = require_constants6();
    var constants_3 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:on\\s*?)?(${constants_2.ORDINAL_NUMBER_PATTERN})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${constants_2.ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s*(?:of)?\\s*)(` + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + `)(?:(?:-|/|,?\\s*)(${constants_3.YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
    var MONTH_NAME_GROUP = 3;
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var YEAR_GROUP = 4;
    var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_2.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        const components = context.createParsingComponents({
          day,
          month
        });
        if (match[YEAR_GROUP]) {
          const year = constants_3.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          components.imply("year", year);
        }
        if (!match[DATE_TO_GROUP]) {
          return components;
        }
        const endDate = constants_2.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
        const result = context.createParsingResult(match.index, match[0]);
        result.start = components;
        result.end = components.clone();
        result.end.assign("day", endDate);
        return result;
      }
    };
    exports.default = NLMonthNameMiddleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js
var require_NLMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants6();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
    var MONTH_NAME_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const components = context.createParsingComponents();
        components.imply("day", 1);
        const monthName = match[MONTH_NAME_GROUP];
        const month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          components.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          components.imply("year", year);
        }
        return components;
      }
    };
    exports.default = NLMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js
var require_NLSlashMonthFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLSlashMonthFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
    var MONTH_GROUP = 1;
    var YEAR_GROUP = 2;
    var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const year = parseInt(match[YEAR_GROUP]);
        const month = parseInt(match[MONTH_GROUP]);
        return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year);
      }
    };
    exports.default = NLSlashMonthFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js
var require_NLTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var NLTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      primaryPrefix() {
        return "(?:(?:om)\\s*)?";
      }
      followingPhase() {
        return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
      }
      primarySuffix() {
        return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
      }
      extractPrimaryTimeComponents(context, match) {
        if (match[0].match(/^\s*\d{4}\s*$/)) {
          return null;
        }
        return super.extractPrimaryTimeComponents(context, match);
      }
    };
    exports.default = NLTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js
var require_NLCasualYearMonthDayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualYearMonthDayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
    var YEAR_NUMBER_GROUP = 1;
    var MONTH_NAME_GROUP = 2;
    var MONTH_NUMBER_GROUP = 3;
    var DATE_NUMBER_GROUP = 4;
    var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        if (month < 1 || month > 12) {
          return null;
        }
        const year = parseInt(match[YEAR_NUMBER_GROUP]);
        const day = parseInt(match[DATE_NUMBER_GROUP]);
        return {
          day,
          month,
          year
        };
      }
    };
    exports.default = NLCasualYearMonthDayParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js
var require_NLCasualDateTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLCasualDateTimeParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var index_1 = require_dist();
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var DATE_GROUP = 1;
    var TIME_OF_DAY_GROUP = 2;
    var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
      }
      innerExtract(context, match) {
        const dateText = match[DATE_GROUP].toLowerCase();
        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
        const component = context.createParsingComponents();
        const targetDate = dayjs_2.default(context.refDate);
        switch (dateText) {
          case "gisteren":
            dayjs_1.assignSimilarDate(component, targetDate.add(-1, "day"));
            break;
          case "van":
            dayjs_1.assignSimilarDate(component, targetDate);
            break;
          case "morgen":
            dayjs_1.assignTheNextDay(component, targetDate);
            break;
        }
        switch (timeText) {
          case "ochtend":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 6);
            break;
          case "middag":
            component.imply("meridiem", index_1.Meridiem.AM);
            component.imply("hour", 12);
            break;
          case "namiddag":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 15);
            break;
          case "avond":
            component.imply("meridiem", index_1.Meridiem.PM);
            component.imply("hour", 20);
            break;
        }
        return component;
      }
    };
    exports.default = NLCasualDateTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var require_NLTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(deze|vorige|afgelopen|komende|over|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
    var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "vorige":
          case "afgelopen":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = NLTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js
var require_NLRelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLRelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(dit|deze|komende|volgend|volgende|afgelopen|vorige)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "volgend" || modifier == "volgende" || modifier == "komende") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "afgelopen" || modifier == "vorige") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (unitWord.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (unitWord.match(/maand/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (unitWord.match(/jaar/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = NLRelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var require_NLTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")geleden(?=(?:\\W|$))", "i");
    var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = NLTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var require_NLTimeUnitLaterFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/parsers/NLTimeUnitLaterFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants6();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
    var STRICT_PATTERN = new RegExp("(" + constants_1.TIME_UNITS_PATTERN + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
    var GROUP_NUM_TIMEUNITS = 1;
    var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      constructor(strictMode) {
        super();
        this.strictMode = strictMode;
      }
      innerPattern() {
        return this.strictMode ? STRICT_PATTERN : PATTERN;
      }
      innerExtract(context, match) {
        const fragments = constants_1.parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, fragments);
      }
    };
    exports.default = NLTimeUnitLaterFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/nl/index.js
var require_nl = __commonJS({
  "node_modules/chrono-node/dist/locales/nl/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var configurations_1 = require_configurations();
    var chrono_1 = require_chrono();
    var NLMergeDateRangeRefiner_1 = __importDefault(require_NLMergeDateRangeRefiner());
    var NLMergeDateTimeRefiner_1 = __importDefault(require_NLMergeDateTimeRefiner());
    var NLCasualDateParser_1 = __importDefault(require_NLCasualDateParser());
    var NLCasualTimeParser_1 = __importDefault(require_NLCasualTimeParser());
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var NLTimeUnitWithinFormatParser_1 = __importDefault(require_NLTimeUnitWithinFormatParser());
    var NLWeekdayParser_1 = __importDefault(require_NLWeekdayParser());
    var NLMonthNameMiddleEndianParser_1 = __importDefault(require_NLMonthNameMiddleEndianParser());
    var NLMonthNameParser_1 = __importDefault(require_NLMonthNameParser());
    var NLSlashMonthFormatParser_1 = __importDefault(require_NLSlashMonthFormatParser());
    var NLTimeExpressionParser_1 = __importDefault(require_NLTimeExpressionParser());
    var NLCasualYearMonthDayParser_1 = __importDefault(require_NLCasualYearMonthDayParser());
    var NLCasualDateTimeParser_1 = __importDefault(require_NLCasualDateTimeParser());
    var NLTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_NLTimeUnitCasualRelativeFormatParser());
    var NLRelativeDateFormatParser_1 = __importDefault(require_NLRelativeDateFormatParser());
    var NLTimeUnitAgoFormatParser_1 = __importDefault(require_NLTimeUnitAgoFormatParser());
    var NLTimeUnitLaterFormatParser_1 = __importDefault(require_NLTimeUnitLaterFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration(littleEndian = true) {
      const option = createConfiguration(false, littleEndian);
      option.parsers.unshift(new NLCasualDateParser_1.default());
      option.parsers.unshift(new NLCasualTimeParser_1.default());
      option.parsers.unshift(new NLCasualDateTimeParser_1.default());
      option.parsers.unshift(new NLMonthNameParser_1.default());
      option.parsers.unshift(new NLRelativeDateFormatParser_1.default());
      option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true, littleEndian = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(littleEndian),
          new NLTimeUnitWithinFormatParser_1.default(),
          new NLMonthNameMiddleEndianParser_1.default(),
          new NLMonthNameParser_1.default(),
          new NLWeekdayParser_1.default(),
          new NLCasualYearMonthDayParser_1.default(),
          new NLSlashMonthFormatParser_1.default(),
          new NLTimeExpressionParser_1.default(strictMode),
          new NLTimeUnitAgoFormatParser_1.default(strictMode),
          new NLTimeUnitLaterFormatParser_1.default(strictMode)
        ],
        refiners: [new NLMergeDateTimeRefiner_1.default(), new NLMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var require_ZHHantCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9" || time1 == "\u671D") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B" || time2 == "\u664F") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B" || time3 == "\u664F") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHantCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/constants.js
var require_constants7 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u5169": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10,
      "\u5EFF": 20,
      "\u5345": 30
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js
var require_ZHHantDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHantDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var require_ZHHantDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u5E7E") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星禮月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHantDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var require_ZHHantRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u4ECA" || prefix == "\u9019" || prefix == "\u5462") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var require_ZHHantTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var FIRST_REG_PATTERN = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          var day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E" || day1 == "\u807D") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          var day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E" || day3 == "\u807D") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u5F8C") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u5F8C") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          var second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          var zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          var zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          var zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHantTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var require_ZHHantWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/parsers/ZHHantWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants7();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHantWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var require_ZHHantMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var require_ZHHantMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHantMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hant/index.js
var require_hant = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hant/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hant = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHantCasualDateParser_1 = __importDefault(require_ZHHantCasualDateParser());
    var ZHHantDateParser_1 = __importDefault(require_ZHHantDateParser());
    var ZHHantDeadlineFormatParser_1 = __importDefault(require_ZHHantDeadlineFormatParser());
    var ZHHantRelationWeekdayParser_1 = __importDefault(require_ZHHantRelationWeekdayParser());
    var ZHHantTimeExpressionParser_1 = __importDefault(require_ZHHantTimeExpressionParser());
    var ZHHantWeekdayParser_1 = __importDefault(require_ZHHantWeekdayParser());
    var ZHHantMergeDateRangeRefiner_1 = __importDefault(require_ZHHantMergeDateRangeRefiner());
    var ZHHantMergeDateTimeRefiner_1 = __importDefault(require_ZHHantMergeDateTimeRefiner());
    exports.hant = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHantCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHantDateParser_1.default(),
          new ZHHantRelationWeekdayParser_1.default(),
          new ZHHantWeekdayParser_1.default(),
          new ZHHantTimeExpressionParser_1.default(),
          new ZHHantDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHantMergeDateRangeRefiner_1.default(), new ZHHantMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var require_ZHHansCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansCasualDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var NOW_GROUP = 1;
    var DAY_GROUP_1 = 2;
    var TIME_GROUP_1 = 3;
    var TIME_GROUP_2 = 4;
    var DAY_GROUP_3 = 5;
    var TIME_GROUP_3 = 6;
    var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern(context) {
        return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
      }
      innerExtract(context, match) {
        const index = match.index;
        const result = context.createParsingResult(index, match[0]);
        const refMoment = dayjs_1.default(context.refDate);
        let startMoment = refMoment;
        if (match[NOW_GROUP]) {
          result.start.imply("hour", refMoment.hour());
          result.start.imply("minute", refMoment.minute());
          result.start.imply("second", refMoment.second());
          result.start.imply("millisecond", refMoment.millisecond());
        } else if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          const time1 = match[TIME_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          if (time1 == "\u65E9") {
            result.start.imply("hour", 6);
          } else if (time1 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          }
        } else if (match[TIME_GROUP_2]) {
          const timeString2 = match[TIME_GROUP_2];
          const time2 = timeString2[0];
          if (time2 == "\u65E9" || time2 == "\u4E0A") {
            result.start.imply("hour", 6);
          } else if (time2 == "\u4E0B") {
            result.start.imply("hour", 15);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u4E2D") {
            result.start.imply("hour", 12);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u591C" || time2 == "\u665A") {
            result.start.imply("hour", 22);
            result.start.imply("meridiem", 1);
          } else if (time2 == "\u51CC") {
            result.start.imply("hour", 0);
          }
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment = startMoment.add(1, "day");
            }
          } else if (day3 == "\u6628") {
            startMoment = startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment = startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment = startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment = startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment = startMoment.add(3, "day");
          }
          const timeString3 = match[TIME_GROUP_3];
          if (timeString3) {
            const time3 = timeString3[0];
            if (time3 == "\u65E9" || time3 == "\u4E0A") {
              result.start.imply("hour", 6);
            } else if (time3 == "\u4E0B") {
              result.start.imply("hour", 15);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u4E2D") {
              result.start.imply("hour", 12);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u591C" || time3 == "\u665A") {
              result.start.imply("hour", 22);
              result.start.imply("meridiem", 1);
            } else if (time3 == "\u51CC") {
              result.start.imply("hour", 0);
            }
          }
        }
        result.start.assign("day", startMoment.date());
        result.start.assign("month", startMoment.month() + 1);
        result.start.assign("year", startMoment.year());
        return result;
      }
    };
    exports.default = ZHHansCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/constants.js
var require_constants8 = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhStringToYear = exports.zhStringToNumber = exports.WEEKDAY_OFFSET = exports.NUMBER = void 0;
    exports.NUMBER = {
      "\u96F6": 0,
      "\u3007": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E24": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6,
      "\u4E03": 7,
      "\u516B": 8,
      "\u4E5D": 9,
      "\u5341": 10
    };
    exports.WEEKDAY_OFFSET = {
      "\u5929": 0,
      "\u65E5": 0,
      "\u4E00": 1,
      "\u4E8C": 2,
      "\u4E09": 3,
      "\u56DB": 4,
      "\u4E94": 5,
      "\u516D": 6
    };
    function zhStringToNumber(text2) {
      let number = 0;
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        if (char === "\u5341") {
          number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
          number += exports.NUMBER[char];
        }
      }
      return number;
    }
    exports.zhStringToNumber = zhStringToNumber;
    function zhStringToYear(text2) {
      let string = "";
      for (let i = 0; i < text2.length; i++) {
        const char = text2[i];
        string = string + exports.NUMBER[char];
      }
      return parseInt(string);
    }
    exports.zhStringToYear = zhStringToYear;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js
var require_ZHHansDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDateParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var YEAR_GROUP = 1;
    var MONTH_GROUP = 2;
    var DAY_GROUP = 3;
    var ZHHansDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return new RegExp("(\\d{2,4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{4}|[" + Object.keys(constants_1.NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(constants_1.NUMBER).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
      }
      innerExtract(context, match) {
        const startMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        let month = parseInt(match[MONTH_GROUP]);
        if (isNaN(month))
          month = constants_1.zhStringToNumber(match[MONTH_GROUP]);
        result.start.assign("month", month);
        if (match[DAY_GROUP]) {
          let day = parseInt(match[DAY_GROUP]);
          if (isNaN(day))
            day = constants_1.zhStringToNumber(match[DAY_GROUP]);
          result.start.assign("day", day);
        } else {
          result.start.imply("day", startMoment.date());
        }
        if (match[YEAR_GROUP]) {
          let year = parseInt(match[YEAR_GROUP]);
          if (isNaN(year))
            year = constants_1.zhStringToYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansDateParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var require_ZHHansDeadlineFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
    var NUMBER_GROUP = 1;
    var UNIT_GROUP = 2;
    var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        let number = parseInt(match[NUMBER_GROUP]);
        if (isNaN(number)) {
          number = constants_1.zhStringToNumber(match[NUMBER_GROUP]);
        }
        if (isNaN(number)) {
          const string = match[NUMBER_GROUP];
          if (string === "\u51E0") {
            number = 3;
          } else if (string === "\u534A") {
            number = 0.5;
          } else {
            return null;
          }
        }
        let date = dayjs_1.default(context.refDate);
        const unit = match[UNIT_GROUP];
        const unitAbbr = unit[0];
        if (unitAbbr.match(/[日天星礼月年]/)) {
          if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
            date = date.add(number, "d");
          } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
            date = date.add(number * 7, "d");
          } else if (unitAbbr == "\u6708") {
            date = date.add(number, "month");
          } else if (unitAbbr == "\u5E74") {
            date = date.add(number, "year");
          }
          result.start.assign("year", date.year());
          result.start.assign("month", date.month() + 1);
          result.start.assign("day", date.date());
          return result;
        }
        if (unitAbbr == "\u79D2") {
          date = date.add(number, "second");
        } else if (unitAbbr == "\u5206") {
          date = date.add(number, "minute");
        } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
          date = date.add(number, "hour");
        }
        result.start.imply("year", date.year());
        result.start.imply("month", date.month() + 1);
        result.start.imply("day", date.date());
        result.start.assign("hour", date.hour());
        result.start.assign("minute", date.minute());
        result.start.assign("second", date.second());
        return result;
      }
    };
    exports.default = ZHHansDeadlineFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var require_ZHHansRelationWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let modifier = null;
        const prefix = match.groups.prefix;
        if (prefix == "\u4E0A") {
          modifier = "last";
        } else if (prefix == "\u4E0B") {
          modifier = "next";
        } else if (prefix == "\u8FD9") {
          modifier = "this";
        }
        let startMoment = dayjs_1.default(context.refDate);
        let startMomentFixed = false;
        const refOffset = startMoment.day();
        if (modifier == "last" || modifier == "past") {
          startMoment = startMoment.day(offset - 7);
          startMomentFixed = true;
        } else if (modifier == "next") {
          startMoment = startMoment.day(offset + 7);
          startMomentFixed = true;
        } else if (modifier == "this") {
          startMoment = startMoment.day(offset);
        } else {
          if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset - 7);
          } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
            startMoment = startMoment.day(offset + 7);
          } else {
            startMoment = startMoment.day(offset);
          }
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansRelationWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var require_ZHHansTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var FIRST_REG_PATTERN = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var SECOND_REG_PATTERN = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(constants_1.NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
    var DAY_GROUP_1 = 1;
    var ZH_AM_PM_HOUR_GROUP_1 = 2;
    var ZH_AM_PM_HOUR_GROUP_2 = 3;
    var DAY_GROUP_3 = 4;
    var ZH_AM_PM_HOUR_GROUP_3 = 5;
    var HOUR_GROUP = 6;
    var MINUTE_GROUP = 7;
    var SECOND_GROUP = 8;
    var AM_PM_HOUR_GROUP = 9;
    var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return FIRST_REG_PATTERN;
      }
      innerExtract(context, match) {
        if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
          return null;
        }
        const refMoment = dayjs_1.default(context.refDate);
        const result = context.createParsingResult(match.index, match[0]);
        const startMoment = refMoment.clone();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              startMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            startMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            startMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            startMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            startMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            startMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            startMoment.add(3, "day");
          }
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        let hour = 0;
        let minute = 0;
        let meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.start.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.start.assign("hour", hour);
        result.start.assign("minute", minute);
        if (meridiem >= 0) {
          result.start.assign("meridiem", meridiem);
        } else {
          if (hour < 12) {
            result.start.imply("meridiem", 0);
          } else {
            result.start.imply("meridiem", 1);
          }
        }
        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));
        if (!match) {
          if (result.text.match(/^\d+$/)) {
            return null;
          }
          return result;
        }
        const endMoment = startMoment.clone();
        result.end = context.createParsingComponents();
        if (match[DAY_GROUP_1]) {
          const day1 = match[DAY_GROUP_1];
          if (day1 == "\u660E") {
            if (refMoment.hour() > 1) {
              endMoment.add(1, "day");
            }
          } else if (day1 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day1 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day1 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day1 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day1 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else if (match[DAY_GROUP_3]) {
          const day3 = match[DAY_GROUP_3];
          if (day3 == "\u660E") {
            endMoment.add(1, "day");
          } else if (day3 == "\u6628") {
            endMoment.add(-1, "day");
          } else if (day3 == "\u524D") {
            endMoment.add(-2, "day");
          } else if (day3 == "\u5927\u524D") {
            endMoment.add(-3, "day");
          } else if (day3 == "\u540E") {
            endMoment.add(2, "day");
          } else if (day3 == "\u5927\u540E") {
            endMoment.add(3, "day");
          }
          result.end.assign("day", endMoment.date());
          result.end.assign("month", endMoment.month() + 1);
          result.end.assign("year", endMoment.year());
        } else {
          result.end.imply("day", endMoment.date());
          result.end.imply("month", endMoment.month() + 1);
          result.end.imply("year", endMoment.year());
        }
        hour = 0;
        minute = 0;
        meridiem = -1;
        if (match[SECOND_GROUP]) {
          let second = parseInt(match[SECOND_GROUP]);
          if (isNaN(second)) {
            second = constants_1.zhStringToNumber(match[SECOND_GROUP]);
          }
          if (second >= 60)
            return null;
          result.end.assign("second", second);
        }
        hour = parseInt(match[HOUR_GROUP]);
        if (isNaN(hour)) {
          hour = constants_1.zhStringToNumber(match[HOUR_GROUP]);
        }
        if (match[MINUTE_GROUP]) {
          if (match[MINUTE_GROUP] == "\u534A") {
            minute = 30;
          } else if (match[MINUTE_GROUP] == "\u6B63" || match[MINUTE_GROUP] == "\u6574") {
            minute = 0;
          } else {
            minute = parseInt(match[MINUTE_GROUP]);
            if (isNaN(minute)) {
              minute = constants_1.zhStringToNumber(match[MINUTE_GROUP]);
            }
          }
        } else if (hour > 100) {
          minute = hour % 100;
          hour = Math.floor(hour / 100);
        }
        if (minute >= 60) {
          return null;
        }
        if (hour > 24) {
          return null;
        }
        if (hour >= 12) {
          meridiem = 1;
        }
        if (match[AM_PM_HOUR_GROUP]) {
          if (hour > 12)
            return null;
          const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
          if (ampm == "a") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          }
          if (ampm == "p") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
          if (!result.start.isCertain("meridiem")) {
            if (meridiem == 0) {
              result.start.imply("meridiem", 0);
              if (result.start.get("hour") == 12) {
                result.start.assign("hour", 0);
              }
            } else {
              result.start.imply("meridiem", 1);
              if (result.start.get("hour") != 12) {
                result.start.assign("hour", result.start.get("hour") + 12);
              }
            }
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
          const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
          const zhAMPM1 = zhAMPMString1[0];
          if (zhAMPM1 == "\u65E9") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM1 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
          const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
          const zhAMPM2 = zhAMPMString2[0];
          if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
          const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
          const zhAMPM3 = zhAMPMString3[0];
          if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
            meridiem = 0;
            if (hour == 12)
              hour = 0;
          } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
            meridiem = 1;
            if (hour != 12)
              hour += 12;
          }
        }
        result.text = result.text + match[0];
        result.end.assign("hour", hour);
        result.end.assign("minute", minute);
        if (meridiem >= 0) {
          result.end.assign("meridiem", meridiem);
        } else {
          const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
          if (startAtPM && result.start.get("hour") > hour) {
            result.end.imply("meridiem", 0);
          } else if (hour > 12) {
            result.end.imply("meridiem", 1);
          }
        }
        if (result.end.date().getTime() < result.start.date().getTime()) {
          result.end.imply("day", result.end.get("day") + 1);
        }
        return result;
      }
    };
    exports.default = ZHHansTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var require_ZHHansWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/parsers/ZHHansWeekdayParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var constants_1 = require_constants8();
    var PATTERN = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(constants_1.WEEKDAY_OFFSET).join("|") + ")");
    var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const dayOfWeek = match.groups.weekday;
        const offset = constants_1.WEEKDAY_OFFSET[dayOfWeek];
        if (offset === void 0)
          return null;
        let startMoment = dayjs_1.default(context.refDate);
        const startMomentFixed = false;
        const refOffset = startMoment.day();
        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset - 7);
        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {
          startMoment = startMoment.day(offset + 7);
        } else {
          startMoment = startMoment.day(offset);
        }
        result.start.assign("weekday", offset);
        if (startMomentFixed) {
          result.start.assign("day", startMoment.date());
          result.start.assign("month", startMoment.month() + 1);
          result.start.assign("year", startMoment.year());
        } else {
          result.start.imply("day", startMoment.date());
          result.start.imply("month", startMoment.month() + 1);
          result.start.imply("year", startMoment.year());
        }
        return result;
      }
    };
    exports.default = ZHHansWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var require_ZHHansMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateRangeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var require_ZHHansMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return /^\s*$/i;
      }
    };
    exports.default = ZHHansMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/zh/hans/index.js
var require_hans = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/hans/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = exports.hans = void 0;
    var chrono_1 = require_chrono();
    var ExtractTimezoneOffsetRefiner_1 = __importDefault(require_ExtractTimezoneOffsetRefiner());
    var configurations_1 = require_configurations();
    var ZHHansCasualDateParser_1 = __importDefault(require_ZHHansCasualDateParser());
    var ZHHansDateParser_1 = __importDefault(require_ZHHansDateParser());
    var ZHHansDeadlineFormatParser_1 = __importDefault(require_ZHHansDeadlineFormatParser());
    var ZHHansRelationWeekdayParser_1 = __importDefault(require_ZHHansRelationWeekdayParser());
    var ZHHansTimeExpressionParser_1 = __importDefault(require_ZHHansTimeExpressionParser());
    var ZHHansWeekdayParser_1 = __importDefault(require_ZHHansWeekdayParser());
    var ZHHansMergeDateRangeRefiner_1 = __importDefault(require_ZHHansMergeDateRangeRefiner());
    var ZHHansMergeDateTimeRefiner_1 = __importDefault(require_ZHHansMergeDateTimeRefiner());
    exports.hans = new chrono_1.Chrono(createCasualConfiguration());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration());
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration();
      option.parsers.unshift(new ZHHansCasualDateParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration() {
      const configuration = configurations_1.includeCommonConfiguration({
        parsers: [
          new ZHHansDateParser_1.default(),
          new ZHHansRelationWeekdayParser_1.default(),
          new ZHHansWeekdayParser_1.default(),
          new ZHHansTimeExpressionParser_1.default(),
          new ZHHansDeadlineFormatParser_1.default()
        ],
        refiners: [new ZHHansMergeDateRangeRefiner_1.default(), new ZHHansMergeDateTimeRefiner_1.default()]
      });
      configuration.refiners = configuration.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner_1.default));
      return configuration;
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/locales/zh/index.js
var require_zh = __commonJS({
  "node_modules/chrono-node/dist/locales/zh/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hans = void 0;
    __exportStar(require_hant(), exports);
    exports.hans = __importStar(require_hans());
  }
});

// node_modules/chrono-node/dist/locales/ru/constants.js
var require_constants9 = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTimeUnits = exports.TIME_UNITS_PATTERN = exports.parseYear = exports.YEAR_PATTERN = exports.parseOrdinalNumberPattern = exports.ORDINAL_NUMBER_PATTERN = exports.parseNumberPattern = exports.NUMBER_PATTERN = exports.TIME_UNIT_DICTIONARY = exports.ORDINAL_WORD_DICTIONARY = exports.INTEGER_WORD_DICTIONARY = exports.MONTH_DICTIONARY = exports.FULL_MONTH_NAME_DICTIONARY = exports.WEEKDAY_DICTIONARY = exports.REGEX_PARTS = void 0;
    var pattern_1 = require_pattern();
    var years_1 = require_years();
    exports.REGEX_PARTS = {
      leftBoundary: "([^\\p{L}\\p{N}_]|^)",
      rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
      flags: "iu"
    };
    exports.WEEKDAY_DICTIONARY = {
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
      \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
      \u0432\u0441\u043A: 0,
      "\u0432\u0441\u043A.": 0,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
      \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
      \u043F\u043D: 1,
      "\u043F\u043D.": 1,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
      \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
      \u0432\u0442: 2,
      "\u0432\u0442.": 2,
      \u0441\u0440\u0435\u0434\u0430: 3,
      \u0441\u0440\u0435\u0434\u044B: 3,
      \u0441\u0440\u0435\u0434\u0443: 3,
      \u0441\u0440: 3,
      "\u0441\u0440.": 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
      \u0447\u0442: 4,
      "\u0447\u0442.": 4,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
      \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
      \u043F\u0442: 5,
      "\u043F\u0442.": 5,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
      \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
      \u0441\u0431: 6,
      "\u0441\u0431.": 6
    };
    exports.FULL_MONTH_NAME_DICTIONARY = {
      \u044F\u043D\u0432\u0430\u0440\u044C: 1,
      \u044F\u043D\u0432\u0430\u0440\u044F: 1,
      \u044F\u043D\u0432\u0430\u0440\u0435: 1,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044C: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u044F: 2,
      \u0444\u0435\u0432\u0440\u044F\u043B\u0435: 2,
      \u043C\u0430\u0440\u0442: 3,
      \u043C\u0430\u0440\u0442\u0430: 3,
      \u043C\u0430\u0440\u0442\u0435: 3,
      \u0430\u043F\u0440\u0435\u043B\u044C: 4,
      \u0430\u043F\u0440\u0435\u043B\u044F: 4,
      \u0430\u043F\u0440\u0435\u043B\u0435: 4,
      \u043C\u0430\u0439: 5,
      \u043C\u0430\u044F: 5,
      \u043C\u0430\u0435: 5,
      \u0438\u044E\u043D\u044C: 6,
      \u0438\u044E\u043D\u044F: 6,
      \u0438\u044E\u043D\u0435: 6,
      \u0438\u044E\u043B\u044C: 7,
      \u0438\u044E\u043B\u044F: 7,
      \u0438\u044E\u043B\u0435: 7,
      \u0430\u0432\u0433\u0443\u0441\u0442: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
      \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
      \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
      \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
      \u043D\u043E\u044F\u0431\u0440\u044C: 11,
      \u043D\u043E\u044F\u0431\u0440\u044F: 11,
      \u043D\u043E\u044F\u0431\u0440\u0435: 11,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
      \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
    };
    exports.MONTH_DICTIONARY = Object.assign(Object.assign({}, exports.FULL_MONTH_NAME_DICTIONARY), { \u044F\u043D\u0432: 1, "\u044F\u043D\u0432.": 1, \u0444\u0435\u0432: 2, "\u0444\u0435\u0432.": 2, \u043C\u0430\u0440: 3, "\u043C\u0430\u0440.": 3, \u0430\u043F\u0440: 4, "\u0430\u043F\u0440.": 4, \u0430\u0432\u0433: 8, "\u0430\u0432\u0433.": 8, \u0441\u0435\u043D: 9, "\u0441\u0435\u043D.": 9, \u043E\u043A\u0442: 10, "\u043E\u043A\u0442.": 10, \u043D\u043E\u044F: 11, "\u043D\u043E\u044F.": 11, \u0434\u0435\u043A: 12, "\u0434\u0435\u043A.": 12 });
    exports.INTEGER_WORD_DICTIONARY = {
      \u043E\u0434\u0438\u043D: 1,
      \u043E\u0434\u043D\u0430: 1,
      \u043E\u0434\u043D\u043E\u0439: 1,
      \u043E\u0434\u043D\u0443: 1,
      \u0434\u0432\u0435: 2,
      \u0434\u0432\u0430: 2,
      \u0434\u0432\u0443\u0445: 2,
      \u0442\u0440\u0438: 3,
      \u0442\u0440\u0435\u0445: 3,
      \u0442\u0440\u0451\u0445: 3,
      \u0447\u0435\u0442\u044B\u0440\u0435: 4,
      \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
      \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
      \u043F\u044F\u0442\u044C: 5,
      \u043F\u044F\u0442\u0438: 5,
      \u0448\u0435\u0441\u0442\u044C: 6,
      \u0448\u0435\u0441\u0442\u0438: 6,
      \u0441\u0435\u043C\u044C: 7,
      \u0441\u0435\u043C\u0438: 7,
      \u0432\u043E\u0441\u0435\u043C\u044C: 8,
      \u0432\u043E\u0441\u0435\u043C\u044C\u043C\u0438: 8,
      \u0434\u0435\u0432\u044F\u0442\u044C: 9,
      \u0434\u0435\u0432\u044F\u0442\u0438: 9,
      \u0434\u0435\u0441\u044F\u0442\u044C: 10,
      \u0434\u0435\u0441\u044F\u0442\u0438: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
    };
    exports.ORDINAL_WORD_DICTIONARY = {
      \u043F\u0435\u0440\u0432\u043E\u0435: 1,
      \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
      \u0432\u0442\u043E\u0440\u043E\u0435: 2,
      \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
      \u0442\u0440\u0435\u0442\u044C\u0435: 3,
      \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
      \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
      \u043F\u044F\u0442\u043E\u0435: 5,
      \u043F\u044F\u0442\u043E\u0433\u043E: 5,
      \u0448\u0435\u0441\u0442\u043E\u0435: 6,
      \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
      \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
      \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
      \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
      \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
      \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
      \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
      \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
      \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
      \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
      \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
      \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
      \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
      \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
      \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
      "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
      "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
    };
    exports.TIME_UNIT_DICTIONARY = {
      \u0441\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
      \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
      \u043C\u0438\u043D: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
      \u043C\u0438\u043D\u0443\u0442: "minute",
      \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
      \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
      \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
      \u0447\u0430\u0441: "hour",
      \u0447\u0430\u0441\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0430: "hour",
      \u0447\u0430\u0441\u0443: "hour",
      \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
      \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
      \u0447\u0430\u0441\u0438\u043A: "hour",
      \u0434\u0435\u043D\u044C: "d",
      \u0434\u043D\u044F: "d",
      \u0434\u043D\u0435\u0439: "d",
      \u0441\u0443\u0442\u043E\u043A: "d",
      \u0441\u0443\u0442\u043A\u0438: "d",
      \u043D\u0435\u0434\u0435\u043B\u044F: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u044E: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
      \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
      \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
      \u043C\u0435\u0441\u044F\u0446: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435: "month",
      \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
      \u043C\u0435\u0441\u044F\u0446\u0430: "month",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
      \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
      \u0433\u043E\u0434: "year",
      \u0433\u043E\u0434\u0430: "year",
      \u0433\u043E\u0434\u0443: "year",
      \u0433\u043E\u0434\u043E\u0432: "year",
      \u043B\u0435\u0442: "year",
      \u0433\u043E\u0434\u0438\u043A: "year",
      \u0433\u043E\u0434\u0438\u043A\u0430: "year",
      \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
    };
    exports.NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
    function parseNumberPattern(match) {
      const num = match.toLowerCase();
      if (exports.INTEGER_WORD_DICTIONARY[num] !== void 0) {
        return exports.INTEGER_WORD_DICTIONARY[num];
      }
      if (num.match(/несколько/)) {
        return 3;
      } else if (num.match(/пол/)) {
        return 0.5;
      } else if (num.match(/пар/)) {
        return 2;
      } else if (num === "") {
        return 1;
      }
      return parseFloat(num);
    }
    exports.parseNumberPattern = parseNumberPattern;
    exports.ORDINAL_NUMBER_PATTERN = `(?:${pattern_1.matchAnyPattern(exports.ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
    function parseOrdinalNumberPattern(match) {
      let num = match.toLowerCase();
      if (exports.ORDINAL_WORD_DICTIONARY[num] !== void 0) {
        return exports.ORDINAL_WORD_DICTIONARY[num];
      }
      num = num.replace(/(?:st|nd|rd|th)$/i, "");
      return parseInt(num);
    }
    exports.parseOrdinalNumberPattern = parseOrdinalNumberPattern;
    var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
    exports.YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
    function parseYear(match) {
      if (/(год|года|г|г.)/i.test(match)) {
        match = match.replace(/(год|года|г|г.)/i, "");
      }
      if (/(до н.э.|до н. э.)/i.test(match)) {
        match = match.replace(/(до н.э.|до н. э.)/i, "");
        return -parseInt(match);
      }
      if (/(н. э.|н.э.)/i.test(match)) {
        match = match.replace(/(н. э.|н.э.)/i, "");
        return parseInt(match);
      }
      const rawYearNumber = parseInt(match);
      return years_1.findMostLikelyADYear(rawYearNumber);
    }
    exports.parseYear = parseYear;
    var SINGLE_TIME_UNIT_PATTERN = `(${exports.NUMBER_PATTERN})\\s{0,3}(${pattern_1.matchAnyPattern(exports.TIME_UNIT_DICTIONARY)})`;
    var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
    exports.TIME_UNITS_PATTERN = pattern_1.repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);
    function parseTimeUnits(timeunitText) {
      const fragments = {};
      let remainingText = timeunitText;
      let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      while (match) {
        collectDateTimeFragment(fragments, match);
        remainingText = remainingText.substring(match[0].length).trim();
        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
      }
      return fragments;
    }
    exports.parseTimeUnits = parseTimeUnits;
    function collectDateTimeFragment(fragments, match) {
      const num = parseNumberPattern(match[1]);
      const unit = exports.TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
      fragments[unit] = num;
    }
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var require_RUTimeUnitWithinFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitWithinFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`;
    var PATTERN_WITH_PREFIX = new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN}`, constants_1.REGEX_PARTS.flags);
    var PATTERN_WITHOUT_PREFIX = new RegExp(PATTERN, "i");
    var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitWithinFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var require_RUMonthNameLittleEndianParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameLittleEndianParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var years_1 = require_years();
    var constants_1 = require_constants9();
    var constants_2 = require_constants9();
    var constants_3 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`(?:\u0441)?\\s*(${constants_3.ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${constants_3.ORDINAL_NUMBER_PATTERN}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})(?:(?:-|\\/|,?\\s{0,3})(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var DATE_GROUP = 1;
    var DATE_TO_GROUP = 2;
    var MONTH_NAME_GROUP = 3;
    var YEAR_GROUP = 4;
    var RUMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const result = context.createParsingResult(match.index, match[0]);
        const month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        const day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
          match.index = match.index + match[DATE_GROUP].length;
          return null;
        }
        result.start.assign("month", month);
        result.start.assign("day", day);
        if (match[YEAR_GROUP]) {
          const yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", yearNumber);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, day, month);
          result.start.imply("year", year);
        }
        if (match[DATE_TO_GROUP]) {
          const endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
          result.end = result.start.clone();
          result.end.assign("day", endDate);
        }
        return result;
      }
    };
    exports.default = RUMonthNameLittleEndianParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js
var require_RUMonthNameParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUMonthNameParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var years_1 = require_years();
    var pattern_1 = require_pattern();
    var constants_2 = require_constants9();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var PATTERN = new RegExp(`((?:\u0432)\\s*)?(${pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${constants_2.YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, constants_1.REGEX_PARTS.flags);
    var MONTH_NAME_GROUP = 2;
    var YEAR_GROUP = 3;
    var RUMonthNameParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const monthName = match[MONTH_NAME_GROUP].toLowerCase();
        if (match[0].length <= 3 && !constants_1.FULL_MONTH_NAME_DICTIONARY[monthName]) {
          return null;
        }
        const result = context.createParsingResult(match.index, match.index + match[0].length);
        result.start.imply("day", 1);
        const month = constants_1.MONTH_DICTIONARY[monthName];
        result.start.assign("month", month);
        if (match[YEAR_GROUP]) {
          const year = constants_2.parseYear(match[YEAR_GROUP]);
          result.start.assign("year", year);
        } else {
          const year = years_1.findYearClosestToRef(context.refDate, 1, month);
          result.start.imply("year", year);
        }
        return result;
      }
    };
    exports.default = RUMonthNameParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js
var require_RUTimeExpressionParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeExpressionParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_dist();
    var AbstractTimeExpressionParser_1 = require_AbstractTimeExpressionParser();
    var constants_1 = require_constants9();
    var RUTimeExpressionParser = class extends AbstractTimeExpressionParser_1.AbstractTimeExpressionParser {
      constructor(strictMode) {
        super(strictMode);
      }
      patternFlags() {
        return constants_1.REGEX_PARTS.flags;
      }
      primaryPatternLeftBoundary() {
        return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
      }
      followingPhase() {
        return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
      }
      primaryPrefix() {
        return `(?:(?:\u0432|\u0441)\\s*)??`;
      }
      primarySuffix() {
        return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${constants_1.REGEX_PARTS.rightBoundary}`;
      }
      extractPrimaryTimeComponents(context, match) {
        const components = super.extractPrimaryTimeComponents(context, match);
        if (components) {
          if (match[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
            const hour = components.get("hour");
            if (hour >= 6 && hour < 12) {
              components.assign("hour", components.get("hour") + 12);
              components.assign("meridiem", index_1.Meridiem.PM);
            } else if (hour < 6) {
              components.assign("meridiem", index_1.Meridiem.AM);
            }
          }
          if (match[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
            components.assign("meridiem", index_1.Meridiem.PM);
            const hour = components.get("hour");
            if (hour >= 0 && hour <= 6) {
              components.assign("hour", components.get("hour") + 12);
            }
          }
          if (match[0].endsWith("\u0443\u0442\u0440\u0430")) {
            components.assign("meridiem", index_1.Meridiem.AM);
            const hour = components.get("hour");
            if (hour < 12) {
              components.assign("hour", components.get("hour"));
            }
          }
        }
        return components;
      }
    };
    exports.default = RUTimeExpressionParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var require_RUTimeUnitAgoFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitAgoFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(${constants_1.TIME_UNITS_PATTERN})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const timeUnits = constants_1.parseTimeUnits(match[1]);
        const outputTimeUnits = timeunits_1.reverseTimeUnits(timeUnits);
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
      }
    };
    exports.default = RUTimeUnitAgoFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js
var require_RUMergeDateRangeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateRangeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateRangeRefiner_1 = __importDefault(require_AbstractMergeDateRangeRefiner());
    var xf = class extends AbstractMergeDateRangeRefiner_1.default {
      patternBetween() {
        return /^\s*(и до|и по|до|по|-)\s*$/i;
      }
    };
    exports.default = xf;
  }
});

// node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js
var require_RUMergeDateTimeRefiner = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/refiners/RUMergeDateTimeRefiner.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractMergeDateTimeRefiner_1 = __importDefault(require_AbstractMergeDateTimeRefiner());
    var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner_1.default {
      patternBetween() {
        return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
      }
    };
    exports.default = RUMergeDateTimeRefiner;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js
var require_RUCasualDateParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualDateParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualDateParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern(context) {
        return PATTERN;
      }
      innerExtract(context, match) {
        const lowerText = match[1].toLowerCase();
        const component = context.createParsingComponents();
        switch (lowerText) {
          case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
            return references.today(context.reference);
          case "\u0432\u0447\u0435\u0440\u0430":
            return references.yesterday(context.reference);
          case "\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.tomorrow(context.reference);
          case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
            return references.theDayAfter(context.reference, 2);
          case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
            return references.theDayBefore(context.reference, 2);
        }
        return component;
      }
    };
    exports.default = RUCasualDateParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js
var require_RUCasualTimeParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUCasualTimeParser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var references = __importStar(require_casualReferences());
    var dayjs_1 = require_dayjs();
    var dayjs_2 = __importDefault(require_dayjs_min());
    var constants_1 = require_constants9();
    var PATTERN = new RegExp(`(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUCasualTimeParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        let targetDate = dayjs_2.default(context.refDate);
        const lowerText = match[0].toLowerCase();
        const component = context.createParsingComponents();
        if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
          return references.now(context.reference);
        }
        if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
          return references.evening(context.reference);
        }
        if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
          return references.morning(context.reference);
        }
        if (lowerText.match(/в\s*полдень/)) {
          return references.noon(context.reference);
        }
        if (lowerText.match(/прошлой\s*ночью/)) {
          return references.lastNight(context.reference);
        }
        if (lowerText.match(/прошлым\s*вечером/)) {
          return references.yesterdayEvening(context.reference);
        }
        if (lowerText.match(/следующей\s*ночью/)) {
          const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
          targetDate = targetDate.add(daysToAdd, "day");
          dayjs_1.assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
          return references.midnight(context.reference);
        }
        return component;
      }
    };
    exports.default = RUCasualTimeParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js
var require_RUWeekdayParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUWeekdayParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var pattern_1 = require_pattern();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var weeks_1 = require_weeks();
    var PATTERN = new RegExp(`(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var PREFIX_GROUP = 1;
    var WEEKDAY_GROUP = 2;
    var POSTFIX_GROUP = 3;
    var RUWeekdayParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      innerPattern() {
        return PATTERN;
      }
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerExtract(context, match) {
        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();
        const offset = constants_1.WEEKDAY_DICTIONARY[dayOfWeek];
        const prefix = match[PREFIX_GROUP];
        const postfix = match[POSTFIX_GROUP];
        let modifierWord = prefix || postfix;
        modifierWord = modifierWord || "";
        modifierWord = modifierWord.toLowerCase();
        let modifier = null;
        if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          modifier = "last";
        } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
          modifier = "next";
        } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
          modifier = "this";
        }
        const date = weeks_1.toDayJSWeekday(context.refDate, offset, modifier);
        return context.createParsingComponents().assign("weekday", offset).imply("day", date.date()).imply("month", date.month() + 1).imply("year", date.year());
      }
    };
    exports.default = RUWeekdayParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js
var require_RURelativeDateFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RURelativeDateFormatParser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var dayjs_1 = __importDefault(require_dayjs_min());
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var pattern_1 = require_pattern();
    var PATTERN = new RegExp(`(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${pattern_1.matchAnyPattern(constants_1.TIME_UNIT_DICTIONARY)})(?=\\s*)${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var MODIFIER_WORD_GROUP = 1;
    var RELATIVE_WORD_GROUP = 2;
    var RURelativeDateFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
        const timeunit = constants_1.TIME_UNIT_DICTIONARY[unitWord];
        if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
          const timeUnits = {};
          timeUnits[timeunit] = 1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
          const timeUnits = {};
          timeUnits[timeunit] = -1;
          return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
        }
        const components = context.createParsingComponents();
        let date = dayjs_1.default(context.reference.instant);
        if (timeunit.match(/week/i)) {
          date = date.add(-date.get("d"), "d");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.imply("year", date.year());
        } else if (timeunit.match(/month/i)) {
          date = date.add(-date.date() + 1, "d");
          components.imply("day", date.date());
          components.assign("year", date.year());
          components.assign("month", date.month() + 1);
        } else if (timeunit.match(/year/i)) {
          date = date.add(-date.date() + 1, "d");
          date = date.add(-date.month(), "month");
          components.imply("day", date.date());
          components.imply("month", date.month() + 1);
          components.assign("year", date.year());
        }
        return components;
      }
    };
    exports.default = RURelativeDateFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var require_RUTimeUnitCasualRelativeFormatParser = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants9();
    var results_1 = require_results();
    var AbstractParserWithWordBoundary_1 = require_AbstractParserWithWordBoundary();
    var timeunits_1 = require_timeunits();
    var PATTERN = new RegExp(`(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${constants_1.TIME_UNITS_PATTERN})${constants_1.REGEX_PARTS.rightBoundary}`, constants_1.REGEX_PARTS.flags);
    var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking {
      patternLeftBoundary() {
        return constants_1.REGEX_PARTS.leftBoundary;
      }
      innerPattern() {
        return PATTERN;
      }
      innerExtract(context, match) {
        const prefix = match[1].toLowerCase();
        let timeUnits = constants_1.parseTimeUnits(match[2]);
        switch (prefix) {
          case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
          case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
          case "-":
            timeUnits = timeunits_1.reverseTimeUnits(timeUnits);
            break;
        }
        return results_1.ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
      }
    };
    exports.default = RUTimeUnitCasualRelativeFormatParser;
  }
});

// node_modules/chrono-node/dist/locales/ru/index.js
var require_ru = __commonJS({
  "node_modules/chrono-node/dist/locales/ru/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConfiguration = exports.createCasualConfiguration = exports.parseDate = exports.parse = exports.strict = exports.casual = void 0;
    var RUTimeUnitWithinFormatParser_1 = __importDefault(require_RUTimeUnitWithinFormatParser());
    var RUMonthNameLittleEndianParser_1 = __importDefault(require_RUMonthNameLittleEndianParser());
    var RUMonthNameParser_1 = __importDefault(require_RUMonthNameParser());
    var RUTimeExpressionParser_1 = __importDefault(require_RUTimeExpressionParser());
    var RUTimeUnitAgoFormatParser_1 = __importDefault(require_RUTimeUnitAgoFormatParser());
    var RUMergeDateRangeRefiner_1 = __importDefault(require_RUMergeDateRangeRefiner());
    var RUMergeDateTimeRefiner_1 = __importDefault(require_RUMergeDateTimeRefiner());
    var configurations_1 = require_configurations();
    var RUCasualDateParser_1 = __importDefault(require_RUCasualDateParser());
    var RUCasualTimeParser_1 = __importDefault(require_RUCasualTimeParser());
    var RUWeekdayParser_1 = __importDefault(require_RUWeekdayParser());
    var RURelativeDateFormatParser_1 = __importDefault(require_RURelativeDateFormatParser());
    var chrono_1 = require_chrono();
    var SlashDateFormatParser_1 = __importDefault(require_SlashDateFormatParser());
    var RUTimeUnitCasualRelativeFormatParser_1 = __importDefault(require_RUTimeUnitCasualRelativeFormatParser());
    exports.casual = new chrono_1.Chrono(createCasualConfiguration());
    exports.strict = new chrono_1.Chrono(createConfiguration(true));
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
    function createCasualConfiguration() {
      const option = createConfiguration(false);
      option.parsers.unshift(new RUCasualDateParser_1.default());
      option.parsers.unshift(new RUCasualTimeParser_1.default());
      option.parsers.unshift(new RUMonthNameParser_1.default());
      option.parsers.unshift(new RURelativeDateFormatParser_1.default());
      option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser_1.default());
      return option;
    }
    exports.createCasualConfiguration = createCasualConfiguration;
    function createConfiguration(strictMode = true) {
      return configurations_1.includeCommonConfiguration({
        parsers: [
          new SlashDateFormatParser_1.default(true),
          new RUTimeUnitWithinFormatParser_1.default(),
          new RUMonthNameLittleEndianParser_1.default(),
          new RUWeekdayParser_1.default(),
          new RUTimeExpressionParser_1.default(strictMode),
          new RUTimeUnitAgoFormatParser_1.default()
        ],
        refiners: [new RUMergeDateTimeRefiner_1.default(), new RUMergeDateRangeRefiner_1.default()]
      }, strictMode);
    }
    exports.createConfiguration = createConfiguration;
  }
});

// node_modules/chrono-node/dist/index.js
var require_dist = __commonJS({
  "node_modules/chrono-node/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDate = exports.parse = exports.casual = exports.strict = exports.ru = exports.zh = exports.nl = exports.pt = exports.ja = exports.fr = exports.de = exports.Meridiem = exports.Chrono = exports.en = void 0;
    var en = __importStar(require_en());
    exports.en = en;
    var chrono_1 = require_chrono();
    Object.defineProperty(exports, "Chrono", { enumerable: true, get: function() {
      return chrono_1.Chrono;
    } });
    var Meridiem;
    (function(Meridiem2) {
      Meridiem2[Meridiem2["AM"] = 0] = "AM";
      Meridiem2[Meridiem2["PM"] = 1] = "PM";
    })(Meridiem = exports.Meridiem || (exports.Meridiem = {}));
    var de = __importStar(require_de());
    exports.de = de;
    var fr = __importStar(require_fr());
    exports.fr = fr;
    var ja = __importStar(require_ja());
    exports.ja = ja;
    var pt = __importStar(require_pt());
    exports.pt = pt;
    var nl = __importStar(require_nl());
    exports.nl = nl;
    var zh = __importStar(require_zh());
    exports.zh = zh;
    var ru = __importStar(require_ru());
    exports.ru = ru;
    exports.strict = en.strict;
    exports.casual = en.casual;
    function parse4(text2, ref, option) {
      return exports.casual.parse(text2, ref, option);
    }
    exports.parse = parse4;
    function parseDate3(text2, ref, option) {
      return exports.casual.parseDate(text2, ref, option);
    }
    exports.parseDate = parseDate3;
  }
});

// node_modules/mustache-validator/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/mustache-validator/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PathSymbol = Symbol("MustacheDataPath");
    function createPropertyPathArray({ target, propertyName }) {
      return [...target[PathSymbol] || [], propertyName];
    }
    function proxyMustacheData(data, options) {
      if (typeof data !== "object") {
        return data;
      }
      return new Proxy(data, {
        get(target, propertyName) {
          let value = target[propertyName];
          if (value === void 0 && !(propertyName in target)) {
            const pathSegments = createPropertyPathArray({ target, propertyName });
            if (options === null || options === void 0 ? void 0 : options.handleError) {
              options.handleError(pathSegments);
              return value;
            }
            throw Error(`Missing Mustache data property: ${pathSegments.join(" > ")}`);
          }
          if (value && typeof value === "object") {
            value[PathSymbol] = createPropertyPathArray({ target, propertyName });
            return proxyMustacheData(value, options);
          }
          return value;
        }
      });
    }
    exports.default = proxyMustacheData;
  }
});

// node_modules/boon-js/lib/types.js
var require_types = __commonJS({
  "node_modules/boon-js/lib/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Tokens = exports.StructuralCharacters = exports.Operators = void 0;
    var Operators;
    (function(Operators2) {
      Operators2["AND"] = "AND";
      Operators2["OR"] = "OR";
      Operators2["XOR"] = "XOR";
      Operators2["NOT"] = "NOT";
    })(Operators = exports.Operators || (exports.Operators = {}));
    var StructuralCharacters;
    (function(StructuralCharacters2) {
      StructuralCharacters2["OPEN_PARENTHESIS"] = "(";
      StructuralCharacters2["CLOSE_PARENTHESIS"] = ")";
    })(StructuralCharacters = exports.StructuralCharacters || (exports.StructuralCharacters = {}));
    var Tokens;
    (function(Tokens2) {
      Tokens2["IDENTIFIER"] = "IDENTIFIER";
      Tokens2["OPERATOR"] = "OPERATOR";
      Tokens2["STRUCTURAL_CHARACTER"] = "STRUCTURAL_CHARACTER";
      Tokens2["EOF"] = "EOF";
      Tokens2["COMMENT"] = "COMMENT";
    })(Tokens = exports.Tokens || (exports.Tokens = {}));
  }
});

// node_modules/boon-js/lib/parse/const.js
var require_const = __commonJS({
  "node_modules/boon-js/lib/parse/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.VALID_TOKENS = exports.OPERATOR_PRECEDENCE = void 0;
    var types_1 = require_types();
    exports.OPERATOR_PRECEDENCE = {
      NOT: 0,
      XOR: 1,
      AND: 2,
      OR: 3
    };
    exports.VALID_TOKENS = {
      identifierOnly: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        }
      ],
      identifierOrNot: [
        { name: types_1.Tokens.IDENTIFIER },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.OPEN_PARENTHESIS
        },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }
      ],
      binaryOperator: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR }
      ],
      binaryOperatorOrClose: [
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.AND },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.OR },
        { name: types_1.Tokens.OPERATOR, value: types_1.Operators.XOR },
        {
          name: types_1.Tokens.STRUCTURAL_CHARACTER,
          value: types_1.StructuralCharacters.CLOSE_PARENTHESIS
        }
      ]
    };
  }
});

// node_modules/boon-js/lib/lex/const.js
var require_const2 = __commonJS({
  "node_modules/boon-js/lib/lex/const.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.ESCAPE_CHARACTER = exports.EOL = exports.COMMENT_DELIMITER = exports.QUOTED_IDENTIFIER_DELIMITER = exports.SEPARATORS = exports.OPERATORS = exports.STRUCTURAL_CHARACTERS = void 0;
    var types_1 = require_types();
    exports.STRUCTURAL_CHARACTERS = {
      "(": types_1.StructuralCharacters.OPEN_PARENTHESIS,
      ")": types_1.StructuralCharacters.CLOSE_PARENTHESIS
    };
    exports.OPERATORS = {
      AND: types_1.Operators.AND,
      OR: types_1.Operators.OR,
      XOR: types_1.Operators.XOR,
      NOT: types_1.Operators.NOT
    };
    exports.SEPARATORS = new Set([
      32,
      9,
      10,
      13
    ].map(function(separator) {
      return String.fromCodePoint(separator);
    }));
    exports.QUOTED_IDENTIFIER_DELIMITER = String.fromCodePoint(34);
    exports.COMMENT_DELIMITER = String.fromCodePoint(35);
    exports.EOL = String.fromCodePoint(10);
    exports.ESCAPE_CHARACTER = String.fromCodePoint(92);
  }
});

// node_modules/boon-js/lib/lex/utils.js
var require_utils = __commonJS({
  "node_modules/boon-js/lib/lex/utils.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.getQuotedIdentifier = exports.getComment = exports.createResult = void 0;
    var types_1 = require_types();
    var const_1 = require_const2();
    var createResult = function(name, value, remainingString) {
      return {
        token: __assign2({ name }, value !== null ? { value } : {}),
        remainingString
      };
    };
    exports.createResult = createResult;
    var getComment = function(expression) {
      var tokenEnd = expression.length;
      for (var i = 0; i < expression.length; i += 1) {
        var letter = expression[i];
        if (letter === const_1.EOL) {
          tokenEnd = i;
          break;
        }
      }
      return (0, exports.createResult)(types_1.Tokens.COMMENT, expression.slice(0, tokenEnd), expression.slice(tokenEnd + 1));
    };
    exports.getComment = getComment;
    var getQuotedIdentifier = function(expression) {
      var escapeQuotation = false;
      var value = "";
      var tokenEnd = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenEnd === null) {
          if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
            if (escapeQuotation) {
              value = value.slice(-1) + const_1.QUOTED_IDENTIFIER_DELIMITER;
            } else {
              tokenEnd = i;
            }
          } else {
            if (char === const_1.ESCAPE_CHARACTER) {
              escapeQuotation = true;
            } else {
              escapeQuotation = false;
            }
            value = value += char;
          }
        } else {
          if (!const_1.SEPARATORS.has(char) && !const_1.STRUCTURAL_CHARACTERS[char]) {
            throw new Error("Unexpected character: ".concat(char, " Expected ) character or separator"));
          }
          break;
        }
      }
      if (tokenEnd === null) {
        throw new Error("Unexpected end of expression: expected ".concat(const_1.QUOTED_IDENTIFIER_DELIMITER, " character"));
      }
      return (0, exports.createResult)(types_1.Tokens.IDENTIFIER, value, expression.slice(tokenEnd + 1));
    };
    exports.getQuotedIdentifier = getQuotedIdentifier;
  }
});

// node_modules/boon-js/lib/lex/lex.js
var require_lex = __commonJS({
  "node_modules/boon-js/lib/lex/lex.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.lex = void 0;
    var types_1 = require_types();
    var const_1 = require_const2();
    var utils_1 = require_utils();
    var lex = function(expression) {
      var tokenStart = null;
      var tokenEnd = null;
      var delimitingCharacter = null;
      for (var i = 0; i < expression.length; i += 1) {
        var char = expression[i];
        if (tokenStart === null) {
          if (!const_1.SEPARATORS.has(char)) {
            var structuralChar = const_1.STRUCTURAL_CHARACTERS[char];
            if (structuralChar) {
              var nextChar = expression[i + 1];
              if (structuralChar === types_1.StructuralCharacters.CLOSE_PARENTHESIS && nextChar && !const_1.SEPARATORS.has(nextChar) && nextChar !== types_1.StructuralCharacters.CLOSE_PARENTHESIS) {
                throw new Error("Unexpected character: ".concat(nextChar, ". A closing parenthesis should be followed by another closing parenthesis or whitespace"));
              }
              return (0, utils_1.createResult)(types_1.Tokens.STRUCTURAL_CHARACTER, const_1.STRUCTURAL_CHARACTERS[char], expression.slice(i + 1));
            }
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER) {
              return (0, utils_1.getQuotedIdentifier)(expression.slice(i + 1));
            }
            if (char === const_1.COMMENT_DELIMITER) {
              return (0, utils_1.getComment)(expression.slice(i + 1));
            }
            tokenStart = i;
          }
        } else {
          if (const_1.SEPARATORS.has(char) || const_1.STRUCTURAL_CHARACTERS[char]) {
            tokenEnd = i;
            delimitingCharacter = char;
            break;
          } else {
            if (char === const_1.QUOTED_IDENTIFIER_DELIMITER || char === const_1.COMMENT_DELIMITER) {
              throw new Error("Unexpected character: ".concat(char));
            }
          }
        }
      }
      if (tokenStart !== null) {
        tokenEnd = tokenEnd !== null && tokenEnd !== void 0 ? tokenEnd : expression.length;
        var value = expression.slice(tokenStart, tokenEnd);
        var remainingString = expression.slice(tokenEnd);
        if (const_1.OPERATORS[value]) {
          if (delimitingCharacter && !const_1.SEPARATORS.has(delimitingCharacter)) {
            throw new Error("Unexpected character: ".concat(delimitingCharacter, ". Operators should be separated using whitespace"));
          }
          return (0, utils_1.createResult)(types_1.Tokens.OPERATOR, const_1.OPERATORS[value], remainingString);
        } else {
          return (0, utils_1.createResult)(types_1.Tokens.IDENTIFIER, value, remainingString);
        }
      }
      return (0, utils_1.createResult)(types_1.Tokens.EOF, null, "");
    };
    exports.lex = lex;
  }
});

// node_modules/boon-js/lib/parse/utils.js
var require_utils2 = __commonJS({
  "node_modules/boon-js/lib/parse/utils.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.validateToken = exports.previousOperatorTakesPrecedent = exports.getValue = exports.newTokenGenerator = void 0;
    var lex_1 = require_lex();
    var types_1 = require_types();
    var const_1 = require_const();
    var newTokenGenerator = function(expression) {
      var remainingExpression = expression;
      return function(validTokens, endIsValid) {
        if (endIsValid === void 0) {
          endIsValid = false;
        }
        while (true) {
          var _a = (0, lex_1.lex)(remainingExpression), token = _a.token, remainingString = _a.remainingString;
          remainingExpression = remainingString;
          if (token.name !== types_1.Tokens.COMMENT) {
            (0, exports.validateToken)(token, validTokens, endIsValid);
            return token;
          }
        }
      };
    };
    exports.newTokenGenerator = newTokenGenerator;
    var getValue = function(getNextToken, parser) {
      var nextToken = getNextToken(const_1.VALID_TOKENS.identifierOrNot);
      var negatedValue = nextToken.value === types_1.Operators.NOT;
      if (negatedValue) {
        nextToken = getNextToken(const_1.VALID_TOKENS.identifierOnly);
      }
      var value = nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER ? parser(getNextToken, true) : [nextToken];
      return negatedValue ? __spreadArray2(__spreadArray2([], value, true), [{ name: types_1.Tokens.OPERATOR, value: types_1.Operators.NOT }], false) : value;
    };
    exports.getValue = getValue;
    var previousOperatorTakesPrecedent = function(previousOperator, nextOperator) {
      return const_1.OPERATOR_PRECEDENCE[previousOperator] <= const_1.OPERATOR_PRECEDENCE[nextOperator];
    };
    exports.previousOperatorTakesPrecedent = previousOperatorTakesPrecedent;
    var validateToken = function(token, validTokens, endIsValid) {
      if (endIsValid === void 0) {
        endIsValid = false;
      }
      if (token.name === types_1.Tokens.EOF) {
        if (endIsValid) {
          return;
        }
        throw new Error("Unexpected end of expression");
      }
      for (var _i = 0, validTokens_1 = validTokens; _i < validTokens_1.length; _i++) {
        var validToken = validTokens_1[_i];
        if (validToken.name === token.name) {
          if (!validToken.value || validToken.value === token.value) {
            return;
          }
        }
      }
      throw new TypeError("Invalid token");
    };
    exports.validateToken = validateToken;
  }
});

// node_modules/boon-js/lib/parse/parse.js
var require_parse = __commonJS({
  "node_modules/boon-js/lib/parse/parse.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.parse = void 0;
    var types_1 = require_types();
    var const_1 = require_const();
    var utils_1 = require_utils2();
    var parse4 = function(expression) {
      if (typeof expression !== "string") {
        throw new Error("Expected string but received ".concat(typeof expression));
      }
      var getNextToken = (0, utils_1.newTokenGenerator)(expression);
      return parseInternal(getNextToken);
    };
    exports.parse = parse4;
    var parseInternal = function(getNextToken, nested) {
      if (nested === void 0) {
        nested = false;
      }
      var output = __spreadArray2([], (0, utils_1.getValue)(getNextToken, parseInternal), true);
      var operators = [];
      while (true) {
        var validTokens = nested ? const_1.VALID_TOKENS.binaryOperatorOrClose : const_1.VALID_TOKENS.binaryOperator;
        var nextToken = getNextToken(validTokens, !nested);
        if (nextToken.name === types_1.Tokens.EOF || nextToken.name === types_1.Tokens.STRUCTURAL_CHARACTER) {
          return __spreadArray2(__spreadArray2([], output, true), __spreadArray2([], operators, true).reverse(), true);
        }
        while (operators.length) {
          var previousOperator = operators[operators.length - 1] || null;
          if (previousOperator && (0, utils_1.previousOperatorTakesPrecedent)(previousOperator.value, nextToken.value)) {
            output = __spreadArray2(__spreadArray2([], output, true), [previousOperator], false);
            operators = operators.slice(0, -1);
          } else {
            break;
          }
        }
        operators = __spreadArray2(__spreadArray2([], operators, true), [nextToken], false);
        output = __spreadArray2(__spreadArray2([], output, true), (0, utils_1.getValue)(getNextToken, parseInternal), true);
      }
    };
  }
});

// node_modules/boon-js/lib/evaluate/utils.js
var require_utils3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.throwInvalidExpression = exports.isOperator = exports.isIdentifier = exports.notUtil = exports.xorUtil = exports.orUtil = exports.andUtil = void 0;
    var types_1 = require_types();
    var andUtil = function(left, right) {
      return left && right;
    };
    exports.andUtil = andUtil;
    var orUtil = function(left, right) {
      return left || right;
    };
    exports.orUtil = orUtil;
    var xorUtil = function(left, right) {
      return !(left === right);
    };
    exports.xorUtil = xorUtil;
    var notUtil = function(identifier) {
      return !identifier;
    };
    exports.notUtil = notUtil;
    var isIdentifier = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.IDENTIFIER && typeof value === "string";
    };
    exports.isIdentifier = isIdentifier;
    var isOperator = function(_a) {
      var name = _a.name, value = _a.value;
      return name === types_1.Tokens.OPERATOR && typeof value === "string";
    };
    exports.isOperator = isOperator;
    var throwInvalidExpression = function(message) {
      throw new TypeError("Invalid postfix expression: ".concat(message));
    };
    exports.throwInvalidExpression = throwInvalidExpression;
  }
});

// node_modules/boon-js/lib/evaluate/const.js
var require_const3 = __commonJS({
  "node_modules/boon-js/lib/evaluate/const.js"(exports) {
    "use strict";
    var _a;
    exports.__esModule = true;
    exports.OPERATOR_MAP = void 0;
    var types_1 = require_types();
    var utils_1 = require_utils3();
    exports.OPERATOR_MAP = (_a = {}, _a[types_1.Operators.AND] = utils_1.andUtil, _a[types_1.Operators.OR] = utils_1.orUtil, _a[types_1.Operators.XOR] = utils_1.xorUtil, _a);
  }
});

// node_modules/boon-js/lib/evaluate/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/boon-js/lib/evaluate/evaluate.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.evaluate = exports.getEvaluator = void 0;
    var parse_1 = require_parse();
    var types_1 = require_types();
    var const_1 = require_const3();
    var utils_1 = require_utils3();
    var getEvaluator = function(expression) {
      var parsedExpression = (0, parse_1.parse)(expression);
      return function(booleanMap) {
        return (0, exports.evaluate)(parsedExpression, booleanMap);
      };
    };
    exports.getEvaluator = getEvaluator;
    var evaluate = function(expression, booleanMap) {
      if (!Array.isArray(expression)) {
        throw new Error("".concat(expression, " should be an array. evaluate takes in a parsed expression. Use in combination with parse or use getEvaluator"));
      }
      var evaluatedExpression = expression.reduce(function(stack, token, i) {
        if (!(token && ((0, utils_1.isIdentifier)(token) || (0, utils_1.isOperator)(token)))) {
          throw new Error("Invalid token: ".concat(token, ". Found in parsed expression at index ").concat(i));
        }
        if (token.name === types_1.Tokens.IDENTIFIER) {
          return __spreadArray2(__spreadArray2([], stack, true), [Boolean(booleanMap[token.value])], false);
        }
        var secondLastItem = stack[stack.length - 2];
        var lastItem = stack[stack.length - 1];
        if (token.value === types_1.Operators.NOT) {
          if (lastItem === void 0) {
            (0, utils_1.throwInvalidExpression)("missing identifier");
          }
          return __spreadArray2(__spreadArray2([], stack.slice(0, -1), true), [(0, utils_1.notUtil)(lastItem)], false);
        }
        if (lastItem === void 0 || secondLastItem === void 0) {
          (0, utils_1.throwInvalidExpression)("missing identifier");
        }
        var operatorUtil = const_1.OPERATOR_MAP[token.value];
        if (!operatorUtil) {
          (0, utils_1.throwInvalidExpression)("unknown operator");
        }
        return __spreadArray2(__spreadArray2([], stack.slice(0, -2), true), [operatorUtil(secondLastItem, lastItem)], false);
      }, []);
      if (evaluatedExpression.length !== 1) {
        (0, utils_1.throwInvalidExpression)("too many identifiers after evaluation");
      }
      return evaluatedExpression[0];
    };
    exports.evaluate = evaluate;
  }
});

// node_modules/boon-js/lib/index.js
var require_lib = __commonJS({
  "node_modules/boon-js/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    exports.__esModule = true;
    exports.parse = exports.evaluate = exports.getEvaluator = void 0;
    var evaluate_1 = require_evaluate();
    __createBinding(exports, evaluate_1, "getEvaluator");
    __createBinding(exports, evaluate_1, "evaluate");
    var parse_1 = require_parse();
    __createBinding(exports, parse_1, "parse");
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray3 = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init2() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a, b, c) {
        var n = arguments.length;
        switch (n) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b];
          case 3:
            return [a, b, c];
          default:
            var arr = new Array(n);
            while (n--) {
              arr[n] = arguments[n];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = i < valuesCount ? values[i] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
          on = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on = target.on;
          off = target.off;
        }
        if (!on && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i = events.length;
            while (i-- > 0) {
              event = events[i];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i = 0; i < length; i++) {
          option = keys[i];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value = options[option];
          if (value !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value, reject) : value;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v, reject) {
            if (typeof v === firstType) {
              return v;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType)
              return v;
            reject(message);
          };
        }
        return function(v, reject) {
          var kind = typeof v;
          var i = len;
          while (i-- > 0) {
            if (kind === types[i])
              return v;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value, reject2) {
              value *= 1;
              if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                reject2("timeout must be a positive number");
              }
              return value;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value) {
            cleanup();
            resolve(value);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i = 1; i < length; i++) {
              callbacks[i](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i = 0; i < len; i++) {
          if (observers[i]._target === observer)
            return i;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) {
          return null;
        }
        if (i === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l++] = type.slice(j, n);
                j = n + dl;
              } while ((n = type.indexOf(delimiter, j)) !== -1);
              ns[l++] = type.slice(j);
              type = ns;
              typeLength = l;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j, i);
              j = i + dl;
            } while ((i = type.indexOf(delimiter, j)) !== -1);
            ns[len++] = type.slice(j);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i = 0; i + 1 < len; i++) {
            if (ns[i] === "**" && ns[i + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i = 0; i < len; i++) {
          name = ns[i];
          tree = tree[name] || (tree[name] = {});
          if (i === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i-- > 0) {
          branchName = branches[i];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while (i-- > 0) {
          key = keys[i];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen2(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i = 0; i < len; i++) {
            event = keys[i];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray3(events) ? listen2(toObject(events)) : typeof events === "string" ? listen2(toObject(events.split(/\s+/))) : listen2(events);
        return this;
      };
      EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i-- > 0) {
          observer = observers[i];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn, options) {
        return this._once(event, fn, false, options);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
        return this._once(event, fn, true, options);
      };
      EventEmitter.prototype._once = function(event, fn, prepend, options) {
        return this._many(event, 1, fn, prepend, options);
      };
      EventEmitter.prototype.many = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, false, options);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, true, options);
      };
      EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
        var self2 = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init2.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init2.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray3(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init2.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
          if (!leafs)
            return this;
          for (i = 0; i < leafs.length; i++) {
            leaf = leafs[i];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i = keys.length;
          allListeners = [];
          while (i-- > 0) {
            listeners = _events[keys[i]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter.prototype;
      Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n) {
            if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module2.exports = EventEmitter;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TasksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/Cache.ts
var import_obsidian = require("obsidian");

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._weightedQueues = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      if (!this._weightedQueues[weight - 1])
        this._weightedQueues[weight - 1] = [];
      this._weightedQueues[weight - 1].push({ resolve, reject });
      this._dispatch();
    });
  }
  runExclusive(callback, weight = 1) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire(weight);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve) => {
      if (!this._weightedWaiters[weight - 1])
        this._weightedWaiters[weight - 1] = [];
      this._weightedWaiters[weight - 1].push(resolve);
      this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatch();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));
    this._weightedQueues = [];
  }
  _dispatch() {
    var _a;
    for (let weight = this._value; weight > 0; weight--) {
      const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
      if (!queueEntry)
        continue;
      const previousValue = this._value;
      const previousWeight = weight;
      this._value -= weight;
      weight = this._value + 1;
      queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    for (let weight = this._value; weight > 0; weight--) {
      if (!this._weightedWaiters[weight - 1])
        continue;
      this._weightedWaiters[weight - 1].forEach((waiter) => waiter());
      this._weightedWaiters[weight - 1] = [];
    }
  }
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/Query/DateParser.ts
var chrono = __toESM(require_dist());

// src/Query/DateRange.ts
var DateRange = class {
  constructor(start, end) {
    this.start = start;
    this.end = end;
    if (end.isBefore(start)) {
      this.start = end;
      this.end = start;
    }
    this.start = this.start.startOf("day");
    this.end = this.end.startOf("day");
  }
  static buildRelative(range2) {
    const unitOfTime = range2 === "week" ? "isoWeek" : range2;
    return new DateRange(
      window.moment().startOf(unitOfTime).startOf("day"),
      window.moment().endOf(unitOfTime).startOf("day")
    );
  }
  static buildInvalid() {
    return new DateRange(window.moment.invalid(), window.moment.invalid());
  }
  isValid() {
    return this.start.isValid() && this.end.isValid();
  }
  moveToPrevious(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.subtract(delta);
    this.end.subtract(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
  moveToNext(duration) {
    const delta = window.moment.duration(1, duration);
    this.start.add(delta);
    this.end.add(delta);
    if (duration === "month" || duration === "quarter") {
      this.end = this.end.endOf(duration).startOf("day");
    }
  }
};

// src/Query/DateParser.ts
var DateParser = class {
  static parseDate(input, forwardDate = false) {
    return window.moment(
      chrono.parseDate(input, void 0, {
        forwardDate
      })
    ).startOf("day");
  }
  static parseDateRange(input, forwardDate = false) {
    const dateRangeParsers = [
      DateParser.parseRelativeDateRange,
      DateParser.parseNumberedDateRange,
      DateParser.parseAbsoluteDateRange
    ];
    for (const parser of dateRangeParsers) {
      const parsedDateRange = parser(input, forwardDate);
      if (parsedDateRange.isValid()) {
        return parsedDateRange;
      }
    }
    return DateRange.buildInvalid();
  }
  static parseAbsoluteDateRange(input, forwardDate) {
    const result = chrono.parse(input, void 0, {
      forwardDate
    });
    if (result.length === 0) {
      return DateRange.buildInvalid();
    }
    const startDate = result[0].start;
    const endDate = result[1] && result[1].start ? result[1].start : startDate;
    const start = window.moment(startDate.date());
    const end = window.moment(endDate.date());
    return new DateRange(start, end);
  }
  static parseRelativeDateRange(input, _forwardDate) {
    const relativeDateRangeRegexp = /(last|this|next) (week|month|quarter|year)/;
    const relativeDateRangeMatch = input.match(relativeDateRangeRegexp);
    if (relativeDateRangeMatch && relativeDateRangeMatch.length === 3) {
      const lastThisNext = relativeDateRangeMatch[1];
      const range2 = relativeDateRangeMatch[2];
      const dateRange = DateRange.buildRelative(range2);
      switch (lastThisNext) {
        case "last":
          dateRange.moveToPrevious(range2);
          break;
        case "next":
          dateRange.moveToNext(range2);
          break;
      }
      return dateRange;
    }
    return DateRange.buildInvalid();
  }
  static parseNumberedDateRange(input, _forwardDate) {
    const parsingVectors = [
      [/^\s*[0-9]{4}\s*$/, "YYYY", "year"],
      [/^\s*[0-9]{4}-Q[1-4]\s*$/, "YYYY-Q", "quarter"],
      [/^\s*[0-9]{4}-[0-9]{2}\s*$/, "YYYY-MM", "month"],
      [/^\s*[0-9]{4}-W[0-9]{2}\s*$/, "YYYY-WW", "isoWeek"]
    ];
    for (const [regexp, dateFormat, range2] of parsingVectors) {
      const matched = input.match(regexp);
      if (matched) {
        const date = matched[0].trim();
        return new DateRange(
          window.moment(date, dateFormat).startOf(range2),
          window.moment(date, dateFormat).endOf(range2)
        );
      }
    }
    return DateRange.buildInvalid();
  }
};

// src/DateAbbreviations.ts
var abbreviations = {
  td: "today",
  tm: "tomorrow",
  yd: "yesterday",
  tw: "this week",
  nw: "next week",
  weekend: "sat",
  we: "sat"
};
function doAutocomplete(date) {
  for (const [key, val] of Object.entries(abbreviations)) {
    date = date.replace(RegExp(`\\b${key}\\s`, "i"), val);
  }
  return date;
}

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = function() {
  function Weekday2(weekday, n) {
    if (n === 0)
      throw new Error("Can't create weekday with n == 0");
    this.weekday = weekday;
    this.n = n;
  }
  Weekday2.fromStr = function(str) {
    return new Weekday2(ALL_WEEKDAYS.indexOf(str));
  };
  Weekday2.prototype.nth = function(n) {
    return this.n === n ? this : new Weekday2(this.weekday, n);
  };
  Weekday2.prototype.equals = function(other) {
    return this.weekday === other.weekday && this.n === other.n;
  };
  Weekday2.prototype.toString = function() {
    var s = ALL_WEEKDAYS[this.weekday];
    if (this.n)
      s = (this.n > 0 ? "+" : "") + String(this.n) + s;
    return s;
  };
  Weekday2.prototype.getJsWeekday = function() {
    return this.weekday === 6 ? 0 : this.weekday + 1;
  };
  return Weekday2;
}();

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i = start; i < end; i++)
    rang.push(i);
  return rang;
};
var repeat = function(value, times) {
  var i = 0;
  var array = [];
  if (isArray(value)) {
    for (; i < times; i++)
      array[i] = [].concat(value);
  } else {
    for (; i < times; i++)
      array[i] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
var divmod = function(a, b) {
  return { div: Math.floor(a / b), mod: pymod(a, b) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y, m, d, h, i, s) {
  if (h === void 0) {
    h = 0;
  }
  if (i === void 0) {
    i = 0;
  }
  if (s === void 0) {
    s = 0;
  }
  return new Date(Date.UTC(y, m - 1, d, h, i, s));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var tzOffset = function(date) {
  return date.getTimezoneOffset() * 60 * 1e3;
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime() - tzOffset(date1);
  var date2ms = date2.getTime() - tzOffset(date2);
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i = 0; i < dates.length; i++) {
    clones.push(clone(dates[i]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart(date.getUTCFullYear().toString(), 4, "0"),
    padStart(date.getUTCMonth() + 1, 2, "0"),
    padStart(date.getUTCDate(), 2, "0"),
    "T",
    padStart(date.getUTCHours(), 2, "0"),
    padStart(date.getUTCMinutes(), 2, "0"),
    padStart(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset2 = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset2);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = function() {
  function IterResult2(method, args) {
    this.minDate = null;
    this.maxDate = null;
    this._result = [];
    this.total = 0;
    this.method = method;
    this.args = args;
    if (method === "between") {
      this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
      this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
    } else if (method === "before") {
      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
    } else if (method === "after") {
      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
    }
  }
  IterResult2.prototype.accept = function(date) {
    ++this.total;
    var tooEarly = this.minDate && date < this.minDate;
    var tooLate = this.maxDate && date > this.maxDate;
    if (this.method === "between") {
      if (tooEarly)
        return true;
      if (tooLate)
        return false;
    } else if (this.method === "before") {
      if (tooLate)
        return false;
    } else if (this.method === "after") {
      if (tooEarly)
        return true;
      this.add(date);
      return false;
    }
    return this.add(date);
  };
  IterResult2.prototype.add = function(date) {
    this._result.push(date);
    return true;
  };
  IterResult2.prototype.getValue = function() {
    var res = this._result;
    switch (this.method) {
      case "all":
      case "between":
        return res;
      case "before":
      case "after":
      default:
        return res.length ? res[res.length - 1] : null;
    }
  };
  IterResult2.prototype.clone = function() {
    return new IterResult2(this.method, this.args);
  };
  return IterResult2;
}();
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = function(_super) {
  __extends(CallbackIterResult2, _super);
  function CallbackIterResult2(method, args, iterator) {
    var _this = _super.call(this, method, args) || this;
    _this.iterator = iterator;
    return _this;
  }
  CallbackIterResult2.prototype.add = function(date) {
    if (this.iterator(date, this._result.length)) {
      this._result.push(date);
      return true;
    }
    return false;
  };
  return CallbackIterResult2;
}(iterresult_default);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = function() {
  function ToText2(rrule, gettext, language, dateFormatter) {
    if (gettext === void 0) {
      gettext = defaultGetText;
    }
    if (language === void 0) {
      language = i18n_default;
    }
    if (dateFormatter === void 0) {
      dateFormatter = defaultDateFormatter;
    }
    this.text = [];
    this.language = language || i18n_default;
    this.gettext = gettext;
    this.dateFormatter = dateFormatter;
    this.rrule = rrule;
    this.options = rrule.options;
    this.origOptions = rrule.origOptions;
    if (this.origOptions.bymonthday) {
      var bymonthday = [].concat(this.options.bymonthday);
      var bynmonthday = [].concat(this.options.bynmonthday);
      bymonthday.sort(function(a, b) {
        return a - b;
      });
      bynmonthday.sort(function(a, b) {
        return b - a;
      });
      this.bymonthday = bymonthday.concat(bynmonthday);
      if (!this.bymonthday.length)
        this.bymonthday = null;
    }
    if (isPresent(this.origOptions.byweekday)) {
      var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
      var days = String(byweekday);
      this.byweekday = {
        allWeeks: byweekday.filter(function(weekday) {
          return !weekday.n;
        }),
        someWeeks: byweekday.filter(function(weekday) {
          return Boolean(weekday.n);
        }),
        isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
        isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
      };
      var sortWeekDays = function(a, b) {
        return a.weekday - b.weekday;
      };
      this.byweekday.allWeeks.sort(sortWeekDays);
      this.byweekday.someWeeks.sort(sortWeekDays);
      if (!this.byweekday.allWeeks.length)
        this.byweekday.allWeeks = null;
      if (!this.byweekday.someWeeks.length)
        this.byweekday.someWeeks = null;
    } else {
      this.byweekday = null;
    }
  }
  ToText2.isFullyConvertible = function(rrule) {
    var canConvert = true;
    if (!(rrule.options.freq in ToText2.IMPLEMENTED))
      return false;
    if (rrule.origOptions.until && rrule.origOptions.count)
      return false;
    for (var key in rrule.origOptions) {
      if (contains(["dtstart", "wkst", "freq"], key))
        return true;
      if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
        return false;
    }
    return canConvert;
  };
  ToText2.prototype.isFullyConvertible = function() {
    return ToText2.isFullyConvertible(this.rrule);
  };
  ToText2.prototype.toString = function() {
    var gettext = this.gettext;
    if (!(this.options.freq in ToText2.IMPLEMENTED)) {
      return gettext("RRule error: Unable to fully convert this rrule to text");
    }
    this.text = [gettext("every")];
    this[RRule.FREQUENCIES[this.options.freq]]();
    if (this.options.until) {
      this.add(gettext("until"));
      var until = this.options.until;
      this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
    } else if (this.options.count) {
      this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
    }
    if (!this.isFullyConvertible())
      this.add(gettext("(~ approximate)"));
    return this.text.join("");
  };
  ToText2.prototype.HOURLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
  };
  ToText2.prototype.MINUTELY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
  };
  ToText2.prototype.DAILY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1)
      this.add(this.options.interval.toString());
    if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
    } else {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    }
    if (this.origOptions.bymonth) {
      this.add(gettext("in"));
      this._bymonth();
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };
  ToText2.prototype.WEEKLY = function() {
    var gettext = this.gettext;
    if (this.options.interval !== 1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
    }
    if (this.byweekday && this.byweekday.isWeekdays) {
      if (this.options.interval === 1) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(gettext("on")).add(gettext("weekdays"));
      }
    } else if (this.byweekday && this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
    } else {
      if (this.options.interval === 1)
        this.add(gettext("week"));
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
    }
  };
  ToText2.prototype.MONTHLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(gettext("months"));
        if (this.plural(this.options.interval))
          this.add(gettext("in"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday && this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(gettext("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };
  ToText2.prototype.YEARLY = function() {
    var gettext = this.gettext;
    if (this.origOptions.bymonth) {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
        this.add(gettext("years"));
      } else {
      }
      this._bymonth();
    } else {
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString());
      }
      this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
    }
    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }
    if (this.options.byyearday) {
      this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
    }
    if (this.options.byweekno) {
      this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
    }
  };
  ToText2.prototype._bymonthday = function() {
    var gettext = this.gettext;
    if (this.byweekday && this.byweekday.allWeeks) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
    } else {
      this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
    }
  };
  ToText2.prototype._byweekday = function() {
    var gettext = this.gettext;
    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
      this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
    }
    if (this.byweekday.someWeeks) {
      if (this.byweekday.allWeeks)
        this.add(gettext("and"));
      this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
    }
  };
  ToText2.prototype._byhour = function() {
    var gettext = this.gettext;
    this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
  };
  ToText2.prototype._bymonth = function() {
    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
  };
  ToText2.prototype.nth = function(n) {
    n = parseInt(n.toString(), 10);
    var nth;
    var gettext = this.gettext;
    if (n === -1)
      return gettext("last");
    var npos = Math.abs(n);
    switch (npos) {
      case 1:
      case 21:
      case 31:
        nth = npos + gettext("st");
        break;
      case 2:
      case 22:
        nth = npos + gettext("nd");
        break;
      case 3:
      case 23:
        nth = npos + gettext("rd");
        break;
      default:
        nth = npos + gettext("th");
    }
    return n < 0 ? nth + " " + gettext("last") : nth;
  };
  ToText2.prototype.monthtext = function(m) {
    return this.language.monthNames[m - 1];
  };
  ToText2.prototype.weekdaytext = function(wday) {
    var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
    return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
  };
  ToText2.prototype.plural = function(n) {
    return n % 100 !== 1;
  };
  ToText2.prototype.add = function(s) {
    this.text.push(" ");
    this.text.push(s);
    return this;
  };
  ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
    var _this = this;
    if (delim === void 0) {
      delim = ",";
    }
    if (!isArray(arr)) {
      arr = [arr];
    }
    var delimJoin = function(array, delimiter, finalDelimiter) {
      var list = "";
      for (var i = 0; i < array.length; i++) {
        if (i !== 0) {
          if (i === array.length - 1) {
            list += " " + finalDelimiter + " ";
          } else {
            list += delimiter + " ";
          }
        }
        list += array[i];
      }
      return list;
    };
    callback = callback || function(o) {
      return o.toString();
    };
    var realCallback = function(arg) {
      return callback && callback.call(_this, arg);
    };
    if (finalDelim) {
      return delimJoin(arr.map(realCallback), delim, finalDelim);
    } else {
      return arr.map(realCallback).join(delim + " ");
    }
  };
  return ToText2;
}();
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = function() {
  function Parser2(rules) {
    this.done = true;
    this.rules = rules;
  }
  Parser2.prototype.start = function(text2) {
    this.text = text2;
    this.done = false;
    return this.nextSymbol();
  };
  Parser2.prototype.isDone = function() {
    return this.done && this.symbol === null;
  };
  Parser2.prototype.nextSymbol = function() {
    var best;
    var bestSymbol;
    this.symbol = null;
    this.value = null;
    do {
      if (this.done)
        return false;
      var rule = void 0;
      best = null;
      for (var name_1 in this.rules) {
        rule = this.rules[name_1];
        var match = rule.exec(this.text);
        if (match) {
          if (best === null || match[0].length > best[0].length) {
            best = match;
            bestSymbol = name_1;
          }
        }
      }
      if (best != null) {
        this.text = this.text.substr(best[0].length);
        if (this.text === "")
          this.done = true;
      }
      if (best == null) {
        this.done = true;
        this.symbol = null;
        this.value = null;
        return;
      }
    } while (bestSymbol === "SKIP");
    this.symbol = bestSymbol;
    this.value = best;
    return true;
  };
  Parser2.prototype.accept = function(name) {
    if (this.symbol === name) {
      if (this.value) {
        var v = this.value;
        this.nextSymbol();
        return v;
      }
      this.nextSymbol();
      return true;
    }
    return false;
  };
  Parser2.prototype.acceptNumber = function() {
    return this.accept("number");
  };
  Parser2.prototype.expect = function(name) {
    if (this.accept(name))
      return true;
    throw new Error("expected " + name + " but found " + this.symbol);
  };
  return Parser2;
}();
function parseText(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text2))
    return null;
  S();
  return options;
  function S() {
    ttr.expect("every");
    var n = ttr.acceptNumber();
    if (n)
      options.interval = parseInt(n[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        F();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        MDAYs();
        F();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m = decodeM();
          if (!m) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m);
          ttr.nextSymbol();
        }
        ON();
        F();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n[0], 10)];
        while (ttr.accept("comma")) {
          n = ttr.acceptNumber();
          if (!n) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n[0], 10));
        }
      } else if (m) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n = ttr.acceptNumber();
      if (!n) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n[0], 10)];
      while (ttr.accept("comma")) {
        n = ttr.acceptNumber();
        if (!n) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v = parseInt(ttr.value[1], 10);
        if (v < -366 || v > 366)
          throw new Error("Nth out of range: " + v);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v : v;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text2, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text2, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = function() {
  function Time2(hour, minute, second, millisecond) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond || 0;
  }
  Time2.prototype.getHours = function() {
    return this.hour;
  };
  Time2.prototype.getMinutes = function() {
    return this.minute;
  };
  Time2.prototype.getSeconds = function() {
    return this.second;
  };
  Time2.prototype.getMilliseconds = function() {
    return this.millisecond;
  };
  Time2.prototype.getTime = function() {
    return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
  };
  return Time2;
}();
var DateTime = function(_super) {
  __extends(DateTime2, _super);
  function DateTime2(year, month, day, hour, minute, second, millisecond) {
    var _this = _super.call(this, hour, minute, second, millisecond) || this;
    _this.year = year;
    _this.month = month;
    _this.day = day;
    return _this;
  }
  DateTime2.fromDate = function(date) {
    return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
  };
  DateTime2.prototype.getWeekday = function() {
    return getWeekday(new Date(this.getTime()));
  };
  DateTime2.prototype.getTime = function() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
  };
  DateTime2.prototype.getDay = function() {
    return this.day;
  };
  DateTime2.prototype.getMonth = function() {
    return this.month;
  };
  DateTime2.prototype.getYear = function() {
    return this.year;
  };
  DateTime2.prototype.addYears = function(years) {
    this.year += years;
  };
  DateTime2.prototype.addMonths = function(months) {
    this.month += months;
    if (this.month > 12) {
      var yearDiv = Math.floor(this.month / 12);
      var monthMod = pymod(this.month, 12);
      this.month = monthMod;
      this.year += yearDiv;
      if (this.month === 0) {
        this.month = 12;
        --this.year;
      }
    }
  };
  DateTime2.prototype.addWeekly = function(days, wkst) {
    if (wkst > this.getWeekday()) {
      this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
    } else {
      this.day += -(this.getWeekday() - wkst) + days * 7;
    }
    this.fixDay();
  };
  DateTime2.prototype.addDaily = function(days) {
    this.day += days;
    this.fixDay();
  };
  DateTime2.prototype.addHours = function(hours, filtered, byhour) {
    if (filtered) {
      this.hour += Math.floor((23 - this.hour) / hours) * hours;
    }
    for (; ; ) {
      this.hour += hours;
      var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
      if (dayDiv) {
        this.hour = hourMod;
        this.addDaily(dayDiv);
      }
      if (empty(byhour) || includes(byhour, this.hour))
        break;
    }
  };
  DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
    if (filtered) {
      this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
    }
    for (; ; ) {
      this.minute += minutes;
      var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
      if (hourDiv) {
        this.minute = minuteMod;
        this.addHours(hourDiv, false, byhour);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
        break;
      }
    }
  };
  DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
    if (filtered) {
      this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
    }
    for (; ; ) {
      this.second += seconds;
      var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
      if (minuteDiv) {
        this.second = secondMod;
        this.addMinutes(minuteDiv, false, byhour, byminute);
      }
      if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
        break;
      }
    }
  };
  DateTime2.prototype.fixDay = function() {
    if (this.day <= 28) {
      return;
    }
    var daysinmonth = monthRange(this.year, this.month - 1)[1];
    if (this.day <= daysinmonth) {
      return;
    }
    while (this.day > daysinmonth) {
      this.day -= daysinmonth;
      ++this.month;
      if (this.month === 13) {
        this.month = 1;
        ++this.year;
        if (this.year > MAXYEAR) {
          return;
        }
      }
      daysinmonth = monthRange(this.year, this.month - 1)[1];
    }
  };
  DateTime2.prototype.add = function(options, filtered) {
    var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
    switch (freq) {
      case Frequency.YEARLY:
        return this.addYears(interval);
      case Frequency.MONTHLY:
        return this.addMonths(interval);
      case Frequency.WEEKLY:
        return this.addWeekly(interval, wkst);
      case Frequency.DAILY:
        return this.addDaily(interval);
      case Frequency.HOURLY:
        return this.addHours(interval, filtered, byhour);
      case Frequency.MINUTELY:
        return this.addMinutes(interval, filtered, byhour, byminute);
      case Frequency.SECONDLY:
        return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
    }
  };
  return DateTime2;
}(Time);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i = 0; i < opts.bysetpos.length; i++) {
      var v = opts.bysetpos[i];
      if (v === 0 || !(v >= -366 && v <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i = 0; i < opts.bymonthday.length; i++) {
      var v = opts.bymonthday[i];
      if (v > 0) {
        bymonthday.push(v);
      } else if (v < 0) {
        bynmonthday.push(v);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i = 0; i < opts.byweekday.length; i++) {
      var wday = opts.byweekday[i];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x) {
    return x !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr2) {
    var _a = attr2.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = function() {
  function DateWithZone2(date, tzid) {
    if (isNaN(date.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date = date;
    this.tzid = tzid;
  }
  Object.defineProperty(DateWithZone2.prototype, "isUTC", {
    get: function() {
      return !this.tzid || this.tzid.toUpperCase() === "UTC";
    },
    enumerable: false,
    configurable: true
  });
  DateWithZone2.prototype.toString = function() {
    var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
    if (!this.isUTC) {
      return ";TZID=".concat(this.tzid, ":").concat(datestr);
    }
    return ":".concat(datestr);
  };
  DateWithZone2.prototype.getTime = function() {
    return this.date.getTime();
  };
  DateWithZone2.prototype.rezonedDate = function() {
    if (this.isUTC) {
      return this.date;
    }
    return dateInTimeZone(this.date, this.tzid);
  };
  return DateWithZone2;
}();

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i = 0; i < keys.length; i++) {
    if (keys[i] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i]))
      continue;
    var key = keys[i].toUpperCase();
    var value = options[keys[i]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j = 0; j < value.length; j++) {
            strValues[j] = String(value[j]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x) {
    return !!x;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i) {
      return date.getTime() === right[i].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = function() {
  function Cache3() {
    this.all = false;
    this.before = [];
    this.after = [];
    this.between = [];
  }
  Cache3.prototype._cacheAdd = function(what, value, args) {
    if (value) {
      value = value instanceof Date ? clone(value) : cloneDates(value);
    }
    if (what === "all") {
      this.all = value;
    } else {
      args._value = value;
      this[what].push(args);
    }
  };
  Cache3.prototype._cacheGet = function(what, args) {
    var cached = false;
    var argsKeys = args ? Object.keys(args) : [];
    var findCacheDiff = function(item2) {
      for (var i2 = 0; i2 < argsKeys.length; i2++) {
        var key = argsKeys[i2];
        if (!argsMatch(args[key], item2[key])) {
          return true;
        }
      }
      return false;
    };
    var cachedObject = this[what];
    if (what === "all") {
      cached = this.all;
    } else if (isArray(cachedObject)) {
      for (var i = 0; i < cachedObject.length; i++) {
        var item = cachedObject[i];
        if (argsKeys.length && findCacheDiff(item))
          continue;
        cached = item._value;
        break;
      }
    }
    if (!cached && this.all) {
      var iterResult = new iterresult_default(what, args);
      for (var i = 0; i < this.all.length; i++) {
        if (!iterResult.accept(this.all[i]))
          break;
      }
      cached = iterResult.getValue();
      this._cacheAdd(what, cached, args);
    }
    return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
  };
  return Cache3;
}();

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i = 0; i < 55; i++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j = 0; j < options.byweekno.length; j++) {
    var n = options.byweekno[j];
    if (n < 0) {
      n += numweeks + 1;
    }
    if (!(n > 0 && n <= numweeks)) {
      continue;
    }
    var i = void 0;
    if (n > 1) {
      i = no1wkst + (n - 1) * 7;
      if (no1wkst !== firstwkst) {
        i -= 7 - firstwkst;
      }
    } else {
      i = no1wkst;
    }
    for (var k = 0; k < 7; k++) {
      result.wnomask[i] = 1;
      i++;
      if (result.wdaymask[i] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i -= 7 - firstwkst;
    if (i < yearlen) {
      for (var j = 0; j < 7; j++) {
        result.wnomask[i] = 1;
        i += 1;
        if (result.wdaymask[i] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i = 0; i < no1wkst; i++)
        result.wnomask[i] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j = 0; j < options.bymonth.length; j++) {
        month = options.bymonth[j];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j = 0; j < ranges.length; j++) {
    var rang = ranges[j];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k = 0; k < options.bynweekday.length; k++) {
      var i = void 0;
      var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
      if (n < 0) {
        i = last + (n + 1) * 7;
        i -= pymod(wdaymask[i] - wday, 7);
      } else {
        i = first + (n - 1) * 7;
        i += pymod(7 - wdaymask[i] + wday, 7);
      }
      if (first <= i && i <= last)
        result.nwdaymask[i] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a = y % 19;
  var b = Math.floor(y / 100);
  var c = y % 100;
  var d = Math.floor(b / 4);
  var e = b % 4;
  var f = Math.floor((b + 8) / 25);
  var g = Math.floor((b - f + 1) / 3);
  var h = Math.floor(19 * a + b - d - g + 15) % 30;
  var i = Math.floor(c / 4);
  var k = c % 4;
  var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
  var m = Math.floor((a + 11 * h + 22 * l) / 451);
  var month = Math.floor((h + l - 7 * m + 114) / 31);
  var day = (h + l - 7 * m + 114) % 31 + 1;
  var date = Date.UTC(y, month - 1, day + offset);
  var yearStart = Date.UTC(y, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = function() {
  function Iterinfo2(options) {
    this.options = options;
  }
  Iterinfo2.prototype.rebuild = function(year, month) {
    var options = this.options;
    if (year !== this.lastyear) {
      this.yearinfo = rebuildYear(year, options);
    }
    if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
      var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
      this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
    }
    if (isPresent(options.byeaster)) {
      this.eastermask = easter(year, options.byeaster);
    }
  };
  Object.defineProperty(Iterinfo2.prototype, "lastyear", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastyear : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
    get: function() {
      return this.monthinfo ? this.monthinfo.lastmonth : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearlen", {
    get: function() {
      return this.yearinfo.yearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
    get: function() {
      return this.yearinfo.yearordinal;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mrange", {
    get: function() {
      return this.yearinfo.mrange;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
    get: function() {
      return this.yearinfo.wdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mmask", {
    get: function() {
      return this.yearinfo.mmask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "wnomask", {
    get: function() {
      return this.yearinfo.wnomask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
    get: function() {
      return this.monthinfo ? this.monthinfo.nwdaymask : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
    get: function() {
      return this.yearinfo.nextyearlen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
    get: function() {
      return this.yearinfo.mdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
    get: function() {
      return this.yearinfo.nmdaymask;
    },
    enumerable: false,
    configurable: true
  });
  Iterinfo2.prototype.ydayset = function() {
    return [range(this.yearlen), 0, this.yearlen];
  };
  Iterinfo2.prototype.mdayset = function(_, month) {
    var start = this.mrange[month - 1];
    var end = this.mrange[month];
    var set = repeat(null, this.yearlen);
    for (var i = start; i < end; i++)
      set[i] = i;
    return [set, start, end];
  };
  Iterinfo2.prototype.wdayset = function(year, month, day) {
    var set = repeat(null, this.yearlen + 7);
    var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
    var start = i;
    for (var j = 0; j < 7; j++) {
      set[i] = i;
      ++i;
      if (this.wdaymask[i] === this.options.wkst)
        break;
    }
    return [set, start, i];
  };
  Iterinfo2.prototype.ddayset = function(year, month, day) {
    var set = repeat(null, this.yearlen);
    var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
    set[i] = i;
    return [set, i, i + 1];
  };
  Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
    var _this = this;
    var set = [];
    this.options.byminute.forEach(function(minute) {
      set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
    });
    sort(set);
    return set;
  };
  Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
    var set = this.options.bysecond.map(function(second) {
      return new Time(hour, minute, second, millisecond);
    });
    sort(set);
    return set;
  };
  Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
    return [new Time(hour, minute, second, millisecond)];
  };
  Iterinfo2.prototype.getdayset = function(freq) {
    switch (freq) {
      case Frequency.YEARLY:
        return this.ydayset.bind(this);
      case Frequency.MONTHLY:
        return this.mdayset.bind(this);
      case Frequency.WEEKLY:
        return this.wdayset.bind(this);
      case Frequency.DAILY:
        return this.ddayset.bind(this);
      default:
        return this.ddayset.bind(this);
    }
  };
  Iterinfo2.prototype.gettimeset = function(freq) {
    switch (freq) {
      case Frequency.HOURLY:
        return this.htimeset.bind(this);
      case Frequency.MINUTELY:
        return this.mtimeset.bind(this);
      case Frequency.SECONDLY:
        return this.stimeset.bind(this);
    }
  };
  return Iterinfo2;
}();
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j = 0; j < bysetpos.length; j++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k = start; k < end; k++) {
      var val = dayset[k];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i = void 0;
    if (daypos < 0) {
      i = tmp.slice(daypos)[0];
    } else {
      i = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j = 0; j < poslist.length; j++) {
        var res = poslist[j];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j = start; j < end; j++) {
        var currentDay = dayset[j];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k = 0; k < timeset.length; k++) {
          var time = timeset[k];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = function() {
  function RRule2(options, noCache) {
    if (options === void 0) {
      options = {};
    }
    if (noCache === void 0) {
      noCache = false;
    }
    this._cache = noCache ? null : new Cache();
    this.origOptions = initializeOptions(options);
    var parsedOptions = parseOptions(options).parsedOptions;
    this.options = parsedOptions;
  }
  RRule2.parseText = function(text2, language) {
    return parseText(text2, language);
  };
  RRule2.fromText = function(text2, language) {
    return fromText(text2, language);
  };
  RRule2.fromString = function(str) {
    return new RRule2(RRule2.parseString(str) || void 0);
  };
  RRule2.prototype._iter = function(iterResult) {
    return iter(iterResult, this.options);
  };
  RRule2.prototype._cacheGet = function(what, args) {
    if (!this._cache)
      return false;
    return this._cache._cacheGet(what, args);
  };
  RRule2.prototype._cacheAdd = function(what, value, args) {
    if (!this._cache)
      return;
    return this._cache._cacheAdd(what, value, args);
  };
  RRule2.prototype.all = function(iterator) {
    if (iterator) {
      return this._iter(new callbackiterresult_default("all", {}, iterator));
    }
    var result = this._cacheGet("all");
    if (result === false) {
      result = this._iter(new iterresult_default("all", {}));
      this._cacheAdd("all", result);
    }
    return result;
  };
  RRule2.prototype.between = function(after, before, inc, iterator) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(after) || !isValidDate(before)) {
      throw new Error("Invalid date passed in to RRule.between");
    }
    var args = {
      before,
      after,
      inc
    };
    if (iterator) {
      return this._iter(new callbackiterresult_default("between", args, iterator));
    }
    var result = this._cacheGet("between", args);
    if (result === false) {
      result = this._iter(new iterresult_default("between", args));
      this._cacheAdd("between", result, args);
    }
    return result;
  };
  RRule2.prototype.before = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.before");
    }
    var args = { dt, inc };
    var result = this._cacheGet("before", args);
    if (result === false) {
      result = this._iter(new iterresult_default("before", args));
      this._cacheAdd("before", result, args);
    }
    return result;
  };
  RRule2.prototype.after = function(dt, inc) {
    if (inc === void 0) {
      inc = false;
    }
    if (!isValidDate(dt)) {
      throw new Error("Invalid date passed in to RRule.after");
    }
    var args = { dt, inc };
    var result = this._cacheGet("after", args);
    if (result === false) {
      result = this._iter(new iterresult_default("after", args));
      this._cacheAdd("after", result, args);
    }
    return result;
  };
  RRule2.prototype.count = function() {
    return this.all().length;
  };
  RRule2.prototype.toString = function() {
    return optionsToString(this.origOptions);
  };
  RRule2.prototype.toText = function(gettext, language, dateFormatter) {
    return toText(this, gettext, language, dateFormatter);
  };
  RRule2.prototype.isFullyConvertibleToText = function() {
    return isFullyConvertible(this);
  };
  RRule2.prototype.clone = function() {
    return new RRule2(this.origOptions);
  };
  RRule2.FREQUENCIES = [
    "YEARLY",
    "MONTHLY",
    "WEEKLY",
    "DAILY",
    "HOURLY",
    "MINUTELY",
    "SECONDLY"
  ];
  RRule2.YEARLY = Frequency.YEARLY;
  RRule2.MONTHLY = Frequency.MONTHLY;
  RRule2.WEEKLY = Frequency.WEEKLY;
  RRule2.DAILY = Frequency.DAILY;
  RRule2.HOURLY = Frequency.HOURLY;
  RRule2.MINUTELY = Frequency.MINUTELY;
  RRule2.SECONDLY = Frequency.SECONDLY;
  RRule2.MO = Days.MO;
  RRule2.TU = Days.TU;
  RRule2.WE = Days.WE;
  RRule2.TH = Days.TH;
  RRule2.FR = Days.FR;
  RRule2.SA = Days.SA;
  RRule2.SU = Days.SU;
  RRule2.parseString = parseString;
  RRule2.optionsToString = optionsToString;
  return RRule2;
}();

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i = 0; i < _rdate.length; i++) {
    var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s, options) {
  var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s = s && s.trim();
  if (!s)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s.split(/\s/);
  }
  var lines = s.split("\n");
  var i = 0;
  while (i < lines.length) {
    var line = lines[i] = lines[i].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i, 1);
    } else if (i > 0 && line[0] === " ") {
      lines[i - 1] += line.slice(1);
      lines.splice(i, 1);
    } else {
      i += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i = 0; i < _this._rrule.length; i++) {
      var field_1 = _this._rrule[i].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = function(_super) {
  __extends(RRuleSet2, _super);
  function RRuleSet2(noCache) {
    if (noCache === void 0) {
      noCache = false;
    }
    var _this = _super.call(this, {}, noCache) || this;
    _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
    _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
    _this._rrule = [];
    _this._rdate = [];
    _this._exrule = [];
    _this._exdate = [];
    return _this;
  }
  RRuleSet2.prototype._iter = function(iterResult) {
    return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
  };
  RRuleSet2.prototype.rrule = function(rrule) {
    _addRule(rrule, this._rrule);
  };
  RRuleSet2.prototype.exrule = function(rrule) {
    _addRule(rrule, this._exrule);
  };
  RRuleSet2.prototype.rdate = function(date) {
    _addDate(date, this._rdate);
  };
  RRuleSet2.prototype.exdate = function(date) {
    _addDate(date, this._exdate);
  };
  RRuleSet2.prototype.rrules = function() {
    return this._rrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.exrules = function() {
    return this._exrule.map(function(e) {
      return rrulestr(e.toString());
    });
  };
  RRuleSet2.prototype.rdates = function() {
    return this._rdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.exdates = function() {
    return this._exdate.map(function(e) {
      return new Date(e.getTime());
    });
  };
  RRuleSet2.prototype.valueOf = function() {
    var result = [];
    if (!this._rrule.length && this._dtstart) {
      result = result.concat(optionsToString({ dtstart: this._dtstart }));
    }
    this._rrule.forEach(function(rrule) {
      result = result.concat(rrule.toString().split("\n"));
    });
    this._exrule.forEach(function(exrule) {
      result = result.concat(exrule.toString().split("\n").map(function(line) {
        return line.replace(/^RRULE:/, "EXRULE:");
      }).filter(function(line) {
        return !/^DTSTART/.test(line);
      }));
    });
    if (this._rdate.length) {
      result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
    }
    if (this._exdate.length) {
      result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
    }
    return result;
  };
  RRuleSet2.prototype.toString = function() {
    return this.valueOf().join("\n");
  };
  RRuleSet2.prototype.clone = function() {
    var rrs = new RRuleSet2(!!this._cache);
    this._rrule.forEach(function(rule) {
      return rrs.rrule(rule.clone());
    });
    this._exrule.forEach(function(rule) {
      return rrs.exrule(rule.clone());
    });
    this._rdate.forEach(function(date) {
      return rrs.rdate(new Date(date.getTime()));
    });
    this._exdate.forEach(function(date) {
      return rrs.exdate(new Date(date.getTime()));
    });
    return rrs;
  };
  return RRuleSet2;
}(RRule);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// src/lib/DateTools.ts
function compareByDate(a, b) {
  if (a !== null && b === null) {
    return -1;
  } else if (a === null && b !== null) {
    return 1;
  } else if (a !== null && b !== null) {
    if (a.isValid() && !b.isValid()) {
      return -1;
    } else if (!a.isValid() && b.isValid()) {
      return 1;
    }
    if (a.isAfter(b)) {
      return 1;
    } else if (a.isBefore(b)) {
      return -1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

// src/Recurrence.ts
var Recurrence = class {
  constructor({
    rrule,
    baseOnToday,
    referenceDate,
    startDate,
    scheduledDate,
    dueDate
  }) {
    this.rrule = rrule;
    this.baseOnToday = baseOnToday;
    this.referenceDate = referenceDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
  }
  static fromText({
    recurrenceRuleText,
    startDate,
    scheduledDate,
    dueDate
  }) {
    try {
      const match = recurrenceRuleText.match(/^([a-zA-Z0-9, !]+?)( when done)?$/i);
      if (match == null) {
        return null;
      }
      const isolatedRuleText = match[1].trim();
      const baseOnToday = match[2] !== void 0;
      const options = RRule.parseText(isolatedRuleText);
      if (options !== null) {
        let referenceDate = null;
        if (dueDate) {
          referenceDate = window.moment(dueDate);
        } else if (scheduledDate) {
          referenceDate = window.moment(scheduledDate);
        } else if (startDate) {
          referenceDate = window.moment(startDate);
        }
        if (!baseOnToday && referenceDate !== null) {
          options.dtstart = window.moment(referenceDate).startOf("day").utc(true).toDate();
        } else {
          options.dtstart = window.moment().startOf("day").utc(true).toDate();
        }
        const rrule = new RRule(options);
        return new Recurrence({
          rrule,
          baseOnToday,
          referenceDate,
          startDate,
          scheduledDate,
          dueDate
        });
      }
    } catch (e) {
      if (e instanceof Error) {
        console.log(e.message);
      }
    }
    return null;
  }
  toText() {
    let text2 = this.rrule.toText();
    if (this.baseOnToday) {
      text2 += " when done";
    }
    return text2;
  }
  next() {
    const next = this.nextReferenceDate();
    if (next !== null) {
      let startDate = null;
      let scheduledDate = null;
      let dueDate = null;
      if (this.referenceDate) {
        if (this.startDate) {
          const originalDifference = window.moment.duration(this.startDate.diff(this.referenceDate));
          startDate = window.moment(next);
          startDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.scheduledDate) {
          const originalDifference = window.moment.duration(this.scheduledDate.diff(this.referenceDate));
          scheduledDate = window.moment(next);
          scheduledDate.add(Math.round(originalDifference.asDays()), "days");
        }
        if (this.dueDate) {
          const originalDifference = window.moment.duration(this.dueDate.diff(this.referenceDate));
          dueDate = window.moment(next);
          dueDate.add(Math.round(originalDifference.asDays()), "days");
        }
      }
      return {
        startDate,
        scheduledDate,
        dueDate
      };
    }
    return null;
  }
  identicalTo(other) {
    if (this.baseOnToday !== other.baseOnToday) {
      return false;
    }
    if (compareByDate(this.startDate, other.startDate) !== 0) {
      return false;
    }
    if (compareByDate(this.scheduledDate, other.scheduledDate) !== 0) {
      return false;
    }
    if (compareByDate(this.dueDate, other.dueDate) !== 0) {
      return false;
    }
    return this.toText() === other.toText();
  }
  nextReferenceDate() {
    if (this.baseOnToday) {
      const today = window.moment();
      return this.nextReferenceDateFromToday(today).toDate();
    } else {
      return this.nextReferenceDateFromOriginalReferenceDate().toDate();
    }
  }
  nextReferenceDateFromToday(today) {
    const ruleBasedOnToday = new RRule(__spreadProps(__spreadValues({}, this.rrule.origOptions), {
      dtstart: today.startOf("day").utc(true).toDate()
    }));
    return this.nextAfter(today.endOf("day"), ruleBasedOnToday);
  }
  nextReferenceDateFromOriginalReferenceDate() {
    var _a;
    const after = window.moment((_a = this.referenceDate) != null ? _a : void 0).endOf("day");
    return this.nextAfter(after, this.rrule);
  }
  nextAfter(after, rrule) {
    after.utc(true);
    let next = window.moment(rrule.after(after.toDate()));
    const asText = this.toText();
    const monthMatch = asText.match(/every( \d+)? month(s)?(.*)?/);
    if (monthMatch !== null) {
      if (!asText.includes(" on ")) {
        next = Recurrence.nextAfterMonths(after, next, rrule, monthMatch[1]);
      }
    }
    const yearMatch = asText.match(/every( \d+)? year(s)?(.*)?/);
    if (yearMatch !== null) {
      next = Recurrence.nextAfterYears(after, next, rrule, yearMatch[1]);
    }
    return Recurrence.addTimezone(next);
  }
  static nextAfterMonths(after, next, rrule, skippingMonths) {
    let parsedSkippingMonths = 1;
    if (skippingMonths !== void 0) {
      parsedSkippingMonths = Number.parseInt(skippingMonths.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyMonths(after, next, parsedSkippingMonths)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyMonths(after, next, skippingMonths) {
    let diffMonths = next.month() - after.month();
    const diffYears = next.year() - after.year();
    diffMonths += diffYears * 12;
    return diffMonths > skippingMonths;
  }
  static nextAfterYears(after, next, rrule, skippingYears) {
    let parsedSkippingYears = 1;
    if (skippingYears !== void 0) {
      parsedSkippingYears = Number.parseInt(skippingYears.trim(), 10);
    }
    while (Recurrence.isSkippingTooManyYears(after, next, parsedSkippingYears)) {
      next = Recurrence.fromOneDayEarlier(after, rrule);
    }
    return next;
  }
  static isSkippingTooManyYears(after, next, skippingYears) {
    const diff = next.year() - after.year();
    return diff > skippingYears;
  }
  static fromOneDayEarlier(after, rrule) {
    after.subtract(1, "days").endOf("day");
    const options = rrule.origOptions;
    options.dtstart = after.startOf("day").toDate();
    rrule = new RRule(options);
    return window.moment(rrule.after(after.toDate()));
  }
  static addTimezone(date) {
    const localTimeZone = window.moment.utc(date).local(true);
    return localTimeZone.startOf("day");
  }
};

// src/lib/RegExpTools.ts
function escapeRegExp(s) {
  return s.replace(/([.*+?^${}()|[\]/\\])/g, "\\$1");
}

// src/Config/GlobalFilter.ts
var _GlobalFilter = class {
  constructor() {
    this._globalFilter = "";
    this._removeGlobalFilter = false;
  }
  static getInstance() {
    if (!_GlobalFilter.instance) {
      _GlobalFilter.instance = new _GlobalFilter();
    }
    return _GlobalFilter.instance;
  }
  get() {
    return this._globalFilter;
  }
  set(value) {
    this._globalFilter = value;
  }
  reset() {
    this.set(_GlobalFilter.empty);
  }
  isEmpty() {
    return this.get() === _GlobalFilter.empty;
  }
  equals(tag) {
    return this.get() === tag;
  }
  includedIn(description) {
    const globalFilter = this.get();
    return description.includes(globalFilter);
  }
  prependTo(description) {
    return this.get() + " " + description;
  }
  removeAsWordFromDependingOnSettings(description) {
    const removeGlobalFilter = this.getRemoveGlobalFilter();
    if (removeGlobalFilter) {
      return this.removeAsWordFrom(description);
    }
    return description;
  }
  getRemoveGlobalFilter() {
    return this._removeGlobalFilter;
  }
  setRemoveGlobalFilter(removeGlobalFilter) {
    this._removeGlobalFilter = removeGlobalFilter;
  }
  removeAsWordFrom(description) {
    if (this.isEmpty()) {
      return description;
    }
    const theRegExp = RegExp("(^|\\s)" + escapeRegExp(this.get()) + "($|\\s)", "ug");
    if (description.search(theRegExp) > -1) {
      description = description.replace(theRegExp, "$1$2").replace("  ", " ").trim();
    }
    return description;
  }
  removeAsSubstringFrom(description) {
    const globalFilter = this.get();
    return description.replace(globalFilter, "").trim();
  }
};
var GlobalFilter = _GlobalFilter;
GlobalFilter.empty = "";

// src/Suggestor/Suggestor.ts
var DEFAULT_MAX_GENERIC_SUGGESTIONS = 5;
function makeDefaultSuggestionBuilder(symbols, maxGenericSuggestions) {
  const datePrefixRegex = [symbols.startDateSymbol, symbols.scheduledDateSymbol, symbols.dueDateSymbol].join("|");
  return (line, cursorPos, settings2) => {
    let suggestions = [];
    suggestions = suggestions.concat(
      addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions)
    );
    suggestions = suggestions.concat(addRecurrenceSuggestions(line, cursorPos, settings2, symbols.recurrenceSymbol));
    suggestions = suggestions.concat(addTaskPropertySuggestions(line, cursorPos, settings2, symbols));
    if (suggestions.length > 0 && !suggestions.some((value) => value.suggestionType === "match")) {
      suggestions.unshift({
        suggestionType: "empty",
        displayText: "\u23CE",
        appendText: "\n"
      });
    }
    suggestions = suggestions.slice(0, settings2.autoSuggestMaxItems);
    return suggestions;
  };
}
function addTaskPropertySuggestions(line, cursorPos, _settings, symbols) {
  const hasPriority = (line2) => Object.values(symbols.prioritySymbols).some((value) => value.length > 0 && line2.includes(value));
  const genericSuggestions = [];
  if (!line.includes(symbols.dueDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.dueDateSymbol} due date`,
      appendText: `${symbols.dueDateSymbol} `
    });
  if (!line.includes(symbols.startDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.startDateSymbol} start date`,
      appendText: `${symbols.startDateSymbol} `
    });
  if (!line.includes(symbols.scheduledDateSymbol))
    genericSuggestions.push({
      displayText: `${symbols.scheduledDateSymbol} scheduled date`,
      appendText: `${symbols.scheduledDateSymbol} `
    });
  if (!hasPriority(line)) {
    genericSuggestions.push({
      displayText: `${symbols.prioritySymbols.High} high priority`,
      appendText: `${symbols.prioritySymbols.High} `
    });
    genericSuggestions.push({
      displayText: `${symbols.prioritySymbols.Medium} medium priority`,
      appendText: `${symbols.prioritySymbols.Medium} `
    });
    genericSuggestions.push({
      displayText: `${symbols.prioritySymbols.Low} low priority`,
      appendText: `${symbols.prioritySymbols.Low} `
    });
    genericSuggestions.push({
      displayText: `${symbols.prioritySymbols.Highest} highest priority`,
      appendText: `${symbols.prioritySymbols.Highest} `
    });
    genericSuggestions.push({
      displayText: `${symbols.prioritySymbols.Lowest} lowest priority`,
      appendText: `${symbols.prioritySymbols.Lowest} `
    });
  }
  if (!line.includes(symbols.recurrenceSymbol))
    genericSuggestions.push({
      displayText: `${symbols.recurrenceSymbol} recurring (repeat)`,
      appendText: `${symbols.recurrenceSymbol} `
    });
  if (!line.includes(symbols.createdDateSymbol)) {
    const parsedDate = DateParser.parseDate("today", true);
    const formattedDate = parsedDate.format(TaskRegularExpressions.dateFormat);
    genericSuggestions.push({
      textToMatch: `${symbols.createdDateSymbol} created`,
      displayText: `${symbols.createdDateSymbol} created today (${formattedDate})`,
      appendText: `${symbols.createdDateSymbol} ${formattedDate} `
    });
  }
  const wordMatch = matchByPosition(line, /([a-zA-Z'_-]*)/g, cursorPos);
  const matchingSuggestions = [];
  if (wordMatch && wordMatch.length > 0) {
    const wordUnderCursor = wordMatch[0];
    if (wordUnderCursor.length >= Math.max(1, _settings.autoSuggestMinMatch)) {
      const filteredSuggestions = genericSuggestions.filter((suggestInfo) => {
        const textToMatch = suggestInfo.textToMatch || suggestInfo.displayText;
        return textToMatch.toLowerCase().includes(wordUnderCursor.toLowerCase());
      });
      for (const filtered of filteredSuggestions) {
        matchingSuggestions.push({
          suggestionType: "match",
          displayText: filtered.displayText,
          appendText: filtered.appendText,
          insertAt: wordMatch.index,
          insertSkip: wordUnderCursor.length
        });
      }
    }
  }
  if (matchingSuggestions.length === 0 && _settings.autoSuggestMinMatch === 0)
    return genericSuggestions;
  return matchingSuggestions;
}
function addDatesSuggestions(line, cursorPos, settings2, datePrefixRegex, maxGenericSuggestions) {
  const genericSuggestions = [
    "today",
    "tomorrow",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "next week",
    "next month",
    "next year"
  ];
  const results = [];
  const dateRegex = new RegExp(`(${datePrefixRegex})\\s*([0-9a-zA-Z ]*)`, "ug");
  const dateMatch = matchByPosition(line, dateRegex, cursorPos);
  if (dateMatch && dateMatch.length >= 2) {
    const datePrefix = dateMatch[1];
    const dateString = dateMatch[2];
    if (dateString.length < settings2.autoSuggestMinMatch) {
      return [];
    }
    const possibleDate = dateString && dateString.length > 1 ? DateParser.parseDate(doAutocomplete(dateString), true) : null;
    if (possibleDate && possibleDate.isValid()) {
      results.push({
        displayText: `${possibleDate.format(TaskRegularExpressions.dateFormat)}`,
        appendText: `${datePrefix} ${possibleDate.format(TaskRegularExpressions.dateFormat)} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
    const minMatch = 1;
    let genericMatches = genericSuggestions.filter(
      (value) => dateString && dateString.length >= minMatch && value.toLowerCase().includes(dateString.toLowerCase())
    ).slice(0, maxGenericSuggestions);
    if (genericMatches.length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericSuggestions);
    }
    for (const match of genericMatches) {
      const parsedDate = DateParser.parseDate(match, true);
      const formattedDate = `${parsedDate.format(TaskRegularExpressions.dateFormat)}`;
      results.push({
        suggestionType: "match",
        displayText: `${match} (${formattedDate})`,
        appendText: `${datePrefix} ${formattedDate} `,
        insertAt: dateMatch.index,
        insertSkip: dateMatch[0].length
      });
    }
  }
  return results;
}
function addRecurrenceSuggestions(line, cursorPos, settings2, recurrenceSymbol) {
  var _a;
  const genericSuggestions = [
    "every",
    "every day",
    "every week",
    "every month",
    "every month on the",
    "every year",
    "every week on Sunday",
    "every week on Monday",
    "every week on Tuesday",
    "every week on Wednesday",
    "every week on Thursday",
    "every week on Friday",
    "every week on Saturday"
  ];
  const results = [];
  const recurrenceRegex = new RegExp(`(${recurrenceSymbol})\\s*([0-9a-zA-Z ]*)`, "ug");
  const recurrenceMatch = matchByPosition(line, recurrenceRegex, cursorPos);
  if (recurrenceMatch && recurrenceMatch.length >= 2) {
    const recurrencePrefix = recurrenceMatch[1];
    const recurrenceString = recurrenceMatch[2];
    if (recurrenceString.length < settings2.autoSuggestMinMatch)
      return [];
    if (recurrenceString.length > 0) {
      const parsedRecurrence = (_a = Recurrence.fromText({
        recurrenceRuleText: recurrenceString,
        startDate: null,
        scheduledDate: null,
        dueDate: null
      })) == null ? void 0 : _a.toText();
      if (parsedRecurrence) {
        const appendedText = `${recurrencePrefix} ${parsedRecurrence} `;
        results.push({
          suggestionType: "match",
          displayText: `\u2705 ${parsedRecurrence}`,
          appendText: appendedText,
          insertAt: recurrenceMatch.index,
          insertSkip: recurrenceMatch[0].length
        });
        if (recurrenceMatch[0] == appendedText)
          return [];
      }
    }
    const minMatch = 1;
    const maxGenericDateSuggestions = settings2.autoSuggestMaxItems / 2;
    let genericMatches = genericSuggestions.filter(
      (value) => recurrenceString && recurrenceString.length >= minMatch && value.toLowerCase().includes(recurrenceString.toLowerCase())
    ).slice(0, maxGenericDateSuggestions);
    if (genericMatches.length === 0 && recurrenceString.trim().length === 0) {
      genericMatches = genericSuggestions.slice(0, maxGenericDateSuggestions);
    }
    for (const match of genericMatches) {
      results.push({
        suggestionType: "match",
        displayText: `${match}`,
        appendText: `${recurrencePrefix} ${match} `,
        insertAt: recurrenceMatch.index,
        insertSkip: recurrenceMatch[0].length
      });
    }
  }
  return results;
}
function matchByPosition(s, r, position) {
  const matches = s.matchAll(r);
  for (const match of matches) {
    if ((match == null ? void 0 : match.index) && match.index <= position && position <= match.index + match[0].length)
      return match;
  }
}
function isAnyBracketOpen(line, brackets) {
  if (brackets.length === 0) {
    return false;
  }
  const numOpeningBrackets = Object.fromEntries(brackets.map(([open, _]) => [open, 0]));
  const openingOf = Object.fromEntries(brackets.map(([open, close]) => [close, open]));
  for (const c of line) {
    if (c in numOpeningBrackets) {
      numOpeningBrackets[c]++;
    } else if (c in openingOf) {
      numOpeningBrackets[openingOf[c]] = Math.max(0, numOpeningBrackets[openingOf[c]] - 1);
    }
  }
  return Object.values(numOpeningBrackets).some((n) => n > 0);
}
function onlySuggestIfBracketOpen(fn, brackets) {
  return (line, cursorPos, settings2) => {
    if (!isAnyBracketOpen(line.slice(0, cursorPos), brackets)) {
      return [];
    }
    return fn(line, cursorPos, settings2);
  };
}
function canSuggestForLine(line, cursorPosition) {
  return GlobalFilter.getInstance().includedIn(line) && cursorIsInTaskLineDescription(line, cursorPosition);
}
function cursorIsInTaskLineDescription(line, cursorPosition) {
  if (line.length === 0) {
    return false;
  }
  const components = Task.extractTaskComponents(line);
  if (!components) {
    return false;
  }
  const beforeDescription = components.indentation + components.listMarker + " [" + components.status.symbol + "] ";
  return cursorPosition >= beforeDescription.length;
}

// src/TaskLayout.ts
var LayoutOptions = class {
  constructor() {
    this.hideTaskCount = false;
    this.hideBacklinks = false;
    this.hidePriority = false;
    this.hideCreatedDate = false;
    this.hideStartDate = false;
    this.hideScheduledDate = false;
    this.hideDoneDate = false;
    this.hideDueDate = false;
    this.hideRecurrenceRule = false;
    this.hideEditButton = false;
    this.hideUrgency = true;
    this.hideTags = false;
    this.shortMode = false;
    this.explainQuery = false;
  }
};
var TaskLayout = class {
  constructor(options) {
    this.defaultLayout = [
      "description",
      "priority",
      "recurrenceRule",
      "createdDate",
      "startDate",
      "scheduledDate",
      "dueDate",
      "doneDate",
      "blockLink"
    ];
    this.hiddenTaskLayoutComponents = [];
    this.taskListHiddenClasses = [];
    if (options) {
      this.options = options;
    } else {
      this.options = new LayoutOptions();
    }
    this.shownTaskLayoutComponents = this.defaultLayout;
    this.applyOptions();
  }
  applyOptions() {
    const componentsToHideAndGenerateClasses = [
      [this.options.hidePriority, "priority"],
      [this.options.hideRecurrenceRule, "recurrenceRule"],
      [this.options.hideCreatedDate, "createdDate"],
      [this.options.hideStartDate, "startDate"],
      [this.options.hideScheduledDate, "scheduledDate"],
      [this.options.hideDueDate, "dueDate"],
      [this.options.hideDoneDate, "doneDate"]
    ];
    for (const [hide, component] of componentsToHideAndGenerateClasses) {
      this.hideComponent(hide, component);
      this.generateHiddenClassForTaskList(hide, component);
    }
    const componentsToGenerateClassesOnly = [
      [this.options.hideTags, "tags"],
      [this.options.hideUrgency, "urgency"],
      [this.options.hideBacklinks, "backlinks"],
      [this.options.hideEditButton, "edit-button"]
    ];
    for (const [hide, component] of componentsToGenerateClassesOnly) {
      this.generateHiddenClassForTaskList(hide, component);
    }
    if (this.options.shortMode)
      this.taskListHiddenClasses.push("tasks-layout-short-mode");
  }
  generateHiddenClassForTaskList(hide, component) {
    if (hide) {
      this.taskListHiddenClasses.push(`tasks-layout-hide-${component}`);
    }
  }
  hideComponent(hide, component) {
    if (hide) {
      this.hiddenTaskLayoutComponents.push(component);
      this.shownTaskLayoutComponents = this.shownTaskLayoutComponents.filter((element2) => element2 != component);
    }
  }
};

// src/TaskSerializer/DefaultTaskSerializer.ts
var DEFAULT_SYMBOLS = {
  prioritySymbols: {
    Highest: "\u{1F53A}",
    High: "\u23EB",
    Medium: "\u{1F53C}",
    Low: "\u{1F53D}",
    Lowest: "\u23EC",
    None: ""
  },
  startDateSymbol: "\u{1F6EB}",
  createdDateSymbol: "\u2795",
  scheduledDateSymbol: "\u23F3",
  dueDateSymbol: "\u{1F4C5}",
  doneDateSymbol: "\u2705",
  recurrenceSymbol: "\u{1F501}",
  TaskFormatRegularExpressions: {
    priorityRegex: /([🔺⏫🔼🔽⏬])$/u,
    startDateRegex: /🛫 *(\d{4}-\d{2}-\d{2})$/u,
    createdDateRegex: /➕ *(\d{4}-\d{2}-\d{2})$/u,
    scheduledDateRegex: /[⏳⌛] *(\d{4}-\d{2}-\d{2})$/u,
    dueDateRegex: /[📅📆🗓] *(\d{4}-\d{2}-\d{2})$/u,
    doneDateRegex: /✅ *(\d{4}-\d{2}-\d{2})$/u,
    recurrenceRegex: /🔁 ?([a-zA-Z0-9, !]+)$/iu
  }
};
var DefaultTaskSerializer = class {
  constructor(symbols) {
    this.symbols = symbols;
  }
  serialize(task) {
    const taskLayout = new TaskLayout();
    let taskString = "";
    for (const component of taskLayout.shownTaskLayoutComponents) {
      taskString += this.componentToString(task, taskLayout, component);
    }
    return taskString;
  }
  componentToString(task, layout, component) {
    var _a;
    const {
      prioritySymbols,
      startDateSymbol,
      createdDateSymbol,
      scheduledDateSymbol,
      doneDateSymbol,
      recurrenceSymbol,
      dueDateSymbol
    } = this.symbols;
    switch (component) {
      case "description":
        return task.description;
      case "priority": {
        let priority = "";
        if (task.priority === "0" /* Highest */) {
          priority = " " + prioritySymbols.Highest;
        } else if (task.priority === "1" /* High */) {
          priority = " " + prioritySymbols.High;
        } else if (task.priority === "2" /* Medium */) {
          priority = " " + prioritySymbols.Medium;
        } else if (task.priority === "4" /* Low */) {
          priority = " " + prioritySymbols.Low;
        } else if (task.priority === "5" /* Lowest */) {
          priority = " " + prioritySymbols.Lowest;
        }
        return priority;
      }
      case "startDate":
        if (!task.startDate)
          return "";
        return layout.options.shortMode ? " " + startDateSymbol : ` ${startDateSymbol} ${task.startDate.format(TaskRegularExpressions.dateFormat)}`;
      case "createdDate":
        if (!task.createdDate)
          return "";
        return layout.options.shortMode ? " " + createdDateSymbol : ` ${createdDateSymbol} ${task.createdDate.format(TaskRegularExpressions.dateFormat)}`;
      case "scheduledDate":
        if (!task.scheduledDate || task.scheduledDateIsInferred)
          return "";
        return layout.options.shortMode ? " " + scheduledDateSymbol : ` ${scheduledDateSymbol} ${task.scheduledDate.format(TaskRegularExpressions.dateFormat)}`;
      case "doneDate":
        if (!task.doneDate)
          return "";
        return layout.options.shortMode ? " " + doneDateSymbol : ` ${doneDateSymbol} ${task.doneDate.format(TaskRegularExpressions.dateFormat)}`;
      case "dueDate":
        if (!task.dueDate)
          return "";
        return layout.options.shortMode ? " " + dueDateSymbol : ` ${dueDateSymbol} ${task.dueDate.format(TaskRegularExpressions.dateFormat)}`;
      case "recurrenceRule":
        if (!task.recurrence)
          return "";
        return layout.options.shortMode ? " " + recurrenceSymbol : ` ${recurrenceSymbol} ${task.recurrence.toText()}`;
      case "blockLink":
        return (_a = task.blockLink) != null ? _a : "";
      default:
        throw new Error(`Don't know how to render task component of type '${component}'`);
    }
  }
  parsePriority(p) {
    const { prioritySymbols } = this.symbols;
    switch (p) {
      case prioritySymbols.Lowest:
        return "5" /* Lowest */;
      case prioritySymbols.Low:
        return "4" /* Low */;
      case prioritySymbols.Medium:
        return "2" /* Medium */;
      case prioritySymbols.High:
        return "1" /* High */;
      case prioritySymbols.Highest:
        return "0" /* Highest */;
      default:
        return "3" /* None */;
    }
  }
  deserialize(line) {
    const { TaskFormatRegularExpressions } = this.symbols;
    let matched;
    let priority = "3" /* None */;
    let startDate = null;
    let scheduledDate = null;
    let dueDate = null;
    let doneDate = null;
    let createdDate = null;
    let recurrenceRule = "";
    let recurrence = null;
    let trailingTags = "";
    const maxRuns = 20;
    let runs = 0;
    do {
      matched = false;
      const priorityMatch = line.match(TaskFormatRegularExpressions.priorityRegex);
      if (priorityMatch !== null) {
        priority = this.parsePriority(priorityMatch[1]);
        line = line.replace(TaskFormatRegularExpressions.priorityRegex, "").trim();
        matched = true;
      }
      const doneDateMatch = line.match(TaskFormatRegularExpressions.doneDateRegex);
      if (doneDateMatch !== null) {
        doneDate = window.moment(doneDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.doneDateRegex, "").trim();
        matched = true;
      }
      const dueDateMatch = line.match(TaskFormatRegularExpressions.dueDateRegex);
      if (dueDateMatch !== null) {
        dueDate = window.moment(dueDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.dueDateRegex, "").trim();
        matched = true;
      }
      const scheduledDateMatch = line.match(TaskFormatRegularExpressions.scheduledDateRegex);
      if (scheduledDateMatch !== null) {
        scheduledDate = window.moment(scheduledDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.scheduledDateRegex, "").trim();
        matched = true;
      }
      const startDateMatch = line.match(TaskFormatRegularExpressions.startDateRegex);
      if (startDateMatch !== null) {
        startDate = window.moment(startDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.startDateRegex, "").trim();
        matched = true;
      }
      const createdDateMatch = line.match(TaskFormatRegularExpressions.createdDateRegex);
      if (createdDateMatch !== null) {
        createdDate = window.moment(createdDateMatch[1], TaskRegularExpressions.dateFormat);
        line = line.replace(TaskFormatRegularExpressions.createdDateRegex, "").trim();
        matched = true;
      }
      const recurrenceMatch = line.match(TaskFormatRegularExpressions.recurrenceRegex);
      if (recurrenceMatch !== null) {
        recurrenceRule = recurrenceMatch[1].trim();
        line = line.replace(TaskFormatRegularExpressions.recurrenceRegex, "").trim();
        matched = true;
      }
      const tagsMatch = line.match(TaskRegularExpressions.hashTagsFromEnd);
      if (tagsMatch != null) {
        line = line.replace(TaskRegularExpressions.hashTagsFromEnd, "").trim();
        matched = true;
        const tagName = tagsMatch[0].trim();
        trailingTags = trailingTags.length > 0 ? [tagName, trailingTags].join(" ") : tagName;
      }
      runs++;
    } while (matched && runs <= maxRuns);
    if (recurrenceRule.length > 0) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    if (trailingTags.length > 0)
      line += " " + trailingTags;
    return {
      description: line,
      priority,
      startDate,
      createdDate,
      scheduledDate,
      dueDate,
      doneDate,
      recurrence,
      tags: Task.extractHashtags(line)
    };
  }
};

// src/TaskSerializer/DataviewTaskSerializer.ts
function toInlineFieldRegex(innerFieldRegex) {
  const fieldRegex = [
    "(?:",
    /(?=[^\]]+\])\[/,
    "|",
    /(?=[^)]+\))\(/,
    ")",
    / */,
    innerFieldRegex,
    / */,
    /[)\]]/,
    /(?: *,)?/,
    /$/
  ].map((val) => val instanceof RegExp ? val.source : val).join("");
  return new RegExp(fieldRegex, innerFieldRegex.flags);
}
var DATAVIEW_SYMBOLS = {
  prioritySymbols: {
    Highest: "priority:: highest",
    High: "priority:: high",
    Medium: "priority:: medium",
    Low: "priority:: low",
    Lowest: "priority:: lowest",
    None: ""
  },
  startDateSymbol: "start::",
  createdDateSymbol: "created::",
  scheduledDateSymbol: "scheduled::",
  dueDateSymbol: "due::",
  doneDateSymbol: "completion::",
  recurrenceSymbol: "repeat::",
  TaskFormatRegularExpressions: {
    priorityRegex: toInlineFieldRegex(/priority:: *(highest|high|medium|low|lowest)/),
    startDateRegex: toInlineFieldRegex(/start:: *(\d{4}-\d{2}-\d{2})/),
    createdDateRegex: toInlineFieldRegex(/created:: *(\d{4}-\d{2}-\d{2})/),
    scheduledDateRegex: toInlineFieldRegex(/scheduled:: *(\d{4}-\d{2}-\d{2})/),
    dueDateRegex: toInlineFieldRegex(/due:: *(\d{4}-\d{2}-\d{2})/),
    doneDateRegex: toInlineFieldRegex(/completion:: *(\d{4}-\d{2}-\d{2})/),
    recurrenceRegex: toInlineFieldRegex(/repeat:: *([a-zA-Z0-9, !]+)/)
  }
};
var DataviewTaskSerializer = class extends DefaultTaskSerializer {
  constructor() {
    super(DATAVIEW_SYMBOLS);
  }
  parsePriority(p) {
    switch (p) {
      case "highest":
        return "0" /* Highest */;
      case "high":
        return "1" /* High */;
      case "medium":
        return "2" /* Medium */;
      case "low":
        return "4" /* Low */;
      case "lowest":
        return "5" /* Lowest */;
      default:
        return "3" /* None */;
    }
  }
  componentToString(task, layout, component) {
    const stringComponent = super.componentToString(task, layout, component);
    const notInlineFieldComponents = ["blockLink", "description"];
    const shouldMakeInlineField = stringComponent !== "" && !notInlineFieldComponents.includes(component);
    return shouldMakeInlineField ? `  [${stringComponent.trim()}]` : stringComponent;
  }
};

// src/StatusConfiguration.ts
var StatusType = /* @__PURE__ */ ((StatusType2) => {
  StatusType2["TODO"] = "TODO";
  StatusType2["DONE"] = "DONE";
  StatusType2["IN_PROGRESS"] = "IN_PROGRESS";
  StatusType2["CANCELLED"] = "CANCELLED";
  StatusType2["NON_TASK"] = "NON_TASK";
  StatusType2["EMPTY"] = "EMPTY";
  return StatusType2;
})(StatusType || {});
var StatusConfiguration = class {
  constructor(symbol, name, nextStatusSymbol, availableAsCommand, type = "TODO" /* TODO */) {
    this.symbol = symbol;
    this.name = name;
    this.nextStatusSymbol = nextStatusSymbol;
    this.availableAsCommand = availableAsCommand;
    this.type = type;
  }
};

// src/Status.ts
var _Status = class {
  get symbol() {
    return this.configuration.symbol;
  }
  get name() {
    return this.configuration.name;
  }
  get nextStatusSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  get nextSymbol() {
    return this.configuration.nextStatusSymbol;
  }
  get availableAsCommand() {
    return this.configuration.availableAsCommand;
  }
  get type() {
    return this.configuration.type;
  }
  constructor(configuration) {
    this.configuration = configuration;
  }
  static makeDone() {
    return new _Status(new StatusConfiguration("x", "Done", " ", true, "DONE" /* DONE */));
  }
  static makeEmpty() {
    return new _Status(new StatusConfiguration("", "EMPTY", "", true, "EMPTY" /* EMPTY */));
  }
  static makeTodo() {
    return new _Status(new StatusConfiguration(" ", "Todo", "x", true, "TODO" /* TODO */));
  }
  static makeCancelled() {
    return new _Status(new StatusConfiguration("-", "Cancelled", " ", true, "CANCELLED" /* CANCELLED */));
  }
  static makeInProgress() {
    return new _Status(new StatusConfiguration("/", "In Progress", "x", true, "IN_PROGRESS" /* IN_PROGRESS */));
  }
  static getTypeForUnknownSymbol(symbol) {
    switch (symbol) {
      case "x":
      case "X":
        return "DONE" /* DONE */;
      case "/":
        return "IN_PROGRESS" /* IN_PROGRESS */;
      case "-":
        return "CANCELLED" /* CANCELLED */;
      case "":
        return "EMPTY" /* EMPTY */;
      case " ":
      default:
        return "TODO" /* TODO */;
    }
  }
  static getTypeFromStatusTypeString(statusTypeAsString) {
    return StatusType[statusTypeAsString] || "TODO" /* TODO */;
  }
  static createUnknownStatus(unknownSymbol) {
    return new _Status(new StatusConfiguration(unknownSymbol, "Unknown", "x", false, "TODO" /* TODO */));
  }
  static createFromImportedValue(imported) {
    const symbol = imported[0];
    const type = _Status.getTypeFromStatusTypeString(imported[3]);
    return new _Status(new StatusConfiguration(symbol, imported[1], imported[2], false, type));
  }
  isCompleted() {
    return this.type === "DONE" /* DONE */;
  }
  identicalTo(other) {
    const args = [
      "symbol",
      "name",
      "nextStatusSymbol",
      "availableAsCommand",
      "type"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    return true;
  }
  previewText() {
    let commandNotice = "";
    if (_Status.tasksPluginCanCreateCommandsForStatuses() && this.availableAsCommand) {
      commandNotice = " Available as a command.";
    }
    return `- [${this.symbol}] => [${this.nextStatusSymbol}], name: '${this.name}', type: '${this.configuration.type}'.${commandNotice}`;
  }
  static tasksPluginCanCreateCommandsForStatuses() {
    return false;
  }
};
var Status = _Status;
Status.DONE = _Status.makeDone();
Status.EMPTY = _Status.makeEmpty();
Status.TODO = _Status.makeTodo();

// src/Config/DebugSettings.ts
var DebugSettings = class {
  constructor(ignoreSortInstructions = false, showTaskHiddenData = false) {
    this.ignoreSortInstructions = ignoreSortInstructions;
    this.showTaskHiddenData = showTaskHiddenData;
  }
};

// src/Config/StatusSettings.ts
var StatusSettings = class {
  constructor() {
    this.coreStatuses = [
      Status.makeTodo().configuration,
      Status.makeDone().configuration
    ];
    this.customStatuses = [
      Status.makeInProgress().configuration,
      Status.makeCancelled().configuration
    ];
  }
  static addStatus(statuses, newStatus) {
    statuses.push(newStatus);
  }
  static replaceStatus(statuses, originalStatus, newStatus) {
    const index = this.findStatusIndex(originalStatus, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1, newStatus);
    return true;
  }
  static findStatusIndex(statusConfiguration, statuses) {
    const originalStatusAsStatus = new Status(statusConfiguration);
    return statuses.findIndex((s) => {
      return new Status(s).previewText() == originalStatusAsStatus.previewText();
    });
  }
  static deleteStatus(statuses, status) {
    const index = this.findStatusIndex(status, statuses);
    if (index <= -1) {
      return false;
    }
    statuses.splice(index, 1);
    return true;
  }
  static deleteAllCustomStatuses(statusSettings) {
    statusSettings.customStatuses.splice(0);
  }
  static resetAllCustomStatuses(statusSettings) {
    StatusSettings.deleteAllCustomStatuses(statusSettings);
    const defaultSettings2 = new StatusSettings();
    defaultSettings2.customStatuses.forEach((s) => {
      StatusSettings.addStatus(statusSettings.customStatuses, s);
    });
  }
  static bulkAddStatusCollection(statusSettings, supportedStatuses) {
    const notices = [];
    supportedStatuses.forEach((importedStatus) => {
      const hasStatus = statusSettings.customStatuses.find((element2) => {
        return element2.symbol == importedStatus[0] && element2.name == importedStatus[1] && element2.nextStatusSymbol == importedStatus[2];
      });
      if (!hasStatus) {
        StatusSettings.addStatus(statusSettings.customStatuses, Status.createFromImportedValue(importedStatus));
      } else {
        notices.push(`The status ${importedStatus[1]} (${importedStatus[0]}) is already added.`);
      }
    });
    return notices;
  }
  static applyToStatusRegistry(statusSettings, statusRegistry) {
    statusRegistry.clearStatuses();
    statusSettings.coreStatuses.forEach((statusType) => {
      statusRegistry.add(statusType);
    });
    statusSettings.customStatuses.forEach((statusType) => {
      statusRegistry.add(statusType);
    });
  }
};

// src/Config/featureConfiguration.json
var featureConfiguration_default = [
  {
    index: 9999,
    internalName: "INTERNAL_TESTING_ENABLED_BY_DEFAULT",
    displayName: "Test Item. Used to validate the Feature Framework.",
    description: "Description",
    enabledByDefault: true,
    stable: false
  }
];

// src/Config/Feature.ts
var Feature = class {
  constructor(internalName, index, description, displayName, enabledByDefault, stable) {
    this.internalName = internalName;
    this.index = index;
    this.description = description;
    this.displayName = displayName;
    this.enabledByDefault = enabledByDefault;
    this.stable = stable;
  }
  static get values() {
    let availableFeatures = [];
    featureConfiguration_default.forEach((feature) => {
      availableFeatures = [
        ...availableFeatures,
        new Feature(
          feature.internalName,
          feature.index,
          feature.description,
          feature.displayName,
          feature.enabledByDefault,
          feature.stable
        )
      ];
    });
    return availableFeatures;
  }
  static get settingsFlags() {
    const featureFlags = {};
    Feature.values.forEach((feature) => {
      featureFlags[feature.internalName] = feature.enabledByDefault;
    });
    return featureFlags;
  }
  static fromString(name) {
    for (const feature of Feature.values) {
      if (name === feature.internalName) {
        return feature;
      }
    }
    throw new RangeError(
      `Illegal argument passed to fromString(): ${name} does not correspond to any available Feature ${this.prototype.constructor.name}`
    );
  }
};

// src/Config/Settings.ts
var TASK_FORMATS = {
  tasksPluginEmoji: {
    displayName: "Tasks Emoji Format",
    taskSerializer: new DefaultTaskSerializer(DEFAULT_SYMBOLS),
    buildSuggestions: makeDefaultSuggestionBuilder(DEFAULT_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS)
  },
  dataview: {
    displayName: "Dataview",
    taskSerializer: new DataviewTaskSerializer(),
    buildSuggestions: onlySuggestIfBracketOpen(
      makeDefaultSuggestionBuilder(DATAVIEW_SYMBOLS, DEFAULT_MAX_GENERIC_SUGGESTIONS),
      [
        ["(", ")"],
        ["[", "]"]
      ]
    )
  }
};
var defaultSettings = {
  globalQuery: "",
  globalFilter: "",
  removeGlobalFilter: false,
  taskFormat: "tasksPluginEmoji",
  setCreatedDate: false,
  setDoneDate: true,
  autoSuggestInEditor: true,
  autoSuggestMinMatch: 0,
  autoSuggestMaxItems: 6,
  provideAccessKeys: true,
  useFilenameAsScheduledDate: false,
  filenameAsDateFolders: [],
  recurrenceOnNextLine: false,
  statusSettings: new StatusSettings(),
  features: Feature.settingsFlags,
  generalSettings: {},
  headingOpened: {},
  debugSettings: new DebugSettings()
};
var settings = __spreadValues({}, defaultSettings);
var getSettings = () => {
  for (const flag in Feature.settingsFlags) {
    if (settings.features[flag] === void 0) {
      settings.features[flag] = Feature.settingsFlags[flag];
    }
  }
  settings.statusSettings.customStatuses.forEach((s, index, array) => {
    var _a, _b;
    const newType = Status.getTypeFromStatusTypeString(s.type);
    array[index] = new StatusConfiguration(
      (_a = s.symbol) != null ? _a : " ",
      s.name,
      (_b = s.nextStatusSymbol) != null ? _b : "x",
      s.availableAsCommand,
      newType
    );
  });
  return __spreadValues({}, settings);
};
var updateSettings = (newSettings) => {
  settings = __spreadValues(__spreadValues({}, settings), newSettings);
  return getSettings();
};
var updateGeneralSetting = (name, value) => {
  settings.generalSettings[name] = value;
  return getSettings();
};
var isFeatureEnabled = (internalName) => {
  var _a;
  return (_a = settings.features[internalName]) != null ? _a : false;
};
function getUserSelectedTaskFormat() {
  return TASK_FORMATS[getSettings().taskFormat];
}

// src/StatusRegistry.ts
var StatusRegistry = class {
  constructor() {
    this._registeredStatuses = [];
    this.addDefaultStatusTypes();
  }
  get registeredStatuses() {
    return this._registeredStatuses.filter(({ symbol }) => symbol !== Status.EMPTY.symbol);
  }
  static getInstance() {
    if (!StatusRegistry.instance) {
      StatusRegistry.instance = new StatusRegistry();
    }
    return StatusRegistry.instance;
  }
  add(status) {
    if (!this.hasSymbol(status.symbol)) {
      if (status instanceof Status) {
        this._registeredStatuses.push(status);
      } else {
        this._registeredStatuses.push(new Status(status));
      }
    }
  }
  bySymbol(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.EMPTY;
  }
  bySymbolOrCreate(symbol) {
    if (this.hasSymbol(symbol)) {
      return this.getSymbol(symbol);
    }
    return Status.createUnknownStatus(symbol);
  }
  byName(nameToFind) {
    if (this._registeredStatuses.filter(({ name }) => name === nameToFind).length > 0) {
      return this._registeredStatuses.filter(({ name }) => name === nameToFind)[0];
    }
    return Status.EMPTY;
  }
  resetToDefaultStatuses() {
    this.clearStatuses();
    this.addDefaultStatusTypes();
  }
  clearStatuses() {
    this._registeredStatuses = [];
  }
  getNextStatus(status) {
    if (status.nextStatusSymbol !== "") {
      const nextStatus = this.bySymbol(status.nextStatusSymbol);
      if (nextStatus !== null) {
        return nextStatus;
      }
    }
    return Status.EMPTY;
  }
  getNextStatusOrCreate(status) {
    const nextStatus = this.getNextStatus(status);
    if (nextStatus.type !== "EMPTY" /* EMPTY */) {
      return nextStatus;
    }
    return Status.createUnknownStatus(status.nextStatusSymbol);
  }
  findUnknownStatuses(allStatuses) {
    const unknownStatuses = allStatuses.filter((s) => {
      return !this.hasSymbol(s.symbol);
    });
    const newStatusRegistry = new StatusRegistry();
    const namedUniqueStatuses = [];
    unknownStatuses.forEach((s) => {
      if (newStatusRegistry.hasSymbol(s.symbol)) {
        return;
      }
      const newStatus = StatusRegistry.copyStatusWithNewName(s, `Unknown (${s.symbol})`);
      namedUniqueStatuses.push(newStatus);
      newStatusRegistry.add(newStatus);
    });
    return namedUniqueStatuses;
  }
  static copyStatusWithNewName(s, newName) {
    const statusConfiguration = new StatusConfiguration(
      s.symbol,
      newName,
      s.nextStatusSymbol,
      s.availableAsCommand,
      s.type
    );
    return new Status(statusConfiguration);
  }
  getSymbol(symbolToFind) {
    return this._registeredStatuses.filter(({ symbol }) => symbol === symbolToFind)[0];
  }
  hasSymbol(symbolToFind) {
    return this._registeredStatuses.find((element2) => {
      return element2.symbol === symbolToFind;
    }) !== void 0;
  }
  addDefaultStatusTypes() {
    const defaultStatuses = [Status.makeTodo(), Status.makeInProgress(), Status.makeDone(), Status.makeCancelled()];
    defaultStatuses.forEach((status) => {
      this.add(status);
    });
  }
};

// src/Urgency.ts
var _Urgency = class {
  static calculate(task) {
    let urgency = 0;
    if (task.dueDate !== null) {
      const startOfToday = window.moment().startOf("day");
      const daysOverdue = Math.round(startOfToday.diff(task.dueDate) / _Urgency.milliSecondsPerDay);
      let dueMultiplier;
      if (daysOverdue >= 7) {
        dueMultiplier = 1;
      } else if (daysOverdue >= -14) {
        dueMultiplier = (daysOverdue + 14) * 0.8 / 21 + 0.2;
      } else {
        dueMultiplier = 0.2;
      }
      urgency += dueMultiplier * _Urgency.dueCoefficient;
    }
    if (task.scheduledDate !== null) {
      if (window.moment().isSameOrAfter(task.scheduledDate)) {
        urgency += 1 * _Urgency.scheduledCoefficient;
      }
    }
    if (task.startDate !== null) {
      if (window.moment().isBefore(task.startDate)) {
        urgency += 1 * _Urgency.startedCoefficient;
      }
    }
    switch (task.priority) {
      case "0":
        urgency += 1.5 * _Urgency.priorityCoefficient;
        break;
      case "1":
        urgency += 1 * _Urgency.priorityCoefficient;
        break;
      case "2":
        urgency += 0.65 * _Urgency.priorityCoefficient;
        break;
      case "3":
        urgency += 0.325 * _Urgency.priorityCoefficient;
        break;
      case "5":
        urgency -= 0.3 * _Urgency.priorityCoefficient;
        break;
    }
    return urgency;
  }
};
var Urgency = _Urgency;
Urgency.dueCoefficient = 12;
Urgency.scheduledCoefficient = 5;
Urgency.startedCoefficient = -3;
Urgency.priorityCoefficient = 6;
Urgency.milliSecondsPerDay = 1e3 * 60 * 60 * 24;

// src/DateFallback.ts
var DateFallback = class {
  static fromPath(path) {
    const { useFilenameAsScheduledDate, filenameAsDateFolders } = getSettings();
    if (!useFilenameAsScheduledDate) {
      return null;
    }
    if (!this.matchesAnyFolder(filenameAsDateFolders, path)) {
      return null;
    }
    return this.extractDateFromPath(path);
  }
  static matchesAnyFolder(folders, path) {
    if (folders.length === 0) {
      return true;
    }
    return folders.some((folder) => path.startsWith(folder + "/"));
  }
  static extractDateFromPath(path) {
    const firstPos = Math.max(0, path.lastIndexOf("/") + 1);
    const lastPos = path.lastIndexOf(".");
    const basename = path.substring(firstPos, lastPos);
    let dateMatch = /(\d{4})-(\d{2})-(\d{2})/.exec(basename);
    if (!dateMatch)
      dateMatch = /(\d{4})(\d{2})(\d{2})/.exec(basename);
    if (dateMatch) {
      const date = window.moment([parseInt(dateMatch[1]), parseInt(dateMatch[2]) - 1, parseInt(dateMatch[3])]);
      if (date.isValid()) {
        return date;
      }
    }
    return null;
  }
  static canApplyFallback({
    startDate,
    scheduledDate,
    dueDate
  }) {
    return startDate === null && dueDate === null && scheduledDate === null;
  }
  static updateTaskPath(task, newPath, fallbackDate) {
    let scheduledDate = task.scheduledDate;
    let scheduledDateIsInferred = task.scheduledDateIsInferred;
    if (fallbackDate === null) {
      if (scheduledDateIsInferred) {
        scheduledDateIsInferred = false;
        scheduledDate = null;
      } else {
      }
    } else {
      if (scheduledDateIsInferred) {
        scheduledDate = fallbackDate;
      } else if (this.canApplyFallback(task)) {
        scheduledDate = fallbackDate;
        scheduledDateIsInferred = true;
      } else {
      }
    }
    return new Task(__spreadProps(__spreadValues({}, task), {
      taskLocation: task.taskLocation.fromRenamedFile(newPath),
      scheduledDate,
      scheduledDateIsInferred
    }));
  }
  static removeInferredStatusIfNeeded(originalTask, updatedTasks) {
    const inferredScheduledDate = originalTask.scheduledDateIsInferred ? originalTask.scheduledDate : null;
    return updatedTasks.map((task) => {
      if (inferredScheduledDate !== null && !inferredScheduledDate.isSame(task.scheduledDate, "day")) {
        task = new Task(__spreadProps(__spreadValues({}, task), { scheduledDateIsInferred: false }));
      }
      return task;
    });
  }
};

// src/Scripting/TasksDate.ts
var TasksDate = class {
  constructor(date) {
    this._date = null;
    this._date = date;
  }
  get moment() {
    return this._date;
  }
  formatAsDate(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateFormat, fallBackText);
  }
  formatAsDateAndTime(fallBackText = "") {
    return this.format(TaskRegularExpressions.dateTimeFormat, fallBackText);
  }
  format(format, fallBackText = "") {
    return this._date ? this._date.format(format) : fallBackText;
  }
  toISOString(keepOffset) {
    return this._date ? this._date.toISOString(keepOffset) : "";
  }
};

// src/Scripting/TasksFile.ts
var TasksFile = class {
  constructor(path) {
    this._path = path;
  }
  get path() {
    return this._path;
  }
  get pathWithoutExtension() {
    return this.withoutExtension(this.path);
  }
  withoutExtension(value) {
    return value.replace(/\.md$/, "");
  }
  get root() {
    let path = this.path.replace(/\\/g, "/");
    if (path.charAt(0) === "/") {
      path = path.substring(1);
    }
    const separatorIndex = path.indexOf("/");
    if (separatorIndex == -1) {
      return "/";
    }
    return path.substring(0, separatorIndex + 1);
  }
  get folder() {
    const path = this.path;
    const fileNameWithExtension = this.filename;
    const folder = path.substring(0, path.lastIndexOf(fileNameWithExtension));
    if (folder === "") {
      return "/";
    }
    return folder;
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return "";
    }
  }
  get filenameWithoutExtension() {
    return this.withoutExtension(this.filename);
  }
};

// src/lib/PriorityTools.ts
var PriorityTools = class {
  static priorityNameUsingNone(priority) {
    let priorityName = "ERROR";
    switch (priority) {
      case "1" /* High */:
        priorityName = "High";
        break;
      case "0" /* Highest */:
        priorityName = "Highest";
        break;
      case "2" /* Medium */:
        priorityName = "Medium";
        break;
      case "3" /* None */:
        priorityName = "None";
        break;
      case "4" /* Low */:
        priorityName = "Low";
        break;
      case "5" /* Lowest */:
        priorityName = "Lowest";
        break;
    }
    return priorityName;
  }
  static priorityNameUsingNormal(priority) {
    return PriorityTools.priorityNameUsingNone(priority).replace("None", "Normal");
  }
};

// src/Task.ts
var _TaskRegularExpressions = class {
};
var TaskRegularExpressions = _TaskRegularExpressions;
TaskRegularExpressions.dateFormat = "YYYY-MM-DD";
TaskRegularExpressions.dateTimeFormat = "YYYY-MM-DD HH:mm";
TaskRegularExpressions.indentationRegex = /^([\s\t>]*)/;
TaskRegularExpressions.listMarkerRegex = /([-*+]|[0-9]+\.)/;
TaskRegularExpressions.checkboxRegex = /\[(.)\]/u;
TaskRegularExpressions.afterCheckboxRegex = / *(.*)/u;
TaskRegularExpressions.taskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + " +" + _TaskRegularExpressions.checkboxRegex.source + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.nonTaskRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source + "? *(" + _TaskRegularExpressions.checkboxRegex.source + ")?" + _TaskRegularExpressions.afterCheckboxRegex.source,
  "u"
);
TaskRegularExpressions.listItemRegex = new RegExp(
  _TaskRegularExpressions.indentationRegex.source + _TaskRegularExpressions.listMarkerRegex.source
);
TaskRegularExpressions.blockLinkRegex = / \^[a-zA-Z0-9-]+$/u;
TaskRegularExpressions.hashTags = /(^|\s)#[^ !@#$%^&*(),.?":{}|<>]+/g;
TaskRegularExpressions.hashTagsFromEnd = new RegExp(_TaskRegularExpressions.hashTags.source + "$");
var Task = class {
  constructor({
    status,
    description,
    taskLocation,
    indentation,
    listMarker,
    priority,
    createdDate,
    startDate,
    scheduledDate,
    dueDate,
    doneDate,
    recurrence,
    blockLink,
    tags,
    originalMarkdown,
    scheduledDateIsInferred
  }) {
    this._urgency = null;
    this.status = status;
    this.description = description;
    this.indentation = indentation;
    this.listMarker = listMarker;
    this.taskLocation = taskLocation;
    this.tags = tags;
    this.priority = priority;
    this.createdDate = createdDate;
    this.startDate = startDate;
    this.scheduledDate = scheduledDate;
    this.dueDate = dueDate;
    this.doneDate = doneDate;
    this.recurrence = recurrence;
    this.blockLink = blockLink;
    this.originalMarkdown = originalMarkdown;
    this.scheduledDateIsInferred = scheduledDateIsInferred;
  }
  static fromLine({
    line,
    taskLocation,
    fallbackDate
  }) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    if (!GlobalFilter.getInstance().includedIn(taskComponents.body)) {
      return null;
    }
    return Task.parseTaskSignifiers(line, taskLocation, fallbackDate);
  }
  static parseTaskSignifiers(line, taskLocation, fallbackDate) {
    const taskComponents = Task.extractTaskComponents(line);
    if (taskComponents === null) {
      return null;
    }
    const { taskSerializer } = getUserSelectedTaskFormat();
    const taskInfo = taskSerializer.deserialize(taskComponents.body);
    let scheduledDateIsInferred = false;
    if (DateFallback.canApplyFallback(taskInfo) && fallbackDate !== null) {
      taskInfo.scheduledDate = fallbackDate;
      scheduledDateIsInferred = true;
    }
    taskInfo.tags = taskInfo.tags.map((tag) => tag.trim());
    taskInfo.tags = taskInfo.tags.filter((tag) => !GlobalFilter.getInstance().equals(tag));
    return new Task(__spreadProps(__spreadValues(__spreadValues({}, taskComponents), taskInfo), {
      taskLocation,
      originalMarkdown: line,
      scheduledDateIsInferred
    }));
  }
  static extractTaskComponents(line) {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch === null) {
      return null;
    }
    const indentation = regexMatch[1];
    const listMarker = regexMatch[2];
    const statusString = regexMatch[3];
    const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
    let body = regexMatch[4].trim();
    const blockLinkMatch = body.match(TaskRegularExpressions.blockLinkRegex);
    const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
    if (blockLink !== "") {
      body = body.replace(TaskRegularExpressions.blockLinkRegex, "").trim();
    }
    return { indentation, listMarker, status, body, blockLink };
  }
  toString() {
    return getUserSelectedTaskFormat().taskSerializer.serialize(this);
  }
  toFileLineString() {
    return `${this.indentation}${this.listMarker} [${this.status.symbol}] ${this.toString()}`;
  }
  toggle() {
    const newStatus = StatusRegistry.getInstance().getNextStatusOrCreate(this.status);
    let newDoneDate = null;
    let nextOccurrence = null;
    if (newStatus.isCompleted()) {
      const { setDoneDate } = getSettings();
      if (setDoneDate) {
        newDoneDate = window.moment();
      }
      if (this.recurrence !== null) {
        nextOccurrence = this.recurrence.next();
      }
    }
    const toggledTask = new Task(__spreadProps(__spreadValues({}, this), {
      status: newStatus,
      doneDate: newDoneDate
    }));
    const newTasks = [];
    if (nextOccurrence !== null) {
      const { setCreatedDate } = getSettings();
      let createdDate = null;
      if (setCreatedDate) {
        createdDate = window.moment();
      }
      const nextStatus = StatusRegistry.getInstance().getNextStatusOrCreate(newStatus);
      const nextTask = new Task(__spreadProps(__spreadValues(__spreadValues({}, this), nextOccurrence), {
        status: nextStatus,
        blockLink: "",
        createdDate
      }));
      newTasks.push(nextTask);
    }
    newTasks.push(toggledTask);
    return newTasks;
  }
  toggleWithRecurrenceInUsersOrder() {
    const newTasks = this.toggle();
    const { recurrenceOnNextLine } = getSettings();
    return recurrenceOnNextLine ? newTasks.reverse() : newTasks;
  }
  get isDone() {
    return this.status.type === "DONE" /* DONE */ || this.status.type === "CANCELLED" /* CANCELLED */ || this.status.type === "NON_TASK" /* NON_TASK */;
  }
  get priorityNumber() {
    return Number.parseInt(this.priority);
  }
  get descriptionWithoutTags() {
    return this.description.replace(TaskRegularExpressions.hashTags, "").trim();
  }
  get priorityName() {
    return PriorityTools.priorityNameUsingNormal(this.priority);
  }
  get urgency() {
    if (this._urgency === null) {
      this._urgency = Urgency.calculate(this);
    }
    return this._urgency;
  }
  get path() {
    return this.taskLocation.path;
  }
  get created() {
    return new TasksDate(this.createdDate);
  }
  get done() {
    return new TasksDate(this.doneDate);
  }
  get due() {
    return new TasksDate(this.dueDate);
  }
  get scheduled() {
    return new TasksDate(this.scheduledDate);
  }
  get start() {
    return new TasksDate(this.startDate);
  }
  get happensDates() {
    return Array.of(this.startDate, this.scheduledDate, this.dueDate);
  }
  get happens() {
    const happensDates = this.happensDates;
    const sortedHappensDates = happensDates.sort(compareByDate);
    return new TasksDate(sortedHappensDates[0]);
  }
  get isRecurring() {
    return this.recurrence !== null;
  }
  get recurrenceRule() {
    return this.recurrence ? this.recurrence.toText() : "";
  }
  get heading() {
    return this.precedingHeader;
  }
  get hasHeading() {
    return this.precedingHeader !== null;
  }
  get file() {
    return new TasksFile(this.path);
  }
  get filename() {
    const fileNameMatch = this.path.match(/([^/]+)\.md$/);
    if (fileNameMatch !== null) {
      return fileNameMatch[1];
    } else {
      return null;
    }
  }
  get lineNumber() {
    return this.taskLocation.lineNumber;
  }
  get sectionStart() {
    return this.taskLocation.sectionStart;
  }
  get sectionIndex() {
    return this.taskLocation.sectionIndex;
  }
  get precedingHeader() {
    return this.taskLocation.precedingHeader;
  }
  getLinkText({ isFilenameUnique }) {
    let linkText;
    if (isFilenameUnique) {
      linkText = this.filename;
    } else {
      linkText = "/" + this.path;
    }
    if (linkText === null) {
      return null;
    }
    if (this.precedingHeader !== null && this.precedingHeader !== linkText) {
      linkText = linkText + " > " + this.precedingHeader;
    }
    return linkText;
  }
  static tasksListsIdentical(oldTasks, newTasks) {
    if (oldTasks.length !== newTasks.length) {
      return false;
    }
    return oldTasks.every((oldTask, index) => oldTask.identicalTo(newTasks[index]));
  }
  identicalTo(other) {
    let args = [
      "description",
      "path",
      "indentation",
      "listMarker",
      "lineNumber",
      "sectionStart",
      "sectionIndex",
      "precedingHeader",
      "priority",
      "blockLink",
      "scheduledDateIsInferred"
    ];
    for (const el of args) {
      if (this[el] !== other[el])
        return false;
    }
    if (!this.status.identicalTo(other.status)) {
      return false;
    }
    if (this.tags.length !== other.tags.length) {
      return false;
    }
    if (!this.tags.every(function(element2, index) {
      return element2 === other.tags[index];
    })) {
      return false;
    }
    args = ["createdDate", "startDate", "scheduledDate", "dueDate", "doneDate"];
    for (const el of args) {
      const date1 = this[el];
      const date2 = other[el];
      if (compareByDate(date1, date2) !== 0) {
        return false;
      }
    }
    const recurrence1 = this.recurrence;
    const recurrence2 = other.recurrence;
    if (recurrence1 === null && recurrence2 !== null) {
      return false;
    } else if (recurrence1 !== null && recurrence2 === null) {
      return false;
    } else if (recurrence1 && recurrence2 && !recurrence1.identicalTo(recurrence2)) {
      return false;
    }
    return true;
  }
  static extractHashtags(description) {
    var _a, _b;
    return (_b = (_a = description.match(TaskRegularExpressions.hashTags)) == null ? void 0 : _a.map((tag) => tag.trim())) != null ? _b : [];
  }
};

// src/lib/Lazy.ts
var Lazy = class {
  constructor(fetch) {
    this.fetch = fetch;
    this._value = void 0;
  }
  get value() {
    if (this._value === void 0) {
      this._value = this.fetch();
    }
    return this._value;
  }
};

// src/TaskLocation.ts
var TaskLocation = class {
  constructor(path, lineNumber, sectionStart, sectionIndex, precedingHeader) {
    this._path = path;
    this._lineNumber = lineNumber;
    this._sectionStart = sectionStart;
    this._sectionIndex = sectionIndex;
    this._precedingHeader = precedingHeader;
  }
  static fromUnknownPosition(path) {
    return new TaskLocation(path, 0, 0, 0, null);
  }
  fromRenamedFile(newPath) {
    return new TaskLocation(newPath, this.lineNumber, this.sectionStart, this.sectionIndex, this.precedingHeader);
  }
  get path() {
    return this._path;
  }
  get lineNumber() {
    return this._lineNumber;
  }
  get sectionStart() {
    return this._sectionStart;
  }
  get sectionIndex() {
    return this._sectionIndex;
  }
  get precedingHeader() {
    return this._precedingHeader;
  }
};

// src/Cache.ts
var Cache2 = class {
  constructor({ metadataCache: metadataCache2, vault: vault2, events }) {
    this.metadataCache = metadataCache2;
    this.metadataCacheEventReferences = [];
    this.vault = vault2;
    this.vaultEventReferences = [];
    this.events = events;
    this.eventsEventReferences = [];
    this.tasksMutex = new Mutex();
    this.state = "Cold" /* Cold */;
    this.tasks = [];
    this.loadedAfterFirstResolve = false;
    this.subscribeToCache();
    this.subscribeToVault();
    this.subscribeToEvents();
    this.loadVault();
  }
  unload() {
    for (const eventReference of this.metadataCacheEventReferences) {
      this.metadataCache.offref(eventReference);
    }
    for (const eventReference of this.vaultEventReferences) {
      this.vault.offref(eventReference);
    }
    for (const eventReference of this.eventsEventReferences) {
      this.events.off(eventReference);
    }
  }
  getTasks() {
    return this.tasks;
  }
  getState() {
    return this.state;
  }
  notifySubscribers() {
    this.events.triggerCacheUpdate({
      tasks: this.tasks,
      state: this.state
    });
  }
  subscribeToCache() {
    const resolvedEventeReference = this.metadataCache.on("resolved", () => __async(this, null, function* () {
      if (!this.loadedAfterFirstResolve) {
        this.loadedAfterFirstResolve = true;
        this.loadVault();
      }
    }));
    this.metadataCacheEventReferences.push(resolvedEventeReference);
    const changedEventReference = this.metadataCache.on("changed", (file) => {
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.metadataCacheEventReferences.push(changedEventReference);
  }
  subscribeToVault() {
    const { useFilenameAsScheduledDate } = getSettings();
    const createdEventReference = this.vault.on("create", (file) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        this.indexFile(file);
      });
    });
    this.vaultEventReferences.push(createdEventReference);
    const deletedEventReference = this.vault.on("delete", (file) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        this.tasks = this.tasks.filter((task) => {
          return task.path !== file.path;
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(deletedEventReference);
    const renamedEventReference = this.vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      this.tasksMutex.runExclusive(() => {
        const fallbackDate = new Lazy(() => DateFallback.fromPath(file.path));
        this.tasks = this.tasks.map((task) => {
          if (task.path === oldPath) {
            if (!useFilenameAsScheduledDate) {
              return new Task(__spreadProps(__spreadValues({}, task), {
                taskLocation: task.taskLocation.fromRenamedFile(file.path)
              }));
            } else {
              return DateFallback.updateTaskPath(task, file.path, fallbackDate.value);
            }
          } else {
            return task;
          }
        });
        this.notifySubscribers();
      });
    });
    this.vaultEventReferences.push(renamedEventReference);
  }
  subscribeToEvents() {
    const requestReference = this.events.onRequestCacheUpdate((handler) => {
      handler({ tasks: this.tasks, state: this.state });
    });
    this.eventsEventReferences.push(requestReference);
  }
  loadVault() {
    return this.tasksMutex.runExclusive(() => __async(this, null, function* () {
      this.state = "Initializing" /* Initializing */;
      yield Promise.all(
        this.vault.getMarkdownFiles().map((file) => {
          return this.indexFile(file);
        })
      );
      this.state = "Warm" /* Warm */;
      this.notifySubscribers();
    }));
  }
  indexFile(file) {
    return __async(this, null, function* () {
      const fileCache = this.metadataCache.getFileCache(file);
      if (fileCache === null || fileCache === void 0) {
        return;
      }
      const oldTasks = this.tasks.filter((task) => {
        return task.path === file.path;
      });
      const listItems = fileCache.listItems;
      let newTasks = [];
      if (listItems !== void 0) {
        const fileContent = yield this.vault.cachedRead(file);
        newTasks = this.getTasksFromFileContent(fileContent, listItems, fileCache, file);
      }
      if (Task.tasksListsIdentical(oldTasks, newTasks)) {
        return;
      }
      this.tasks = this.tasks.filter((task) => {
        return task.path !== file.path;
      });
      this.tasks.push(...newTasks);
      this.notifySubscribers();
    });
  }
  getTasksFromFileContent(fileContent, listItems, fileCache, file) {
    const tasks = [];
    const fileLines = fileContent.split("\n");
    const linesInFile = fileLines.length;
    const dateFromFileName = new Lazy(() => DateFallback.fromPath(file.path));
    let currentSection = null;
    let sectionIndex = 0;
    for (const listItem of listItems) {
      if (listItem.task !== void 0) {
        const lineNumber = listItem.position.start.line;
        if (lineNumber >= linesInFile) {
          console.log(
            `${file.path} Obsidian gave us a line number ${lineNumber} past the end of the file. ${linesInFile}.`
          );
          return tasks;
        }
        if (currentSection === null || currentSection.position.end.line < lineNumber) {
          currentSection = Cache2.getSection(lineNumber, fileCache.sections);
          sectionIndex = 0;
        }
        if (currentSection === null) {
          continue;
        }
        const line = fileLines[lineNumber];
        if (line === void 0) {
          console.log(`${file.path}: line ${lineNumber} - ignoring 'undefined' line.`);
          continue;
        }
        let task;
        try {
          task = Task.fromLine({
            line,
            taskLocation: new TaskLocation(
              file.path,
              lineNumber,
              currentSection.position.start.line,
              sectionIndex,
              Cache2.getPrecedingHeader(lineNumber, fileCache.headings)
            ),
            fallbackDate: dateFromFileName.value
          });
        } catch (e) {
          this.reportTaskParsingErrorToUser(e, file, listItem, line);
          continue;
        }
        if (task !== null) {
          sectionIndex++;
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  reportTaskParsingErrorToUser(e, file, listItem, line) {
    const msg = `There was an error reading one of the tasks in this vault.
The following task has been ignored, to prevent Tasks queries getting stuck with 'Loading Tasks ...'
Error: ${e}
File: ${file.path}
Line number: ${listItem.position.start.line}
Task line: ${line}

Please create a bug report for this message at
https://github.com/obsidian-tasks-group/obsidian-tasks/issues/new/choose
to help us find and fix the underlying issue.

Include:
- either a screenshot of the error popup, or copy the text from the console, if on a desktop machine.
- the output from running the Obsidian command 'Show debug info'

The error popup will only be shown when Tasks is starting up, but if the error persists,
it will be shown in the console every time this file is edited during the Obsidian
session.
`;
    console.error(msg);
    if (e instanceof Error) {
      console.error(e.stack);
    }
    if (this.state === "Initializing" /* Initializing */) {
      new import_obsidian.Notice(msg, 1e4);
    }
  }
  static getSection(lineNumberTask, sections) {
    if (sections === void 0) {
      return null;
    }
    for (const section of sections) {
      if (section.position.start.line <= lineNumberTask && section.position.end.line >= lineNumberTask) {
        return section;
      }
    }
    return null;
  }
  static getPrecedingHeader(lineNumberTask, headings) {
    if (headings === void 0) {
      return null;
    }
    let precedingHeader = null;
    for (const heading of headings) {
      if (heading.position.start.line > lineNumberTask) {
        return precedingHeader;
      }
      precedingHeader = heading.heading;
    }
    return precedingHeader;
  }
};

// src/Commands/CreateOrEdit.ts
var import_obsidian3 = require("obsidian");

// src/TaskModal.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function init_binding_group(group) {
  let _inputs;
  return {
    p(...inputs) {
      _inputs = inputs;
      _inputs.forEach((input) => group.push(input));
    },
    r() {
      _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
    }
  };
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeType === 11 ? "TEMPLATE" : target.nodeName);
      this.t = target.tagName !== "TEMPLATE" ? target : target.content;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/EditTask.svelte
var chrono2 = __toESM(require_dist());
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[48] = list[i].value;
  child_ctx[49] = list[i].label;
  child_ctx[50] = list[i].symbol;
  child_ctx[51] = list[i].accessKey;
  child_ctx[52] = list[i].accessKeyIndex;
  return child_ctx;
}
function create_if_block(ctx) {
  let span;
  let t_value = ctx[50] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_1(ctx) {
  let span3;
  let input;
  let input_id_value;
  let input_value_value;
  let input_accesskey_value;
  let t0;
  let label;
  let span0;
  let t1_value = ctx[49].substring(0, ctx[52]) + "";
  let t1;
  let span1;
  let t2_value = ctx[49].substring(ctx[52], ctx[52] + 1) + "";
  let t2;
  let span2;
  let t3_value = ctx[49].substring(ctx[52] + 1) + "";
  let t3;
  let t4;
  let show_if = ctx[50] && ctx[50].charCodeAt(0) >= 256;
  let label_for_value;
  let t5;
  let binding_group;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block(ctx);
  binding_group = init_binding_group(ctx[33][0]);
  return {
    c() {
      span3 = element("span");
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      t1 = text(t1_value);
      span1 = element("span");
      t2 = text(t2_value);
      span2 = element("span");
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
      t5 = space();
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = "priority-" + ctx[48]);
      input.__value = input_value_value = ctx[48];
      input.value = input.__value;
      attr(input, "accesskey", input_accesskey_value = ctx[15](ctx[51]));
      attr(span1, "class", "accesskey");
      attr(label, "for", label_for_value = "priority-" + ctx[48]);
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, span3, anchor);
      append(span3, input);
      input.checked = input.__value === ctx[1].priority;
      append(span3, t0);
      append(span3, label);
      append(label, span0);
      append(span0, t1);
      append(label, span1);
      append(span1, t2);
      append(label, span2);
      append(span2, t3);
      append(label, t4);
      if (if_block)
        if_block.m(label, null);
      append(span3, t5);
      if (!mounted) {
        dispose = listen(input, "change", ctx[32]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768 && input_accesskey_value !== (input_accesskey_value = ctx2[15](ctx2[51]))) {
        attr(input, "accesskey", input_accesskey_value);
      }
      if (dirty[0] & 3) {
        input.checked = input.__value === ctx2[1].priority;
      }
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span3);
      if (if_block)
        if_block.d();
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let option;
  let t0_value = ctx[45].name + "";
  let t0;
  let t1;
  let t2_value = ctx[45].symbol + "";
  let t2;
  let t3;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = text(" [");
      t2 = text(t2_value);
      t3 = text("]");
      option.__value = option_value_value = ctx[45];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
      append(option, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t0_value !== (t0_value = ctx2[45].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[45].symbol + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 1 && option_value_value !== (option_value_value = ctx2[45])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment(ctx) {
  let div10;
  let form;
  let div0;
  let label0;
  let t3;
  let textarea;
  let textarea_accesskey_value;
  let t4;
  let div1;
  let label1;
  let t5;
  let label1_for_value;
  let t6;
  let t7;
  let div3;
  let label2;
  let t9;
  let input0;
  let input0_accesskey_value;
  let t10;
  let code0;
  let t11;
  let t12;
  let html_tag;
  let t13;
  let label3;
  let t15;
  let input1;
  let input1_accesskey_value;
  let t16;
  let code1;
  let t17;
  let t18;
  let html_tag_1;
  let t19;
  let label4;
  let t21;
  let input2;
  let input2_accesskey_value;
  let t22;
  let code2;
  let t23;
  let t24;
  let html_tag_2;
  let t25;
  let label5;
  let t29;
  let input3;
  let input3_accesskey_value;
  let t30;
  let code3;
  let t31;
  let t32;
  let html_tag_3;
  let t33;
  let div2;
  let label6;
  let t37;
  let input4;
  let input4_accesskey_value;
  let t38;
  let div4;
  let label7;
  let t42;
  let select;
  let select_accesskey_value;
  let t43;
  let div8;
  let div5;
  let label8;
  let t45;
  let input5;
  let input5_checked_value;
  let t46;
  let div6;
  let span4;
  let t48;
  let code4;
  let t49;
  let div7;
  let span5;
  let t51;
  let code5;
  let t52;
  let div9;
  let button0;
  let t53;
  let button0_disabled_value;
  let t54;
  let button1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[20];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div10 = element("div");
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      label0.innerHTML = `Descrip<span class="accesskey">t</span>ion`;
      t3 = space();
      textarea = element("textarea");
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      t5 = text("Priority");
      t6 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t7 = space();
      div3 = element("div");
      label2 = element("label");
      label2.textContent = "Recurs";
      t9 = space();
      input0 = element("input");
      t10 = space();
      code0 = element("code");
      t11 = text(ctx[16]);
      t12 = space();
      html_tag = new HtmlTag(false);
      t13 = space();
      label3 = element("label");
      label3.textContent = "Due";
      t15 = space();
      input1 = element("input");
      t16 = space();
      code1 = element("code");
      t17 = text(ctx[19]);
      t18 = space();
      html_tag_1 = new HtmlTag(false);
      t19 = space();
      label4 = element("label");
      label4.textContent = "Scheduled";
      t21 = space();
      input2 = element("input");
      t22 = space();
      code2 = element("code");
      t23 = text(ctx[18]);
      t24 = space();
      html_tag_2 = new HtmlTag(false);
      t25 = space();
      label5 = element("label");
      label5.innerHTML = `St<span class="accesskey">a</span>rt`;
      t29 = space();
      input3 = element("input");
      t30 = space();
      code3 = element("code");
      t31 = text(ctx[17]);
      t32 = space();
      html_tag_3 = new HtmlTag(false);
      t33 = space();
      div2 = element("div");
      label6 = element("label");
      label6.innerHTML = `Only
                    <span class="accesskey-first">future</span> dates:`;
      t37 = space();
      input4 = element("input");
      t38 = space();
      div4 = element("div");
      label7 = element("label");
      label7.innerHTML = `Stat<span class="accesskey">u</span>s`;
      t42 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t43 = space();
      div8 = element("div");
      div5 = element("div");
      label8 = element("label");
      label8.textContent = "Completed:";
      t45 = space();
      input5 = element("input");
      t46 = space();
      div6 = element("div");
      span4 = element("span");
      span4.textContent = "Created on:";
      t48 = space();
      code4 = element("code");
      t49 = space();
      div7 = element("div");
      span5 = element("span");
      span5.textContent = "Done on:";
      t51 = space();
      code5 = element("code");
      t52 = space();
      div9 = element("div");
      button0 = element("button");
      t53 = text("Apply");
      t54 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(label0, "for", "description");
      attr(textarea, "id", "description");
      attr(textarea, "class", "tasks-modal-description");
      attr(textarea, "placeholder", "Take out the trash");
      attr(textarea, "accesskey", textarea_accesskey_value = ctx[15]("t"));
      attr(div0, "class", "tasks-modal-section");
      attr(label1, "for", label1_for_value = "priority-" + ctx[1].priority);
      attr(div1, "class", "tasks-modal-section tasks-modal-priorities");
      attr(label2, "for", "recurrence");
      attr(label2, "class", "accesskey-first");
      attr(input0, "id", "recurrence");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Try 'every 2 weeks on Thursday'.");
      attr(input0, "accesskey", input0_accesskey_value = ctx[15]("r"));
      toggle_class(input0, "tasks-modal-error", !ctx[8]);
      html_tag.a = null;
      attr(label3, "for", "due");
      attr(label3, "class", "accesskey-first");
      attr(input1, "id", "due");
      attr(input1, "type", "text");
      attr(input1, "placeholder", datePlaceholder);
      attr(input1, "accesskey", input1_accesskey_value = ctx[15]("d"));
      toggle_class(input1, "tasks-modal-error", !ctx[7]);
      html_tag_1.a = null;
      attr(label4, "for", "scheduled");
      attr(label4, "class", "accesskey-first");
      attr(input2, "id", "scheduled");
      attr(input2, "type", "text");
      attr(input2, "placeholder", datePlaceholder);
      attr(input2, "accesskey", input2_accesskey_value = ctx[15]("s"));
      toggle_class(input2, "tasks-modal-error", !ctx[5]);
      html_tag_2.a = null;
      attr(label5, "for", "start");
      attr(input3, "id", "start");
      attr(input3, "type", "text");
      attr(input3, "placeholder", datePlaceholder);
      attr(input3, "accesskey", input3_accesskey_value = ctx[15]("a"));
      toggle_class(input3, "tasks-modal-error", !ctx[3]);
      html_tag_3.a = null;
      attr(label6, "for", "forwardOnly");
      attr(input4, "id", "forwardOnly");
      attr(input4, "type", "checkbox");
      attr(input4, "class", "task-list-item-checkbox tasks-modal-checkbox");
      attr(input4, "accesskey", input4_accesskey_value = ctx[15]("f"));
      attr(div3, "class", "tasks-modal-section tasks-modal-dates");
      attr(label7, "for", "status");
      attr(select, "id", "status-type");
      attr(select, "class", "dropdown");
      attr(select, "accesskey", select_accesskey_value = ctx[15]("u"));
      if (ctx[1].status === void 0)
        add_render_callback(() => ctx[39].call(select));
      attr(div4, "class", "tasks-modal-section");
      attr(label8, "for", "status");
      attr(input5, "id", "status");
      attr(input5, "type", "checkbox");
      attr(input5, "class", "task-list-item-checkbox tasks-modal-checkbox");
      input5.checked = input5_checked_value = ctx[1].status.isCompleted();
      input5.disabled = true;
      attr(div8, "class", "tasks-modal-section tasks-modal-status");
      button0.disabled = button0_disabled_value = !ctx[14];
      attr(button0, "type", "submit");
      attr(button0, "class", "mod-cta");
      attr(button1, "type", "button");
      attr(div9, "class", "tasks-modal-section tasks-modal-buttons");
      toggle_class(form, "with-accesskeys", ctx[9]);
      attr(div10, "class", "tasks-modal");
    },
    m(target, anchor) {
      insert(target, div10, anchor);
      append(div10, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t3);
      append(div0, textarea);
      set_input_value(textarea, ctx[1].description);
      ctx[31](textarea);
      append(form, t4);
      append(form, div1);
      append(div1, label1);
      append(label1, t5);
      append(div1, t6);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append(form, t7);
      append(form, div3);
      append(div3, label2);
      append(div3, t9);
      append(div3, input0);
      set_input_value(input0, ctx[1].recurrenceRule);
      append(div3, t10);
      append(div3, code0);
      append(code0, t11);
      append(code0, t12);
      html_tag.m(ctx[12], code0);
      append(div3, t13);
      append(div3, label3);
      append(div3, t15);
      append(div3, input1);
      set_input_value(input1, ctx[1].dueDate);
      append(div3, t16);
      append(div3, code1);
      append(code1, t17);
      append(code1, t18);
      html_tag_1.m(ctx[6], code1);
      append(div3, t19);
      append(div3, label4);
      append(div3, t21);
      append(div3, input2);
      set_input_value(input2, ctx[1].scheduledDate);
      append(div3, t22);
      append(div3, code2);
      append(code2, t23);
      append(code2, t24);
      html_tag_2.m(ctx[4], code2);
      append(div3, t25);
      append(div3, label5);
      append(div3, t29);
      append(div3, input3);
      set_input_value(input3, ctx[1].startDate);
      append(div3, t30);
      append(div3, code3);
      append(code3, t31);
      append(code3, t32);
      html_tag_3.m(ctx[2], code3);
      append(div3, t33);
      append(div3, div2);
      append(div2, label6);
      append(div2, t37);
      append(div2, input4);
      input4.checked = ctx[1].forwardOnly;
      append(form, t38);
      append(form, div4);
      append(div4, label7);
      append(div4, t42);
      append(div4, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[1].status, true);
      append(form, t43);
      append(form, div8);
      append(div8, div5);
      append(div5, label8);
      append(div5, t45);
      append(div5, input5);
      append(div8, t46);
      append(div8, div6);
      append(div6, span4);
      append(div6, t48);
      append(div6, code4);
      code4.innerHTML = ctx[11];
      append(div8, t49);
      append(div8, div7);
      append(div7, span5);
      append(div7, t51);
      append(div7, code5);
      code5.innerHTML = ctx[13];
      append(form, t52);
      append(form, div9);
      append(div9, button0);
      append(button0, t53);
      append(div9, t54);
      append(div9, button1);
      if (!mounted) {
        dispose = [
          listen(textarea, "input", ctx[30]),
          listen(textarea, "keydown", ctx[23]),
          listen(textarea, "paste", ctx[24]),
          listen(textarea, "drop", ctx[24]),
          listen(div1, "keyup", ctx[21]),
          listen(input0, "input", ctx[34]),
          listen(input1, "input", ctx[35]),
          listen(input2, "input", ctx[36]),
          listen(input3, "input", ctx[37]),
          listen(input4, "change", ctx[38]),
          listen(select, "change", ctx[39]),
          listen(button1, "click", ctx[22]),
          listen(form, "submit", prevent_default(ctx[25]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768 && textarea_accesskey_value !== (textarea_accesskey_value = ctx2[15]("t"))) {
        attr(textarea, "accesskey", textarea_accesskey_value);
      }
      if (dirty[0] & 3) {
        set_input_value(textarea, ctx2[1].description);
      }
      if (dirty[0] & 3 && label1_for_value !== (label1_for_value = "priority-" + ctx2[1].priority)) {
        attr(label1, "for", label1_for_value);
      }
      if (dirty[0] & 1081346) {
        each_value_1 = ctx2[20];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty[0] & 32768 && input0_accesskey_value !== (input0_accesskey_value = ctx2[15]("r"))) {
        attr(input0, "accesskey", input0_accesskey_value);
      }
      if (dirty[0] & 3 && input0.value !== ctx2[1].recurrenceRule) {
        set_input_value(input0, ctx2[1].recurrenceRule);
      }
      if (dirty[0] & 256) {
        toggle_class(input0, "tasks-modal-error", !ctx2[8]);
      }
      if (dirty[0] & 4096)
        html_tag.p(ctx2[12]);
      if (dirty[0] & 32768 && input1_accesskey_value !== (input1_accesskey_value = ctx2[15]("d"))) {
        attr(input1, "accesskey", input1_accesskey_value);
      }
      if (dirty[0] & 3 && input1.value !== ctx2[1].dueDate) {
        set_input_value(input1, ctx2[1].dueDate);
      }
      if (dirty[0] & 128) {
        toggle_class(input1, "tasks-modal-error", !ctx2[7]);
      }
      if (dirty[0] & 64)
        html_tag_1.p(ctx2[6]);
      if (dirty[0] & 32768 && input2_accesskey_value !== (input2_accesskey_value = ctx2[15]("s"))) {
        attr(input2, "accesskey", input2_accesskey_value);
      }
      if (dirty[0] & 3 && input2.value !== ctx2[1].scheduledDate) {
        set_input_value(input2, ctx2[1].scheduledDate);
      }
      if (dirty[0] & 32) {
        toggle_class(input2, "tasks-modal-error", !ctx2[5]);
      }
      if (dirty[0] & 16)
        html_tag_2.p(ctx2[4]);
      if (dirty[0] & 32768 && input3_accesskey_value !== (input3_accesskey_value = ctx2[15]("a"))) {
        attr(input3, "accesskey", input3_accesskey_value);
      }
      if (dirty[0] & 3 && input3.value !== ctx2[1].startDate) {
        set_input_value(input3, ctx2[1].startDate);
      }
      if (dirty[0] & 8) {
        toggle_class(input3, "tasks-modal-error", !ctx2[3]);
      }
      if (dirty[0] & 4)
        html_tag_3.p(ctx2[2]);
      if (dirty[0] & 32768 && input4_accesskey_value !== (input4_accesskey_value = ctx2[15]("f"))) {
        attr(input4, "accesskey", input4_accesskey_value);
      }
      if (dirty[0] & 3) {
        input4.checked = ctx2[1].forwardOnly;
      }
      if (dirty[0] & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 32768 && select_accesskey_value !== (select_accesskey_value = ctx2[15]("u"))) {
        attr(select, "accesskey", select_accesskey_value);
      }
      if (dirty[0] & 3) {
        select_option(select, ctx2[1].status);
      }
      if (dirty[0] & 3 && input5_checked_value !== (input5_checked_value = ctx2[1].status.isCompleted())) {
        input5.checked = input5_checked_value;
      }
      if (dirty[0] & 2048)
        code4.innerHTML = ctx2[11];
      ;
      if (dirty[0] & 8192)
        code5.innerHTML = ctx2[13];
      ;
      if (dirty[0] & 16384 && button0_disabled_value !== (button0_disabled_value = !ctx2[14])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty[0] & 512) {
        toggle_class(form, "with-accesskeys", ctx2[9]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div10);
      ctx[31](null);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
var datePlaceholder = "Try 'Monday' or 'tomorrow', or [td|tm|yd|tw|nw|we] then space.";
function instance($$self, $$props, $$invalidate) {
  let accesskey;
  var _a;
  let { task } = $$props;
  let { onSubmit } = $$props;
  let { statusOptions } = $$props;
  const { prioritySymbols, recurrenceSymbol, startDateSymbol, scheduledDateSymbol, dueDateSymbol } = TASK_FORMATS.tasksPluginEmoji.taskSerializer.symbols;
  let descriptionInput;
  let editableTask = {
    description: "",
    status: Status.TODO,
    priority: "none",
    recurrenceRule: "",
    createdDate: "",
    startDate: "",
    scheduledDate: "",
    dueDate: "",
    doneDate: "",
    forwardOnly: true
  };
  let isDescriptionValid = true;
  let parsedCreated = "";
  let parsedStartDate = "";
  let isStartDateValid = true;
  let parsedScheduledDate = "";
  let isScheduledDateValid = true;
  let parsedDueDate = "";
  let isDueDateValid = true;
  let parsedRecurrence = "";
  let isRecurrenceValid = true;
  let parsedDone = "";
  let addGlobalFilterOnSave = false;
  let withAccessKeys = true;
  let formIsValid = true;
  const priorityOptions = [
    {
      value: "lowest",
      label: "Lowest",
      symbol: prioritySymbols.Lowest,
      accessKey: "o",
      accessKeyIndex: 1
    },
    {
      value: "low",
      label: "Low",
      symbol: prioritySymbols.Low,
      accessKey: "l",
      accessKeyIndex: 0
    },
    {
      value: "none",
      label: "Normal",
      symbol: prioritySymbols.None,
      accessKey: "n",
      accessKeyIndex: 0
    },
    {
      value: "medium",
      label: "Medium",
      symbol: prioritySymbols.Medium,
      accessKey: "m",
      accessKeyIndex: 0
    },
    {
      value: "high",
      label: "High",
      symbol: prioritySymbols.High,
      accessKey: "h",
      accessKeyIndex: 0
    },
    {
      value: "highest",
      label: "Highest",
      symbol: prioritySymbols.Highest,
      accessKey: "i",
      accessKeyIndex: 1
    }
  ];
  function parseTypedDateForDisplay(fieldName, typedDate, forwardDate = void 0) {
    if (!typedDate) {
      return `<i>no ${fieldName} date</i>`;
    }
    const parsed = chrono2.parseDate(typedDate, forwardDate, { forwardDate: forwardDate != void 0 });
    if (parsed !== null) {
      return window.moment(parsed).format("YYYY-MM-DD");
    }
    return `<i>invalid ${fieldName} date</i>`;
  }
  function parseTypedDateForDisplayUsingFutureDate(fieldName, typedDate) {
    return parseTypedDateForDisplay(fieldName, typedDate, editableTask.forwardOnly ? new Date() : void 0);
  }
  function parseTypedDateForSaving(typedDate) {
    let date = null;
    const parsedDate = chrono2.parseDate(typedDate, new Date(), { forwardDate: editableTask.forwardOnly });
    if (parsedDate !== null) {
      date = window.moment(parsedDate);
    }
    return date;
  }
  onMount(() => {
    const { provideAccessKeys } = getSettings();
    $$invalidate(9, withAccessKeys = provideAccessKeys);
    const description = GlobalFilter.getInstance().removeAsWordFrom(task.description);
    if (description != task.description || !GlobalFilter.getInstance().includedIn(task.description)) {
      addGlobalFilterOnSave = true;
    }
    let priority = "none";
    if (task.priority === "5" /* Lowest */) {
      priority = "lowest";
    } else if (task.priority === "4" /* Low */) {
      priority = "low";
    } else if (task.priority === "2" /* Medium */) {
      priority = "medium";
    } else if (task.priority === "1" /* High */) {
      priority = "high";
    } else if (task.priority === "0" /* Highest */) {
      priority = "highest";
    }
    $$invalidate(1, editableTask = {
      description,
      status: task.status,
      priority,
      recurrenceRule: task.recurrence ? task.recurrence.toText() : "",
      createdDate: new TasksDate(task.createdDate).formatAsDate(),
      startDate: new TasksDate(task.startDate).formatAsDate(),
      scheduledDate: new TasksDate(task.scheduledDate).formatAsDate(),
      dueDate: new TasksDate(task.dueDate).formatAsDate(),
      doneDate: new TasksDate(task.doneDate).formatAsDate(),
      forwardOnly: true
    });
    setTimeout(
      () => {
        descriptionInput.focus();
      },
      10
    );
  });
  const _onPriorityKeyup = (event) => {
    if (event.key && !event.altKey && !event.ctrlKey) {
      const priorityOption = priorityOptions.find((option) => option.label.charAt(0).toLowerCase() == event.key);
      if (priorityOption) {
        $$invalidate(1, editableTask.priority = priorityOption.value, editableTask);
      }
    }
  };
  const _onClose = () => {
    onSubmit([]);
  };
  const _onDescriptionKeyDown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (formIsValid)
        _onSubmit();
    }
  };
  const _removeLinebreaksFromDescription = () => {
    setTimeout(
      () => {
        $$invalidate(1, editableTask.description = editableTask.description.replace(/[\r\n]+/g, " "), editableTask);
      },
      0
    );
  };
  const _onSubmit = () => {
    let description = editableTask.description.trim();
    if (addGlobalFilterOnSave) {
      description = GlobalFilter.getInstance().prependTo(description);
    }
    const startDate = parseTypedDateForSaving(editableTask.startDate);
    const scheduledDate = parseTypedDateForSaving(editableTask.scheduledDate);
    const dueDate = parseTypedDateForSaving(editableTask.dueDate);
    let recurrence = null;
    if (editableTask.recurrenceRule) {
      recurrence = Recurrence.fromText({
        recurrenceRuleText: editableTask.recurrenceRule,
        startDate,
        scheduledDate,
        dueDate
      });
    }
    let parsedPriority;
    switch (editableTask.priority) {
      case "lowest":
        parsedPriority = "5" /* Lowest */;
        break;
      case "low":
        parsedPriority = "4" /* Low */;
        break;
      case "medium":
        parsedPriority = "2" /* Medium */;
        break;
      case "high":
        parsedPriority = "1" /* High */;
        break;
      case "highest":
        parsedPriority = "0" /* Highest */;
        break;
      default:
        parsedPriority = "3" /* None */;
    }
    const updatedTask = new Task(Object.assign(Object.assign({}, task), {
      description,
      status: editableTask.status,
      priority: parsedPriority,
      recurrence,
      startDate,
      scheduledDate,
      dueDate,
      doneDate: window.moment(editableTask.doneDate, "YYYY-MM-DD").isValid() ? window.moment(editableTask.doneDate, "YYYY-MM-DD") : null
    }));
    onSubmit([updatedTask]);
  };
  const $$binding_groups = [[]];
  function textarea_input_handler() {
    editableTask.description = this.value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      descriptionInput = $$value;
      $$invalidate(10, descriptionInput);
    });
  }
  function input_change_handler() {
    editableTask.priority = this.__value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function input0_input_handler() {
    editableTask.recurrenceRule = this.value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function input1_input_handler() {
    editableTask.dueDate = this.value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function input2_input_handler() {
    editableTask.scheduledDate = this.value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function input3_input_handler() {
    editableTask.startDate = this.value;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function input4_change_handler() {
    editableTask.forwardOnly = this.checked;
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  function select_change_handler() {
    editableTask.status = select_value(this);
    $$invalidate(1, editableTask), $$invalidate(6, parsedDueDate), $$invalidate(2, parsedStartDate), $$invalidate(4, parsedScheduledDate);
    $$invalidate(0, statusOptions);
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2)
      $$invalidate(26, task = $$props2.task);
    if ("onSubmit" in $$props2)
      $$invalidate(27, onSubmit = $$props2.onSubmit);
    if ("statusOptions" in $$props2)
      $$invalidate(0, statusOptions = $$props2.statusOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 512) {
      $:
        $$invalidate(15, accesskey = (key) => withAccessKeys ? key : null);
    }
    if ($$self.$$.dirty[0] & 66) {
      $: {
        $$invalidate(1, editableTask.dueDate = doAutocomplete(editableTask.dueDate), editableTask);
        $$invalidate(6, parsedDueDate = parseTypedDateForDisplayUsingFutureDate("due", editableTask.dueDate));
        $$invalidate(7, isDueDateValid = !parsedDueDate.includes("invalid"));
      }
    }
    if ($$self.$$.dirty[0] & 6) {
      $: {
        $$invalidate(1, editableTask.startDate = doAutocomplete(editableTask.startDate), editableTask);
        $$invalidate(2, parsedStartDate = parseTypedDateForDisplayUsingFutureDate("start", editableTask.startDate));
        $$invalidate(3, isStartDateValid = !parsedStartDate.includes("invalid"));
      }
    }
    if ($$self.$$.dirty[0] & 18) {
      $: {
        $$invalidate(1, editableTask.scheduledDate = doAutocomplete(editableTask.scheduledDate), editableTask);
        $$invalidate(4, parsedScheduledDate = parseTypedDateForDisplayUsingFutureDate("scheduled", editableTask.scheduledDate));
        $$invalidate(5, isScheduledDateValid = !parsedScheduledDate.includes("invalid"));
      }
    }
    if ($$self.$$.dirty[0] & 268435458) {
      $: {
        $$invalidate(8, isRecurrenceValid = true);
        if (!editableTask.recurrenceRule) {
          $$invalidate(12, parsedRecurrence = "<i>not recurring</>");
        } else {
          const recurrenceFromText = $$invalidate(28, _a = Recurrence.fromText({
            recurrenceRuleText: editableTask.recurrenceRule,
            startDate: null,
            scheduledDate: null,
            dueDate: null
          })) === null || _a === void 0 ? void 0 : _a.toText();
          if (!recurrenceFromText) {
            $$invalidate(12, parsedRecurrence = "<i>invalid recurrence rule</i>");
            $$invalidate(8, isRecurrenceValid = false);
          } else {
            $$invalidate(12, parsedRecurrence = recurrenceFromText);
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(29, isDescriptionValid = editableTask.description.trim() !== "");
    }
    if ($$self.$$.dirty[0] & 536871336) {
      $:
        $$invalidate(14, formIsValid = isDueDateValid && isRecurrenceValid && isScheduledDateValid && isStartDateValid && isDescriptionValid);
    }
    if ($$self.$$.dirty[0] & 2) {
      $: {
        $$invalidate(11, parsedCreated = parseTypedDateForDisplay("created", editableTask.createdDate));
        $$invalidate(13, parsedDone = parseTypedDateForDisplay("done", editableTask.doneDate));
      }
    }
  };
  return [
    statusOptions,
    editableTask,
    parsedStartDate,
    isStartDateValid,
    parsedScheduledDate,
    isScheduledDateValid,
    parsedDueDate,
    isDueDateValid,
    isRecurrenceValid,
    withAccessKeys,
    descriptionInput,
    parsedCreated,
    parsedRecurrence,
    parsedDone,
    formIsValid,
    accesskey,
    recurrenceSymbol,
    startDateSymbol,
    scheduledDateSymbol,
    dueDateSymbol,
    priorityOptions,
    _onPriorityKeyup,
    _onClose,
    _onDescriptionKeyDown,
    _removeLinebreaksFromDescription,
    _onSubmit,
    task,
    onSubmit,
    _a,
    isDescriptionValid,
    textarea_input_handler,
    textarea_binding,
    input_change_handler,
    $$binding_groups,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_change_handler,
    select_change_handler
  ];
}
var EditTask = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { task: 26, onSubmit: 27, statusOptions: 0 }, null, [-1, -1]);
  }
};
var EditTask_default = EditTask;

// src/TaskModal.ts
var TaskModal = class extends import_obsidian2.Modal {
  constructor({ app: app2, task, onSubmit }) {
    super(app2);
    this.task = task;
    this.onSubmit = (updatedTasks) => {
      updatedTasks.length && onSubmit(updatedTasks);
      this.close();
    };
  }
  onOpen() {
    this.titleEl.setText("Create or edit Task");
    const { contentEl } = this;
    const statusOptions = this.getKnownStatusesAndCurrentTaskStatusIfNotKnown();
    new EditTask_default({
      target: contentEl,
      props: { task: this.task, statusOptions, onSubmit: this.onSubmit }
    });
  }
  getKnownStatusesAndCurrentTaskStatusIfNotKnown() {
    const statusOptions = StatusRegistry.getInstance().registeredStatuses;
    if (StatusRegistry.getInstance().bySymbol(this.task.status.symbol) === Status.EMPTY) {
      statusOptions.push(this.task.status);
    }
    return statusOptions;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Commands/CreateOrEditTaskParser.ts
function getDefaultCreatedDate() {
  const { setCreatedDate } = getSettings();
  return setCreatedDate ? window.moment() : null;
}
function shouldUpdateCreatedDateForTask(task) {
  const { setCreatedDate } = getSettings();
  if (!setCreatedDate) {
    return false;
  }
  if (task.createdDate !== null) {
    return false;
  }
  const descriptionIsEmpty = task.description === "";
  const globalFilterEnabled = !GlobalFilter.getInstance().isEmpty();
  const taskDoesNotContainGlobalFilter = !GlobalFilter.getInstance().includedIn(task.description);
  const needsGlobalFilterToBeAdded = globalFilterEnabled && taskDoesNotContainGlobalFilter;
  return descriptionIsEmpty || needsGlobalFilterToBeAdded;
}
var taskFromLine = ({ line, path }) => {
  var _a, _b;
  const task = Task.parseTaskSignifiers(
    line,
    TaskLocation.fromUnknownPosition(path),
    DateFallback.fromPath(path)
  );
  const createdDate = getDefaultCreatedDate();
  if (task !== null) {
    if (shouldUpdateCreatedDateForTask(task)) {
      return new Task(__spreadProps(__spreadValues({}, task), { createdDate }));
    }
    return task;
  }
  const nonTaskMatch = line.match(TaskRegularExpressions.nonTaskRegex);
  if (nonTaskMatch === null) {
    console.error("Tasks: Cannot create task on line:", line);
    return new Task({
      status: Status.TODO,
      description: "",
      taskLocation: TaskLocation.fromUnknownPosition(path),
      indentation: "",
      listMarker: "-",
      priority: "3" /* None */,
      createdDate,
      startDate: null,
      scheduledDate: null,
      dueDate: null,
      doneDate: null,
      recurrence: null,
      blockLink: "",
      tags: [],
      originalMarkdown: "",
      scheduledDateIsInferred: false
    });
  }
  const indentation = nonTaskMatch[1];
  const listMarker = (_a = nonTaskMatch[2]) != null ? _a : "-";
  const statusString = (_b = nonTaskMatch[4]) != null ? _b : " ";
  const status = StatusRegistry.getInstance().bySymbolOrCreate(statusString);
  let description = nonTaskMatch[5];
  const blockLinkMatch = line.match(TaskRegularExpressions.blockLinkRegex);
  const blockLink = blockLinkMatch !== null ? blockLinkMatch[0] : "";
  if (blockLink !== "") {
    description = description.replace(TaskRegularExpressions.blockLinkRegex, "");
  }
  return new Task({
    status,
    description,
    taskLocation: TaskLocation.fromUnknownPosition(path),
    indentation,
    listMarker,
    blockLink,
    priority: "3" /* None */,
    createdDate,
    startDate: null,
    scheduledDate: null,
    dueDate: null,
    doneDate: null,
    recurrence: null,
    tags: [],
    originalMarkdown: "",
    scheduledDateIsInferred: false
  });
};

// src/Commands/CreateOrEdit.ts
var createOrEdit = (checking, editor, view, app2) => {
  var _a;
  if (checking) {
    return view instanceof import_obsidian3.MarkdownView;
  }
  if (!(view instanceof import_obsidian3.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const cursorPosition = editor.getCursor();
  const lineNumber = cursorPosition.line;
  const line = editor.getLine(lineNumber);
  const task = taskFromLine({ line, path });
  const onSubmit = (updatedTasks) => {
    const serialized = DateFallback.removeInferredStatusIfNeeded(task, updatedTasks).map((task2) => task2.toFileLineString()).join("\n");
    editor.setLine(lineNumber, serialized);
  };
  const taskModal = new TaskModal({
    app: app2,
    task,
    onSubmit
  });
  taskModal.open();
};

// src/Commands/ToggleDone.ts
var import_obsidian4 = require("obsidian");
var toggleDone = (checking, editor, view) => {
  var _a;
  if (checking) {
    if (!(view instanceof import_obsidian4.MarkdownView)) {
      return false;
    }
    return true;
  }
  if (!(view instanceof import_obsidian4.MarkdownView)) {
    return;
  }
  const path = (_a = view.file) == null ? void 0 : _a.path;
  if (path === void 0) {
    return;
  }
  const origCursorPos = editor.getCursor();
  const lineNumber = origCursorPos.line;
  const line = editor.getLine(lineNumber);
  const insertion = toggleLine(line, path);
  editor.setLine(lineNumber, insertion.text);
  editor.setCursor(getNewCursorPosition(origCursorPos, insertion));
};
var toggleLine = (line, path) => {
  const task = Task.fromLine({
    line,
    taskLocation: TaskLocation.fromUnknownPosition(path),
    fallbackDate: null
  });
  if (task !== null) {
    const lines = task.toggleWithRecurrenceInUsersOrder().map((t) => t.toFileLineString());
    return { text: lines.join("\n"), moveTo: { line: lines.length - 1 } };
  } else {
    const regexMatch = line.match(TaskRegularExpressions.taskRegex);
    if (regexMatch !== null) {
      const statusString = regexMatch[3];
      const status = StatusRegistry.getInstance().bySymbol(statusString);
      const newStatusString = status.nextStatusSymbol;
      return { text: line.replace(TaskRegularExpressions.taskRegex, `$1- [${newStatusString}] $4`) };
    } else if (TaskRegularExpressions.listItemRegex.test(line)) {
      const text2 = line.replace(TaskRegularExpressions.listItemRegex, "$1$2 [ ]");
      return { text: text2, moveTo: { ch: text2.length } };
    } else {
      const text2 = line.replace(TaskRegularExpressions.indentationRegex, "$1- ");
      return { text: text2, moveTo: { ch: text2.length } };
    }
  }
};
var getNewCursorPosition = (startPos, insertion) => {
  var _a;
  const defaultMoveTo = { line: 0, ch: startPos.ch };
  const moveTo = __spreadValues(__spreadValues({}, defaultMoveTo), (_a = insertion.moveTo) != null ? _a : {});
  const destinationLineLength = insertion.text.split("\n")[moveTo.line].length;
  return {
    line: startPos.line + moveTo.line,
    ch: Math.min(moveTo.ch, destinationLineLength)
  };
};

// src/Commands/index.ts
var Commands = class {
  get app() {
    return this.plugin.app;
  }
  constructor({ plugin }) {
    this.plugin = plugin;
    plugin.addCommand({
      id: "edit-task",
      name: "Create or edit task",
      icon: "pencil",
      editorCheckCallback: (checking, editor, view) => {
        return createOrEdit(checking, editor, view, this.app);
      }
    });
    plugin.addCommand({
      id: "toggle-done",
      name: "Toggle task done",
      icon: "check-in-circle",
      editorCheckCallback: toggleDone
    });
  }
};

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray2 = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray2(obj) ? "array" : typeof obj;
}
function escapeRegExp2(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp2(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp2(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp2("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index = this.tail.search(re), match;
  switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index = 0;
        while (intermediateValue != null && index < names.length) {
          if (index === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
          intermediateValue = intermediateValue[names[index++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse2(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value = this.unescapedValue(token, context);
    else if (symbol === "name")
      value = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self2 = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self2.render(template, context, partials, config);
  }
  if (!value)
    return;
  if (isArray2(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray2(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray2(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray2(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse3(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// src/Scripting/ExpandPlaceholders.ts
var import_mustache_validator = __toESM(require_dist2());
function expandPlaceholders(template, view) {
  mustache_default.escape = function(text2) {
    return text2;
  };
  try {
    return mustache_default.render(template, (0, import_mustache_validator.default)(view));
  } catch (error) {
    let message = "";
    if (error instanceof Error) {
      message = `There was an error expanding one or more placeholders.

The error message was:
    ${error.message.replace(/ > /g, ".").replace("Missing Mustache data property", "Unknown property")}`;
    } else {
      message = "Unknown error expanding placeholders.";
    }
    message += `

The problem is in:
    ${template}`;
    throw Error(message);
  }
}

// src/Scripting/QueryContext.ts
function makeQueryContext(path) {
  const tasksFile = new TasksFile(path);
  return {
    query: {
      file: tasksFile
    }
  };
}

// src/lib/ExceptionTools.ts
function errorMessageForException(whatWasHappening, exception) {
  const errorMessage = `Error: ${whatWasHappening}.
The error message was:
    `;
  let detail = "";
  if (exception instanceof Error) {
    detail += exception;
  } else {
    detail += "Unknown error";
  }
  return `${errorMessage}"${detail}"`;
}

// src/Query/Sorter.ts
var Sorter = class {
  constructor(property, comparator, reverse) {
    this.property = property;
    this.comparator = Sorter.maybeReverse(reverse, comparator);
  }
  static maybeReverse(reverse, comparator) {
    return reverse ? Sorter.makeReversedComparator(comparator) : comparator;
  }
  static makeReversedComparator(comparator) {
    return (a, b) => comparator(a, b) * -1;
  }
};

// src/Query/Grouper.ts
var Grouper = class {
  constructor(property, grouper, reverse) {
    this.property = property;
    this.grouper = grouper;
    this.reverse = reverse;
  }
};

// src/Query/Filter/Field.ts
var Field = class {
  canCreateFilterForLine(line) {
    return Field.lineMatchesFilter(this.filterRegExp(), line);
  }
  static lineMatchesFilter(filter, line) {
    if (filter) {
      return filter.test(line);
    } else {
      return false;
    }
  }
  static getMatch(filterRegExp, line) {
    if (filterRegExp) {
      return line.match(filterRegExp);
    } else {
      return null;
    }
  }
  fieldNameSingular() {
    return this.fieldName();
  }
  fieldNameSingularEscaped() {
    return escapeRegExp(this.fieldNameSingular());
  }
  supportsSorting() {
    return false;
  }
  createSorterFromLine(line) {
    if (!this.supportsSorting()) {
      return null;
    }
    const match = Field.getMatch(this.sorterRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    return this.createSorter(reverse);
  }
  sorterRegExp() {
    if (!this.supportsSorting()) {
      throw Error(`sorterRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^sort by ${this.fieldNameSingularEscaped()}( reverse)?`);
  }
  comparator() {
    throw Error(`comparator() unimplemented for ${this.fieldNameSingular()}`);
  }
  createSorter(reverse) {
    return new Sorter(this.fieldNameSingular(), this.comparator(), reverse);
  }
  createNormalSorter() {
    return this.createSorter(false);
  }
  createReverseSorter() {
    return this.createSorter(true);
  }
  supportsGrouping() {
    return false;
  }
  createGrouperFromLine(line) {
    if (!this.supportsGrouping()) {
      return null;
    }
    const match = Field.getMatch(this.grouperRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    return this.createGrouper(reverse);
  }
  grouperRegExp() {
    if (!this.supportsGrouping()) {
      throw Error(`grouperRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^group by ${this.fieldNameSingularEscaped()}( reverse)?$`);
  }
  grouper() {
    throw Error(`grouper() unimplemented for ${this.fieldNameSingular()}`);
  }
  createGrouper(reverse) {
    return new Grouper(this.fieldNameSingular(), this.grouper(), reverse);
  }
  createNormalGrouper() {
    return this.createGrouper(false);
  }
  createReverseGrouper() {
    return this.createGrouper(true);
  }
};

// src/Query/Explain/Explanation.ts
var Explanation = class {
  constructor(description, children2 = [], symbol = "") {
    this.description = description;
    this.symbol = symbol;
    this.children = children2;
  }
  static booleanAnd(children2) {
    return this.combineOrCreateExplanation("All of", children2, "AND");
  }
  static booleanOr(children2) {
    return this.combineOrCreateExplanation("At least one of", children2, "OR");
  }
  static booleanNot(children2) {
    return new Explanation("None of", children2, "NOT");
  }
  static booleanXor(children2) {
    return new Explanation("Exactly one of", children2, "XOR");
  }
  asString(currentIndentation = "") {
    if (this.children.length == 0) {
      return currentIndentation + this.description;
    }
    let result = currentIndentation;
    if (this.symbol === "") {
      result += this.description;
    } else {
      result += this.symbol;
      if (this.children.length > 1) {
        result += ` (${this.description})`;
      }
      result += ":";
    }
    const newIndentation = currentIndentation + "  ";
    for (let i = 0; i < this.children.length; i++) {
      result += `
${this.children[i].asString(newIndentation)}`;
    }
    return result;
  }
  static combineOrCreateExplanation(description, children2, symbol) {
    if (children2.length === 2) {
      const child0 = children2[0];
      const child1 = children2[1];
      if (child0.symbol === symbol && child1.symbol === "") {
        child0.children.push(child1);
        return child0;
      }
    }
    return new Explanation(description, children2, symbol);
  }
};

// src/Query/Filter/Filter.ts
var Filter = class {
  constructor(instruction, filterFunction, explanation) {
    this.instruction = instruction;
    this.explanation = explanation;
    this.filterFunction = filterFunction;
  }
  explainFilterIndented(indent) {
    const explanation = this.explanation;
    const unindentedExplanation = explanation.asString();
    if (unindentedExplanation === this.instruction) {
      return `${indent}${this.instruction}
`;
    } else {
      return `${indent}${this.instruction} =>
${explanation.asString("  ")}
`;
    }
  }
};

// src/Query/QueryComponentOrError.ts
var QueryComponentOrError = class {
  constructor(instruction) {
    this.instruction = instruction;
  }
  get queryComponent() {
    return this._queryComponent;
  }
  set queryComponent(value) {
    this._queryComponent = value;
  }
  get error() {
    return this._error;
  }
  set error(value) {
    this._error = value;
  }
  static fromObject(instruction, object) {
    const result = new QueryComponentOrError(instruction);
    result._queryComponent = object;
    return result;
  }
  static fromError(instruction, errorMessage) {
    const result = new QueryComponentOrError(instruction);
    result._error = errorMessage;
    return result;
  }
};

// src/Query/Filter/FilterOrErrorMessage.ts
var FilterOrErrorMessage = class {
  constructor(object) {
    this.object = object;
  }
  get instruction() {
    return this.object.instruction;
  }
  get filter() {
    return this.object.queryComponent;
  }
  get error() {
    return this.object.error;
  }
  get filterFunction() {
    if (this.filter) {
      return this.filter.filterFunction;
    } else {
      return void 0;
    }
  }
  static fromFilter(filter) {
    return new FilterOrErrorMessage(QueryComponentOrError.fromObject(filter.instruction, filter));
  }
  static fromError(instruction, errorMessage) {
    return new FilterOrErrorMessage(QueryComponentOrError.fromError(instruction, errorMessage));
  }
};

// src/Query/Filter/FilterInstruction.ts
var FilterInstruction = class {
  constructor(instruction, filter) {
    this._instruction = instruction;
    this._filter = filter;
  }
  canCreateFilterForLine(line) {
    return line == this._instruction;
  }
  createFilterOrErrorMessage(line) {
    if (line === this._instruction) {
      return FilterOrErrorMessage.fromFilter(new Filter(line, this._filter, new Explanation(line)));
    }
    return FilterOrErrorMessage.fromError(line, `do not understand filter: ${line}`);
  }
};

// src/Query/Filter/FilterInstructions.ts
var FilterInstructions = class {
  constructor() {
    this._filters = [];
  }
  add(instruction, filter) {
    this._filters.push(new FilterInstruction(instruction, filter));
  }
  canCreateFilterForLine(line) {
    for (const filter of this._filters) {
      if (filter.canCreateFilterForLine(line)) {
        return true;
      }
    }
    return false;
  }
  createFilterOrErrorMessage(line) {
    for (const filter of this._filters) {
      const x = filter.createFilterOrErrorMessage(line);
      if (x.error === void 0) {
        return x;
      }
    }
    return FilterOrErrorMessage.fromError(line, `do not understand filter: ${line}`);
  }
};

// src/Query/Filter/FilterInstructionsBasedField.ts
var FilterInstructionsBasedField = class extends Field {
  constructor() {
    super(...arguments);
    this._filters = new FilterInstructions();
  }
  canCreateFilterForLine(line) {
    return this._filters.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    return this._filters.createFilterOrErrorMessage(line);
  }
  filterRegExp() {
    return null;
  }
};

// src/Query/Filter/StatusField.ts
var StatusField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("done", (task) => task.isDone);
    this._filters.add("not done", (task) => !task.isDone);
  }
  fieldName() {
    return "status";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const oldStatusNameA = StatusField.oldStatusName(a);
      const oldStatusNameB = StatusField.oldStatusName(b);
      if (oldStatusNameA < oldStatusNameB) {
        return 1;
      } else if (oldStatusNameA > oldStatusNameB) {
        return -1;
      } else {
        return 0;
      }
    };
  }
  static oldStatusName(a) {
    if (a.status.symbol === " ") {
      return "Todo";
    } else {
      return "Done";
    }
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [StatusField.oldStatusName(task)];
    };
  }
};

// src/Query/Filter/DateField.ts
var DateField = class extends Field {
  constructor(filterInstructions = null) {
    super();
    if (filterInstructions !== null) {
      this.filterInstructions = filterInstructions;
    } else {
      this.filterInstructions = new FilterInstructions();
      this.filterInstructions.add(`has ${this.fieldName()} date`, (task) => this.date(task) !== null);
      this.filterInstructions.add(`no ${this.fieldName()} date`, (task) => this.date(task) === null);
      this.filterInstructions.add(`${this.fieldName()} date is invalid`, (task) => {
        const date = this.date(task);
        return date !== null && !date.isValid();
      });
    }
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.filter !== void 0) {
      return filterResult;
    }
    const fieldNameKeywordDate = Field.getMatch(this.filterRegExp(), line);
    if (fieldNameKeywordDate === null) {
      return FilterOrErrorMessage.fromError(
        line,
        "do not understand query filter (" + this.fieldName() + " date)"
      );
    }
    const keywordAndDateString = fieldNameKeywordDate[1];
    const fieldKeyword = fieldNameKeywordDate[2];
    const fieldDateString = fieldNameKeywordDate[3];
    let fieldDates = DateParser.parseDateRange(fieldDateString);
    if (!fieldDates.isValid()) {
      const date = DateParser.parseDate(keywordAndDateString);
      if (date.isValid()) {
        fieldDates = new DateRange(date, date);
      }
    }
    if (!fieldDates.isValid()) {
      return FilterOrErrorMessage.fromError(line, "do not understand " + this.fieldName() + " date");
    }
    const filterFunction = this.buildFilterFunction(fieldKeyword, fieldDates);
    const explanation = DateField.buildExplanation(
      this.fieldNameForExplanation(),
      fieldKeyword,
      this.filterResultIfFieldMissing(),
      fieldDates
    );
    return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, explanation));
  }
  buildFilterFunction(fieldKeyword, fieldDates) {
    let dateFilter;
    switch (fieldKeyword) {
      case "before":
        dateFilter = (date) => date ? date.isBefore(fieldDates.start) : this.filterResultIfFieldMissing();
        break;
      case "after":
        dateFilter = (date) => date ? date.isAfter(fieldDates.end) : this.filterResultIfFieldMissing();
        break;
      case "on or before":
      case "in or before":
        dateFilter = (date) => date ? date.isSameOrBefore(fieldDates.end) : this.filterResultIfFieldMissing();
        break;
      case "on or after":
      case "in or after":
        dateFilter = (date) => date ? date.isSameOrAfter(fieldDates.start) : this.filterResultIfFieldMissing();
        break;
      default:
        dateFilter = (date) => date ? date.isSameOrAfter(fieldDates.start) && date.isSameOrBefore(fieldDates.end) : this.filterResultIfFieldMissing();
    }
    return this.getFilter(dateFilter);
  }
  getFilter(dateFilterFunction) {
    return (task) => {
      return dateFilterFunction(this.date(task));
    };
  }
  filterRegExp() {
    return new RegExp(
      `^${this.fieldNameForFilterInstruction()} (((?:on|in) or before|before|(?:on|in) or after|after|on|in)? ?(.*))`
    );
  }
  fieldNameForFilterInstruction() {
    return this.fieldName();
  }
  static buildExplanation(fieldName, fieldKeyword, filterResultIfFieldMissing, filterDates) {
    let relationship = fieldKeyword;
    const dateFormat = "YYYY-MM-DD (dddd Do MMMM YYYY)";
    let explanationDates;
    switch (fieldKeyword) {
      case "before":
      case "on or after":
        explanationDates = filterDates.start.format(dateFormat);
        break;
      case "after":
      case "on or before":
        explanationDates = filterDates.end.format(dateFormat);
        break;
      case "in or before":
        relationship = "on or before";
        explanationDates = filterDates.end.format(dateFormat);
        break;
      case "in or after":
        relationship = "on or after";
        explanationDates = filterDates.start.format(dateFormat);
        break;
      default:
        if (!filterDates.start.isSame(filterDates.end)) {
          const firstLine = `${fieldName} date is between:`;
          const subExplanations = [
            new Explanation(`${filterDates.start.format(dateFormat)} and`),
            new Explanation(`${filterDates.end.format(dateFormat)} inclusive`)
          ];
          if (filterResultIfFieldMissing) {
            subExplanations.push(new Explanation(`OR no ${fieldName} date`));
          }
          return new Explanation(firstLine, subExplanations);
        }
        relationship = "on";
        explanationDates = filterDates.start.format(dateFormat);
        break;
    }
    let oneLineExplanation = `${fieldName} date is ${relationship} ${explanationDates}`;
    if (filterResultIfFieldMissing) {
      oneLineExplanation += ` OR no ${fieldName} date`;
    }
    return new Explanation(oneLineExplanation);
  }
  fieldNameForExplanation() {
    return this.fieldName();
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return compareByDate(this.date(a), this.date(b));
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const date = this.date(task);
      if (date === null) {
        return ["No " + this.fieldName() + " date"];
      }
      return [date.format("YYYY-MM-DD dddd")];
    };
  }
};

// src/Query/Filter/DueDateField.ts
var DueDateField = class extends DateField {
  fieldName() {
    return "due";
  }
  date(task) {
    return task.dueDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/PriorityField.ts
var _PriorityField = class extends Field {
  createFilterOrErrorMessage(line) {
    const priorityMatch = Field.getMatch(this.filterRegExp(), line);
    if (priorityMatch !== null) {
      const filterPriorityString = priorityMatch[5];
      let filterPriority = null;
      switch (filterPriorityString) {
        case "lowest":
          filterPriority = "5" /* Lowest */;
          break;
        case "low":
          filterPriority = "4" /* Low */;
          break;
        case "none":
          filterPriority = "3" /* None */;
          break;
        case "medium":
          filterPriority = "2" /* Medium */;
          break;
        case "high":
          filterPriority = "1" /* High */;
          break;
        case "highest":
          filterPriority = "0" /* Highest */;
          break;
      }
      if (filterPriority === null) {
        return FilterOrErrorMessage.fromError(line, "do not understand priority");
      }
      let explanation = line;
      let filter;
      switch (priorityMatch[3]) {
        case "above":
          filter = (task) => task.priority.localeCompare(filterPriority) < 0;
          break;
        case "below":
          filter = (task) => task.priority.localeCompare(filterPriority) > 0;
          break;
        case "not":
          filter = (task) => task.priority !== filterPriority;
          break;
        default:
          filter = (task) => task.priority === filterPriority;
          explanation = `${this.fieldName()} is ${filterPriorityString}`;
      }
      return FilterOrErrorMessage.fromFilter(new Filter(line, filter, new Explanation(explanation)));
    } else {
      return FilterOrErrorMessage.fromError(line, "do not understand query filter (priority)");
    }
  }
  fieldName() {
    return "priority";
  }
  filterRegExp() {
    return _PriorityField.priorityRegexp;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return a.priority.localeCompare(b.priority);
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const priorityName = PriorityTools.priorityNameUsingNormal(task.priority);
      return [`%%${task.priority}%%${priorityName} priority`];
    };
  }
};
var PriorityField = _PriorityField;
PriorityField.priorityRegexp = /^priority(\s+is)?(\s+(above|below|not))?(\s+(lowest|low|none|medium|high|highest))$/;

// src/Query/Matchers/IStringMatcher.ts
var IStringMatcher = class {
  matchesAnyOf(stringsToSearch) {
    return stringsToSearch.some((s) => this.matches(s));
  }
};

// src/Query/Matchers/SubstringMatcher.ts
var SubstringMatcher = class extends IStringMatcher {
  constructor(stringToFind) {
    super();
    this.stringToFind = stringToFind;
  }
  matches(stringToSearch) {
    return SubstringMatcher.stringIncludesCaseInsensitive(stringToSearch, this.stringToFind);
  }
  static stringIncludesCaseInsensitive(haystack, needle) {
    return haystack.toLocaleLowerCase().includes(needle.toLocaleLowerCase());
  }
  explanation(instruction) {
    return new Explanation(instruction);
  }
};

// src/Query/Matchers/RegexMatcher.ts
var RegexMatcher = class extends IStringMatcher {
  constructor(regex) {
    super();
    this.regex = regex;
  }
  static validateAndConstruct(regexInput) {
    const regexPattern = /^\/(.+)\/([^/]*)$/;
    const query = regexInput.match(regexPattern);
    if (query !== null) {
      const regExp = new RegExp(query[1], query[2]);
      return new RegexMatcher(regExp);
    } else {
      return null;
    }
  }
  matches(stringToSearch) {
    return stringToSearch.match(this.regex) !== null;
  }
  static helpMessage() {
    return String.raw`See https://publish.obsidian.md/tasks/Queries/Regular+Expressions

Regular expressions must look like this:
    /pattern/
or this:
    /pattern/flags

Where:
- pattern: The 'regular expression' pattern to search for.
- flags:   Optional characters that modify the search.
           i => make the search case-insensitive
           u => add Unicode support

Examples:  /^Log/
           /^Log/i
           /File Name\.md/
           /waiting|waits|waited/i
           /\d\d:\d\d/

The following characters have special meaning in the pattern:
to find them literally, you must add a \ before them:
    [\^$.|?*+()

CAUTION! Regular expression (or 'regex') searching is a powerful
but advanced feature that requires thorough knowledge in order to
use successfully, and not miss intended search results.
`;
  }
  explanation(instruction) {
    const intro = "using regex: ";
    const explanationText = alignRegexWithOriginalInstruction(instruction, intro, this.regexAsString());
    return new Explanation(explanationText);
  }
  regexAsString() {
    let result = `'${this.regex.source}' with `;
    switch (this.regex.flags.length) {
      case 0:
        result += "no flags";
        break;
      case 1:
        result += `flag '${this.regex.flags}'`;
        break;
      default:
        result += `flags '${this.regex.flags}'`;
        break;
    }
    return result;
  }
};
function alignRegexWithOriginalInstruction(instruction, intro, regexAsString) {
  var _a;
  const match = instruction.match(/\//);
  if (!match) {
    return "Error explaining instruction. Could not find a slash character";
  }
  const indentation = 2;
  const startOfRegex = ((_a = match.index) != null ? _a : indentation) - indentation;
  const prefixPadded = intro.padEnd(startOfRegex);
  return `${prefixPadded}${regexAsString}`;
}

// src/Query/Filter/TextField.ts
var TextField = class extends Field {
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const [_, filterOperator, filterValue] = match;
    let matcher = null;
    if (filterOperator.includes("include")) {
      matcher = new SubstringMatcher(filterValue);
    } else if (filterOperator.includes("regex")) {
      try {
        matcher = RegexMatcher.validateAndConstruct(filterValue);
      } catch (e) {
        const message = errorMessageForException("Parsing regular expression", e) + `

${RegexMatcher.helpMessage()}`;
        return FilterOrErrorMessage.fromError(line, message);
      }
      if (matcher === null) {
        return FilterOrErrorMessage.fromError(
          line,
          `Invalid instruction: '${line}'

${RegexMatcher.helpMessage()}`
        );
      }
    }
    if (matcher === null) {
      return FilterOrErrorMessage.fromError(line, `do not understand query filter (${this.fieldName()})`);
    }
    const negate = filterOperator.match(/not/) !== null;
    const filter = new Filter(line, this.getFilter(matcher, negate), matcher.explanation(line));
    return FilterOrErrorMessage.fromFilter(filter);
  }
  fieldPattern() {
    return this.fieldNameSingularEscaped();
  }
  filterOperatorPattern() {
    return "includes|does not include|regex matches|regex does not match";
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldPattern()}) (${this.filterOperatorPattern()}) (.*)`);
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matches(this.value(task));
      return negate ? !match : match;
    };
  }
  comparator() {
    return (a, b) => {
      return this.value(a).localeCompare(this.value(b), void 0, { numeric: true });
    };
  }
  grouper() {
    return (task) => {
      return [this.value(task)];
    };
  }
  static escapeMarkdownCharacters(filename) {
    return filename.replace(/\\/g, "\\\\").replace(/_/g, "\\_");
  }
};

// src/Query/Filter/PathField.ts
var PathField = class extends TextField {
  fieldName() {
    return "path";
  }
  value(task) {
    return task.path;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(task.path.replace(".md", ""))];
    };
  }
};

// src/Query/Filter/UrgencyField.ts
var UrgencyField = class extends Field {
  canCreateFilterForLine(_line) {
    return false;
  }
  createFilterOrErrorMessage(line) {
    return FilterOrErrorMessage.fromError(line, "Filtering by urgency is not yet supported");
  }
  fieldName() {
    return "urgency";
  }
  filterRegExp() {
    throw Error(`filterRegExp() unimplemented for ${this.fieldName()}`);
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      return b.urgency - a.urgency;
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [`${task.urgency.toFixed(2)}`];
    };
  }
  createGrouper(reverse) {
    return super.createGrouper(!reverse);
  }
};

// src/Query/Sort.ts
var Sort = class {
  static by(sorters, tasks) {
    const defaultComparators = [
      new UrgencyField().comparator(),
      new StatusField().comparator(),
      new DueDateField().comparator(),
      new PriorityField().comparator(),
      new PathField().comparator()
    ];
    const userComparators = [];
    for (const sorter of sorters) {
      userComparators.push(sorter.comparator);
    }
    return tasks.sort(Sort.makeCompositeComparator([...userComparators, ...defaultComparators]));
  }
  static makeCompositeComparator(comparators) {
    return (a, b) => {
      for (const comparator of comparators) {
        const result = comparator(a, b);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    };
  }
};

// src/Query/GroupDisplayHeading.ts
var GroupDisplayHeading = class {
  constructor(nestingLevel, displayName, property) {
    this.nestingLevel = nestingLevel;
    this.displayName = displayName;
    this.property = property;
  }
};

// src/Query/GroupDisplayHeadingSelector.ts
var GroupDisplayHeadingSelector = class {
  constructor(taskGroupingTreeStorage, groupers) {
    this.lastHeadingAtLevel = new Array();
    this.groupers = groupers;
    const firstGroup = taskGroupingTreeStorage.keys().next().value;
    const groupCount = firstGroup.length;
    for (let i = 0; i < groupCount; i++) {
      this.lastHeadingAtLevel.push("");
    }
  }
  getHeadingsForTaskGroup(groupNames) {
    const headingsForGroup = new Array();
    for (let level = 0; level < groupNames.length; level++) {
      const group = groupNames[level];
      if (group != this.lastHeadingAtLevel[level]) {
        headingsForGroup.push(new GroupDisplayHeading(level, group, this.groupers[level].property));
        for (let j = level; j < groupNames.length; j++) {
          this.lastHeadingAtLevel[j] = "";
        }
        this.lastHeadingAtLevel[level] = group;
      }
    }
    return headingsForGroup;
  }
};

// src/Query/GroupingTreeNode.ts
var GroupingTreeNode = class {
  constructor(values) {
    this.children = /* @__PURE__ */ new Map();
    this.values = [];
    this.values = values;
  }
  generateAllPaths(pathSoFar = []) {
    const resultMap = /* @__PURE__ */ new Map();
    if (this.children.size == 0) {
      resultMap.set([...pathSoFar], this.values);
      return resultMap;
    }
    for (const [property, child] of this.children) {
      pathSoFar.push(property);
      const childResult = child.generateAllPaths(pathSoFar);
      childResult.forEach((value, key) => resultMap.set(key, value));
      pathSoFar.pop();
    }
    return resultMap;
  }
};

// src/Query/TaskGroupingTree.ts
var TaskGroupingTreeNode = class extends GroupingTreeNode {
};
var TaskGroupingTree = class {
  constructor(groupers, tasks) {
    this.root = new TaskGroupingTreeNode(tasks);
    this.buildGroupingTree(groupers);
  }
  buildGroupingTree(groupers) {
    let currentTreeLevel = [this.root];
    for (const grouper of groupers) {
      const nextTreeLevel = [];
      for (const currentTreeNode of currentTreeLevel) {
        for (const task of currentTreeNode.values) {
          const groupNames = grouper.grouper(task);
          if (groupNames.length === 0) {
            groupNames.push("");
          }
          for (const groupName of groupNames) {
            let child = currentTreeNode.children.get(groupName);
            if (child === void 0) {
              child = new TaskGroupingTreeNode([]);
              currentTreeNode.children.set(groupName, child);
              nextTreeLevel.push(child);
            }
            child.values.push(task);
          }
        }
      }
      currentTreeLevel = nextTreeLevel;
    }
  }
  generateTaskTreeStorage() {
    return this.root.generateAllPaths();
  }
};

// src/Query/TaskGroup.ts
var TaskGroup = class {
  constructor(groups, tasks) {
    this.groups = groups;
    this.groupHeadings = [];
    this.tasks = tasks;
  }
  setGroupHeadings(headingsForTaskGroup) {
    for (const groupDisplayHeading of headingsForTaskGroup) {
      this.groupHeadings.push(groupDisplayHeading);
    }
  }
  applyTaskLimit(limit) {
    this.tasks = this.tasks.slice(0, limit);
  }
  tasksAsStringOfLines() {
    let output = "";
    for (const task of this.tasks) {
      output += task.toFileLineString() + "\n";
    }
    return output;
  }
  toString() {
    let output = "\n";
    output += `Group names: [${this.groups}]
`;
    for (const heading of this.groupHeadings) {
      const headingPrefix = "#".repeat(4 + heading.nestingLevel);
      output += `${headingPrefix} [${heading.property}] ${heading.displayName}
`;
    }
    output += this.tasksAsStringOfLines();
    return output;
  }
};

// src/Query/TaskGroups.ts
var TaskGroups = class {
  constructor(groups, tasks) {
    this._groups = new Array();
    this._totalTaskCount = 0;
    this._totalTaskCount = tasks.length;
    this._groupers = groups;
    const taskGroupingTree = new TaskGroupingTree(groups, tasks);
    const groupingTreeStorage = taskGroupingTree.generateTaskTreeStorage();
    this.addTaskGroups(groupingTreeStorage);
    this.sortTaskGroups();
    this.setGroupsHeadings(groupingTreeStorage);
  }
  get groupers() {
    return this._groupers;
  }
  get groups() {
    return this._groups;
  }
  totalTasksCount() {
    return this._totalTaskCount;
  }
  toString() {
    let output = "";
    output += "Groupers (if any):\n";
    for (const grouper of this._groupers) {
      const reverseText = grouper.reverse ? " reverse" : "";
      output += `- ${grouper.property}${reverseText}
`;
    }
    for (const taskGroup of this.groups) {
      output += taskGroup.toString();
      output += "\n---\n";
    }
    const totalTasksCount = this.totalTasksCount();
    output += `
${totalTasksCount} tasks
`;
    return output;
  }
  addTaskGroups(groupingTreeStorage) {
    for (const [groups, tasks] of groupingTreeStorage) {
      const taskGroup = new TaskGroup(groups, tasks);
      this.addTaskGroup(taskGroup);
    }
  }
  addTaskGroup(taskGroup) {
    this._groups.push(taskGroup);
  }
  sortTaskGroups() {
    const compareFn = (group1, group2) => {
      const groupNames1 = group1.groups;
      const groupNames2 = group2.groups;
      for (let i = 0; i < groupNames1.length; i++) {
        const grouper = this._groupers[i];
        const result = groupNames1[i].localeCompare(groupNames2[i], void 0, { numeric: true });
        if (result !== 0) {
          return grouper.reverse ? -result : result;
        }
      }
      return 0;
    };
    this._groups.sort(compareFn);
  }
  setGroupsHeadings(groupingTreeStorage) {
    const displayHeadingSelector = new GroupDisplayHeadingSelector(groupingTreeStorage, this._groupers);
    for (const group of this._groups) {
      group.setGroupHeadings(displayHeadingSelector.getHeadingsForTaskGroup(group.groups));
    }
  }
  applyTaskLimit(limit) {
    if (this._groupers.length === 0) {
      return;
    }
    this._groups.forEach((group) => {
      group.applyTaskLimit(limit);
    });
    this.recalculateTotalTaskCount();
  }
  recalculateTotalTaskCount() {
    let concatenatedTasks = [];
    this._groups.forEach((group) => {
      concatenatedTasks = [...concatenatedTasks, ...group.tasks];
    });
    const uniqueTasks = [...new Set(concatenatedTasks)];
    this._totalTaskCount = uniqueTasks.length;
  }
};

// src/Query/Filter/DescriptionField.ts
var DescriptionField = class extends TextField {
  fieldName() {
    return "description";
  }
  value(task) {
    return GlobalFilter.getInstance().removeAsSubstringFrom(task.description);
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const descriptionA = DescriptionField.cleanDescription(a.description);
      const descriptionB = DescriptionField.cleanDescription(b.description);
      return descriptionA.localeCompare(descriptionB, void 0, { numeric: true });
    };
  }
  static cleanDescription(description) {
    description = GlobalFilter.getInstance().removeAsSubstringFrom(description);
    const startsWithLinkRegex = /^\[\[?([^\]]*)]]?/;
    const linkRegexMatch = description.match(startsWithLinkRegex);
    if (linkRegexMatch !== null) {
      const innerLinkText = linkRegexMatch[1];
      description = innerLinkText.substring(innerLinkText.indexOf("|") + 1) + description.replace(startsWithLinkRegex, "");
    }
    description = this.replaceFormatting(description, /^\*\*([^*]+)\*\*/);
    description = this.replaceFormatting(description, /^\*([^*]+)\*/);
    description = this.replaceFormatting(description, /^==([^=]+)==/);
    description = this.replaceFormatting(description, /^__([^_]+)__/);
    description = this.replaceFormatting(description, /^_([^_]+)_/);
    return description;
  }
  static replaceFormatting(description, regExp) {
    const italicBoldRegexMatch = description.match(regExp);
    if (italicBoldRegexMatch !== null) {
      const innerItalicBoldText = italicBoldRegexMatch[1];
      description = innerItalicBoldText + description.replace(regExp, "");
    }
    return description;
  }
};

// src/Query/Filter/CreatedDateField.ts
var CreatedDateField = class extends DateField {
  fieldName() {
    return "created";
  }
  date(task) {
    return task.createdDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/DoneDateField.ts
var DoneDateField = class extends DateField {
  fieldName() {
    return "done";
  }
  date(task) {
    return task.doneDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/ExcludeSubItemsField.ts
var ExcludeSubItemsField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("exclude sub-items", (task) => {
      if (task.indentation === "")
        return true;
      const lastBlockquoteMark = task.indentation.lastIndexOf(">");
      if (lastBlockquoteMark === -1)
        return false;
      return /^ ?$/.test(task.indentation.slice(lastBlockquoteMark + 1));
    });
  }
  fieldName() {
    return "exclude";
  }
};

// src/Scripting/Expression.ts
var FunctionOrError = class extends QueryComponentOrError {
};
function constructArguments(task) {
  const paramsArgs = [
    ["task", task]
  ];
  return paramsArgs;
}
function parseExpression(paramsArgs, arg) {
  const params = paramsArgs.map(([p]) => p);
  try {
    const input = arg.includes("return") ? arg : `return ${arg}`;
    const expression = arg && new Function(...params, input);
    if (expression instanceof Function) {
      return FunctionOrError.fromObject(arg, expression);
    }
    return FunctionOrError.fromError(arg, "Error parsing group function");
  } catch (e) {
    return FunctionOrError.fromError(arg, errorMessageForException(`Failed parsing expression "${arg}"`, e));
  }
}
function evaluateExpression(expression, paramsArgs) {
  const args = paramsArgs.map(([_, a]) => a);
  return expression(...args);
}
function evaluateExpressionOrCatch(expression, paramsArgs, arg) {
  try {
    return evaluateExpression(expression, paramsArgs);
  } catch (e) {
    return errorMessageForException(`Failed calculating expression "${arg}"`, e);
  }
}
function parseAndEvaluateExpression(task, arg) {
  const paramsArgs = constructArguments(task);
  const functionOrError = parseExpression(paramsArgs, arg);
  if (functionOrError.error) {
    return functionOrError.error;
  }
  return evaluateExpressionOrCatch(functionOrError.queryComponent, paramsArgs, arg);
}

// src/Scripting/TaskExpression.ts
var TaskExpression = class {
  constructor(line) {
    this.line = line;
    this.functionOrError = parseExpression(constructArguments(null), line);
  }
  isValid() {
    return this.functionOrError.error === void 0;
  }
  get parseError() {
    return this.functionOrError.error;
  }
  evaluate(task) {
    if (!this.isValid()) {
      throw Error(
        `Error: Cannot evaluate an expression which is not valid: "${this.line}" gave error: "${this.parseError}"`
      );
    }
    return evaluateExpression(this.functionOrError.queryComponent, constructArguments(task));
  }
  evaluateOrCatch(task) {
    if (!this.isValid()) {
      return `Error: Cannot evaluate an expression which is not valid: "${this.line}" gave error: "${this.parseError}"`;
    }
    return evaluateExpressionOrCatch(this.functionOrError.queryComponent, constructArguments(task), this.line);
  }
};

// src/Query/Filter/FunctionField.ts
var FunctionField = class extends Field {
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return FilterOrErrorMessage.fromError(line, "Unable to parse line");
    }
    const expression = match[1];
    const taskExpression = new TaskExpression(expression);
    if (!taskExpression.isValid()) {
      return FilterOrErrorMessage.fromError(line, taskExpression.parseError);
    }
    return FilterOrErrorMessage.fromFilter(
      new Filter(line, createFilterFunctionFromLine(taskExpression), new Explanation(line))
    );
  }
  fieldName() {
    return "function";
  }
  filterRegExp() {
    return new RegExp(`^filter by ${this.fieldNameSingularEscaped()} (.*)`);
  }
  supportsGrouping() {
    return true;
  }
  createGrouperFromLine(line) {
    const match = Field.getMatch(this.grouperRegExp(), line);
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const args = match[2];
    return new Grouper("function", createGrouperFunctionFromLine(args), reverse);
  }
  grouperRegExp() {
    return new RegExp(`^group by ${this.fieldNameSingularEscaped()}( reverse)? (.*)`);
  }
  grouper() {
    throw Error("grouper() function not valid for FunctionField. Use createGrouperFromLine() instead.");
  }
};
function createFilterFunctionFromLine(expression) {
  return (task) => {
    return filterByFunction(expression, task);
  };
}
function filterByFunction(expression, task) {
  const result = expression.evaluate(task);
  if (typeof result === "boolean") {
    return result;
  }
  throw Error(`filtering function must return true or false. This returned "${result}".`);
}
function createGrouperFunctionFromLine(line) {
  return (task) => {
    return groupByFunction(task, line);
  };
}
function groupByFunction(task, arg) {
  try {
    const result = parseAndEvaluateExpression(task, arg);
    if (Array.isArray(result)) {
      return result.map((h) => h.toString());
    }
    if (result === null) {
      return [];
    }
    const group = result.toString();
    return [group];
  } catch (e) {
    const errorMessage = `Error: Failed calculating expression "${arg}". The error message was: `;
    if (e instanceof Error) {
      return [errorMessage + e.message];
    } else {
      return [errorMessage + "Unknown error"];
    }
  }
}

// src/Query/Filter/HeadingField.ts
var HeadingField = class extends TextField {
  fieldName() {
    return "heading";
  }
  value(task) {
    if (task.precedingHeader) {
      return task.precedingHeader;
    } else {
      return "";
    }
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.precedingHeader === null || task.precedingHeader.length === 0) {
        return ["(No heading)"];
      }
      return [task.precedingHeader];
    };
  }
};

// src/Query/Filter/ScheduledDateField.ts
var ScheduledDateField = class extends DateField {
  fieldName() {
    return "scheduled";
  }
  date(task) {
    return task.scheduledDate;
  }
  filterResultIfFieldMissing() {
    return false;
  }
};

// src/Query/Filter/StartDateField.ts
var StartDateField = class extends DateField {
  fieldName() {
    return "start";
  }
  fieldNameForFilterInstruction() {
    return "starts";
  }
  date(task) {
    return task.startDate;
  }
  filterResultIfFieldMissing() {
    return true;
  }
};

// src/Query/Filter/HappensDateField.ts
var HappensDateField = class extends DateField {
  constructor() {
    const filterInstructions = new FilterInstructions();
    filterInstructions.add("has happens date", (task) => this.dates(task).some((date) => date !== null));
    filterInstructions.add("no happens date", (task) => !this.dates(task).some((date) => date !== null));
    super(filterInstructions);
  }
  fieldName() {
    return "happens";
  }
  fieldNameForExplanation() {
    return "due, start or scheduled";
  }
  date(task) {
    return this.earliestDate(task);
  }
  dates(task) {
    return task.happensDates;
  }
  earliestDate(task) {
    return task.happens.moment;
  }
  filterResultIfFieldMissing() {
    return false;
  }
  getFilter(dateFilterFunction) {
    return (task) => {
      return this.dates(task).some((date) => dateFilterFunction(date));
    };
  }
};

// src/Query/Filter/RecurringField.ts
var RecurringField = class extends FilterInstructionsBasedField {
  constructor() {
    super();
    this._filters.add("is recurring", (task) => task.recurrence !== null);
    this._filters.add("is not recurring", (task) => task.recurrence === null);
  }
  fieldName() {
    return "recurring";
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      if (a.recurrence !== null && b.recurrence === null) {
        return -1;
      } else if (a.recurrence === null && b.recurrence !== null) {
        return 1;
      } else {
        return 0;
      }
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.recurrence !== null) {
        return ["Recurring"];
      } else {
        return ["Not Recurring"];
      }
    };
  }
};

// src/Query/Filter/MultiTextField.ts
var MultiTextField = class extends TextField {
  fieldNamePlural() {
    return this.fieldNameSingular() + "s";
  }
  fieldName() {
    return `${this.fieldNameSingular()}/${this.fieldNamePlural()}`;
  }
  fieldPattern() {
    return `${this.fieldNameSingular()}|${this.fieldNamePlural()}`;
  }
  filterOperatorPattern() {
    return `${super.filterOperatorPattern()}|include|do not include`;
  }
  value(task) {
    return this.values(task).join(", ");
  }
  getFilter(matcher, negate) {
    return (task) => {
      const match = matcher.matchesAnyOf(this.values(task));
      return negate ? !match : match;
    };
  }
  createGrouper(reverse) {
    return new Grouper(this.fieldNamePlural(), this.grouper(), reverse);
  }
  grouperRegExp() {
    if (!this.supportsGrouping()) {
      throw Error(`grouperRegExp() unimplemented for ${this.fieldNameSingular()}`);
    }
    return new RegExp(`^group by ${this.fieldNamePlural()}( reverse)?$`);
  }
};

// src/Query/Filter/TagsField.ts
var TagsField = class extends MultiTextField {
  constructor() {
    super();
    this.filterInstructions = new FilterInstructions();
    this.filterInstructions.add(`has ${this.fieldNameSingular()}`, (task) => this.values(task).length > 0);
    this.filterInstructions.add(`has ${this.fieldNamePlural()}`, (task) => this.values(task).length > 0);
    this.filterInstructions.add(`no ${this.fieldNameSingular()}`, (task) => this.values(task).length === 0);
    this.filterInstructions.add(`no ${this.fieldNamePlural()}`, (task) => this.values(task).length === 0);
  }
  createFilterOrErrorMessage(line) {
    const filterResult = this.filterInstructions.createFilterOrErrorMessage(line);
    if (filterResult.filter !== void 0) {
      return filterResult;
    }
    return super.createFilterOrErrorMessage(line);
  }
  canCreateFilterForLine(line) {
    if (this.filterInstructions.canCreateFilterForLine(line)) {
      return true;
    }
    return super.canCreateFilterForLine(line);
  }
  fieldNameSingular() {
    return "tag";
  }
  values(task) {
    return task.tags;
  }
  supportsSorting() {
    return true;
  }
  createSorterFromLine(line) {
    const match = line.match(this.sorterRegExp());
    if (match === null) {
      return null;
    }
    const reverse = !!match[1];
    const propertyInstance = isNaN(+match[2]) ? 1 : +match[2];
    const comparator = TagsField.makeCompareByTagComparator(propertyInstance);
    return new Sorter(this.fieldNameSingular(), comparator, reverse);
  }
  sorterRegExp() {
    return /^sort by tag( reverse)?[\s]*(\d+)?/;
  }
  comparator() {
    return TagsField.makeCompareByTagComparator(1);
  }
  static makeCompareByTagComparator(propertyInstance) {
    return (a, b) => {
      if (a.tags.length === 0 && b.tags.length === 0) {
        return 0;
      } else if (a.tags.length === 0) {
        return 1;
      } else if (b.tags.length === 0) {
        return -1;
      }
      const tagInstanceToSortBy = propertyInstance - 1;
      if (a.tags.length < propertyInstance && b.tags.length >= propertyInstance) {
        return 1;
      } else if (b.tags.length < propertyInstance && a.tags.length >= propertyInstance) {
        return -1;
      } else if (a.tags.length < propertyInstance && b.tags.length < propertyInstance) {
        return 0;
      }
      const tagA = a.tags[tagInstanceToSortBy];
      const tagB = b.tags[tagInstanceToSortBy];
      return tagA.localeCompare(tagB, void 0, { numeric: true });
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.tags.length == 0) {
        return ["(No tags)"];
      }
      return task.tags;
    };
  }
};

// src/Query/Filter/BooleanField.ts
var import_boon_js = __toESM(require_lib());
var BooleanField = class extends Field {
  constructor() {
    super(...arguments);
    this.basicBooleanRegexp = /(.*(AND|OR|XOR|NOT)\s*[("].*|\(.+\))/g;
    this.supportedOperators = ["AND", "OR", "XOR", "NOT"];
    this.subFields = {};
  }
  filterRegExp() {
    return this.basicBooleanRegexp;
  }
  createFilterOrErrorMessage(line) {
    return this.parseLine(line);
  }
  fieldName() {
    return "boolean query";
  }
  parseLine(line) {
    if (line.length === 0) {
      return FilterOrErrorMessage.fromError(line, "empty line");
    }
    const preprocessed = this.preprocessExpression(line);
    try {
      const postfixExpression = (0, import_boon_js.parse)(preprocessed);
      for (const token of postfixExpression) {
        if (token.name === "IDENTIFIER" && token.value) {
          const identifier = token.value.trim();
          if (!(identifier in this.subFields)) {
            const parsedField = parseFilter(identifier);
            if (parsedField === null) {
              return FilterOrErrorMessage.fromError(
                line,
                `couldn't parse sub-expression '${identifier}'`
              );
            }
            if (parsedField.error) {
              return FilterOrErrorMessage.fromError(
                line,
                `couldn't parse sub-expression '${identifier}': ${parsedField.error}`
              );
            } else if (parsedField.filter) {
              this.subFields[identifier] = parsedField.filter;
            }
          }
        } else if (token.name === "OPERATOR") {
          if (token.value == void 0) {
            return FilterOrErrorMessage.fromError(line, "empty operator in boolean query");
          }
          if (!this.supportedOperators.includes(token.value)) {
            return FilterOrErrorMessage.fromError(line, `unknown boolean operator '${token.value}'`);
          }
        }
      }
      const filterFunction = (task) => {
        return this.filterTaskWithParsedQuery(task, postfixExpression);
      };
      const explanation = this.constructExplanation(postfixExpression);
      return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, explanation));
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error type";
      return FilterOrErrorMessage.fromError(
        line,
        `malformed boolean query -- ${message} (check the documentation for guidelines)`
      );
    }
  }
  preprocessExpression(line) {
    return line.replace(/\(([^()]+)\)/g, '("$1")');
  }
  filterTaskWithParsedQuery(task, postfixExpression) {
    const toBool = (s) => {
      return s === "true";
    };
    const toString = (b) => {
      return b ? "true" : "false";
    };
    const booleanStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        const result = filter.filterFunction(task);
        booleanStack.push(toString(result));
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = toBool(booleanStack.pop());
          booleanStack.push(toString(!arg1));
        } else if (token.value === "OR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 || arg2));
        } else if (token.value === "AND") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && arg2));
        } else if (token.value === "XOR") {
          const arg1 = toBool(booleanStack.pop());
          const arg2 = toBool(booleanStack.pop());
          booleanStack.push(toString(arg1 && !arg2 || !arg1 && arg2));
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token);
      }
    }
    return toBool(booleanStack[0]);
  }
  constructExplanation(postfixExpression) {
    const explanationStack = [];
    for (const token of postfixExpression) {
      if (token.name === "IDENTIFIER") {
        if (token.value == null)
          throw Error("null token value");
        const filter = this.subFields[token.value.trim()];
        explanationStack.push(filter.explanation);
      } else if (token.name === "OPERATOR") {
        if (token.value === "NOT") {
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanNot([arg1]));
        } else if (token.value === "OR") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanOr([arg1, arg2]));
        } else if (token.value === "AND") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanAnd([arg1, arg2]));
        } else if (token.value === "XOR") {
          const arg2 = explanationStack.pop();
          const arg1 = explanationStack.pop();
          explanationStack.push(Explanation.booleanXor([arg1, arg2]));
        } else {
          throw Error("Unsupported operator: " + token.value);
        }
      } else {
        throw Error("Unsupported token type: " + token.name);
      }
    }
    return explanationStack[0];
  }
};

// src/Query/Filter/FilenameField.ts
var FilenameField = class extends TextField {
  fieldName() {
    return "filename";
  }
  value(task) {
    const filename = task.filename;
    if (filename === null) {
      return "";
    }
    return filename + ".md";
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const filename = task.filename;
      if (filename === null) {
        return ["Unknown Location"];
      }
      return ["[[" + filename + "]]"];
    };
  }
};

// src/Query/Filter/StatusNameField.ts
var StatusNameField = class extends TextField {
  constructor() {
    super();
  }
  fieldName() {
    return "status.name";
  }
  value(task) {
    return task.status.name;
  }
  supportsSorting() {
    return true;
  }
  supportsGrouping() {
    return true;
  }
};

// src/Query/Filter/StatusTypeField.ts
var StatusTypeField = class extends Field {
  canCreateFilterForLine(line) {
    const relaxedRegExp = new RegExp(`^(?:${this.fieldNameSingularEscaped()})`);
    return Field.lineMatchesFilter(relaxedRegExp, line);
  }
  createFilterOrErrorMessage(line) {
    const match = Field.getMatch(this.filterRegExp(), line);
    if (match === null) {
      return this.helpMessage(line);
    }
    const [_, filterOperator, statusTypeAsString] = match;
    const statusTypeElement = StatusType[statusTypeAsString.toUpperCase()];
    if (!statusTypeElement) {
      return this.helpMessage(line);
    }
    let filterFunction;
    switch (filterOperator) {
      case "is":
        filterFunction = (task) => {
          return task.status.type === statusTypeElement;
        };
        break;
      case "is not":
        filterFunction = (task) => {
          return task.status.type !== statusTypeElement;
        };
        break;
      default:
        return this.helpMessage(line);
    }
    return FilterOrErrorMessage.fromFilter(new Filter(line, filterFunction, new Explanation(line)));
  }
  filterRegExp() {
    return new RegExp(`^(?:${this.fieldNameSingularEscaped()}) (is|is not) ([^ ]+)$`);
  }
  helpMessage(line) {
    const allowedTypes = Object.values(StatusType).filter((t) => t !== "EMPTY" /* EMPTY */).join(" ");
    const message = `Invalid ${this.fieldNameSingular()} instruction: '${line}'.
    Allowed options: 'is' and 'is not' (without quotes).
    Allowed values:  ${allowedTypes}
                     Note: values are case-insensitive,
                           so 'in_progress' works too, for example.
    Example:         ${this.fieldNameSingular()} is not NON_TASK`;
    return FilterOrErrorMessage.fromError(line, message);
  }
  fieldName() {
    return "status.type";
  }
  value(task) {
    return task.status.type;
  }
  supportsSorting() {
    return true;
  }
  comparator() {
    return (a, b) => {
      const keyA = StatusTypeField.groupName(a);
      const keyB = StatusTypeField.groupName(b);
      return keyA.localeCompare(keyB, void 0, { numeric: true });
    };
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [StatusTypeField.groupName(task)];
    };
  }
  static groupName(task) {
    let prefix;
    switch (task.status.type) {
      case "IN_PROGRESS" /* IN_PROGRESS */:
        prefix = "1";
        break;
      case "TODO" /* TODO */:
        prefix = "2";
        break;
      case "DONE" /* DONE */:
        prefix = "3";
        break;
      case "CANCELLED" /* CANCELLED */:
        prefix = "4";
        break;
      case "NON_TASK" /* NON_TASK */:
        prefix = "5";
        break;
      case "EMPTY" /* EMPTY */:
        prefix = "6";
        break;
    }
    return `%%${prefix}%%${task.status.type}`;
  }
};

// src/Query/Filter/RecurrenceField.ts
var RecurrenceField = class extends TextField {
  fieldName() {
    return "recurrence";
  }
  value(task) {
    if (task.recurrence !== null) {
      return task.recurrence.toText();
    } else {
      return "";
    }
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      if (task.recurrence !== null) {
        return [task.recurrence.toText()];
      } else {
        return ["None"];
      }
    };
  }
};

// src/Query/Filter/FolderField.ts
var FolderField = class extends TextField {
  fieldName() {
    return "folder";
  }
  value(task) {
    return task.file.folder;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(this.value(task))];
    };
  }
};

// src/Query/Filter/RootField.ts
var RootField = class extends TextField {
  fieldName() {
    return "root";
  }
  value(task) {
    return task.file.root;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      return [TextField.escapeMarkdownCharacters(this.value(task))];
    };
  }
};

// src/Query/Filter/BacklinkField.ts
var BacklinkField = class extends TextField {
  fieldName() {
    return "backlink";
  }
  value(task) {
    const linkText = task.getLinkText({ isFilenameUnique: true });
    if (linkText === null) {
      return "Unknown Location";
    }
    return linkText;
  }
  createFilterOrErrorMessage(line) {
    return FilterOrErrorMessage.fromError(line, "backlink field does not support filtering");
  }
  canCreateFilterForLine(_line) {
    return false;
  }
  supportsGrouping() {
    return true;
  }
  grouper() {
    return (task) => {
      const filename = task.filename;
      if (filename === null) {
        return ["Unknown Location"];
      }
      const header = task.precedingHeader;
      if (header === null) {
        return ["[[" + filename + "]]"];
      }
      return [`[[${filename}#${header}|${filename} > ${header}]]`];
    };
  }
};

// src/Query/FilterParser.ts
var fieldCreators = [
  () => new StatusNameField(),
  () => new StatusTypeField(),
  () => new StatusField(),
  () => new RecurringField(),
  () => new PriorityField(),
  () => new HappensDateField(),
  () => new CreatedDateField(),
  () => new StartDateField(),
  () => new ScheduledDateField(),
  () => new DueDateField(),
  () => new DoneDateField(),
  () => new PathField(),
  () => new FolderField(),
  () => new RootField(),
  () => new BacklinkField(),
  () => new DescriptionField(),
  () => new TagsField(),
  () => new HeadingField(),
  () => new ExcludeSubItemsField(),
  () => new FilenameField(),
  () => new UrgencyField(),
  () => new RecurrenceField(),
  () => new FunctionField(),
  () => new BooleanField()
];
function parseFilter(filterString) {
  for (const creator of fieldCreators) {
    const field = creator();
    if (field.canCreateFilterForLine(filterString))
      return field.createFilterOrErrorMessage(filterString);
  }
  return null;
}
function parseSorter(sorterString) {
  const sortByRegexp = /^sort by /;
  if (sorterString.match(sortByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const sorter = field.createSorterFromLine(sorterString);
    if (sorter) {
      return sorter;
    }
  }
  return null;
}
function parseGrouper(line) {
  const groupByRegexp = /^group by /;
  if (line.match(groupByRegexp) === null) {
    return null;
  }
  for (const creator of fieldCreators) {
    const field = creator();
    const grouper = field.createGrouperFromLine(line);
    if (grouper) {
      return grouper;
    }
  }
  return null;
}

// src/Query/QueryResult.ts
var QueryResult = class {
  constructor(groups) {
    this._searchErrorMessage = void 0;
    this.taskGroups = groups;
  }
  get searchErrorMessage() {
    return this._searchErrorMessage;
  }
  set searchErrorMessage(value) {
    this._searchErrorMessage = value;
  }
  get totalTasksCount() {
    return this.taskGroups.totalTasksCount();
  }
  get groups() {
    return this.taskGroups.groups;
  }
  static fromError(message) {
    const result = new QueryResult(new TaskGroups([], []));
    result._searchErrorMessage = message;
    return result;
  }
  tasksCountDisplayText() {
    const tasksCount = this.totalTasksCount;
    return `${tasksCount} task${tasksCount !== 1 ? "s" : ""}`;
  }
};

// src/Query/Query.ts
var Query = class {
  constructor(source, path = void 0) {
    this._limit = void 0;
    this._taskGroupLimit = void 0;
    this._layoutOptions = new LayoutOptions();
    this._filters = [];
    this._error = void 0;
    this._sorting = [];
    this._grouping = [];
    this._ignoreGlobalQuery = false;
    this.hideOptionsRegexp = /^(hide|show) (task count|backlink|priority|created date|start date|scheduled date|done date|due date|recurrence rule|edit button|urgency|tags)/;
    this.shortModeRegexp = /^short/;
    this.explainQueryRegexp = /^explain/;
    this.ignoreGlobalQueryRegexp = /^ignore global query/;
    this.limitRegexp = /^limit (groups )?(to )?(\d+)( tasks?)?/;
    this.commentRegexp = /^#.*/;
    this.source = source;
    this.filePath = path;
    source.split("\n").map((rawLine) => rawLine.trim()).forEach((rawLine) => {
      const line = this.expandPlaceholders(rawLine, path);
      if (this.error !== void 0) {
        return;
      }
      switch (true) {
        case line === "":
          break;
        case this.shortModeRegexp.test(line):
          this._layoutOptions.shortMode = true;
          break;
        case this.explainQueryRegexp.test(line):
          this._layoutOptions.explainQuery = true;
          break;
        case this.ignoreGlobalQueryRegexp.test(line):
          this._ignoreGlobalQuery = true;
          break;
        case this.limitRegexp.test(line):
          this.parseLimit(line);
          break;
        case this.parseSortBy(line):
          break;
        case this.parseGroupBy(line):
          break;
        case this.hideOptionsRegexp.test(line):
          this.parseHideOptions(line);
          break;
        case this.commentRegexp.test(line):
          break;
        case this.parseFilter(line):
          break;
        default:
          this.setError("do not understand query", line);
      }
    });
  }
  expandPlaceholders(source, path) {
    if (source.includes("{{") && source.includes("}}")) {
      if (this.filePath === void 0) {
        this._error = `The query looks like it contains a placeholder, with "{{" and "}}"
but no file path has been supplied, so cannot expand placeholder values.
The query is:
${source}`;
        return source;
      }
    }
    let expandedSource = source;
    if (path) {
      const queryContext = makeQueryContext(path);
      try {
        expandedSource = expandPlaceholders(source, queryContext);
      } catch (error) {
        if (error instanceof Error) {
          this._error = error.message;
        } else {
          this._error = "Internal error. expandPlaceholders() threw something other than Error.";
        }
        return source;
      }
    }
    return expandedSource;
  }
  append(q2) {
    if (this.source === "")
      return q2;
    if (q2.source === "")
      return this;
    return new Query(`${this.source}
${q2.source}`, this.filePath);
  }
  explainQuery() {
    let result = "";
    if (this.error !== void 0) {
      result += "Query has an error:\n";
      result += this.error + "\n";
      return result;
    }
    const numberOfFilters = this.filters.length;
    if (numberOfFilters === 0) {
      result += "No filters supplied. All tasks will match the query.";
    } else {
      for (let i = 0; i < numberOfFilters; i++) {
        if (i > 0)
          result += "\n";
        result += this.filters[i].explainFilterIndented("");
      }
    }
    result += this.explainQueryLimits();
    const { debugSettings } = getSettings();
    if (debugSettings.ignoreSortInstructions) {
      result += "\n\nNOTE: All sort instructions, including default sort order, are disabled, due to 'ignoreSortInstructions' setting.";
    }
    return result;
  }
  explainQueryLimits() {
    let result = "";
    function getPluralisedText(limit) {
      let text2 = `

At most ${limit} task`;
      if (limit !== 1) {
        text2 += "s";
      }
      return text2;
    }
    if (this._limit !== void 0) {
      result += getPluralisedText(this._limit);
      result += ".\n";
    }
    if (this._taskGroupLimit !== void 0) {
      result += getPluralisedText(this._taskGroupLimit);
      result += ' per group (if any "group by" options are supplied).\n';
    }
    return result;
  }
  get limit() {
    return this._limit;
  }
  get layoutOptions() {
    return this._layoutOptions;
  }
  get filters() {
    return this._filters;
  }
  get sorting() {
    return this._sorting;
  }
  get grouping() {
    return this._grouping;
  }
  get error() {
    return this._error;
  }
  setError(message, line) {
    this._error = `${message}
Problem line: "${line}"`;
  }
  get ignoreGlobalQuery() {
    return this._ignoreGlobalQuery;
  }
  applyQueryToTasks(tasks) {
    try {
      this.filters.forEach((filter) => {
        tasks = tasks.filter(filter.filterFunction);
      });
      const { debugSettings } = getSettings();
      const tasksSorted = debugSettings.ignoreSortInstructions ? tasks : Sort.by(this.sorting, tasks);
      const tasksSortedLimited = tasksSorted.slice(0, this.limit);
      const taskGroups = new TaskGroups(this.grouping, tasksSortedLimited);
      if (this._taskGroupLimit !== void 0) {
        taskGroups.applyTaskLimit(this._taskGroupLimit);
      }
      return new QueryResult(taskGroups);
    } catch (e) {
      const description = "Search failed";
      return QueryResult.fromError(errorMessageForException(description, e));
    }
  }
  parseHideOptions(line) {
    const hideOptionsMatch = line.match(this.hideOptionsRegexp);
    if (hideOptionsMatch !== null) {
      const hide = hideOptionsMatch[1] === "hide";
      const option = hideOptionsMatch[2];
      switch (option) {
        case "task count":
          this._layoutOptions.hideTaskCount = hide;
          break;
        case "backlink":
          this._layoutOptions.hideBacklinks = hide;
          break;
        case "priority":
          this._layoutOptions.hidePriority = hide;
          break;
        case "created date":
          this._layoutOptions.hideCreatedDate = hide;
          break;
        case "start date":
          this._layoutOptions.hideStartDate = hide;
          break;
        case "scheduled date":
          this._layoutOptions.hideScheduledDate = hide;
          break;
        case "due date":
          this._layoutOptions.hideDueDate = hide;
          break;
        case "done date":
          this._layoutOptions.hideDoneDate = hide;
          break;
        case "recurrence rule":
          this._layoutOptions.hideRecurrenceRule = hide;
          break;
        case "edit button":
          this._layoutOptions.hideEditButton = hide;
          break;
        case "urgency":
          this._layoutOptions.hideUrgency = hide;
          break;
        case "tags":
          this._layoutOptions.hideTags = hide;
          break;
        default:
          this.setError("do not understand hide/show option", line);
      }
    }
  }
  parseFilter(line) {
    var _a;
    const filterOrError = parseFilter(line);
    if (filterOrError != null) {
      if (filterOrError.filter) {
        this._filters.push(filterOrError.filter);
      } else {
        this.setError((_a = filterOrError.error) != null ? _a : "Unknown error", line);
      }
      return true;
    }
    return false;
  }
  parseLimit(line) {
    const limitMatch = line.match(this.limitRegexp);
    if (limitMatch === null) {
      this.setError("do not understand query limit", line);
      return;
    }
    const limitFromLine = Number.parseInt(limitMatch[3], 10);
    if (limitMatch[1] !== void 0) {
      this._taskGroupLimit = limitFromLine;
    } else {
      this._limit = limitFromLine;
    }
  }
  parseSortBy(line) {
    const sortingMaybe = parseSorter(line);
    if (sortingMaybe) {
      this._sorting.push(sortingMaybe);
      return true;
    }
    return false;
  }
  parseGroupBy(line) {
    const groupingMaybe = parseGrouper(line);
    if (groupingMaybe) {
      this._grouping.push(groupingMaybe);
      return true;
    }
    return false;
  }
};

// src/Config/GlobalQuery.ts
var _GlobalQuery = class {
  constructor(source = _GlobalQuery.empty) {
    this._source = source;
  }
  static getInstance() {
    if (!_GlobalQuery.instance) {
      _GlobalQuery.instance = new _GlobalQuery();
    }
    return _GlobalQuery.instance;
  }
  set(source) {
    this._source = source;
  }
  query(path = void 0) {
    return new Query(this._source, path);
  }
  hasInstructions() {
    return this._source.trim() !== _GlobalQuery.empty;
  }
};
var GlobalQuery = _GlobalQuery;
GlobalQuery.empty = "";

// src/TasksEvents.ts
var TasksEvents = class {
  constructor({ obsidianEvents }) {
    this.obsidianEvents = obsidianEvents;
  }
  onCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, handler);
  }
  triggerCacheUpdate(cacheData) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:cache-update" /* CacheUpdate */, cacheData);
  }
  onRequestCacheUpdate(handler) {
    return this.obsidianEvents.on("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, handler);
  }
  triggerRequestCacheUpdate(fn) {
    this.obsidianEvents.trigger("obsidian-tasks-plugin:request-cache-update" /* RequestCacheUpdate */, fn);
  }
  off(eventRef) {
    this.obsidianEvents.offref(eventRef);
  }
};

// src/File.ts
var import_obsidian6 = require("obsidian");

// src/lib/MockDataCreator.ts
function getMockDataForTesting(originalTask, fileLines, listItemsCache) {
  const allDataFromListItemCache = [];
  for (const listItemCache of listItemsCache) {
    const pos = listItemCache.position;
    const task = listItemCache.task;
    const dataFromListItemCache = {
      position: pos,
      task
    };
    allDataFromListItemCache.push(dataFromListItemCache);
  }
  const mockTaskLocation = {
    path: originalTask.taskLocation.path,
    lineNumber: originalTask.taskLocation.lineNumber,
    sectionStart: originalTask.taskLocation.sectionStart,
    sectionIndex: originalTask.taskLocation.sectionIndex,
    precedingHeader: originalTask.taskLocation.precedingHeader
  };
  return {
    taskData: {
      originalMarkdown: originalTask.originalMarkdown,
      taskLocation: mockTaskLocation
    },
    fileData: {
      fileLines
    },
    cacheData: {
      listItemsCache: allDataFromListItemCache
    }
  };
}
function saveMockDataForTesting(originalTask, fileLines, listItemsCache) {
  const everything = getMockDataForTesting(originalTask, fileLines, listItemsCache);
  console.error(`Inconsistent lines: SAVE THE OUTPUT
data:
${JSON.stringify(everything)}
`);
}

// src/lib/logging.ts
var import_obsidian5 = require("obsidian");
var import_eventemitter2 = __toESM(require_eventemitter2());
var LogManager = class extends import_eventemitter2.EventEmitter2 {
  constructor() {
    super(...arguments);
    this.options = {
      minLevels: {
        "": "info",
        tasks: "info"
      }
    };
    this.consoleLoggerRegistered = false;
    this.arrAvg = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
  }
  configure(options) {
    this.options = Object.assign({}, this.options, options);
    return this;
  }
  getLogger(module2) {
    let minLevel = "none";
    let match = "";
    for (const key in this.options.minLevels) {
      if (module2.startsWith(key) && key.length >= match.length) {
        minLevel = this.options.minLevels[key];
        match = key;
      }
    }
    return new Logger(this, module2, minLevel);
  }
  onLogEntry(listener) {
    this.on("log", listener);
    return this;
  }
  registerConsoleLogger() {
    if (this.consoleLoggerRegistered)
      return this;
    this.onLogEntry((logEntry) => {
      let msg = `[${window.moment().format("YYYY-MM-DD-HH:mm:ss.SSS")}][${logEntry.level}][${logEntry.module}]`;
      if (logEntry.traceId) {
        msg += `[${logEntry.traceId}]`;
      }
      msg += ` ${logEntry.message}`;
      if (logEntry.objects === void 0) {
        logEntry.objects = "";
      }
      switch (logEntry.level) {
        case "trace":
          console.trace(msg, logEntry.objects);
          break;
        case "debug":
          console.debug(msg, logEntry.objects);
          break;
        case "info":
          console.info(msg, logEntry.objects);
          break;
        case "warn":
          console.warn(msg, logEntry.objects);
          break;
        case "error":
          console.error(msg, logEntry.objects);
          break;
        default:
          console.log(`{${logEntry.level}} ${msg}`, logEntry.objects);
      }
    });
    this.consoleLoggerRegistered = true;
    return this;
  }
};
var logging = new LogManager();
var Logger = class {
  constructor(logManager, module2, minLevel) {
    this.levels = {
      trace: 1,
      debug: 2,
      info: 3,
      warn: 4,
      error: 5
    };
    this.logManager = logManager;
    this.module = module2;
    this.minLevel = this.levelToInt(minLevel);
  }
  levelToInt(minLevel) {
    if (minLevel.toLowerCase() in this.levels)
      return this.levels[minLevel.toLowerCase()];
    else
      return 99;
  }
  log(logLevel, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId: void 0
    };
    this.logManager.emit("log", logEntry);
  }
  trace(message, objects) {
    this.log("trace", message, objects);
  }
  debug(message, objects) {
    this.log("debug", message, objects);
  }
  info(message, objects) {
    this.log("info", message, objects);
  }
  warn(message, objects) {
    this.log("warn", message, objects);
  }
  error(message, objects) {
    this.log("error", message, objects);
  }
  logWithId(logLevel, traceId, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId
    };
    this.logManager.emit("log", logEntry);
  }
  traceWithId(traceId, message, objects) {
    this.logWithId("trace", traceId, message, objects);
  }
  debugWithId(traceId, message, objects) {
    this.logWithId("debug", traceId, message, objects);
  }
  infoWithId(traceId, message, objects) {
    this.logWithId("info", traceId, message, objects);
  }
  warnWithId(traceId, message, objects) {
    this.logWithId("warn", traceId, message, objects);
  }
  errorWithId(traceId, message, objects) {
    this.logWithId("error", traceId, message, objects);
  }
};

// src/File.ts
var metadataCache;
var vault;
var workspace;
var supportedFileExtensions = ["md"];
var logger = logging.getLogger("tasks");
var initializeFile = ({
  metadataCache: newMetadataCache,
  vault: newVault,
  workspace: newWorkspace
}) => {
  metadataCache = newMetadataCache;
  vault = newVault;
  workspace = newWorkspace;
};
var replaceTaskWithTasks = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks
}) {
  if (vault === void 0 || metadataCache === void 0 || workspace === void 0) {
    errorAndNotice("Tasks: cannot use File before initializing it.");
    return;
  }
  if (!Array.isArray(newTasks)) {
    newTasks = [newTasks];
  }
  logger.debug(`replaceTaskWithTasks entered. ${originalTask.path}`);
  tryRepetitive({
    originalTask,
    newTasks,
    vault,
    metadataCache,
    workspace,
    previousTries: 0
  });
});
function errorAndNotice(message) {
  console.error(message);
  new import_obsidian6.Notice(message, 15e3);
}
function warnAndNotice(message) {
  console.warn(message);
  new import_obsidian6.Notice(message, 1e4);
}
function debugLog(message) {
  logger.debug(message);
}
var WarningWorthRetrying = class extends Error {
};
var RetryWithoutWarning = class extends Error {
};
var tryRepetitive = (_0) => __async(void 0, [_0], function* ({
  originalTask,
  newTasks,
  vault: vault2,
  metadataCache: metadataCache2,
  workspace: workspace2,
  previousTries
}) {
  logger.debug(`tryRepetitive after ${previousTries} previous tries`);
  const retry = () => {
    if (previousTries > 10) {
      const message = `Tasks: Could not find the correct task line to update.

The task line not updated is:
${originalTask.originalMarkdown}

In this markdown file:
"${originalTask.taskLocation.path}"

Note: further clicks on this checkbox will usually now be ignored until the file is opened (or certain, specific edits are made - it's complicated).

Recommendations:

1. Close all panes that have the above file open, and then re-open the file.

2. Check for exactly identical copies of the task line, in this file, and see if you can make them different.
`;
      errorAndNotice(message);
      return;
    }
    const timeout = Math.min(Math.pow(10, previousTries), 100);
    logger.debug(`timeout = ${timeout}`);
    setTimeout(() => {
      tryRepetitive({
        originalTask,
        newTasks,
        vault: vault2,
        metadataCache: metadataCache2,
        workspace: workspace2,
        previousTries: previousTries + 1
      });
    }, timeout);
  };
  try {
    const [taskLineNumber, file, fileLines] = yield getTaskAndFileLines(originalTask, vault2);
    const updatedFileLines = [
      ...fileLines.slice(0, taskLineNumber),
      ...newTasks.map((task) => task.toFileLineString()),
      ...fileLines.slice(taskLineNumber + 1)
    ];
    yield vault2.modify(file, updatedFileLines.join("\n"));
  } catch (e) {
    if (e instanceof WarningWorthRetrying) {
      if (e.message)
        warnAndNotice(e.message);
      return retry();
    } else if (e instanceof RetryWithoutWarning) {
      return retry();
    } else if (e instanceof Error) {
      errorAndNotice(e.message);
    }
  }
});
function getTaskAndFileLines(task, vault2) {
  return __async(this, null, function* () {
    if (metadataCache === void 0)
      throw new WarningWorthRetrying();
    const file = vault2.getAbstractFileByPath(task.path);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new WarningWorthRetrying(`Tasks: No file found for task ${task.description}. Retrying ...`);
    }
    if (!supportedFileExtensions.includes(file.extension)) {
      throw new Error(`Tasks: Does not support files with the ${file.extension} file extension.`);
    }
    const fileCache = metadataCache.getFileCache(file);
    if (fileCache == void 0 || fileCache === null) {
      throw new WarningWorthRetrying(`Tasks: No file cache found for file ${file.path}. Retrying ...`);
    }
    const listItemsCache = fileCache.listItems;
    if (listItemsCache === void 0 || listItemsCache.length === 0) {
      throw new WarningWorthRetrying(`Tasks: No list items found in file cache of ${file.path}. Retrying ...`);
    }
    const fileContent = yield vault2.read(file);
    const fileLines = fileContent.split("\n");
    const taskLineNumber = findLineNumberOfTaskToToggle(task, fileLines, listItemsCache, debugLog);
    if (taskLineNumber === void 0) {
      const logDataForMocking = false;
      if (logDataForMocking) {
        saveMockDataForTesting(task, fileLines, listItemsCache);
      }
      throw new RetryWithoutWarning();
    }
    return [taskLineNumber, file, fileLines];
  });
}
function getTaskLineAndFile(task, vault2) {
  return __async(this, null, function* () {
    try {
      const [taskLineNumber, file, _] = yield getTaskAndFileLines(task, vault2);
      return [taskLineNumber, file];
    } catch (e) {
      if (e instanceof WarningWorthRetrying) {
        if (e.message)
          warnAndNotice(e.message);
      } else if (e instanceof Error) {
        errorAndNotice(e.message);
      }
    }
    return void 0;
  });
}
function isValidLineNumber(listItemLineNumber, fileLines) {
  return listItemLineNumber < fileLines.length;
}
function findLineNumberOfTaskToToggle(originalTask, fileLines, listItemsCache, errorLoggingFunction) {
  let result = tryFindingExactMatchAtOriginalLineNumber(originalTask, fileLines);
  if (result !== void 0) {
    return result;
  }
  result = tryFindingIdenticalUniqueMarkdownLineInFile(originalTask, fileLines);
  if (result !== void 0) {
    return result;
  }
  return tryFindingLineNumberFromTaskSectionInfo(originalTask, fileLines, listItemsCache, errorLoggingFunction);
}
function tryFindingExactMatchAtOriginalLineNumber(originalTask, fileLines) {
  const originalTaskLineNumber = originalTask.taskLocation.lineNumber;
  if (isValidLineNumber(originalTaskLineNumber, fileLines)) {
    if (fileLines[originalTaskLineNumber] === originalTask.originalMarkdown) {
      logger.debug(`Found original markdown at original line number ${originalTaskLineNumber}`);
      return originalTaskLineNumber;
    }
  }
  return void 0;
}
function tryFindingIdenticalUniqueMarkdownLineInFile(originalTask, fileLines) {
  const matchingLineNumbers = [];
  for (let i = 0; i < fileLines.length; i++) {
    if (fileLines[i] === originalTask.originalMarkdown) {
      matchingLineNumbers.push(i);
    }
  }
  if (matchingLineNumbers.length === 1) {
    return matchingLineNumbers[0];
  }
  return void 0;
}
function tryFindingLineNumberFromTaskSectionInfo(originalTask, fileLines, listItemsCache, errorLoggingFunction) {
  let taskLineNumber;
  let sectionIndex = 0;
  for (const listItemCache of listItemsCache) {
    const listItemLineNumber = listItemCache.position.start.line;
    if (!isValidLineNumber(listItemLineNumber, fileLines)) {
      return void 0;
    }
    if (listItemLineNumber < originalTask.taskLocation.sectionStart) {
      continue;
    }
    if (listItemCache.task === void 0) {
      continue;
    }
    const line = fileLines[listItemLineNumber];
    if (GlobalFilter.getInstance().includedIn(line)) {
      if (sectionIndex === originalTask.taskLocation.sectionIndex) {
        if (line === originalTask.originalMarkdown) {
          taskLineNumber = listItemLineNumber;
        } else {
          errorLoggingFunction(
            `Tasks: Unable to find task in file ${originalTask.taskLocation.path}.
Expected task:
${originalTask.originalMarkdown}
Found task:
${line}`
          );
          return;
        }
        break;
      }
      sectionIndex++;
    }
  }
  return taskLineNumber;
}

// src/InlineRenderer.ts
var import_obsidian8 = require("obsidian");

// src/TaskLineRenderer.ts
var import_obsidian7 = require("obsidian");
var LayoutClasses = {
  description: "task-description",
  priority: "task-priority",
  dueDate: "task-due",
  startDate: "task-start",
  createdDate: "task-created",
  scheduledDate: "task-scheduled",
  doneDate: "task-done",
  recurrenceRule: "task-recurring",
  blockLink: ""
};
var MAX_DAY_VALUE_RANGE = 7;
var DAY_VALUE_OVER_RANGE_POSTFIX = "far";
function renderTaskLine(task, renderDetails, textRenderer) {
  return __async(this, null, function* () {
    var _a;
    const li = document.createElement("li");
    renderDetails.parentUlElement.appendChild(li);
    li.classList.add("task-list-item", "plugin-tasks-list-item");
    const textSpan = document.createElement("span");
    li.appendChild(textSpan);
    textSpan.classList.add("tasks-list-text");
    const attributes = yield taskToHtml(task, renderDetails, textSpan, textRenderer);
    for (const key in attributes)
      li.dataset[key] = attributes[key];
    const checkbox = document.createElement("input");
    li.appendChild(checkbox);
    checkbox.classList.add("task-list-item-checkbox");
    checkbox.type = "checkbox";
    if (task.status.symbol !== " ") {
      checkbox.checked = true;
      li.classList.add("is-checked");
    }
    checkbox.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      checkbox.disabled = true;
      const toggledTasks = task.toggleWithRecurrenceInUsersOrder();
      replaceTaskWithTasks({
        originalTask: task,
        newTasks: toggledTasks
      });
    });
    li.prepend(checkbox);
    li.setAttribute("data-task", task.status.symbol.trim());
    li.setAttribute("data-line", renderDetails.listIndex.toString());
    li.setAttribute("data-task-status-name", task.status.name);
    li.setAttribute("data-task-status-type", task.status.type);
    checkbox.setAttribute("data-line", renderDetails.listIndex.toString());
    if ((_a = renderDetails.layoutOptions) == null ? void 0 : _a.shortMode) {
      addTooltip({ task, element: textSpan, isFilenameUnique: renderDetails.isFilenameUnique });
    }
    return li;
  });
}
function taskToHtml(task, renderDetails, parentElement, textRenderer) {
  return __async(this, null, function* () {
    let allAttributes = {};
    const taskLayout = new TaskLayout(renderDetails.layoutOptions);
    const emojiSerializer = TASK_FORMATS.tasksPluginEmoji.taskSerializer;
    for (const component of taskLayout.shownTaskLayoutComponents) {
      let componentString = emojiSerializer.componentToString(task, taskLayout, component);
      if (componentString) {
        if (component === "description") {
          componentString = GlobalFilter.getInstance().removeAsWordFromDependingOnSettings(componentString);
        }
        const span = document.createElement("span");
        parentElement.appendChild(span);
        if (span) {
          const internalSpan = document.createElement("span");
          span.appendChild(internalSpan);
          yield renderComponentText(
            internalSpan,
            componentString,
            component,
            task,
            textRenderer,
            renderDetails.obsidianComponent
          );
          addInternalClasses(component, internalSpan);
          const componentClass = getTaskComponentClass(component, task);
          span.classList.add(...componentClass);
          const componentDataAttribute = getComponentDataAttribute(component, task);
          for (const key in componentDataAttribute)
            span.dataset[key] = componentDataAttribute[key];
          allAttributes = __spreadValues(__spreadValues({}, allAttributes), componentDataAttribute);
        }
      }
    }
    for (const component of taskLayout.hiddenTaskLayoutComponents) {
      const hiddenComponentDataAttribute = getComponentDataAttribute(component, task);
      allAttributes = __spreadValues(__spreadValues({}, allAttributes), hiddenComponentDataAttribute);
    }
    if (allAttributes.taskPriority === void 0) {
      const priorityDataAttribute = getComponentDataAttribute("priority", task);
      allAttributes = __spreadValues(__spreadValues({}, allAttributes), priorityDataAttribute);
    }
    return allAttributes;
  });
}
function renderComponentText(span, componentString, component, task, textRenderer, obsidianComponent) {
  return __async(this, null, function* () {
    if (component === "description") {
      const { debugSettings } = getSettings();
      if (debugSettings.showTaskHiddenData) {
        componentString += `<br>\u{1F41B} <b>${task.lineNumber}</b> . ${task.sectionStart} . ${task.sectionIndex} . '<code>${task.originalMarkdown}</code>'<br>'<code>${task.path}</code>' > '<code>${task.precedingHeader}</code>'<br>`;
      }
      yield textRenderer(componentString, span, task.path, obsidianComponent);
      const blockQuote = span.querySelector("blockquote");
      const directParentOfPTag = blockQuote != null ? blockQuote : span;
      const pElement = directParentOfPTag.querySelector("p");
      if (pElement !== null) {
        while (pElement.firstChild) {
          directParentOfPTag.insertBefore(pElement.firstChild, pElement);
        }
        pElement.remove();
      }
      span.querySelectorAll("p").forEach((pElement2) => {
        if (!pElement2.hasChildNodes()) {
          pElement2.remove();
        }
      });
      span.querySelectorAll(".footnotes").forEach((footnoteElement) => {
        footnoteElement.remove();
      });
    } else {
      span.innerHTML = componentString;
    }
  });
}
function getTaskComponentClass(component, task) {
  const componentClassContainer = [];
  const componentClass = LayoutClasses[component];
  switch (component) {
    case "blockLink":
      break;
    case "description":
    case "priority":
    case "recurrenceRule":
      componentClassContainer.push(componentClass);
      break;
    case "createdDate":
    case "dueDate":
    case "startDate":
    case "scheduledDate":
    case "doneDate": {
      const date = task[component];
      if (date) {
        componentClassContainer.push(componentClass);
      }
      break;
    }
  }
  return componentClassContainer;
}
function getComponentDataAttribute(component, task) {
  const dataAttribute = {};
  const DataAttributeNames = {
    createdDate: "taskCreated",
    dueDate: "taskDue",
    startDate: "taskStart",
    scheduledDate: "taskScheduled",
    doneDate: "taskDone",
    priority: "taskPriority",
    description: "",
    recurrenceRule: "",
    blockLink: ""
  };
  switch (component) {
    case "description":
    case "recurrenceRule":
    case "blockLink":
      break;
    case "priority": {
      const attributeName = DataAttributeNames[component];
      dataAttribute[attributeName] = PriorityTools.priorityNameUsingNormal(task.priority).toLocaleLowerCase();
      break;
    }
    case "createdDate":
    case "dueDate":
    case "startDate":
    case "scheduledDate":
    case "doneDate": {
      const date = task[component];
      if (date) {
        const attributeValue = dateToAttribute(date);
        if (attributeValue) {
          const attributeName = DataAttributeNames[component];
          dataAttribute[attributeName] = attributeValue;
        }
      }
      break;
    }
  }
  return dataAttribute;
}
function addInternalClasses(component, renderedComponent) {
  if (component === "description") {
    const tags = renderedComponent.getElementsByClassName("tag");
    for (let i = 0; i < tags.length; i++) {
      const tagName = tags[i].textContent;
      if (tagName) {
        const className = tagToAttributeValue(tagName);
        const element2 = tags[i];
        if (className)
          element2.dataset.tagName = className;
      }
    }
  }
}
function dateToAttribute(date) {
  const today = window.moment().startOf("day");
  let result = "";
  const diffDays = today.diff(date, "days");
  if (isNaN(diffDays))
    return null;
  if (diffDays === 0)
    return "today";
  else if (diffDays > 0)
    result += "past-";
  else if (diffDays < 0)
    result += "future-";
  if (Math.abs(diffDays) <= MAX_DAY_VALUE_RANGE) {
    result += Math.abs(diffDays).toString() + "d";
  } else {
    result += DAY_VALUE_OVER_RANGE_POSTFIX;
  }
  return result;
}
function tagToAttributeValue(tag) {
  const illegalChars = /["&\x00\r\n]/g;
  let sanitizedTag = tag.replace(illegalChars, "-");
  sanitizedTag = sanitizedTag.replace(/^[-_]+/, "");
  if (sanitizedTag.length > 0)
    return sanitizedTag;
  else
    return null;
}
function addTooltip({
  task,
  element: element2,
  isFilenameUnique
}) {
  const { recurrenceSymbol, startDateSymbol, createdDateSymbol, scheduledDateSymbol, dueDateSymbol, doneDateSymbol } = TASK_FORMATS.tasksPluginEmoji.taskSerializer.symbols;
  element2.addEventListener("mouseenter", () => {
    const tooltip = element2.createDiv();
    tooltip.addClasses(["tooltip", "pop-up"]);
    if (task.recurrence) {
      const recurrenceDiv = tooltip.createDiv();
      recurrenceDiv.setText(`${recurrenceSymbol} ${task.recurrence.toText()}`);
    }
    addDateToTooltip(tooltip, task.createdDate, createdDateSymbol);
    addDateToTooltip(tooltip, task.startDate, startDateSymbol);
    addDateToTooltip(tooltip, task.scheduledDate, scheduledDateSymbol);
    addDateToTooltip(tooltip, task.dueDate, dueDateSymbol);
    addDateToTooltip(tooltip, task.doneDate, doneDateSymbol);
    const linkText = task.getLinkText({ isFilenameUnique });
    if (linkText) {
      const backlinkDiv = tooltip.createDiv();
      backlinkDiv.setText(`\u{1F517} ${linkText}`);
    }
    element2.addEventListener("mouseleave", () => {
      tooltip.remove();
    });
  });
}
function addDateToTooltip(tooltip, date, signifier) {
  if (date) {
    const createdDateDiv = tooltip.createDiv();
    createdDateDiv.setText(
      toTooltipDate({
        signifier,
        date
      })
    );
  }
}
function toTooltipDate({ signifier, date }) {
  return `${signifier} ${date.format(TaskRegularExpressions.dateFormat)} (${date.from(
    window.moment().startOf("day")
  )})`;
}
function taskToLi(task, renderDetails) {
  function obsidianMarkdownRenderer(text2, element2, path, obsidianComponent) {
    return __async(this, null, function* () {
      if (!obsidianComponent)
        throw new Error("Must call the Obsidian renderer with an Obsidian Component object");
      yield import_obsidian7.MarkdownRenderer.renderMarkdown(text2, element2, path, obsidianComponent);
    });
  }
  return renderTaskLine(task, renderDetails, obsidianMarkdownRenderer);
}

// src/InlineRenderer.ts
var InlineRenderer = class {
  constructor({ plugin }) {
    this.markdownPostProcessor = this._markdownPostProcessor.bind(this);
    plugin.registerMarkdownPostProcessor(this._markdownPostProcessor.bind(this));
  }
  _markdownPostProcessor(element2, context) {
    return __async(this, null, function* () {
      var _a;
      const childComponent = new import_obsidian8.MarkdownRenderChild(element2);
      context.addChild(childComponent);
      const renderedElements = element2.findAll(".task-list-item").filter((taskItem) => {
        var _a2;
        const linesText = (_a2 = taskItem.textContent) == null ? void 0 : _a2.split("\n");
        if (linesText === void 0) {
          return false;
        }
        let firstLineText = null;
        for (let i = 0; i < linesText.length; i = i + 1) {
          if (linesText[i] !== "") {
            firstLineText = linesText[i];
            break;
          }
        }
        if (firstLineText === null) {
          return false;
        }
        return GlobalFilter.getInstance().includedIn(firstLineText);
      });
      if (renderedElements.length === 0) {
        return;
      }
      const path = context.sourcePath;
      const section = context.getSectionInfo(element2);
      if (section === null) {
        return;
      }
      const fileLines = section.text.split("\n");
      let sectionIndex = 0;
      const fileTasks = [];
      for (let lineNumber = section.lineStart; lineNumber <= section.lineEnd; lineNumber++) {
        const line = fileLines[lineNumber];
        if (line === void 0) {
          continue;
        }
        const precedingHeader = null;
        const task = Task.fromLine({
          line,
          taskLocation: new TaskLocation(path, lineNumber, section.lineStart, sectionIndex, precedingHeader),
          fallbackDate: null
        });
        if (task !== null) {
          fileTasks.push(task);
          sectionIndex++;
        }
      }
      for (let sectionIndex2 = 0; sectionIndex2 < renderedElements.length; sectionIndex2++) {
        const task = fileTasks[sectionIndex2];
        const renderedElement = renderedElements[sectionIndex2];
        if (task === void 0 || renderedElement === void 0) {
          continue;
        }
        const dataLine = (_a = renderedElement.getAttr("data-line")) != null ? _a : "0";
        const listIndex = Number.parseInt(dataLine, 10);
        const taskElement = yield taskToLi(task, {
          parentUlElement: element2,
          listIndex,
          obsidianComponent: childComponent
        });
        const renderedChildren = renderedElement.childNodes;
        for (let i = 0; i < renderedChildren.length; i = i + 1) {
          const renderedChild = renderedChildren[i];
          if (renderedChild.nodeName.toLowerCase() === "div") {
            taskElement.prepend(renderedChild);
          } else if (renderedChild.nodeName.toLowerCase() === "ul") {
            taskElement.append(renderedChild);
          }
        }
        const originalFootnotes = renderedElement.querySelectorAll("[data-footnote-id]");
        const newFootnotes = taskElement.querySelectorAll("[data-footnote-id]");
        if (originalFootnotes.length === newFootnotes.length) {
          for (let i = 0; i < originalFootnotes.length; i++) {
            newFootnotes[i].replaceWith(originalFootnotes[i]);
          }
        }
        renderedElement.replaceWith(taskElement);
      }
    });
  }
};

// src/LivePreviewExtension.ts
var import_view = require("@codemirror/view");
var import_obsidian9 = require("obsidian");
var newLivePreviewExtension = () => {
  return import_view.ViewPlugin.fromClass(LivePreviewExtension);
};
var LivePreviewExtension = class {
  constructor(view) {
    this.view = view;
    this.handleClickEvent = this.handleClickEvent.bind(this);
    this.view.dom.addEventListener("click", this.handleClickEvent);
  }
  destroy() {
    this.view.dom.removeEventListener("click", this.handleClickEvent);
  }
  handleClickEvent(event) {
    const { target } = event;
    if (!target || !(target instanceof HTMLInputElement) || target.type !== "checkbox") {
      return false;
    }
    const ancestor = target.closest("ul.plugin-tasks-query-result, div.callout-content");
    if (ancestor) {
      if (ancestor.matches("div.callout-content")) {
        const msg = 'obsidian-tasks-plugin warning: Tasks cannot add or remove completion dates or make the next copy of a recurring task for tasks written inside a callout when you click their checkboxes in Live Preview. \nIf you wanted Tasks to do these things, please undo your change, then either click the line of the task and use the "Toggle Task Done" command, or switch to Reading View to click the checkbox.';
        console.warn(msg);
        new import_obsidian9.Notice(msg, 45e3);
      }
      return false;
    }
    const { state } = this.view;
    const position = this.view.posAtDOM(target);
    const line = state.doc.lineAt(position);
    const task = Task.fromLine({
      line: line.text,
      taskLocation: TaskLocation.fromUnknownPosition(""),
      fallbackDate: null
    });
    if (task === null) {
      return false;
    }
    event.preventDefault();
    const toggled = task.toggleWithRecurrenceInUsersOrder();
    const toggledString = toggled.map((t) => t.toFileLineString()).join(state.lineBreak);
    const transaction = state.update({
      changes: {
        from: line.from,
        to: line.to,
        insert: toggledString
      }
    });
    this.view.dispatch(transaction);
    const desiredCheckedStatus = target.checked;
    setTimeout(() => {
      target.checked = desiredCheckedStatus;
    }, 1);
    return true;
  }
};

// src/QueryRenderer.ts
var import_obsidian10 = require("obsidian");

// src/lib/QueryRendererHelper.ts
function explainResults(source, globalFilter, globalQuery, path = void 0) {
  let result = "";
  if (!globalFilter.isEmpty()) {
    result += `Only tasks containing the global filter '${globalFilter.get()}'.

`;
  }
  const tasksBlockQuery = new Query(source, path);
  if (!tasksBlockQuery.ignoreGlobalQuery) {
    if (globalQuery.hasInstructions()) {
      result += `Explanation of the global query:

${globalQuery.query(path).explainQuery()}
`;
    }
  }
  result += `Explanation of this Tasks code block query:

${tasksBlockQuery.explainQuery()}`;
  return result;
}
function getQueryForQueryRenderer(source, globalQuery, path) {
  const tasksBlockQuery = new Query(source, path);
  if (tasksBlockQuery.ignoreGlobalQuery) {
    return tasksBlockQuery;
  }
  return globalQuery.query(path).append(tasksBlockQuery);
}

// src/QueryRenderer.ts
var QueryRenderer = class {
  constructor({ plugin, events }) {
    this.addQueryRenderChild = this._addQueryRenderChild.bind(this);
    this.app = plugin.app;
    this.events = events;
    plugin.registerMarkdownCodeBlockProcessor("tasks", this._addQueryRenderChild.bind(this));
  }
  _addQueryRenderChild(source, element2, context) {
    return __async(this, null, function* () {
      context.addChild(
        new QueryRenderChild({
          app: this.app,
          events: this.events,
          container: element2,
          source,
          filePath: context.sourcePath
        })
      );
    });
  }
};
var QueryRenderChild = class extends import_obsidian10.MarkdownRenderChild {
  constructor({
    app: app2,
    events,
    container,
    source,
    filePath
  }) {
    super(container);
    this.app = app2;
    this.events = events;
    this.source = source;
    this.filePath = filePath;
    switch (this.containerEl.className) {
      case "block-language-tasks":
        this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
        this.queryType = "tasks";
        break;
      default:
        this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
        this.queryType = "tasks";
        break;
    }
  }
  onload() {
    this.events.triggerRequestCacheUpdate(this.render.bind(this));
    this.renderEventRef = this.events.onCacheUpdate(this.render.bind(this));
    this.reloadQueryAtMidnight();
  }
  onunload() {
    if (this.renderEventRef !== void 0) {
      this.events.off(this.renderEventRef);
    }
    if (this.queryReloadTimeout !== void 0) {
      clearTimeout(this.queryReloadTimeout);
    }
  }
  reloadQueryAtMidnight() {
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    const now = new Date();
    const millisecondsToMidnight = midnight.getTime() - now.getTime();
    this.queryReloadTimeout = setTimeout(() => {
      this.query = getQueryForQueryRenderer(this.source, GlobalQuery.getInstance(), this.filePath);
      this.events.triggerRequestCacheUpdate(this.render.bind(this));
      this.reloadQueryAtMidnight();
    }, millisecondsToMidnight + 1e3);
  }
  render(_0) {
    return __async(this, arguments, function* ({ tasks, state }) {
      var _a;
      const content = this.containerEl.createEl("div");
      if (state === "Warm" /* Warm */ && this.query.error === void 0) {
        yield this.renderQuerySearchResults(tasks, state, content);
      } else if (this.query.error !== void 0) {
        this.renderErrorMessage(content, this.query.error);
      } else {
        this.renderLoadingMessage(content);
      }
      (_a = this.containerEl.firstChild) == null ? void 0 : _a.replaceWith(content);
    });
  }
  renderQuerySearchResults(tasks, state, content) {
    return __async(this, null, function* () {
      const debug = false;
      if (debug) {
        console.debug(
          `Render ${this.queryType} called for a block in active file "${this.filePath}", to select from ${tasks.length} tasks: plugin state: ${state}`
        );
      }
      if (this.query.layoutOptions.explainQuery) {
        this.createExplanation(content);
      }
      const queryResult = this.query.applyQueryToTasks(tasks);
      if (queryResult.searchErrorMessage !== void 0) {
        this.renderErrorMessage(content, queryResult.searchErrorMessage);
        return;
      }
      yield this.addAllTaskGroups(queryResult.taskGroups, content);
      const totalTasksCount = queryResult.totalTasksCount;
      if (debug) {
        console.debug(`${totalTasksCount} of ${tasks.length} tasks displayed in a block in "${this.filePath}"`);
      }
      this.addTaskCount(content, queryResult);
    });
  }
  renderErrorMessage(content, errorMessage) {
    content.createDiv().innerHTML = `<pre>Tasks query: ${errorMessage.replace(/\n/g, "<br>")}</pre>`;
  }
  renderLoadingMessage(content) {
    content.setText("Loading Tasks ...");
  }
  createExplanation(content) {
    const explanationAsString = explainResults(
      this.source,
      GlobalFilter.getInstance(),
      GlobalQuery.getInstance(),
      this.filePath
    );
    const explanationsBlock = content.createEl("pre");
    explanationsBlock.addClasses(["plugin-tasks-query-explanation"]);
    explanationsBlock.setText(explanationAsString);
    content.appendChild(explanationsBlock);
  }
  createTaskList(tasks, content) {
    return __async(this, null, function* () {
      const layout = new TaskLayout(this.query.layoutOptions);
      const taskList = content.createEl("ul");
      taskList.addClasses(["contains-task-list", "plugin-tasks-query-result"]);
      taskList.addClasses(layout.taskListHiddenClasses);
      const groupingAttribute = this.getGroupingAttribute();
      if (groupingAttribute && groupingAttribute.length > 0)
        taskList.dataset.taskGroupBy = groupingAttribute;
      for (const [i, task] of tasks.entries()) {
        const isFilenameUnique = this.isFilenameUnique({ task });
        const listItem = yield taskToLi(task, {
          parentUlElement: taskList,
          listIndex: i,
          layoutOptions: this.query.layoutOptions,
          isFilenameUnique,
          taskLayout: layout,
          obsidianComponent: this
        });
        const footnotes = listItem.querySelectorAll("[data-footnote-id]");
        footnotes.forEach((footnote) => footnote.remove());
        const extrasSpan = listItem.createSpan("task-extras");
        if (!this.query.layoutOptions.hideUrgency) {
          this.addUrgency(extrasSpan, task);
        }
        if (!this.query.layoutOptions.hideBacklinks) {
          const shortMode = this.query.layoutOptions.shortMode;
          this.addBacklinks(extrasSpan, task, shortMode, isFilenameUnique);
        }
        if (!this.query.layoutOptions.hideEditButton) {
          this.addEditButton(extrasSpan, task);
        }
        taskList.appendChild(listItem);
      }
      content.appendChild(taskList);
    });
  }
  addEditButton(listItem, task) {
    const editTaskPencil = listItem.createEl("a", {
      cls: "tasks-edit"
    });
    editTaskPencil.onClickEvent((event) => {
      event.preventDefault();
      const onSubmit = (updatedTasks) => {
        replaceTaskWithTasks({
          originalTask: task,
          newTasks: DateFallback.removeInferredStatusIfNeeded(task, updatedTasks)
        });
      };
      const taskModal = new TaskModal({
        app: this.app,
        task,
        onSubmit
      });
      taskModal.open();
    });
  }
  addUrgency(listItem, task) {
    const text2 = new Intl.NumberFormat().format(task.urgency);
    listItem.createSpan({ text: text2, cls: "tasks-urgency" });
  }
  addAllTaskGroups(tasksSortedLimitedGrouped, content) {
    return __async(this, null, function* () {
      for (const group of tasksSortedLimitedGrouped.groups) {
        this.addGroupHeadings(content, group.groupHeadings);
        yield this.createTaskList(group.tasks, content);
      }
    });
  }
  addGroupHeadings(content, groupHeadings) {
    for (const heading of groupHeadings) {
      this.addGroupHeading(content, heading);
    }
  }
  addGroupHeading(content, group) {
    return __async(this, null, function* () {
      let header = "h6";
      if (group.nestingLevel === 0) {
        header = "h4";
      } else if (group.nestingLevel === 1) {
        header = "h5";
      }
      const headerEl = content.createEl(header, {
        cls: "tasks-group-heading"
      });
      yield import_obsidian10.MarkdownRenderer.renderMarkdown(group.displayName, headerEl, this.filePath, this);
    });
  }
  addBacklinks(listItem, task, shortMode, isFilenameUnique) {
    var _a;
    const backLink = listItem.createSpan({ cls: "tasks-backlink" });
    if (!shortMode) {
      backLink.append(" (");
    }
    const link = backLink.createEl("a");
    link.rel = "noopener";
    link.target = "_blank";
    link.addClass("internal-link");
    if (shortMode) {
      link.addClass("internal-link-short-mode");
    }
    let linkText;
    if (shortMode) {
      linkText = " \u{1F517}";
    } else {
      linkText = (_a = task.getLinkText({ isFilenameUnique })) != null ? _a : "";
    }
    link.setText(linkText);
    const vault2 = this.app.vault;
    link.addEventListener("click", (ev) => __async(this, null, function* () {
      const result = yield getTaskLineAndFile(task, vault2);
      if (result) {
        const [line, file] = result;
        const leaf = this.app.workspace.getLeaf(import_obsidian10.Keymap.isModEvent(ev));
        yield leaf.openFile(file, { eState: { line } });
      }
    }));
    link.addEventListener("mousedown", (ev) => __async(this, null, function* () {
      if (ev.button === 1) {
        const result = yield getTaskLineAndFile(task, vault2);
        if (result) {
          const [line, file] = result;
          const leaf = this.app.workspace.getLeaf("tab");
          yield leaf.openFile(file, { eState: { line } });
        }
      }
    }));
    if (!shortMode) {
      backLink.append(")");
    }
  }
  addTaskCount(content, queryResult) {
    if (!this.query.layoutOptions.hideTaskCount) {
      const tasksCountLabel = queryResult.tasksCountDisplayText();
      content.createDiv({
        text: tasksCountLabel,
        cls: "tasks-count"
      });
    }
  }
  isFilenameUnique({ task }) {
    const filenameMatch = task.path.match(/([^/]*)\..+$/i);
    if (filenameMatch === null) {
      return void 0;
    }
    const filename = filenameMatch[1];
    const allFilesWithSameName = this.app.vault.getMarkdownFiles().filter((file) => {
      if (file.basename === filename) {
        return true;
      }
    });
    return allFilesWithSameName.length < 2;
  }
  getGroupingAttribute() {
    const groupingRules = [];
    for (const group of this.query.grouping) {
      groupingRules.push(group.property);
    }
    return groupingRules.join(",");
  }
};

// src/Config/SettingsTab.ts
var import_obsidian12 = require("obsidian");

// src/Config/Themes/AnuPpuccinThemeCollection.ts
function anuppuccinSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    [">", "Rescheduled", "x", "TODO"],
    ["<", "Scheduled", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    ["?", "Question", "x", "TODO"],
    ["*", "Star", "x", "TODO"],
    ["n", "Note", "x", "TODO"],
    ["l", "Location", "x", "TODO"],
    ["i", "Information", "x", "TODO"],
    ["I", "Idea", "x", "TODO"],
    ["S", "Amount", "x", "TODO"],
    ["p", "Pro", "x", "TODO"],
    ["c", "Con", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ['"', "Quote", "x", "TODO"],
    ["0", "Speech bubble 0", "0", "NON_TASK"],
    ["1", "Speech bubble 1", "1", "NON_TASK"],
    ["2", "Speech bubble 2", "2", "NON_TASK"],
    ["3", "Speech bubble 3", "3", "NON_TASK"],
    ["4", "Speech bubble 4", "4", "NON_TASK"],
    ["5", "Speech bubble 5", "5", "NON_TASK"],
    ["6", "Speech bubble 6", "6", "NON_TASK"],
    ["7", "Speech bubble 7", "7", "NON_TASK"],
    ["8", "Speech bubble 8", "8", "NON_TASK"],
    ["9", "Speech bubble 9", "9", "NON_TASK"]
  ];
  return zzz;
}

// src/Config/Themes/AuraThemeCollection.ts
function auraSupportedStatuses() {
  const zzz = [
    [" ", "incomplete", "x", "TODO"],
    ["x", "complete / done", " ", "DONE"],
    ["-", "cancelled", " ", "CANCELLED"],
    [">", "deferred", "x", "TODO"],
    ["/", "in progress, or half-done", "x", "IN_PROGRESS"],
    ["!", "Important", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["R", "review", "x", "TODO"],
    ["+", "Inbox / task that should be processed later", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["B", "brainstorm", "x", "TODO"],
    ["D", "deferred or scheduled", "x", "TODO"],
    ["I", "Info", "x", "TODO"],
    ["i", "idea", "x", "TODO"],
    ["N", "note", "x", "TODO"],
    ["Q", "quote", "x", "TODO"],
    ["W", "win / success / reward", "x", "TODO"],
    ["P", "pro", "x", "TODO"],
    ["C", "con", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/EbullientworksThemeCollection.ts
function ebullientworksSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    [">", "Deferred", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["?", "Question", "x", "TODO"],
    ["r", "Review", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/ITSThemeCollection.ts
function itsSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Regular", " ", "DONE"],
    ["X", "Checked", " ", "DONE"],
    ["-", "Dropped", " ", "CANCELLED"],
    [">", "Forward", "x", "TODO"],
    ["D", "Date", "x", "TODO"],
    ["?", "Question", "x", "TODO"],
    ["/", "Half Done", "x", "IN_PROGRESS"],
    ["+", "Add", "x", "TODO"],
    ["R", "Research", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["i", "Idea", "x", "TODO"],
    ["B", "Brainstorm", "x", "TODO"],
    ["P", "Pro", "x", "TODO"],
    ["C", "Con", "x", "TODO"],
    ["Q", "Quote", "x", "TODO"],
    ["N", "Note", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ["I", "Information", "x", "TODO"],
    ["p", "Paraphrase", "x", "TODO"],
    ["L", "Location", "x", "TODO"],
    ["E", "Example", "x", "TODO"],
    ["A", "Answer", "x", "TODO"],
    ["r", "Reward", "x", "TODO"],
    ["c", "Choice", "x", "TODO"],
    ["d", "Doing", "x", "IN_PROGRESS"],
    ["T", "Time", "x", "TODO"],
    ["@", "Character / Person", "x", "TODO"],
    ["t", "Talk", "x", "TODO"],
    ["O", "Outline / Plot", "x", "TODO"],
    ["~", "Conflict", "x", "TODO"],
    ["W", "World", "x", "TODO"],
    ["f", "Clue / Find", "x", "TODO"],
    ["F", "Foreshadow", "x", "TODO"],
    ["H", "Favorite / Health", "x", "TODO"],
    ["&", "Symbolism", "x", "TODO"],
    ["s", "Secret", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/LYTModeThemeCollection.ts
function lytModeSupportedStatuses() {
  const zzz = [
    [" ", "Unchecked", "x", "TODO"],
    ["x", "Checked", " ", "DONE"],
    [">", "Rescheduled", "x", "TODO"],
    ["<", "Scheduled", "x", "TODO"],
    ["!", "Important", "x", "TODO"],
    ["-", "Cancelled", " ", "CANCELLED"],
    ["/", "In Progress", "x", "IN_PROGRESS"],
    ["?", "Question", "x", "TODO"],
    ["*", "Star", "x", "TODO"],
    ["n", "Note", "x", "TODO"],
    ["l", "Location", "x", "TODO"],
    ["i", "Information", "x", "TODO"],
    ["I", "Idea", "x", "TODO"],
    ["S", "Amount", "x", "TODO"],
    ["p", "Pro", "x", "TODO"],
    ["c", "Con", "x", "TODO"],
    ["b", "Bookmark", "x", "TODO"],
    ["f", "Fire", "x", "TODO"],
    ["k", "Key", "x", "TODO"],
    ["w", "Win", "x", "TODO"],
    ["u", "Up", "x", "TODO"],
    ["d", "Down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/MinimalThemeCollection.ts
function minimalSupportedStatuses() {
  const zzz = [
    [" ", "to-do", "x", "TODO"],
    ["/", "incomplete", "x", "IN_PROGRESS"],
    ["x", "done", " ", "DONE"],
    ["-", "canceled", " ", "CANCELLED"],
    [">", "forwarded", "x", "TODO"],
    ["<", "scheduling", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["!", "important", "x", "TODO"],
    ["*", "star", "x", "TODO"],
    ['"', "quote", "x", "TODO"],
    ["l", "location", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["i", "information", "x", "TODO"],
    ["S", "savings", "x", "TODO"],
    ["I", "idea", "x", "TODO"],
    ["p", "pros", "x", "TODO"],
    ["c", "cons", "x", "TODO"],
    ["f", "fire", "x", "TODO"],
    ["k", "key", "x", "TODO"],
    ["w", "win", "x", "TODO"],
    ["u", "up", "x", "TODO"],
    ["d", "down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/Themes/ThingsThemeCollection.ts
function thingsSupportedStatuses() {
  const zzz = [
    [" ", "to-do", "x", "TODO"],
    ["/", "incomplete", "x", "IN_PROGRESS"],
    ["x", "done", " ", "DONE"],
    ["-", "canceled", " ", "CANCELLED"],
    [">", "forwarded", "x", "TODO"],
    ["<", "scheduling", "x", "TODO"],
    ["?", "question", "x", "TODO"],
    ["!", "important", "x", "TODO"],
    ["*", "star", "x", "TODO"],
    ['"', "quote", "x", "TODO"],
    ["l", "location", "x", "TODO"],
    ["b", "bookmark", "x", "TODO"],
    ["i", "information", "x", "TODO"],
    ["S", "savings", "x", "TODO"],
    ["I", "idea", "x", "TODO"],
    ["p", "pros", "x", "TODO"],
    ["c", "cons", "x", "TODO"],
    ["f", "fire", "x", "TODO"],
    ["k", "key", "x", "TODO"],
    ["w", "win", "x", "TODO"],
    ["u", "up", "x", "TODO"],
    ["d", "down", "x", "TODO"]
  ];
  return zzz;
}

// src/Config/settingsConfiguration.json
var settingsConfiguration_default = [
  {
    text: "Core Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: "<p>These are the core statuses that Tasks supports natively, with no need for custom CSS styling or theming.</p><p>You can add edit and add your own custom statuses in the section below.</p>"
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertTaskCoreStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  },
  {
    text: "Custom Statuses",
    level: "h3",
    class: "",
    open: true,
    notice: {
      class: "setting-item-description",
      text: null,
      html: `<p>You should first <b>select and install a CSS Snippet or Theme</b> to style custom checkboxes.</p><p>Then, use the buttons below to set up your custom statuses, to match your chosen CSS checkboxes.</p><p><b>Note</b> Any statuses with the same symbol as any earlier statuses will be ignored. You can confirm the actually loaded statuses by running the 'Create or edit task' command and looking at the Status drop-down.</p><p></p><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Statuses">documentation</a> to get started!</p>`
    },
    settings: [
      {
        name: "",
        description: "",
        type: "function",
        initialValue: "",
        placeholder: "",
        settingName: "insertCustomTaskStatusSettings",
        featureFlag: "",
        notice: null
      }
    ]
  }
];

// src/Config/CustomStatusModal.ts
var import_obsidian11 = require("obsidian");

// src/StatusValidator.ts
var StatusValidator = class {
  validate(statusConfiguration) {
    const errors = [];
    errors.push(...this.validateSymbol(statusConfiguration));
    errors.push(...this.validateName(statusConfiguration));
    errors.push(...this.validateNextSymbol(statusConfiguration));
    return errors;
  }
  validateStatusCollectionEntry(entry) {
    const [symbol, _name, nextStatusSymbol, typeAsString] = entry;
    const errors = [];
    errors.push(...this.validateType(typeAsString));
    if (symbol === nextStatusSymbol && typeAsString !== "NON_TASK") {
      errors.push(`Status symbol '${symbol}' toggles to itself`);
    }
    if (errors.length > 0) {
      return errors;
    }
    const configuration = Status.createFromImportedValue(entry).configuration;
    errors.push(...this.validateSymbolTypeConventions(configuration));
    errors.push(...this.validate(configuration));
    return errors;
  }
  validateSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.symbol, "Task Status Symbol");
  }
  validateNextSymbol(statusConfiguration) {
    return StatusValidator.validateOneSymbol(statusConfiguration.nextStatusSymbol, "Task Next Status Symbol");
  }
  validateName(statusConfiguration) {
    const errors = [];
    if (statusConfiguration.name.length === 0) {
      errors.push("Task Status Name cannot be empty.");
    }
    return errors;
  }
  validateType(symbolName) {
    const statusTypeElement = StatusType[symbolName];
    const errors = [];
    if (!statusTypeElement) {
      errors.push(`Status Type "${symbolName}" is not a valid type`);
    }
    if (statusTypeElement == "EMPTY" /* EMPTY */) {
      errors.push('Status Type "EMPTY" is not permitted in user data');
    }
    return errors;
  }
  validateSymbolTypeConventions(configuration) {
    const errors = [];
    const symbol = configuration.symbol;
    const registry = new StatusRegistry();
    const symbolToSearchFor = symbol === "X" ? "x" : symbol;
    const defaultStatusFromRegistry = registry.bySymbol(symbolToSearchFor);
    if (defaultStatusFromRegistry.type !== "EMPTY" /* EMPTY */) {
      if (configuration.nextStatusSymbol !== defaultStatusFromRegistry.nextStatusSymbol) {
        errors.push(
          `Next Status Symbol for symbol '${symbol}': '${configuration.nextStatusSymbol}' is inconsistent with convention '${defaultStatusFromRegistry.nextStatusSymbol}'`
        );
      }
      if (configuration.type !== defaultStatusFromRegistry.type) {
        errors.push(
          `Status Type for symbol '${symbol}': '${configuration.type}' is inconsistent with convention '${defaultStatusFromRegistry.type}'`
        );
      }
    }
    return errors;
  }
  static validateOneSymbol(symbol, symbolName) {
    const errors = [];
    if (symbol.length === 0) {
      errors.push(`${symbolName} cannot be empty.`);
    }
    if (symbol.length > 1) {
      errors.push(`${symbolName} ("${symbol}") must be a single character.`);
    }
    return errors;
  }
};

// src/Config/CustomStatusModal.ts
var validator = new StatusValidator();
var CustomStatusModal = class extends import_obsidian11.Modal {
  constructor(plugin, statusType, isCoreStatus) {
    super(plugin.app);
    this.plugin = plugin;
    this.saved = false;
    this.error = false;
    this.statusSymbol = statusType.symbol;
    this.statusName = statusType.name;
    this.statusNextSymbol = statusType.nextStatusSymbol;
    this.statusAvailableAsCommand = statusType.availableAsCommand;
    this.type = statusType.type;
    this.isCoreStatus = isCoreStatus;
  }
  statusConfiguration() {
    return new StatusConfiguration(
      this.statusSymbol,
      this.statusName,
      this.statusNextSymbol,
      this.statusAvailableAsCommand,
      this.type
    );
  }
  display() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      const settingDiv = contentEl.createDiv();
      let statusSymbolText;
      new import_obsidian11.Setting(settingDiv).setName("Task Status Symbol").setDesc(
        "This is the character between the square braces. (It can only be edited for Custom statuses, and not Core statuses.)"
      ).addText((text2) => {
        statusSymbolText = text2;
        text2.setValue(this.statusSymbol).onChange((v) => {
          this.statusSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateSymbol(this.statusConfiguration()));
        });
      }).setDisabled(this.isCoreStatus).then((_setting) => {
        CustomStatusModal.setValid(statusSymbolText, validator.validateSymbol(this.statusConfiguration()));
      });
      let statusNameText;
      new import_obsidian11.Setting(settingDiv).setName("Task Status Name").setDesc("This is the friendly name of the task status.").addText((text2) => {
        statusNameText = text2;
        text2.setValue(this.statusName).onChange((v) => {
          this.statusName = v;
          CustomStatusModal.setValid(text2, validator.validateName(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(statusNameText, validator.validateName(this.statusConfiguration()));
      });
      let statusNextSymbolText;
      new import_obsidian11.Setting(settingDiv).setName("Task Next Status Symbol").setDesc("When clicked on this is the symbol that should be used next.").addText((text2) => {
        statusNextSymbolText = text2;
        text2.setValue(this.statusNextSymbol).onChange((v) => {
          this.statusNextSymbol = v;
          CustomStatusModal.setValid(text2, validator.validateNextSymbol(this.statusConfiguration()));
        });
      }).then((_setting) => {
        CustomStatusModal.setValid(
          statusNextSymbolText,
          validator.validateNextSymbol(this.statusConfiguration())
        );
      });
      new import_obsidian11.Setting(settingDiv).setName("Task Status Type").setDesc("Control how the status behaves for searching and toggling.").addDropdown((dropdown) => {
        const types = [
          "TODO" /* TODO */,
          "IN_PROGRESS" /* IN_PROGRESS */,
          "DONE" /* DONE */,
          "CANCELLED" /* CANCELLED */,
          "NON_TASK" /* NON_TASK */
        ];
        types.forEach((s) => {
          dropdown.addOption(s, s);
        });
        dropdown.setValue(this.type).onChange((v) => {
          this.type = Status.getTypeFromStatusTypeString(v);
        });
      });
      if (Status.tasksPluginCanCreateCommandsForStatuses()) {
        new import_obsidian11.Setting(settingDiv).setName("Available as command").setDesc(
          "If enabled this status will be available as a command so you can assign a hotkey and toggle the status using it."
        ).addToggle((toggle) => {
          toggle.setValue(this.statusAvailableAsCommand).onChange((value) => __async(this, null, function* () {
            this.statusAvailableAsCommand = value;
          }));
        });
      }
      const footerEl = contentEl.createDiv();
      const footerButtons = new import_obsidian11.Setting(footerEl);
      footerButtons.addButton((b) => {
        b.setTooltip("Save").setIcon("checkmark").onClick(() => __async(this, null, function* () {
          const errors = validator.validate(this.statusConfiguration());
          if (errors.length > 0) {
            const message = errors.join("\n") + "\n\nFix errors before saving.";
            new import_obsidian11.Notice(message);
            return;
          }
          this.saved = true;
          this.close();
        }));
        return b;
      });
      footerButtons.addExtraButton((b) => {
        b.setIcon("cross").setTooltip("Cancel").onClick(() => {
          this.saved = false;
          this.close();
        });
        return b;
      });
    });
  }
  onOpen() {
    this.display();
  }
  static setValidationError(textInput) {
    textInput.inputEl.addClass("tasks-settings-is-invalid");
  }
  static removeValidationError(textInput) {
    textInput.inputEl.removeClass("tasks-settings-is-invalid");
  }
  static setValid(text2, messages) {
    const valid = messages.length === 0;
    if (valid) {
      CustomStatusModal.removeValidationError(text2);
    } else {
      CustomStatusModal.setValidationError(text2);
    }
  }
};

// src/Config/SettingsTab.ts
var _SettingsTab = class extends import_obsidian12.PluginSettingTab {
  constructor({ plugin }) {
    super(plugin.app, plugin);
    this.customFunctions = {
      insertTaskCoreStatusSettings: this.insertTaskCoreStatusSettings.bind(this),
      insertCustomTaskStatusSettings: this.insertCustomTaskStatusSettings.bind(this)
    };
    this.plugin = plugin;
  }
  saveSettings(update2) {
    return __async(this, null, function* () {
      yield this.plugin.saveSettings();
      if (update2) {
        this.display();
      }
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.addClass("tasks-settings");
    containerEl.createEl("h3", { text: "Tasks Settings" });
    containerEl.createEl("p", {
      cls: "tasks-setting-important",
      text: "Changing any settings requires a restart of obsidian."
    });
    containerEl.createEl("h4", { text: "Task Format Settings" });
    new import_obsidian12.Setting(containerEl).setName("Task Format").setDesc(
      _SettingsTab.createFragmentWithHTML(
        '<p>The format that Tasks uses to read and write tasks.</p><p><b>Important:</b> Tasks currently only supports one format at a time. Selecting Dataview will currently <b>stop Tasks reading its own emoji signifiers</b>.</p><p>See the <a href="https://publish.obsidian.md/tasks/Reference/Task+Formats/About+Task+Formats">documentation</a>.</p>'
      )
    ).addDropdown((dropdown) => {
      for (const key of Object.keys(TASK_FORMATS)) {
        dropdown.addOption(key, TASK_FORMATS[key].displayName);
      }
      dropdown.setValue(getSettings().taskFormat).onChange((value) => __async(this, null, function* () {
        updateSettings({ taskFormat: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Global filter Settings" });
    new import_obsidian12.Setting(containerEl).setName("Global task filter").setDesc(
      _SettingsTab.createFragmentWithHTML(
        '<p><b>Recommended: Leave empty if you want all checklist items in your vault to be tasks managed by this plugin.</b></p><p>Use a global filter if you want Tasks to only act on a subset of your "<code>- [ ]</code>" checklist items, so that a checklist item must include the specified string in its description in order to be considered a task.<p><p>For example, if you set the global filter to <code>#task</code>, the Tasks plugin will only handle checklist items tagged with <code>#task</code>.</br>Other checklist items will remain normal checklist items and not appear in queries or get a done date set.</p><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Global+Filter">documentation</a>.</p>'
      )
    ).addText((text2) => {
      text2.setPlaceholder("e.g. #task or TODO").setValue(GlobalFilter.getInstance().get()).onChange((value) => __async(this, null, function* () {
        updateSettings({ globalFilter: value });
        GlobalFilter.getInstance().set(value);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Remove global filter from description").setDesc(
      "Enabling this removes the string that you set as global filter from the task description when displaying a task."
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.removeGlobalFilter).onChange((value) => __async(this, null, function* () {
        updateSettings({ removeGlobalFilter: value });
        GlobalFilter.getInstance().setRemoveGlobalFilter(value);
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Global Query" });
    makeMultilineTextSetting(
      new import_obsidian12.Setting(containerEl).setDesc(
        _SettingsTab.createFragmentWithHTML(
          '<p>A query that is automatically included at the start of every Tasks block in the vault. Useful for adding default filters, or layout options.</p><p>See the <a href="https://publish.obsidian.md/tasks/Queries/Global+Query">documentation</a>.</p>'
        )
      ).addTextArea((text2) => {
        const settings2 = getSettings();
        text2.inputEl.rows = 4;
        text2.setPlaceholder("# For example...\npath does not include _templates/\nlimit 300\nshow urgency").setValue(settings2.globalQuery).onChange((value) => __async(this, null, function* () {
          updateSettings({ globalQuery: value });
          GlobalQuery.getInstance().set(value);
          yield this.plugin.saveSettings();
        }));
      })
    );
    containerEl.createEl("h4", { text: "Task Statuses" });
    const { headingOpened } = getSettings();
    settingsConfiguration_default.forEach((heading) => {
      this.addOneSettingsBlock(containerEl, heading, headingOpened);
    });
    containerEl.createEl("h4", { text: "Date Settings" });
    new import_obsidian12.Setting(containerEl).setName("Set created date on every added task").setDesc(
      _SettingsTab.createFragmentWithHTML(
        `Enabling this will add a timestamp \u2795 YYYY-MM-DD before other date values, when a task is created with 'Create or edit task', or by completing a recurring task.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Dates#Created+date">documentation</a>.</p>`
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setCreatedDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setCreatedDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Set done date on every completed task").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will add a timestamp \u2705 YYYY-MM-DD at the end when a task is toggled to done.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Dates#Done+date">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.setDoneDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ setDoneDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Use filename as Scheduled date for undated tasks").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Save time entering Scheduled (\u23F3) dates.</br>If this option is enabled, any undated tasks will be given a default Scheduled date extracted from their file name.</br>The date in the file name must be in one of <code>YYYY-MM-DD</code> or <code>YYYYMMDD</code> formats.</br>Undated tasks have none of Due (\u{1F4C5} ), Scheduled (\u23F3) and Start (\u{1F6EB}) dates.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Use+Filename+as+Default+Date">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.useFilenameAsScheduledDate).onChange((value) => __async(this, null, function* () {
        updateSettings({ useFilenameAsScheduledDate: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Folders with default Scheduled dates").setDesc(
      "Leave empty if you want to use default Scheduled dates everywhere, or enter a comma-separated list of folders."
    ).addText((input) => __async(this, null, function* () {
      const settings2 = getSettings();
      yield this.plugin.saveSettings();
      input.setValue(_SettingsTab.renderFolderArray(settings2.filenameAsDateFolders)).onChange((value) => __async(this, null, function* () {
        const folders = _SettingsTab.parseCommaSeparatedFolders(value);
        updateSettings({ filenameAsDateFolders: folders });
        yield this.plugin.saveSettings();
      }));
    }));
    containerEl.createEl("h4", { text: "Recurring task Settings" });
    new import_obsidian12.Setting(containerEl).setName("Next recurrence appears on the line below").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will make the next recurrence of a task appear on the line below the completed task. Otherwise the next recurrence will appear before the completed one.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Recurring+Tasks">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const { recurrenceOnNextLine } = getSettings();
      toggle.setValue(recurrenceOnNextLine).onChange((value) => __async(this, null, function* () {
        updateSettings({ recurrenceOnNextLine: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Auto-suggest Settings" });
    new import_obsidian12.Setting(containerEl).setName("Auto-suggest task content").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'Enabling this will open an intelligent suggest menu while typing inside a recognized task line.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Auto-Suggest">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.autoSuggestInEditor).onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestInEditor: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Minimum match length for auto-suggest").setDesc(
      "If higher than 0, auto-suggest will be triggered only when the beginning of any supported keywords is recognized."
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(0, 3, 1).setValue(settings2.autoSuggestMinMatch).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMinMatch: value });
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian12.Setting(containerEl).setName("Maximum number of auto-suggestions to show").setDesc(
      'How many suggestions should be shown when an auto-suggest menu pops up (including the "\u23CE" option).'
    ).addSlider((slider) => {
      const settings2 = getSettings();
      slider.setLimits(3, 12, 1).setValue(settings2.autoSuggestMaxItems).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        updateSettings({ autoSuggestMaxItems: value });
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h4", { text: "Dialog Settings" });
    new import_obsidian12.Setting(containerEl).setName("Provide access keys in dialogs").setDesc(
      _SettingsTab.createFragmentWithHTML(
        'If the access keys (keyboard shortcuts) for various controls in dialog boxes conflict with system keyboard shortcuts or assistive technology functionality that is important for you, you may want to deactivate them here.</br><p>See the <a href="https://publish.obsidian.md/tasks/Getting+Started/Create+or+edit+Task#Keyboard+shortcuts">documentation</a>.</p>'
      )
    ).addToggle((toggle) => {
      const settings2 = getSettings();
      toggle.setValue(settings2.provideAccessKeys).onChange((value) => __async(this, null, function* () {
        updateSettings({ provideAccessKeys: value });
        yield this.plugin.saveSettings();
      }));
    });
  }
  addOneSettingsBlock(containerEl, heading, headingOpened) {
    const detailsContainer = containerEl.createEl("details", {
      cls: "tasks-nested-settings",
      attr: __spreadValues({}, heading.open || headingOpened[heading.text] ? { open: true } : {})
    });
    detailsContainer.empty();
    detailsContainer.ontoggle = () => {
      headingOpened[heading.text] = detailsContainer.open;
      updateSettings({ headingOpened });
      this.plugin.saveSettings();
    };
    const summary = detailsContainer.createEl("summary");
    new import_obsidian12.Setting(summary).setHeading().setName(heading.text);
    summary.createDiv("collapser").createDiv("handle");
    if (heading.notice !== null) {
      const notice = detailsContainer.createEl("div", {
        cls: heading.notice.class,
        text: heading.notice.text
      });
      if (heading.notice.html !== null) {
        notice.insertAdjacentHTML("beforeend", heading.notice.html);
      }
    }
    heading.settings.forEach((setting) => {
      if (setting.featureFlag !== "" && !isFeatureEnabled(setting.featureFlag)) {
        return;
      }
      if (setting.type === "checkbox") {
        new import_obsidian12.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addToggle((toggle) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          toggle.setValue(settings2.generalSettings[setting.settingName]).onChange((value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          }));
        });
      } else if (setting.type === "text") {
        new import_obsidian12.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addText((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian12.debounce)(onChange, 500, true));
        });
      } else if (setting.type === "textarea") {
        new import_obsidian12.Setting(detailsContainer).setName(setting.name).setDesc(setting.description).addTextArea((text2) => {
          const settings2 = getSettings();
          if (!settings2.generalSettings[setting.settingName]) {
            updateGeneralSetting(setting.settingName, setting.initialValue);
          }
          const onChange = (value) => __async(this, null, function* () {
            updateGeneralSetting(setting.settingName, value);
            yield this.plugin.saveSettings();
          });
          text2.setPlaceholder(setting.placeholder.toString()).setValue(settings2.generalSettings[setting.settingName].toString()).onChange((0, import_obsidian12.debounce)(onChange, 500, true));
          text2.inputEl.rows = 8;
          text2.inputEl.cols = 40;
        });
      } else if (setting.type === "function") {
        this.customFunctions[setting.settingName](detailsContainer, this);
      }
      if (setting.notice !== null) {
        const notice = detailsContainer.createEl("p", {
          cls: setting.notice.class,
          text: setting.notice.text
        });
        if (setting.notice.html !== null) {
          notice.insertAdjacentHTML("beforeend", setting.notice.html);
        }
      }
    });
  }
  static parseCommaSeparatedFolders(input) {
    return input.split(",").map((folder) => folder.trim()).map((folder) => folder.replace(/^\/|\/$/g, "")).filter((folder) => folder !== "");
  }
  static renderFolderArray(folders) {
    return folders.join(",");
  }
  insertTaskCoreStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.coreStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.coreStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        true
      );
    });
  }
  insertCustomTaskStatusSettings(containerEl, settings2) {
    const { statusSettings } = getSettings();
    statusSettings.customStatuses.forEach((status_type) => {
      createRowForTaskStatus(
        containerEl,
        status_type,
        statusSettings.customStatuses,
        statusSettings,
        settings2,
        settings2.plugin,
        false
      );
    });
    containerEl.createEl("div");
    const setting = new import_obsidian12.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add New Task Status").setCta().onClick(() => __async(this, null, function* () {
        StatusSettings.addStatus(
          statusSettings.customStatuses,
          new StatusConfiguration("", "", "", false, "TODO" /* TODO */)
        );
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    setting.infoEl.remove();
    const themes = [
      ["AnuPpuccin Theme", anuppuccinSupportedStatuses()],
      ["Aura Theme", auraSupportedStatuses()],
      ["Ebullientworks Theme", ebullientworksSupportedStatuses()],
      ["ITS Theme & SlRvb Checkboxes", itsSupportedStatuses()],
      ["Minimal Theme", minimalSupportedStatuses()],
      ["Things Theme", thingsSupportedStatuses()],
      ["LYT Mode Theme (Dark mode only)", lytModeSupportedStatuses()]
    ];
    for (const [name, collection] of themes) {
      const addStatusesSupportedByThisTheme = new import_obsidian12.Setting(containerEl).addButton((button) => {
        const label = `${name}: Add ${collection.length} supported Statuses`;
        button.setButtonText(label).onClick(() => __async(this, null, function* () {
          yield addCustomStatesToSettings(collection, statusSettings, settings2);
        }));
      });
      addStatusesSupportedByThisTheme.infoEl.remove();
    }
    const addAllUnknownStatuses = new import_obsidian12.Setting(containerEl).addButton((button) => {
      button.setButtonText("Add All Unknown Status Types").setCta().onClick(() => __async(this, null, function* () {
        const tasks = this.plugin.getTasks();
        const allStatuses = tasks.map((task) => {
          return task.status;
        });
        const unknownStatuses = StatusRegistry.getInstance().findUnknownStatuses(allStatuses);
        if (unknownStatuses.length === 0) {
          return;
        }
        unknownStatuses.forEach((s) => {
          StatusSettings.addStatus(statusSettings.customStatuses, s);
        });
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    addAllUnknownStatuses.infoEl.remove();
    const clearCustomStatuses = new import_obsidian12.Setting(containerEl).addButton((button) => {
      button.setButtonText("Reset Custom Status Types to Defaults").setWarning().onClick(() => __async(this, null, function* () {
        StatusSettings.resetAllCustomStatuses(statusSettings);
        yield updateAndSaveStatusSettings(statusSettings, settings2);
      }));
    });
    clearCustomStatuses.infoEl.remove();
  }
};
var SettingsTab = _SettingsTab;
SettingsTab.createFragmentWithHTML = (html) => createFragment((documentFragment) => documentFragment.createDiv().innerHTML = html);
function createRowForTaskStatus(containerEl, statusType, statuses, statusSettings, settings2, plugin, isCoreStatus) {
  const taskStatusPreview = containerEl.createEl("pre");
  taskStatusPreview.addClass("row-for-status");
  taskStatusPreview.textContent = new Status(statusType).previewText();
  const setting = new import_obsidian12.Setting(containerEl);
  setting.infoEl.replaceWith(taskStatusPreview);
  if (!isCoreStatus) {
    setting.addExtraButton((extra) => {
      extra.setIcon("cross").setTooltip("Delete").onClick(() => __async(this, null, function* () {
        if (StatusSettings.deleteStatus(statuses, statusType)) {
          yield updateAndSaveStatusSettings(statusSettings, settings2);
        }
      }));
    });
  }
  setting.addExtraButton((extra) => {
    extra.setIcon("pencil").setTooltip("Edit").onClick(() => __async(this, null, function* () {
      const modal = new CustomStatusModal(plugin, statusType, isCoreStatus);
      modal.onClose = () => __async(this, null, function* () {
        if (modal.saved) {
          if (StatusSettings.replaceStatus(statuses, statusType, modal.statusConfiguration())) {
            yield updateAndSaveStatusSettings(statusSettings, settings2);
          }
        }
      });
      modal.open();
    }));
  });
  setting.infoEl.remove();
}
function addCustomStatesToSettings(supportedStatuses, statusSettings, settings2) {
  return __async(this, null, function* () {
    const notices = StatusSettings.bulkAddStatusCollection(statusSettings, supportedStatuses);
    notices.forEach((notice) => {
      new import_obsidian12.Notice(notice);
    });
    yield updateAndSaveStatusSettings(statusSettings, settings2);
  });
}
function updateAndSaveStatusSettings(statusTypes, settings2) {
  return __async(this, null, function* () {
    updateSettings({
      statusSettings: statusTypes
    });
    StatusSettings.applyToStatusRegistry(statusTypes, StatusRegistry.getInstance());
    yield settings2.saveSettings(true);
  });
}
function makeMultilineTextSetting(setting) {
  const { settingEl, infoEl, controlEl } = setting;
  const textEl = controlEl.querySelector("textarea");
  if (textEl === null) {
    return;
  }
  settingEl.style.display = "block";
  infoEl.style.marginRight = "0px";
  textEl.style.minWidth = "-webkit-fill-available";
}

// src/Suggestor/EditorSuggestorPopup.ts
var import_obsidian13 = require("obsidian");
var EditorSuggestor = class extends import_obsidian13.EditorSuggest {
  constructor(app2, settings2) {
    super(app2);
    this.settings = settings2;
  }
  onTrigger(cursor, editor, _file) {
    if (!this.settings.autoSuggestInEditor)
      return null;
    const line = editor.getLine(cursor.line);
    if (canSuggestForLine(line, cursor.ch)) {
      return {
        start: { line: cursor.line, ch: 0 },
        end: {
          line: cursor.line,
          ch: line.length
        },
        query: line
      };
    }
    return null;
  }
  getSuggestions(context) {
    var _a, _b, _c;
    const line = context.query;
    const currentCursor = context.editor.getCursor();
    const suggestions = (_c = (_b = (_a = getUserSelectedTaskFormat()).buildSuggestions) == null ? void 0 : _b.call(_a, line, currentCursor.ch, this.settings)) != null ? _c : [];
    return suggestions.map((s) => __spreadProps(__spreadValues({}, s), { context }));
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    var _a, _b, _c;
    const editor = value.context.editor;
    if (value.suggestionType === "empty") {
      this.close();
      const eventClone = new KeyboardEvent("keydown", {
        code: "Enter",
        key: "Enter"
      });
      (_b = (_a = editor == null ? void 0 : editor.cm) == null ? void 0 : _a.contentDOM) == null ? void 0 : _b.dispatchEvent(eventClone);
      return;
    }
    const currentCursor = value.context.editor.getCursor();
    const replaceFrom = {
      line: currentCursor.line,
      ch: (_c = value.insertAt) != null ? _c : currentCursor.ch
    };
    const replaceTo = value.insertSkip ? {
      line: currentCursor.line,
      ch: replaceFrom.ch + value.insertSkip
    } : void 0;
    value.context.editor.replaceRange(value.appendText, replaceFrom, replaceTo);
    value.context.editor.setCursor({
      line: currentCursor.line,
      ch: replaceFrom.ch + value.appendText.length
    });
  }
};

// src/Api/createTaskLineModal.ts
var createTaskLineModal = (app2, taskModalFactory) => {
  let resolvePromise;
  const waitForClose = new Promise((resolve, _) => {
    resolvePromise = resolve;
  });
  const onSubmit = (updatedTasks) => {
    const line = updatedTasks.map((task) => task.toFileLineString()).join("\n");
    resolvePromise(line);
  };
  const taskModal = taskModalFactory(app2, onSubmit);
  taskModal.open();
  return waitForClose;
};

// src/Api/createTaskLineModalHelper.ts
var defaultTaskModalFactory = (app2, onSubmit) => {
  const task = taskFromLine({ line: "", path: "" });
  return new TaskModal({ app: app2, task, onSubmit });
};

// src/Api/index.ts
var tasksApiV1 = (app2) => {
  return {
    createTaskLineModal: () => {
      return createTaskLineModal(app2, defaultTaskModalFactory);
    }
  };
};

// src/main.ts
var TasksPlugin = class extends import_obsidian14.Plugin {
  get apiV1() {
    return tasksApiV1(app);
  }
  onload() {
    return __async(this, null, function* () {
      logging.registerConsoleLogger();
      console.log('loading plugin "tasks"');
      yield this.loadSettings();
      this.addSettingTab(new SettingsTab({ plugin: this }));
      initializeFile({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        workspace: this.app.workspace
      });
      yield this.loadTaskStatuses();
      const events = new TasksEvents({ obsidianEvents: this.app.workspace });
      this.cache = new Cache2({
        metadataCache: this.app.metadataCache,
        vault: this.app.vault,
        events
      });
      this.inlineRenderer = new InlineRenderer({ plugin: this });
      this.queryRenderer = new QueryRenderer({ plugin: this, events });
      this.registerEditorExtension(newLivePreviewExtension());
      this.registerEditorSuggest(new EditorSuggestor(this.app, getSettings()));
      new Commands({ plugin: this });
    });
  }
  loadTaskStatuses() {
    return __async(this, null, function* () {
      const { statusSettings } = getSettings();
      StatusSettings.applyToStatusRegistry(statusSettings, StatusRegistry.getInstance());
    });
  }
  onunload() {
    var _a;
    console.log('unloading plugin "tasks"');
    (_a = this.cache) == null ? void 0 : _a.unload();
  }
  loadSettings() {
    return __async(this, null, function* () {
      const newSettings = yield this.loadData();
      updateSettings(newSettings);
      GlobalFilter.getInstance().set(newSettings.globalFilter);
      GlobalFilter.getInstance().setRemoveGlobalFilter(newSettings.removeGlobalFilter);
      GlobalQuery.getInstance().set(newSettings.globalQuery);
      yield this.loadTaskStatuses();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(getSettings());
    });
  }
  getTasks() {
    var _a;
    return (_a = this.cache) == null ? void 0 : _a.getTasks();
  }
};
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy91dGlscy9wYXR0ZXJuLnRzIiwgIm5vZGVfbW9kdWxlcy9kYXlqcy9kYXlqcy5taW4uanMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jYWxjdWxhdGlvbi95ZWFycy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vcXVhcnRlck9mWWVhci5qcyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL3V0aWxzL2RheWpzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdGltZXpvbmUudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9yZXN1bHRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvQWJzdHJhY3RQYXJzZXJXaXRoV29yZEJvdW5kYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5Nb250aE5hbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5DYXN1YWxZZWFyTW9udGhEYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5TbGFzaE1vbnRoRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvQWJzdHJhY3RUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTlRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvdXRpbHMvdGltZXVuaXRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lVW5pdExhdGVyRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL2Fic3RyYWN0UmVmaW5lcnMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvQWJzdHJhY3RNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3JlZmluZXJzL0VOTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY2FsY3VsYXRpb24vbWVyZ2luZ0NhbGN1bGF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL0Fic3RyYWN0TWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3JlZmluZXJzL0VOTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRXh0cmFjdFRpbWV6b25lQWJiclJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRXh0cmFjdFRpbWV6b25lT2Zmc2V0UmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9yZWZpbmVycy9PdmVybGFwUmVtb3ZhbFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcmVmaW5lcnMvRm9yd2FyZERhdGVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL1VubGlrZWx5Rm9ybWF0RmlsdGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3BhcnNlcnMvSVNPRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvY29tbW9uL3JlZmluZXJzL01lcmdlV2Vla2RheUNvbXBvbmVudFJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb25maWd1cmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2NvbW1vbi9jYXN1YWxSZWZlcmVuY2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9wYXJzZXJzL0VOQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTkNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jYWxjdWxhdGlvbi93ZWVrcy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vcGFyc2Vycy9FTldlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5SZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jaHJvbm8udHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9jb21tb24vcGFyc2Vycy9TbGFzaERhdGVGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2VuL3BhcnNlcnMvRU5UaW1lVW5pdENhc3VhbFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9lbi9yZWZpbmVycy9FTk1lcmdlUmVsYXRpdmVEYXRlUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZW4vaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERVNwZWNpZmljVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3JlZmluZXJzL0RFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9yZWZpbmVycy9ERU1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9wYXJzZXJzL0RFQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZGUvcGFyc2Vycy9ERUNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2RlL3BhcnNlcnMvREVUaW1lVW5pdFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9kZS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUkNhc3VhbERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJDYXN1YWxUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3JlZmluZXJzL0ZSTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3JlZmluZXJzL0ZSTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSU3BlY2lmaWNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvZnIvcGFyc2Vycy9GUlRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9wYXJzZXJzL0ZSVGltZVVuaXRXaXRoaW5Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2ZyL3BhcnNlcnMvRlJUaW1lVW5pdFJlbGF0aXZlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9mci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9wYXJzZXJzL0pQU3RhbmRhcmRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL2phL3JlZmluZXJzL0pQTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9qYS9wYXJzZXJzL0pQQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvamEvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcGFyc2Vycy9QVFdlZWtkYXlQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcmVmaW5lcnMvUFRNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvcmVmaW5lcnMvUFRNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3B0L3BhcnNlcnMvUFRDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9wdC9wYXJzZXJzL1BUQ2FzdWFsVGltZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcHQvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3JlZmluZXJzL05MTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9yZWZpbmVycy9OTE1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0V2l0aGluRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTE1vbnRoTmFtZU1pZGRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTE1vbnRoTmFtZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFNsYXNoTW9udGhGb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL25sL3BhcnNlcnMvTkxUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbFllYXJNb250aERheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTENhc3VhbERhdGVUaW1lUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvcGFyc2Vycy9OTFRpbWVVbml0QWdvRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ubC9wYXJzZXJzL05MVGltZVVuaXRMYXRlckZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvbmwvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnRDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudERhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcGFyc2Vycy9aSEhhbnREZWFkbGluZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFJlbGF0aW9uV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9wYXJzZXJzL1pISGFudFRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW50L3BhcnNlcnMvWkhIYW50V2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFudC9yZWZpbmVycy9aSEhhbnRNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvcmVmaW5lcnMvWkhIYW50TWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnQvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNDYXN1YWxEYXRlUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc0RhdGVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcGFyc2Vycy9aSEhhbnNEZWFkbGluZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1JlbGF0aW9uV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9wYXJzZXJzL1pISGFuc1RpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy96aC9oYW5zL3BhcnNlcnMvWkhIYW5zV2Vla2RheVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvemgvaGFucy9yZWZpbmVycy9aSEhhbnNNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvcmVmaW5lcnMvWkhIYW5zTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2hhbnMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3poL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVUaW1lVW5pdFdpdGhpbkZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVU1vbnRoTmFtZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVVRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRBZ29Gb3JtYXRQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3JlZmluZXJzL1JVTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9yZWZpbmVycy9SVU1lcmdlRGF0ZVRpbWVSZWZpbmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVQ2FzdWFsRGF0ZVBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvcGFyc2Vycy9SVUNhc3VhbFRpbWVQYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9sb2NhbGVzL3J1L3BhcnNlcnMvUlVXZWVrZGF5UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9jaHJvbm8tbm9kZS9zcmMvbG9jYWxlcy9ydS9wYXJzZXJzL1JVVGltZVVuaXRDYXN1YWxSZWxhdGl2ZUZvcm1hdFBhcnNlci50cyIsICJub2RlX21vZHVsZXMvY2hyb25vLW5vZGUvc3JjL2xvY2FsZXMvcnUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL2Nocm9uby1ub2RlL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvbXVzdGFjaGUtdmFsaWRhdG9yL2Rpc3QvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9jb25zdC5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvbGV4L2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9sZXgvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2xleC9sZXguanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL3BhcnNlL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9wYXJzZS9wYXJzZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvZXZhbHVhdGUvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2Jvb24tanMvbGliL2V2YWx1YXRlL2NvbnN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ib29uLWpzL2xpYi9ldmFsdWF0ZS9ldmFsdWF0ZS5qcyIsICJub2RlX21vZHVsZXMvYm9vbi1qcy9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjIvbGliL2V2ZW50ZW1pdHRlcjIuanMiLCAic3JjL21haW4udHMiLCAic3JjL0NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy1tdXRleC9pbmRleC5tanMiLCAic3JjL1F1ZXJ5L0RhdGVQYXJzZXIudHMiLCAic3JjL1F1ZXJ5L0RhdGVSYW5nZS50cyIsICJzcmMvRGF0ZUFiYnJldmlhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy93ZWVrZGF5LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV1dGlsLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvY2FsbGJhY2tpdGVycmVzdWx0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL2kxOG4udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ubHAvdG90ZXh0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3BhcnNldGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvZGF0ZXRpbWUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9wYXJzZW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9wYXJzZXN0cmluZy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV3aXRoem9uZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL29wdGlvbnN0b3N0cmluZy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhY2hlLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbWFza3MudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby95ZWFyaW5mby50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL21vbnRoaW5mby50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL2Vhc3Rlci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJpbmZvL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlci9wb3NsaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcnNldC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc3RyLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcnJ1bGVzZXQudHMiLCAic3JjL2xpYi9EYXRlVG9vbHMudHMiLCAic3JjL1JlY3VycmVuY2UudHMiLCAic3JjL2xpYi9SZWdFeHBUb29scy50cyIsICJzcmMvQ29uZmlnL0dsb2JhbEZpbHRlci50cyIsICJzcmMvU3VnZ2VzdG9yL1N1Z2dlc3Rvci50cyIsICJzcmMvVGFza0xheW91dC50cyIsICJzcmMvVGFza1NlcmlhbGl6ZXIvRGVmYXVsdFRhc2tTZXJpYWxpemVyLnRzIiwgInNyYy9UYXNrU2VyaWFsaXplci9EYXRhdmlld1Rhc2tTZXJpYWxpemVyLnRzIiwgInNyYy9TdGF0dXNDb25maWd1cmF0aW9uLnRzIiwgInNyYy9TdGF0dXMudHMiLCAic3JjL0NvbmZpZy9EZWJ1Z1NldHRpbmdzLnRzIiwgInNyYy9Db25maWcvU3RhdHVzU2V0dGluZ3MudHMiLCAic3JjL0NvbmZpZy9GZWF0dXJlLnRzIiwgInNyYy9Db25maWcvU2V0dGluZ3MudHMiLCAic3JjL1N0YXR1c1JlZ2lzdHJ5LnRzIiwgInNyYy9VcmdlbmN5LnRzIiwgInNyYy9EYXRlRmFsbGJhY2sudHMiLCAic3JjL1NjcmlwdGluZy9UYXNrc0RhdGUudHMiLCAic3JjL1NjcmlwdGluZy9UYXNrc0ZpbGUudHMiLCAic3JjL2xpYi9Qcmlvcml0eVRvb2xzLnRzIiwgInNyYy9UYXNrLnRzIiwgInNyYy9saWIvTGF6eS50cyIsICJzcmMvVGFza0xvY2F0aW9uLnRzIiwgInNyYy9Db21tYW5kcy9DcmVhdGVPckVkaXQudHMiLCAic3JjL1Rhc2tNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcyIsICJzcmMvdWkvRWRpdFRhc2suc3ZlbHRlIiwgInNyYy9Db21tYW5kcy9DcmVhdGVPckVkaXRUYXNrUGFyc2VyLnRzIiwgInNyYy9Db21tYW5kcy9Ub2dnbGVEb25lLnRzIiwgInNyYy9Db21tYW5kcy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUubWpzIiwgInNyYy9TY3JpcHRpbmcvRXhwYW5kUGxhY2Vob2xkZXJzLnRzIiwgInNyYy9TY3JpcHRpbmcvUXVlcnlDb250ZXh0LnRzIiwgInNyYy9saWIvRXhjZXB0aW9uVG9vbHMudHMiLCAic3JjL1F1ZXJ5L1NvcnRlci50cyIsICJzcmMvUXVlcnkvR3JvdXBlci50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9FeHBsYWluL0V4cGxhbmF0aW9uLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVyLnRzIiwgInNyYy9RdWVyeS9RdWVyeUNvbXBvbmVudE9yRXJyb3IudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9GaWx0ZXJPckVycm9yTWVzc2FnZS50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0ZpbHRlckluc3RydWN0aW9uLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVySW5zdHJ1Y3Rpb25zLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRHVlRGF0ZUZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvUHJpb3JpdHlGaWVsZC50cyIsICJzcmMvUXVlcnkvTWF0Y2hlcnMvSVN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1N1YnN0cmluZ01hdGNoZXIudHMiLCAic3JjL1F1ZXJ5L01hdGNoZXJzL1JlZ2V4TWF0Y2hlci50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1RleHRGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1BhdGhGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1VyZ2VuY3lGaWVsZC50cyIsICJzcmMvUXVlcnkvU29ydC50cyIsICJzcmMvUXVlcnkvR3JvdXBEaXNwbGF5SGVhZGluZy50cyIsICJzcmMvUXVlcnkvR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yLnRzIiwgInNyYy9RdWVyeS9Hcm91cGluZ1RyZWVOb2RlLnRzIiwgInNyYy9RdWVyeS9UYXNrR3JvdXBpbmdUcmVlLnRzIiwgInNyYy9RdWVyeS9UYXNrR3JvdXAudHMiLCAic3JjL1F1ZXJ5L1Rhc2tHcm91cHMudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9EZXNjcmlwdGlvbkZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQ3JlYXRlZERhdGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0RvbmVEYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9FeGNsdWRlU3ViSXRlbXNGaWVsZC50cyIsICJzcmMvU2NyaXB0aW5nL0V4cHJlc3Npb24udHMiLCAic3JjL1NjcmlwdGluZy9UYXNrRXhwcmVzc2lvbi50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0Z1bmN0aW9uRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9IZWFkaW5nRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TY2hlZHVsZWREYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9TdGFydERhdGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0hhcHBlbnNEYXRlRmllbGQudHMiLCAic3JjL1F1ZXJ5L0ZpbHRlci9SZWN1cnJpbmdGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL011bHRpVGV4dEZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvVGFnc0ZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQm9vbGVhbkZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvRmlsZW5hbWVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c05hbWVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1N0YXR1c1R5cGVGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL1JlY3VycmVuY2VGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyL0ZvbGRlckZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvUm9vdEZpZWxkLnRzIiwgInNyYy9RdWVyeS9GaWx0ZXIvQmFja2xpbmtGaWVsZC50cyIsICJzcmMvUXVlcnkvRmlsdGVyUGFyc2VyLnRzIiwgInNyYy9RdWVyeS9RdWVyeVJlc3VsdC50cyIsICJzcmMvUXVlcnkvUXVlcnkudHMiLCAic3JjL0NvbmZpZy9HbG9iYWxRdWVyeS50cyIsICJzcmMvVGFza3NFdmVudHMudHMiLCAic3JjL0ZpbGUudHMiLCAic3JjL2xpYi9Nb2NrRGF0YUNyZWF0b3IudHMiLCAic3JjL2xpYi9sb2dnaW5nLnRzIiwgInNyYy9JbmxpbmVSZW5kZXJlci50cyIsICJzcmMvVGFza0xpbmVSZW5kZXJlci50cyIsICJzcmMvTGl2ZVByZXZpZXdFeHRlbnNpb24udHMiLCAic3JjL1F1ZXJ5UmVuZGVyZXIudHMiLCAic3JjL2xpYi9RdWVyeVJlbmRlcmVySGVscGVyLnRzIiwgInNyYy9Db25maWcvU2V0dGluZ3NUYWIudHMiLCAic3JjL0NvbmZpZy9UaGVtZXMvQW51UHB1Y2NpblRoZW1lQ29sbGVjdGlvbi50cyIsICJzcmMvQ29uZmlnL1RoZW1lcy9BdXJhVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL0VidWxsaWVudHdvcmtzVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL0lUU1RoZW1lQ29sbGVjdGlvbi50cyIsICJzcmMvQ29uZmlnL1RoZW1lcy9MWVRNb2RlVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvVGhlbWVzL01pbmltYWxUaGVtZUNvbGxlY3Rpb24udHMiLCAic3JjL0NvbmZpZy9UaGVtZXMvVGhpbmdzVGhlbWVDb2xsZWN0aW9uLnRzIiwgInNyYy9Db25maWcvQ3VzdG9tU3RhdHVzTW9kYWwudHMiLCAic3JjL1N0YXR1c1ZhbGlkYXRvci50cyIsICJzcmMvU3VnZ2VzdG9yL0VkaXRvclN1Z2dlc3RvclBvcHVwLnRzIiwgInNyYy9BcGkvY3JlYXRlVGFza0xpbmVNb2RhbC50cyIsICJzcmMvQXBpL2NyZWF0ZVRhc2tMaW5lTW9kYWxIZWxwZXIudHMiLCAic3JjL0FwaS9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFtudWxsLCAiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSxEPVwiZW5cIix2PXt9O3ZbRF09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24odCxlLG4pe3ZhciByO2lmKCF0KXJldHVybiBEO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXZbdF0mJihyPXQpLGUmJih2W3RdPWUscj10KTtlbHNle3ZhciBpPXQubmFtZTt2W2ldPXQscj1pfXJldHVybiFuJiZyJiYoRD1yKSxyfHwhbiYmRH0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIEQ9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLHY9KHk8RD95Kzc6eSktRDtyZXR1cm4gJChyP20tdjptKyg2LXYpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zdWJzdHIoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sRD1PLm0odGhpcyxNKTtyZXR1cm4gRD0obD17fSxsW2NdPUQvMTIsbFtmXT1ELGxbaF09RC8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD9EOk8uYShEKX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdlt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxiPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1iLFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtiW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj12W0RdLHcuTHM9dix3LnA9e30sd30pKTsiLCBudWxsLCBudWxsLCAiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUobik6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fcXVhcnRlck9mWWVhcj1uKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9XCJtb250aFwiLG49XCJxdWFydGVyXCI7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHI9aS5wcm90b3R5cGU7ci5xdWFydGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiR1dGlscygpLnUodCk/TWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkrMSkvMyk6dGhpcy5tb250aCh0aGlzLm1vbnRoKCklMyszKih0LTEpKX07dmFyIHM9ci5hZGQ7ci5hZGQ9ZnVuY3Rpb24oZSxpKXtyZXR1cm4gZT1OdW1iZXIoZSksdGhpcy4kdXRpbHMoKS5wKGkpPT09bj90aGlzLmFkZCgzKmUsdCk6cy5iaW5kKHRoaXMpKGUsaSl9O3ZhciB1PXIuc3RhcnRPZjtyLnN0YXJ0T2Y9ZnVuY3Rpb24oZSxpKXt2YXIgcj10aGlzLiR1dGlscygpLHM9ISFyLnUoaSl8fGk7aWYoci5wKGUpPT09bil7dmFyIG89dGhpcy5xdWFydGVyKCktMTtyZXR1cm4gcz90aGlzLm1vbnRoKDMqbykuc3RhcnRPZih0KS5zdGFydE9mKFwiZGF5XCIpOnRoaXMubW9udGgoMypvKzIpLmVuZE9mKHQpLmVuZE9mKFwiZGF5XCIpfXJldHVybiB1LmJpbmQodGhpcykoZSxpKX19fSkpOyIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBhdGhTeW1ib2wgPSBTeW1ib2woXCJNdXN0YWNoZURhdGFQYXRoXCIpO1xuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlQYXRoQXJyYXkoeyB0YXJnZXQsIHByb3BlcnR5TmFtZSwgfSkge1xuICAgIHJldHVybiBbLi4uKHRhcmdldFtQYXRoU3ltYm9sXSB8fCBbXSksIHByb3BlcnR5TmFtZV07XG59XG5mdW5jdGlvbiBwcm94eU11c3RhY2hlRGF0YShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb3h5KGRhdGEsIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEocHJvcGVydHlOYW1lIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBjcmVhdGVQcm9wZXJ0eVBhdGhBcnJheSh7IHRhcmdldCwgcHJvcGVydHlOYW1lIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGFuZGxlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVFcnJvcihwYXRoU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNzaW5nIE11c3RhY2hlIGRhdGEgcHJvcGVydHk6ICR7cGF0aFNlZ21lbnRzLmpvaW4oXCIgPiBcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbUGF0aFN5bWJvbF0gPSBjcmVhdGVQcm9wZXJ0eVBhdGhBcnJheSh7IHRhcmdldCwgcHJvcGVydHlOYW1lIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm94eU11c3RhY2hlRGF0YSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcm94eU11c3RhY2hlRGF0YTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlRva2VucyA9IGV4cG9ydHMuU3RydWN0dXJhbENoYXJhY3RlcnMgPSBleHBvcnRzLk9wZXJhdG9ycyA9IHZvaWQgMDtcbnZhciBPcGVyYXRvcnM7XG4oZnVuY3Rpb24gKE9wZXJhdG9ycykge1xuICAgIE9wZXJhdG9yc1tcIkFORFwiXSA9IFwiQU5EXCI7XG4gICAgT3BlcmF0b3JzW1wiT1JcIl0gPSBcIk9SXCI7XG4gICAgT3BlcmF0b3JzW1wiWE9SXCJdID0gXCJYT1JcIjtcbiAgICBPcGVyYXRvcnNbXCJOT1RcIl0gPSBcIk5PVFwiO1xufSkoT3BlcmF0b3JzID0gZXhwb3J0cy5PcGVyYXRvcnMgfHwgKGV4cG9ydHMuT3BlcmF0b3JzID0ge30pKTtcbnZhciBTdHJ1Y3R1cmFsQ2hhcmFjdGVycztcbihmdW5jdGlvbiAoU3RydWN0dXJhbENoYXJhY3RlcnMpIHtcbiAgICBTdHJ1Y3R1cmFsQ2hhcmFjdGVyc1tcIk9QRU5fUEFSRU5USEVTSVNcIl0gPSBcIihcIjtcbiAgICBTdHJ1Y3R1cmFsQ2hhcmFjdGVyc1tcIkNMT1NFX1BBUkVOVEhFU0lTXCJdID0gXCIpXCI7XG59KShTdHJ1Y3R1cmFsQ2hhcmFjdGVycyA9IGV4cG9ydHMuU3RydWN0dXJhbENoYXJhY3RlcnMgfHwgKGV4cG9ydHMuU3RydWN0dXJhbENoYXJhY3RlcnMgPSB7fSkpO1xudmFyIFRva2VucztcbihmdW5jdGlvbiAoVG9rZW5zKSB7XG4gICAgVG9rZW5zW1wiSURFTlRJRklFUlwiXSA9IFwiSURFTlRJRklFUlwiO1xuICAgIFRva2Vuc1tcIk9QRVJBVE9SXCJdID0gXCJPUEVSQVRPUlwiO1xuICAgIFRva2Vuc1tcIlNUUlVDVFVSQUxfQ0hBUkFDVEVSXCJdID0gXCJTVFJVQ1RVUkFMX0NIQVJBQ1RFUlwiO1xuICAgIFRva2Vuc1tcIkVPRlwiXSA9IFwiRU9GXCI7XG4gICAgVG9rZW5zW1wiQ09NTUVOVFwiXSA9IFwiQ09NTUVOVFwiO1xufSkoVG9rZW5zID0gZXhwb3J0cy5Ub2tlbnMgfHwgKGV4cG9ydHMuVG9rZW5zID0ge30pKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlZBTElEX1RPS0VOUyA9IGV4cG9ydHMuT1BFUkFUT1JfUFJFQ0VERU5DRSA9IHZvaWQgMDtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuZXhwb3J0cy5PUEVSQVRPUl9QUkVDRURFTkNFID0ge1xuICAgIE5PVDogMCxcbiAgICBYT1I6IDEsXG4gICAgQU5EOiAyLFxuICAgIE9SOiAzXG59O1xuZXhwb3J0cy5WQUxJRF9UT0tFTlMgPSB7XG4gICAgaWRlbnRpZmllck9ubHk6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSLFxuICAgICAgICAgICAgdmFsdWU6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgIF0sXG4gICAgaWRlbnRpZmllck9yTm90OiBbXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUiB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUixcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlc18xLlN0cnVjdHVyYWxDaGFyYWN0ZXJzLk9QRU5fUEFSRU5USEVTSVNcbiAgICAgICAgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCB9LFxuICAgIF0sXG4gICAgYmluYXJ5T3BlcmF0b3I6IFtcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCB9LFxuICAgICAgICB7IG5hbWU6IHR5cGVzXzEuVG9rZW5zLk9QRVJBVE9SLCB2YWx1ZTogdHlwZXNfMS5PcGVyYXRvcnMuT1IgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLlhPUiB9LFxuICAgIF0sXG4gICAgYmluYXJ5T3BlcmF0b3JPckNsb3NlOiBbXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5BTkQgfSxcbiAgICAgICAgeyBuYW1lOiB0eXBlc18xLlRva2Vucy5PUEVSQVRPUiwgdmFsdWU6IHR5cGVzXzEuT3BlcmF0b3JzLk9SIH0sXG4gICAgICAgIHsgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5YT1IgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVIsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJU1xuICAgICAgICB9LFxuICAgIF1cbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSID0gZXhwb3J0cy5FT0wgPSBleHBvcnRzLkNPTU1FTlRfREVMSU1JVEVSID0gZXhwb3J0cy5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIgPSBleHBvcnRzLlNFUEFSQVRPUlMgPSBleHBvcnRzLk9QRVJBVE9SUyA9IGV4cG9ydHMuU1RSVUNUVVJBTF9DSEFSQUNURVJTID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5leHBvcnRzLlNUUlVDVFVSQUxfQ0hBUkFDVEVSUyA9IHtcbiAgICAnKCc6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuT1BFTl9QQVJFTlRIRVNJUyxcbiAgICAnKSc6IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuQ0xPU0VfUEFSRU5USEVTSVNcbn07XG5leHBvcnRzLk9QRVJBVE9SUyA9IHtcbiAgICBBTkQ6IHR5cGVzXzEuT3BlcmF0b3JzLkFORCxcbiAgICBPUjogdHlwZXNfMS5PcGVyYXRvcnMuT1IsXG4gICAgWE9SOiB0eXBlc18xLk9wZXJhdG9ycy5YT1IsXG4gICAgTk9UOiB0eXBlc18xLk9wZXJhdG9ycy5OT1Rcbn07XG5leHBvcnRzLlNFUEFSQVRPUlMgPSBuZXcgU2V0KFtcbiAgICAweDAwMjAsXG4gICAgMHgwMDA5LFxuICAgIDB4MDAwYSxcbiAgICAweDAwMGQsIC8vIENhcnJpYWdlIHJldHVyblxuXS5tYXAoZnVuY3Rpb24gKHNlcGFyYXRvcikgeyByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoc2VwYXJhdG9yKTsgfSkpO1xuZXhwb3J0cy5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDAwMjIpO1xuZXhwb3J0cy5DT01NRU5UX0RFTElNSVRFUiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDAyMyk7XG5leHBvcnRzLkVPTCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KDB4MDAwYSk7XG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDAwNWMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldFF1b3RlZElkZW50aWZpZXIgPSBleHBvcnRzLmdldENvbW1lbnQgPSBleHBvcnRzLmNyZWF0ZVJlc3VsdCA9IHZvaWQgMDtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbnZhciBjcmVhdGVSZXN1bHQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHJlbWFpbmluZ1N0cmluZykgeyByZXR1cm4gKHtcbiAgICB0b2tlbjogX19hc3NpZ24oeyBuYW1lOiBuYW1lIH0sICh2YWx1ZSAhPT0gbnVsbCA/IHsgdmFsdWU6IHZhbHVlIH0gOiB7fSkpLFxuICAgIHJlbWFpbmluZ1N0cmluZzogcmVtYWluaW5nU3RyaW5nXG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlUmVzdWx0ID0gY3JlYXRlUmVzdWx0O1xudmFyIGdldENvbW1lbnQgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciB0b2tlbkVuZCA9IGV4cHJlc3Npb24ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGV0dGVyID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgaWYgKGxldHRlciA9PT0gY29uc3RfMS5FT0wpIHtcbiAgICAgICAgICAgIHRva2VuRW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVSZXN1bHQpKHR5cGVzXzEuVG9rZW5zLkNPTU1FTlQsIGV4cHJlc3Npb24uc2xpY2UoMCwgdG9rZW5FbmQpLCBleHByZXNzaW9uLnNsaWNlKHRva2VuRW5kICsgMSkpO1xufTtcbmV4cG9ydHMuZ2V0Q29tbWVudCA9IGdldENvbW1lbnQ7XG52YXIgZ2V0UXVvdGVkSWRlbnRpZmllciA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIGVzY2FwZVF1b3RhdGlvbiA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgIHZhciB0b2tlbkVuZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgaWYgKHRva2VuRW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlUXVvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoLTEpICsgY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGNvbnN0XzEuRVNDQVBFX0NIQVJBQ1RFUikge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVRdW90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlUXVvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSAmJiAhY29uc3RfMS5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlNbY2hhcl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIuY29uY2F0KGNoYXIsIFwiIEV4cGVjdGVkICkgY2hhcmFjdGVyIG9yIHNlcGFyYXRvclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodG9rZW5FbmQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogZXhwZWN0ZWQgXCIuY29uY2F0KGNvbnN0XzEuUVVPVEVEX0lERU5USUZJRVJfREVMSU1JVEVSLCBcIiBjaGFyYWN0ZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuY3JlYXRlUmVzdWx0KSh0eXBlc18xLlRva2Vucy5JREVOVElGSUVSLCB2YWx1ZSwgZXhwcmVzc2lvbi5zbGljZSh0b2tlbkVuZCArIDEpKTtcbn07XG5leHBvcnRzLmdldFF1b3RlZElkZW50aWZpZXIgPSBnZXRRdW90ZWRJZGVudGlmaWVyO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubGV4ID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBsZXggPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciB0b2tlblN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgdG9rZW5FbmQgPSBudWxsO1xuICAgIHZhciBkZWxpbWl0aW5nQ2hhcmFjdGVyID0gbnVsbDtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGNoYXJhY3RlcnMgaW4gdGhlIGV4cHJlc3Npb24gdW50aWwgdGhlIG5leHQgdG9rZW4gaXMgZm91bmRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICAvLyBGaW5kcyB0b2tlbSBzdGFydCBhbmQgcmV0dXJucyBpbW1lZGlhdGVseSByZXR1cm5zIGFueSBpZGVudGlmaWFibGUgdG9rZW5zXG4gICAgICAgIGlmICh0b2tlblN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnN0XzEuU0VQQVJBVE9SUy5oYXMoY2hhcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RydWN0dXJhbENoYXIgPSBjb25zdF8xLlNUUlVDVFVSQUxfQ0hBUkFDVEVSU1tjaGFyXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RydWN0dXJhbENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gZXhwcmVzc2lvbltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmFsQ2hhciA9PT0gdHlwZXNfMS5TdHJ1Y3R1cmFsQ2hhcmFjdGVycy5DTE9TRV9QQVJFTlRIRVNJUyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFjb25zdF8xLlNFUEFSQVRPUlMuaGFzKG5leHRDaGFyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIgIT09IHR5cGVzXzEuU3RydWN0dXJhbENoYXJhY3RlcnMuQ0xPU0VfUEFSRU5USEVTSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIi5jb25jYXQobmV4dENoYXIsIFwiLiBBIGNsb3NpbmcgcGFyZW50aGVzaXMgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGFub3RoZXIgY2xvc2luZyBwYXJlbnRoZXNpcyBvciB3aGl0ZXNwYWNlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY3JlYXRlUmVzdWx0KSh0eXBlc18xLlRva2Vucy5TVFJVQ1RVUkFMX0NIQVJBQ1RFUiwgY29uc3RfMS5TVFJVQ1RVUkFMX0NIQVJBQ1RFUlNbY2hhcl0sIGV4cHJlc3Npb24uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT25jZSBhIHF1b3RlZCBpZGVudGlmaWVyIGhhcyBiZWVuIGlkZW50aWZpZWQgaXQgaXMgcmV0cmlldmVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY29uc3RfMS5RVU9URURfSURFTlRJRklFUl9ERUxJTUlURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmdldFF1b3RlZElkZW50aWZpZXIpKGV4cHJlc3Npb24uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT25jZSBhIGNvbW1lbnQgaGFzIGJlZW4gaWRlbnRpZmllZCBpdCBpcyByZXRyaWV2ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLkNPTU1FTlRfREVMSU1JVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5nZXRDb21tZW50KShleHByZXNzaW9uLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuU3RhcnQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJlYWtzIG9uIHRoZSBlbmQgb2YgdGhlIHRva2VuIGFuZCB0aHJvd3Mgb24gaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBpZiAoY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhjaGFyKSB8fCBjb25zdF8xLlNUUlVDVFVSQUxfQ0hBUkFDVEVSU1tjaGFyXSkge1xuICAgICAgICAgICAgICAgIHRva2VuRW5kID0gaTtcbiAgICAgICAgICAgICAgICBkZWxpbWl0aW5nQ2hhcmFjdGVyID0gY2hhcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjb25zdF8xLlFVT1RFRF9JREVOVElGSUVSX0RFTElNSVRFUiB8fFxuICAgICAgICAgICAgICAgICAgICBjaGFyID09PSBjb25zdF8xLkNPTU1FTlRfREVMSU1JVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIi5jb25jYXQoY2hhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXBhcmF0ZXMgb3BlcmF0b3JzIGZyb20gaWRlbnRpZmllcnMgYW5kIHJldHVybnMgdGhlIGNvcnJlY3QgdG9rZW5cbiAgICBpZiAodG9rZW5TdGFydCAhPT0gbnVsbCkge1xuICAgICAgICB0b2tlbkVuZCA9IHRva2VuRW5kICE9PSBudWxsICYmIHRva2VuRW5kICE9PSB2b2lkIDAgPyB0b2tlbkVuZCA6IGV4cHJlc3Npb24ubGVuZ3RoO1xuICAgICAgICB2YXIgdmFsdWUgPSBleHByZXNzaW9uLnNsaWNlKHRva2VuU3RhcnQsIHRva2VuRW5kKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1N0cmluZyA9IGV4cHJlc3Npb24uc2xpY2UodG9rZW5FbmQpO1xuICAgICAgICBpZiAoY29uc3RfMS5PUEVSQVRPUlNbdmFsdWVdKSB7XG4gICAgICAgICAgICBpZiAoZGVsaW1pdGluZ0NoYXJhY3RlciAmJiAhY29uc3RfMS5TRVBBUkFUT1JTLmhhcyhkZWxpbWl0aW5nQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIi5jb25jYXQoZGVsaW1pdGluZ0NoYXJhY3RlciwgXCIuIE9wZXJhdG9ycyBzaG91bGQgYmUgc2VwYXJhdGVkIHVzaW5nIHdoaXRlc3BhY2VcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNyZWF0ZVJlc3VsdCkodHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIGNvbnN0XzEuT1BFUkFUT1JTW3ZhbHVlXSwgcmVtYWluaW5nU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jcmVhdGVSZXN1bHQpKHR5cGVzXzEuVG9rZW5zLklERU5USUZJRVIsIHZhbHVlLCByZW1haW5pbmdTdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgcmVhY2hlZCBubyB0b2tlbnMgd2VyZSBmb3VuZCBzbyBFT0YgaXMgcmV0dXJuZWRcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY3JlYXRlUmVzdWx0KSh0eXBlc18xLlRva2Vucy5FT0YsIG51bGwsICcnKTtcbn07XG5leHBvcnRzLmxleCA9IGxleDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnZhbGlkYXRlVG9rZW4gPSBleHBvcnRzLnByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudCA9IGV4cG9ydHMuZ2V0VmFsdWUgPSBleHBvcnRzLm5ld1Rva2VuR2VuZXJhdG9yID0gdm9pZCAwO1xudmFyIGxleF8xID0gcmVxdWlyZShcIi4uL2xleC9sZXhcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG52YXIgbmV3VG9rZW5HZW5lcmF0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciByZW1haW5pbmdFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbGlkVG9rZW5zLCBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGlmIChlbmRJc1ZhbGlkID09PSB2b2lkIDApIHsgZW5kSXNWYWxpZCA9IGZhbHNlOyB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSAoMCwgbGV4XzEubGV4KShyZW1haW5pbmdFeHByZXNzaW9uKSwgdG9rZW4gPSBfYS50b2tlbiwgcmVtYWluaW5nU3RyaW5nID0gX2EucmVtYWluaW5nU3RyaW5nO1xuICAgICAgICAgICAgcmVtYWluaW5nRXhwcmVzc2lvbiA9IHJlbWFpbmluZ1N0cmluZztcbiAgICAgICAgICAgIGlmICh0b2tlbi5uYW1lICE9PSB0eXBlc18xLlRva2Vucy5DT01NRU5UKSB7XG4gICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMudmFsaWRhdGVUb2tlbikodG9rZW4sIHZhbGlkVG9rZW5zLCBlbmRJc1ZhbGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMubmV3VG9rZW5HZW5lcmF0b3IgPSBuZXdUb2tlbkdlbmVyYXRvcjtcbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIChnZXROZXh0VG9rZW4sIHBhcnNlcikge1xuICAgIHZhciBuZXh0VG9rZW4gPSBnZXROZXh0VG9rZW4oY29uc3RfMS5WQUxJRF9UT0tFTlMuaWRlbnRpZmllck9yTm90KTtcbiAgICB2YXIgbmVnYXRlZFZhbHVlID0gbmV4dFRva2VuLnZhbHVlID09PSB0eXBlc18xLk9wZXJhdG9ycy5OT1Q7XG4gICAgaWYgKG5lZ2F0ZWRWYWx1ZSkge1xuICAgICAgICBuZXh0VG9rZW4gPSBnZXROZXh0VG9rZW4oY29uc3RfMS5WQUxJRF9UT0tFTlMuaWRlbnRpZmllck9ubHkpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBuZXh0VG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuU1RSVUNUVVJBTF9DSEFSQUNURVJcbiAgICAgICAgPyBwYXJzZXIoZ2V0TmV4dFRva2VuLCB0cnVlKVxuICAgICAgICA6IFtuZXh0VG9rZW5dO1xuICAgIHJldHVybiBuZWdhdGVkVmFsdWVcbiAgICAgICAgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHZhbHVlLCB0cnVlKSwgW3sgbmFtZTogdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IsIHZhbHVlOiB0eXBlc18xLk9wZXJhdG9ycy5OT1QgfV0sIGZhbHNlKSA6IHZhbHVlO1xufTtcbmV4cG9ydHMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbnZhciBwcmV2aW91c09wZXJhdG9yVGFrZXNQcmVjZWRlbnQgPSBmdW5jdGlvbiAocHJldmlvdXNPcGVyYXRvciwgbmV4dE9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0XzEuT1BFUkFUT1JfUFJFQ0VERU5DRVtwcmV2aW91c09wZXJhdG9yXSA8PSBjb25zdF8xLk9QRVJBVE9SX1BSRUNFREVOQ0VbbmV4dE9wZXJhdG9yXTtcbn07XG5leHBvcnRzLnByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudCA9IHByZXZpb3VzT3BlcmF0b3JUYWtlc1ByZWNlZGVudDtcbnZhciB2YWxpZGF0ZVRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWxpZFRva2VucywgZW5kSXNWYWxpZCkge1xuICAgIGlmIChlbmRJc1ZhbGlkID09PSB2b2lkIDApIHsgZW5kSXNWYWxpZCA9IGZhbHNlOyB9XG4gICAgaWYgKHRva2VuLm5hbWUgPT09IHR5cGVzXzEuVG9rZW5zLkVPRikge1xuICAgICAgICBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHZhbGlkVG9rZW5zXzEgPSB2YWxpZFRva2VuczsgX2kgPCB2YWxpZFRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdmFsaWRUb2tlbiA9IHZhbGlkVG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodmFsaWRUb2tlbi5uYW1lID09PSB0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkVG9rZW4udmFsdWUgfHwgdmFsaWRUb2tlbi52YWx1ZSA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b2tlbicpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVUb2tlbiA9IHZhbGlkYXRlVG9rZW47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5wYXJzZSA9IHZvaWQgMDtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBSZXR1cm5zIHRoZSB0b2tlbnMgdXNpbmcgcG9zdGZpeCBub3RhdGlvblxudmFyIHBhcnNlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQgXCIuY29uY2F0KHR5cGVvZiBleHByZXNzaW9uKSk7XG4gICAgfVxuICAgIC8vIGdldE5leHRUb2tlbiBrZWVwcyB0cmFjayBvZiB0aGUgcmVtYWluaW5nIGV4cHJlc3Npb25cbiAgICAvLyBhbmQgcmV0dXJuIHRoZSBuZXh0IHRva2VuIGVhY2ggdGltZSBpdCBpcyBjYWxsZWRcbiAgICB2YXIgZ2V0TmV4dFRva2VuID0gKDAsIHV0aWxzXzEubmV3VG9rZW5HZW5lcmF0b3IpKGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBwYXJzZUludGVybmFsKGdldE5leHRUb2tlbik7XG59O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8gcGFyc2VJbnRlcm5hbCB3aWxsIHJlY3Vyc2Ugb3ZlciBicmFja2V0ZWQgZXhwcmVzc2lvbnNcbnZhciBwYXJzZUludGVybmFsID0gZnVuY3Rpb24gKGdldE5leHRUb2tlbiwgbmVzdGVkKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7IG5lc3RlZCA9IGZhbHNlOyB9XG4gICAgLy8gVGhpcyBpbml0aWFsaXNlcyB0aGUgb3V0cHV0IHdpdGggZXZlcnl0aGluZyB1cCB0aGUgZmlyc3QgdW5uZXN0ZWQgb3BlcmF0b3JcbiAgICB2YXIgb3V0cHV0ID0gX19zcHJlYWRBcnJheShbXSwgKDAsIHV0aWxzXzEuZ2V0VmFsdWUpKGdldE5leHRUb2tlbiwgcGFyc2VJbnRlcm5hbCksIHRydWUpO1xuICAgIHZhciBvcGVyYXRvcnMgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsaWRUb2tlbnMgPSBuZXN0ZWRcbiAgICAgICAgICAgID8gY29uc3RfMS5WQUxJRF9UT0tFTlMuYmluYXJ5T3BlcmF0b3JPckNsb3NlXG4gICAgICAgICAgICA6IGNvbnN0XzEuVkFMSURfVE9LRU5TLmJpbmFyeU9wZXJhdG9yO1xuICAgICAgICAvLyBSZXRyaWV2ZXMgdGhlIG5leHQgVG9rZW5cbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IGdldE5leHRUb2tlbih2YWxpZFRva2VucywgIW5lc3RlZCk7XG4gICAgICAgIGlmIChuZXh0VG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuRU9GIHx8IC8vIElmIHRoZSBlbmQgb2YgZmlsZSBpcyBmb3VuZCBoZXJlIHRoZW4gcmV0dXJuIHdoYXQgd2UgaGF2ZVxuICAgICAgICAgICAgbmV4dFRva2VuLm5hbWUgPT09IHR5cGVzXzEuVG9rZW5zLlNUUlVDVFVSQUxfQ0hBUkFDVEVSIC8vIFRoZSBleHByZXNzaW9uIHdpbGwgYmUgcmV0dXJuZWQgYW5kIGluY29ycG9yYXRlZCBpbnRvIHRoZSBmaW5hbCBleHByZXNzaW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3V0cHV0LCB0cnVlKSwgX19zcHJlYWRBcnJheShbXSwgb3BlcmF0b3JzLCB0cnVlKS5yZXZlcnNlKCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHBvc3RmaXggbm90YXRpb24gb3BlcmF0b3Igb3JkZXIgaXMgZGV0ZXJtaW5lZCBieSBwcmVjZWRlbmNlXG4gICAgICAgIHdoaWxlIChvcGVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRvciA9IG9wZXJhdG9yc1tvcGVyYXRvcnMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c09wZXJhdG9yICYmXG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEucHJldmlvdXNPcGVyYXRvclRha2VzUHJlY2VkZW50KShwcmV2aW91c09wZXJhdG9yLnZhbHVlLCBuZXh0VG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvdXRwdXQsIHRydWUpLCBbcHJldmlvdXNPcGVyYXRvcl0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcnMgPSBvcGVyYXRvcnMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG5ldyBvcGVyYXRvciBpcyBub3cgYWRkZWQgdG8gdGhlIHN0YWNrXG4gICAgICAgIG9wZXJhdG9ycyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3BlcmF0b3JzLCB0cnVlKSwgW25leHRUb2tlbl0sIGZhbHNlKTtcbiAgICAgICAgLy8gT25jZSB0aGlzIGlzIGRvbmUgd2UgY2FuIGdldCBldmVyeXRoaW5nIHVudGlsIHRoZSBuZXh0IHVubmVzdGVkXG4gICAgICAgIC8vIG9wZXJhdG9yIGFuZCBhZGQgaXQgdG8gdGhlIG91dHB1dFxuICAgICAgICBvdXRwdXQgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG91dHB1dCwgdHJ1ZSksICgwLCB1dGlsc18xLmdldFZhbHVlKShnZXROZXh0VG9rZW4sIHBhcnNlSW50ZXJuYWwpLCB0cnVlKTtcbiAgICB9XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudGhyb3dJbnZhbGlkRXhwcmVzc2lvbiA9IGV4cG9ydHMuaXNPcGVyYXRvciA9IGV4cG9ydHMuaXNJZGVudGlmaWVyID0gZXhwb3J0cy5ub3RVdGlsID0gZXhwb3J0cy54b3JVdGlsID0gZXhwb3J0cy5vclV0aWwgPSBleHBvcnRzLmFuZFV0aWwgPSB2b2lkIDA7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBhbmRVdGlsID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiBsZWZ0ICYmIHJpZ2h0OyB9O1xuZXhwb3J0cy5hbmRVdGlsID0gYW5kVXRpbDtcbnZhciBvclV0aWwgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7IH07XG5leHBvcnRzLm9yVXRpbCA9IG9yVXRpbDtcbnZhciB4b3JVdGlsID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7IHJldHVybiAhKGxlZnQgPT09IHJpZ2h0KTsgfTtcbmV4cG9ydHMueG9yVXRpbCA9IHhvclV0aWw7XG52YXIgbm90VXRpbCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7IHJldHVybiAhaWRlbnRpZmllcjsgfTtcbmV4cG9ydHMubm90VXRpbCA9IG5vdFV0aWw7XG52YXIgaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiBuYW1lID09PSB0eXBlc18xLlRva2Vucy5JREVOVElGSUVSICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59O1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG52YXIgaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuT1BFUkFUT1IgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn07XG5leHBvcnRzLmlzT3BlcmF0b3IgPSBpc09wZXJhdG9yO1xudmFyIHRocm93SW52YWxpZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBvc3RmaXggZXhwcmVzc2lvbjogXCIuY29uY2F0KG1lc3NhZ2UpKTtcbn07XG5leHBvcnRzLnRocm93SW52YWxpZEV4cHJlc3Npb24gPSB0aHJvd0ludmFsaWRFeHByZXNzaW9uO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuT1BFUkFUT1JfTUFQID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5PUEVSQVRPUl9NQVAgPSAoX2EgPSB7fSxcbiAgICBfYVt0eXBlc18xLk9wZXJhdG9ycy5BTkRdID0gdXRpbHNfMS5hbmRVdGlsLFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLk9SXSA9IHV0aWxzXzEub3JVdGlsLFxuICAgIF9hW3R5cGVzXzEuT3BlcmF0b3JzLlhPUl0gPSB1dGlsc18xLnhvclV0aWwsXG4gICAgX2EpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBleHBvcnRzLmdldEV2YWx1YXRvciA9IHZvaWQgMDtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4uL3BhcnNlL3BhcnNlXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBnZXRFdmFsdWF0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciBwYXJzZWRFeHByZXNzaW9uID0gKDAsIHBhcnNlXzEucGFyc2UpKGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoYm9vbGVhbk1hcCkgeyByZXR1cm4gKDAsIGV4cG9ydHMuZXZhbHVhdGUpKHBhcnNlZEV4cHJlc3Npb24sIGJvb2xlYW5NYXApOyB9O1xufTtcbmV4cG9ydHMuZ2V0RXZhbHVhdG9yID0gZ2V0RXZhbHVhdG9yO1xudmFyIGV2YWx1YXRlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGJvb2xlYW5NYXApIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGV4cHJlc3Npb24sIFwiIHNob3VsZCBiZSBhbiBhcnJheS4gZXZhbHVhdGUgdGFrZXMgaW4gYSBwYXJzZWQgZXhwcmVzc2lvbi4gVXNlIGluIGNvbWJpbmF0aW9uIHdpdGggcGFyc2Ugb3IgdXNlIGdldEV2YWx1YXRvclwiKSk7XG4gICAgfVxuICAgIC8vIFJlc29sdmVzIGVhY2ggaWRlbnRpZmllciBhbmQgYWRkcyBpdCB0byBhIHN0YWNrXG4gICAgLy8gV2hlbiBvcGVyYXRvciBpcyBmb3VuZCBpdCBvcGVyYXRlcyBvbiB0aGUgdG9wIHZhbHVlKHMpXG4gICAgLy8gb24gdGhlIHN0YWNrLCByZW1vdmVzIHRoZW0gYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCB0aGVcbiAgICAvLyByZXN1bHRcbiAgICB2YXIgZXZhbHVhdGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVkdWNlKGZ1bmN0aW9uIChzdGFjaywgdG9rZW4sIGkpIHtcbiAgICAgICAgaWYgKCEodG9rZW4gJiYgKCgwLCB1dGlsc18xLmlzSWRlbnRpZmllcikodG9rZW4pIHx8ICgwLCB1dGlsc18xLmlzT3BlcmF0b3IpKHRva2VuKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuOiBcIi5jb25jYXQodG9rZW4sIFwiLiBGb3VuZCBpbiBwYXJzZWQgZXhwcmVzc2lvbiBhdCBpbmRleCBcIikuY29uY2F0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gdHlwZXNfMS5Ub2tlbnMuSURFTlRJRklFUikge1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgc3RhY2ssIHRydWUpLCBbQm9vbGVhbihib29sZWFuTWFwW3Rva2VuLnZhbHVlXSldLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlY29uZExhc3RJdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgIHZhciBsYXN0SXRlbSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IHR5cGVzXzEuT3BlcmF0b3JzLk5PVCkge1xuICAgICAgICAgICAgaWYgKGxhc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS50aHJvd0ludmFsaWRFeHByZXNzaW9uKSgnbWlzc2luZyBpZGVudGlmaWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBzdGFjay5zbGljZSgwLCAtMSksIHRydWUpLCBbKDAsIHV0aWxzXzEubm90VXRpbCkobGFzdEl0ZW0pXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SXRlbSA9PT0gdW5kZWZpbmVkIHx8IHNlY29uZExhc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLnRocm93SW52YWxpZEV4cHJlc3Npb24pKCdtaXNzaW5nIGlkZW50aWZpZXInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0b3JVdGlsID0gY29uc3RfMS5PUEVSQVRPUl9NQVBbdG9rZW4udmFsdWVdO1xuICAgICAgICBpZiAoIW9wZXJhdG9yVXRpbCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhyb3dJbnZhbGlkRXhwcmVzc2lvbikoJ3Vua25vd24gb3BlcmF0b3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBzdGFjay5zbGljZSgwLCAtMiksIHRydWUpLCBbb3BlcmF0b3JVdGlsKHNlY29uZExhc3RJdGVtLCBsYXN0SXRlbSldLCBmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChldmFsdWF0ZWRFeHByZXNzaW9uLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAoMCwgdXRpbHNfMS50aHJvd0ludmFsaWRFeHByZXNzaW9uKSgndG9vIG1hbnkgaWRlbnRpZmllcnMgYWZ0ZXIgZXZhbHVhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbHVhdGVkRXhwcmVzc2lvblswXTtcbn07XG5leHBvcnRzLmV2YWx1YXRlID0gZXZhbHVhdGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucGFyc2UgPSBleHBvcnRzLmV2YWx1YXRlID0gZXhwb3J0cy5nZXRFdmFsdWF0b3IgPSB2b2lkIDA7XG52YXIgZXZhbHVhdGVfMSA9IHJlcXVpcmUoXCIuL2V2YWx1YXRlL2V2YWx1YXRlXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIGV2YWx1YXRlXzEsIFwiZ2V0RXZhbHVhdG9yXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIGV2YWx1YXRlXzEsIFwiZXZhbHVhdGVcIik7XG52YXIgcGFyc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlL3BhcnNlXCIpO1xuX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIHBhcnNlXzEsIFwicGFyc2VcIik7XG4iLCAiLyohXG4gKiBFdmVudEVtaXR0ZXIyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaGlqMW54L0V2ZW50RW1pdHRlcjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgaGlqMW54XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbjshZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eT0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gX2lzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH07XG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gIHZhciBuZXh0VGlja1N1cHBvcnRlZD0gdHlwZW9mIHByb2Nlc3M9PSdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrPT0nZnVuY3Rpb24nO1xuICB2YXIgc3ltYm9sc1N1cHBvcnRlZD0gdHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbic7XG4gIHZhciByZWZsZWN0U3VwcG9ydGVkPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCc7XG4gIHZhciBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQ9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbic7XG4gIHZhciBfc2V0SW1tZWRpYXRlPSBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuICB2YXIgb3duS2V5cz0gc3ltYm9sc1N1cHBvcnRlZD8gKHJlZmxlY3RTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlZmxlY3Qub3duS2V5cz09PSdmdW5jdGlvbic/IFJlZmxlY3Qub3duS2V5cyA6IGZ1bmN0aW9uKG9iail7XG4gICAgdmFyIGFycj0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgICBhcnIucHVzaC5hcHBseShhcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfSkgOiBPYmplY3Qua2V5cztcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGlmICh0aGlzLl9jb25mKSB7XG4gICAgICBjb25maWd1cmUuY2FsbCh0aGlzLCB0aGlzLl9jb25mKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmUoY29uZikge1xuICAgIGlmIChjb25mKSB7XG4gICAgICB0aGlzLl9jb25mID0gY29uZjtcblxuICAgICAgY29uZi5kZWxpbWl0ZXIgJiYgKHRoaXMuZGVsaW1pdGVyID0gY29uZi5kZWxpbWl0ZXIpO1xuXG4gICAgICBpZihjb25mLm1heExpc3RlbmVycyE9PXVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzPSBjb25mLm1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgY29uZi53aWxkY2FyZCAmJiAodGhpcy53aWxkY2FyZCA9IGNvbmYud2lsZGNhcmQpO1xuICAgICAgY29uZi5uZXdMaXN0ZW5lciAmJiAodGhpcy5fbmV3TGlzdGVuZXIgPSBjb25mLm5ld0xpc3RlbmVyKTtcbiAgICAgIGNvbmYucmVtb3ZlTGlzdGVuZXIgJiYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gY29uZi5yZW1vdmVMaXN0ZW5lcik7XG4gICAgICBjb25mLnZlcmJvc2VNZW1vcnlMZWFrICYmICh0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gY29uZi52ZXJib3NlTWVtb3J5TGVhayk7XG4gICAgICBjb25mLmlnbm9yZUVycm9ycyAmJiAodGhpcy5pZ25vcmVFcnJvcnMgPSBjb25mLmlnbm9yZUVycm9ycyk7XG5cbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJUcmVlID0ge307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9nUG9zc2libGVNZW1vcnlMZWFrKGNvdW50LCBldmVudE5hbWUpIHtcbiAgICB2YXIgZXJyb3JNc2cgPSAnKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICdsZWFrIGRldGVjdGVkLiAnICsgY291bnQgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nO1xuXG4gICAgaWYodGhpcy52ZXJib3NlTWVtb3J5TGVhayl7XG4gICAgICBlcnJvck1zZyArPSAnIEV2ZW50IG5hbWU6ICcgKyBldmVudE5hbWUgKyAnLic7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpe1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgZS5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICBlLmVtaXR0ZXIgPSB0aGlzO1xuICAgICAgZS5jb3VudCA9IGNvdW50O1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1zZyk7XG5cbiAgICAgIGlmIChjb25zb2xlLnRyYWNlKXtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFthXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICBhcnJbbl0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9PYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXNDb3VudCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmpba2V5XSA9IGkgPCB2YWx1ZXNDb3VudCA/IHZhbHVlc1tpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRhcmdldE9ic2VydmVyKGVtaXR0ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9saXN0ZW5lcnNDb3VudCA9IDA7XG5cbiAgICB2YXIgb24sIG9mZjtcblxuICAgIGlmIChvcHRpb25zLm9uIHx8IG9wdGlvbnMub2ZmKSB7XG4gICAgICBvbiA9IG9wdGlvbnMub247XG4gICAgICBvZmYgPSBvcHRpb25zLm9mZjtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIG9uID0gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hZGRMaXN0ZW5lcikge1xuICAgICAgb24gPSB0YXJnZXQuYWRkTGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlTGlzdGVuZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQub24pIHtcbiAgICAgIG9uID0gdGFyZ2V0Lm9uO1xuICAgICAgb2ZmID0gdGFyZ2V0Lm9mZjtcbiAgICB9XG5cbiAgICBpZiAoIW9uICYmICFvZmYpIHtcbiAgICAgIHRocm93IEVycm9yKCd0YXJnZXQgZG9lcyBub3QgaW1wbGVtZW50IGFueSBrbm93biBldmVudCBBUEknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ29uIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvZmYgbWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMuX29uID0gb247XG4gICAgdGhpcy5fb2ZmID0gb2ZmO1xuXG4gICAgdmFyIF9vYnNlcnZlcnM9IGVtaXR0ZXIuX29ic2VydmVycztcbiAgICBpZihfb2JzZXJ2ZXJzKXtcbiAgICAgIF9vYnNlcnZlcnMucHVzaCh0aGlzKTtcbiAgICB9ZWxzZXtcbiAgICAgIGVtaXR0ZXIuX29ic2VydmVycz0gW3RoaXNdO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oVGFyZ2V0T2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCwgbG9jYWxFdmVudCwgcmVkdWNlcil7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgdGFyZ2V0PSB0aGlzLl90YXJnZXQ7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBsaXN0ZW5lcnM9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBoYW5kbGVyPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYXJncz0gdG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZXZlbnRPYmo9IHtcbiAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgIG5hbWU6IGxvY2FsRXZlbnQsXG4gICAgICAgICAgb3JpZ2luYWw6IGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmKHJlZHVjZXIpe1xuICAgICAgICAgIHZhciByZXN1bHQ9IHJlZHVjZXIuY2FsbCh0YXJnZXQsIGV2ZW50T2JqKTtcbiAgICAgICAgICBpZihyZXN1bHQhPT1mYWxzZSl7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQuYXBwbHkoZW1pdHRlciwgW2V2ZW50T2JqLm5hbWVdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVtaXR0ZXIuZW1pdC5hcHBseShlbWl0dGVyLCBbbG9jYWxFdmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG5cblxuICAgICAgaWYobGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgIHRocm93IEVycm9yKCdFdmVudCBcXCcnICsgZXZlbnQgKyAnXFwnIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50Kys7XG5cbiAgICAgIGlmKGVtaXR0ZXIuX25ld0xpc3RlbmVyICYmIGVtaXR0ZXIuX3JlbW92ZUxpc3RlbmVyICYmICFvYnNlcnZlci5fb25OZXdMaXN0ZW5lcil7XG5cbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IGZ1bmN0aW9uIChfZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX2V2ZW50ID09PSBsb2NhbEV2ZW50ICYmIGxpc3RlbmVyc1tldmVudF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcj0gZnVuY3Rpb24oX2V2ZW50KXtcbiAgICAgICAgICBpZihfZXZlbnQgPT09IGxvY2FsRXZlbnQgJiYgIWVtaXR0ZXIuaGFzTGlzdGVuZXJzKF9ldmVudCkgJiYgbGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gaGFuZGxlcjtcbiAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgbGlzdGVuZXJzPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgdmFyIGV2ZW50cztcbiAgICAgIHZhciBvZmY9IHRoaXMuX29mZjtcbiAgICAgIHZhciB0YXJnZXQ9IHRoaXMuX3RhcmdldDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZihldmVudCAmJiB0eXBlb2YgZXZlbnQhPT0nc3RyaW5nJyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclJlZnMoKXtcbiAgICAgICAgaWYob2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpe1xuICAgICAgICAgIGVtaXR0ZXIub2ZmKCduZXdMaXN0ZW5lcicsIG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgICBlbWl0dGVyLm9mZigncmVtb3ZlTGlzdGVuZXInLCBvYnNlcnZlci5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXI9IG51bGw7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uUmVtb3ZlTGlzdGVuZXI9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4PSBmaW5kVGFyZ2V0SW5kZXguY2FsbChlbWl0dGVyLCBvYnNlcnZlcik7XG4gICAgICAgIGVtaXR0ZXIuX29ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZihldmVudCl7XG4gICAgICAgIGhhbmRsZXI9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYoIS0tdGhpcy5fbGlzdGVuZXJzQ291bnQpe1xuICAgICAgICAgIGNsZWFyUmVmcygpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzPSBvd25LZXlzKGxpc3RlbmVycyk7XG4gICAgICAgIGk9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgICBldmVudD0gZXZlbnRzW2ldO1xuICAgICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycz0ge307XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50PSAwO1xuICAgICAgICBjbGVhclJlZnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgcmVkdWNlcnMsIGFsbG93VW5rbm93bikge1xuICAgIHZhciBjb21wdXRlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEpO1xuXG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm4gY29tcHV0ZWRPcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9uLCB2YWx1ZTtcbiAgICB2YXIgcmVkdWNlcjtcblxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24gdmFsdWUnICsgKHJlYXNvbiA/ICcuIFJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBvcHRpb24gPSBrZXlzW2ldO1xuICAgICAgaWYgKCFhbGxvd1Vua25vd24gJiYgIWhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBvcHRpb24pKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVkdWNlciA9IHJlZHVjZXJzW29wdGlvbl07XG4gICAgICAgIGNvbXB1dGVkT3B0aW9uc1tvcHRpb25dID0gcmVkdWNlciA/IHJlZHVjZXIodmFsdWUsIHJlamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVkT3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yUmVkdWNlcih2YWx1ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhdmFsdWUuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpKSB7XG4gICAgICByZWplY3QoJ3ZhbHVlIG11c3QgYmUgYSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVHlwZVJlZHVjZXIodHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZT0gJ3ZhbHVlIG11c3QgYmUgdHlwZSBvZiAnICsgdHlwZXMuam9pbignfCcpO1xuICAgIHZhciBsZW49IHR5cGVzLmxlbmd0aDtcbiAgICB2YXIgZmlyc3RUeXBlPSB0eXBlc1swXTtcbiAgICB2YXIgc2Vjb25kVHlwZT0gdHlwZXNbMV07XG5cbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICB2YXIga2luZD0gdHlwZW9mIHY7XG4gICAgICAgIGlmIChraW5kID09PSBmaXJzdFR5cGUgfHwga2luZCA9PT0gc2Vjb25kVHlwZSkgcmV0dXJuIHY7XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdjtcbiAgICAgIHZhciBpID0gbGVuO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IHR5cGVzW2ldKSByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydmdW5jdGlvbiddKTtcblxuICB2YXIgb2JqZWN0RnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydvYmplY3QnLCAnZnVuY3Rpb24nXSk7XG5cbiAgZnVuY3Rpb24gbWFrZUNhbmNlbGFibGVQcm9taXNlKFByb21pc2UsIGV4ZWN1dG9yLCBvcHRpb25zKSB7XG4gICAgdmFyIGlzQ2FuY2VsYWJsZTtcbiAgICB2YXIgY2FsbGJhY2tzO1xuICAgIHZhciB0aW1lcj0gMDtcbiAgICB2YXIgc3Vic2NyaXB0aW9uQ2xvc2VkO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICBvdmVybG9hZDogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24odmFsdWUsIHJlamVjdCl7XG4gICAgICAgICAgdmFsdWUqPSAxO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVqZWN0KCd0aW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXNDYW5jZWxhYmxlID0gIW9wdGlvbnMub3ZlcmxvYWQgJiYgdHlwZW9mIFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgdGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfcmVzb2x2ZT0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9yZWplY3Q9IGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNDYW5jZWxhYmxlKSB7XG4gICAgICAgIGV4ZWN1dG9yKF9yZXNvbHZlLCBfcmVqZWN0LCBvbkNhbmNlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3MgPSBbZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICBfcmVqZWN0KHJlYXNvbiB8fCBFcnJvcignY2FuY2VsZWQnKSk7XG4gICAgICAgIH1dO1xuICAgICAgICBleGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuYWJsZSB0byBzdWJzY3JpYmUgb24gY2FuY2VsIGV2ZW50IGFzeW5jaHJvbm91c2x5JylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdvbkNhbmNlbCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xvc2VkPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICB0aW1lcj0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZWFzb249IEVycm9yKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgcmVhc29uLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgICAgICAgIHRpbWVyPSAwO1xuICAgICAgICAgIHByb21pc2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzQ2FuY2VsYWJsZSkge1xuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgY2FsbGJhY2sgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNhbGxiYWNrc1swXShyZWFzb24pO1xuICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChvYnNlcnZlcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnM7XG4gICAgaWYoIW9ic2VydmVycyl7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvYnNlcnZlcnNbaV0uX3RhcmdldCA9PT0gb2JzZXJ2ZXIpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBBdHRlbnRpb24sIGZ1bmN0aW9uIHJldHVybiB0eXBlIG5vdyBpcyBhcnJheSwgYWx3YXlzICFcbiAgLy8gSXQgaGFzIHplcm8gZWxlbWVudHMgaWYgbm8gYW55IG1hdGNoZXMgZm91bmQgYW5kIG9uZSBvciBtb3JlXG4gIC8vIGVsZW1lbnRzIChsZWFmcykgaWYgdGhlcmUgYXJlIG1hdGNoZXNcbiAgLy9cbiAgZnVuY3Rpb24gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCBpLCB0eXBlTGVuZ3RoKSB7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdHlwZTtcbiAgICAgIGlmIChraW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbnMsIG4sIGwgPSAwLCBqID0gMCwgZGVsaW1pdGVyID0gdGhpcy5kZWxpbWl0ZXIsIGRsID0gZGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKChuID0gdHlwZS5pbmRleE9mKGRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5zW2wrK10gPSB0eXBlLnNsaWNlKGosIG4pO1xuICAgICAgICAgICAgaiA9IG4gKyBkbDtcbiAgICAgICAgICB9IHdoaWxlICgobiA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgICAgbnNbbCsrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICAgICAgdHlwZSA9IG5zO1xuICAgICAgICAgIHR5cGVMZW5ndGggPSBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHlwZUxlbmd0aCA9IHR5cGUubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycz0gbnVsbCwgYnJhbmNoLCB4VHJlZSwgeHhUcmVlLCBpc29sYXRlZEJyYW5jaCwgZW5kUmVhY2hlZCwgY3VycmVudFR5cGUgPSB0eXBlW2ldLFxuICAgICAgICBuZXh0VHlwZSA9IHR5cGVbaSArIDFdLCBicmFuY2hlcywgX2xpc3RlbmVycztcblxuICAgIGlmIChpID09PSB0eXBlTGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQocykgbGlzdCBhbmQgdGhlIHRyZWUgaGFzIGxpc3RlbmVyc1xuICAgICAgLy8gaW52b2tlIHRob3NlIGxpc3RlbmVycy5cbiAgICAgIC8vXG5cbiAgICAgIGlmKHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2godHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaC5hcHBseShoYW5kbGVycywgdHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoY3VycmVudFR5cGUgPT09ICcqJykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgZW1pdHRlZCBpcyAnKicgYXQgdGhpcyBwYXJ0XG4gICAgICAgIC8vIG9yIHRoZXJlIGlzIGEgY29uY3JldGUgbWF0Y2ggYXQgdGhpcyBwYXRjaFxuICAgICAgICAvL1xuICAgICAgICBicmFuY2hlcyA9IG93bktleXModHJlZSk7XG4gICAgICAgIG4gPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFR5cGUgPT09ICcqKicpIHtcbiAgICAgICAgZW5kUmVhY2hlZCA9IChpICsgMSA9PT0gdHlwZUxlbmd0aCB8fCAoaSArIDIgPT09IHR5cGVMZW5ndGggJiYgbmV4dFR5cGUgPT09ICcqJykpO1xuICAgICAgICBpZiAoZW5kUmVhY2hlZCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBUaGUgbmV4dCBlbGVtZW50IGhhcyBhIF9saXN0ZW5lcnMsIGFkZCBpdCB0byB0aGUgaGFuZGxlcnMuXG4gICAgICAgICAgbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyYW5jaGVzID0gb3duS2V5cyh0cmVlKTtcbiAgICAgICAgbiA9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICBicmFuY2ggPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09ICcqJyB8fCBicmFuY2ggPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgaWYgKHRyZWVbYnJhbmNoXS5fbGlzdGVuZXJzICYmICFlbmRSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAyLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vIG1hdGNoIG9uIHRoaXMgb25lLCBzaGlmdCBpbnRvIHRoZSB0cmVlIGJ1dCBub3QgaW4gdGhlIHR5cGUgYXJyYXkuXG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2UgaWYgKHRyZWVbY3VycmVudFR5cGVdKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVtjdXJyZW50VHlwZV0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAgIHhUcmVlID0gdHJlZVsnKiddO1xuICAgIGlmICh4VHJlZSkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciB0cmVlIHdpbGwgYWxsb3cgYW55IG1hdGNoIGZvciB0aGlzIHBhcnQsXG4gICAgICAvLyB0aGVuIHJlY3Vyc2l2ZWx5IGV4cGxvcmUgYWxsIGJyYW5jaGVzIG9mIHRoZSB0cmVlXG4gICAgICAvL1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4VHJlZSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgIH1cblxuICAgIHh4VHJlZSA9IHRyZWVbJyoqJ107XG4gICAgaWYgKHh4VHJlZSkge1xuICAgICAgaWYgKGkgPCB0eXBlTGVuZ3RoKSB7XG4gICAgICAgIGlmICh4eFRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsaXN0ZW5lciBvbiBhICcqKicsIGl0IHdpbGwgY2F0Y2ggYWxsLCBzbyBhZGQgaXRzIGhhbmRsZXIuXG4gICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgYXJyYXlzIG9mIG1hdGNoaW5nIG5leHQgYnJhbmNoZXMgYW5kIG90aGVycy5cbiAgICAgICAgYnJhbmNoZXM9IG93bktleXMoeHhUcmVlKTtcbiAgICAgICAgbj0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZShuLS0+MCl7XG4gICAgICAgICAgYnJhbmNoPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09IG5leHRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIG5leHQgZWxlbWVudCB3aWxsIG1hdGNoLCBzbyBqdW1wIHR3aWNlLlxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpICsgMiwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYW5jaCA9PT0gY3VycmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCBub2RlIG1hdGNoZXMsIG1vdmUgaW50byB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2ggPSB7fTtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2hbYnJhbmNoXSA9IHh4VHJlZVticmFuY2hdO1xuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHsnKionOiBpc29sYXRlZEJyYW5jaH0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgYW5kIHN0aWxsIG9uIGEgJyoqJ1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHh4VHJlZVsnKiddICYmIHh4VHJlZVsnKiddLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbJyonXSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RlbmVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3dMaXN0ZW5lclRyZWUodHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICB2YXIgbGVuID0gMCwgaiA9IDAsIGksIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyLCBkbD0gZGVsaW1pdGVyLmxlbmd0aCwgbnM7XG5cbiAgICBpZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKSB7XG4gICAgICBpZiAoKGkgPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgIT09IC0xKSB7XG4gICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbnNbbGVuKytdID0gdHlwZS5zbGljZShqLCBpKTtcbiAgICAgICAgICBqID0gaSArIGRsO1xuICAgICAgICB9IHdoaWxlICgoaSA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgIG5zW2xlbisrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbnM9IFt0eXBlXTtcbiAgICAgICAgbGVuPSAxO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBsZW49IHR5cGUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTG9va3MgZm9yIHR3byBjb25zZWN1dGl2ZSAnKionLCBpZiBzbywgZG9uJ3QgYWRkIHRoZSBldmVudCBhdCBhbGwuXG4gICAgLy9cbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSArIDEgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobnNbaV0gPT09ICcqKicgJiYgbnNbaSArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cblxuICAgIHZhciB0cmVlID0gdGhpcy5saXN0ZW5lclRyZWUsIG5hbWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5hbWUgPSBuc1tpXTtcblxuICAgICAgdHJlZSA9IHRyZWVbbmFtZV0gfHwgKHRyZWVbbmFtZV0gPSB7fSk7XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGlmICghdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gbGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IFt0cmVlLl9saXN0ZW5lcnNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF0cmVlLl9saXN0ZW5lcnMud2FybmVkICYmXG4gICAgICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycyA+IDAgJiZcbiAgICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCA+IHRoaXMuX21heExpc3RlbmVyc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VHJlZUV2ZW50cyh0cmVlLCBldmVudHMsIHJvb3QsIGFzQXJyYXkpe1xuICAgICB2YXIgYnJhbmNoZXM9IG93bktleXModHJlZSk7XG4gICAgIHZhciBpPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgIHZhciBicmFuY2gsIGJyYW5jaE5hbWUsIHBhdGg7XG4gICAgIHZhciBoYXNMaXN0ZW5lcnM9IHRyZWVbJ19saXN0ZW5lcnMnXTtcbiAgICAgdmFyIGlzQXJyYXlQYXRoO1xuXG4gICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgIGJyYW5jaE5hbWU9IGJyYW5jaGVzW2ldO1xuXG4gICAgICAgICBicmFuY2g9IHRyZWVbYnJhbmNoTmFtZV07XG5cbiAgICAgICAgIGlmKGJyYW5jaE5hbWU9PT0nX2xpc3RlbmVycycpe1xuICAgICAgICAgICAgIHBhdGg9IHJvb3Q7XG4gICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgcGF0aCA9IHJvb3QgPyByb290LmNvbmNhdChicmFuY2hOYW1lKSA6IFticmFuY2hOYW1lXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaXNBcnJheVBhdGg9IGFzQXJyYXkgfHwgdHlwZW9mIGJyYW5jaE5hbWU9PT0nc3ltYm9sJztcblxuICAgICAgICAgaGFzTGlzdGVuZXJzICYmIGV2ZW50cy5wdXNoKGlzQXJyYXlQYXRoPyBwYXRoIDogcGF0aC5qb2luKHRoaXMuZGVsaW1pdGVyKSk7XG5cbiAgICAgICAgIGlmKHR5cGVvZiBicmFuY2g9PT0nb2JqZWN0Jyl7XG4gICAgICAgICAgICAgY29sbGVjdFRyZWVFdmVudHMuY2FsbCh0aGlzLCBicmFuY2gsIGV2ZW50cywgcGF0aCwgaXNBcnJheVBhdGgpO1xuICAgICAgICAgfVxuICAgICB9XG5cbiAgICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qocm9vdCkge1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhyb290KTtcbiAgICB2YXIgaT0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIG9iaiwga2V5LCBmbGFnO1xuICAgIHdoaWxlKGktLT4wKXtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmogPSByb290W2tleV07XG5cbiAgICAgIGlmKG9iail7XG4gICAgICAgICAgZmxhZz0gdHJ1ZTtcbiAgICAgICAgICBpZihrZXkgIT09ICdfbGlzdGVuZXJzJyAmJiAhcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChvYmopKXtcbiAgICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBsaXN0ZW5lcil7XG4gICAgdGhpcy5lbWl0dGVyPSBlbWl0dGVyO1xuICAgIHRoaXMuZXZlbnQ9IGV2ZW50O1xuICAgIHRoaXMubGlzdGVuZXI9IGxpc3RlbmVyO1xuICB9XG5cbiAgTGlzdGVuZXIucHJvdG90eXBlLm9mZj0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZXZlbnQsIHRoaXMubGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldHVwTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKXtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHByb21pc2lmeSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdCBvciB0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzeW5jID0gb3B0aW9ucy5hc3luYztcbiAgICAgICAgdmFyIHByb21pc2lmeSA9IG9wdGlvbnMucHJvbWlzaWZ5O1xuICAgICAgICB2YXIgbmV4dFRpY2sgPSBvcHRpb25zLm5leHRUaWNrO1xuICAgICAgICB2YXIgb2JqZWN0aWZ5ID0gb3B0aW9ucy5vYmplY3RpZnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhc3luYyB8fCBuZXh0VGljayB8fCBwcm9taXNpZnkpIHtcbiAgICAgICAgdmFyIF9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB2YXIgX29yaWdpbiA9IGxpc3RlbmVyLl9vcmlnaW4gfHwgbGlzdGVuZXI7XG5cbiAgICAgICAgaWYgKG5leHRUaWNrICYmICFuZXh0VGlja1N1cHBvcnRlZCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdwcm9jZXNzLm5leHRUaWNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNpZnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb21pc2lmeSA9IGxpc3RlbmVyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50O1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2lmeSA/IChuZXh0VGljayA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF9zZXRJbW1lZGlhdGUocmVzb2x2ZSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2xpc3RlbmVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgfSkpIDogKG5leHRUaWNrID8gcHJvY2Vzcy5uZXh0VGljayA6IF9zZXRJbW1lZGlhdGUpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIF9saXN0ZW5lci5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbmVyLl9hc3luYyA9IHRydWU7XG4gICAgICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBfb3JpZ2luO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIFtsaXN0ZW5lciwgb2JqZWN0aWZ5PyBuZXcgTGlzdGVuZXIodGhpcywgZXZlbnQsIGxpc3RlbmVyKTogdGhpc107XG4gIH1cblxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoY29uZikge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHRoaXMuX25ld0xpc3RlbmVyID0gZmFsc2U7XG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gZmFsc2U7XG4gICAgY29uZmlndXJlLmNhbGwodGhpcywgY29uZik7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGV4cG9ydGluZyBFdmVudEVtaXR0ZXIgcHJvcGVydHlcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlblRvPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cywgb3B0aW9ucyl7XG4gICAgaWYodHlwZW9mIHRhcmdldCE9PSdvYmplY3QnKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcigndGFyZ2V0IG11c3RzIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBlbWl0dGVyPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIG9uOiB1bmRlZmluZWQsXG4gICAgICBvZmY6IHVuZGVmaW5lZCxcbiAgICAgIHJlZHVjZXJzOiB1bmRlZmluZWRcbiAgICB9LCB7XG4gICAgICBvbjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgb2ZmOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICByZWR1Y2Vyczogb2JqZWN0RnVuY3Rpb25SZWR1Y2VyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4oZXZlbnRzKXtcbiAgICAgIGlmKHR5cGVvZiBldmVudHMhPT0nb2JqZWN0Jyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnRzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWR1Y2Vycz0gb3B0aW9ucy5yZWR1Y2VycztcbiAgICAgIHZhciBpbmRleD0gZmluZFRhcmdldEluZGV4LmNhbGwoZW1pdHRlciwgdGFyZ2V0KTtcbiAgICAgIHZhciBvYnNlcnZlcjtcblxuICAgICAgaWYoaW5kZXg9PT0tMSl7XG4gICAgICAgIG9ic2VydmVyPSBuZXcgVGFyZ2V0T2JzZXJ2ZXIoZW1pdHRlciwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBvYnNlcnZlcj0gZW1pdHRlci5fb2JzZXJ2ZXJzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXM9IG93bktleXMoZXZlbnRzKTtcbiAgICAgIHZhciBsZW49IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdmFyIGlzU2luZ2xlUmVkdWNlcj0gdHlwZW9mIHJlZHVjZXJzPT09J2Z1bmN0aW9uJztcblxuICAgICAgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspe1xuICAgICAgICBldmVudD0ga2V5c1tpXTtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBldmVudHNbZXZlbnRdIHx8IGV2ZW50LFxuICAgICAgICAgICAgaXNTaW5nbGVSZWR1Y2VyID8gcmVkdWNlcnMgOiByZWR1Y2VycyAmJiByZWR1Y2Vyc1tldmVudF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FycmF5KGV2ZW50cyk/XG4gICAgICAgIGxpc3Rlbih0b09iamVjdChldmVudHMpKSA6XG4gICAgICAgICh0eXBlb2YgZXZlbnRzPT09J3N0cmluZyc/IGxpc3Rlbih0b09iamVjdChldmVudHMuc3BsaXQoL1xccysvKSkpOiBsaXN0ZW4oZXZlbnRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN0b3BMaXN0ZW5pbmdUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycztcblxuICAgIGlmKCFvYnNlcnZlcnMpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1hdGNoZWQ9IGZhbHNlO1xuXG4gICAgaWYodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQhPT0nb2JqZWN0Jyl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RhcmdldCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJzW2ldO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgb2JzZXJ2ZXIuX3RhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKGV2ZW50KTtcbiAgICAgICAgbWF0Y2hlZD0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4gIC8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuICAvLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgLy9cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVsaW1pdGVyID0gJy4nO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gICAgICBpZiAoIXRoaXMuX2NvbmYpIHRoaXMuX2NvbmYgPSB7fTtcbiAgICAgIHRoaXMuX2NvbmYubWF4TGlzdGVuZXJzID0gbjtcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnQgPSAnJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgMSwgZm4sIHByZXBlbmQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIHR0bCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRNYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgdHRsLCBmbiwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmICgtLXR0bCA9PT0gMCkge1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXIuX29yaWdpbiA9IGZuO1xuXG4gICAgcmV0dXJuIHRoaXMuX29uKGV2ZW50LCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgJiYgIXRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgbnMsIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkO1xuICAgIHZhciBhcmdzLGwsaSxqLCBjb250YWluc1N5bWJvbDtcblxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fYWxsLnNsaWNlKCk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgaGFuZGxlciA9IFtdO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwLCBsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBuZWVkIHRvIG1ha2UgY29weSBvZiBoYW5kbGVycyBiZWNhdXNlIGxpc3QgY2FuIGNoYW5nZSBpbiB0aGUgbWlkZGxlXG4gICAgICAgIC8vIG9mIGVtaXQgY2FsbFxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5zbGljZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYWwgPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuX2FsbDtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzICYmICF0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkLCBucywgY29udGFpbnNTeW1ib2w7XG4gICAgdmFyIGFyZ3MsbCxpLGo7XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbZmFsc2VdKTsgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZXM9IFtdO1xuXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLl9hbGwpIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9hbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIGlmIChhbCA+IDMpIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFyZ3VtZW50c1sxXSk7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgbGlzdGVuZXIsIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb25BbnkoZm4sIGZhbHNlKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRBbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiB0aGlzLl9vbkFueShmbiwgdHJ1ZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb25BbnkgPSBmdW5jdGlvbihmbiwgcHJlcGVuZCl7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hbGwpIHtcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNvbGxlY3Rpb24uXG4gICAgaWYocHJlcGVuZCl7XG4gICAgICB0aGlzLl9hbGwudW5zaGlmdChmbik7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9hbGwucHVzaChmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fb25BbnkodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbiBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgcmV0dXJuVmFsdWU9IHRoaXMsIHRlbXA7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZW1wID0gc2V0dXBMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVyID0gdGVtcFswXTtcbiAgICAgIHJldHVyblZhbHVlID0gdGVtcFsxXTtcbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gICAgaWYgKHRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICBncm93TGlzdGVuZXJUcmVlLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGFuZ2UgdG8gYXJyYXkuXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhZGRcbiAgICAgIGlmKHByZXBlbmQpe1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0udW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCAmJlxuICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPiAwICYmXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzLGxlYWZzPVtdO1xuXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICBpZighbGVhZnMpIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgbGVhZnMucHVzaCh7X2xpc3RlbmVyczpoYW5kbGVyc30pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xuICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XG4gICAgICBoYW5kbGVycyA9IGxlYWYuX2xpc3RlbmVycztcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5saXN0ZW5lciAmJiBoYW5kbGVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0uX29yaWdpbiAmJiBoYW5kbGVyc1tpXS5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBsZWFmLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChoYW5kbGVycyA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgKGhhbmRsZXJzLmxpc3RlbmVyICYmIGhhbmRsZXJzLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgKGhhbmRsZXJzLl9vcmlnaW4gJiYgaGFuZGxlcnMuX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyVHJlZSAmJiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgaSA9IDAsIGwgPSAwLCBmbnM7XG4gICAgaWYgKGZuICYmIHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoID4gMCkge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZihmbiA9PT0gZm5zW2ldKSB7XG4gICAgICAgICAgZm5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm5zW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICF0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIHR5cGUsIHRoaXMubGlzdGVuZXJUcmVlLCAwKSwgbGVhZiwgaTtcbiAgICAgIGlmICghbGVhZnMpIHJldHVybiB0aGlzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlYWYgPSBsZWFmc1tpXTtcbiAgICAgICAgbGVhZi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJUcmVlICYmIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3QodGhpcy5saXN0ZW5lclRyZWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgdmFyIGtleXMsIGxpc3RlbmVycywgYWxsTGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsaXN0ZW5lclRyZWU7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignZXZlbnQgbmFtZSByZXF1aXJlZCBmb3Igd2lsZGNhcmQgZW1pdHRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBrZXlzID0gb3duS2V5cyhfZXZlbnRzKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGFsbExpc3RlbmVycyA9IFtdO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgbGlzdGVuZXJzID0gX2V2ZW50c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhbGxMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbExpc3RlbmVycy5wdXNoLmFwcGx5KGFsbExpc3RlbmVycywgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgbGlzdGVuZXJUcmVlPSB0aGlzLmxpc3RlbmVyVHJlZTtcbiAgICAgICAgaWYoIWxpc3RlbmVyVHJlZSkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgbGlzdGVuZXJUcmVlLCAwKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBfZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyA/IFtsaXN0ZW5lcnNdIDogbGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbihuc0FzQXJyYXkpe1xuICAgIHZhciBfZXZlbnRzPSB0aGlzLl9ldmVudHM7XG4gICAgcmV0dXJuIHRoaXMud2lsZGNhcmQ/IGNvbGxlY3RUcmVlRXZlbnRzLmNhbGwodGhpcywgdGhpcy5saXN0ZW5lclRyZWUsIFtdLCBudWxsLCBuc0FzQXJyYXkpIDogKF9ldmVudHM/IG93bktleXMoX2V2ZW50cykgOiBbXSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICByZXR1cm4gaGFuZGxlcnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICB2YXIgX2FsbCA9IHRoaXMuX2FsbDtcblxuICAgIHJldHVybiAhIShfYWxsICYmIF9hbGwubGVuZ3RoIHx8IF9ldmVudHMgJiYgKHR5cGUgPT09IHVuZGVmaW5lZCA/IG93bktleXMoX2V2ZW50cykubGVuZ3RoIDogX2V2ZW50c1t0eXBlXSkpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzQW55ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcHRpb25zO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IHt0aW1lb3V0OiBvcHRpb25zfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSB7ZmlsdGVyOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICBoYW5kbGVFcnJvcjogZmFsc2UsXG4gICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgZmlsdGVyOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICBQcm9taXNlOiBjb25zdHJ1Y3RvclJlZHVjZXJcbiAgICB9KTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2Uob3B0aW9ucy5Qcm9taXNlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBmaWx0ZXI9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fb24oZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgb3ZlcmxvYWQ6IG9wdGlvbnMub3ZlcmxvYWRcbiAgICB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgUHJvbWlzZTogY29uc3RydWN0b3JSZWR1Y2VyXG4gICAgfSk7XG5cbiAgICB2YXIgX1Byb21pc2U9IG9wdGlvbnMuUHJvbWlzZTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2UoX1Byb21pc2UsIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpe1xuICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyPSAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICB7b25jZTogdHJ1ZX1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgJiYgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXJyKXtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgZXJyb3JMaXN0ZW5lciAmJiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICB9LCB7XG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICBvdmVybG9hZDogb3B0aW9ucy5vdmVybG9hZFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZT0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudEVtaXR0ZXIsIHtcbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgICAgICB9XG4gICAgICAgIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBvbmNlOiB7XG4gICAgICB2YWx1ZTogb25jZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90b3R5cGUsIHtcbiAgICAgIF9tYXhMaXN0ZW5lcnM6IHtcbiAgICAgICAgICB2YWx1ZTogZGVmYXVsdE1heExpc3RlbmVycyxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBfb2JzZXJ2ZXJzOiB7dmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnbG9iYWwgZm9yIGFueSBraW5kIG9mIGVudmlyb25tZW50LlxuICAgIHZhciBfZ2xvYmFsPSBuZXcgRnVuY3Rpb24oJycsJ3JldHVybiB0aGlzJykoKTtcbiAgICBfZ2xvYmFsLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0oKTtcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZSc7XG5pbXBvcnQgeyBDb21tYW5kcyB9IGZyb20gJy4vQ29tbWFuZHMnO1xuaW1wb3J0IHsgR2xvYmFsUXVlcnkgfSBmcm9tICcuL0NvbmZpZy9HbG9iYWxRdWVyeSc7XG5pbXBvcnQgeyBUYXNrc0V2ZW50cyB9IGZyb20gJy4vVGFza3NFdmVudHMnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUZpbGUgfSBmcm9tICcuL0ZpbGUnO1xuaW1wb3J0IHsgSW5saW5lUmVuZGVyZXIgfSBmcm9tICcuL0lubGluZVJlbmRlcmVyJztcbmltcG9ydCB7IG5ld0xpdmVQcmV2aWV3RXh0ZW5zaW9uIH0gZnJvbSAnLi9MaXZlUHJldmlld0V4dGVuc2lvbic7XG5pbXBvcnQgeyBRdWVyeVJlbmRlcmVyIH0gZnJvbSAnLi9RdWVyeVJlbmRlcmVyJztcbmltcG9ydCB7IGdldFNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IFNldHRpbmdzVGFiIH0gZnJvbSAnLi9Db25maWcvU2V0dGluZ3NUYWInO1xuaW1wb3J0IHsgU3RhdHVzUmVnaXN0cnkgfSBmcm9tICcuL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IGxvZ2dpbmcgfSBmcm9tICcuL2xpYi9sb2dnaW5nJztcbmltcG9ydCB7IEVkaXRvclN1Z2dlc3RvciB9IGZyb20gJy4vU3VnZ2VzdG9yL0VkaXRvclN1Z2dlc3RvclBvcHVwJztcbmltcG9ydCB7IFN0YXR1c1NldHRpbmdzIH0gZnJvbSAnLi9Db25maWcvU3RhdHVzU2V0dGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB7IHRhc2tzQXBpVjEgfSBmcm9tICcuL0FwaSc7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYXNrc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgcHJpdmF0ZSBjYWNoZTogQ2FjaGUgfCB1bmRlZmluZWQ7XG4gICAgcHVibGljIGlubGluZVJlbmRlcmVyOiBJbmxpbmVSZW5kZXJlciB8IHVuZGVmaW5lZDtcbiAgICBwdWJsaWMgcXVlcnlSZW5kZXJlcjogUXVlcnlSZW5kZXJlciB8IHVuZGVmaW5lZDtcblxuICAgIGdldCBhcGlWMSgpIHtcbiAgICAgICAgcmV0dXJuIHRhc2tzQXBpVjEoYXBwKTtcbiAgICB9XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGxvZ2dpbmcucmVnaXN0ZXJDb25zb2xlTG9nZ2VyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nIHBsdWdpbiBcInRhc2tzXCInKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHsgcGx1Z2luOiB0aGlzIH0pKTtcblxuICAgICAgICBpbml0aWFsaXplRmlsZSh7XG4gICAgICAgICAgICBtZXRhZGF0YUNhY2hlOiB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLFxuICAgICAgICAgICAgdmF1bHQ6IHRoaXMuYXBwLnZhdWx0LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB0aGlzLmFwcC53b3Jrc3BhY2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExvYWQgY29uZmlndXJlZCBzdGF0dXMgdHlwZXMuXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFRhc2tTdGF0dXNlcygpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBUYXNrc0V2ZW50cyh7IG9ic2lkaWFuRXZlbnRzOiB0aGlzLmFwcC53b3Jrc3BhY2UgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoe1xuICAgICAgICAgICAgbWV0YWRhdGFDYWNoZTogdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgIHZhdWx0OiB0aGlzLmFwcC52YXVsdCxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5saW5lUmVuZGVyZXIgPSBuZXcgSW5saW5lUmVuZGVyZXIoeyBwbHVnaW46IHRoaXMgfSk7XG4gICAgICAgIHRoaXMucXVlcnlSZW5kZXJlciA9IG5ldyBRdWVyeVJlbmRlcmVyKHsgcGx1Z2luOiB0aGlzLCBldmVudHMgfSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihuZXdMaXZlUHJldmlld0V4dGVuc2lvbigpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvclN1Z2dlc3QobmV3IEVkaXRvclN1Z2dlc3Rvcih0aGlzLmFwcCwgZ2V0U2V0dGluZ3MoKSkpO1xuICAgICAgICBuZXcgQ29tbWFuZHMoeyBwbHVnaW46IHRoaXMgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFRhc2tTdGF0dXNlcygpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXNTZXR0aW5ncyB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgU3RhdHVzU2V0dGluZ3MuYXBwbHlUb1N0YXR1c1JlZ2lzdHJ5KHN0YXR1c1NldHRpbmdzLCBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3VubG9hZGluZyBwbHVnaW4gXCJ0YXNrc1wiJyk7XG4gICAgICAgIHRoaXMuY2FjaGU/LnVubG9hZCgpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHVwZGF0ZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuc2V0KG5ld1NldHRpbmdzLmdsb2JhbEZpbHRlcik7XG4gICAgICAgIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnNldFJlbW92ZUdsb2JhbEZpbHRlcihuZXdTZXR0aW5ncy5yZW1vdmVHbG9iYWxGaWx0ZXIpO1xuICAgICAgICBHbG9iYWxRdWVyeS5nZXRJbnN0YW5jZSgpLnNldChuZXdTZXR0aW5ncy5nbG9iYWxRdWVyeSk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFRhc2tTdGF0dXNlcygpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YShnZXRTZXR0aW5ncygpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VGFza3MoKTogVGFza1tdIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGU/LmdldFRhc2tzKCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IE1ldGFkYXRhQ2FjaGUsIE5vdGljZSwgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBDYWNoZWRNZXRhZGF0YSwgRXZlbnRSZWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEhlYWRpbmdDYWNoZSwgTGlzdEl0ZW1DYWNoZSwgU2VjdGlvbkNhY2hlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTXV0ZXggfSBmcm9tICdhc3luYy1tdXRleCc7XG5cbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBUYXNrc0V2ZW50cyB9IGZyb20gJy4vVGFza3NFdmVudHMnO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBMYXp5IH0gZnJvbSAnLi9saWIvTGF6eSc7XG5pbXBvcnQgeyBUYXNrTG9jYXRpb24gfSBmcm9tICcuL1Rhc2tMb2NhdGlvbic7XG4vLyBpbXBvcnQgeyBsb2dnaW5nIH0gZnJvbSAnLi9saWIvbG9nZ2luZyc7XG5cbmV4cG9ydCBlbnVtIFN0YXRlIHtcbiAgICBDb2xkID0gJ0NvbGQnLFxuICAgIEluaXRpYWxpemluZyA9ICdJbml0aWFsaXppbmcnLFxuICAgIFdhcm0gPSAnV2FybScsXG59XG5cbi8vIGNvbnN0IGxvZ2dlciA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd0YXNrcycpO1xuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXM6IEV2ZW50UmVmW107XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdDogVmF1bHQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXVsdEV2ZW50UmVmZXJlbmNlczogRXZlbnRSZWZbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogVGFza3NFdmVudHM7XG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudHNFdmVudFJlZmVyZW5jZXM6IEV2ZW50UmVmW107XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhc2tzTXV0ZXg6IE11dGV4O1xuICAgIHByaXZhdGUgc3RhdGU6IFN0YXRlO1xuICAgIHByaXZhdGUgdGFza3M6IFRhc2tbXTtcblxuICAgIC8qKlxuICAgICAqIFdlIGNhbm5vdCBrbm93IGlmIHRoaXMgY2xhc3Mgd2lsbCBiZSBpbnN0YW50aWF0ZWQgYmVjYXVzZSBvYnNpZGlhbiBzdGFydGVkXG4gICAgICogb3IgYmVjYXVzZSB0aGUgcGx1Z2luIHdhcyBhY3RpdmF0ZWQgbGF0ZXIuIFRoaXMgbWVhbnMgd2UgaGF2ZSB0byBsb2FkIHRoZVxuICAgICAqIHdob2xlIHZhdWx0IG9uY2UgYWZ0ZXIgdGhlIGZpcnN0IG1ldGFkYXRhIGNhY2hlIHJlc29sdmUgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgKiBsb2FkIHRoZSBlbnRpcmUgdmF1bHQgaW4gY2FzZSBvYnNpZGlhbiBpcyBzdGFydGluZyB1cC4gSW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiBvYnNpZGlhbiBzdGFydGluZywgdGhlIHRhc2sgY2FjaGUncyBpbml0aWFsIGxvYWQgd291bGQgZW5kIHVwIHdpdGggMCB0YXNrcyxcbiAgICAgKiBhcyB0aGUgbWV0YWRhdGEgY2FjaGUgd291bGQgc3RpbGwgYmUgZW1wdHkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkZWRBZnRlckZpcnN0UmVzb2x2ZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQsIGV2ZW50cyB9OiB7IG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7IHZhdWx0OiBWYXVsdDsgZXZlbnRzOiBUYXNrc0V2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG1ldGFkYXRhQ2FjaGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZUV2ZW50UmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnZhdWx0ID0gdmF1bHQ7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgdGhpcy50YXNrc011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5Db2xkO1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG5cbiAgICAgICAgdGhpcy5sb2FkZWRBZnRlckZpcnN0UmVzb2x2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DYWNoZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvVmF1bHQoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xuXG4gICAgICAgIHRoaXMubG9hZFZhdWx0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVubG9hZCgpOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudFJlZmVyZW5jZSBvZiB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5vZmZyZWYoZXZlbnRSZWZlcmVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBldmVudFJlZmVyZW5jZSBvZiB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnZhdWx0Lm9mZnJlZihldmVudFJlZmVyZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50UmVmZXJlbmNlIG9mIHRoaXMuZXZlbnRzRXZlbnRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5vZmYoZXZlbnRSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRhc2tzKCk6IFRhc2tbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdGF0ZSgpOiBTdGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5U3Vic2NyaWJlcnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJDYWNoZVVwZGF0ZSh7XG4gICAgICAgICAgICB0YXNrczogdGhpcy50YXNrcyxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRXZlbnRlUmVmZXJlbmNlID0gdGhpcy5tZXRhZGF0YUNhY2hlLm9uKCdyZXNvbHZlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmVkIGZpcmVzIG9uIGV2ZXJ5IGNoYW5nZS5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBpbml0aWFsaXplIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRBZnRlckZpcnN0UmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkQWZ0ZXJGaXJzdFJlc29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZFZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChyZXNvbHZlZEV2ZW50ZVJlZmVyZW5jZSk7XG5cbiAgICAgICAgLy8gRG9lcyBub3QgZmlyZSB3aGVuIHN0YXJ0aW5nIHVwIG9ic2lkaWFuIGFuZCBvbmx5IHdvcmtzIGZvciBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBjaGFuZ2VkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLm1ldGFkYXRhQ2FjaGUub24oJ2NoYW5nZWQnLCAoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGVFdmVudFJlZmVyZW5jZXMucHVzaChjaGFuZ2VkRXZlbnRSZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9WYXVsdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyB1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSB9ID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICBjb25zdCBjcmVhdGVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdjcmVhdGUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50YXNrc011dGV4LnJ1bkV4Y2x1c2l2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmF1bHRFdmVudFJlZmVyZW5jZXMucHVzaChjcmVhdGVkRXZlbnRSZWZlcmVuY2UpO1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRFdmVudFJlZmVyZW5jZSA9IHRoaXMudmF1bHQub24oJ2RlbGV0ZScsIChmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5maWx0ZXIoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2sucGF0aCAhPT0gZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhdWx0RXZlbnRSZWZlcmVuY2VzLnB1c2goZGVsZXRlZEV2ZW50UmVmZXJlbmNlKTtcblxuICAgICAgICBjb25zdCByZW5hbWVkRXZlbnRSZWZlcmVuY2UgPSB0aGlzLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhc2tzTXV0ZXgucnVuRXhjbHVzaXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja0RhdGUgPSBuZXcgTGF6eSgoKSA9PiBEYXRlRmFsbGJhY2suZnJvbVBhdGgoZmlsZS5wYXRoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5tYXAoKHRhc2s6IFRhc2spOiBUYXNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2sucGF0aCA9PT0gb2xkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogdGFzay50YXNrTG9jYXRpb24uZnJvbVJlbmFtZWRGaWxlKGZpbGUucGF0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlRmFsbGJhY2sudXBkYXRlVGFza1BhdGgodGFzaywgZmlsZS5wYXRoLCBmYWxsYmFja0RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXVsdEV2ZW50UmVmZXJlbmNlcy5wdXNoKHJlbmFtZWRFdmVudFJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVUb0V2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFJlZmVyZW5jZSA9IHRoaXMuZXZlbnRzLm9uUmVxdWVzdENhY2hlVXBkYXRlKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKHsgdGFza3M6IHRoaXMudGFza3MsIHN0YXRlOiB0aGlzLnN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHNFdmVudFJlZmVyZW5jZXMucHVzaChyZXF1ZXN0UmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxvYWRWYXVsdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza3NNdXRleC5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluaXRpYWxpemluZztcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLm1hcCgoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XYXJtO1xuICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgdGhlIGNhY2hlIGlzIG5vdyB3YXJtOlxuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGluZGV4RmlsZShmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgICAgICBpZiAoZmlsZUNhY2hlID09PSBudWxsIHx8IGZpbGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRUYXNrcyA9IHRoaXMudGFza3MuZmlsdGVyKCh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wYXRoID09PSBmaWxlLnBhdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IGZpbGVDYWNoZS5saXN0SXRlbXM7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gbGlzdCBpdGVtcyBjYWNoZSwgdGhlcmUgYXJlIG5vIHRhc2tzLlxuICAgICAgICAvLyBTdGlsbCBjb250aW51ZSB0byBub3RpZnkgd2F0Y2hlcnMgb2YgcmVtb3ZhbC5cblxuICAgICAgICBsZXQgbmV3VGFza3M6IFRhc2tbXSA9IFtdO1xuICAgICAgICBpZiAobGlzdEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmVhZCB0aGUgZmlsZSBhbmQgcHJvY2VzcyBmb3IgdGFza3MgaWYgdGhlcmUgYXJlIGxpc3QgaXRlbXMuXG4gICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcbiAgICAgICAgICAgIG5ld1Rhc2tzID0gdGhpcy5nZXRUYXNrc0Zyb21GaWxlQ29udGVudChmaWxlQ29udGVudCwgbGlzdEl0ZW1zLCBmaWxlQ2FjaGUsIGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgaW4gYW55IG9mIHRoZSB0YXNrcywgdGhlcmUnc1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvLCBzbyBqdXN0IHJldHVybi5cbiAgICAgICAgaWYgKFRhc2sudGFza3NMaXN0c0lkZW50aWNhbChvbGRUYXNrcywgbmV3VGFza3MpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUga2VwdCBmb3Igbm93LCB0byBhbGxvdyBmb3IgZGVidWdnaW5nIGR1cmluZyBkZXZlbG9wbWVudC5cbiAgICAgICAgICAgIC8vIEl0IGlzIHRvbyB2ZXJib3NlIHRvIHJlbGVhc2UgdG8gdXNlcnMuXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5nZXRTdGF0ZSgpID09IFN0YXRlLldhcm0pIHtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmRlYnVnKGBUYXNrcyB1bmNoYW5nZWQgaW4gJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcnkgZWRpdCAtIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzIxNjBcbiAgICAgICAgLypcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PSBTdGF0ZS5XYXJtKSB7XG4gICAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYENhY2hlIHJlYWQ6ICR7ZmlsZS5wYXRofWApO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgQXQgbGVhc3Qgb25lIHRhc2ssIGl0cyBsaW5lIG51bWJlciBvciBpdHMgaGVhZGluZyBoYXMgY2hhbmdlZCBpbiAke2ZpbGUucGF0aH06IHRyaWdnZXJpbmcgYSByZWZyZXNoIG9mIGFsbCBhY3RpdmUgVGFza3MgYmxvY2tzIGluIExpdmUgUHJldmlldyBhbmQgUmVhZGluZyBtb2RlIHZpZXdzLmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0YXNrcyBmcm9tIHRoaXMgZmlsZSBmcm9tIHRoZSBjYWNoZSBiZWZvcmVcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBvbmVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGUgZmlsZS5cbiAgICAgICAgdGhpcy50YXNrcyA9IHRoaXMudGFza3MuZmlsdGVyKCh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wYXRoICE9PSBmaWxlLnBhdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudGFza3MucHVzaCguLi5uZXdUYXNrcyk7XG5cbiAgICAgICAgLy8gQWxsIHVwZGF0ZWQsIGluZm9ybSBvdXIgc3Vic2NyaWJlcnMuXG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRhc2tzRnJvbUZpbGVDb250ZW50KFxuICAgICAgICBmaWxlQ29udGVudDogc3RyaW5nLFxuICAgICAgICBsaXN0SXRlbXM6IExpc3RJdGVtQ2FjaGVbXSxcbiAgICAgICAgZmlsZUNhY2hlOiBDYWNoZWRNZXRhZGF0YSxcbiAgICAgICAgZmlsZTogVEZpbGUsXG4gICAgKTogVGFza1tdIHtcbiAgICAgICAgY29uc3QgdGFza3M6IFRhc2tbXSA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlTGluZXMgPSBmaWxlQ29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGxpbmVzSW5GaWxlID0gZmlsZUxpbmVzLmxlbmd0aDtcblxuICAgICAgICAvLyBMYXppbHkgc3RvcmUgZGF0ZSBleHRyYWN0ZWQgZnJvbSBmaWxlbmFtZSB0byBhdm9pZCBwYXJzaW5nIG1vcmUgdGhhbiBuZWVkZWRcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgZ2V0VGFza3NGcm9tRmlsZUNvbnRlbnQoKSByZWFkaW5nICR7ZmlsZS5wYXRofWApO1xuICAgICAgICBjb25zdCBkYXRlRnJvbUZpbGVOYW1lID0gbmV3IExhenkoKCkgPT4gRGF0ZUZhbGxiYWNrLmZyb21QYXRoKGZpbGUucGF0aCkpO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc3RvcmUgc2VjdGlvbiBpbmZvcm1hdGlvbiB3aXRoIGV2ZXJ5IHRhc2sgc29cbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gdXNlIHRoYXQgd2hlbiB3ZSBwb3N0IHByb2Nlc3MgdGhlIG1hcmtkb3duXG4gICAgICAgIC8vIHJlbmRlcmVkIGxpc3RzLlxuICAgICAgICBsZXQgY3VycmVudFNlY3Rpb246IFNlY3Rpb25DYWNoZSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbS50YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gbGlzdEl0ZW0ucG9zaXRpb24uc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlciA+PSBsaW5lc0luRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JzaWRpYW4gQ2FjaGVkTWV0YWRhdGEgaGFzIHRvbGQgdXMgdGhhdCB0aGVyZSBpcyBhIHRhc2sgb24gbGluZU51bWJlciwgYnV0IHRoZXJlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90IHRoYXQgbWFueSBsaW5lcyBpbiB0aGUgZmlsZS5cblxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB3YXMgdGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgYWxsIHRoZSAnU3R1Y2sgb24gXCJMb2FkaW5nIFRhc2tzLi4uXCInIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMgaXQgcmVzdWx0ZWQgaW4gdGhlIGxpbmUgJ3VuZGVmaW5lZCcgYmVpbmcgcGFyc2VkLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBTb21laG93IHRoZSBmaWxlIGhhZCBiZWVuIHNob3J0ZW5lZCB3aGlsc3QgT2JzaWRpYW4gd2FzIGNsb3NlZCwgbWVhbmluZyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuIE9ic2lkaWFuIHN0YXJ0ZWQgdXAsIGl0IGdvdCB0aGUgbmV3IGZpbGUgY29udGVudCwgYnV0IHN0aWxsIGhhZCB0aGUgb2xkIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSBhYm91dCBsb2NhdGlvbnMgb2YgbGlzdCBpdGVtcyBpbiB0aGUgZmlsZS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZmlsZS5wYXRofSBPYnNpZGlhbiBnYXZlIHVzIGEgbGluZSBudW1iZXIgJHtsaW5lTnVtYmVyfSBwYXN0IHRoZSBlbmQgb2YgdGhlIGZpbGUuICR7bGluZXNJbkZpbGV9LmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lIDwgbGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZW50IHBhc3QgdGhlIGN1cnJlbnQgc2VjdGlvbiAob3IgdGhpcyBpcyB0aGUgZmlyc3QgdGFzaykuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gdGhhdCBpcyByZWxldmFudCBmb3IgdGhpcyB0YXNrIGFuZCB0aGUgZm9sbG93aW5nIG9mIHRoZSBzYW1lIHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gQ2FjaGUuZ2V0U2VjdGlvbihsaW5lTnVtYmVyLCBmaWxlQ2FjaGUuc2VjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcHJvY2VzcyBhIHRhc2sgd2l0aG91dCBhIHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBmaWxlTGluZXNbbGluZU51bWJlcl07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtmaWxlLnBhdGh9OiBsaW5lICR7bGluZU51bWJlcn0gLSBpZ25vcmluZyAndW5kZWZpbmVkJyBsaW5lLmApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza0xvY2F0aW9uOiBuZXcgVGFza0xvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uLnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlLmdldFByZWNlZGluZ0hlYWRlcihsaW5lTnVtYmVyLCBmaWxlQ2FjaGUuaGVhZGluZ3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrRGF0ZTogZGF0ZUZyb21GaWxlTmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFRhc2tQYXJzaW5nRXJyb3JUb1VzZXIoZSwgZmlsZSwgbGlzdEl0ZW0sIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFza3M7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXBvcnRUYXNrUGFyc2luZ0Vycm9yVG9Vc2VyKGU6IGFueSwgZmlsZTogVEZpbGUsIGxpc3RJdGVtOiBMaXN0SXRlbUNhY2hlLCBsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZXJlIHdhcyBhbiBlcnJvciByZWFkaW5nIG9uZSBvZiB0aGUgdGFza3MgaW4gdGhpcyB2YXVsdC5cblRoZSBmb2xsb3dpbmcgdGFzayBoYXMgYmVlbiBpZ25vcmVkLCB0byBwcmV2ZW50IFRhc2tzIHF1ZXJpZXMgZ2V0dGluZyBzdHVjayB3aXRoICdMb2FkaW5nIFRhc2tzIC4uLidcbkVycm9yOiAke2V9XG5GaWxlOiAke2ZpbGUucGF0aH1cbkxpbmUgbnVtYmVyOiAke2xpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmV9XG5UYXNrIGxpbmU6ICR7bGluZX1cblxuUGxlYXNlIGNyZWF0ZSBhIGJ1ZyByZXBvcnQgZm9yIHRoaXMgbWVzc2FnZSBhdFxuaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy9uZXcvY2hvb3NlXG50byBoZWxwIHVzIGZpbmQgYW5kIGZpeCB0aGUgdW5kZXJseWluZyBpc3N1ZS5cblxuSW5jbHVkZTpcbi0gZWl0aGVyIGEgc2NyZWVuc2hvdCBvZiB0aGUgZXJyb3IgcG9wdXAsIG9yIGNvcHkgdGhlIHRleHQgZnJvbSB0aGUgY29uc29sZSwgaWYgb24gYSBkZXNrdG9wIG1hY2hpbmUuXG4tIHRoZSBvdXRwdXQgZnJvbSBydW5uaW5nIHRoZSBPYnNpZGlhbiBjb21tYW5kICdTaG93IGRlYnVnIGluZm8nXG5cblRoZSBlcnJvciBwb3B1cCB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiBUYXNrcyBpcyBzdGFydGluZyB1cCwgYnV0IGlmIHRoZSBlcnJvciBwZXJzaXN0cyxcbml0IHdpbGwgYmUgc2hvd24gaW4gdGhlIGNvbnNvbGUgZXZlcnkgdGltZSB0aGlzIGZpbGUgaXMgZWRpdGVkIGR1cmluZyB0aGUgT2JzaWRpYW5cbnNlc3Npb24uXG5gO1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluaXRpYWxpemluZykge1xuICAgICAgICAgICAgbmV3IE5vdGljZShtc2csIDEwMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFNlY3Rpb24obGluZU51bWJlclRhc2s6IG51bWJlciwgc2VjdGlvbnM6IFNlY3Rpb25DYWNoZVtdIHwgdW5kZWZpbmVkKTogU2VjdGlvbkNhY2hlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZSA8PSBsaW5lTnVtYmVyVGFzayAmJiBzZWN0aW9uLnBvc2l0aW9uLmVuZC5saW5lID49IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRQcmVjZWRpbmdIZWFkZXIobGluZU51bWJlclRhc2s6IG51bWJlciwgaGVhZGluZ3M6IEhlYWRpbmdDYWNoZVtdIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGlmIChoZWFkaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcmVjZWRpbmdIZWFkZXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGluZyBvZiBoZWFkaW5ncykge1xuICAgICAgICAgICAgaWYgKGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSA+IGxpbmVOdW1iZXJUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWNlZGluZ0hlYWRlciA9IGhlYWRpbmcuaGVhZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cbn1cbiIsICJjb25zdCBFX1RJTUVPVVQgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgbXV0ZXggdG8gYmVjb21lIGF2YWlsYWJsZScpO1xuY29uc3QgRV9BTFJFQURZX0xPQ0tFRCA9IG5ldyBFcnJvcignbXV0ZXggYWxyZWFkeSBsb2NrZWQnKTtcbmNvbnN0IEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoJ3JlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWQnKTtcblxudmFyIF9fYXdhaXRlciQyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2NhbmNlbEVycm9yID0gRV9DQU5DRUxFRCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsRXJyb3IgPSBfY2FuY2VsRXJyb3I7XG4gICAgICAgIHRoaXMuX3dlaWdodGVkUXVldWVzID0gW107XG4gICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVycyA9IFtdO1xuICAgIH1cbiAgICBhY3F1aXJlKHdlaWdodCA9IDEpIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2VpZ2h0ZWRRdWV1ZXNbd2VpZ2h0IC0gMV0pXG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRRdWV1ZXNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkUXVldWVzW3dlaWdodCAtIDFdLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCB3ZWlnaHQgPSAxKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgcmVsZWFzZV0gPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2sod2VpZ2h0ID0gMSkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdKVxuICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA8PSAwO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgIH1cbiAgICByZWxlYXNlKHdlaWdodCA9IDEpIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgKz0gd2VpZ2h0O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX3dlaWdodGVkUXVldWVzLmZvckVhY2goKHF1ZXVlKSA9PiBxdWV1ZS5mb3JFYWNoKChlbnRyeSkgPT4gZW50cnkucmVqZWN0KHRoaXMuX2NhbmNlbEVycm9yKSkpO1xuICAgICAgICB0aGlzLl93ZWlnaHRlZFF1ZXVlcyA9IFtdO1xuICAgIH1cbiAgICBfZGlzcGF0Y2goKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChsZXQgd2VpZ2h0ID0gdGhpcy5fdmFsdWU7IHdlaWdodCA+IDA7IHdlaWdodC0tKSB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZUVudHJ5ID0gKF9hID0gdGhpcy5fd2VpZ2h0ZWRRdWV1ZXNbd2VpZ2h0IC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFxdWV1ZUVudHJ5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNXZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSAtPSB3ZWlnaHQ7XG4gICAgICAgICAgICB3ZWlnaHQgPSB0aGlzLl92YWx1ZSArIDE7XG4gICAgICAgICAgICBxdWV1ZUVudHJ5LnJlc29sdmUoW3ByZXZpb3VzVmFsdWUsIHRoaXMuX25ld1JlbGVhc2VyKHByZXZpb3VzV2VpZ2h0KV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgIH1cbiAgICBfbmV3UmVsZWFzZXIod2VpZ2h0KSB7XG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSh3ZWlnaHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZHJhaW5VbmxvY2tXYWl0ZXJzKCkge1xuICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdLmZvckVhY2goKHdhaXRlcikgPT4gd2FpdGVyKCkpO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBfX2F3YWl0ZXIkMSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY2xhc3MgTXV0ZXgge1xuICAgIGNvbnN0cnVjdG9yKGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NlbWFwaG9yZSA9IG5ldyBTZW1hcGhvcmUoMSwgY2FuY2VsRXJyb3IpO1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBbLCByZWxlYXNlcl0gPSB5aWVsZCB0aGlzLl9zZW1hcGhvcmUuYWNxdWlyZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2VyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUucnVuRXhjbHVzaXZlKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLndhaXRGb3JVbmxvY2soKTtcbiAgICB9XG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpKVxuICAgICAgICAgICAgdGhpcy5fc2VtYXBob3JlLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gd2l0aFRpbWVvdXQoc3luYywgdGltZW91dCwgdGltZW91dEVycm9yID0gRV9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNxdWlyZTogKHdlaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCBzeW5jLmFjcXVpcmUod2VpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IEFycmF5LmlzQXJyYXkodGlja2V0KSA/IHRpY2tldFsxXSA6IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCB3ZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgdGhpcy5hY3F1aXJlKHdlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRpY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodGlja2V0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlKHdlaWdodCkge1xuICAgICAgICAgICAgc3luYy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICB3YWl0Rm9yVW5sb2NrOiAod2VpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzeW5jLndhaXRGb3JVbmxvY2sod2VpZ2h0KS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KHRpbWVvdXRFcnJvciksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTG9ja2VkOiAoKSA9PiBzeW5jLmlzTG9ja2VkKCksXG4gICAgICAgIGdldFZhbHVlOiAoKSA9PiBzeW5jLmdldFZhbHVlKCksXG4gICAgICAgIHNldFZhbHVlOiAodmFsdWUpID0+IHN5bmMuc2V0VmFsdWUodmFsdWUpLFxuICAgIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGlzbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gdHJ5QWNxdWlyZShzeW5jLCBhbHJlYWR5QWNxdWlyZWRFcnJvciA9IEVfQUxSRUFEWV9MT0NLRUQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiB3aXRoVGltZW91dChzeW5jLCAwLCBhbHJlYWR5QWNxdWlyZWRFcnJvcik7XG59XG5cbmV4cG9ydCB7IEVfQUxSRUFEWV9MT0NLRUQsIEVfQ0FOQ0VMRUQsIEVfVElNRU9VVCwgTXV0ZXgsIFNlbWFwaG9yZSwgdHJ5QWNxdWlyZSwgd2l0aFRpbWVvdXQgfTtcbiIsICJpbXBvcnQgKiBhcyBjaHJvbm8gZnJvbSAnY2hyb25vLW5vZGUnO1xuaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9EYXRlUmFuZ2UnO1xuXG5leHBvcnQgY2xhc3MgRGF0ZVBhcnNlciB7XG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGUoaW5wdXQ6IHN0cmluZywgZm9yd2FyZERhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IE1vbWVudCB7XG4gICAgICAgIC8vIFVzaW5nIHN0YXJ0IG9mIGRheSB0byBjb3JyZWN0bHkgbWF0Y2ggb24gY29tcGFyaXNvbiB3aXRoIG90aGVyIGRhdGVzIChsaWtlIGVxdWFsaXR5KS5cbiAgICAgICAgcmV0dXJuIHdpbmRvd1xuICAgICAgICAgICAgLm1vbWVudChcbiAgICAgICAgICAgICAgICBjaHJvbm8ucGFyc2VEYXRlKGlucHV0LCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZERhdGU6IGZvcndhcmREYXRlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN0YXJ0T2YoJ2RheScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbGluZSBhbmQgZXh0cmFjdCBhIHBhaXIgb2YgZGF0ZXMsIHJldHVybmVkIGluIGEgdHVwbGUsIHNvcnRlZCBieSBkYXRlLlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIGFueSBwYWlyIG9mIGRhdGVzLCBzZXBhcmF0ZSBieSBvbmUgb3IgbW9yZSBzcGFjZXMgJzE3IEF1Z3VzdCAyMDEzIDE5IEF1Z3VzdCAyMDEzJyxcbiAgICAgKiAgICAgICAgICAgICAgICBvciBhIHNpbmdsZSBkYXRlLlxuICAgICAqIEBwYXJhbSBmb3J3YXJkRGF0ZSAtIGlmIHRydWUsIGFuZCBkYXRlIGlzIGFtYmlndW91cywgY2hyb25vIHdpbGwgcmV0dXJuIGRhdGVzIGluIHRoZSBmdXR1cmVcbiAgICAgKiBAcmV0dXJuIC0gQSBUdXBsZSBvZiBkYXRlcy4gSWYgYm90aCBpbnB1dCBkYXRlcyBhcmUgaW52YWxpZCwgdGhlbiBib3RoIG91dHB1dCBkYXRlcyB3aWxsIGJlIGludmFsaWQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVSYW5nZShpbnB1dDogc3RyaW5nLCBmb3J3YXJkRGF0ZTogYm9vbGVhbiA9IGZhbHNlKTogRGF0ZVJhbmdlIHtcbiAgICAgICAgY29uc3QgZGF0ZVJhbmdlUGFyc2VycyA9IFtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIGEgcmVsYXRpdmUgZGF0ZSByYW5nZSBsaWtlICdjdXJyZW50IG1vbnRoJ1xuICAgICAgICAgICAgRGF0ZVBhcnNlci5wYXJzZVJlbGF0aXZlRGF0ZVJhbmdlLFxuICAgICAgICAgICAgLy8gVHJ5ICcyMDIyLVcxMCcgb3RoZXJ3aXNlXG4gICAgICAgICAgICBEYXRlUGFyc2VyLnBhcnNlTnVtYmVyZWREYXRlUmFuZ2UsXG4gICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBmYWlsZWQsIGZhbGxiYWNrIG9uIGFic29sdXRlIGRhdGUgcmFuZ2Ugd2l0aCBjaHJvbm9cbiAgICAgICAgICAgIERhdGVQYXJzZXIucGFyc2VBYnNvbHV0ZURhdGVSYW5nZSxcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHBhcnNlciBvZiBkYXRlUmFuZ2VQYXJzZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRlUmFuZ2UgPSBwYXJzZXIoaW5wdXQsIGZvcndhcmREYXRlKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlUmFuZ2UuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGVSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd29ya2VkIHJldHVybiBhbmQgaW52YWxpZCBkYXRlIHJhbmdlXG4gICAgICAgIHJldHVybiBEYXRlUmFuZ2UuYnVpbGRJbnZhbGlkKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VBYnNvbHV0ZURhdGVSYW5nZShpbnB1dDogc3RyaW5nLCBmb3J3YXJkRGF0ZTogYm9vbGVhbik6IERhdGVSYW5nZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNocm9uby5wYXJzZShpbnB1dCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBmb3J3YXJkRGF0ZTogZm9yd2FyZERhdGUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIGNocm9ubyBwYXJzaW5nXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVJhbmdlLmJ1aWxkSW52YWxpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gcmVzdWx0WzBdLnN0YXJ0O1xuICAgICAgICBjb25zdCBlbmREYXRlID0gcmVzdWx0WzFdICYmIHJlc3VsdFsxXS5zdGFydCA/IHJlc3VsdFsxXS5zdGFydCA6IHN0YXJ0RGF0ZTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB3aW5kb3cubW9tZW50KHN0YXJ0RGF0ZS5kYXRlKCkpO1xuICAgICAgICBjb25zdCBlbmQgPSB3aW5kb3cubW9tZW50KGVuZERhdGUuZGF0ZSgpKTtcblxuICAgICAgICByZXR1cm4gbmV3IERhdGVSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZVJlbGF0aXZlRGF0ZVJhbmdlKGlucHV0OiBzdHJpbmcsIF9mb3J3YXJkRGF0ZTogYm9vbGVhbik6IERhdGVSYW5nZSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlRGF0ZVJhbmdlUmVnZXhwID0gLyhsYXN0fHRoaXN8bmV4dCkgKHdlZWt8bW9udGh8cXVhcnRlcnx5ZWFyKS87XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlRGF0ZVJhbmdlTWF0Y2ggPSBpbnB1dC5tYXRjaChyZWxhdGl2ZURhdGVSYW5nZVJlZ2V4cCk7XG4gICAgICAgIGlmIChyZWxhdGl2ZURhdGVSYW5nZU1hdGNoICYmIHJlbGF0aXZlRGF0ZVJhbmdlTWF0Y2gubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGhpc05leHQgPSByZWxhdGl2ZURhdGVSYW5nZU1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByZWxhdGl2ZURhdGVSYW5nZU1hdGNoWzJdO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRlUmFuZ2UgPSBEYXRlUmFuZ2UuYnVpbGRSZWxhdGl2ZShyYW5nZSBhcyBtb21lbnQudW5pdE9mVGltZS5TdGFydE9mKTtcblxuICAgICAgICAgICAgc3dpdGNoIChsYXN0VGhpc05leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVJhbmdlLm1vdmVUb1ByZXZpb3VzKHJhbmdlIGFzIG1vbWVudC51bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVJhbmdlLm1vdmVUb05leHQocmFuZ2UgYXMgbW9tZW50LnVuaXRPZlRpbWUuRHVyYXRpb25Db25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0ZVJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERhdGVSYW5nZS5idWlsZEludmFsaWQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZU51bWJlcmVkRGF0ZVJhbmdlKGlucHV0OiBzdHJpbmcsIF9mb3J3YXJkRGF0ZTogYm9vbGVhbik6IERhdGVSYW5nZSB7XG4gICAgICAgIGNvbnN0IHBhcnNpbmdWZWN0b3JzOiBbUmVnRXhwLCBzdHJpbmcsIG1vbWVudC51bml0T2ZUaW1lLlN0YXJ0T2ZdW10gPSBbXG4gICAgICAgICAgICBbL15cXHMqWzAtOV17NH1cXHMqJC8sICdZWVlZJywgJ3llYXInXSxcbiAgICAgICAgICAgIFsvXlxccypbMC05XXs0fS1RWzEtNF1cXHMqJC8sICdZWVlZLVEnLCAncXVhcnRlciddLFxuICAgICAgICAgICAgWy9eXFxzKlswLTldezR9LVswLTldezJ9XFxzKiQvLCAnWVlZWS1NTScsICdtb250aCddLFxuICAgICAgICAgICAgWy9eXFxzKlswLTldezR9LVdbMC05XXsyfVxccyokLywgJ1lZWVktV1cnLCAnaXNvV2VlayddLFxuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3JlZ2V4cCwgZGF0ZUZvcm1hdCwgcmFuZ2VdIG9mIHBhcnNpbmdWZWN0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gaW5wdXQubWF0Y2gocmVnZXhwKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVnRXhwcyBhbGxvdyBzcGFjZXMgKFxccyopLCByZW1vdmUgdGhlbSBiZWZvcmUgY2FsbGluZyB3aW5kb3cubW9tZW50KClcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbWF0Y2hlZFswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoZGF0ZSwgZGF0ZUZvcm1hdCkuc3RhcnRPZihyYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoZGF0ZSwgZGF0ZUZvcm1hdCkuZW5kT2YocmFuZ2UpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGF0ZVJhbmdlLmJ1aWxkSW52YWxpZCgpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIGluY2x1c2l2ZSBzcGFuIG9mIHRpbWUgYmV0d2VlbiB0d28gZGF5cyBhdCAwMDowMCBsb2NhbCB0aW1lLlxuICovXG5leHBvcnQgY2xhc3MgRGF0ZVJhbmdlIHtcbiAgICBzdGFydDogTW9tZW50O1xuICAgIGVuZDogTW9tZW50O1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBkYXRlIHJhbmdlLiBJZiBzdGFydCBpcyBhZnRlciB0aGUgZW5kLCB0aGUgZGF0ZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJldmVyc2VkLlxuICAgICAqIFN0YXJ0IGFuZCBlbmQgd2lsbCBiZSBzYXZlZCBhdCAwMDowMCBsb2NhbCB0aW1lLlxuICAgICAqIFRoZSBzdG9yZWQgdmFsdWVzIG9mIGFyZSBtdXRhYmxlLlxuICAgICAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyB2YWxpZGF0aW9uIG9mIHRoZSBzdGFydCBhbmQgZW5kIG1vbWVudC4gVGhleSBjYW4gYmUgY2hlY2tlZCB3aXRoIHN0YXJ0LmlzVmFsaWQoKSBhbmQgZW5kLmlzVmFsaWQoKS5cbiAgICAgKiBAcGFyYW0gc3RhcnRcbiAgICAgKiBAcGFyYW0gZW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IE1vbWVudCwgZW5kOiBNb21lbnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcblxuICAgICAgICBpZiAoZW5kLmlzQmVmb3JlKHN0YXJ0KSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEYXRlcyBzaGFsbCBiZSBhdCBtaWRuaWdodCBlZyAwMDowMFxuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmVuZC5zdGFydE9mKCdkYXknKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBkYXRlIHJhbmdlIHJlbGF0aXZlIHRvIHRvZGF5IGxpa2UgdGhpcyB3ZWVrL21vbnRoL3F1YXJ0ZXIveWVhci5cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj4gY29uc3RydWN0IGEgZGF0ZSByYW5nZSBjb250YWluaW5nIHRoZSBjdXJyZW50IG1vbnRoLjwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCB0aGlzTW9udGggPSBEYXRlUmFuZ2UuYnVpbGRSZWxhdGl2ZSgnbW9udGgnKTtcbiAgICAgKiBAcGFyYW0gcmFuZ2Ugb25lIG9mICd3ZWVrJywgJ21vbnRoJywgJ3F1YXJ0ZXInLCAneWVhcidcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYnVpbGRSZWxhdGl2ZShyYW5nZTogbW9tZW50LnVuaXRPZlRpbWUuU3RhcnRPZikge1xuICAgICAgICAvLyBUcmVhdCBhbGwgd2Vla3MgYXMgSVNPIDg2MDEgd2Vla3NcbiAgICAgICAgY29uc3QgdW5pdE9mVGltZSA9IHJhbmdlID09PSAnd2VlaycgPyAnaXNvV2VlaycgOiByYW5nZTtcblxuICAgICAgICByZXR1cm4gbmV3IERhdGVSYW5nZShcbiAgICAgICAgICAgIHdpbmRvdy5tb21lbnQoKS5zdGFydE9mKHVuaXRPZlRpbWUpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgd2luZG93Lm1vbWVudCgpLmVuZE9mKHVuaXRPZlRpbWUpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnZhbGlkIGRhdGUgcmFuZ2Ugd2l0aCBpbnZhbGlkIG1vbWVudGtzIG9iamVjdHMgKGh0dHBzOi8vbW9tZW50anNjb20ucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L21vbWVudC8wOS11dGlsaXRpZXMvMDItaW52YWxpZC8pLlxuICAgICAqIEZvciBleGFtcGxlIGlmIHRoZSBwYXJzaW5nIGhhcyBnb25lIHdyb25nLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBidWlsZEludmFsaWQoKTogRGF0ZVJhbmdlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlUmFuZ2Uod2luZG93Lm1vbWVudC5pbnZhbGlkKCksIHdpbmRvdy5tb21lbnQuaW52YWxpZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYm90aCBkYXRlcyBvZiB0aGUgZGF0ZSByYW5nZSBhcmUgdmFsaWQgaW4gdGVybXMgb2YgbW9tZW50anMuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBib3RoIGRhdGVzIGFyZSB2YWxpZFxuICAgICAqL1xuICAgIHB1YmxpYyBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5pc1ZhbGlkKCkgJiYgdGhpcy5lbmQuaXNWYWxpZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGRhdGUgcmFuZ2UgdG8gdGhlIHByZXZpb3VzIHdlZWsvbW9udGgvcXVhcnRlci95ZWFyLlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBkdXJhdGlvbiBpbiB0aGUgcGFyYW1ldGVycyBtYXRjaGVzIHRoZSByYW5nZSBzaXplLCBmb3IgZXhhbXBsZSBzdWJ0cmFjdGluZyBhIG1vbnRoIGZyb20gYSB3ZWVrIGxvbmcgcmFuZ2Ugd2FzIG5vdCB0ZXN0ZWQuXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIG9uZSBvZiAnd2VlaycvJ21vbnRoJy8ncXVhcnRlcicvJ3llYXInXG4gICAgICovXG4gICAgcHVibGljIG1vdmVUb1ByZXZpb3VzKGR1cmF0aW9uOiBtb21lbnQudW5pdE9mVGltZS5EdXJhdGlvbkNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbigxLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuc3RhcnQuc3VidHJhY3QoZGVsdGEpO1xuICAgICAgICB0aGlzLmVuZC5zdWJ0cmFjdChkZWx0YSk7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSAnbW9udGgnIHx8IGR1cmF0aW9uID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIC8vIE1vbnRoIGFuZCBxdWFydGVyIGR1cmF0aW9ucyBpbiBkYXlzIG1heSBkaWZmZXIgKDI4LzMwLzMxIGRheXMpLlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGFkanVzdCB0aGUgZW5kLlxuICAgICAgICAgICAgdGhpcy5lbmQgPSB0aGlzLmVuZC5lbmRPZihkdXJhdGlvbikuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBkYXRlIHJhbmdlIHRvIHRoZSBuZXh0IHdlZWsvbW9udGgvcXVhcnRlci95ZWFyLlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBkdXJhdGlvbiBpbiB0aGUgcGFyYW1ldGVycyBtYXRjaGVzIHRoZSByYW5nZSBzaXplLCBmb3IgZXhhbXBsZSBzdWJ0cmFjdGluZyBhIG1vbnRoIGZyb20gYSB3ZWVrIGxvbmcgcmFuZ2Ugd2FzIG5vdCB0ZXN0ZWQuXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIG9uZSBvZiAnd2VlaycvJ21vbnRoJy8ncXVhcnRlcicvJ3llYXInXG4gICAgICovXG4gICAgcHVibGljIG1vdmVUb05leHQoZHVyYXRpb246IG1vbWVudC51bml0T2ZUaW1lLkR1cmF0aW9uQ29uc3RydWN0b3IpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB3aW5kb3cubW9tZW50LmR1cmF0aW9uKDEsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zdGFydC5hZGQoZGVsdGEpO1xuICAgICAgICB0aGlzLmVuZC5hZGQoZGVsdGEpO1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gJ21vbnRoJyB8fCBkdXJhdGlvbiA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAvLyBNb250aCBhbmQgcXVhcnRlciBkdXJhdGlvbnMgaW4gZGF5cyBtYXkgZGlmZmVyICgyOC8zMC8zMSBkYXlzKS5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhZGp1c3QgdGhlIGVuZC5cbiAgICAgICAgICAgIHRoaXMuZW5kID0gdGhpcy5lbmQuZW5kT2YoZHVyYXRpb24pLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8vIEFiYnJldmlhdGlvbnMgZm9yIGVudGVyaW5nIGRhdGVzIHdpdGggY2hyb25vXG4vLyBNQUlOVEVOQU5DRSBOT1RFOlxuLy8gICAgICBJZiBhZGRpbmcgbW9yZSBhYmJyZXZpYXRpb25zLCBwbGVhc2UgcmV2aWV3IGRhdGVQbGFjZWhvbGRlciBpbiBzcmMvdWkvRWRpdFRhc2suc3ZlbHRlXG5jb25zdCBhYmJyZXZpYXRpb25zID0ge1xuICAgIHRkOiAndG9kYXknLFxuICAgIHRtOiAndG9tb3Jyb3cnLFxuICAgIHlkOiAneWVzdGVyZGF5JyxcbiAgICB0dzogJ3RoaXMgd2VlaycsXG4gICAgbnc6ICduZXh0IHdlZWsnLFxuICAgIHdlZWtlbmQ6ICdzYXQnLFxuICAgIHdlOiAnc2F0Jyxcbn07XG5cbi8qKlxuICogRXhwYW5kIGFueSByZWNvZ25pc2VkIGFiYnJldmlhdGlvbnMgZm9yIGRhdGVzLlxuICpcbiAqIEltcG9ydGFudDogdGhlIGFiYnJldmlhdGlvbiBpcyBvbmx5IGV4cGFuZGVkIGlmIGl0IGlzIGZvb2xvd2VkIGJ5IGEgc3BhY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsICd0ZCAnIGlzIGV4cGFuZGVkIHRvICd0b2RheSdcbiAqIEBwYXJhbSBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb0F1dG9jb21wbGV0ZShkYXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhhYmJyZXZpYXRpb25zKSkge1xuICAgICAgICBkYXRlID0gZGF0ZS5yZXBsYWNlKFJlZ0V4cChgXFxcXGIke2tleX1cXFxcc2AsICdpJyksIHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XHJcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cclxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XHJcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcclxuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xyXG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcclxuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xyXG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XHJcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XHJcbiAgICBkb25lID0gdHJ1ZTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XHJcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcclxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIF9fZXh0ZW5kcyxcclxuICAgIF9fYXNzaWduLFxyXG4gICAgX19yZXN0LFxyXG4gICAgX19kZWNvcmF0ZSxcclxuICAgIF9fcGFyYW0sXHJcbiAgICBfX21ldGFkYXRhLFxyXG4gICAgX19hd2FpdGVyLFxyXG4gICAgX19nZW5lcmF0b3IsXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcsXHJcbiAgICBfX2V4cG9ydFN0YXIsXHJcbiAgICBfX3ZhbHVlcyxcclxuICAgIF9fcmVhZCxcclxuICAgIF9fc3ByZWFkLFxyXG4gICAgX19zcHJlYWRBcnJheXMsXHJcbiAgICBfX3NwcmVhZEFycmF5LFxyXG4gICAgX19hd2FpdCxcclxuICAgIF9fYXN5bmNHZW5lcmF0b3IsXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yLFxyXG4gICAgX19hc3luY1ZhbHVlcyxcclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxyXG4gICAgX19pbXBvcnRTdGFyLFxyXG4gICAgX19pbXBvcnREZWZhdWx0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXHJcbn07XHJcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgZnVuY3Rpb24gY29tcGFyZUJ5RGF0ZShhOiBtb21lbnQuTW9tZW50IHwgbnVsbCwgYjogbW9tZW50Lk1vbWVudCB8IG51bGwpOiAtMSB8IDAgfCAxIHtcbiAgICBpZiAoYSAhPT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoYS5pc1ZhbGlkKCkgJiYgIWIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoIWEuaXNWYWxpZCgpICYmIGIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLmlzQWZ0ZXIoYikpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGEuaXNCZWZvcmUoYikpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuIiwgIi8vIGJlZ2luLXNuaXBwZXQ6IGRlY2xhcmUtTW9tZW50LXR5cGUtaW4tc3JjXG5pbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG4vLyBlbmQtc25pcHBldFxuXG5pbXBvcnQgeyBSUnVsZSB9IGZyb20gJ3JydWxlJztcbmltcG9ydCB7IGNvbXBhcmVCeURhdGUgfSBmcm9tICcuL2xpYi9EYXRlVG9vbHMnO1xuXG5leHBvcnQgY2xhc3MgUmVjdXJyZW5jZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBycnVsZTogUlJ1bGU7XG4gICAgcHJpdmF0ZSByZWFkb25seSBiYXNlT25Ub2RheTogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHJpdmF0ZSByZWFkb25seSBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZmVyZW5jZSBkYXRlIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGZ1dHVyZSBvY2N1cnJlbmNlcy5cbiAgICAgKlxuICAgICAqIEZ1dHVyZSBvY2N1cnJlbmNlcyB3aWxsIHJlY3VyIGJhc2VkIG9uIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAgICAgKiBUaGUgcmVmZXJlbmNlIGRhdGUgaXMgdGhlIGR1ZSBkYXRlLCBpZiBpdCBpcyBnaXZlbi5cbiAgICAgKiBPdGhlcndpc2UgdGhlIHNjaGVkdWxlZCBkYXRlLCBpZiBpdCBpcyBnaXZlbi4gQW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogUmVjdXJyZW5jZSBvZiBhbGwgZGF0ZXMgd2lsbCBiZSBrZXB0IHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAgICAgKiBGb3IgZXhhbXBsZTogaWYgdGhlIGR1ZSBkYXRlIGFuZCB0aGUgc3RhcnQgZGF0ZSBhcmUgZ2l2ZW4sIHRoZSBkdWUgZGF0ZVxuICAgICAqIGlzIHRoZSByZWZlcmVuY2UgZGF0ZS4gRnV0dXJlIG9jY3VycmVuY2VzIHdpbGwgaGF2ZSBhIHN0YXJ0IGRhdGUgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHJlbGF0aXZlIGRpc3RhbmNlIHRvIHRoZSBkdWUgZGF0ZSBhcyB0aGUgb3JpZ2luYWwgdGFzay4gRm9yIGV4YW1wbGVcbiAgICAgKiBcInN0YXJ0cyBvbmUgd2VlayBiZWZvcmUgaXQgaXMgZHVlXCIuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWZlcmVuY2VEYXRlOiBNb21lbnQgfCBudWxsO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBycnVsZSxcbiAgICAgICAgYmFzZU9uVG9kYXksXG4gICAgICAgIHJlZmVyZW5jZURhdGUsXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgZHVlRGF0ZSxcbiAgICB9OiB7XG4gICAgICAgIHJydWxlOiBSUnVsZTtcbiAgICAgICAgYmFzZU9uVG9kYXk6IGJvb2xlYW47XG4gICAgICAgIHJlZmVyZW5jZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMucnJ1bGUgPSBycnVsZTtcbiAgICAgICAgdGhpcy5iYXNlT25Ub2RheSA9IGJhc2VPblRvZGF5O1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURhdGUgPSByZWZlcmVuY2VEYXRlO1xuICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREYXRlID0gc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgdGhpcy5kdWVEYXRlID0gZHVlRGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZyb21UZXh0KHtcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGVUZXh0LFxuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgfToge1xuICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IHN0cmluZztcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0pOiBSZWN1cnJlbmNlIHwgbnVsbCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlY3VycmVuY2VSdWxlVGV4dC5tYXRjaCgvXihbYS16QS1aMC05LCAhXSs/KSggd2hlbiBkb25lKT8kL2kpO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXNvbGF0ZWRSdWxlVGV4dCA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VPblRvZGF5ID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFJSdWxlLnBhcnNlVGV4dChpc29sYXRlZFJ1bGVUZXh0KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gUGljayB0aGUgcmVmZXJlbmNlIGRhdGUgZm9yIHJlY3VycmVuY2UgYmFzZWQgb24gaW1wb3J0YW5jZS5cbiAgICAgICAgICAgICAgICAvLyBBc3N1bWluZyBkdWUgZGF0ZSBoYXMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgbGV0IHJlZmVyZW5jZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBtb21lbnQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICBpZiAoZHVlRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRlID0gd2luZG93Lm1vbWVudChkdWVEYXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVkdWxlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSA9IHdpbmRvdy5tb21lbnQoc2NoZWR1bGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRGF0ZSA9IHdpbmRvdy5tb21lbnQoc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJhc2VPblRvZGF5ICYmIHJlZmVyZW5jZURhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kdHN0YXJ0ID0gd2luZG93Lm1vbWVudChyZWZlcmVuY2VEYXRlKS5zdGFydE9mKCdkYXknKS51dGModHJ1ZSkudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kdHN0YXJ0ID0gd2luZG93Lm1vbWVudCgpLnN0YXJ0T2YoJ2RheScpLnV0Yyh0cnVlKS50b0RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBycnVsZSA9IG5ldyBSUnVsZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlY3VycmVuY2Uoe1xuICAgICAgICAgICAgICAgICAgICBycnVsZSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZU9uVG9kYXksXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZURhdGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gQ291bGQgbm90IHJlYWQgcmVjdXJyZW5jZSBydWxlLiBVc2VyIHBvc3NpYmx5IG5vdCBkb25lIHR5cGluZy5cbiAgICAgICAgICAgIC8vIFByaW50IGVycm9yIG1lc3NhZ2UsIGFzIGl0IGlzIHVzZWZ1bCBpZiBhIHRlc3QgZmlsZSBoYXMgbm90IHNldCB1cCB3aW5kb3cubW9tZW50XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1RleHQoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHRleHQgPSB0aGlzLnJydWxlLnRvVGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5iYXNlT25Ub2RheSkge1xuICAgICAgICAgICAgdGV4dCArPSAnIHdoZW4gZG9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlcyBvZiB0aGUgbmV4dCBvY2N1cnJlbmNlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0KCk6IHtcbiAgICAgICAgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICBkdWVEYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIH0gfCBudWxsIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFJlZmVyZW5jZURhdGUoKTtcblxuICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZGF0ZSBhbmRcbiAgICAgICAgICAgIC8vIHN0YXJ0L3NjaGVkdWxlZC9kdWUuXG4gICAgICAgICAgICBsZXQgc3RhcnREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkdWVEYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gT25seSBpZiBhIHJlZmVyZW5jZSBkYXRlIGlzIGdpdmVuLiBBIHJlZmVyZW5jZSBkYXRlIHdpbGwgZXhpc3QgaWYgYXRcbiAgICAgICAgICAgIC8vIGxlYXN0IG9uZSBvZiB0aGUgb3RoZXIgZGF0ZXMgaXMgc2V0LlxuICAgICAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbERpZmZlcmVuY2UgPSB3aW5kb3cubW9tZW50LmR1cmF0aW9uKHRoaXMuc3RhcnREYXRlLmRpZmYodGhpcy5yZWZlcmVuY2VEYXRlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBzbyB0aGF0IG9yaWdpbmFsIHdvbid0IGJlIG1hbmlwdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSB3aW5kb3cubW9tZW50KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyBkYXlzIHRvIGhhbmRsZSBjcm9zcyBkYXlsaWdodC1zYXZpbmdzLXRpbWUgcmVjdXJyZW5jZXMuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoTWF0aC5yb3VuZChvcmlnaW5hbERpZmZlcmVuY2UuYXNEYXlzKCkpLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2hlZHVsZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGlmZmVyZW5jZSA9IHdpbmRvdy5tb21lbnQuZHVyYXRpb24odGhpcy5zY2hlZHVsZWREYXRlLmRpZmYodGhpcy5yZWZlcmVuY2VEYXRlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBzbyB0aGF0IG9yaWdpbmFsIHdvbid0IGJlIG1hbmlwdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gd2luZG93Lm1vbWVudChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgZGF5cyB0byBoYW5kbGUgY3Jvc3MgZGF5bGlnaHQtc2F2aW5ncy10aW1lIHJlY3VycmVuY2VzLlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlLmFkZChNYXRoLnJvdW5kKG9yaWdpbmFsRGlmZmVyZW5jZS5hc0RheXMoKSksICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR1ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEaWZmZXJlbmNlID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbih0aGlzLmR1ZURhdGUuZGlmZih0aGlzLnJlZmVyZW5jZURhdGUpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uaW5nIHNvIHRoYXQgb3JpZ2luYWwgd29uJ3QgYmUgbWFuaXB1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGR1ZURhdGUgPSB3aW5kb3cubW9tZW50KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZGluZyBkYXlzIHRvIGhhbmRsZSBjcm9zcyBkYXlsaWdodC1zYXZpbmdzLXRpbWUgcmVjdXJyZW5jZXMuXG4gICAgICAgICAgICAgICAgICAgIGR1ZURhdGUuYWRkKE1hdGgucm91bmQob3JpZ2luYWxEaWZmZXJlbmNlLmFzRGF5cygpKSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaWRlbnRpY2FsVG8ob3RoZXI6IFJlY3VycmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZU9uVG9kYXkgIT09IG90aGVyLmJhc2VPblRvZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIERhdGUgZmllbGRzXG4gICAgICAgIGlmIChjb21wYXJlQnlEYXRlKHRoaXMuc3RhcnREYXRlLCBvdGhlci5zdGFydERhdGUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVCeURhdGUodGhpcy5zY2hlZHVsZWREYXRlLCBvdGhlci5zY2hlZHVsZWREYXRlKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlQnlEYXRlKHRoaXMuZHVlRGF0ZSwgb3RoZXIuZHVlRGF0ZSkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvVGV4dCgpID09PSBvdGhlci50b1RleHQoKTsgLy8gdGhpcyBhbHNvIGNoZWNrcyBiYXNlT25Ub2RheVxuICAgIH1cblxuICAgIHByaXZhdGUgbmV4dFJlZmVyZW5jZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VPblRvZGF5KSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV4dCBvY2N1cnJlbmNlIHNob3VsZCBoYXBwZW4gYmFzZWQgb2ZmIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICAgICAgICAvLyBiZWdpbi1zbmlwcGV0OiB1c2UtbW9tZW50LWluLXNyY1xuICAgICAgICAgICAgY29uc3QgdG9kYXkgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgICAgICAvLyBlbmQtc25pcHBldFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFJlZmVyZW5jZURhdGVGcm9tVG9kYXkodG9kYXkpLnRvRGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFJlZmVyZW5jZURhdGVGcm9tT3JpZ2luYWxSZWZlcmVuY2VEYXRlKCkudG9EYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG5leHRSZWZlcmVuY2VEYXRlRnJvbVRvZGF5KHRvZGF5OiBNb21lbnQpOiBNb21lbnQge1xuICAgICAgICBjb25zdCBydWxlQmFzZWRPblRvZGF5ID0gbmV3IFJSdWxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMucnJ1bGUub3JpZ09wdGlvbnMsXG4gICAgICAgICAgICBkdHN0YXJ0OiB0b2RheS5zdGFydE9mKCdkYXknKS51dGModHJ1ZSkudG9EYXRlKCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRBZnRlcih0b2RheS5lbmRPZignZGF5JyksIHJ1bGVCYXNlZE9uVG9kYXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbmV4dFJlZmVyZW5jZURhdGVGcm9tT3JpZ2luYWxSZWZlcmVuY2VEYXRlKCk6IE1vbWVudCB7XG4gICAgICAgIC8vIFRoZSBuZXh0IG9jY3VycmVuY2Ugc2hvdWxkIGhhcHBlbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGRhdGUgaWYgcG9zc2libGUuIE90aGVyd2lzZSwgYmFzZSBpdCBvbiB0b2RheSBpZiB3ZSBkbyBub3QgaGF2ZSBhXG4gICAgICAgIC8vIHJlZmVyZW5jZSBkYXRlLlxuICAgICAgICBjb25zdCBhZnRlciA9IHdpbmRvd1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNlIGRhdGUgY2FuIGJlIGB1bmRlZmluZWRgIHRvIG1lYW4gXCJ0b2RheVwiLlxuICAgICAgICAgICAgLy8gTW9tZW50IG9ubHkgYWNjZXB0cyBgdW5kZWZpbmVkYCwgbm90IGBudWxsYC5cbiAgICAgICAgICAgIC5tb21lbnQodGhpcy5yZWZlcmVuY2VEYXRlID8/IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5lbmRPZignZGF5Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEFmdGVyKGFmdGVyLCB0aGlzLnJydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXIgcmV0dXJucyB0aGUgbmV4dCBvY2N1cnJlbmNlJ3MgZGF0ZSBhZnRlciBgYWZ0ZXJgLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcnJ1bGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29tbW9uIGNhc2UgaXMgdGhhdCBgcnJ1bGUuYWZ0ZXJgIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhbmQgaXRcbiAgICAgKiBjYW4gYmUgdXNlZCBhcyBpcy5cbiAgICAgKlxuICAgICAqIEluIHRoZSBzcGVjaWFsIGNhc2VzIG9mIG1vbnRobHkgYW5kIHllYXJseSByZWN1cnJlbmNlcywgdGhlcmUgZXhpc3RzIGFuXG4gICAgICogZWRnZSBjYXNlIHdoZXJlIGFuIG9jY3VycmVuY2UgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZiBtb250aHMgb3IgeWVhcnNcbiAgICAgKiBpcyBub3QgcG9zc2libGUuIEZvciBleGFtcGxlOiBBIHRhc2sgaXMgZHVlIG9uIDIwMjItMDEtMzEgYW5kIGhhcyBhXG4gICAgICogcmVjdXJyZW5jZSBvZiBgZXZlcnkgbW9udGhgLiBXaGVuIG1hcmtpbmcgdGhlIHRhc2sgYXMgZG9uZSwgdGhlIG5leHRcbiAgICAgKiBvY2N1cnJlbmNlIHdpbGwgaGFwcGVuIG9uIDIwMjItMDMtMzEuIFRoZSByZWFzb24gYmVpbmcgdGhhdCBGZWJydWFyeVxuICAgICAqIGRvZXMgbm90IGhhdmUgMzEgZGF5cywgeWV0IFJSdWxlIHNldHMgYGJ5bW9udGhkYXlgIHRvIGAzMWAgZm9yIGxhY2sgb2ZcbiAgICAgKiBoYXZpbmcgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUuXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBmaXggdGhpcywgYGFmdGVyYCB3aWxsIG1vdmUgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LiBFYWNoXG4gICAgICogZGF5LCB0aGUgbmV4dCBvY2N1cnJlbmNlIGlzIGNoZWNrZWQgdG8gYmUgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZlxuICAgICAqIG1vbnRocyBvciB5ZWFycy4gQnkgbW92aW5nIGBhZnRlcmAgaW50byB0aGUgcGFzdCBkYXkgYnkgZGF5LCBpdCB3aWxsXG4gICAgICogZXZlbnR1YWxseSBjYWxjdWxhdGUgdGhlIG5leHQgb2NjdXJyZW5jZSBiYXNlZCBvbiBgMjAyMi0wMS0yOGAsIGVuZGluZyB1cFxuICAgICAqIGluIEZlYnJ1YXJ5IGFzIHRoZSB1c2VyIHdvdWxkIGV4cGVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5leHRBZnRlcihhZnRlcjogTW9tZW50LCBycnVsZTogUlJ1bGUpOiBNb21lbnQge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgdGltZXpvbmUsIGFzIHJydWxlIGRvZXMgbm90IHJlZ2FyZCB0aW1lem9uZXMgYW5kIGFsd2F5c1xuICAgICAgICAvLyBjYWxjdWxhdGVzIGluIFVUQy5cbiAgICAgICAgLy8gVGhlIHRpbWV6b25lIGlzIGFkZGVkIGFnYWluIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5leHQgZGF0ZS5cbiAgICAgICAgYWZ0ZXIudXRjKHRydWUpO1xuICAgICAgICBsZXQgbmV4dCA9IHdpbmRvdy5tb21lbnQocnJ1bGUuYWZ0ZXIoYWZ0ZXIudG9EYXRlKCkpKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbW9udGhseSByZWN1cnJlbmNlLCB0cmVhdCBpdCBzcGVjaWFsLlxuICAgICAgICBjb25zdCBhc1RleHQgPSB0aGlzLnRvVGV4dCgpO1xuICAgICAgICBjb25zdCBtb250aE1hdGNoID0gYXNUZXh0Lm1hdGNoKC9ldmVyeSggXFxkKyk/IG1vbnRoKHMpPyguKik/Lyk7XG4gICAgICAgIGlmIChtb250aE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyAuLi4gdW5sZXNzIHRoZSBydWxlIGZpeGVzIHRoZSBkYXRlLCBzdWNoIGFzICdldmVyeSBtb250aCBvbiB0aGUgMzFzdCdcbiAgICAgICAgICAgIGlmICghYXNUZXh0LmluY2x1ZGVzKCcgb24gJykpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gUmVjdXJyZW5jZS5uZXh0QWZ0ZXJNb250aHMoYWZ0ZXIsIG5leHQsIHJydWxlLCBtb250aE1hdGNoWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB5ZWFybHkgcmVjdXJyZW5jZSwgdHJlYXQgaXQgc3BlY2lhbC5cbiAgICAgICAgY29uc3QgeWVhck1hdGNoID0gYXNUZXh0Lm1hdGNoKC9ldmVyeSggXFxkKyk/IHllYXIocyk/KC4qKT8vKTtcbiAgICAgICAgaWYgKHllYXJNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UubmV4dEFmdGVyWWVhcnMoYWZ0ZXIsIG5leHQsIHJydWxlLCB5ZWFyTWF0Y2hbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBhZGQgdGhlIHRpbWV6b25lIGFnYWluIHRoYXQgd2UgcmVtb3ZlZCBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgbWV0aG9kLlxuICAgICAgICByZXR1cm4gUmVjdXJyZW5jZS5hZGRUaW1lem9uZShuZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuZXh0QWZ0ZXJNb250aHMgY2FsY3VsYXRlcyB0aGUgbmV4dCBkYXRlIGFmdGVyIGBza2lwcGluZ01vbnRoc2AgbW9udGhzLlxuICAgICAqXG4gICAgICogYHNraXBwaW5nTW9udGhzYCBkZWZhdWx0cyB0byBgMWAgaWYgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIG5leHRBZnRlck1vbnRocyhcbiAgICAgICAgYWZ0ZXI6IE1vbWVudCxcbiAgICAgICAgbmV4dDogTW9tZW50LFxuICAgICAgICBycnVsZTogUlJ1bGUsXG4gICAgICAgIHNraXBwaW5nTW9udGhzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgKTogTW9tZW50IHtcbiAgICAgICAgLy8gUGFyc2UgYHNraXBwaW5nTW9udGhzYCwgaWYgaXQgZXhpc3RzLlxuICAgICAgICBsZXQgcGFyc2VkU2tpcHBpbmdNb250aHM6IG51bWJlciA9IDE7XG4gICAgICAgIGlmIChza2lwcGluZ01vbnRocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJzZWRTa2lwcGluZ01vbnRocyA9IE51bWJlci5wYXJzZUludChza2lwcGluZ01vbnRocy50cmltKCksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoaWxlIHdlIHNraXAgdGhlIHdyb25nIG51bWJlciBvZiBtb250aHMsIG1vdmUgYGFmdGVyYCBvbmUgZGF5IGludG8gdGhlIHBhc3QuXG4gICAgICAgIHdoaWxlIChSZWN1cnJlbmNlLmlzU2tpcHBpbmdUb29NYW55TW9udGhzKGFmdGVyLCBuZXh0LCBwYXJzZWRTa2lwcGluZ01vbnRocykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgYWx0ZXJzIGBhZnRlcmAgdG8gYmUgb25lIGRheSBlYXJsaWVyLlxuICAgICAgICAgICAgLy8gVGhlbiByZXR1cm5zIGBuZXh0YCBiYXNlZCBvbiB0aGF0LlxuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UuZnJvbU9uZURheUVhcmxpZXIoYWZ0ZXIsIHJydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlzU2tpcHBpbmdUb29NYW55TW9udGhzIHJldHVybnMgdHJ1ZSBpZiBgbmV4dGAgaXMgbW9yZSB0aGFuIGBza2lwcGluZ01vbnRoc2AgbW9udGhzIGFmdGVyIGBhZnRlcmAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNTa2lwcGluZ1Rvb01hbnlNb250aHMoYWZ0ZXI6IE1vbWVudCwgbmV4dDogTW9tZW50LCBza2lwcGluZ01vbnRoczogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkaWZmTW9udGhzID0gbmV4dC5tb250aCgpIC0gYWZ0ZXIubW9udGgoKTtcblxuICAgICAgICAvLyBNYXliZSBzb21lIHllYXJzIGhhdmUgcGFzc2VkP1xuICAgICAgICBjb25zdCBkaWZmWWVhcnMgPSBuZXh0LnllYXIoKSAtIGFmdGVyLnllYXIoKTtcbiAgICAgICAgZGlmZk1vbnRocyArPSBkaWZmWWVhcnMgKiAxMjtcblxuICAgICAgICByZXR1cm4gZGlmZk1vbnRocyA+IHNraXBwaW5nTW9udGhzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5leHRBZnRlclllYXJzIGNhbGN1bGF0ZXMgdGhlIG5leHQgZGF0ZSBhZnRlciBgc2tpcHBpbmdZZWFyc2AgeWVhcnMuXG4gICAgICpcbiAgICAgKiBgc2tpcHBpbmdZZWFyc2AgZGVmYXVsdHMgdG8gYDFgIGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBuZXh0QWZ0ZXJZZWFycyhcbiAgICAgICAgYWZ0ZXI6IE1vbWVudCxcbiAgICAgICAgbmV4dDogTW9tZW50LFxuICAgICAgICBycnVsZTogUlJ1bGUsXG4gICAgICAgIHNraXBwaW5nWWVhcnM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICApOiBNb21lbnQge1xuICAgICAgICAvLyBQYXJzZSBgc2tpcHBpbmdZZWFyc2AsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgbGV0IHBhcnNlZFNraXBwaW5nWWVhcnM6IG51bWJlciA9IDE7XG4gICAgICAgIGlmIChza2lwcGluZ1llYXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnNlZFNraXBwaW5nWWVhcnMgPSBOdW1iZXIucGFyc2VJbnQoc2tpcHBpbmdZZWFycy50cmltKCksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoaWxlIHdlIHNraXAgdGhlIHdyb25nIG51bWJlciBvZiB5ZWFycywgbW92ZSBgYWZ0ZXJgIG9uZSBkYXkgaW50byB0aGUgcGFzdC5cbiAgICAgICAgd2hpbGUgKFJlY3VycmVuY2UuaXNTa2lwcGluZ1Rvb01hbnlZZWFycyhhZnRlciwgbmV4dCwgcGFyc2VkU2tpcHBpbmdZZWFycykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgYWx0ZXJzIGBhZnRlcmAgdG8gYmUgb25lIGRheSBlYXJsaWVyLlxuICAgICAgICAgICAgLy8gVGhlbiByZXR1cm5zIGBuZXh0YCBiYXNlZCBvbiB0aGF0LlxuICAgICAgICAgICAgbmV4dCA9IFJlY3VycmVuY2UuZnJvbU9uZURheUVhcmxpZXIoYWZ0ZXIsIHJydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlzU2tpcHBpbmdUb29NYW55WWVhcnMgcmV0dXJucyB0cnVlIGlmIGBuZXh0YCBpcyBtb3JlIHRoYW4gYHNraXBwaW5nWWVhcnNgIHllYXJzIGFmdGVyIGBhZnRlcmAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNTa2lwcGluZ1Rvb01hbnlZZWFycyhhZnRlcjogTW9tZW50LCBuZXh0OiBNb21lbnQsIHNraXBwaW5nWWVhcnM6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBkaWZmID0gbmV4dC55ZWFyKCkgLSBhZnRlci55ZWFyKCk7XG5cbiAgICAgICAgcmV0dXJuIGRpZmYgPiBza2lwcGluZ1llYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZyb21PbmVEYXlFYXJsaWVyIHJldHVybnMgdGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlciBtb3ZpbmcgYGFmdGVyYCBvbmUgZGF5IGludG8gdGhlIHBhc3QuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCBtYW5pcHVsYXRlcyB0aGUgZ2l2ZW4gaW5zdGFuY2Ugb2YgYGFmdGVyYC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBmcm9tT25lRGF5RWFybGllcihhZnRlcjogTW9tZW50LCBycnVsZTogUlJ1bGUpOiBNb21lbnQge1xuICAgICAgICBhZnRlci5zdWJ0cmFjdCgxLCAnZGF5cycpLmVuZE9mKCdkYXknKTtcblxuICAgICAgICBjb25zdCBvcHRpb25zID0gcnJ1bGUub3JpZ09wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMuZHRzdGFydCA9IGFmdGVyLnN0YXJ0T2YoJ2RheScpLnRvRGF0ZSgpO1xuICAgICAgICBycnVsZSA9IG5ldyBSUnVsZShvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gd2luZG93Lm1vbWVudChycnVsZS5hZnRlcihhZnRlci50b0RhdGUoKSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGFkZFRpbWV6b25lKGRhdGU6IE1vbWVudCk6IE1vbWVudCB7XG4gICAgICAgIGNvbnN0IGxvY2FsVGltZVpvbmUgPSB3aW5kb3cubW9tZW50LnV0YyhkYXRlKS5sb2NhbCh0cnVlKTtcblxuICAgICAgICByZXR1cm4gbG9jYWxUaW1lWm9uZS5zdGFydE9mKCdkYXknKTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgYXMgcGFydCBvZiBhIFJlZ0V4cCBsaXRlcmFsbHkuXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucyNlc2NhcGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHM6IHN0cmluZykge1xuICAgIC8vIE5PVEU6ID0gaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXD13b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vIE5PVEU6ICEgaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXCF3b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vIE5PVEU6IDogaXMgbm90IGVzY2FwZWQsIGFzIGRvaW5nIHNvIGdpdmVzIGVycm9yOlxuICAgIC8vICAgICAgICAgSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oXnxcXHMpaGVsbG9cXDp3b3JsZCgkfFxccykvOiBJbnZhbGlkIGVzY2FwZVxuICAgIC8vXG4gICAgLy8gRXhwbGFuYXRpb24gZnJvbSBAQW5uYUtvcm5mZWxkU2ltcHNvbiBpbjpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXNtNy9vYnNpZGlhbi10YXNrcy9wdWxsLzE4I2lzc3VlY29tbWVudC0xMTk2MTE1NDA3XG4gICAgLy8gRnJvbSB3aGF0IEkgY2FuIHRlbGwsIHRoZSB0aHJlZSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSB0aGUgb3JpZ2luYWwgcmVnZXggLSA6ICEgPVxuICAgIC8vIGFyZSBhbGwgb25seSBjb25zaWRlcmVkIHRvIGhhdmUgc3BlY2lhbCBtZWFuaW5ncyBpZiB0aGV5IGRpcmVjdGx5IGZvbGxvd1xuICAgIC8vIGEgPyAoYWxsIDMpIG9yIGEgPzwgKCEgYW5kID0pLlxuICAgIC8vIFNvIHRoZW9yZXRpY2FsbHkgaWYgdGhlID8gYXJlIGFsbCBlc2NhcGVkLCB0aG9zZSB0aHJlZSBjaGFyYWN0ZXJzIGRvIG5vdCBoYXZlIHRvIGJlLlxuICAgIHJldHVybiBzLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxdL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG4iLCAiaW1wb3J0ICogYXMgUmVnRXhwVG9vbHMgZnJvbSAnLi4vbGliL1JlZ0V4cFRvb2xzJztcblxuLyoqXG4gKiBHbG9iYWxGaWx0ZXIgaGFzIGl0cyBvd24gZGF0YSwgaW5kZXBlbmRlbnQgb2Yge0BsaW5rIFNldHRpbmdzLmdsb2JhbEZpbHRlcn0gdmFsdWUgaW4ge0BsaW5rIFNldHRpbmdzfS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL0dldHRpbmcrU3RhcnRlZC9HbG9iYWwrRmlsdGVyXG4gKlxuICogTGltaXRhdGlvbnM6XG4gKiAtIEFsbCBtZXRob2RzIGFyZSBzdGF0aWMsIHNvIGl0IGlzIGEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSBzdGF0aWMgdGhpbmdzXG4gKiAgICAgLSBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIHtAbGluayBHbG9iYWxRdWVyeX0gd2hhdCBoYXMganVzdCB0aGUgb25lIHN0YXRpYyBtZXRob2QsIHtAbGluayBHbG9iYWxRdWVyeS5nZXRJbnN0YW5jZX0uXG4gKiAgICAgLSBUaGVzZSBzdGF0aWMgbWV0aG9kcyB3aWxsIGJlIG1hZGUgbm9uLXN0YXRpYyBpbiBhIGZ1dHVyZSBjaGFuZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iYWxGaWx0ZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBHbG9iYWxGaWx0ZXI7XG5cbiAgICBzdGF0aWMgZW1wdHkgPSAnJztcbiAgICBwcml2YXRlIF9nbG9iYWxGaWx0ZXIgPSAnJztcbiAgICBwcml2YXRlIF9yZW1vdmVHbG9iYWxGaWx0ZXIgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgc2luZ2xlIGdsb2JhbCBpbnN0YW5jZSBvZiBHbG9iYWxGaWx0ZXIuXG4gICAgICogVGhpcyBzaG91bGQgZXZlbnR1YWxseSBvbmx5IGJlIHVzZWQgaW4gdGhlIHBsdWdpbiBjb2RlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR2xvYmFsRmlsdGVyIHtcbiAgICAgICAgaWYgKCFHbG9iYWxGaWx0ZXIuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIEdsb2JhbEZpbHRlci5pbnN0YW5jZSA9IG5ldyBHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBHbG9iYWxGaWx0ZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsRmlsdGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9nbG9iYWxGaWx0ZXIgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc2V0KEdsb2JhbEZpbHRlci5lbXB0eSk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgpID09PSBHbG9iYWxGaWx0ZXIuZW1wdHk7XG4gICAgfVxuXG4gICAgcHVibGljIGVxdWFscyh0YWc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoKSA9PT0gdGFnO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbmNsdWRlZEluKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsRmlsdGVyID0gdGhpcy5nZXQoKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLmluY2x1ZGVzKGdsb2JhbEZpbHRlcik7XG4gICAgfVxuXG4gICAgcHVibGljIHByZXBlbmRUbyhkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCkgKyAnICcgKyBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlQXNXb3JkRnJvbURlcGVuZGluZ09uU2V0dGluZ3MoZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUdsb2JhbEZpbHRlciA9IHRoaXMuZ2V0UmVtb3ZlR2xvYmFsRmlsdGVyKCk7XG4gICAgICAgIGlmIChyZW1vdmVHbG9iYWxGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFzV29yZEZyb20oZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgc2V0UmVtb3ZlR2xvYmFsRmlsdGVyXG4gICAgICovXG4gICAgcHVibGljIGdldFJlbW92ZUdsb2JhbEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUdsb2JhbEZpbHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGdldFJlbW92ZUdsb2JhbEZpbHRlclxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRSZW1vdmVHbG9iYWxGaWx0ZXIocmVtb3ZlR2xvYmFsRmlsdGVyOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUdsb2JhbEZpbHRlciA9IHJlbW92ZUdsb2JhbEZpbHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGZvciB0aGUgcHVycG9zZSBvZiByZW1vdmluZyBpdCBmcm9tIHRoZSBkZXNjcmlwdGlvbiwgYnV0IGRvIHNvIG9ubHlcbiAgICAgKiBpZiBpdCBpcyBhIHNlcGFyYXRlIHdvcmQgKHByZWNlZGluZyB0aGUgYmVnaW5uaW5nIG9mIGxpbmUgb3IgYSBzcGFjZSBhbmQgZm9sbG93ZWQgYnkgdGhlIGVuZCBvZiBsaW5lXG4gICAgICogb3IgYSBzcGFjZSksIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjdXQtb2ZmIG5lc3RlZCB0YWdzIGxpa2UgI3Rhc2svc3VidGFnLlxuICAgICAqIElmIHRoZSBnbG9iYWwgZmlsdGVyIGV4aXN0cyBhcyBwYXJ0IG9mIGEgbmVzdGVkIHRhZywgd2Uga2VlcCBpdCB1bnRvdWNoZWQuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUFzV29yZEZyb20oZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBnbG9iYWwgZmlsdGVyIChhZnRlciBlc2NhcGluZyBpdCkgb25seSB3aGVuIGl0J3MgYSBjb21wbGV0ZSB3b3JkXG4gICAgICAgIGNvbnN0IHRoZVJlZ0V4cCA9IFJlZ0V4cCgnKF58XFxcXHMpJyArIFJlZ0V4cFRvb2xzLmVzY2FwZVJlZ0V4cCh0aGlzLmdldCgpKSArICcoJHxcXFxccyknLCAndWcnKTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRpb24uc2VhcmNoKHRoZVJlZ0V4cCkgPiAtMSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKHRoZVJlZ0V4cCwgJyQxJDInKS5yZXBsYWNlKCcgICcsICcgJykudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVBc1N1YnN0cmluZ0Zyb20oZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGdsb2JhbEZpbHRlciA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5yZXBsYWNlKGdsb2JhbEZpbHRlciwgJycpLnRyaW0oKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTZXR0aW5ncyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBEYXRlUGFyc2VyIH0gZnJvbSAnLi4vUXVlcnkvRGF0ZVBhcnNlcic7XG5pbXBvcnQgeyBkb0F1dG9jb21wbGV0ZSB9IGZyb20gJy4uL0RhdGVBYmJyZXZpYXRpb25zJztcbmltcG9ydCB7IFJlY3VycmVuY2UgfSBmcm9tICcuLi9SZWN1cnJlbmNlJztcbmltcG9ydCB0eXBlIHsgRGVmYXVsdFRhc2tTZXJpYWxpemVyU3ltYm9scyB9IGZyb20gJy4uL1Rhc2tTZXJpYWxpemVyL0RlZmF1bHRUYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgeyBUYXNrLCBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgU3VnZ2VzdEluZm8sIFN1Z2dlc3Rpb25CdWlsZGVyIH0gZnJvbSAnLic7XG5cbi8qKlxuICogUmVjb21tZW5kZWQgZGVmYXVsdCB2YWx1ZSB0byBwYXNzIGluIHRvIHtAbGluayBtYWtlRGVmYXVsdFN1Z2dlc3Rpb25CdWlsZGVyfSBtYXhHZW5lcmljU3VnZ2VzdGlvbnMgcGFyYW1ldGVyXG4gKiBmb3IgcHJvZHVjdGlvbiBjb2RlLlxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfR0VORVJJQ19TVUdHRVNUSU9OUyA9IDU7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRGVmYXVsdFN1Z2dlc3Rpb25CdWlsZGVyKFxuICAgIHN5bWJvbHM6IERlZmF1bHRUYXNrU2VyaWFsaXplclN5bWJvbHMsXG4gICAgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zOiBudW1iZXIgLyoqIFNlZSB7QGxpbmsgREVGQVVMVF9NQVhfR0VORVJJQ19TVUdHRVNUSU9OU30gKi8sXG4pOiBTdWdnZXN0aW9uQnVpbGRlciB7XG4gICAgY29uc3QgZGF0ZVByZWZpeFJlZ2V4ID0gW3N5bWJvbHMuc3RhcnREYXRlU3ltYm9sLCBzeW1ib2xzLnNjaGVkdWxlZERhdGVTeW1ib2wsIHN5bWJvbHMuZHVlRGF0ZVN5bWJvbF0uam9pbignfCcpO1xuICAgIC8qXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiBzdWdnZXN0aW9ucywgZWl0aGVyIGdlbmVyaWMgb3IgbW9yZSBmaW5lLWdyYWluZWQgdG8gdGhlIHdvcmRzIGF0IHRoZSBjdXJzb3IuXG4gICAgICovXG4gICAgcmV0dXJuIChsaW5lOiBzdHJpbmcsIGN1cnNvclBvczogbnVtYmVyLCBzZXR0aW5nczogU2V0dGluZ3MpOiBTdWdnZXN0SW5mb1tdID0+IHtcbiAgICAgICAgbGV0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID0gW107XG5cbiAgICAgICAgLy8gU3RlcCAxOiBhZGQgZGF0ZSBzdWdnZXN0aW9ucyBpZiByZWxldmFudFxuICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChcbiAgICAgICAgICAgIGFkZERhdGVzU3VnZ2VzdGlvbnMobGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncywgZGF0ZVByZWZpeFJlZ2V4LCBtYXhHZW5lcmljU3VnZ2VzdGlvbnMpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0ZXAgMjogYWRkIHJlY3VycmVuY2Ugc3VnZ2VzdGlvbnMgaWYgcmVsZXZhbnRcbiAgICAgICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucy5jb25jYXQoYWRkUmVjdXJyZW5jZVN1Z2dlc3Rpb25zKGxpbmUsIGN1cnNvclBvcywgc2V0dGluZ3MsIHN5bWJvbHMucmVjdXJyZW5jZVN5bWJvbCkpO1xuXG4gICAgICAgIC8vIFN0ZXAgMzogYWRkIHRhc2sgcHJvcGVydHkgc3VnZ2VzdGlvbnMgKCdkdWUnLCAncmVjdXJyZW5jZScgZXRjKVxuICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zLmNvbmNhdChhZGRUYXNrUHJvcGVydHlTdWdnZXN0aW9ucyhsaW5lLCBjdXJzb3JQb3MsIHNldHRpbmdzLCBzeW1ib2xzKSk7XG5cbiAgICAgICAgLy8gVW5sZXNzIHdlIGhhdmUgYSBzdWdnZXN0aW9uIHRoYXQgaXMgYSBtYXRjaCBmb3Igc29tZXRoaW5nIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0eXBpbmcsIGFkZFxuICAgICAgICAvLyBhbiAnRW50ZXInIGVudHJ5IGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1lbnUsIHNvIGFuIEVudGVyIHByZXNzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCBsaW5lXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGluc2VydCBhIHN1Z2dlc3Rpb25cbiAgICAgICAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCA+IDAgJiYgIXN1Z2dlc3Rpb25zLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZS5zdWdnZXN0aW9uVHlwZSA9PT0gJ21hdGNoJykpIHtcbiAgICAgICAgICAgIC8vIE5vIGFjdHVhbCBtYXRjaCwgb25seSBkZWZhdWx0IG9uZXNcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnZW1wdHknLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiAnXHUyM0NFJyxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiAnXFxuJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWl0aGVyIHdheSwgYWZ0ZXIgYWxsIHRoZSBhZ2dyZWdhdGlvbnMgYWJvdmUsIG5ldmVyIHN1Z2dlc3QgbW9yZSB0aGFuIHRoZSBtYXggaXRlbXNcbiAgICAgICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucy5zbGljZSgwLCBzZXR0aW5ncy5hdXRvU3VnZ2VzdE1heEl0ZW1zKTtcblxuICAgICAgICByZXR1cm4gc3VnZ2VzdGlvbnM7XG4gICAgfTtcbn1cblxuLypcbiAqIEdldCBzdWdnZXN0aW9ucyBmb3IgZ2VuZXJpYyB0YXNrIGNvbXBvbmVudHMsIGUuZy4gYSBwcmlvcml0eSBvciBhICdkdWUnIHN5bWJvbFxuICovXG5mdW5jdGlvbiBhZGRUYXNrUHJvcGVydHlTdWdnZXN0aW9ucyhcbiAgICBsaW5lOiBzdHJpbmcsXG4gICAgY3Vyc29yUG9zOiBudW1iZXIsXG4gICAgX3NldHRpbmdzOiBTZXR0aW5ncyxcbiAgICBzeW1ib2xzOiBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzLFxuKTogU3VnZ2VzdEluZm9bXSB7XG4gICAgY29uc3QgaGFzUHJpb3JpdHkgPSAobGluZTogc3RyaW5nKSA9PlxuICAgICAgICBPYmplY3QudmFsdWVzKHN5bWJvbHMucHJpb3JpdHlTeW1ib2xzKS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMCAmJiBsaW5lLmluY2x1ZGVzKHZhbHVlKSk7XG5cbiAgICBjb25zdCBnZW5lcmljU3VnZ2VzdGlvbnM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcblxuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLmR1ZURhdGVTeW1ib2wpKVxuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5kdWVEYXRlU3ltYm9sfSBkdWUgZGF0ZWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLmR1ZURhdGVTeW1ib2x9IGAsXG4gICAgICAgIH0pO1xuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLnN0YXJ0RGF0ZVN5bWJvbCkpXG4gICAgICAgIGdlbmVyaWNTdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtzeW1ib2xzLnN0YXJ0RGF0ZVN5bWJvbH0gc3RhcnQgZGF0ZWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLnN0YXJ0RGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFsaW5lLmluY2x1ZGVzKHN5bWJvbHMuc2NoZWR1bGVkRGF0ZVN5bWJvbCkpXG4gICAgICAgIGdlbmVyaWNTdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtzeW1ib2xzLnNjaGVkdWxlZERhdGVTeW1ib2x9IHNjaGVkdWxlZCBkYXRlYCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMuc2NoZWR1bGVkRGF0ZVN5bWJvbH0gYCxcbiAgICAgICAgfSk7XG4gICAgaWYgKCFoYXNQcmlvcml0eShsaW5lKSkge1xuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5wcmlvcml0eVN5bWJvbHMuSGlnaH0gaGlnaCBwcmlvcml0eWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLnByaW9yaXR5U3ltYm9scy5IaWdofSBgLFxuICAgICAgICB9KTtcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMucHJpb3JpdHlTeW1ib2xzLk1lZGl1bX0gbWVkaXVtIHByaW9yaXR5YCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMucHJpb3JpdHlTeW1ib2xzLk1lZGl1bX0gYCxcbiAgICAgICAgfSk7XG4gICAgICAgIGdlbmVyaWNTdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtzeW1ib2xzLnByaW9yaXR5U3ltYm9scy5Mb3d9IGxvdyBwcmlvcml0eWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLnByaW9yaXR5U3ltYm9scy5Mb3d9IGAsXG4gICAgICAgIH0pO1xuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5wcmlvcml0eVN5bWJvbHMuSGlnaGVzdH0gaGlnaGVzdCBwcmlvcml0eWAsXG4gICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtzeW1ib2xzLnByaW9yaXR5U3ltYm9scy5IaWdoZXN0fSBgLFxuICAgICAgICB9KTtcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke3N5bWJvbHMucHJpb3JpdHlTeW1ib2xzLkxvd2VzdH0gbG93ZXN0IHByaW9yaXR5YCxcbiAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke3N5bWJvbHMucHJpb3JpdHlTeW1ib2xzLkxvd2VzdH0gYCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGluZS5pbmNsdWRlcyhzeW1ib2xzLnJlY3VycmVuY2VTeW1ib2wpKVxuICAgICAgICBnZW5lcmljU3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5yZWN1cnJlbmNlU3ltYm9sfSByZWN1cnJpbmcgKHJlcGVhdClgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7c3ltYm9scy5yZWN1cnJlbmNlU3ltYm9sfSBgLFxuICAgICAgICB9KTtcbiAgICBpZiAoIWxpbmUuaW5jbHVkZXMoc3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IERhdGVQYXJzZXIucGFyc2VEYXRlKCd0b2RheScsIHRydWUpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gcGFyc2VkRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KTtcbiAgICAgICAgZ2VuZXJpY1N1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGlzIHRvIG1hdGNoIHdoZW4gdGhlIHVzZXIgdHlwZXMgXCJ0b2RheVwiXG4gICAgICAgICAgICB0ZXh0VG9NYXRjaDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gY3JlYXRlZGAsXG4gICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gY3JlYXRlZCB0b2RheSAoJHtmb3JtYXR0ZWREYXRlfSlgLFxuICAgICAgICAgICAgYXBwZW5kVGV4dDogYCR7c3ltYm9scy5jcmVhdGVkRGF0ZVN5bWJvbH0gJHtmb3JtYXR0ZWREYXRlfSBgLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSBub3cgZmlsdGVyIHRoZSBnZW5lcmFsIHN1Z2dlc3Rpb25zIGFjY29yZGluZyB0byB0aGUgd29yZCBhdCB0aGUgY3Vyc29yLiBJZiB0aGVyZSdzXG4gICAgLy8gc29tZXRoaW5nIHRvIG1hdGNoLCB3ZSBmaWx0ZXIgdGhlIHN1Z2dlc3Rpb25zIGFjY29yZGluZ2x5LCBzbyB0aGUgdXNlciBjYW4gZ2V0IG1vcmUgc3BlY2lmaWNcbiAgICAvLyByZXN1bHRzIGFjY29yZGluZyB0byB3aGF0IHNoZSdzIHR5cGluZy5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGdvb2QgbWF0Y2gsIHByZXNlbnQgdGhlIHN1Z2dlc3Rpb25zIGFzIHRoZXkgYXJlXG4gICAgY29uc3Qgd29yZE1hdGNoID0gbWF0Y2hCeVBvc2l0aW9uKGxpbmUsIC8oW2EtekEtWidfLV0qKS9nLCBjdXJzb3JQb3MpO1xuICAgIGNvbnN0IG1hdGNoaW5nU3VnZ2VzdGlvbnM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcbiAgICBpZiAod29yZE1hdGNoICYmIHdvcmRNYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmRVbmRlckN1cnNvciA9IHdvcmRNYXRjaFswXTtcbiAgICAgICAgaWYgKHdvcmRVbmRlckN1cnNvci5sZW5ndGggPj0gTWF0aC5tYXgoMSwgX3NldHRpbmdzLmF1dG9TdWdnZXN0TWluTWF0Y2gpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN1Z2dlc3Rpb25zID0gZ2VuZXJpY1N1Z2dlc3Rpb25zLmZpbHRlcigoc3VnZ2VzdEluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0VG9NYXRjaCA9IHN1Z2dlc3RJbmZvLnRleHRUb01hdGNoIHx8IHN1Z2dlc3RJbmZvLmRpc3BsYXlUZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0VG9NYXRjaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHdvcmRVbmRlckN1cnNvci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXJlZCBvZiBmaWx0ZXJlZFN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBmaWx0ZXJlZC5kaXNwbGF5VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogZmlsdGVyZWQuYXBwZW5kVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QXQ6IHdvcmRNYXRjaC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U2tpcDogd29yZFVuZGVyQ3Vyc29yLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGF0J3Mgd2hlcmUgd2UncmUgYWRkaW5nIGFsbCB0aGUgc3VnZ2VzdGlvbnMgaW4gY2FzZSB0aGVyZSdzIG5vdGhpbmcgc3BlY2lmaWMgdG8gbWF0Y2hcbiAgICAvLyAoYW5kIHdlJ3JlIGFsbG93ZWQgYnkgdGhlIHNldHRpbmdzIHRvIGJyaW5nIGJhY2sgYSB6ZXJvLXNpemVkIG1hdGNoKVxuICAgIGlmIChtYXRjaGluZ1N1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBfc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCA9PT0gMCkgcmV0dXJuIGdlbmVyaWNTdWdnZXN0aW9ucztcblxuICAgIHJldHVybiBtYXRjaGluZ1N1Z2dlc3Rpb25zO1xufVxuXG4vKlxuICogSWYgdGhlIGN1cnNvciBpcyBsb2NhdGVkIGluIGEgc2VjdGlvbiB0aGF0IHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGRhdGUgKGR1ZSwgc3RhcnQgZGF0ZSBvciBzY2hlZHVsZWQgZGF0ZSksXG4gKiBzdWdnZXN0IG9wdGlvbnMgZm9yIHdoYXQgdG8gZW50ZXIgYXMgYSBkYXRlLlxuICogVGhpcyBoYXMgdHdvIHBhcnRzOiBlaXRoZXIgZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLCBvciBhIHNpbmdsZSBzdWdnZXN0aW9uIHRoYXQgaXMgYSBwYXJzZWQgcmVzdWx0XG4gKiBvZiB3aGF0IHRoZSB1c2VyIGlzIHR5cGluZy5cbiAqIEdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgaW4gdHVybiwgYWxzbyBoYXZlIHR3byBvcHRpb25zOiBlaXRoZXIgZmlsdGVyZWQgKGlmIHRoZSB1c2VyIHN0YXJ0ZWQgdHlwaW5nXG4gKiBzb21ldGhpbmcgd2hlcmUgYSBkYXRlIGlzIGV4cGVjdGVkKSBvciB1bmZpbHRlcmVkXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGVzU3VnZ2VzdGlvbnMoXG4gICAgbGluZTogc3RyaW5nLFxuICAgIGN1cnNvclBvczogbnVtYmVyLFxuICAgIHNldHRpbmdzOiBTZXR0aW5ncyxcbiAgICBkYXRlUHJlZml4UmVnZXg6IHN0cmluZyxcbiAgICBtYXhHZW5lcmljU3VnZ2VzdGlvbnM6IG51bWJlcixcbik6IFN1Z2dlc3RJbmZvW10ge1xuICAgIGNvbnN0IGdlbmVyaWNTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgJ3RvZGF5JyxcbiAgICAgICAgJ3RvbW9ycm93JyxcbiAgICAgICAgJ1N1bmRheScsXG4gICAgICAgICdNb25kYXknLFxuICAgICAgICAnVHVlc2RheScsXG4gICAgICAgICdXZWRuZXNkYXknLFxuICAgICAgICAnVGh1cnNkYXknLFxuICAgICAgICAnRnJpZGF5JyxcbiAgICAgICAgJ1NhdHVyZGF5JyxcbiAgICAgICAgJ25leHQgd2VlaycsXG4gICAgICAgICduZXh0IG1vbnRoJyxcbiAgICAgICAgJ25leHQgeWVhcicsXG4gICAgXTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IFN1Z2dlc3RJbmZvW10gPSBbXTtcbiAgICBjb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGAoJHtkYXRlUHJlZml4UmVnZXh9KVxcXFxzKihbMC05YS16QS1aIF0qKWAsICd1ZycpO1xuICAgIGNvbnN0IGRhdGVNYXRjaCA9IG1hdGNoQnlQb3NpdGlvbihsaW5lLCBkYXRlUmVnZXgsIGN1cnNvclBvcyk7XG4gICAgaWYgKGRhdGVNYXRjaCAmJiBkYXRlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgZGF0ZVByZWZpeCA9IGRhdGVNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IGRhdGVNYXRjaFsyXTtcbiAgICAgICAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoIDwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZW50ZXJlZCB0ZXh0IGFzIGEgdmFsaWQgZGF0ZS5cbiAgICAgICAgLy8gV2UgcGFzcyBmb3J3YXJkRGF0ZT10cnVlIHRvIHBhcnNlRGF0ZSBiZWNhdXNlIHdlIGV4cGVjdCBkdWUsIHN0YXJ0IGFuZCBzY2hlZHVsZWQgZGF0ZXMgdG9cbiAgICAgICAgLy8gYmUgaW4gdGhlIGZ1dHVyZSwgaS5lLiBpZiB0b2RheSBpcyBTdW5kYXkgYW5kIHRoZSB1c2VyIHR5cGVkIFwiZHVlIDxFbnRlcj4gU2F0dXJkYXlcIiwgc2hlXG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IG1lYW5zIFNhdHVyZGF5ICppbiB0aGUgZnV0dXJlKiBhbmQgbm90IHllc3RlcmRheS5cbiAgICAgICAgY29uc3QgcG9zc2libGVEYXRlID1cbiAgICAgICAgICAgIGRhdGVTdHJpbmcgJiYgZGF0ZVN0cmluZy5sZW5ndGggPiAxID8gRGF0ZVBhcnNlci5wYXJzZURhdGUoZG9BdXRvY29tcGxldGUoZGF0ZVN0cmluZyksIHRydWUpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvc3NpYmxlRGF0ZSAmJiBwb3NzaWJsZURhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWVtcyBsaWtlIHRoZSB0ZXh0IHRoYXQgdGhlIHVzZXIgdHlwZWQgY2FuIGJlIHBhcnNlZCBhcyBhIHZhbGlkIGRhdGUuXG4gICAgICAgICAgICAvLyBQcmVzZW50IGl0cyBjb21wbGV0ZWQgZm9ybSBhcyBhIDFzdCBzdWdnZXN0aW9uXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiBgJHtwb3NzaWJsZURhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtkYXRlUHJlZml4fSAke3Bvc3NpYmxlRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogZGF0ZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGRhdGVNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB0byBnZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMuXG4gICAgICAgIC8vIElmIHdlIGdldCBhIHBhcnRpYWwgbWF0Y2ggd2l0aCBzb21lIG9mIHRoZSBzdWdnZXN0aW9ucyAoZS5nLiB0aGUgdXNlciBzdGFydGVkIHR5cGluZyBcInRvXCIpLFxuICAgICAgICAvLyB3ZSB1c2UgdGhhdCBmb3IgbWF0Y2hlcyAoXCJ0b21vcnJvd1wiLCBcInRvZGF5XCIgZXRjKS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBqdXN0IGRpc3BsYXkgdGhlIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMsIGFuZCBlaXRoZXIgd2F5LCB0cnVuY2F0ZSB0aGVtIGV2ZW50dWFsbHkgdG9cbiAgICAgICAgLy8gYSBtYXggbnVtYmVyLiBXZSB3YW50IHRoZSBtYXggbnVtYmVyIHRvIGJlIGFyb3VuZCBoYWxmIHRoZSB0b3RhbCBhbGxvd2VkIG1hdGNoZXMsIHRvIGFsc28gYWxsb3dcbiAgICAgICAgLy8gc29tZSBnbG9iYWwgZ2VuZXJpYyBtYXRjaGVzIChlLmcuIHRhc2sgY29tcG9uZW50cykgdG8gZmluZCB0aGVpciB3YXkgdG8gdGhlIG1lbnVcbiAgICAgICAgY29uc3QgbWluTWF0Y2ggPSAxO1xuICAgICAgICBsZXQgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICBkYXRlU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJpbmcubGVuZ3RoID49IG1pbk1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZGF0ZVN0cmluZy50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zbGljZSgwLCBtYXhHZW5lcmljU3VnZ2VzdGlvbnMpO1xuICAgICAgICBpZiAoZ2VuZXJpY01hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEbyBjb21wbGV0ZWx5IGdlbmVyaWMgZGF0ZSBzdWdnZXN0aW9uc1xuICAgICAgICAgICAgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnMuc2xpY2UoMCwgbWF4R2VuZXJpY1N1Z2dlc3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGdlbmVyaWNNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gRGF0ZVBhcnNlci5wYXJzZURhdGUobWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGAke3BhcnNlZERhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvblR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGAke21hdGNofSAoJHtmb3JtYXR0ZWREYXRlfSlgLFxuICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGAke2RhdGVQcmVmaXh9ICR7Zm9ybWF0dGVkRGF0ZX0gYCxcbiAgICAgICAgICAgICAgICBpbnNlcnRBdDogZGF0ZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgIGluc2VydFNraXA6IGRhdGVNYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLypcbiAqIElmIHRoZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiBhIHNlY3Rpb24gdGhhdCBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYSByZWN1cnJlbmNlIGRlc2NyaXB0aW9uLCBzdWdnZXN0IG9wdGlvbnNcbiAqIGZvciB3aGF0IHRvIGVudGVyIGFzIGEgcmVjdXJyZW5jZS5cbiAqIFRoaXMgaGFzIHR3byBwYXJ0czogZWl0aGVyIGdlbmVyaWMgcHJlZGVmaW5lZCBzdWdnZXN0aW9ucywgb3IgYSBzaW5nbGUgc3VnZ2VzdGlvbiB0aGF0IGlzIGEgcGFyc2VkIHJlc3VsdFxuICogb2Ygd2hhdCB0aGUgdXNlciBpcyB0eXBpbmcuXG4gKiBHZW5lcmljIHByZWRlZmluZWQgc3VnZ2VzdGlvbnMsIGluIHR1cm4sIGFsc28gaGF2ZSB0d28gb3B0aW9uczogZWl0aGVyIGZpbHRlcmVkIChpZiB0aGUgdXNlciBzdGFydGVkIHR5cGluZ1xuICogc29tZXRoaW5nIHdoZXJlIGEgcmVjdXJyZW5jZSBpcyBleHBlY3RlZCkgb3IgdW5maWx0ZXJlZFxuICovXG5mdW5jdGlvbiBhZGRSZWN1cnJlbmNlU3VnZ2VzdGlvbnMobGluZTogc3RyaW5nLCBjdXJzb3JQb3M6IG51bWJlciwgc2V0dGluZ3M6IFNldHRpbmdzLCByZWN1cnJlbmNlU3ltYm9sOiBzdHJpbmcpIHtcbiAgICBjb25zdCBnZW5lcmljU3VnZ2VzdGlvbnMgPSBbXG4gICAgICAgICdldmVyeScsXG4gICAgICAgICdldmVyeSBkYXknLFxuICAgICAgICAnZXZlcnkgd2VlaycsXG4gICAgICAgICdldmVyeSBtb250aCcsXG4gICAgICAgICdldmVyeSBtb250aCBvbiB0aGUnLFxuICAgICAgICAnZXZlcnkgeWVhcicsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFN1bmRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIE1vbmRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFR1ZXNkYXknLFxuICAgICAgICAnZXZlcnkgd2VlayBvbiBXZWRuZXNkYXknLFxuICAgICAgICAnZXZlcnkgd2VlayBvbiBUaHVyc2RheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIEZyaWRheScsXG4gICAgICAgICdldmVyeSB3ZWVrIG9uIFNhdHVyZGF5JyxcbiAgICBdO1xuXG4gICAgY29uc3QgcmVzdWx0czogU3VnZ2VzdEluZm9bXSA9IFtdO1xuICAgIGNvbnN0IHJlY3VycmVuY2VSZWdleCA9IG5ldyBSZWdFeHAoYCgke3JlY3VycmVuY2VTeW1ib2x9KVxcXFxzKihbMC05YS16QS1aIF0qKWAsICd1ZycpO1xuICAgIGNvbnN0IHJlY3VycmVuY2VNYXRjaCA9IG1hdGNoQnlQb3NpdGlvbihsaW5lLCByZWN1cnJlbmNlUmVnZXgsIGN1cnNvclBvcyk7XG4gICAgaWYgKHJlY3VycmVuY2VNYXRjaCAmJiByZWN1cnJlbmNlTWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZVByZWZpeCA9IHJlY3VycmVuY2VNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZVN0cmluZyA9IHJlY3VycmVuY2VNYXRjaFsyXTtcbiAgICAgICAgaWYgKHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoIDwgc2V0dGluZ3MuYXV0b1N1Z2dlc3RNaW5NYXRjaCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAocmVjdXJyZW5jZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBtYXRjaGVzIGEgdmFsaWQgcmVjdXJlbmNlIGRlc2NyaXB0aW9uLCBwcmVzZW50IGl0IGFzIGEgMXN0IHN1Z2dlc3Rpb24uXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGFkZCBhIG5pY2UgY2hlY2ttYXJrIGluIHRoaXMgY2FzZSB0byBkZW5vdGUgaXQncyBhIGNvbXBsZXRlIHZhbGlkIHJlY3VycmVuY2UgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlY3VycmVuY2UgPSBSZWN1cnJlbmNlLmZyb21UZXh0KHtcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IHJlY3VycmVuY2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIH0pPy50b1RleHQoKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRSZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwZW5kZWRUZXh0ID0gYCR7cmVjdXJyZW5jZVByZWZpeH0gJHtwYXJzZWRSZWN1cnJlbmNlfSBgO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25UeXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogYFx1MjcwNSAke3BhcnNlZFJlY3VycmVuY2V9YCxcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogYXBwZW5kZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBdDogcmVjdXJyZW5jZU1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTa2lwOiByZWN1cnJlbmNlTWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdWxsIG1hdGNoIGluY2x1ZGVzIGEgY29tcGxldGUgdmFsaWQgc3VnZ2VzdGlvbiAqZW5kaW5nIHdpdGggc3BhY2UqLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3QgYW55dGhpbmcuIFRoZSB1c2VyIGlzIHRyeWluZyB0byBjb250aW51ZSB0byB0eXBlIHNvbWV0aGluZyB0aGF0IGlzIGxpa2VseVxuICAgICAgICAgICAgICAgIC8vIG5vdCByZWxhdGVkIHRvIHJlY3VycmVuY2UuIFdoZW4gc2hlIHN0YXJ0cyBhIG5ldyB3b3JkLCBtYXliZSB0aGUgcmVjdXJyZW5jZSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZWxldmFudCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnJlbmNlTWF0Y2hbMF0gPT0gYXBwZW5kZWRUZXh0KSByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdG8gZ2VuZXJpYyBwcmVkZWZpbmVkIHN1Z2dlc3Rpb25zLlxuICAgICAgICAvLyBJZiB3ZSBnZXQgYSBwYXJ0aWFsIG1hdGNoIHdpdGggc29tZSBvZiB0aGUgc3VnZ2VzdGlvbnMgKGUuZy4gdGhlIHVzZXIgc3RhcnRlZCB0eXBpbmcgXCJldmVyeSBkXCIpLFxuICAgICAgICAvLyB3ZSB1c2UgdGhhdCBmb3IgbWF0Y2hlcyAoXCJldmVyeSBkYXlcIikuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIHN1Z2dlc3Rpb25zLCBhbmQgZWl0aGVyIHdheSwgdHJ1bmNhdGUgdGhlbSBldmVudHVhbGx5IHRvXG4gICAgICAgIC8vIGEgbWF4IG51bWJlci5cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgcmVjdXJyZW5jZSBydWxlcywgdGhlIG1heCBudW1iZXIgc2hvdWxkIGJlIHNtYWxsIGVub3VnaCB0byBhbGxvdyB1c2VycyB0byBcImVzY2FwZVwiXG4gICAgICAgIC8vIHRoZSBtb2RlIG9mIHdyaXRpbmcgYSByZWN1cnJlbmNlIHJ1bGUsIGkuZS4gd2Ugc2hvdWxkIGxlYXZlIGVub3VnaCBzcGFjZSBmb3IgY29tcG9uZW50IHN1Z2dlc3Rpb25zXG4gICAgICAgIGNvbnN0IG1pbk1hdGNoID0gMTtcbiAgICAgICAgY29uc3QgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyA9IHNldHRpbmdzLmF1dG9TdWdnZXN0TWF4SXRlbXMgLyAyO1xuICAgICAgICBsZXQgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICByZWN1cnJlbmNlU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHJlY3VycmVuY2VTdHJpbmcubGVuZ3RoID49IG1pbk1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocmVjdXJyZW5jZVN0cmluZy50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zbGljZSgwLCBtYXhHZW5lcmljRGF0ZVN1Z2dlc3Rpb25zKTtcbiAgICAgICAgaWYgKGdlbmVyaWNNYXRjaGVzLmxlbmd0aCA9PT0gMCAmJiByZWN1cnJlbmNlU3RyaW5nLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgbm8gYWN0dWFsIG1hdGNoIHNvIGRvIGNvbXBsZXRlbHkgZ2VuZXJpYyByZWN1cnJlbmNlIHN1Z2dlc3Rpb25zLCBidXQgbm90IGlmXG4gICAgICAgICAgICAvLyB0aGVyZSAqd2FzKiBhIHRleHQgdG8gbWF0Y2ggKGJlY2F1c2UgaXQgbWVhbnMgdGhlIHVzZXIgaXMgYWN0dWFsbHkgdHlwaW5nIHNvbWV0aGluZyBlbHNlKVxuICAgICAgICAgICAgZ2VuZXJpY01hdGNoZXMgPSBnZW5lcmljU3VnZ2VzdGlvbnMuc2xpY2UoMCwgbWF4R2VuZXJpY0RhdGVTdWdnZXN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBnZW5lcmljTWF0Y2hlcykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVHlwZTogJ21hdGNoJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogYCR7bWF0Y2h9YCxcbiAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBgJHtyZWN1cnJlbmNlUHJlZml4fSAke21hdGNofSBgLFxuICAgICAgICAgICAgICAgIGluc2VydEF0OiByZWN1cnJlbmNlTWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgaW5zZXJ0U2tpcDogcmVjdXJyZW5jZU1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogTWF0Y2hlcyBhIHN0cmluZyB3aXRoIGEgcmVnZXggYWNjb3JkaW5nIHRvIGEgcG9zaXRpb24gKHR5cGljYWxseSBvZiBhIGN1cnNvcikuXG4gKiBXaWxsIHJldHVybiBhIHJlc3VsdCBvbmx5IGlmIGEgbWF0Y2ggZXhpc3RzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcGFydCBvZiBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoQnlQb3NpdGlvbihzOiBzdHJpbmcsIHI6IFJlZ0V4cCwgcG9zaXRpb246IG51bWJlcik6IFJlZ0V4cE1hdGNoQXJyYXkgfCB2b2lkIHtcbiAgICBjb25zdCBtYXRjaGVzID0gcy5tYXRjaEFsbChyKTtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoPy5pbmRleCAmJiBtYXRjaC5pbmRleCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgcmV0dXJuIG1hdGNoO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBfYW55XyBvZiB0aGUgYnJhY2tldCBwYWlycyBpbiB7QGxpbmsgYnJhY2tldHN9IGlzIG9wZW4gYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHtAbGluayBsaW5lfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgaXNBbnlCcmFja2V0T3BlbihcIihoZWxsbyB3b3JsZFwiLCAgIFtbJygnLCAnKSddXSk7ICAgICAgICAgICAgIC8vIHRydWVcbiAqICAgICBpc0FueUJyYWNrZXRPcGVuKFwiW2hlbGxvIHdvcmxkXCIsICAgW1snWycsICddJ11dKTsgICAgICAgICAgICAgLy8gdHJ1ZVxuICogICAgIGlzQW55QnJhY2tldE9wZW4oXCJbaGVsbG8gd29ybGRcIiwgICBbWycoJywgJyknXSwgWydbJywgJ10nXV0pOyAvLyB0cnVlXG4gKiAgICAgaXNBbnlCcmFja2V0T3BlbihcIihbaGVsbG8gd29ybGQpXCIsIFtbJygnLCAnKSddLCBbJ1snLCAnXSddXSkgIC8vIHRydWVcbiAqICAgICBpc0FueUJyYWNrZXRPcGVuKFwiKSkpKShcIiwgICAgICAgICAgW1snKCcsICcpJ11dKSAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogICAgIGlzQW55QnJhY2tldE9wZW4oXCIoaGVsbG8gd29ybGQpXCIsICBbWycoJywgJyknXV0pOyAgICAgICAgICAgICAvLyBmYWxzZVxuICogICAgIGlzQW55QnJhY2tldE9wZW4oXCIoaGVsbG8gd29ybGQpXCIsICBbXSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBzY2FuXG4gKiBAcGFyYW0gYnJhY2tldHMgLSBBIGxpc3Qgb2YgdHVwbGVzIHRoYXQgZGVmaW5lcyBicmFja2V0IHBhaXJzLlxuICovXG5mdW5jdGlvbiBpc0FueUJyYWNrZXRPcGVuKGxpbmU6IHN0cmluZywgYnJhY2tldHM6IFtvcGVuaW5nX2JyYWNrZXQ6IHN0cmluZywgY2xvc2luZ19icmFja2V0OiBzdHJpbmddW10pOiBib29sZWFuIHtcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNYXBzIGFuIG9wZW5pbmcgYnJhY2tldCB0byB0aGUgbnVtYmVyIG9mIG9wZW4gYnJhY2tldHMgb2YgdGhhdCB0eXBlXG4gICAgY29uc3QgbnVtT3BlbmluZ0JyYWNrZXRzID0gT2JqZWN0LmZyb21FbnRyaWVzKGJyYWNrZXRzLm1hcCgoW29wZW4sIF9dKSA9PiBbb3BlbiwgMF0pKTtcbiAgICAvLyBNYXBzIGEgY2xvc2luZyBicmFja2V0IHRvIGFuIG9wZW5pbmcgYnJhY2tldFxuICAgIGNvbnN0IG9wZW5pbmdPZiA9IE9iamVjdC5mcm9tRW50cmllcyhicmFja2V0cy5tYXAoKFtvcGVuLCBjbG9zZV0pID0+IFtjbG9zZSwgb3Blbl0pKTtcblxuICAgIGZvciAoY29uc3QgYyBvZiBsaW5lKSB7XG4gICAgICAgIGlmIChjIGluIG51bU9wZW5pbmdCcmFja2V0cykge1xuICAgICAgICAgICAgbnVtT3BlbmluZ0JyYWNrZXRzW2NdKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYyBpbiBvcGVuaW5nT2YpIHtcbiAgICAgICAgICAgIG51bU9wZW5pbmdCcmFja2V0c1tvcGVuaW5nT2ZbY11dID0gTWF0aC5tYXgoMCwgbnVtT3BlbmluZ0JyYWNrZXRzW29wZW5pbmdPZltjXV0gLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKG51bU9wZW5pbmdCcmFja2V0cykuc29tZSgobikgPT4gbiA+IDApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgU3VnZ2VzdGlvbkJ1aWxkZXIge0BsaW5rIGZufSwgcmV0dXJucyBhIG5ldyBTdWdnZXN0aW9uQnVpbGRlciB3aXRoIGlkZW50aWNhbCBiZWhhdmlvciB0byB7QGxpbmsgZm59IGV4Y2VwdFxuICogICAgIGl0IG9ubHkgcmV0dXJucyBzdWdnZXN0aW9ucyBpZiB0aGVyZSBpcyBhbiBvcGVuIGJyYWNrZXQgYXQgdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0gZm4gLSBBIHN1Z2dlc3Rpb24gYnVpbGRlciB0byB3cmFwXG4gKiBAcGFyYW0gYnJhY2tldHMgLSBBIGxpc3Qgb2YgdHVwbGVzIHRoYXQgZGVmaW5lcyBicmFja2V0IHBhaXJzLlxuICogQHJldHVybnMgQSB7QGxpbmsgU3VnZ2VzdGlvbkJ1aWxkZXJ9IHRoYXQgcmV0dXJuczpcbiAqICAgKiBgW11gIGlmIHRoZXJlIGFyZSBubyBvcGVuIGJyYWNrZXRzIGF0IHRoZSBnaXZlbiBjdXJzb3IgcG9zaXRpb25cbiAqICAgKiB7QGxpbmsgZm59YChsaW5lLCBjdXJzb3JQb3MsIHNldHRpbmdzKWAgb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmx5U3VnZ2VzdElmQnJhY2tldE9wZW4oZm46IFN1Z2dlc3Rpb25CdWlsZGVyLCBicmFja2V0czogW3N0cmluZywgc3RyaW5nXVtdKTogU3VnZ2VzdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiAobGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncyk6IFN1Z2dlc3RJbmZvW10gPT4ge1xuICAgICAgICBpZiAoIWlzQW55QnJhY2tldE9wZW4obGluZS5zbGljZSgwLCBjdXJzb3JQb3MpLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4obGluZSwgY3Vyc29yUG9zLCBzZXR0aW5ncyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgQXV0by1TdWdnZXN0IG1lbnUgbWF5IGJlIHNob3duIG9uIHRoZSBjdXJyZW50IGxpbmUsXG4gKiBhbmQgZmFsc2UgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIFRoaXMgY2hlY2tzIGZvciBzaW1wbGUgcHJlLWNvbmRpdGlvbnM6XG4gKiAgLSBJcyB0aGUgZ2xvYmFsIGZpbHRlciAoaWYgc2V0KSBpbiB0aGUgbGluZT9cbiAqICAtIElzIHRoZSBsaW5lIGEgdGFzayBsaW5lICh3aXRoIGEgY2hlY2tib3gpXG4gKiBAcGFyYW0gbGluZVxuICogQHBhcmFtIGN1cnNvclBvc2l0aW9uIC0gdGhlIGN1cnNvciBwb3NpdGlvbiwgd2hlbiAwIGlzIHByZXN1bWVkIHRvIG1lYW4gJ2F0IHRoZSBzdGFydCBvZiB0aGUgbGluZScuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlICdjaCcgaW4gaHR0cHM6Ly9kb2NzLm9ic2lkaWFuLm1kL1JlZmVyZW5jZS9UeXBlU2NyaXB0K0FQSS9FZGl0b3JQb3NpdGlvbi9FZGl0b3JQb3NpdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuU3VnZ2VzdEZvckxpbmUobGluZTogc3RyaW5nLCBjdXJzb3JQb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgcmV0dXJuIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmluY2x1ZGVkSW4obGluZSkgJiYgY3Vyc29ySXNJblRhc2tMaW5lRGVzY3JpcHRpb24obGluZSwgY3Vyc29yUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmOlxuICogLSBsaW5lIGlzIGEgdGFzayBsaW5lLCB0aGF0IGlzLCBpdCBpcyBhIGxpc3QgaXRlbSB3aXRoIGEgY2hlY2tib3guXG4gKiAtIHRoZSBjdXJzb3IgaXMgaW4gYSB0YXNrIGxpbmUncyBkZXNjcmlwdGlvbi5cbiAqXG4gKiBIZXJlLCBkZXNjcmlwdGlvbiBpbmNsdWRlcyBhbnkgdGFzayBzaWduaWZpZXJzLCBhcyB3ZWxsIGFzIHRoZSB2YW5pbGxhIGRlc2NyaXB0aW9uLlxuICogQHBhcmFtIGxpbmVcbiAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvblxuICovXG5mdW5jdGlvbiBjdXJzb3JJc0luVGFza0xpbmVEZXNjcmlwdGlvbihsaW5lOiBzdHJpbmcsIGN1cnNvclBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBUYXNrLmV4dHJhY3RUYXNrQ29tcG9uZW50cyhsaW5lKTtcbiAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgLy8gSXQgaXMgbm90IGEgdGFzayBsaW5lLCB0aGF0IGlzLCBpdCBpcyBub3QgYSBsaXN0IGl0ZW0gd2l0aCBhIGNoZWNrYm94OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBsaW5lLCB1cCB0byB0aGUgc3BhY2UgYWZ0ZXIgdGhlIGNsb3NpbmcgJ10nIGluIHRoZSBjaGVja2JveDpcbiAgICBjb25zdCBiZWZvcmVEZXNjcmlwdGlvbiA9IGNvbXBvbmVudHMuaW5kZW50YXRpb24gKyBjb21wb25lbnRzLmxpc3RNYXJrZXIgKyAnIFsnICsgY29tcG9uZW50cy5zdGF0dXMuc3ltYm9sICsgJ10gJztcblxuICAgIHJldHVybiBjdXJzb3JQb3NpdGlvbiA+PSBiZWZvcmVEZXNjcmlwdGlvbi5sZW5ndGg7XG59XG4iLCAiLyoqXG4gKiBWYXJpb3VzIHJlbmRlcmluZyBvcHRpb25zIGZvciBhIHF1ZXJ5LlxuICogU2VlIGFwcGx5T3B0aW9ucyBiZWxvdyB3aGVuIGFkZGluZyBvcHRpb25zIGhlcmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXlvdXRPcHRpb25zIHtcbiAgICBoaWRlVGFza0NvdW50OiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZUJhY2tsaW5rczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVQcmlvcml0eTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVDcmVhdGVkRGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVTdGFydERhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlU2NoZWR1bGVkRGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVEb25lRGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhpZGVEdWVEYXRlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZVJlY3VycmVuY2VSdWxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGlkZUVkaXRCdXR0b246IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBoaWRlVXJnZW5jeTogYm9vbGVhbiA9IHRydWU7XG4gICAgaGlkZVRhZ3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG9ydE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBleHBsYWluUXVlcnk6IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuZXhwb3J0IHR5cGUgVGFza0xheW91dENvbXBvbmVudCA9XG4gICAgfCAnZGVzY3JpcHRpb24nXG4gICAgfCAncHJpb3JpdHknXG4gICAgfCAncmVjdXJyZW5jZVJ1bGUnXG4gICAgfCAnY3JlYXRlZERhdGUnXG4gICAgfCAnc3RhcnREYXRlJ1xuICAgIHwgJ3NjaGVkdWxlZERhdGUnXG4gICAgfCAnZHVlRGF0ZSdcbiAgICB8ICdkb25lRGF0ZSdcbiAgICB8ICdibG9ja0xpbmsnO1xuXG4vKipcbiAqIFRoaXMgcmVwcmVzZW50cyB0aGUgZGVzaXJlZCBsYXlvdXQgb2YgdGFza3Mgd2hlbiB0aGV5IGFyZSByZW5kZXJlZCBpbiBhIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGUgbGF5b3V0IGlzIHVzZWQgd2hlbiBmbGF0dGVuaW5nIHRoZSB0YXNrIHRvIGEgc3RyaW5nIGFuZCB3aGVuIHJlbmRlcmluZyBxdWVyaWVzLCBhbmQgY2FuIGJlXG4gKiBtb2RpZmllZCBieSBhcHBseWluZyB7QGxpbmsgTGF5b3V0T3B0aW9uc30gb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tMYXlvdXQge1xuICAgIHB1YmxpYyBkZWZhdWx0TGF5b3V0OiBUYXNrTGF5b3V0Q29tcG9uZW50W10gPSBbXG4gICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICdyZWN1cnJlbmNlUnVsZScsXG4gICAgICAgICdjcmVhdGVkRGF0ZScsXG4gICAgICAgICdzdGFydERhdGUnLFxuICAgICAgICAnc2NoZWR1bGVkRGF0ZScsXG4gICAgICAgICdkdWVEYXRlJyxcbiAgICAgICAgJ2RvbmVEYXRlJyxcbiAgICAgICAgJ2Jsb2NrTGluaycsXG4gICAgXTtcbiAgICBwdWJsaWMgc2hvd25UYXNrTGF5b3V0Q29tcG9uZW50czogVGFza0xheW91dENvbXBvbmVudFtdO1xuICAgIHB1YmxpYyBoaWRkZW5UYXNrTGF5b3V0Q29tcG9uZW50czogVGFza0xheW91dENvbXBvbmVudFtdID0gW107XG4gICAgcHVibGljIG9wdGlvbnM6IExheW91dE9wdGlvbnM7XG4gICAgcHVibGljIHRhc2tMaXN0SGlkZGVuQ2xhc3Nlczogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBMYXlvdXRPcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IExheW91dE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3duVGFza0xheW91dENvbXBvbmVudHMgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIHRoaXMuYXBwbHlPcHRpb25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseU9wdGlvbnMoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIGxheW91dCBhY2NvcmRpbmcgdG8gdGhlIHRhc2sgb3B0aW9ucy4gVGhlc2UgcmVwcmVzZW50IHRoZSBleGlzdGluZyB0YXNrIG9wdGlvbnMsXG4gICAgICAgIC8vIHNvIHNvbWUgY29tcG9uZW50cyAoZS5nLiB0aGUgZGVzY3JpcHRpb24pIGFyZSBub3QgaGVyZSBiZWNhdXNlIHRoZXJlIGFyZSBubyBsYXlvdXQgb3B0aW9ucyB0byByZW1vdmUgdGhlbS5cbiAgICAgICAgY29uc3QgY29tcG9uZW50c1RvSGlkZUFuZEdlbmVyYXRlQ2xhc3NlczogW2Jvb2xlYW4sIFRhc2tMYXlvdXRDb21wb25lbnRdW10gPSBbXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVQcmlvcml0eSwgJ3ByaW9yaXR5J10sXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVSZWN1cnJlbmNlUnVsZSwgJ3JlY3VycmVuY2VSdWxlJ10sXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVDcmVhdGVkRGF0ZSwgJ2NyZWF0ZWREYXRlJ10sXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVTdGFydERhdGUsICdzdGFydERhdGUnXSxcbiAgICAgICAgICAgIFt0aGlzLm9wdGlvbnMuaGlkZVNjaGVkdWxlZERhdGUsICdzY2hlZHVsZWREYXRlJ10sXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVEdWVEYXRlLCAnZHVlRGF0ZSddLFxuICAgICAgICAgICAgW3RoaXMub3B0aW9ucy5oaWRlRG9uZURhdGUsICdkb25lRGF0ZSddLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IFtoaWRlLCBjb21wb25lbnRdIG9mIGNvbXBvbmVudHNUb0hpZGVBbmRHZW5lcmF0ZUNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbXBvbmVudChoaWRlLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QoaGlkZSwgY29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHNUb0dlbmVyYXRlQ2xhc3Nlc09ubHk6IFtib29sZWFuLCBzdHJpbmddW10gPSBbXG4gICAgICAgICAgICAvLyBUYWdzIGFyZSBoaWRkZW4sIHJhdGhlciB0aGFuIHJlbW92ZWQuIFNlZSB0YXNrcy1sYXlvdXQtaGlkZS10YWdzIGluIHN0eWxlcy5jc3MuXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVUYWdzLCAndGFncyddLFxuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbXBvbmVudHMgYXJlIGhhbmRsZWQgaW4gUXVlcnlSZW5kZXJlci50cyBhbmQgdGh1cyBhcmUgbm90IHBhcnQgb2YgdGhlIHNhbWUgZmxvdyB0aGF0XG4gICAgICAgICAgICAvLyBoaWRlcyBUYXNrTGF5b3V0Q29tcG9uZW50IGl0ZW1zLiBIb3dldmVyLCB3ZSBzdGlsbCB3YW50IHRvIGhhdmUgJ3Rhc2tzLWxheW91dC1oaWRlJyBpdGVtcyBmb3IgdGhlbVxuICAgICAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzE4NjYpLlxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gYmVuZWZpdCBmcm9tIHNvbWUgcmVmYWN0b3JpbmcsIGkuZS4gcmVuZGVyIHRoZXNlIGNvbXBvbmVudHMgaW4gYSBzaW1pbGFyIGZsb3cgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgIC8vIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVVcmdlbmN5LCAndXJnZW5jeSddLFxuICAgICAgICAgICAgW3RoaXMub3B0aW9ucy5oaWRlQmFja2xpbmtzLCAnYmFja2xpbmtzJ10sXG4gICAgICAgICAgICBbdGhpcy5vcHRpb25zLmhpZGVFZGl0QnV0dG9uLCAnZWRpdC1idXR0b24nXSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGlkZSwgY29tcG9uZW50XSBvZiBjb21wb25lbnRzVG9HZW5lcmF0ZUNsYXNzZXNPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSGlkZGVuQ2xhc3NGb3JUYXNrTGlzdChoaWRlLCBjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG9ydE1vZGUpIHRoaXMudGFza0xpc3RIaWRkZW5DbGFzc2VzLnB1c2goJ3Rhc2tzLWxheW91dC1zaG9ydC1tb2RlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUhpZGRlbkNsYXNzRm9yVGFza0xpc3QoaGlkZTogYm9vbGVhbiwgY29tcG9uZW50OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFza0xpc3RIaWRkZW5DbGFzc2VzLnB1c2goYHRhc2tzLWxheW91dC1oaWRlLSR7Y29tcG9uZW50fWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBzaG93biB0byBoaWRkZW4gaWYgdGhlIGdpdmVuIGxheW91dE9wdGlvbiBjcml0ZXJpYSBpcyBtZXQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlQ29tcG9uZW50KGhpZGU6IGJvb2xlYW4sIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRkZW5UYXNrTGF5b3V0Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLnNob3duVGFza0xheW91dENvbXBvbmVudHMgPSB0aGlzLnNob3duVGFza0xheW91dENvbXBvbmVudHMuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50ICE9IGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgVGFza0xheW91dCB9IGZyb20gJy4uL1Rhc2tMYXlvdXQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrTGF5b3V0Q29tcG9uZW50IH0gZnJvbSAnLi4vVGFza0xheW91dCc7XG5pbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vUmVjdXJyZW5jZSc7XG5pbXBvcnQgeyBQcmlvcml0eSwgVGFzaywgVGFza1JlZ3VsYXJFeHByZXNzaW9ucyB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBUYXNrRGV0YWlscywgVGFza1NlcmlhbGl6ZXIgfSBmcm9tICcuJztcblxuLyogSW50ZXJmYWNlIGRlc2NyaWJpbmcgdGhlIHN5bWJvbHMgdGhhdCB7QGxpbmsgRGVmYXVsdFRhc2tTZXJpYWxpemVyfVxuICogdXNlcyB0byBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHRhc2tzLlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgRGVmYXVsdFRhc2tTZXJpYWxpemVyU3ltYm9sc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRUYXNrU2VyaWFsaXplclN5bWJvbHMge1xuICAgIHJlYWRvbmx5IHByaW9yaXR5U3ltYm9sczoge1xuICAgICAgICBIaWdoZXN0OiBzdHJpbmc7XG4gICAgICAgIEhpZ2g6IHN0cmluZztcbiAgICAgICAgTWVkaXVtOiBzdHJpbmc7XG4gICAgICAgIExvdzogc3RyaW5nO1xuICAgICAgICBMb3dlc3Q6IHN0cmluZztcbiAgICAgICAgTm9uZTogc3RyaW5nO1xuICAgIH07XG4gICAgcmVhZG9ubHkgc3RhcnREYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgY3JlYXRlZERhdGVTeW1ib2w6IHN0cmluZztcbiAgICByZWFkb25seSBzY2hlZHVsZWREYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZHVlRGF0ZVN5bWJvbDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGRvbmVEYXRlU3ltYm9sOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgcmVjdXJyZW5jZVN5bWJvbDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnM6IHtcbiAgICAgICAgcHJpb3JpdHlSZWdleDogUmVnRXhwO1xuICAgICAgICBzdGFydERhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICBjcmVhdGVkRGF0ZVJlZ2V4OiBSZWdFeHA7XG4gICAgICAgIHNjaGVkdWxlZERhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICBkdWVEYXRlUmVnZXg6IFJlZ0V4cDtcbiAgICAgICAgZG9uZURhdGVSZWdleDogUmVnRXhwO1xuICAgICAgICByZWN1cnJlbmNlUmVnZXg6IFJlZ0V4cDtcbiAgICB9O1xufVxuXG4vKipcbiAqIEEgc3ltYm9sIG1hcCBmb3Igb2JzaWRpYW4tdGFzaydzIGRlZmF1bHQgdGFzayBzdHlsZS5cbiAqIFVzZXMgZW1vamlzIHRvIGNvbmNpc2VseSBjb252ZXkgbWVhbmluZ1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9TWU1CT0xTOiBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzID0ge1xuICAgIHByaW9yaXR5U3ltYm9sczoge1xuICAgICAgICBIaWdoZXN0OiAnXHVEODNEXHVERDNBJyxcbiAgICAgICAgSGlnaDogJ1x1MjNFQicsXG4gICAgICAgIE1lZGl1bTogJ1x1RDgzRFx1REQzQycsXG4gICAgICAgIExvdzogJ1x1RDgzRFx1REQzRCcsXG4gICAgICAgIExvd2VzdDogJ1x1MjNFQycsXG4gICAgICAgIE5vbmU6ICcnLFxuICAgIH0sXG4gICAgc3RhcnREYXRlU3ltYm9sOiAnXHVEODNEXHVERUVCJyxcbiAgICBjcmVhdGVkRGF0ZVN5bWJvbDogJ1x1Mjc5NScsXG4gICAgc2NoZWR1bGVkRGF0ZVN5bWJvbDogJ1x1MjNGMycsXG4gICAgZHVlRGF0ZVN5bWJvbDogJ1x1RDgzRFx1RENDNScsXG4gICAgZG9uZURhdGVTeW1ib2w6ICdcdTI3MDUnLFxuICAgIHJlY3VycmVuY2VTeW1ib2w6ICdcdUQ4M0RcdUREMDEnLFxuICAgIFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnM6IHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCdzIGVuZCB3aXRoIGAkYCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhlIGVuZCB1bnRpbCBub25lIGFyZSBsZWZ0LlxuICAgICAgICBwcmlvcml0eVJlZ2V4OiAvKFtcdUQ4M0RcdUREM0FcdTIzRUJcdUQ4M0RcdUREM0NcdUQ4M0RcdUREM0RcdTIzRUNdKSQvdSxcbiAgICAgICAgc3RhcnREYXRlUmVnZXg6IC9cdUQ4M0RcdURFRUIgKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3UsXG4gICAgICAgIGNyZWF0ZWREYXRlUmVnZXg6IC9cdTI3OTUgKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkkL3UsXG4gICAgICAgIHNjaGVkdWxlZERhdGVSZWdleDogL1tcdTIzRjNcdTIzMUJdICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pJC91LFxuICAgICAgICBkdWVEYXRlUmVnZXg6IC9bXHVEODNEXHVEQ0M1XHVEODNEXHVEQ0M2XHVEODNEXHVEREQzXSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdSxcbiAgICAgICAgZG9uZURhdGVSZWdleDogL1x1MjcwNSAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvdSxcbiAgICAgICAgcmVjdXJyZW5jZVJlZ2V4OiAvXHVEODNEXHVERDAxID8oW2EtekEtWjAtOSwgIV0rKSQvaXUsXG4gICAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0VGFza1NlcmlhbGl6ZXIgaW1wbGVtZW50cyBUYXNrU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHN5bWJvbHM6IERlZmF1bHRUYXNrU2VyaWFsaXplclN5bWJvbHMpIHt9XG5cbiAgICAvKiBDb252ZXJ0IGEgdGFzayB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzayB0byBzZXJpYWxpemVcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFza1xuICAgICAqL1xuICAgIHB1YmxpYyBzZXJpYWxpemUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHRhc2tMYXlvdXQgPSBuZXcgVGFza0xheW91dCgpO1xuICAgICAgICBsZXQgdGFza1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiB0YXNrTGF5b3V0LnNob3duVGFza0xheW91dENvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRhc2tTdHJpbmcgKz0gdGhpcy5jb21wb25lbnRUb1N0cmluZyh0YXNrLCB0YXNrTGF5b3V0LCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpYyBUYXNrTGF5b3V0Q29tcG9uZW50IG9mIHRoZSB0YXNrIChpdHMgZGVzY3JpcHRpb24sIHByaW9yaXR5LCBldGMpIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wb25lbnRUb1N0cmluZyh0YXNrOiBUYXNrLCBsYXlvdXQ6IFRhc2tMYXlvdXQsIGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwcmlvcml0eVN5bWJvbHMsXG4gICAgICAgICAgICBzdGFydERhdGVTeW1ib2wsXG4gICAgICAgICAgICBjcmVhdGVkRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGVTeW1ib2wsXG4gICAgICAgICAgICBkb25lRGF0ZVN5bWJvbCxcbiAgICAgICAgICAgIHJlY3VycmVuY2VTeW1ib2wsXG4gICAgICAgICAgICBkdWVEYXRlU3ltYm9sLFxuICAgICAgICB9ID0gdGhpcy5zeW1ib2xzO1xuXG4gICAgICAgIHN3aXRjaCAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjYXNlICdkZXNjcmlwdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGVzY3JpcHRpb247XG4gICAgICAgICAgICBjYXNlICdwcmlvcml0eSc6IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJpb3JpdHk6IHN0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5LkhpZ2hlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnICcgKyBwcmlvcml0eVN5bWJvbHMuSGlnaGVzdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5LkhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnICcgKyBwcmlvcml0eVN5bWJvbHMuSGlnaDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5Lk1lZGl1bSkge1xuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICcgJyArIHByaW9yaXR5U3ltYm9scy5NZWRpdW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5Mb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSAnICcgKyBwcmlvcml0eVN5bWJvbHMuTG93O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTG93ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gJyAnICsgcHJpb3JpdHlTeW1ib2xzLkxvd2VzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3RhcnREYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2suc3RhcnREYXRlKSByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheW91dC5vcHRpb25zLnNob3J0TW9kZVxuICAgICAgICAgICAgICAgICAgICA/ICcgJyArIHN0YXJ0RGF0ZVN5bWJvbFxuICAgICAgICAgICAgICAgICAgICA6IGAgJHtzdGFydERhdGVTeW1ib2x9ICR7dGFzay5zdGFydERhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZWREYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2suY3JlYXRlZERhdGUpIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5b3V0Lm9wdGlvbnMuc2hvcnRNb2RlXG4gICAgICAgICAgICAgICAgICAgID8gJyAnICsgY3JlYXRlZERhdGVTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgOiBgICR7Y3JlYXRlZERhdGVTeW1ib2x9ICR7dGFzay5jcmVhdGVkRGF0ZS5mb3JtYXQoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX1gO1xuICAgICAgICAgICAgY2FzZSAnc2NoZWR1bGVkRGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrLnNjaGVkdWxlZERhdGUgfHwgdGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZCkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXlvdXQub3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAnICcgKyBzY2hlZHVsZWREYXRlU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIDogYCAke3NjaGVkdWxlZERhdGVTeW1ib2x9ICR7dGFzay5zY2hlZHVsZWREYXRlLmZvcm1hdChUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpfWA7XG4gICAgICAgICAgICBjYXNlICdkb25lRGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrLmRvbmVEYXRlKSByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheW91dC5vcHRpb25zLnNob3J0TW9kZVxuICAgICAgICAgICAgICAgICAgICA/ICcgJyArIGRvbmVEYXRlU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIDogYCAke2RvbmVEYXRlU3ltYm9sfSAke3Rhc2suZG9uZURhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ2R1ZURhdGUnOlxuICAgICAgICAgICAgICAgIGlmICghdGFzay5kdWVEYXRlKSByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheW91dC5vcHRpb25zLnNob3J0TW9kZVxuICAgICAgICAgICAgICAgICAgICA/ICcgJyArIGR1ZURhdGVTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgOiBgICR7ZHVlRGF0ZVN5bWJvbH0gJHt0YXNrLmR1ZURhdGUuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2VSdWxlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2sucmVjdXJyZW5jZSkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXlvdXQub3B0aW9ucy5zaG9ydE1vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAnICcgKyByZWN1cnJlbmNlU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIDogYCAke3JlY3VycmVuY2VTeW1ib2x9ICR7dGFzay5yZWN1cnJlbmNlLnRvVGV4dCgpfWA7XG4gICAgICAgICAgICBjYXNlICdibG9ja0xpbmsnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmJsb2NrTGluayA/PyAnJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb24ndCBrbm93IGhvdyB0byByZW5kZXIgdGFzayBjb21wb25lbnQgb2YgdHlwZSAnJHtjb21wb25lbnR9J2ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHN0cmluZyBjYXB0dXJlZCBpbiB0aGUgZmlyc3QgY2FwdHVyZSBncm91cCBvZlxuICAgICAqICAgIHtAbGluayBEZWZhdWx0VGFza1NlcmlhbGl6ZXJTeW1ib2xzLlRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMucHJpb3JpdHlSZWdleH0sXG4gICAgICogICAgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBQcmlvcml0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwIFN0cmluZyBjYXB0dXJlZCBieSBwcmlvcml0eVJlZ2V4XG4gICAgICogQHJldHVybnMgQ29ycmVzcG9uZGluZyBwcmlvcml0eSBpZiBwYXJzaW5nIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2Uge0BsaW5rIFByaW9yaXR5Lk5vbmV9XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhcnNlUHJpb3JpdHkocDogc3RyaW5nKTogUHJpb3JpdHkge1xuICAgICAgICBjb25zdCB7IHByaW9yaXR5U3ltYm9scyB9ID0gdGhpcy5zeW1ib2xzO1xuICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgIGNhc2UgcHJpb3JpdHlTeW1ib2xzLkxvd2VzdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTG93ZXN0O1xuICAgICAgICAgICAgY2FzZSBwcmlvcml0eVN5bWJvbHMuTG93OlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5NZWRpdW06XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgIGNhc2UgcHJpb3JpdHlTeW1ib2xzLkhpZ2g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5LkhpZ2g7XG4gICAgICAgICAgICBjYXNlIHByaW9yaXR5U3ltYm9scy5IaWdoZXN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmlvcml0eS5IaWdoZXN0O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuTm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIFBhcnNlIFRhc2tEZXRhaWxzIGZyb20gdGhlIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgYSB7QGxpbmsgVGFza31cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Rhc2tEZXRhaWxzfVxuICAgICAqL1xuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShsaW5lOiBzdHJpbmcpOiBUYXNrRGV0YWlscyB7XG4gICAgICAgIGNvbnN0IHsgVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucyB9ID0gdGhpcy5zeW1ib2xzO1xuXG4gICAgICAgIC8vIEtlZXAgbWF0Y2hpbmcgYW5kIHJlbW92aW5nIHNwZWNpYWwgc3RyaW5ncyBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGRlc2NyaXB0aW9uIGluIGFueSBvcmRlci4gVGhlIGxvb3Agc2hvdWxkIG9ubHkgcnVuIG9uY2UgaWYgdGhlXG4gICAgICAgIC8vIHN0cmluZ3MgYXJlIGluIHRoZSBleHBlY3RlZCBvcmRlciBhZnRlciB0aGUgZGVzY3JpcHRpb24uXG4gICAgICAgIGxldCBtYXRjaGVkOiBib29sZWFuO1xuICAgICAgICBsZXQgcHJpb3JpdHk6IFByaW9yaXR5ID0gUHJpb3JpdHkuTm9uZTtcbiAgICAgICAgbGV0IHN0YXJ0RGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGR1ZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgZG9uZURhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgY3JlYXRlZERhdGU6IE1vbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZVJ1bGU6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgcmVjdXJyZW5jZTogUmVjdXJyZW5jZSB8IG51bGwgPSBudWxsO1xuICAgICAgICAvLyBUYWdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSB0aGUgZW5kIHdoaWxlIHBhcnNpbmcsIGJ1dCB3ZSB3YW50IHRvIGFkZCB0aGVtIGJhY2sgZm9yIGJlaW5nIHBhcnQgb2YgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAgICAvLyBJbiB0aGUgb3JpZ2luYWwgdGFzayBkZXNjcmlwdGlvbiB0aGV5IGFyZSBwb3NzaWJseSBtaXhlZCB3aXRoIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgLy8gKGUuZy4gI3RhZzEgPGR1ZSBkYXRlPiAjdGFnMiksIHRoZXkgZG8gbm90IGhhdmUgdG8gYWxsIHRyYWlsIGFsbCB0YXNrIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIGJ1dCBldmVudHVhbGx5IHdlIHdhbnQgdG8gcGFzdGUgdGhlbSBiYWNrIHRvIHRoZSB0YXNrIGRlc2NyaXB0aW9uIGF0IHRoZSBlbmRcbiAgICAgICAgbGV0IHRyYWlsaW5nVGFncyA9ICcnO1xuICAgICAgICAvLyBBZGQgYSBcIm1heCBydW5zXCIgZmFpbHNhZmUgdG8gbmV2ZXIgZW5kIGluIGFuIGVuZGxlc3MgbG9vcDpcbiAgICAgICAgY29uc3QgbWF4UnVucyA9IDIwO1xuICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5TWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMucHJpb3JpdHlSZWdleCk7XG4gICAgICAgICAgICBpZiAocHJpb3JpdHlNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gdGhpcy5wYXJzZVByaW9yaXR5KHByaW9yaXR5TWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5wcmlvcml0eVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkb25lRGF0ZU1hdGNoID0gbGluZS5tYXRjaChUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmRvbmVEYXRlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKGRvbmVEYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkb25lRGF0ZSA9IHdpbmRvdy5tb21lbnQoZG9uZURhdGVNYXRjaFsxXSwgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuZG9uZURhdGVSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHVlRGF0ZU1hdGNoID0gbGluZS5tYXRjaChUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmR1ZURhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoZHVlRGF0ZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZHVlRGF0ZSA9IHdpbmRvdy5tb21lbnQoZHVlRGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5kdWVEYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZERhdGVNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5zY2hlZHVsZWREYXRlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZERhdGVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUgPSB3aW5kb3cubW9tZW50KHNjaGVkdWxlZERhdGVNYXRjaFsxXSwgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFRhc2tGb3JtYXRSZWd1bGFyRXhwcmVzc2lvbnMuc2NoZWR1bGVkRGF0ZVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGFydERhdGVNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5zdGFydERhdGVSZWdleCk7XG4gICAgICAgICAgICBpZiAoc3RhcnREYXRlTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUgPSB3aW5kb3cubW9tZW50KHN0YXJ0RGF0ZU1hdGNoWzFdLCBUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5zdGFydERhdGVSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlZERhdGVNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5jcmVhdGVkRGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChjcmVhdGVkRGF0ZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZERhdGUgPSB3aW5kb3cubW9tZW50KGNyZWF0ZWREYXRlTWF0Y2hbMV0sIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLmNyZWF0ZWREYXRlUmVnZXgsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlY3VycmVuY2VNYXRjaCA9IGxpbmUubWF0Y2goVGFza0Zvcm1hdFJlZ3VsYXJFeHByZXNzaW9ucy5yZWN1cnJlbmNlUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHJlY3VycmVuY2VNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJlY3VycmVuY2UgcnVsZSwgYnV0ICpkbyBub3QgcGFyc2UgaXQgeWV0Ki5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyB0aGUgUmVjdXJyZW5jZSBvYmplY3QgcmVxdWlyZXMgYSByZWZlcmVuY2UgZGF0ZSAoZS5nLiBhIGR1ZSBkYXRlKSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXQgbWlnaHQgYXBwZWFyIGluIHRoZSBuZXh0IChlYXJsaWVyIGluIHRoZSBsaW5lKSB0b2tlbnMgdG8gcGFyc2VcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZSA9IHJlY3VycmVuY2VNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zLnJlY3VycmVuY2VSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggdGFncyBmcm9tIHRoZSBlbmQgdG8gYWxsb3cgdXNlcnMgdG8gbWl4IHRoZSB2YXJpb3VzIHRhc2sgY29tcG9uZW50cyB3aXRoXG4gICAgICAgICAgICAvLyB0YWdzLiBUaGVzZSB0YWdzIHdpbGwgYmUgYWRkZWQgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gYmVsb3dcbiAgICAgICAgICAgIGNvbnN0IHRhZ3NNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5oYXNoVGFnc0Zyb21FbmQpO1xuICAgICAgICAgICAgaWYgKHRhZ3NNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmhhc2hUYWdzRnJvbUVuZCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFnc01hdGNoWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIGxlZnQgYmVjYXVzZSB0aGUgbWF0Y2hpbmcgaXMgZG9uZSByaWdodC10by1sZWZ0XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdUYWdzID0gdHJhaWxpbmdUYWdzLmxlbmd0aCA+IDAgPyBbdGFnTmFtZSwgdHJhaWxpbmdUYWdzXS5qb2luKCcgJykgOiB0YWdOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBydW5zKys7XG4gICAgICAgIH0gd2hpbGUgKG1hdGNoZWQgJiYgcnVucyA8PSBtYXhSdW5zKTtcblxuICAgICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGFsbCB0aGUgdGFzayBkZXRhaWxzLCBwYXJzZSB0aGUgcmVjdXJyZW5jZSBydWxlIGlmIHdlIGZvdW5kIGFueVxuICAgICAgICBpZiAocmVjdXJyZW5jZVJ1bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVjdXJyZW5jZSA9IFJlY3VycmVuY2UuZnJvbVRleHQoe1xuICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogcmVjdXJyZW5jZVJ1bGUsXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBiYWNrIGFueSB0cmFpbGluZyB0YWdzIHRvIHRoZSBkZXNjcmlwdGlvbi4gV2UgcmVtb3ZlZCB0aGVtIHNvIHdlIGNhbiBwYXJzZSB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50cyBidXQgbm93IHdlIHdhbnQgdGhlbSBiYWNrLlxuICAgICAgICAvLyBUaGUgZ29hbCBpcyBmb3IgYSB0YXNrIG9mIHRoZW0gZm9ybSAnRG8gc29tZXRoaW5nICN0YWcxIChkdWUpIHRvbW9ycm93ICN0YWcyIChzdGFydCkgdG9kYXknXG4gICAgICAgIC8vIHRvIGFjdHVhbGx5IGhhdmUgdGhlIGRlc2NyaXB0aW9uICdEbyBzb21ldGhpbmcgI3RhZzEgI3RhZzInXG4gICAgICAgIGlmICh0cmFpbGluZ1RhZ3MubGVuZ3RoID4gMCkgbGluZSArPSAnICcgKyB0cmFpbGluZ1RhZ3M7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBsaW5lLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgZG9uZURhdGUsXG4gICAgICAgICAgICByZWN1cnJlbmNlLFxuICAgICAgICAgICAgdGFnczogVGFzay5leHRyYWN0SGFzaHRhZ3MobGluZSksXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFza0xheW91dCwgVGFza0xheW91dENvbXBvbmVudCB9IGZyb20gJy4uL1Rhc2tMYXlvdXQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBQcmlvcml0eSB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgRGVmYXVsdFRhc2tTZXJpYWxpemVyIH0gZnJvbSAnLi9EZWZhdWx0VGFza1NlcmlhbGl6ZXInO1xuXG4vKipcbiAqIFRha2VzIGEgcmVnZXggb2YgdGhlIGZvcm0gJ2tleTo6IHZhbHVlJyBhbmQgdHVybnMgaXQgaW50byBhIHJlZ2V4IHRoYXQgY2FuIHBhcnNlXG4gKiBEYXRhdmlldyBpbmxpbmUgZmllbGQsIGkuZSBlaXRoZXI7XG4gKiAgICAgKiAoa2V5OjogdmFsdWUpXG4gKiAgICAgKiBba2V5OjogdmFsdWVdXG4gKlxuICogVGhlcmUgY2FuIGJlIGFuIGFyYml0cmFyeSBhbW91bnQgb2YgaG9yaXpvbnRhbCB3aGl0ZXNwYWNlIGFyb3VuZCB0aGUga2V5IHZhbHVlIHBhaXIsXG4gKiBhbmQgYWZ0ZXIgdGhlICc6OidcbiAqL1xuZnVuY3Rpb24gdG9JbmxpbmVGaWVsZFJlZ2V4KGlubmVyRmllbGRSZWdleDogUmVnRXhwKTogUmVnRXhwIHtcbiAgICAvKipcbiAgICAgKiBGaXJzdCwgSSdtIHNvcnJ5IHRoaXMgbG9va3Mgc28gYmFkLiBKYXZhc2NyaXB0J3MgcmVnZXggZW5naW5lIGxhY2tzIHNvbWVcbiAgICAgKiBjb252ZW5pZW5jZXMgZnJvbSBvdGhlciBlbmdpbmVzIGxpa2UgUENSRSAoZHVwbGljYXRlIG5hbWVkIGdyb3VwcylcbiAgICAgKiB0aGF0IHdvdWxkJ3ZlIG1hZGUgdGhpcyBlYXNpZXIgdG8gZXhwcmVzcyBpbiBhIHJlYWRhYmxlIHdheS5cbiAgICAgKlxuICAgICAqIFRoZSBpZGVhIGhlcmUgaXMgdGhhdCB3ZSdyZSB0cnlpbmcgdG8gc2F5LCBpbiBFbmdsaXNoOlxuICAgICAqXG4gICAgICogICAgIFwie0BsaW5rIGlubmVyRmllbGRSZWdleH0gY2FuIGVpdGhlciBiZSBzdXJyb3VuZGVkIGJ5IHNxdWFyZSBicmFja2V0cyBgW11gXG4gICAgICogICAgIG9yIHBhcmVucyBgKClgXCJcbiAgICAgKlxuICAgICAqIEJ1dCB0aGVyZSBpcyBhZGRlZCBjb21wbGV4aXR5IGJlY2F1c2Ugd2Ugd2FudCB0byBkaXNhbGxvdyBtaXNtYXRjaGVkIHBhaXJzXG4gICAgICogICAoaS5lLiBubyBgW2tleTo6dmFsdWUpIG9yIChrZXk6OnZhbHVlXWApLiBBbmQgd2UgaGF2ZSB0byB0YWtlIGNhcmUgdG8gbm90XG4gICAgICogaW50cm9kdWNlIG5ldyBjYXB0dXJlIGdyb3Vwcywgc2luY2UgaW5uZXJGaWVsZFJlZ2V4IG1heSBjb250YWluIGNhcHR1cmUgZ3JvdXBzXG4gICAgICogYW5kIGRlcGVuZCBvbiB0aGUgbnVtYmVyaW5nLlxuICAgICAqXG4gICAgICogV2UgYWNoaWV2ZSB0aGlzIGJ5IHVzaW5nIGEgdmFyaWFibGUgbGVuZ3RoLCBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gYXNzZXJ0XG4gICAgICogXCJPbmx5IG1hdGNoIGEgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHBhaXIgaWYgdGhlIG90aGVyIGVsZW1lbnQgaXMgc29tZXdoZXJlIGZ1cnRoZXIgaW4gdGhlIHN0cmluZ1wiLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBsaWtlbHkgc29tZXdoYXQgZnJhZ2lsZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IGZpZWxkUmVnZXggPSAoXG4gICAgICAgIFtcbiAgICAgICAgICAgICcoPzonLFxuICAgICAgICAgICAgLyogICAgICovIC8oPz1bXlxcXV0rXFxdKVxcWy8sIC8vIFRyeSB0byBtYXRjaCAnWycgaWYgdGhlcmUncyBhICddJyBsYXRlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAvKiAgICAqLyAnfCcsXG4gICAgICAgICAgICAvKiAgICAgKi8gLyg/PVteKV0rXFwpKVxcKC8sIC8vIE90aGVyd2lzZSwgbWF0Y2ggJygnIGlmIHRoZXJlJ3MgYSAnKScgbGF0ZXIgaW4gdGhlIHN0cmluZ1xuICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgLyAqLyxcbiAgICAgICAgICAgIGlubmVyRmllbGRSZWdleCxcbiAgICAgICAgICAgIC8gKi8sXG4gICAgICAgICAgICAvWylcXF1dLyxcbiAgICAgICAgICAgIC8oPzogKiwpPy8sIC8vIEFsbG93IHRyYWlsaW5nIGNvbW1hLCBlbmFibGVzIHdvcmthcm91bmQgZnJvbSAjMTkxMyBmb3IgcmVuZGVyaW5nIGlzc3VlXG4gICAgICAgICAgICAvJC8sIC8vIFJlZ2V4ZXMgYXJlIG1hdGNoZWQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgZm9yd2FyZHNcbiAgICAgICAgXSBhcyBjb25zdFxuICAgIClcbiAgICAgICAgLm1hcCgodmFsKSA9PiAodmFsIGluc3RhbmNlb2YgUmVnRXhwID8gdmFsLnNvdXJjZSA6IHZhbCkpXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmaWVsZFJlZ2V4LCBpbm5lckZpZWxkUmVnZXguZmxhZ3MpO1xufVxuXG4vKipcbiAqIEEgc3ltYm9sIG1hcCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgdGFzayBmb3JtYXQgdGhhdCBzdHJpdmVzIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogICBbRGF0YXZpZXdde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGFja3NtaXRoZ3Uvb2JzaWRpYW4tZGF0YXZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCBEQVRBVklFV19TWU1CT0xTID0ge1xuICAgIHByaW9yaXR5U3ltYm9sczoge1xuICAgICAgICBIaWdoZXN0OiAncHJpb3JpdHk6OiBoaWdoZXN0JyxcbiAgICAgICAgSGlnaDogJ3ByaW9yaXR5OjogaGlnaCcsXG4gICAgICAgIE1lZGl1bTogJ3ByaW9yaXR5OjogbWVkaXVtJyxcbiAgICAgICAgTG93OiAncHJpb3JpdHk6OiBsb3cnLFxuICAgICAgICBMb3dlc3Q6ICdwcmlvcml0eTo6IGxvd2VzdCcsXG4gICAgICAgIE5vbmU6ICcnLFxuICAgIH0sXG4gICAgc3RhcnREYXRlU3ltYm9sOiAnc3RhcnQ6OicsXG4gICAgY3JlYXRlZERhdGVTeW1ib2w6ICdjcmVhdGVkOjonLFxuICAgIHNjaGVkdWxlZERhdGVTeW1ib2w6ICdzY2hlZHVsZWQ6OicsXG4gICAgZHVlRGF0ZVN5bWJvbDogJ2R1ZTo6JyxcbiAgICBkb25lRGF0ZVN5bWJvbDogJ2NvbXBsZXRpb246OicsXG4gICAgcmVjdXJyZW5jZVN5bWJvbDogJ3JlcGVhdDo6JyxcbiAgICBUYXNrRm9ybWF0UmVndWxhckV4cHJlc3Npb25zOiB7XG4gICAgICAgIHByaW9yaXR5UmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvcHJpb3JpdHk6OiAqKGhpZ2hlc3R8aGlnaHxtZWRpdW18bG93fGxvd2VzdCkvKSxcbiAgICAgICAgc3RhcnREYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvc3RhcnQ6OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBjcmVhdGVkRGF0ZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL2NyZWF0ZWQ6OiAqKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pLFxuICAgICAgICBzY2hlZHVsZWREYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvc2NoZWR1bGVkOjogKihcXGR7NH0tXFxkezJ9LVxcZHsyfSkvKSxcbiAgICAgICAgZHVlRGF0ZVJlZ2V4OiB0b0lubGluZUZpZWxkUmVnZXgoL2R1ZTo6ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pLyksXG4gICAgICAgIGRvbmVEYXRlUmVnZXg6IHRvSW5saW5lRmllbGRSZWdleCgvY29tcGxldGlvbjo6ICooXFxkezR9LVxcZHsyfS1cXGR7Mn0pLyksXG4gICAgICAgIHJlY3VycmVuY2VSZWdleDogdG9JbmxpbmVGaWVsZFJlZ2V4KC9yZXBlYXQ6OiAqKFthLXpBLVowLTksICFdKykvKSxcbiAgICB9LFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBIHtAbGluayBUYXNrU2VyaWFsaXplcn0gdGhhdCB0aGF0IHJlYWRzIGFuZCB3cml0ZXMgdGFza3MgY29tcGF0aWJsZSB3aXRoXG4gKiAgIFtEYXRhdmlld117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2JsYWNrc21pdGhndS9vYnNpZGlhbi1kYXRhdmlld31cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGF2aWV3VGFza1NlcmlhbGl6ZXIgZXh0ZW5kcyBEZWZhdWx0VGFza1NlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihEQVRBVklFV19TWU1CT0xTKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VQcmlvcml0eShwOiBzdHJpbmcpOiBQcmlvcml0eSB7XG4gICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgY2FzZSAnaGlnaGVzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5LkhpZ2hlc3Q7XG4gICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJpb3JpdHkuSGlnaDtcbiAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5LkxvdztcbiAgICAgICAgICAgIGNhc2UgJ2xvd2VzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lkxvd2VzdDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByaW9yaXR5Lk5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50VG9TdHJpbmcodGFzazogVGFzaywgbGF5b3V0OiBUYXNrTGF5b3V0LCBjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nQ29tcG9uZW50ID0gc3VwZXIuY29tcG9uZW50VG9TdHJpbmcodGFzaywgbGF5b3V0LCBjb21wb25lbnQpO1xuICAgICAgICBjb25zdCBub3RJbmxpbmVGaWVsZENvbXBvbmVudHM6IFRhc2tMYXlvdXRDb21wb25lbnRbXSA9IFsnYmxvY2tMaW5rJywgJ2Rlc2NyaXB0aW9uJ107XG4gICAgICAgIGNvbnN0IHNob3VsZE1ha2VJbmxpbmVGaWVsZCA9IHN0cmluZ0NvbXBvbmVudCAhPT0gJycgJiYgIW5vdElubGluZUZpZWxkQ29tcG9uZW50cy5pbmNsdWRlcyhjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gc2hvdWxkTWFrZUlubGluZUZpZWxkXG4gICAgICAgICAgICA/IC8vIEhhdmluZyAyIChUV08pIGxlYWRpbmcgc3BhY2VzIGF2b2lkcyBhIHJlbmRlcmluZyBpc3N1ZXMgdGhhdCBtYWtlcyBldmVyeSBvdGhlclxuICAgICAgICAgICAgICAvLyBzcXVhcmUtYnJhY2tldGVkIGlubGluZS1maWVsZCBpbnZpc2libGUuXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzE5MTNcbiAgICAgICAgICAgICAgYCAgWyR7c3RyaW5nQ29tcG9uZW50LnRyaW0oKX1dYFxuICAgICAgICAgICAgOiBzdHJpbmdDb21wb25lbnQ7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQ29sbGVjdGlvbiBvZiBzdGF0dXMgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBwbHVnaW4uXG4gKi9cbmV4cG9ydCBlbnVtIFN0YXR1c1R5cGUge1xuICAgIFRPRE8gPSAnVE9ETycsXG4gICAgRE9ORSA9ICdET05FJyxcbiAgICBJTl9QUk9HUkVTUyA9ICdJTl9QUk9HUkVTUycsXG4gICAgQ0FOQ0VMTEVEID0gJ0NBTkNFTExFRCcsXG4gICAgTk9OX1RBU0sgPSAnTk9OX1RBU0snLFxuICAgIEVNUFRZID0gJ0VNUFRZJyxcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBvYmplY3Qgc3RvcmVkIGJ5IHRoZSBPYnNpZGlhbiBjb25maWd1cmF0aW9uIGFuZCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RhdHVzXG4gKiBvYmplY3RzIGZvciB0aGUgc2Vzc2lvblxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNDb25maWd1cmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcmFjdGVyIHVzZWQgYmV0d2VlbiB0aGUgdHdvIHNxdWFyZSBicmFja2V0cyBpbiB0aGUgbWFya2Rvd24gdGFzay5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBzeW1ib2w6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHN0YXR1cyBmb3IgZGlzcGxheSBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHN0YXR1cyBmb3IgYSB0YXNrIHdoZW4gdG9nZ2xlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBuZXh0U3RhdHVzU3ltYm9sOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZW4gaXQgaXMgcmVnaXN0ZXJlZCBhcyBhIGNvbW1hbmQgdGhhdCB0aGUgdXNlciBjYW4gbWFwIHRvLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBhdmFpbGFibGVBc0NvbW1hbmQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgdHlwZS4gU2VlIHtAbGluayBTdGF0dXNUeXBlfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogU3RhdHVzVHlwZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3RhdHVzLiBUaGUgcmVnaXN0cnkgd2lsbCBiZSBhZGRlZCBsYXRlciBpbiB0aGUgY2FzZVxuICAgICAqIG9mIHRoZSBkZWZhdWx0IHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IG5leHRTdGF0dXNTeW1ib2xcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF2YWlsYWJsZUFzQ29tbWFuZFxuICAgICAqIEBwYXJhbSB7U3RhdHVzVHlwZX0gdHlwZVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc3ltYm9sOiBzdHJpbmcsXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgbmV4dFN0YXR1c1N5bWJvbDogc3RyaW5nLFxuICAgICAgICBhdmFpbGFibGVBc0NvbW1hbmQ6IGJvb2xlYW4sXG4gICAgICAgIHR5cGU6IFN0YXR1c1R5cGUgPSBTdGF0dXNUeXBlLlRPRE8sIC8vIFRPRE8gUmVtb3ZlIGRlZmF1bHQgdmFsdWVcbiAgICApIHtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubmV4dFN0YXR1c1N5bWJvbCA9IG5leHRTdGF0dXNTeW1ib2w7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlQXNDb21tYW5kID0gYXZhaWxhYmxlQXNDb21tYW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbkVudHJ5IH0gZnJvbSAnLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBUcmFja3MgdGhlIHBvc3NpYmxlIHN0YXRlcyB0aGF0IGEgdGFzayBjYW4gYmUgaW4uXG4gKlxuICogUmVsYXRlZCBjbGFzc2VzOlxuICogQHNlZSBTdGF0dXNDb25maWd1cmF0aW9uXG4gKiBAc2VlIFN0YXR1c1JlZ2lzdHJ5XG4gKiBAc2VlIFN0YXR1c1NldHRpbmdzXG4gKiBAc2VlIFN0YXR1c1NldHRpbmdzSGVscGVycy50c1xuICogQHNlZSBDdXN0b21TdGF0dXNNb2RhbFxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgRG9uZSBzdGF0dXMuIEdvZXMgdG8gVG9kbyB3aGVuIHRvZ2dsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBET05FOiBTdGF0dXMgPSBTdGF0dXMubWFrZURvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBzdGF0dXMgb2YgZW1wdHksIHVzZWQgd2hlbiB0aGluZ3MgZ28gd3JvbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgRU1QVFk6IFN0YXR1cyA9IFN0YXR1cy5tYWtlRW1wdHkoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IFRvZG8gc3RhdHVzLiBHb2VzIHRvIERvbmUgd2hlbiB0b2dnbGVkLlxuICAgICAqIFVzZXIgbWF5IGxhdGVyIGJlIGFibGUgdG8gb3ZlcnJpZGUgdGhpcyB0byBnbyB0byBJbiBQcm9ncmVzcyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVE9ETzogU3RhdHVzID0gU3RhdHVzLm1ha2VUb2RvKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBzdG9yZWQgaW4gdGhlIGRhdGEuanNvbiBmaWxlLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0YXR1c0NvbmZpZ3VyYXRpb259XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBjb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCB1c2VkIGJldHdlZW4gdGhlIHR3byBzcXVhcmUgYnJhY2tldHMgaW4gdGhlIG1hcmtkb3duIHRhc2suXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN5bWJvbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnN5bWJvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBzdGF0dXMgZm9yIGRpc3BsYXkgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgc3RhdHVzIGZvciBhIHRhc2sgd2hlbiB0b2dnbGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICogQHNlZSBuZXh0U3ltYm9sXG4gICAgICovXG4gICAgcHVibGljIGdldCBuZXh0U3RhdHVzU3ltYm9sKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHN0YXR1cyBmb3IgYSB0YXNrIHdoZW4gdG9nZ2xlZC5cbiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgbmV4dFN0YXR1c1N5bWJvbH0gd2hpY2ggaXMgcHJvdmlkZWQgZm9yIGJyZXZpdHkgaW4gdXNlciBzY3JpcHRzLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICogQHNlZSBuZXh0U3RhdHVzU3ltYm9sXG4gICAgICovXG4gICAgcHVibGljIGdldCBuZXh0U3ltYm9sKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZW4gaXQgaXMgcmVnaXN0ZXJlZCBhcyBhIGNvbW1hbmQgdGhhdCB0aGUgdXNlciBjYW4gbWFwIHRvLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXZhaWxhYmxlQXNDb21tYW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmF2YWlsYWJsZUFzQ29tbWFuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgdHlwZS4gU2VlIHtAbGluayBTdGF0dXNUeXBlfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogU3RhdHVzVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN0YXR1cy4gVGhlIHJlZ2lzdHJ5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhlIGNhc2VcbiAgICAgKiBvZiB0aGUgZGVmYXVsdCBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RhdHVzQ29uZmlndXJhdGlvbn0gY29uZmlndXJhdGlvblxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgRG9uZSBzdGF0dXMuIEdvZXMgdG8gVG9kbyB3aGVuIHRvZ2dsZWQuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VEb25lKCk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKCd4JywgJ0RvbmUnLCAnICcsIHRydWUsIFN0YXR1c1R5cGUuRE9ORSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBzdGF0dXMgb2YgZW1wdHksIHVzZWQgd2hlbiB0aGluZ3MgZ28gd3JvbmcuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VFbXB0eSgpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignJywgJ0VNUFRZJywgJycsIHRydWUsIFN0YXR1c1R5cGUuRU1QVFkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBUb2RvIHN0YXR1cy4gR29lcyB0byBEb25lIHdoZW4gdG9nZ2xlZC5cbiAgICAgKiBVc2VyIG1heSBsYXRlciBiZSBhYmxlIHRvIG92ZXJyaWRlIHRoaXMgdG8gZ28gdG8gSW4gUHJvZ3Jlc3MgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZVRvZG8oKTogU3RhdHVzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXMobmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJyAnLCAnVG9kbycsICd4JywgdHJ1ZSwgU3RhdHVzVHlwZS5UT0RPKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgQ2FuY2VsbGVkIHN0YXR1cy4gR29lcyB0byBUb2RvIHdoZW4gdG9nZ2xlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZUNhbmNlbGxlZCgpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignLScsICdDYW5jZWxsZWQnLCAnICcsIHRydWUsIFN0YXR1c1R5cGUuQ0FOQ0VMTEVEKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgSW4gUHJvZ3Jlc3Mgc3RhdHVzLiBHb2VzIHRvIERvbmUgd2hlbiB0b2dnbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYWtlSW5Qcm9ncmVzcygpOiBTdGF0dXMge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbignLycsICdJbiBQcm9ncmVzcycsICd4JywgdHJ1ZSwgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgU3RhdHVzVHlwZSB0byB1c2UgZm9yIGEgc3ltYm9sLCBpZiBpdCBpcyBub3QgaW4gdGhlIFN0YXR1c1JlZ2lzdHJ5LlxuICAgICAqIFRoZSBjb3JlIHN5bWJvbHMgYXJlIHJlY29nbmlzZWQuXG4gICAgICogT3RoZXIgc3ltYm9scyBhcmUgdHJlYXRlZCBhcyBTdGF0dXNUeXBlLlRPRE9cbiAgICAgKiBAcGFyYW0gc3ltYm9sXG4gICAgICovXG4gICAgc3RhdGljIGdldFR5cGVGb3JVbmtub3duU3ltYm9sKHN5bWJvbDogc3RyaW5nKTogU3RhdHVzVHlwZSB7XG4gICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLkRPTkU7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzVHlwZS5JTl9QUk9HUkVTUztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXNUeXBlLkNBTkNFTExFRDtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGUuRU1QVFk7XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1c1R5cGUuVE9ETztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGV4dCB0aGF0IHdhcyBzYXZlZCBmcm9tIGEgU3RhdHVzVHlwZSB2YWx1ZSBiYWNrIHRvIGEgU3RhdHVzVHlwZS5cbiAgICAgKiBSZXR1cm5zIFN0YXR1c1R5cGUuVE9ETyBpZiB0aGUgc3RyaW5nIGlzIG5vdCB2YWxpZC5cbiAgICAgKiBAcGFyYW0gc3RhdHVzVHlwZUFzU3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGdldFR5cGVGcm9tU3RhdHVzVHlwZVN0cmluZyhzdGF0dXNUeXBlQXNTdHJpbmc6IHN0cmluZyk6IFN0YXR1c1R5cGUge1xuICAgICAgICByZXR1cm4gU3RhdHVzVHlwZVtzdGF0dXNUeXBlQXNTdHJpbmcgYXMga2V5b2YgdHlwZW9mIFN0YXR1c1R5cGVdIHx8IFN0YXR1c1R5cGUuVE9ETztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdGF0dXMgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiwgdW5rbm93biBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBTdGF0dXNSZWdpc3RyeSBkb2VzIG5vdCByZWNvZ25pc2UgYSBzeW1ib2wsXG4gICAgICogYW5kIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgdXNlcidzIGRhdGEgdG8gdGhlIFN0YXR1cy5FTVBUWSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHlwZSBpcyBzZXQgdG8gVE9ETy5cbiAgICAgKiBAcGFyYW0gdW5rbm93blN5bWJvbFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVVbmtub3duU3RhdHVzKHVua25vd25TeW1ib2w6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhuZXcgU3RhdHVzQ29uZmlndXJhdGlvbih1bmtub3duU3ltYm9sLCAnVW5rbm93bicsICd4JywgZmFsc2UsIFN0YXR1c1R5cGUuVE9ETykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYnVsay1pbXBvcnRpbmcgc2V0dGluZ3MgZnJvbSBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbXBvcnRlZCBBbiBhcnJheSBvZiBzeW1ib2wsIG5hbWUsIG5leHQgc3ltYm9sLCBzdGF0dXMgdHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tSW1wb3J0ZWRWYWx1ZShpbXBvcnRlZDogU3RhdHVzQ29sbGVjdGlvbkVudHJ5KSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGltcG9ydGVkWzBdO1xuICAgICAgICBjb25zdCB0eXBlID0gU3RhdHVzLmdldFR5cGVGcm9tU3RhdHVzVHlwZVN0cmluZyhpbXBvcnRlZFszXSk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKHN5bWJvbCwgaW1wb3J0ZWRbMV0sIGltcG9ydGVkWzJdLCBmYWxzZSwgdHlwZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBsZXRpb24gc3RhdHVzIGZvciBhIHRhc2ssIHRoaXMgaXMgb25seSBzdXBwb3J0ZWRcbiAgICAgKiB3aGVuIHRoZSB0YXNrIGlzIGRvbmUveC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGlzQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTdGF0dXNUeXBlLkRPTkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBhbGwgdGhlIGZpZWxkcyBpbiBhbm90aGVyIFN0YXR1cywgdG8gZGV0ZWN0IGFueSBkaWZmZXJlbmNlcyBmcm9tIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogSWYgYW55IGZpZWxkIGlzIGRpZmZlcmVudCBpbiBhbnkgd2F5LCBpdCB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlclxuICAgICAqL1xuICAgIHB1YmxpYyBpZGVudGljYWxUbyhvdGhlcjogU3RhdHVzKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IEFycmF5PGtleW9mIFN0YXR1c0NvbmZpZ3VyYXRpb24+ID0gW1xuICAgICAgICAgICAgJ3N5bWJvbCcsXG4gICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAnbmV4dFN0YXR1c1N5bWJvbCcsXG4gICAgICAgICAgICAnYXZhaWxhYmxlQXNDb21tYW5kJyxcbiAgICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tlbF0gIT09IG90aGVyW2VsXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG9uZS1saW5lIHN1bW1hcnkgb2YgdGhlIHN0YXR1cywgZm9yIHByZXNlbnRhdGlvbiB0byB1c2Vycy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcHJldmlld1RleHQoKSB7XG4gICAgICAgIGxldCBjb21tYW5kTm90aWNlID0gJyc7XG4gICAgICAgIGlmIChTdGF0dXMudGFza3NQbHVnaW5DYW5DcmVhdGVDb21tYW5kc0ZvclN0YXR1c2VzKCkgJiYgdGhpcy5hdmFpbGFibGVBc0NvbW1hbmQpIHtcbiAgICAgICAgICAgIGNvbW1hbmROb3RpY2UgPSAnIEF2YWlsYWJsZSBhcyBhIGNvbW1hbmQuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYC0gWyR7dGhpcy5zeW1ib2x9XWAgKyAvLyBjb21tZW50IHRvIGJyZWFrIGxpbmVcbiAgICAgICAgICAgIGAgPT4gWyR7dGhpcy5uZXh0U3RhdHVzU3ltYm9sfV0sYCArXG4gICAgICAgICAgICBgIG5hbWU6ICcke3RoaXMubmFtZX0nLGAgK1xuICAgICAgICAgICAgYCB0eXBlOiAnJHt0aGlzLmNvbmZpZ3VyYXRpb24udHlwZX0nLmAgK1xuICAgICAgICAgICAgYCR7Y29tbWFuZE5vdGljZX1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBUYXNrcyBjYW4geWV0IGNyZWF0ZSAnVG9nZ2xlIFN0YXR1cycgY29tbWFuZHMgZm9yIHN0YXR1c2VzXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5vdCB5ZXQgcG9zc2libGUsIGFuZCBzbyBzb21lIFVJIGZlYXR1cmVzIGFyZSB0ZW1wb3JhcmlseSBoaWRkZW4uXG4gICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbi10YXNrcy1ncm91cC9vYnNpZGlhbi10YXNrcy9pc3N1ZXMvMTQ4NlxuICAgICAqIE9uY2UgdGhhdCBpc3N1ZSBpcyBhZGRyZXNzZWQsIHRoaXMgbWV0aG9kIGNhbiBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdGFza3NQbHVnaW5DYW5DcmVhdGVDb21tYW5kc0ZvclN0YXR1c2VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBEZWJ1Z1NldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcihpZ25vcmVTb3J0SW5zdHJ1Y3Rpb25zID0gZmFsc2UsIHNob3dUYXNrSGlkZGVuRGF0YSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaWdub3JlU29ydEluc3RydWN0aW9ucyA9IGlnbm9yZVNvcnRJbnN0cnVjdGlvbnM7XG4gICAgICAgIHRoaXMuc2hvd1Rhc2tIaWRkZW5EYXRhID0gc2hvd1Rhc2tIaWRkZW5EYXRhO1xuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgZGlzYWJsZSBhbGwgc29ydGluZyBvZiBzZWFyY2ggcmVzdWx0cywgc28gdGhhdCB0YXNrcyBhcmVcbiAgICAvLyBkaXNwbGF5ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIHRoZSBmaWxlLlxuICAgIHJlYWRvbmx5IGlnbm9yZVNvcnRJbnN0cnVjdGlvbnM6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgc2hvd1Rhc2tIaWRkZW5EYXRhOiBib29sZWFuO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU3RhdHVzQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1cyc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgZW5jYXBzdWxhdGluZyB0aGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIGN1c3RvbSBzdGF0dXNlcy5cbiAqXG4gKiBNb3N0IG1ldGhvZHMgYXJlIHN0YXRpYyB0byBhbGxvdyB0aGVtIHRvIGJlIGNhbGxlZCBmcm9tIGNhbGwtYmFja3MuXG4gKlxuICogQHNlZSBTdGF0dXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1c1NldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3JlU3RhdHVzZXMgPSBbXG4gICAgICAgICAgICAvLyBUaGUgdHdvIHN0YXR1c2VzIHRoYXQgZG8gbm90IG5lZWQgQ1NTIHN0eWxpbmdcbiAgICAgICAgICAgIFN0YXR1cy5tYWtlVG9kbygpLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICBTdGF0dXMubWFrZURvbmUoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICBdOyAvLyBEbyBub3QgbW9kaWZ5IGRpcmVjdGx5OiB1c2UgdGhlIHN0YXRpYyBtdXRhdGlvbiBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gICAgICAgIHRoaXMuY3VzdG9tU3RhdHVzZXMgPSBbXG4gICAgICAgICAgICAvLyBBbnkgc3RhdHVzZXMgdGhhdCBhcmUgYWx3YXlzIHN1cHBvcnRlZCwgYnV0IG5lZWQgY3VzdG9tIENTUyBzdHlsaW5nXG4gICAgICAgICAgICBTdGF0dXMubWFrZUluUHJvZ3Jlc3MoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgU3RhdHVzLm1ha2VDYW5jZWxsZWQoKS5jb25maWd1cmF0aW9uLFxuICAgICAgICBdOyAvLyBEbyBub3QgbW9kaWZ5IGRpcmVjdGx5OiB1c2UgdGhlIHN0YXRpYyBtdXRhdGlvbiBtZXRob2RzIGluIHRoaXMgY2xhc3MuXG4gICAgfVxuICAgIHJlYWRvbmx5IGNvcmVTdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdO1xuICAgIHJlYWRvbmx5IGN1c3RvbVN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW107XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgY3VzdG9tIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc3RhdGljIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIG1vZGFsIG9uQ2xpY2soKSBjYWxsLWJhY2tzLlxuICAgICAqXG4gICAgICogLSBDdXJyZW50bHksIGR1cGxpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gICAgICogLSBBbGxvd3MgZW1wdHkgU3RhdHVzQ29uZmlndXJhdGlvbiBvYmplY3RzIC0gd2hlcmUgZXZlcnkgc3RyaW5nIGlzIGVtcHR5XG4gICAgICogQHBhcmFtIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIG5ld1N0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkU3RhdHVzKHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10sIG5ld1N0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbikge1xuICAgICAgICBzdGF0dXNlcy5wdXNoKG5ld1N0YXR1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZ2l2ZW4gc3RhdHVzLCB0byBlZmZlY3RpdmVseSBlZGl0IGl0LlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2V0dGluZ3Mgd2VyZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBzdGF0aWMgc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gbW9kYWwgb25DbGljaygpIGNhbGwtYmFja3MuXG4gICAgICpcbiAgICAgKiAtIERvZXMgbm90IGN1cnJlbnRseSBjaGVjayB3aGV0aGVyIHRoZSBzdGF0dXMgY2hhcmFjdGVyIGlzIHRoZSBzYW1lXG4gICAgICogLSBJZiB0aGUgc3RhdHVzIGNoYXJhY3RlciBpcyBkaWZmZXJlbnQsIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBvbmUgaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgc3RhdHVzXG4gICAgICogQHBhcmFtIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIG9yaWdpbmFsU3RhdHVzXG4gICAgICogQHBhcmFtIG5ld1N0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVwbGFjZVN0YXR1cyhcbiAgICAgICAgc3RhdHVzZXM6IFN0YXR1c0NvbmZpZ3VyYXRpb25bXSxcbiAgICAgICAgb3JpZ2luYWxTdGF0dXM6IFN0YXR1c0NvbmZpZ3VyYXRpb24sXG4gICAgICAgIG5ld1N0YXR1czogU3RhdHVzQ29uZmlndXJhdGlvbixcbiAgICApOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRTdGF0dXNJbmRleChvcmlnaW5hbFN0YXR1cywgc3RhdHVzZXMpO1xuICAgICAgICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXNlcy5zcGxpY2UoaW5kZXgsIDEsIG5ld1N0YXR1cyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgZmFjdCB0aGF0IHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c1R5cGVzLmluZGV4T2Yoc3RhdHVzQ29uZmlndXJhdGlvbilcbiAgICAgKiBzdG9wcGVkIGZpbmRpbmcgaWRlbnRpY2FsIHN0YXR1c2VzIHNpbmNlIHRoZSBhZGRpdGlvbiBvZiBTdGF0dXNDb25maWd1cmF0aW9uLnR5cGUuXG4gICAgICogQHBhcmFtIHN0YXR1c0NvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gc3RhdHVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGZpbmRTdGF0dXNJbmRleChzdGF0dXNDb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uLCBzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdHVzQXNTdGF0dXMgPSBuZXcgU3RhdHVzKHN0YXR1c0NvbmZpZ3VyYXRpb24pO1xuICAgICAgICByZXR1cm4gc3RhdHVzZXMuZmluZEluZGV4KChzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXR1cyhzKS5wcmV2aWV3VGV4dCgpID09IG9yaWdpbmFsU3RhdHVzQXNTdGF0dXMucHJldmlld1RleHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBnaXZlbiBzdGF0dXMuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGRlbGV0ZWQsIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNlc1xuICAgICAqIEBwYXJhbSBzdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVN0YXR1cyhzdGF0dXNlczogU3RhdHVzQ29uZmlndXJhdGlvbltdLCBzdGF0dXM6IFN0YXR1c0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRTdGF0dXNJbmRleChzdGF0dXMsIHN0YXR1c2VzKTtcbiAgICAgICAgaWYgKGluZGV4IDw9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHVzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFsbCBjdXN0b20gc3RhdHVzZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlQWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzKSB7XG4gICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLnNwbGljZSgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBkZWZhdWx0IGN1c3RvbSBzdGF0dXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5nc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVzZXRBbGxDdXN0b21TdGF0dXNlcyhzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3MpIHtcbiAgICAgICAgU3RhdHVzU2V0dGluZ3MuZGVsZXRlQWxsQ3VzdG9tU3RhdHVzZXMoc3RhdHVzU2V0dGluZ3MpO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3MgPSBuZXcgU3RhdHVzU2V0dGluZ3MoKTtcbiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmN1c3RvbVN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLmFkZFN0YXR1cyhzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcywgcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbGxlY3Rpb24gb2YgY3VzdG9tIHN1cHBvcnRlZCBzdGF0dXNlcyB0byBhIFN0YXR1c1NldHRpbmdzLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcXVpY2tseSBwb3B1bGF0ZSB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgICAqIElmIHRoZXJlIGFyZSBhbnkgZXhhY3QgZHVwbGljYXRlcyBhbHJlYWR5IHByZXNlbnQsIHRoZXkgYXJlIHNraXBwZWQsIGFuZCBub3RlZCBpbiB0aGUgcmV0dXJuZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHN0YXRpYyBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBtb2RhbCBvbkNsaWNrKCkgY2FsbC1iYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXNTZXR0aW5ncyBhIFN0YXR1c1NldHRpbmdzXG4gICAgICogQHBhcmFtIHN1cHBvcnRlZFN0YXR1c2VzIC0gYW4gYXJyYXkgb2Ygc3RhdHVzIHNwZWNpZmljYXRpb25zLCBmb3IgZXhhbXBsZSBgWydiJywgJ0Jvb2ttYXJrJywgJ3gnXWBcbiAgICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIHdhcm5pbmcgbWVzc2FnZXMgdG8gc2hvdyB0aGUgdXNlciwgb25lIGZvciBlYWNoIHJlamVjdGVkIGV4YWN0IGR1cGxpY2F0ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtaW5pbWFsU3VwcG9ydGVkU3RhdHVzZXN9LCB7QGxpbmsgaXRzU3VwcG9ydGVkU3RhdHVzZXN9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBidWxrQWRkU3RhdHVzQ29sbGVjdGlvbihcbiAgICAgICAgc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzLFxuICAgICAgICBzdXBwb3J0ZWRTdGF0dXNlczogU3RhdHVzQ29sbGVjdGlvbixcbiAgICApOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IG5vdGljZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIHN1cHBvcnRlZFN0YXR1c2VzLmZvckVhY2goKGltcG9ydGVkU3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGF0dXMgPSBzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcy5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zeW1ib2wgPT0gaW1wb3J0ZWRTdGF0dXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5uYW1lID09IGltcG9ydGVkU3RhdHVzWzFdICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubmV4dFN0YXR1c1N5bWJvbCA9PSBpbXBvcnRlZFN0YXR1c1syXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaGFzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgU3RhdHVzU2V0dGluZ3MuYWRkU3RhdHVzKHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLCBTdGF0dXMuY3JlYXRlRnJvbUltcG9ydGVkVmFsdWUoaW1wb3J0ZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90aWNlcy5wdXNoKGBUaGUgc3RhdHVzICR7aW1wb3J0ZWRTdGF0dXNbMV19ICgke2ltcG9ydGVkU3RhdHVzWzBdfSkgaXMgYWxyZWFkeSBhZGRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub3RpY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBjdXN0b20gc3RhdHVzZXMgaW4gdGhlIHN0YXR1c1NldHRpbmdzIG9iamVjdCB0byB0aGUgc3RhdHVzUmVnaXN0cnkuXG4gICAgICogQHBhcmFtIHN0YXR1c1NldHRpbmdzXG4gICAgICogQHBhcmFtIHN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhcHBseVRvU3RhdHVzUmVnaXN0cnkoc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzLCBzdGF0dXNSZWdpc3RyeTogU3RhdHVzUmVnaXN0cnkpIHtcbiAgICAgICAgc3RhdHVzUmVnaXN0cnkuY2xlYXJTdGF0dXNlcygpO1xuICAgICAgICBzdGF0dXNTZXR0aW5ncy5jb3JlU3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzVHlwZSkgPT4ge1xuICAgICAgICAgICAgc3RhdHVzUmVnaXN0cnkuYWRkKHN0YXR1c1R5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzVHlwZSkgPT4ge1xuICAgICAgICAgICAgc3RhdHVzUmVnaXN0cnkuYWRkKHN0YXR1c1R5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IGZlYXR1cmVzSnNvbiBmcm9tICcuL2ZlYXR1cmVDb25maWd1cmF0aW9uLmpzb24nO1xuXG5leHBvcnQgdHlwZSBGZWF0dXJlRmxhZyA9IHtcbiAgICBbaW50ZXJuYWxOYW1lOiBzdHJpbmddOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBUaGUgRmVhdHVyZSBjbGFzcyB0cmFja3MgYWxsIHRoZSBwb3NzaWJsZSBmZWF0dXJlcyB0aGF0IHVzZXJzIGNhbiBlbmFibGVkIHRoYXQgYXJlIGluIGRldmVsb3BtZW50LiBUaGlzIGFsbG93c1xuICogbmV3IGZlYXR1cmVzIHRvIGJlIGFkZGVkIHRvIHRoZSBwbGF0Zm9ybSBidXQgbm90IGVuYWJsZWQgYnkgZGVmYXVsdC4gVGhpcyByZWR1Y2VzIHRoZSBjb21wbGljYXRpb25zIHdoZW4gaXRcbiAqIGNvbWVzIHRvIGFkZGluZyBuZXcgZmVhdHVyZXMgYW5kIGEgbGFyZ2UgY2FzY2FkZSBvZiBkZXBlbmRlbnQgYnJhbmNoZXMuXG4gKlxuICogV2hlbiB5b3UgYWRkIGEgbmV3IGZlYXR1cmUgeW91IG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBmZWF0dXJlQ29uZmlndXJhdGlvbi5qc29uIGZpbGUuIEl0IHRoZW4gbmVlZHMgdG8gYmUgYWRkZWQgdG9cbiAqIHNldHRpbmdzIHNvIGEgdXNlciBjYW4gZW5hYmxlIGl0LiBJZiB5b3Ugd2FudCBpdCBoaWRkZW4geW91IHdpbGwgbmVlZCB0byBtYW51YWxseSB1cGRhdGUgdGhlIGRhdGEuanNvbiBmaWxlLiBJbiB0aGVcbiAqIHBsdWdpbiBmb2xkZXIuXG4gKlxuICogQHNpbmNlIDIwMjItMDUtMjlcbiAqL1xuZXhwb3J0IGNsYXNzIEZlYXR1cmUge1xuICAgIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBpbnRlcm5hbE5hbWU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGluZGV4OiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZGlzcGxheU5hbWU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGVuYWJsZWRCeURlZmF1bHQ6IGJvb2xlYW4sXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBzdGFibGU6IGJvb2xlYW4sXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGZWF0dXJlW119XG4gICAgICogQG1lbWJlcm9mIEZlYXR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHZhbHVlcygpOiBGZWF0dXJlW10ge1xuICAgICAgICBsZXQgYXZhaWxhYmxlRmVhdHVyZXM6IEZlYXR1cmVbXSA9IFtdO1xuXG4gICAgICAgIGZlYXR1cmVzSnNvbi5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICBhdmFpbGFibGVGZWF0dXJlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5hdmFpbGFibGVGZWF0dXJlcyxcbiAgICAgICAgICAgICAgICBuZXcgRmVhdHVyZShcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5pbnRlcm5hbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZW5hYmxlZEJ5RGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdGFibGUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXZhaWxhYmxlRmVhdHVyZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgZmVhdHVyZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RmVhdHVyZUZsYWd9XG4gICAgICogQG1lbWJlcm9mIEZlYXR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHNldHRpbmdzRmxhZ3MoKTogRmVhdHVyZUZsYWcge1xuICAgICAgICBjb25zdCBmZWF0dXJlRmxhZ3M6IHsgW2ludGVybmFsTmFtZTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgICAgICAgRmVhdHVyZS52YWx1ZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgZmVhdHVyZUZsYWdzW2ZlYXR1cmUuaW50ZXJuYWxOYW1lXSA9IGZlYXR1cmUuZW5hYmxlZEJ5RGVmYXVsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlRmxhZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBuYW1lIHRvIGl0cyBjb3JyZXNwb25kaW5nIGRlZmF1bHQgRmVhdHVyZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIHRvIGNvbnZlcnQgdG8gRmVhdHVyZVxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciwgaWYgYSBzdHJpbmcgdGhhdCBoYXMgbm8gY29ycmVzcG9uZGluZyBGZWF0dXJlIHZhbHVlIHdhcyBwYXNzZWQuXG4gICAgICogQHJldHVybnMgdGhlIG1hdGNoaW5nIEZlYXR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhuYW1lOiBzdHJpbmcpOiBGZWF0dXJlIHtcbiAgICAgICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIEZlYXR1cmUudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gZmVhdHVyZS5pbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgYElsbGVnYWwgYXJndW1lbnQgcGFzc2VkIHRvIGZyb21TdHJpbmcoKTogJHtuYW1lfSBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFueSBhdmFpbGFibGUgRmVhdHVyZSAke1xuICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSkucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgIH1gLFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgIERFRkFVTFRfTUFYX0dFTkVSSUNfU1VHR0VTVElPTlMsXG4gICAgbWFrZURlZmF1bHRTdWdnZXN0aW9uQnVpbGRlcixcbiAgICBvbmx5U3VnZ2VzdElmQnJhY2tldE9wZW4sXG59IGZyb20gJy4uL1N1Z2dlc3Rvci9TdWdnZXN0b3InO1xuaW1wb3J0IHsgREVGQVVMVF9TWU1CT0xTIH0gZnJvbSAnLi4vVGFza1NlcmlhbGl6ZXIvRGVmYXVsdFRhc2tTZXJpYWxpemVyJztcbmltcG9ydCB7IERBVEFWSUVXX1NZTUJPTFMgfSBmcm9tICcuLi9UYXNrU2VyaWFsaXplci9EYXRhdmlld1Rhc2tTZXJpYWxpemVyJztcbmltcG9ydCB7IFN0YXR1c0NvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9TdGF0dXNDb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1cyc7XG5pbXBvcnQgeyBEZWZhdWx0VGFza1NlcmlhbGl6ZXIsIHR5cGUgVGFza1NlcmlhbGl6ZXIgfSBmcm9tICcuLi9UYXNrU2VyaWFsaXplcic7XG5pbXBvcnQgdHlwZSB7IFN1Z2dlc3Rpb25CdWlsZGVyIH0gZnJvbSAnLi4vU3VnZ2VzdG9yJztcbmltcG9ydCB7IERhdGF2aWV3VGFza1NlcmlhbGl6ZXIgfSBmcm9tICcuLi9UYXNrU2VyaWFsaXplci9EYXRhdmlld1Rhc2tTZXJpYWxpemVyJztcbmltcG9ydCB7IERlYnVnU2V0dGluZ3MgfSBmcm9tICcuL0RlYnVnU2V0dGluZ3MnO1xuaW1wb3J0IHsgU3RhdHVzU2V0dGluZ3MgfSBmcm9tICcuL1N0YXR1c1NldHRpbmdzJztcbmltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuL0ZlYXR1cmUnO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlRmxhZyB9IGZyb20gJy4vRmVhdHVyZSc7XG5cbmludGVyZmFjZSBTZXR0aW5nc01hcCB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgSGVhZGluZ1N0YXRlID0ge1xuICAgIFtpZDogc3RyaW5nXTogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogSW50ZXJmYWNlIGVuY2Fwc3VsYXRpbmcgaG93IGEgVGFzayBpcyB3cml0dGVuIHRvIGFuZCByZWFkIGZyb20gdGV4dFxuICpcbiAqL1xuaW50ZXJmYWNlIFRhc2tGb3JtYXQge1xuICAgIC8qKiBVc2VyIGZhY2luZyBuYW1lIG9mIHRoZSB7QGxpbmsgVGFza0Zvcm1hdH0gKi9cbiAgICBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICAgIC8qKiB7QGxpbmsgVGFza1NlcmlhbGl6ZXJ9IHJlc3BvbnNpYmxlIGZvciByZWFkaW5nIFRhc2tzIGZyb20gdGV4dCBhbmQgd3JpdGluZyB0aGVtIGJhY2sgaW50byB0ZXh0ICovXG4gICAgdGFza1NlcmlhbGl6ZXI6IFRhc2tTZXJpYWxpemVyO1xuICAgIC8qKiBGdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBJbnRlbGxpc2Vuc2UtbGlrZSBzdWdnZXN0aW9ucyBhcyBhIHVzZXIgaXMgdHlwaW5nIGEgVGFzayAqL1xuICAgIGJ1aWxkU3VnZ2VzdGlvbnM/OiBTdWdnZXN0aW9uQnVpbGRlcjtcbn1cblxuLyoqIE1hcCBvZiBhbGwgZGVmaW5lZCB7QGxpbmsgVGFza0Zvcm1hdH1zICovXG5leHBvcnQgY29uc3QgVEFTS19GT1JNQVRTID0ge1xuICAgIHRhc2tzUGx1Z2luRW1vamk6IHtcbiAgICAgICAgZGlzcGxheU5hbWU6ICdUYXNrcyBFbW9qaSBGb3JtYXQnLFxuICAgICAgICB0YXNrU2VyaWFsaXplcjogbmV3IERlZmF1bHRUYXNrU2VyaWFsaXplcihERUZBVUxUX1NZTUJPTFMpLFxuICAgICAgICBidWlsZFN1Z2dlc3Rpb25zOiBtYWtlRGVmYXVsdFN1Z2dlc3Rpb25CdWlsZGVyKERFRkFVTFRfU1lNQk9MUywgREVGQVVMVF9NQVhfR0VORVJJQ19TVUdHRVNUSU9OUyksXG4gICAgfSxcbiAgICBkYXRhdmlldzoge1xuICAgICAgICBkaXNwbGF5TmFtZTogJ0RhdGF2aWV3JyxcbiAgICAgICAgdGFza1NlcmlhbGl6ZXI6IG5ldyBEYXRhdmlld1Rhc2tTZXJpYWxpemVyKCksXG4gICAgICAgIGJ1aWxkU3VnZ2VzdGlvbnM6IG9ubHlTdWdnZXN0SWZCcmFja2V0T3BlbihcbiAgICAgICAgICAgIG1ha2VEZWZhdWx0U3VnZ2VzdGlvbkJ1aWxkZXIoREFUQVZJRVdfU1lNQk9MUywgREVGQVVMVF9NQVhfR0VORVJJQ19TVUdHRVNUSU9OUyksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgWycoJywgJyknXSxcbiAgICAgICAgICAgICAgICBbJ1snLCAnXSddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgKSxcbiAgICB9LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgVEFTS19GT1JNQVRTID0gdHlwZW9mIFRBU0tfRk9STUFUUzsgLy8gRm9yIGNvbnZlbmllbmNlIHRvIG1ha2Ugc29tZSB0eXBpbmcgZWFzaWVyXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3Mge1xuICAgIGdsb2JhbFF1ZXJ5OiBzdHJpbmc7XG4gICAgZ2xvYmFsRmlsdGVyOiBzdHJpbmc7XG4gICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiBib29sZWFuO1xuICAgIHRhc2tGb3JtYXQ6IGtleW9mIFRBU0tfRk9STUFUUztcbiAgICBzZXRDcmVhdGVkRGF0ZTogYm9vbGVhbjtcbiAgICBzZXREb25lRGF0ZTogYm9vbGVhbjtcbiAgICBhdXRvU3VnZ2VzdEluRWRpdG9yOiBib29sZWFuO1xuICAgIGF1dG9TdWdnZXN0TWluTWF0Y2g6IG51bWJlcjtcbiAgICBhdXRvU3VnZ2VzdE1heEl0ZW1zOiBudW1iZXI7XG4gICAgcHJvdmlkZUFjY2Vzc0tleXM6IGJvb2xlYW47XG4gICAgdXNlRmlsZW5hbWVBc1NjaGVkdWxlZERhdGU6IGJvb2xlYW47XG4gICAgZmlsZW5hbWVBc0RhdGVGb2xkZXJzOiBzdHJpbmdbXTtcbiAgICByZWN1cnJlbmNlT25OZXh0TGluZTogYm9vbGVhbjtcblxuICAgIC8vIFRoZSBjdXN0b20gc3RhdHVzIHN0YXRlcy5cbiAgICBzdGF0dXNTZXR0aW5nczogU3RhdHVzU2V0dGluZ3M7XG5cbiAgICAvLyBDb2xsZWN0aW9uIG9mIGZlYXR1cmUgZmxhZyBJRHMgYW5kIHRoZWlyIHN0YXRlLlxuICAgIGZlYXR1cmVzOiBGZWF0dXJlRmxhZztcblxuICAgIC8vIFNldHRpbmdzIGFyZSBtb3ZlZCB0byBhIG1vcmUgZ2VuZXJhbCBtYXAgdG8gYWxsb3cgdGhlIHNldHRpbmdzIFVJIHRvIGJlXG4gICAgLy8gZHluYW1pY2FsbHkgZ2VuZXJhdGVkLlxuICAgIGdlbmVyYWxTZXR0aW5nczogU2V0dGluZ3NNYXA7XG5cbiAgICAvLyBUcmFja3MgdGhlIHN0YWdlIG9mIHRoZSBoZWFkaW5ncyBpbiB0aGUgc2V0dGluZ3MgVUkuXG4gICAgaGVhZGluZ09wZW5lZDogSGVhZGluZ1N0YXRlO1xuICAgIGRlYnVnU2V0dGluZ3M6IERlYnVnU2V0dGluZ3M7XG59XG5cbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogU2V0dGluZ3MgPSB7XG4gICAgZ2xvYmFsUXVlcnk6ICcnLFxuICAgIGdsb2JhbEZpbHRlcjogJycsXG4gICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiBmYWxzZSxcbiAgICB0YXNrRm9ybWF0OiAndGFza3NQbHVnaW5FbW9qaScsXG4gICAgc2V0Q3JlYXRlZERhdGU6IGZhbHNlLFxuICAgIHNldERvbmVEYXRlOiB0cnVlLFxuICAgIGF1dG9TdWdnZXN0SW5FZGl0b3I6IHRydWUsXG4gICAgYXV0b1N1Z2dlc3RNaW5NYXRjaDogMCxcbiAgICBhdXRvU3VnZ2VzdE1heEl0ZW1zOiA2LFxuICAgIHByb3ZpZGVBY2Nlc3NLZXlzOiB0cnVlLFxuICAgIHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlOiBmYWxzZSxcbiAgICBmaWxlbmFtZUFzRGF0ZUZvbGRlcnM6IFtdLFxuICAgIHJlY3VycmVuY2VPbk5leHRMaW5lOiBmYWxzZSxcbiAgICBzdGF0dXNTZXR0aW5nczogbmV3IFN0YXR1c1NldHRpbmdzKCksXG4gICAgZmVhdHVyZXM6IEZlYXR1cmUuc2V0dGluZ3NGbGFncyxcbiAgICBnZW5lcmFsU2V0dGluZ3M6IHtcbiAgICAgICAgLyogUHJldmVudCBkdXBsaWNhdGUgdmFsdWVzIGluIHVzZXIgc2V0dGluZ3MgZm9yIG5vdyxcbiAgICAgICAgICAgYXQgbGVhc3QgdW50aWwgSSBzdGFydCBwb3J0aW5nIHRoZSBwcmUtMS4yMy4wIHNldHRpbmdzXG4gICAgICAgICAgIGNvZGUgdG8gYmUgZ2VuZXJhdGVkIGZyb20gc2V0dGluZ3NDb25maWd1cmF0aW9uLmpzb24uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBnbG9iYWxGaWx0ZXI6ICcnLFxuICAgICAgICAvLyByZW1vdmVHbG9iYWxGaWx0ZXI6IGZhbHNlLFxuICAgICAgICAvLyBzZXREb25lRGF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGhlYWRpbmdPcGVuZWQ6IHt9LFxuICAgIGRlYnVnU2V0dGluZ3M6IG5ldyBEZWJ1Z1NldHRpbmdzKCksXG59O1xuXG5sZXQgc2V0dGluZ3M6IFNldHRpbmdzID0geyAuLi5kZWZhdWx0U2V0dGluZ3MgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNldHRpbmdzIGFzIGEgb2JqZWN0LCBpdCB3aWxsIGFsc28gY2hlY2sgYW5kXG4gKiB1cGRhdGUgdGhlIGZsYWdzIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBhbGwgc2hvd24gaW4gdGhlIGRhdGEuanNvblxuICogZmlsZS4gRXhwb3N1cmUgdmlhIHRoZSBzZXR0aW5ncyBVSSBpcyBvcHRpb25hbC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZXR0aW5ncyA9ICgpOiBTZXR0aW5ncyA9PiB7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbmV3IGZsYWcgYW5kIGlmIHNvIGFkZCBpdCB0byB0aGUgdXNlcnMgc2V0dGluZ3MuXG4gICAgZm9yIChjb25zdCBmbGFnIGluIEZlYXR1cmUuc2V0dGluZ3NGbGFncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuZmVhdHVyZXNbZmxhZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZmVhdHVyZXNbZmxhZ10gPSBGZWF0dXJlLnNldHRpbmdzRmxhZ3NbZmxhZ107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHNhdmVzIHByZS1kYXRlZCBTdGF0dXNDb25maWd1cmF0aW9uLnR5cGVcbiAgICAvLyBUT0RPIFNwZWNpYWwgY2FzZSBmb3Igc3ltYm9sICdYJyBvciAneCcgKGp1c3QgaW4gY2FzZSlcbiAgICBzZXR0aW5ncy5zdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcy5mb3JFYWNoKChzLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VHlwZSA9IFN0YXR1cy5nZXRUeXBlRnJvbVN0YXR1c1R5cGVTdHJpbmcocy50eXBlKTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gbmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgICBzLnN5bWJvbCA/PyAnICcsXG4gICAgICAgICAgICBzLm5hbWUsXG4gICAgICAgICAgICBzLm5leHRTdGF0dXNTeW1ib2wgPz8gJ3gnLFxuICAgICAgICAgICAgcy5hdmFpbGFibGVBc0NvbW1hbmQsXG4gICAgICAgICAgICBuZXdUeXBlLFxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgLi4uc2V0dGluZ3MgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IChuZXdTZXR0aW5nczogUGFydGlhbDxTZXR0aW5ncz4pOiBTZXR0aW5ncyA9PiB7XG4gICAgc2V0dGluZ3MgPSB7IC4uLnNldHRpbmdzLCAuLi5uZXdTZXR0aW5ncyB9O1xuXG4gICAgcmV0dXJuIGdldFNldHRpbmdzKCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRTZXR0aW5ncyA9ICgpOiBTZXR0aW5ncyA9PiB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldHRpbmdzKGRlZmF1bHRTZXR0aW5ncyk7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlR2VuZXJhbFNldHRpbmcgPSAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgYm9vbGVhbik6IFNldHRpbmdzID0+IHtcbiAgICBzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8qIFByZXZlbnQgZHVwbGljYXRlIHZhbHVlcyBpbiB1c2VyIHNldHRpbmdzIGZvciBub3csXG4gICAgICAgYXQgbGVhc3QgdW50aWwgSSBzdGFydCBwb3J0aW5nIHRoZSBwcmUtMS4yMy4wIHNldHRpbmdzXG4gICAgICAgY29kZSB0byBiZSBnZW5lcmF0ZWQgZnJvbSBzZXR0aW5nc0NvbmZpZ3VyYXRpb24uanNvbi5cbiAgICAgKi9cbiAgICAvLyBzeW5jIHRoZSBvbGQgc2V0dGluZ3MgZm9yIHRoZSBtb21lbnQgc28gYSBsYXJnZXIgY2hhbmdlIGlzIG5vdCBuZWVkZWQuXG4gICAgLy8gdXBkYXRlU2V0dGluZ3Moe1xuICAgIC8vICAgICBnbG9iYWxGaWx0ZXI6IDxzdHJpbmc+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzWydnbG9iYWxGaWx0ZXInXSxcbiAgICAvLyAgICAgcmVtb3ZlR2xvYmFsRmlsdGVyOiA8Ym9vbGVhbj5zZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3NbJ3JlbW92ZUdsb2JhbEZpbHRlciddLFxuICAgIC8vICAgICBzZXREb25lRGF0ZTogPGJvb2xlYW4+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzWydzZXREb25lRGF0ZSddLFxuICAgIC8vIH0pO1xuXG4gICAgcmV0dXJuIGdldFNldHRpbmdzKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIGZlYXR1cmUgZnJvbSBzZXR0aW5ncy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gaW50ZXJuYWxOYW1lIHRoZSBpbnRlcm5hbCBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgaXNGZWF0dXJlRW5hYmxlZCA9IChpbnRlcm5hbE5hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBzZXR0aW5ncy5mZWF0dXJlc1tpbnRlcm5hbE5hbWVdID8/IGZhbHNlO1xufTtcblxuLyoqXG4gKiBlbmFibGVzIHRvZ2dsaW5nIHRoZSBmZWF0dXJlIGFuZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiB3aXRoIHN0YXRlLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSBpbnRlcm5hbE5hbWUgdGhlIGludGVybmFsIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gKiBAcGFyYW0gZW5hYmxlZCB0aGUgZXhwZWN0ZWQgc3RhdGUgb2YgdGhlIGZlYXR1cmUuXG4gKiBAcmV0dXJucyB0aGUgZmVhdHVyZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGZlYXR1cmUgdG9nZ2xlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZlYXR1cmUgPSAoaW50ZXJuYWxOYW1lOiBzdHJpbmcsIGVuYWJsZWQ6IGJvb2xlYW4pOiBGZWF0dXJlRmxhZyA9PiB7XG4gICAgc2V0dGluZ3MuZmVhdHVyZXNbaW50ZXJuYWxOYW1lXSA9IGVuYWJsZWQ7XG4gICAgcmV0dXJuIHNldHRpbmdzLmZlYXR1cmVzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHtAbGluayBUYXNrRm9ybWF0fSB0aGF0IGNvcnJlc3BvbmRzIHRvIHVzZXIncyBzZWxlY3Rpb24gKHtAbGluayBTZXR0aW5ncy50YXNrRm9ybWF0fSlcbiAqXG4gKiBAZXhwb3J0c1xuICogQHJldHVybnMge1Rhc2tGb3JtYXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyU2VsZWN0ZWRUYXNrRm9ybWF0KCk6IFRhc2tGb3JtYXQge1xuICAgIHJldHVybiBUQVNLX0ZPUk1BVFNbZ2V0U2V0dGluZ3MoKS50YXNrRm9ybWF0XTtcbn1cbiIsICJpbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuL1N0YXR1cyc7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi9TdGF0dXNDb25maWd1cmF0aW9uJztcblxuLyoqXG4gKiBUcmFja3MgYWxsIHRoZSByZWdpc3RlcmVkIHN0YXR1c2VzIGEgdGFzayBjYW4gaGF2ZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgb2YgdXNpbmcgdGhpcyBjbGFzcy5cbiAqIC0gSW4gJ3Byb2R1Y3Rpb24nIGNvZGUsIHRoYXQgaXMgaW4gdGhlIGFjdHVhbCBwbHVnaW4gY29kZSB0aGF0IGlzIHJlbGVhc2VkLFxuICogICBjYWxsIGBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpYCB0byBvYnRhaW4gdGhlIHNpbmdsZSBnbG9iYWwgaW5zdGFuY2UuXG4gKiAgIEFueSBjaGFuZ2VzIHRvIHRoZSBzdGF0dXNlcyBpbiB0aGF0IGluc3RhbmNlIGFyZSByZWZsZWN0ZWQgZXZlcnl3aGVyZSB0aHJvdWdob3V0XG4gKiAgIHRoZSBwbHVnaW4uXG4gKiAgIEZvciBleGFtcGxlLCB0aGUgY29kZSB0byB0b2dnbGUgdGFzayBzdGF0dXNlcyB1c2UgdGhlIGdsb2JhbCBpbnN0YW5jZS5cbiAqIC0gVGVzdHMgb2YgU3RhdHVzUmVnaXN0cnkgY2FwYWJpbGl0aWVzIGRvIG5vdCBuZWVkIHRvIG1vZGlmeSB0aGUgZ2xvYmFsIGluc3RhbmNlOlxuICogICBUaGV5IHNob3VsZCB1c2UgYG5ldyBTdGF0dXNSZWdpc3RyeSgpYCwgd2hpY2ggbWFrZXMgZm9yIHNpbXBsZXIsIG1vcmUgcmVhZGFibGVcbiAqICAgdGVzdHMgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTdGF0dXNSZWdpc3RyeVxuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzUmVnaXN0cnkge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBTdGF0dXNSZWdpc3RyeTtcblxuICAgIHByaXZhdGUgX3JlZ2lzdGVyZWRTdGF0dXNlczogU3RhdHVzW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3RhdHVzIGFuZCByZWdpc3RlcnMgaXQgZm9yIHVzZS4gSXQgd2lsbCBhbHNvIGNoZWNrIHRvIHNlZVxuICAgICAqIGlmIHRoZSBkZWZhdWx0IHRvZG8gYW5kIGRvbmUgYXJlIHJlZ2lzdGVyZWQgYW5kIGlmIG5vdCBoYW5kbGUgaXQgaW50ZXJuYWxseS5cbiAgICAgKlxuICAgICAqIENvZGUgaW4gdGhlIHBsdWdpbiBzaG91bGQgdXNlIHtAbGluayBnZXRJbnN0YW5jZX0gdG8gdXNlIGFuZCBtb2RpZnkgdGhlIGdsb2JhbFxuICAgICAqIFN0YXR1c1JlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFkZERlZmF1bHRTdGF0dXNUeXBlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHN0YXR1c2VzIG1pbnVzIHRoZSBlbXB0eSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RhdHVzW119XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGdldCByZWdpc3RlcmVkU3RhdHVzZXMoKTogU3RhdHVzW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBzeW1ib2wgfSkgPT4gc3ltYm9sICE9PSBTdGF0dXMuRU1QVFkuc3ltYm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdGljIG1ldGhvZCB0aGF0IGNvbnRyb2xzIHRoZSBhY2Nlc3MgdG8gdGhlIFN0YXR1c1JlZ2lzdHJ5IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzUmVnaXN0cnl9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBTdGF0dXNSZWdpc3RyeSB7XG4gICAgICAgIGlmICghU3RhdHVzUmVnaXN0cnkuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIFN0YXR1c1JlZ2lzdHJ5Lmluc3RhbmNlID0gbmV3IFN0YXR1c1JlZ2lzdHJ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzUmVnaXN0cnkuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBTdGF0dXMgdG8gdGhlIHJlZ2lzdHJ5IGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0YXR1c0NvbmZpZ3VyYXRpb24gfCBTdGF0dXN9IHN0YXR1c1xuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGQoc3RhdHVzOiBTdGF0dXNDb25maWd1cmF0aW9uIHwgU3RhdHVzKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTeW1ib2woc3RhdHVzLnN5bWJvbCkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgaW5zdGFuY2VvZiBTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMucHVzaChzdGF0dXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMucHVzaChuZXcgU3RhdHVzKHN0YXR1cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBzdGF0dXMgYnkgdGhlIHN5bWJvbCBiZXR3ZWVuIHRoZVxuICAgICAqIHNxdWFyZSBicmFjZXMgaW4gdGhlIG1hcmtkb3duIHRhc2suXG4gICAgICogUmV0dXJucyBhbiBFTVBUWSBzdGF0dXMgaWYgc3ltYm9sIGlzIHVua25vd24uXG4gICAgICpcbiAgICAgKiBAc2VlIGJ5U3ltYm9sT3JDcmVhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHsqfSAge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwdWJsaWMgYnlTeW1ib2woc3ltYm9sOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5oYXNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLkVNUFRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgc3RhdHVzIGJ5IHRoZSBzeW1ib2wgYmV0d2VlbiB0aGVcbiAgICAgKiBzcXVhcmUgYnJhY2VzIGluIHRoZSBtYXJrZG93biB0YXNrLlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHVzYWJsZSBuZXcgU3RhdHVzIHdpdGggdGhpcyBnaXZlbiBzeW1ib2wgaWYgc3ltYm9sIGlzIHVua25vd24uXG4gICAgICogTm90ZTogQW4gdW5rbm93biBzeW1ib2wgaXMgbm90IGFkZGVkIHRvIHRoZSByZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBzZWUgaGFzU3ltYm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGJ5U3ltYm9sT3JDcmVhdGUoc3ltYm9sOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5oYXNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLmNyZWF0ZVVua25vd25TdGF0dXMoc3ltYm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIHN0YXR1cyBieSB0aGUgbmFtZSBhc3NpZ25lZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lVG9GaW5kXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIGJ5TmFtZShuYW1lVG9GaW5kOiBzdHJpbmcpOiBTdGF0dXMge1xuICAgICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZFN0YXR1c2VzLmZpbHRlcigoeyBuYW1lIH0pID0+IG5hbWUgPT09IG5hbWVUb0ZpbmQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMuZmlsdGVyKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gbmFtZVRvRmluZClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RhdHVzLkVNUFRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYXJyYXkgb2YgU3RhdHVzIHR5cGVzIHRvIHRoZSBkZWZhdWx0IHN0YXR1c2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHVibGljIHJlc2V0VG9EZWZhdWx0U3RhdHVzZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0dXNlcygpO1xuICAgICAgICB0aGlzLmFkZERlZmF1bHRTdGF0dXNUeXBlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYXJyYXkgb2YgU3RhdHVzIHR5cGVzIHRvIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhclN0YXR1c2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBhbGxvdyBjdXN0b20gcHJvZ3Jlc3Npb24gb2YgdGFzayBzdGF0dXMgZWFjaCBzdGF0dXMga25vd3NcbiAgICAgKiB3aGljaCBzdGF0dXMgY2FuIGNvbWUgYWZ0ZXIgaXQgYXMgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gIHtTdGF0dXN9XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICogQHNlZSBnZXROZXh0U3RhdHVzT3JDcmVhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TmV4dFN0YXR1cyhzdGF0dXM6IFN0YXR1cyk6IFN0YXR1cyB7XG4gICAgICAgIGlmIChzdGF0dXMubmV4dFN0YXR1c1N5bWJvbCAhPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0dXMgPSB0aGlzLmJ5U3ltYm9sKHN0YXR1cy5uZXh0U3RhdHVzU3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5FTVBUWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgc3RhdHVzIGlmIGl0IGV4aXN0cywgYW5kIGlmIG5vdCwgY3JlYXRlIGEgbmV3XG4gICAgICogVE9ETyBzdGF0dXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBuZXh0IHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7U3RhdHVzfVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqIEBzZWUgZ2V0TmV4dFN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXROZXh0U3RhdHVzT3JDcmVhdGUoc3RhdHVzOiBTdGF0dXMpOiBTdGF0dXMge1xuICAgICAgICBjb25zdCBuZXh0U3RhdHVzID0gdGhpcy5nZXROZXh0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIGlmIChuZXh0U3RhdHVzLnR5cGUgIT09IFN0YXR1c1R5cGUuRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXR1cyBpcyBjb25maWd1cmVkIHRvIGFkdmFuY2UgdG8gYSBzeW1ib2wgdGhhdCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gU28gd2UgZ28gYWhlYWQgYW5kIGNyZWF0ZSBpdCBhbnl3YXkgLSB3ZSBqdXN0IGNhbm5vdCBnaXZlIGl0IGEgbWVhbmluZ2Z1bCBuYW1lLlxuICAgICAgICByZXR1cm4gU3RhdHVzLmNyZWF0ZVVua25vd25TdGF0dXMoc3RhdHVzLm5leHRTdGF0dXNTeW1ib2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW55IHN0YXR1c2VzIGluIHRoZSBnaXZlbiBsaXN0IHRoYXQgYXJlIG5vdCBrbm93biB0byB0aGlzIHJlZ2lzdHJ5LlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWRkIGFsbCB1bmtub3duIHN0YXR1cyB0eXBlcyB0byB0aGUgc2V0dGluZ3MsXG4gICAgICogdG8gc2F2ZSB1c2VycyBmcm9tIGhhdmluZyB0byBkbyB0aGF0IG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogU3RhdHVzZXMgYXJlIHJldHVybmVkIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGZpcnN0IGZvdW5kIGluIHRoZVxuICAgICAqIHN1cHBsaWVkIGxpc3QuXG4gICAgICogQHBhcmFtIGFsbFN0YXR1c2VzXG4gICAgICovXG4gICAgcHVibGljIGZpbmRVbmtub3duU3RhdHVzZXMoYWxsU3RhdHVzZXM6IFN0YXR1c1tdKTogU3RhdHVzW10ge1xuICAgICAgICBjb25zdCB1bmtub3duU3RhdHVzZXMgPSBhbGxTdGF0dXNlcy5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNTeW1ib2wocy5zeW1ib2wpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2UgYSBzZXBhcmF0ZSBTdGF0dXNSZWdpc3RyeSB0byBrZWVwIHRyYWNrIG9mIGR1cGxpY2F0ZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgU2V0IGlzIG5vIHVzZSB0byB1czpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjk3NTk0ODAvaG93LXRvLWN1c3RvbWl6ZS1vYmplY3QtZXF1YWxpdHktZm9yLWphdmFzY3JpcHQtc2V0XG4gICAgICAgIGNvbnN0IG5ld1N0YXR1c1JlZ2lzdHJ5ID0gbmV3IFN0YXR1c1JlZ2lzdHJ5KCk7XG5cbiAgICAgICAgY29uc3QgbmFtZWRVbmlxdWVTdGF0dXNlczogU3RhdHVzW10gPSBbXTtcbiAgICAgICAgdW5rbm93blN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgc2VlbiB0aGlzIHN5bWJvbCBhbHJlYWR5OlxuICAgICAgICAgICAgaWYgKG5ld1N0YXR1c1JlZ2lzdHJ5Lmhhc1N5bWJvbChzLnN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIGFoZWFkIGFuZCBjcmVhdGUgYSBzdWl0YWJseS1uYW1lZCBjb3B5LFxuICAgICAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBzeW1ib2wgaW4gdGhlIG5hbWUuXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5jb3B5U3RhdHVzV2l0aE5ld05hbWUocywgYFVua25vd24gKCR7cy5zeW1ib2x9KWApO1xuICAgICAgICAgICAgbmFtZWRVbmlxdWVTdGF0dXNlcy5wdXNoKG5ld1N0YXR1cyk7XG4gICAgICAgICAgICAvLyBBbmQgYWRkIGl0IHRvIG91ciBsb2NhbCByZWdpc3RyeSwgdG8gcHJldmVudCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgbmV3U3RhdHVzUmVnaXN0cnkuYWRkKG5ld1N0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmFtZWRVbmlxdWVTdGF0dXNlcztcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb3B5U3RhdHVzV2l0aE5ld05hbWUoczogU3RhdHVzLCBuZXdOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29uZmlndXJhdGlvbiA9IG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgcy5zeW1ib2wsXG4gICAgICAgICAgICBuZXdOYW1lLFxuICAgICAgICAgICAgcy5uZXh0U3RhdHVzU3ltYm9sLFxuICAgICAgICAgICAgcy5hdmFpbGFibGVBc0NvbW1hbmQsXG4gICAgICAgICAgICBzLnR5cGUsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHVzKHN0YXR1c0NvbmZpZ3VyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgdGhlIFN0YXR1cyB0eXBlcyBieSB0aGUgc3ltYm9sIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBvbmUgZm91bmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUb0ZpbmRcbiAgICAgKiBAcmV0dXJuIHsqfSAge1N0YXR1c31cbiAgICAgKiBAbWVtYmVyb2YgU3RhdHVzUmVnaXN0cnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFN5bWJvbChzeW1ib2xUb0ZpbmQ6IHN0cmluZyk6IFN0YXR1cyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkU3RhdHVzZXMuZmlsdGVyKCh7IHN5bWJvbCB9KSA9PiBzeW1ib2wgPT09IHN5bWJvbFRvRmluZClbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyBhbGwgdGhlIFN0YXR1cyB0eXBlcyBieSB0aGUgc3ltYm9sIGFuZCByZXR1cm5zIHRydWUgaWYgZm91bmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUb0ZpbmRcbiAgICAgKiBAcmV0dXJuIHsqfSAge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFN0YXR1c1JlZ2lzdHJ5XG4gICAgICovXG4gICAgcHJpdmF0ZSBoYXNTeW1ib2woc3ltYm9sVG9GaW5kOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRTdGF0dXNlcy5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3ltYm9sID09PSBzeW1ib2xUb0ZpbmQ7XG4gICAgICAgICAgICB9KSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSByZWdpc3RyeSBhbmQgYWRkcyB0aGUgZGVmYXVsdCBzdGF0dXMgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJvZiBTdGF0dXNSZWdpc3RyeVxuICAgICAqL1xuICAgIHByaXZhdGUgYWRkRGVmYXVsdFN0YXR1c1R5cGVzKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBkZWZhdWx0U3RhdHVzZXMgPSBbU3RhdHVzLm1ha2VUb2RvKCksIFN0YXR1cy5tYWtlSW5Qcm9ncmVzcygpLCBTdGF0dXMubWFrZURvbmUoKSwgU3RhdHVzLm1ha2VDYW5jZWxsZWQoKV07XG5cbiAgICAgICAgZGVmYXVsdFN0YXR1c2VzLmZvckVhY2goKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGQoc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5cbmV4cG9ydCBjbGFzcyBVcmdlbmN5IHtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBkdWVDb2VmZmljaWVudCA9IDEyLjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgc2NoZWR1bGVkQ29lZmZpY2llbnQgPSA1LjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgc3RhcnRlZENvZWZmaWNpZW50ID0gLTMuMDtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBwcmlvcml0eUNvZWZmaWNpZW50ID0gNi4wO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbWlsbGlTZWNvbmRzUGVyRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcblxuICAgIHB1YmxpYyBzdGF0aWMgY2FsY3VsYXRlKHRhc2s6IFRhc2spOiBudW1iZXIge1xuICAgICAgICBsZXQgdXJnZW5jeSA9IDAuMDtcblxuICAgICAgICBpZiAodGFzay5kdWVEYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBNYXAgYSByYW5nZSBvZiAyMSBkYXlzIHRvIHRoZSB2YWx1ZSAwLjIgLSAxLjBcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2ZUb2RheSA9IHdpbmRvdy5tb21lbnQoKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGRheXNPdmVyZHVlID0gTWF0aC5yb3VuZChzdGFydE9mVG9kYXkuZGlmZih0YXNrLmR1ZURhdGUpIC8gVXJnZW5jeS5taWxsaVNlY29uZHNQZXJEYXkpO1xuXG4gICAgICAgICAgICBsZXQgZHVlTXVsdGlwbGllcjogbnVtYmVyO1xuICAgICAgICAgICAgaWYgKGRheXNPdmVyZHVlID49IDcuMCkge1xuICAgICAgICAgICAgICAgIGR1ZU11bHRpcGxpZXIgPSAxLjA7IC8vIDwgMSB3ayBhZ29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF5c092ZXJkdWUgPj0gLTE0LjApIHtcbiAgICAgICAgICAgICAgICAvLyBEdWUgYmV0d2VlbiA3IGRheXMgKCs3KSBhZ28gYW5kIGluIDE0IGRheXMgKC0xNClcbiAgICAgICAgICAgICAgICBkdWVNdWx0aXBsaWVyID0gKChkYXlzT3ZlcmR1ZSArIDE0LjApICogMC44KSAvIDIxLjAgKyAwLjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1ZU11bHRpcGxpZXIgPSAwLjI7IC8vID4gMiB3a3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJnZW5jeSArPSBkdWVNdWx0aXBsaWVyICogVXJnZW5jeS5kdWVDb2VmZmljaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLnNjaGVkdWxlZERhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubW9tZW50KCkuaXNTYW1lT3JBZnRlcih0YXNrLnNjaGVkdWxlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAxICogVXJnZW5jeS5zY2hlZHVsZWRDb2VmZmljaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrLnN0YXJ0RGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tb21lbnQoKS5pc0JlZm9yZSh0YXNrLnN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDEgKiBVcmdlbmN5LnN0YXJ0ZWRDb2VmZmljaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgLy8gSGlnaGVzdFxuICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAxLjUgKiBVcmdlbmN5LnByaW9yaXR5Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBIaWdoXG4gICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICB1cmdlbmN5ICs9IDEuMCAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIE1lZGl1bVxuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAwLjY1ICogVXJnZW5jeS5wcmlvcml0eUNvZWZmaWNpZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gTm9uZVxuICAgICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgICAgICAgdXJnZW5jeSArPSAwLjMyNSAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIG5vIG1vZGlmaWNhdGlvbiBmb3IgXCJMb3dcIiBwcmlvcml0eVxuICAgICAgICAgICAgLy8gTG93ZXN0XG4gICAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICAgICAgICB1cmdlbmN5IC09IDAuMyAqIFVyZ2VuY3kucHJpb3JpdHlDb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmdlbmN5O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuXG4vKipcbiAqIEltcGxlbWVudCBkYXRlIGZyb20gcGF0aCBkZXRlY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGVGYWxsYmFjayB7XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBwYXJzZSB0aGUgZmlsZW5hbWUgdG8gZXh0cmFjdCBhIGRhdGUgdGFraW5nIHVzZXIgc2V0dGluZ3MgaW50byBhY2NvdW50LiBJZiBkYXRlIGluZmVyZW5jZSBpcyBub3RcbiAgICAgKiBlbmFibGVkIHBhcnNpbmcgaXMgYnlwYXNzZWQgYW5kIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZVxuICAgICAqIEByZXR1cm4gYSBNb21lbnQgb3IgbnVsbCBpZiBubyBkYXRlIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21QYXRoKHBhdGg6IHN0cmluZyk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCB7IHVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlLCBmaWxlbmFtZUFzRGF0ZUZvbGRlcnMgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgaWYgKCF1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZSkge1xuICAgICAgICAgICAgLy8gZmVhdHVyZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlc0FueUZvbGRlcihmaWxlbmFtZUFzRGF0ZUZvbGRlcnMsIHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBmaWxlIGlzIG5vdCBpbiBhbnkgZm9sZGVyIG9yIHN1YmZvbGRlciB0aGF0IHdhcyBzZWxlY3RlZCBmb3IgZGF0ZSBpbmZlcmVuY2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGVGcm9tUGF0aChwYXRoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBtYXRjaGVzQW55Rm9sZGVyKGZvbGRlcnM6IHN0cmluZ1tdLCBwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGZvbGRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBubyBjb25zdHJhaW50cyBvbiBtYXRjaGluZyBmb2xkZXJzXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvbGRlcnMgbmV2ZXIgZW5kIHdpdGggYSAnLycsIGFuZCBwYXRocyBjb250YWluIGF0IGxlYXN0IG9uIHNsYXNoIChzZXBhcmF0aW5nIHRoZSBmb2xkZXIgZnJvbSB0aGVcbiAgICAgICAgLy8gZmlsZW5hbWUpXG4gICAgICAgIHJldHVybiBmb2xkZXJzLnNvbWUoKGZvbGRlcikgPT4gcGF0aC5zdGFydHNXaXRoKGZvbGRlciArICcvJykpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGV4dHJhY3REYXRlRnJvbVBhdGgocGF0aDogc3RyaW5nKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gTWF0aC5tYXgoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb3MgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLnN1YnN0cmluZyhmaXJzdFBvcywgbGFzdFBvcyk7XG5cbiAgICAgICAgbGV0IGRhdGVNYXRjaCA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KS8uZXhlYyhiYXNlbmFtZSk7XG4gICAgICAgIGlmICghZGF0ZU1hdGNoKSBkYXRlTWF0Y2ggPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pLy5leGVjKGJhc2VuYW1lKTtcblxuICAgICAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gd2luZG93Lm1vbWVudChbcGFyc2VJbnQoZGF0ZU1hdGNoWzFdKSwgcGFyc2VJbnQoZGF0ZU1hdGNoWzJdKSAtIDEsIHBhcnNlSW50KGRhdGVNYXRjaFszXSldKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWZmIGEgZmFsbGJhY2sgY2FuIGJlIHNldFxuICAgICAqKi9cbiAgICBwdWJsaWMgc3RhdGljIGNhbkFwcGx5RmFsbGJhY2soe1xuICAgICAgICBzdGFydERhdGUsXG4gICAgICAgIHNjaGVkdWxlZERhdGUsXG4gICAgICAgIGR1ZURhdGUsXG4gICAgfToge1xuICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3RhcnREYXRlID09PSBudWxsICYmIGR1ZURhdGUgPT09IG51bGwgJiYgc2NoZWR1bGVkRGF0ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdGhlIGxvZ2ljIHRvIHVwZGF0ZSB0aGUgZmllbGRzIHJlbGF0ZWQgdG8gZGF0ZSBmYWxsYmFjayBvZiBhIHRhc2sgd2hlbiBpdHMgZmlsZSBoYXMgbW92ZWRcbiAgICAgKiBAcGFyYW0gdGFzayAgICAgICAgIC0gdGFzayB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gbmV3UGF0aCAgICAgIC0gbmV3IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIGZhbGxiYWNrRGF0ZSAtIGZhbGxiYWNrIGRhdGUgZnJvbSBuZXcgbG9jYXRpb24sIGZvciBlZmZpY2llbmN5LiBDYW4gYmUgbnVsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlVGFza1BhdGgodGFzazogVGFzaywgbmV3UGF0aDogc3RyaW5nLCBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGwpOiBUYXNrIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB3aXRoIHZhbHVlcyBmcm9tIGJlZm9yZSB0aGUgcGF0aCB3YXMgY2hhbmdlZFxuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZSA9IHRhc2suc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gdGFzay5zY2hlZHVsZWREYXRlSXNJbmZlcnJlZDtcblxuICAgICAgICBpZiAoZmFsbGJhY2tEYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggZG9lc24ndCBjb250YWluIGEgZGF0ZS4uLlxuXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhlIHByZXZpb3VzIHBhdGggaGFkIG9uZSA6IHJlbW92ZSBpbmZlcnJlZCBkYXRlIGZyb20gVGFza1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB0aGUgb2xkIHBhdGggZGlkbid0IGNvbnRhaW4gYW55IGVpdGhlciA6XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZywgYW5kIGtlZXAgYW55IGV4cGxpY2l0bHkgc2V0IHNjaGVkdWxlZCBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHBhdGggY29udGFpbnMgYSBkYXRlLi4uXG5cbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCkge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB3ZSB1c2VkIHRoZSBmYWxsYmFjayBkYXRlIGZyb20gdGhlIHByZXZpb3VzIHBhdGggOlxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgbmV3IHBhdGhcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWREYXRlID0gZmFsbGJhY2tEYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbkFwcGx5RmFsbGJhY2sodGFzaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5hbmQgdGhlIHRhc2sgaXMgY2FuZGlkYXRlIHRvIGRhdGUgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBzZXN0IHRoZSBzY2hlZHVsZWQgZGF0ZSBmcm9tIHRoZSBuZXcgcGF0aFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGUgPSBmYWxsYmFja0RhdGU7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBleGlzdGluZyBkYXRlcywgaW5jbHVkaW5nIGV4cGxpY2l0IHNjaGVkdWxlZERhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGFzayh7XG4gICAgICAgICAgICAuLi50YXNrLFxuICAgICAgICAgICAgdGFza0xvY2F0aW9uOiB0YXNrLnRhc2tMb2NhdGlvbi5mcm9tUmVuYW1lZEZpbGUobmV3UGF0aCksXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBhcnJheSBvZiB1cGRhdGVkIHRhc2tzIHRvIHJlbW92ZSB0aGUgaW5mZXJyZWQgc2NoZWR1bGVkIGRhdGUgc3RhdHVzIGlmIHRoZSBzY2hlZHVsZWQgZGF0ZSBoYXMgYmVlblxuICAgICAqIG1vZGlmaWVkIGFzIGNvbXBhcmVkIHRvIHRoZSBvcmlnaW5hbCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVJbmZlcnJlZFN0YXR1c0lmTmVlZGVkKG9yaWdpbmFsVGFzazogVGFzaywgdXBkYXRlZFRhc2tzOiBUYXNrW10pOiBUYXNrW10ge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFNjaGVkdWxlZERhdGUgPSBvcmlnaW5hbFRhc2suc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPyBvcmlnaW5hbFRhc2suc2NoZWR1bGVkRGF0ZSA6IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUYXNrcy5tYXAoKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNjaGVkdWxlZERhdGUgIT09IG51bGwgJiYgIWluZmVycmVkU2NoZWR1bGVkRGF0ZS5pc1NhbWUodGFzay5zY2hlZHVsZWREYXRlLCAnZGF5JykpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGZhbGxiYWNrIGRhdGUgd2FzIHVzZWQgYmVmb3JlIG1vZGlmaWNhdGlvbiwgYW5kIHRoZSBzY2hlZHVsZWQgZGF0ZSB3YXMgbW9kaWZpZWQsIHdlIGhhdmUgdG8gbWFya1xuICAgICAgICAgICAgICAgIC8vIHRoZSBzY2hlZHVsZWQgZGF0ZSBhcyBub3QgaW5mZXJyZWQgYW55bW9yZS5cbiAgICAgICAgICAgICAgICB0YXNrID0gbmV3IFRhc2soeyAuLi50YXNrLCBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgVGFza1JlZ3VsYXJFeHByZXNzaW9ucyB9IGZyb20gJy4uL1Rhc2snO1xuXG4vKipcbiAqIFRhc2tzRGF0ZSBlbmNhcHN1bGF0ZXMgYSBkYXRlLCBmb3Igc2ltcGxpZnlpbmcgdGhlIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMgdXNlcnMgbmVlZCB0b1xuICogd3JpdGUgaW4gJ2dyb3VwIGJ5IGZ1bmN0aW9uJyBsaW5lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tzRGF0ZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGF0ZTogTW9tZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoZGF0ZTogTW9tZW50IHwgbnVsbCkge1xuICAgICAgICB0aGlzLl9kYXRlID0gZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJhdyB1bmRlcmx5aW5nIG1vbWVudCAob3IgbnVsbCwgaWYgdGhlcmUgaXMgbm8gZGF0ZSlcbiAgICAgKi9cbiAgICBnZXQgbW9tZW50KCk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgZm9ybWF0dGVkIGFzIFlZWVktTU0tREQsIG9yIHtAbGluayBmYWxsQmFja1RleHR9IGlmIHRoZXJlIGlzIG5vIGRhdGUuXG4gICAgIEBwYXJhbSBmYWxsQmFja1RleHQgLSB0aGUgc3RyaW5nIHRvIHVzZSBpZiB0aGUgZGF0ZSBpcyBudWxsLiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdEFzRGF0ZShmYWxsQmFja1RleHQ6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuZGF0ZUZvcm1hdCwgZmFsbEJhY2tUZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgZm9ybWF0dGVkIGFzIFlZWVktTU0tREQgSEg6bW0sIG9yIHtAbGluayBmYWxsQmFja1RleHR9IGlmIHRoZXJlIGlzIG5vIGRhdGUuXG4gICAgIEBwYXJhbSBmYWxsQmFja1RleHQgLSB0aGUgc3RyaW5nIHRvIHVzZSBpZiB0aGUgZGF0ZSBpcyBudWxsLiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdEFzRGF0ZUFuZFRpbWUoZmFsbEJhY2tUZXh0OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChUYXNrUmVndWxhckV4cHJlc3Npb25zLmRhdGVUaW1lRm9ybWF0LCBmYWxsQmFja1RleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGF0ZSBmb3JtYXR0ZWQgd2l0aCB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZywgb3Ige0BsaW5rIGZhbGxCYWNrVGV4dH0gaWYgdGhlcmUgaXMgbm8gZGF0ZS5cbiAgICAgKiBTZWUgaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvIGZvciBhbGwgdGhlIGF2YWlsYWJsZSBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGZvcm1hdFxuICAgICAqIEBwYXJhbSBmYWxsQmFja1RleHQgLSB0aGUgc3RyaW5nIHRvIHVzZSBpZiB0aGUgZGF0ZSBpcyBudWxsLiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdChmb3JtYXQ6IHN0cmluZywgZmFsbEJhY2tUZXh0OiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlID8gdGhpcy5fZGF0ZSEuZm9ybWF0KGZvcm1hdCkgOiBmYWxsQmFja1RleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkYXRlIGFzIGFuIElTTyBzdHJpbmcsIGZvciBleGFtcGxlICcyMDIzLTEwLTEzVDAwOjAwOjAwLjAwMFonLlxuICAgICAqIEBwYXJhbSBrZWVwT2Zmc2V0XG4gICAgICogQHJldHVybnMgLSBUaGUgZGF0ZSBhcyBhbiBJU08gc3RyaW5nLCBmb3IgZXhhbXBsZTogJzIwMjMtMTAtMTNUMDA6MDA6MDAuMDAwWicsXG4gICAgICogICAgICAgICAgICBPUiBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gZGF0ZSwgT1IgbnVsbCBmb3IgYW4gaW52YWxpZCBkYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0PzogYm9vbGVhbik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZSA/IHRoaXMuX2RhdGUhLnRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIDogJyc7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQSBzaW1wbGUgY2xhc3MgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gZmlsZSBpbmZvcm1hdGlvbiB2aWEgJ3Rhc2suZmlsZScgaW4gc2NyaXB0aW5nIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrc0ZpbGUge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BhdGg6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHBhdGg6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXRoIHRvIHRoZSBmaWxlLCB3aXRoIHRoZSBmaWxlbmFtZSBleHRlbnNpb24gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aFdpdGhvdXRFeHRlbnNpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbih0aGlzLnBhdGgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgd2l0aG91dEV4dGVuc2lvbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXC5tZCQvLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByb290IHRvIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGdldCByb290KCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5wYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblxuICAgICAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBwYXRoLmluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKHNlcGFyYXRvckluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCArIDEpO1xuICAgIH1cblxuICAgIGdldCBmb2xkZXIoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgY29uc3QgZmlsZU5hbWVXaXRoRXh0ZW5zaW9uID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZihmaWxlTmFtZVdpdGhFeHRlbnNpb24pKTtcbiAgICAgICAgaWYgKGZvbGRlciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpbGVuYW1lIGluY2x1ZGluZyB0aGUgZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIGdldCBmaWxlbmFtZSgpOiBzdHJpbmcge1xuICAgICAgICAvLyBDb3BpZWQgZnJvbSBUYXNrLmZpbGVuYW1lIGFuZCBGaWxlbmFtZUZpZWxkLnZhbHVlKCkgaW5pdGlhbGx5XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lTWF0Y2ggPSB0aGlzLnBhdGgubWF0Y2goLyhbXi9dKykkLyk7XG4gICAgICAgIGlmIChmaWxlTmFtZU1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWVNYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aG91dEV4dGVuc2lvbih0aGlzLmZpbGVuYW1lKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUHJpb3JpdHkgfSBmcm9tICcuLi9UYXNrJztcblxuZXhwb3J0IGNsYXNzIFByaW9yaXR5VG9vbHMge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiBhIHtAbGluayBQcmlvcml0eX0gdmFsdWUsIHJldHVybmluZyAnTm9uZScgZm9yIHtAbGluayBQcmlvcml0eS5Ob25lfVxuICAgICAqIEBwYXJhbSBwcmlvcml0eVxuICAgICAqIEBzZWUgcHJpb3JpdHlOYW1lVXNpbmdOb3JtYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHByaW9yaXR5TmFtZVVzaW5nTm9uZShwcmlvcml0eTogUHJpb3JpdHkpIHtcbiAgICAgICAgbGV0IHByaW9yaXR5TmFtZSA9ICdFUlJPUic7XG4gICAgICAgIHN3aXRjaCAocHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgUHJpb3JpdHkuSGlnaDpcbiAgICAgICAgICAgICAgICBwcmlvcml0eU5hbWUgPSAnSGlnaCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5LkhpZ2hlc3Q6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ0hpZ2hlc3QnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5NZWRpdW06XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ01lZGl1bSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5Lk5vbmU6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ05vbmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmlvcml0eS5Mb3c6XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlOYW1lID0gJ0xvdyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByaW9yaXR5Lkxvd2VzdDpcbiAgICAgICAgICAgICAgICBwcmlvcml0eU5hbWUgPSAnTG93ZXN0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpb3JpdHlOYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiBhIHtAbGluayBQcmlvcml0eX0gdmFsdWUsIHJldHVybmluZyAnTm9ybWFsJyBmb3Ige0BsaW5rIFByaW9yaXR5Lk5vbmV9XG4gICAgICogQHBhcmFtIHByaW9yaXR5XG4gICAgICogQHNlZSBwcmlvcml0eU5hbWVVc2luZ05vbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHByaW9yaXR5TmFtZVVzaW5nTm9ybWFsKHByaW9yaXR5OiBQcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlUb29scy5wcmlvcml0eU5hbWVVc2luZ05vbmUocHJpb3JpdHkpLnJlcGxhY2UoJ05vbmUnLCAnTm9ybWFsJyk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFza0xvY2F0aW9uIH0gZnJvbSAnLi9UYXNrTG9jYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi9SZWN1cnJlbmNlJztcbmltcG9ydCB7IGdldFNldHRpbmdzLCBnZXRVc2VyU2VsZWN0ZWRUYXNrRm9ybWF0IH0gZnJvbSAnLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi9TdGF0dXNSZWdpc3RyeSc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1cyB9IGZyb20gJy4vU3RhdHVzJztcbmltcG9ydCB7IFVyZ2VuY3kgfSBmcm9tICcuL1VyZ2VuY3knO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgY29tcGFyZUJ5RGF0ZSB9IGZyb20gJy4vbGliL0RhdGVUb29scyc7XG5pbXBvcnQgeyBUYXNrc0RhdGUgfSBmcm9tICcuL1NjcmlwdGluZy9UYXNrc0RhdGUnO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBUYXNrc0ZpbGUgfSBmcm9tICcuL1NjcmlwdGluZy9UYXNrc0ZpbGUnO1xuaW1wb3J0IHsgUHJpb3JpdHlUb29scyB9IGZyb20gJy4vbGliL1ByaW9yaXR5VG9vbHMnO1xuXG4vKipcbiAqIFdoZW4gc29ydGluZywgbWFrZSBzdXJlIGxvdyBhbHdheXMgY29tZXMgYWZ0ZXIgbm9uZS4gVGhpcyB3YXkgYW55IHRhc2tzIHdpdGggbG93IHdpbGwgYmUgYmVsb3cgYW55IGV4aXRpbmdcbiAqIHRhc2tzIHRoYXQgaGF2ZSBubyBwcmlvcml0eSB3aGljaCB3b3VsZCBiZSB0aGUgZGVmYXVsdC5cbiAqXG4gKiBWYWx1ZXMgY2FuIGJlIGNvbnZlcnRlZCB0byBzdHJpbmdzIHdpdGg6XG4gKiAtIHtAbGluayBwcmlvcml0eU5hbWVVc2luZ05vbmV9IGluIHtAbGluayBQcmlvcml0eVRvb2xzfVxuICogLSB7QGxpbmsgcHJpb3JpdHlOYW1lVXNpbmdOb3JtYWx9IGluIHtAbGluayBQcmlvcml0eVRvb2xzfVxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIFByaW9yaXR5IHtcbiAgICBIaWdoZXN0ID0gJzAnLFxuICAgIEhpZ2ggPSAnMScsXG4gICAgTWVkaXVtID0gJzInLFxuICAgIE5vbmUgPSAnMycsXG4gICAgTG93ID0gJzQnLFxuICAgIExvd2VzdCA9ICc1Jyxcbn1cblxuZXhwb3J0IGNsYXNzIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREJztcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRhdGVUaW1lRm9ybWF0ID0gJ1lZWVktTU0tREQgSEg6bW0nO1xuXG4gICAgLy8gTWF0Y2hlcyBpbmRlbnRhdGlvbiBiZWZvcmUgYSBsaXN0IG1hcmtlciAoaW5jbHVkaW5nID4gZm9yIHBvdGVudGlhbGx5IG5lc3RlZCBibG9ja3F1b3RlcyBvciBPYnNpZGlhbiBjYWxsb3V0cylcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGluZGVudGF0aW9uUmVnZXggPSAvXihbXFxzXFx0Pl0qKS87XG5cbiAgICAvLyBNYXRjaGVzIC0gKiBhbmQgKyBsaXN0IG1hcmtlcnMsIG9yIG51bWJlcmVkIGxpc3QgbWFya2VycyAoZWcgMS4pXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBsaXN0TWFya2VyUmVnZXggPSAvKFstKitdfFswLTldK1xcLikvO1xuXG4gICAgLy8gTWF0Y2hlcyBhIGNoZWNrYm94IGFuZCBzYXZlcyB0aGUgc3RhdHVzIGNoYXJhY3RlciBpbnNpZGVcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNoZWNrYm94UmVnZXggPSAvXFxbKC4pXFxdL3U7XG5cbiAgICAvLyBNYXRjaGVzIHRoZSByZXN0IG9mIHRoZSB0YXNrIGFmdGVyIHRoZSBjaGVja2JveC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGFmdGVyQ2hlY2tib3hSZWdleCA9IC8gKiguKikvdTtcblxuICAgIC8vIE1haW4gcmVnZXggZm9yIHBhcnNpbmcgYSBsaW5lLiBJdCBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gLSBJbmRlbnRhdGlvblxuICAgIC8vIC0gTGlzdCBtYXJrZXJcbiAgICAvLyAtIFN0YXR1cyBjaGFyYWN0ZXJcbiAgICAvLyAtIFJlc3Qgb2YgdGFzayBhZnRlciBjaGVja2JveCBtYXJrZG93blxuICAgIC8vIFNlZSBUYXNrLmV4dHJhY3RUYXNrQ29tcG9uZW50cygpIGZvciBhYnN0cmFjdGlvbiBhcm91bmQgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgLy8gVGhhdCBpcyBwcml2YXRlIGZvciBub3csIGJ1dCBjb3VsZCBiZSBtYWRlIHB1YmxpYyBpbiBmdXR1cmUgaWYgbmVlZGVkLlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdGFza1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5pbmRlbnRhdGlvblJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RNYXJrZXJSZWdleC5zb3VyY2UgK1xuICAgICAgICAgICAgJyArJyArXG4gICAgICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmNoZWNrYm94UmVnZXguc291cmNlICtcbiAgICAgICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYWZ0ZXJDaGVja2JveFJlZ2V4LnNvdXJjZSxcbiAgICAgICAgJ3UnLFxuICAgICk7XG5cbiAgICAvLyBVc2VkIHdpdGggdGhlIFwiQ3JlYXRlIG9yIEVkaXQgVGFza1wiIGNvbW1hbmQgdG8gcGFyc2UgaW5kZW50YXRpb24gYW5kIHN0YXR1cyBpZiBwcmVzZW50XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBub25UYXNrUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICBUYXNrUmVndWxhckV4cHJlc3Npb25zLmluZGVudGF0aW9uUmVnZXguc291cmNlICtcbiAgICAgICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMubGlzdE1hcmtlclJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICAnPyAqKCcgK1xuICAgICAgICAgICAgVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5jaGVja2JveFJlZ2V4LnNvdXJjZSArXG4gICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYWZ0ZXJDaGVja2JveFJlZ2V4LnNvdXJjZSxcbiAgICAgICAgJ3UnLFxuICAgICk7XG5cbiAgICAvLyBVc2VkIHdpdGggXCJUb2dnbGUgRG9uZVwiIGNvbW1hbmQgdG8gZGV0ZWN0IGEgbGlzdCBpdGVtIHRoYXQgY2FuIGdldCBhIGNoZWNrYm94IGFkZGVkIHRvIGl0LlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbGlzdEl0ZW1SZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuaW5kZW50YXRpb25SZWdleC5zb3VyY2UgKyBUYXNrUmVndWxhckV4cHJlc3Npb25zLmxpc3RNYXJrZXJSZWdleC5zb3VyY2UsXG4gICAgKTtcblxuICAgIC8vIE1hdGNoIG9uIGJsb2NrIGxpbmsgYXQgZW5kLlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmxvY2tMaW5rUmVnZXggPSAvIFxcXlthLXpBLVowLTktXSskL3U7XG5cbiAgICAvLyBSZWdleCB0byBtYXRjaCBhbGwgaGFzaCB0YWdzLCBiYXNpY2FsbHkgaGFzaCBmb2xsb3dlZCBieSBhbnl0aGluZyBidXQgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIG5lZ2F0aW9uLlxuICAgIC8vIFRvIGVuc3VyZSBVUkxzIGFyZSBub3QgY2F1Z2h0IGl0IGlzIGxvb2tpbmcgb2YgYmVnaW5uaW5nIG9mIHN0cmluZyB0YWcgYW5kIGFueVxuICAgIC8vIHRhZyB0aGF0IGhhcyBhIHNwYWNlIGluIGZyb250IG9mIGl0LiBBbnkgIyB0aGF0IGhhcyBhIGNoYXJhY3RlciBpbiBmcm9udFxuICAgIC8vIG9mIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAvLyBFWEFNUExFOlxuICAgIC8vIGRlc2NyaXB0aW9uOiAnI2RvZyAjY2FyIGh0dHA6Ly93d3cvZGRkI2VyZSAjaG91c2UnXG4gICAgLy8gbWF0Y2hlczogI2RvZywgI2NhciwgI2hvdXNlXG4gICAgLy8gTUFJTlRFTkFOQ0UgTk9URTpcbiAgICAvLyAgSWYgaGFzaFRhZ3MgaXMgbW9kaWZpZWQsIHBsZWFzZSB1cGRhdGUgJ1JlY29nbmlzaW5nIFRhZ3MnIGluIFRhZ3MubWQgaW4gdGhlIGRvY3MuXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBoYXNoVGFncyA9IC8oXnxcXHMpI1teICFAIyQlXiYqKCksLj9cIjp7fXw8Pl0rL2c7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBoYXNoVGFnc0Zyb21FbmQgPSBuZXcgUmVnRXhwKHRoaXMuaGFzaFRhZ3Muc291cmNlICsgJyQnKTtcbn1cblxuLyoqXG4gKiBTdG9yYWdlIGZvciB0aGUgdGFzayBsaW5lLCBicm9rZW4gZG93biBpbiB0byBzZWN0aW9ucy5cbiAqIFNlZSB7QGxpbmsgVGFzay5leHRyYWN0VGFza0NvbXBvbmVudHN9IGZvciB1c2UuXG4gKi9cbmludGVyZmFjZSBUYXNrQ29tcG9uZW50cyB7XG4gICAgaW5kZW50YXRpb246IHN0cmluZztcbiAgICBsaXN0TWFya2VyOiBzdHJpbmc7XG4gICAgc3RhdHVzOiBTdGF0dXM7XG4gICAgYm9keTogc3RyaW5nO1xuICAgIGJsb2NrTGluazogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRhc2sgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBNYXJrRG93biB0YXNrIGFsb25nIHdpdGhcbiAqIHRoZSBleHRlbnNpb25zIHByb3ZpZGVkIGJ5IHRoaXMgcGx1Z2luLiBUaGlzIGlzIHVzZWQgdG8gcGFyc2UgYW5kXG4gKiBnZW5lcmF0ZSB0aGUgbWFya2Rvd24gdGFzayBmb3IgYWxsIHVwZGF0ZXMgYW5kIHJlcGxhY2VtZW50cy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVGFza1xuICovXG5leHBvcnQgY2xhc3MgVGFzayB7XG4gICAgcHVibGljIHJlYWRvbmx5IHN0YXR1czogU3RhdHVzO1xuICAgIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBpbmRlbnRhdGlvbjogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBsaXN0TWFya2VyOiBzdHJpbmc7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgdGFza0xvY2F0aW9uOiBUYXNrTG9jYXRpb247XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgdGFnczogc3RyaW5nW107XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJpb3JpdHk6IFByaW9yaXR5O1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNyZWF0ZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgIHB1YmxpYyByZWFkb25seSBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHVibGljIHJlYWRvbmx5IHNjaGVkdWxlZERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHVibGljIHJlYWRvbmx5IGR1ZURhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbmVEYXRlOiBNb21lbnQgfCBudWxsO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsO1xuICAgIC8qKiBUaGUgYmxvY2tMaW5rIGlzIGEgXCJeXCIgYW5ub3RhdGlvbiBhZnRlciB0aGUgZGF0ZXMvcmVjdXJyZW5jZSBydWxlcy5cbiAgICAgKiBBbnkgbm9uLWVtcHR5IHZhbHVlIG11c3QgYmVnaW4gd2l0aCAnIF4nLiAqL1xuICAgIHB1YmxpYyByZWFkb25seSBibG9ja0xpbms6IHN0cmluZztcblxuICAgIC8qKiBUaGUgb3JpZ2luYWwgbGluZSByZWFkIGZyb20gZmlsZS5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgZW1wdHkgaWYgVGFzayB3YXMgY3JlYXRlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICogKGZvciBleGFtcGxlLCBieSBDcmVhdGUgb3IgRWRpdCBUYXNrLCBvciBpbiB0ZXN0cywgaW5jbHVkaW5nIHZpYSB7QGxpbmsgVGFza0J1aWxkZXJ9KS4gKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgb3JpZ2luYWxNYXJrZG93bjogc3RyaW5nO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IHNjaGVkdWxlZERhdGVJc0luZmVycmVkOiBib29sZWFuO1xuXG4gICAgcHJpdmF0ZSBfdXJnZW5jeTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHRhc2tMb2NhdGlvbixcbiAgICAgICAgaW5kZW50YXRpb24sXG4gICAgICAgIGxpc3RNYXJrZXIsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICBkdWVEYXRlLFxuICAgICAgICBkb25lRGF0ZSxcbiAgICAgICAgcmVjdXJyZW5jZSxcbiAgICAgICAgYmxvY2tMaW5rLFxuICAgICAgICB0YWdzLFxuICAgICAgICBvcmlnaW5hbE1hcmtkb3duLFxuICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCxcbiAgICB9OiB7XG4gICAgICAgIHN0YXR1czogU3RhdHVzO1xuICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgICB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbjtcbiAgICAgICAgaW5kZW50YXRpb246IHN0cmluZztcbiAgICAgICAgbGlzdE1hcmtlcjogc3RyaW5nO1xuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHk7XG4gICAgICAgIGNyZWF0ZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc3RhcnREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbDtcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIGR1ZURhdGU6IG1vbWVudC5Nb21lbnQgfCBudWxsO1xuICAgICAgICBkb25lRGF0ZTogbW9tZW50Lk1vbWVudCB8IG51bGw7XG4gICAgICAgIHJlY3VycmVuY2U6IFJlY3VycmVuY2UgfCBudWxsO1xuICAgICAgICBibG9ja0xpbms6IHN0cmluZztcbiAgICAgICAgdGFnczogc3RyaW5nW10gfCBbXTtcbiAgICAgICAgb3JpZ2luYWxNYXJrZG93bjogc3RyaW5nO1xuICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDogYm9vbGVhbjtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgdGhpcy5saXN0TWFya2VyID0gbGlzdE1hcmtlcjtcbiAgICAgICAgdGhpcy50YXNrTG9jYXRpb24gPSB0YXNrTG9jYXRpb247XG5cbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcblxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVkRGF0ZSA9IGNyZWF0ZWREYXRlO1xuICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREYXRlID0gc2NoZWR1bGVkRGF0ZTtcbiAgICAgICAgdGhpcy5kdWVEYXRlID0gZHVlRGF0ZTtcbiAgICAgICAgdGhpcy5kb25lRGF0ZSA9IGRvbmVEYXRlO1xuXG4gICAgICAgIHRoaXMucmVjdXJyZW5jZSA9IHJlY3VycmVuY2U7XG4gICAgICAgIHRoaXMuYmxvY2tMaW5rID0gYmxvY2tMaW5rO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTWFya2Rvd24gPSBvcmlnaW5hbE1hcmtkb3duO1xuXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZ2l2ZW4gbGluZSBmcm9tIGFuIE9ic2lkaWFuIG5vdGUgYW5kIHJldHVybnMgYSBUYXNrIG9iamVjdC5cbiAgICAgKiBXaWxsIGNoZWNrIGlmIEdsb2JhbCBGaWx0ZXIgaXMgcHJlc2VudCBpbiB0aGUgbGluZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIFRoZSBmdWxsIGxpbmUgaW4gdGhlIG5vdGUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHtUYXNrTG9jYXRpb259IHRhc2tMb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgdGFzayBsaW5lXG4gICAgICogQHBhcmFtIHsoTW9tZW50IHwgbnVsbCl9IGZhbGxiYWNrRGF0ZSAtIFRoZSBkYXRlIHRvIHVzZSBhcyB0aGUgc2NoZWR1bGVkIGRhdGUgaWYgbm8gb3RoZXIgZGF0ZSBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHsqfSAgeyhUYXNrIHwgbnVsbCl9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKiBAc2VlIHBhcnNlVGFza1NpZ25pZmllcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21MaW5lKHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGFza0xvY2F0aW9uLFxuICAgICAgICBmYWxsYmFja0RhdGUsXG4gICAgfToge1xuICAgICAgICBsaW5lOiBzdHJpbmc7XG4gICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uO1xuICAgICAgICBmYWxsYmFja0RhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgfSk6IFRhc2sgfCBudWxsIHtcbiAgICAgICAgY29uc3QgdGFza0NvbXBvbmVudHMgPSBUYXNrLmV4dHJhY3RUYXNrQ29tcG9uZW50cyhsaW5lKTtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxpbmUgdG8gc2VlIGlmIGl0IGlzIGEgbWFya2Rvd24gdGFzay5cbiAgICAgICAgaWYgKHRhc2tDb21wb25lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBpZiB0aGUgbGluZSBkb2VzIG5vdCBoYXZlIHRoZSBnbG9iYWwgZmlsdGVyLiBEbyB0aGlzIGJlZm9yZVxuICAgICAgICAvLyBhbnkgb3RoZXIgcHJvY2Vzc2luZyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAgICBpZiAoIUdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmluY2x1ZGVkSW4odGFza0NvbXBvbmVudHMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFRhc2sucGFyc2VUYXNrU2lnbmlmaWVycyhsaW5lLCB0YXNrTG9jYXRpb24sIGZhbGxiYWNrRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBsaW5lIGluIGF0dGVtcHQgdG8gZ2V0IHRoZSB0YXNrIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlYWRzIHRoZSB0YXNrIGV2ZW4gaWYgdGhlIEdsb2JhbCBGaWx0ZXIgaXMgbWlzc2luZy5cbiAgICAgKiBJZiBhIEdsb2JhbCBGaWx0ZXIgY2hlY2sgaXMgbmVlZGVkLCB1c2Uge0BsaW5rIFRhc2suZnJvbUxpbmV9LlxuICAgICAqXG4gICAgICogVGFzayBpcyByZXR1cm5lZCByZWdhcmRsZXNzIGlmIEdsb2JhbCBGaWx0ZXIgaXMgcHJlc2VudCBvciBub3QuXG4gICAgICogSG93ZXZlciwgaWYgaXQgaXMsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSB0YWdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmUgLSB0aGUgZnVsbCBsaW5lIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHRhc2tMb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgdGFzayBsaW5lXG4gICAgICogQHBhcmFtIGZhbGxiYWNrRGF0ZSAtIFRoZSBkYXRlIHRvIHVzZSBhcyB0aGUgc2NoZWR1bGVkIGRhdGUgaWYgbm8gb3RoZXIgZGF0ZSBpcyBzZXRcbiAgICAgKiBAcmV0dXJucyB7Kn0geyhUYXNrIHwgbnVsbCl9XG4gICAgICogQHNlZSBmcm9tTGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VUYXNrU2lnbmlmaWVycyhcbiAgICAgICAgbGluZTogc3RyaW5nLFxuICAgICAgICB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbixcbiAgICAgICAgZmFsbGJhY2tEYXRlOiBNb21lbnQgfCBudWxsLFxuICAgICk6IFRhc2sgfCBudWxsIHtcbiAgICAgICAgY29uc3QgdGFza0NvbXBvbmVudHMgPSBUYXNrLmV4dHJhY3RUYXNrQ29tcG9uZW50cyhsaW5lKTtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxpbmUgdG8gc2VlIGlmIGl0IGlzIGEgbWFya2Rvd24gdGFzay5cbiAgICAgICAgaWYgKHRhc2tDb21wb25lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdGFza1NlcmlhbGl6ZXIgfSA9IGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQoKTtcbiAgICAgICAgY29uc3QgdGFza0luZm8gPSB0YXNrU2VyaWFsaXplci5kZXNlcmlhbGl6ZSh0YXNrQ29tcG9uZW50cy5ib2R5KTtcblxuICAgICAgICBsZXQgc2NoZWR1bGVkRGF0ZUlzSW5mZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSW5mZXIgdGhlIHNjaGVkdWxlZCBkYXRlIGZyb20gdGhlIGZpbGUgbmFtZSBpZiBub3Qgc2V0IGV4cGxpY2l0bHlcbiAgICAgICAgaWYgKERhdGVGYWxsYmFjay5jYW5BcHBseUZhbGxiYWNrKHRhc2tJbmZvKSAmJiBmYWxsYmFja0RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRhc2tJbmZvLnNjaGVkdWxlZERhdGUgPSBmYWxsYmFja0RhdGU7XG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgYXJvdW5kIHRhZ3NcbiAgICAgICAgdGFza0luZm8udGFncyA9IHRhc2tJbmZvLnRhZ3MubWFwKCh0YWcpID0+IHRhZy50cmltKCkpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgR2xvYmFsIEZpbHRlciBpZiBpdCBpcyB0aGVyZVxuICAgICAgICB0YXNrSW5mby50YWdzID0gdGFza0luZm8udGFncy5maWx0ZXIoKHRhZykgPT4gIUdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmVxdWFscyh0YWcpKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICAgICAgLi4udGFza0NvbXBvbmVudHMsXG4gICAgICAgICAgICAuLi50YXNrSW5mbyxcbiAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogdGFza0xvY2F0aW9uLFxuICAgICAgICAgICAgb3JpZ2luYWxNYXJrZG93bjogbGluZSxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBjb21wb25lbnQgcGFydHMgb2YgdGhlIHRhc2sgbGluZS5cbiAgICAgKiBAcGFyYW0gbGluZVxuICAgICAqIEByZXR1cm5zIGEge0BsaW5rIFRhc2tDb21wb25lbnRzfSBvYmplY3QgY29udGFpbmluZyB0aGUgY29tcG9uZW50IHBhcnRzIG9mIHRoZSB0YXNrIGxpbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0cmFjdFRhc2tDb21wb25lbnRzKGxpbmU6IHN0cmluZyk6IFRhc2tDb21wb25lbnRzIHwgbnVsbCB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBsaW5lIHRvIHNlZSBpZiBpdCBpcyBhIG1hcmtkb3duIHRhc2suXG4gICAgICAgIGNvbnN0IHJlZ2V4TWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMudGFza1JlZ2V4KTtcbiAgICAgICAgaWYgKHJlZ2V4TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZW50YXRpb24gPSByZWdleE1hdGNoWzFdO1xuICAgICAgICBjb25zdCBsaXN0TWFya2VyID0gcmVnZXhNYXRjaFsyXTtcblxuICAgICAgICAvLyBHZXQgdGhlIHN0YXR1cyBvZiB0aGUgdGFzay5cbiAgICAgICAgY29uc3Qgc3RhdHVzU3RyaW5nID0gcmVnZXhNYXRjaFszXTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5ieVN5bWJvbE9yQ3JlYXRlKHN0YXR1c1N0cmluZyk7XG5cbiAgICAgICAgLy8gbWF0Y2hbNF0gaW5jbHVkZXMgdGhlIHdob2xlIGJvZHkgb2YgdGhlIHRhc2sgYWZ0ZXIgdGhlIGJyYWNrZXRzLlxuICAgICAgICBsZXQgYm9keSA9IHJlZ2V4TWF0Y2hbNF0udHJpbSgpO1xuXG4gICAgICAgIC8vIE1hdGNoIGZvciBibG9jayBsaW5rIGFuZCByZW1vdmUgaWYgZm91bmQuIEFsd2F5cyBleHBlY3RlZCB0byBiZVxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICBjb25zdCBibG9ja0xpbmtNYXRjaCA9IGJvZHkubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5ibG9ja0xpbmtSZWdleCk7XG4gICAgICAgIGNvbnN0IGJsb2NrTGluayA9IGJsb2NrTGlua01hdGNoICE9PSBudWxsID8gYmxvY2tMaW5rTWF0Y2hbMF0gOiAnJztcblxuICAgICAgICBpZiAoYmxvY2tMaW5rICE9PSAnJykge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShUYXNrUmVndWxhckV4cHJlc3Npb25zLmJsb2NrTGlua1JlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGVudGF0aW9uLCBsaXN0TWFya2VyLCBzdGF0dXMsIGJvZHksIGJsb2NrTGluayB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0dGVuIHRoZSB0YXNrIGFzIGEgc3RyaW5nIHRoYXQgaW5jbHVkZXMgYWxsIGl0cyBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogQG5vdGUgT3V0cHV0IGRlcGVuZHMgb24ge0BsaW5rIFNldHRpbmdzLnRhc2tGb3JtYXR9XG4gICAgICogQHJldHVybiB7Kn0gIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQoKS50YXNrU2VyaWFsaXplci5zZXJpYWxpemUodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVGFzayBhcyBhIGxpc3QgaXRlbSB3aXRoIGEgY2hlY2tib3guXG4gICAgICpcbiAgICAgKiBAbm90ZSBPdXRwdXQgZGVwZW5kcyBvbiB7QGxpbmsgU2V0dGluZ3MudGFza0Zvcm1hdH1cbiAgICAgKiBAcmV0dXJuIHsqfSAge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgVGFza1xuICAgICAqL1xuICAgIHB1YmxpYyB0b0ZpbGVMaW5lU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmluZGVudGF0aW9ufSR7dGhpcy5saXN0TWFya2VyfSBbJHt0aGlzLnN0YXR1cy5zeW1ib2x9XSAke3RoaXMudG9TdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhpcyB0YXNrIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdGFzayhzKS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpZiB5b3UgbmVlZCB0byBrbm93IHdoaWNoIGlzIHRoZSBvcmlnaW5hbCAoY29tcGxldGVkKVxuICAgICAqIHRhc2sgYW5kIHdoaWNoIGlzIHRoZSBuZXcgcmVjdXJyZW5jZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXNrIGlzIG5vdCByZWN1cnJpbmcsIGl0IHdpbGwgcmV0dXJuIGBbdG9nZ2xlZF1gLlxuICAgICAqXG4gICAgICogVG9nZ2xpbmcgY2FuIHJlc3VsdCBpbiBtb3JlIHRoYW4gb25lIHJldHVybmVkIHRhc2sgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiByZWN1cnJlbmNlLiBJbiB0aGlzIGNhc2UsIHRoZSB0b2dnbGVkIHRhc2sgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIHRvZ2V0aGVyIHdpdGggdGhlIG5leHQgb2NjdXJyZW5jZSBpbiB0aGUgb3JkZXIgYFtuZXh0LCB0b2dnbGVkXWAuXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBhIHBvc3NpYmlsaXR5IHRvIHVzZSB1c2VyIHNldCBvcmRlciBgW25leHQsIHRvZ2dsZWRdYFxuICAgICAqIG9yIGBbdG9nZ2xlZCwgbmV4dF1gIC0ge0BsaW5rIHRvZ2dsZVdpdGhSZWN1cnJlbmNlSW5Vc2Vyc09yZGVyfS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKTogVGFza1tdIHtcbiAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5nZXROZXh0U3RhdHVzT3JDcmVhdGUodGhpcy5zdGF0dXMpO1xuXG4gICAgICAgIGxldCBuZXdEb25lRGF0ZSA9IG51bGw7XG5cbiAgICAgICAgbGV0IG5leHRPY2N1cnJlbmNlOiB7XG4gICAgICAgICAgICBzdGFydERhdGU6IE1vbWVudCB8IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgZHVlRGF0ZTogTW9tZW50IHwgbnVsbDtcbiAgICAgICAgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXdTdGF0dXMuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgLy8gU2V0IGRvbmUgZGF0ZSBvbmx5IGlmIHNldHRpbmcgdmFsdWUgaXMgdHJ1ZVxuICAgICAgICAgICAgY29uc3QgeyBzZXREb25lRGF0ZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmIChzZXREb25lRGF0ZSkge1xuICAgICAgICAgICAgICAgIG5ld0RvbmVEYXRlID0gd2luZG93Lm1vbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHRhc2sgaXMgbm8gbG9uZ2VyIHRvZG8sIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgcmVjdXJyaW5nOlxuICAgICAgICAgICAgaWYgKHRoaXMucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHRPY2N1cnJlbmNlID0gdGhpcy5yZWN1cnJlbmNlLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvZ2dsZWRUYXNrID0gbmV3IFRhc2soe1xuICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgIHN0YXR1czogbmV3U3RhdHVzLFxuICAgICAgICAgICAgZG9uZURhdGU6IG5ld0RvbmVEYXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBuZXdUYXNrczogVGFza1tdID0gW107XG5cbiAgICAgICAgaWYgKG5leHRPY2N1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNldENyZWF0ZWREYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgbGV0IGNyZWF0ZWREYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2V0Q3JlYXRlZERhdGUpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkRGF0ZSA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0dXMgPSBTdGF0dXNSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLmdldE5leHRTdGF0dXNPckNyZWF0ZShuZXdTdGF0dXMpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFRhc2sgPSBuZXcgVGFzayh7XG4gICAgICAgICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAgICAgICAuLi5uZXh0T2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5leHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgLy8gTmV3IG9jY3VycmVuY2VzIGNhbm5vdCBoYXZlIHRoZSBzYW1lIGJsb2NrIGxpbmsuXG4gICAgICAgICAgICAgICAgLy8gQW5kIHJhbmRvbSBibG9jayBsaW5rcyBkb24ndCBoZWxwLlxuICAgICAgICAgICAgICAgIGJsb2NrTGluazogJycsXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBjcmVhdGVkRGF0ZSBvbiByZWN1cnJpbmcgdGFza3NcbiAgICAgICAgICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3VGFza3MucHVzaChuZXh0VGFzayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBuZXh0IG9jY3VycmVuY2UgYmVmb3JlIHByZXZpb3VzIG9jY3VycmVuY2UuXG4gICAgICAgIG5ld1Rhc2tzLnB1c2godG9nZ2xlZFRhc2spO1xuXG4gICAgICAgIHJldHVybiBuZXdUYXNrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoaXMgdGFzayBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHRhc2socykuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgdGhlIHVwZGF0ZWQgdGFzayhzKSBhcmUgdG8gYmUgc2F2ZWQsXG4gICAgICogYXMgdGhpcyBob25vdXJzIHRoZSB1c2VyIHNldHRpbmcgdG8gY29udHJvbCB0aGUgb3JkZXJcbiAgICAgKiB0aGUgdGFza3Mgc2hvdWxkIGJlIHNhdmVkIGluLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRhc2sgaXMgbm90IHJlY3VycmluZywgaXQgd2lsbCByZXR1cm4gYFt0b2dnbGVkXWAuXG4gICAgICpcbiAgICAgKiBUb2dnbGluZyBjYW4gcmVzdWx0IGluIG1vcmUgdGhhbiBvbmUgcmV0dXJuZWQgdGFzayBpbiB0aGUgY2FzZSBvZlxuICAgICAqIHJlY3VycmVuY2UuIEluIHRoaXMgY2FzZSwgdGhlIHRvZ2dsZWQgdGFzayB3aWxsIGJlIHJldHVybmVkIGluXG4gICAgICogdXNlciBzZXQgb3JkZXIgYFtuZXh0LCB0b2dnbGVkXWAgb3IgYFt0b2dnbGVkLCBuZXh0XWAgZGVwZW5kaW5nXG4gICAgICogb24ge0BsaW5rIFNldHRpbmdzfS5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29uc2lkZXIgdXNlciBzZXR0aW5ncyBjYWxsIHtAbGluayB0b2dnbGV9LlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZVdpdGhSZWN1cnJlbmNlSW5Vc2Vyc09yZGVyKCk6IFRhc2tbXSB7XG4gICAgICAgIGNvbnN0IG5ld1Rhc2tzID0gdGhpcy50b2dnbGUoKTtcblxuICAgICAgICBjb25zdCB7IHJlY3VycmVuY2VPbk5leHRMaW5lOiByZWN1cnJlbmNlT25OZXh0TGluZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIHJlY3VycmVuY2VPbk5leHRMaW5lID8gbmV3VGFza3MucmV2ZXJzZSgpIDogbmV3VGFza3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHRhc2sgaXMgY29uc2lkZXJlZCBkb25lLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHN0YXR1cyB0eXBlIGlzIHtAbGluayBTdGF0dXNUeXBlLkRPTkV9LCB7QGxpbmsgU3RhdHVzVHlwZS5DQU5DRUxMRUR9IG9yIHtAbGluayBTdGF0dXNUeXBlLk5PTl9UQVNLfSwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzRG9uZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnR5cGUgPT09IFN0YXR1c1R5cGUuRE9ORSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMudHlwZSA9PT0gU3RhdHVzVHlwZS5DQU5DRUxMRUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnR5cGUgPT09IFN0YXR1c1R5cGUuTk9OX1RBU0tcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiB0aGUgVGFzaydzIHByaW9yaXR5LlxuICAgICAqICAgICAtIEhpZ2hlc3QgPSAwXG4gICAgICogICAgIC0gSGlnaCA9IDFcbiAgICAgKiAgICAgLSBNZWRpdW0gPSAyXG4gICAgICogICAgIC0gTm9uZSA9IDNcbiAgICAgKiAgICAgLSBMb3cgPSA0XG4gICAgICogICAgIC0gTG93ZXN0ID0gNVxuICAgICAqIEBzZWUgcHJpb3JpdHlOYW1lXG4gICAgICovXG4gICAgcHVibGljIGdldCBwcmlvcml0eU51bWJlcigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRoaXMucHJpb3JpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhlIGRlc2NyaXB0aW9uLCB3aXRoIGFueSB0YWdzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyByZW1vdmVzIHRhZ3MgcmVjb2duaXNlZCBieSBUYXNrcyAoaW5jbHVkaW5nIHJlbW92aW5nICMxMjMsIGZvciBleGFtcGxlKSxcbiAgICAgKiBhcyBvcHBvc2VkIHRvIHRhZ3MgcmVjb2duaXNlZCBieSBPYnNpZGlhbiwgd2hpY2ggZG9lcyBub3QgdHJlYXQgbnVtYmVycy1vbmx5IGFzIHZhbGlkIHRhZ3MuXG4gICAgICovXG4gICAgcHVibGljIGdldCBkZXNjcmlwdGlvbldpdGhvdXRUYWdzKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5oYXNoVGFncywgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIFRhc2sncyBwcmlvcml0eS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBwcmlvcml0eSBpcyBjYWxsZWQgJ05vcm1hbCcsIG5vdCAnTm9uZScuXG4gICAgIEBzZWUgcHJpb3JpdHlOdW1iZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHByaW9yaXR5TmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gUHJpb3JpdHlUb29scy5wcmlvcml0eU5hbWVVc2luZ05vcm1hbCh0aGlzLnByaW9yaXR5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHVyZ2VuY3koKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3VyZ2VuY3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VyZ2VuY3kgPSBVcmdlbmN5LmNhbGN1bGF0ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl91cmdlbmN5O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcGF0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrTG9jYXRpb24ucGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIGNyZWF0ZWREYXRlfSBhcyBhIHtAbGluayBUYXNrc0RhdGV9LCBzbyB0aGUgZmllbGQgbmFtZXMgaW4gc2NyaXB0aW5nIGRvY3MgYXJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhpc3Rpbmcgc2VhcmNoIGluc3RydWN0aW9uIG5hbWVzLCBhbmQgbnVsbCB2YWx1ZXMgYXJlIGVhc3kgdG8gZGVhbCB3aXRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY3JlYXRlZCgpOiBUYXNrc0RhdGUge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tzRGF0ZSh0aGlzLmNyZWF0ZWREYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIGRvbmVEYXRlfSBhcyBhIHtAbGluayBUYXNrc0RhdGV9LCBzbyB0aGUgZmllbGQgbmFtZXMgaW4gc2NyaXB0aW5nIGRvY3MgYXJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhpc3Rpbmcgc2VhcmNoIGluc3RydWN0aW9uIG5hbWVzLCBhbmQgbnVsbCB2YWx1ZXMgYXJlIGVhc3kgdG8gZGVhbCB3aXRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZG9uZSgpOiBUYXNrc0RhdGUge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tzRGF0ZSh0aGlzLmRvbmVEYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIGR1ZURhdGV9IGFzIGEge0BsaW5rIFRhc2tzRGF0ZX0sIHNvIHRoZSBmaWVsZCBuYW1lcyBpbiBzY3JpcHRpbmcgZG9jcyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBleGlzdGluZyBzZWFyY2ggaW5zdHJ1Y3Rpb24gbmFtZXMsIGFuZCBudWxsIHZhbHVlcyBhcmUgZWFzeSB0byBkZWFsIHdpdGguXG4gICAgICovXG4gICAgcHVibGljIGdldCBkdWUoKTogVGFza3NEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrc0RhdGUodGhpcy5kdWVEYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIHNjaGVkdWxlZERhdGV9IGFzIGEge0BsaW5rIFRhc2tzRGF0ZX0sIHNvIHRoZSBmaWVsZCBuYW1lcyBpbiBzY3JpcHRpbmcgZG9jcyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBleGlzdGluZyBzZWFyY2ggaW5zdHJ1Y3Rpb24gbmFtZXMsIGFuZCBudWxsIHZhbHVlcyBhcmUgZWFzeSB0byBkZWFsIHdpdGguXG4gICAgICovXG4gICAgcHVibGljIGdldCBzY2hlZHVsZWQoKTogVGFza3NEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrc0RhdGUodGhpcy5zY2hlZHVsZWREYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIHN0YXJ0RGF0ZX0gYXMgYSB7QGxpbmsgVGFza3NEYXRlfSwgc28gdGhlIGZpZWxkIG5hbWVzIGluIHNjcmlwdGluZyBkb2NzIGFyZSBjb25zaXN0ZW50IHdpdGggdGhlIGV4aXN0aW5nIHNlYXJjaCBpbnN0cnVjdGlvbiBuYW1lcywgYW5kIG51bGwgdmFsdWVzIGFyZSBlYXN5IHRvIGRlYWwgd2l0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN0YXJ0KCk6IFRhc2tzRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKHRoaXMuc3RhcnREYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgZmllbGRzIHRoYXQgY29udHJpYnV0ZSB0byAnaGFwcGVucycgc2VhcmNoZXMuXG4gICAgICpcbiAgICAgKiBAc2VlIGhhcHBlbnNcbiAgICAgKiBAc2VlIHtAbGluayBIYXBwZW5zRGF0ZUZpZWxkfVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFwcGVuc0RhdGVzKCk6IChNb21lbnQgfCBudWxsKVtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5Lm9mKHRoaXMuc3RhcnREYXRlLCB0aGlzLnNjaGVkdWxlZERhdGUsIHRoaXMuZHVlRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlYXJsaWVzdCBvZiB0aGUgZGF0ZXMgdXNlZCBieSAnaGFwcGVucycgaW4gdGhpcyBnaXZlbiB0YXNrIGFzIGEge0BsaW5rIFRhc2tzRGF0ZX0uXG4gICAgICpcbiAgICAgKiBHZW5lcmFsbHkgc3BlYWtpbmcsIHRoZSBlYXJsaWVzdCBkYXRlIGlzIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGhpZ2hlc3QgcHJpb3JpdHksXG4gICAgICogYXMgaXQgaXMgdGhlIGZpcnN0IHBvaW50IGF0IHdoaWNoIHRoZSB1c2VyIG1pZ2h0IHdpc2ggdG8gYWN0IG9uIHRoZSB0YXNrLlxuICAgICAqXG4gICAgICogQHNlZSBoYXBwZW5zRGF0ZXNcbiAgICAgKiBAc2VlIHtAbGluayBIYXBwZW5zRGF0ZUZpZWxkfVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFwcGVucygpOiBUYXNrc0RhdGUge1xuICAgICAgICBjb25zdCBoYXBwZW5zRGF0ZXMgPSB0aGlzLmhhcHBlbnNEYXRlcztcbiAgICAgICAgY29uc3Qgc29ydGVkSGFwcGVuc0RhdGVzID0gaGFwcGVuc0RhdGVzLnNvcnQoY29tcGFyZUJ5RGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFza3NEYXRlKHNvcnRlZEhhcHBlbnNEYXRlc1swXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIFRhc2sgaGFzIGEgdmFsaWQgcmVjdXJyZW5jZSBydWxlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLFxuICAgICAqIHRoYXQgaXMsIGZhbHNlIGlmIGl0IGRvZXMgbm90IGhhdmUgYSByZWN1cnJlbmNlIHJ1bGUsIG9yIHRoZSByZWN1cnJlbmNlIHJ1bGUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzUmVjdXJyaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnJlbmNlICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGV4dCBvZiB0aGUgVGFzaydzIHJlY3VycmVuY2UgcnVsZSwgaWYgaXQgaXMgc3VwcGxpZWQgYW5kIGlzIHZhbGlkLFxuICAgICAqIGFuZCBhbiBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcmVjdXJyZW5jZVJ1bGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJyZW5jZSA/IHRoaXMucmVjdXJyZW5jZS50b1RleHQoKSA6ICcnO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaGVhZGluZygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaGFzSGVhZGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkaW5nSGVhZGVyICE9PSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlsZSgpOiBUYXNrc0ZpbGUge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tzRmlsZSh0aGlzLnBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZmlsZSBjb250YWluaW5nIHRoZSB0YXNrLCB3aXRoIHRoZSAubWQgZXh0ZW5zaW9uIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBmaWxlbmFtZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWVNYXRjaCA9IHRoaXMucGF0aC5tYXRjaCgvKFteL10rKVxcLm1kJC8pO1xuICAgICAgICBpZiAoZmlsZU5hbWVNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lTWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsaW5lTnVtYmVyKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyO1xuICAgIH1cblxuICAgIGdldCBzZWN0aW9uU3RhcnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza0xvY2F0aW9uLnNlY3Rpb25TdGFydDtcbiAgICB9XG5cbiAgICBnZXQgc2VjdGlvbkluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tMb2NhdGlvbi5zZWN0aW9uSW5kZXg7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwcmVjZWRpbmdIZWFkZXIoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tMb2NhdGlvbi5wcmVjZWRpbmdIZWFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2hlbiBsaW5raW5nIHRvIHRoZSBvcmlnaW4gb2YgdGhlIHRhc2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0ZpbGVuYW1lVW5pcXVlIHtib29sZWFufG51bGx9IFdoZXRoZXIgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdGhhdCBjb250YWlucyB0aGUgdGFzayBpcyB1bmlxdWUgaW4gdGhlIHZhdWx0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGl0IGlzIHVuZGVmaW5lZCwgdGhlIG91dGNvbWUgd2lsbCBiZSB0aGUgc2FtZSBhcyB3aXRoIGEgdW5pcXVlIGZpbGUgbmFtZTogdGhlIGZpbGUgbmFtZSBvbmx5LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBmdWxsIHBhdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TGlua1RleHQoeyBpc0ZpbGVuYW1lVW5pcXVlIH06IHsgaXNGaWxlbmFtZVVuaXF1ZTogYm9vbGVhbiB8IHVuZGVmaW5lZCB9KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGxldCBsaW5rVGV4dDogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaWYgKGlzRmlsZW5hbWVVbmlxdWUpIHtcbiAgICAgICAgICAgIGxpbmtUZXh0ID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEEgc2xhc2ggYXQgdGhlIGJlZ2lubmluZyBpbmRpY2F0ZXMgdGhpcyBpcyBhIHBhdGgsIG5vdCBhIGZpbGVuYW1lLlxuICAgICAgICAgICAgbGlua1RleHQgPSAnLycgKyB0aGlzLnBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlua1RleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIHdvdWxkbid0IHByb3ZpZGUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhbmQgb25seSB0YWtlIHVwIHNwYWNlLlxuICAgICAgICBpZiAodGhpcy5wcmVjZWRpbmdIZWFkZXIgIT09IG51bGwgJiYgdGhpcy5wcmVjZWRpbmdIZWFkZXIgIT09IGxpbmtUZXh0KSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IGxpbmtUZXh0ICsgJyA+ICcgKyB0aGlzLnByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBsaXN0cyBvZiBUYXNrIG9iamVjdHMsIGFuZCByZXBvcnQgd2hldGhlciB0aGVpclxuICAgICAqIHRhc2tzIGFyZSBpZGVudGljYWwgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIG9wdGltaXNpbmcgY29kZSBpZiBpdCBpcyBndWFyYW50ZWVkIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gcG9zc2libGUgZGlmZmVyZW5jZXMgaW4gdGhlIHRhc2tzIGluIGEgZmlsZVxuICAgICAqIGFmdGVyIGFuIGVkaXQsIGZvciBleGFtcGxlLlxuICAgICAqXG4gICAgICogSWYgYW55IGZpZWxkIGlzIGRpZmZlcmVudCBpbiBhbnkgdGFzaywgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2xkVGFza3NcbiAgICAgKiBAcGFyYW0gbmV3VGFza3NcbiAgICAgKi9cbiAgICBzdGF0aWMgdGFza3NMaXN0c0lkZW50aWNhbChvbGRUYXNrczogVGFza1tdLCBuZXdUYXNrczogVGFza1tdKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvbGRUYXNrcy5sZW5ndGggIT09IG5ld1Rhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGRUYXNrcy5ldmVyeSgob2xkVGFzaywgaW5kZXgpID0+IG9sZFRhc2suaWRlbnRpY2FsVG8obmV3VGFza3NbaW5kZXhdKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBhbGwgdGhlIGZpZWxkcyBpbiBhbm90aGVyIFRhc2ssIHRvIGRldGVjdCBhbnkgZGlmZmVyZW5jZXMgZnJvbSB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIElmIGFueSBmaWVsZCBpcyBkaWZmZXJlbnQgaW4gYW55IHdheSwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgaW4gc29tZSBvcHRpbWlzYXRpb25zLCB0byBhdm9pZCB3b3JrIGlmIGFuIGVkaXQgdG8gZmlsZVxuICAgICAqIGRvZXMgbm90IGNoYW5nZSBhbnkgdGFza3MsIHNvIGl0IGlzIHZpdGFsIHRoYXQgaXRzIGRlZmluaXRpb25cbiAgICAgKiBvZiBpZGVudGljYWwgaXMgdmVyeSBzdHJpY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgaWRlbnRpY2FsVG8ob3RoZXI6IFRhc2spIHtcbiAgICAgICAgLy8gQmFzZWQgb24gaWRlYXMgZnJvbSBrb2FsYS4gQXF1YUNhdCBhbmQgamF2YWxlbnQgaW4gRGlzY29yZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82ODYwNTM3MDgyNjEyMjg1NzcvODQwMjg2MjY0OTY0MDIyMzAyLzk5NjczNTIwMDM4ODE4NjE4MlxuICAgICAgICAvLyBhbmQgbGF0ZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IHNlY3Rpb25TdGFydCBjaGFuZ2VzIGV2ZXJ5IHRpbWUgYSBsaW5lIGlzIGFkZGVkIG9yIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAgIC8vICAgICAgIGFueSBvZiB0aGUgdGFza3MgaW4gYSBmaWxlLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHJlZHJhd2luZyBvZiB0YXNrcyBibG9ja3NcbiAgICAgICAgLy8gICAgICAgaGFwcGVucyBtb3JlIG9mdGVuIHRoYW4gaXMgaWRlYWwuXG4gICAgICAgIGxldCBhcmdzOiBBcnJheTxrZXlvZiBUYXNrPiA9IFtcbiAgICAgICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAncGF0aCcsXG4gICAgICAgICAgICAnaW5kZW50YXRpb24nLFxuICAgICAgICAgICAgJ2xpc3RNYXJrZXInLFxuICAgICAgICAgICAgJ2xpbmVOdW1iZXInLFxuICAgICAgICAgICAgJ3NlY3Rpb25TdGFydCcsXG4gICAgICAgICAgICAnc2VjdGlvbkluZGV4JyxcbiAgICAgICAgICAgICdwcmVjZWRpbmdIZWFkZXInLFxuICAgICAgICAgICAgJ3ByaW9yaXR5JyxcbiAgICAgICAgICAgICdibG9ja0xpbmsnLFxuICAgICAgICAgICAgJ3NjaGVkdWxlZERhdGVJc0luZmVycmVkJyxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tlbF0gIT09IG90aGVyW2VsXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1cy5pZGVudGljYWxUbyhvdGhlci5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIHRhZ3NcbiAgICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggIT09IG90aGVyLnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFncyBhcmUgdGhlIHNhbWUgb25seSBpZiB0aGUgdmFsdWVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGhpcy50YWdzLmV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09PSBvdGhlci50YWdzW2luZGV4XTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBEYXRlIGZpZWxkc1xuICAgICAgICBhcmdzID0gWydjcmVhdGVkRGF0ZScsICdzdGFydERhdGUnLCAnc2NoZWR1bGVkRGF0ZScsICdkdWVEYXRlJywgJ2RvbmVEYXRlJ107XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgYXJncykge1xuICAgICAgICAgICAgY29uc3QgZGF0ZTEgPSB0aGlzW2VsXSBhcyBNb21lbnQgfCBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0ZTIgPSBvdGhlcltlbF0gYXMgTW9tZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChjb21wYXJlQnlEYXRlKGRhdGUxLCBkYXRlMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWN1cnJlbmNlMSA9IHRoaXMucmVjdXJyZW5jZTtcbiAgICAgICAgY29uc3QgcmVjdXJyZW5jZTIgPSBvdGhlci5yZWN1cnJlbmNlO1xuICAgICAgICBpZiAocmVjdXJyZW5jZTEgPT09IG51bGwgJiYgcmVjdXJyZW5jZTIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWN1cnJlbmNlMSAhPT0gbnVsbCAmJiByZWN1cnJlbmNlMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY3VycmVuY2UxICYmIHJlY3VycmVuY2UyICYmICFyZWN1cnJlbmNlMS5pZGVudGljYWxUbyhyZWN1cnJlbmNlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaGFzaHRhZ3MgZm91bmQgaW4gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gQSB0YXNrIGRlc2NyaXB0aW9uIHRoYXQgbWF5IGNvbnRhaW4gaGFzaHRhZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGhhc2hUYWdzIGZvdW5kIGluIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGV4dHJhY3RIYXNodGFncyhkZXNjcmlwdGlvbjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24ubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5oYXNoVGFncyk/Lm1hcCgodGFnKSA9PiB0YWcudHJpbSgpKSA/PyBbXTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBMYXp5IGxvYWRlZCB2YXJpYWJsZSA6IGZldGNoaW5nIHRoZSB2YWx1ZSBpcyBwb3N0cG9uZWQgdW50aWwgdGhlIGZpcnN0IGdldCgpXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5PFQ+IHtcbiAgICBwcml2YXRlIF92YWx1ZTogVCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIGxhenkgb2JqZWN0XG4gICAgICogQHBhcmFtIGZldGNoIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBmZXRjaDogKCkgPT4gVCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBsYXp5IHZhbHVlLCBjYWxsaW5nIHRoZSBmZXRjaCBmdW5jdGlvbiB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKTogVCB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZmV0Y2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBUYXNrTG9jYXRpb24gaXMgdGhlIHBsYWNlIHdoZXJlIGFsbCBpbmZvcm1hdGlvbiBhYm91dCBhIHRhc2sgbGluZSdzIGxvY2F0aW9uXG4gKiBpbiBhIG1hcmtkb3duIGZpbGUgaXMgc3RvcmVkLCBzbyB0aGF0IHRlc3RhYmxlIGFsZ29yaXRobXMgY2FuIHRoZW4gYmUgYWRkZWQgaGVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tMb2NhdGlvbiB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfcGF0aDogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2xpbmVOdW1iZXI6IG51bWJlcjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9zZWN0aW9uU3RhcnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9zZWN0aW9uSW5kZXg6IG51bWJlcjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9wcmVjZWRpbmdIZWFkZXI6IHN0cmluZyB8IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHBhdGg6IHN0cmluZyxcbiAgICAgICAgbGluZU51bWJlcjogbnVtYmVyLFxuICAgICAgICBzZWN0aW9uU3RhcnQ6IG51bWJlcixcbiAgICAgICAgc2VjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgIHByZWNlZGluZ0hlYWRlcjogc3RyaW5nIHwgbnVsbCxcbiAgICApIHtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2xpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSBzZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IHNlY3Rpb25JbmRleDtcbiAgICAgICAgdGhpcy5fcHJlY2VkaW5nSGVhZGVyID0gcHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLCBmb3IgdXNlIHdoZW4gdGhlIFRhc2sncyBleGFjdCBsb2NhdGlvbiBpbiBhIGZpbGUgaXMgZWl0aGVyIHVua25vd24sIG9yIG5vdCBuZWVkZWQuXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21Vbmtub3duUG9zaXRpb24ocGF0aDogc3RyaW5nKTogVGFza0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrTG9jYXRpb24ocGF0aCwgMCwgMCwgMCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IsIGZvciB3aGVuIHRoZSBmaWxlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBhbGwgb3RoZXIgZGF0YSByZW1haW5zIHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSBuZXdQYXRoXG4gICAgICovXG4gICAgZnJvbVJlbmFtZWRGaWxlKG5ld1BhdGg6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IFRhc2tMb2NhdGlvbihuZXdQYXRoLCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLnNlY3Rpb25JbmRleCwgdGhpcy5wcmVjZWRpbmdIZWFkZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcGF0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGxpbmVOdW1iZXIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXI7XG4gICAgfVxuXG4gICAgLyoqIExpbmUgbnVtYmVyIHdoZXJlIHRoZSBzZWN0aW9uIHN0YXJ0cyB0aGF0IGNvbnRhaW5zIHRoaXMgdGFzay4gKi9cbiAgICBnZXQgc2VjdGlvblN0YXJ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgbnRoIHRhc2sgaW4gaXRzIHNlY3Rpb24uICovXG4gICAgZ2V0IHNlY3Rpb25JbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbkluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcHJlY2VkaW5nSGVhZGVyKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlY2VkaW5nSGVhZGVyO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGFza01vZGFsIH0gZnJvbSAnLi4vVGFza01vZGFsJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi4vRGF0ZUZhbGxiYWNrJztcbmltcG9ydCB7IHRhc2tGcm9tTGluZSB9IGZyb20gJy4vQ3JlYXRlT3JFZGl0VGFza1BhcnNlcic7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVPckVkaXQgPSAoY2hlY2tpbmc6IGJvb2xlYW4sIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBWaWV3LCBhcHA6IEFwcCkgPT4ge1xuICAgIGlmIChjaGVja2luZykge1xuICAgICAgICByZXR1cm4gdmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldztcbiAgICB9XG5cbiAgICBpZiAoISh2aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSkge1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuIGR1ZSB0byBjaGVjayBhYm92ZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSB2aWV3LmZpbGU/LnBhdGg7XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgY29uc3QgbGluZU51bWJlciA9IGN1cnNvclBvc2l0aW9uLmxpbmU7XG4gICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuICAgIGNvbnN0IHRhc2sgPSB0YXNrRnJvbUxpbmUoeyBsaW5lLCBwYXRoIH0pO1xuXG4gICAgY29uc3Qgb25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IERhdGVGYWxsYmFjay5yZW1vdmVJbmZlcnJlZFN0YXR1c0lmTmVlZGVkKHRhc2ssIHVwZGF0ZWRUYXNrcylcbiAgICAgICAgICAgIC5tYXAoKHRhc2s6IFRhc2spID0+IHRhc2sudG9GaWxlTGluZVN0cmluZygpKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICBlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCBzZXJpYWxpemVkKTtcbiAgICB9O1xuXG4gICAgLy8gTmVlZCB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSwgYXMgY3Vyc29yL3Rhc2sgY2FuIGNoYW5nZS5cbiAgICBjb25zdCB0YXNrTW9kYWwgPSBuZXcgVGFza01vZGFsKHtcbiAgICAgICAgYXBwLFxuICAgICAgICB0YXNrLFxuICAgICAgICBvblN1Ym1pdCxcbiAgICB9KTtcbiAgICB0YXNrTW9kYWwub3BlbigpO1xufTtcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IEVkaXRUYXNrIGZyb20gJy4vdWkvRWRpdFRhc2suc3ZlbHRlJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4vVGFzayc7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4vU3RhdHVzUmVnaXN0cnknO1xuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi9TdGF0dXMnO1xuXG5leHBvcnQgY2xhc3MgVGFza01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHB1YmxpYyByZWFkb25seSB0YXNrOiBUYXNrO1xuICAgIHB1YmxpYyByZWFkb25seSBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoeyBhcHAsIHRhc2ssIG9uU3VibWl0IH06IHsgYXBwOiBBcHA7IHRhc2s6IFRhc2s7IG9uU3VibWl0OiAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHZvaWQgfSkge1xuICAgICAgICBzdXBlcihhcHApO1xuXG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZWRUYXNrcy5sZW5ndGggJiYgb25TdWJtaXQodXBkYXRlZFRhc2tzKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25PcGVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRpdGxlRWwuc2V0VGV4dCgnQ3JlYXRlIG9yIGVkaXQgVGFzaycpO1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCBzdGF0dXNPcHRpb25zID0gdGhpcy5nZXRLbm93blN0YXR1c2VzQW5kQ3VycmVudFRhc2tTdGF0dXNJZk5vdEtub3duKCk7XG5cbiAgICAgICAgbmV3IEVkaXRUYXNrKHtcbiAgICAgICAgICAgIHRhcmdldDogY29udGVudEVsLFxuICAgICAgICAgICAgcHJvcHM6IHsgdGFzazogdGhpcy50YXNrLCBzdGF0dXNPcHRpb25zOiBzdGF0dXNPcHRpb25zLCBvblN1Ym1pdDogdGhpcy5vblN1Ym1pdCB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFzayBiZWluZyBlZGl0ZWQgaGFzIGFuIHVua25vd24gc3RhdHVzLCBtYWtlIHN1cmUgaXQgaXMgYWRkZWRcbiAgICAgKiB0byB0aGUgZHJvcGRvd24gbGlzdC5cbiAgICAgKiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgc3RhdHVzIGFuZCB0aGVuIGNoYW5nZSB0aGVpclxuICAgICAqIG1pbmQgYW5kIHJldHVybiB0byB0aGUgaW5pdGlhbCBzdGF0dXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRLbm93blN0YXR1c2VzQW5kQ3VycmVudFRhc2tTdGF0dXNJZk5vdEtub3duKCkge1xuICAgICAgICBjb25zdCBzdGF0dXNPcHRpb25zOiBTdGF0dXNbXSA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkucmVnaXN0ZXJlZFN0YXR1c2VzO1xuICAgICAgICBpZiAoU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5ieVN5bWJvbCh0aGlzLnRhc2suc3RhdHVzLnN5bWJvbCkgPT09IFN0YXR1cy5FTVBUWSkge1xuICAgICAgICAgICAgc3RhdHVzT3B0aW9ucy5wdXNoKHRoaXMudGFzay5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXNPcHRpb25zO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkNsb3NlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuIiwgImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcbiAgICBjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuICAgIHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbdmFsdWUsICdweCddO1xufVxuY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuY2xhc3MgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9nZXRPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0T2JzZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX29ic2VydmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX2xpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0ICYmIGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuICAgIE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEodGFnKSB7XG4gICAgcmV0dXJuICgvLS8udGVzdCh0YWcpKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcbiAgICBsZXQgX2lucHV0cztcbiAgICByZXR1cm4ge1xuICAgICAgICAvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG4gICAgICAgICAgICBfaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IGdyb3VwLnB1c2goaW5wdXQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogcmVtb3ZlICovIHIoKSB7XG4gICAgICAgICAgICBfaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gZ3JvdXAuc3BsaWNlKGdyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMoZ3JvdXAsIGluZGV4ZXMpIHtcbiAgICBsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuICAgIGxldCBfaW5wdXRzO1xuICAgIGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IF9ncm91cC5wdXNoKGlucHV0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8qIHVwZGF0ZSAqLyB1KG5ld19pbmRleGVzKSB7XG4gICAgICAgICAgICBpbmRleGVzID0gbmV3X2luZGV4ZXM7XG4gICAgICAgICAgICBjb25zdCBuZXdfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG4gICAgICAgICAgICBpZiAobmV3X2dyb3VwICE9PSBfZ3JvdXApIHtcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBfZ3JvdXAgPSBuZXdfZ3JvdXA7XG4gICAgICAgICAgICAgICAgcHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG4gICAgICAgICAgICBfaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgcHVzaCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbW1lbnQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDgsIChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjb21tZW50KGRhdGEpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC5kYXRhID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcbiAgICBpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcbiAgICAgICAgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0X2RhdGEodGV4dCwgZGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBpbml0aWFsIHJlc2l6ZSBldmVudCBpcyBmaXJlZCBfYWZ0ZXJfIHRoZSBpZnJhbWUgaXMgbG9hZGVkICh3aGljaCBpcyBhc3luY2hyb25vdXMpXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNDIzM1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5jb25zdCByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHsgYm94OiAnY29udGVudC1ib3gnIH0pO1xuY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHsgYm94OiAnYm9yZGVyLWJveCcgfSk7XG5jb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfSk7XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHN0YXJ0ZWQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gbm9kZS50ZXh0Q29udGVudC50cmltKCk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X0VORGApIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkIC09IDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBpc19zdmc7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19zdmcpXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gc3ZnX2VsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCgodGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWUpKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnID8gdGFyZ2V0IDogdGFyZ2V0LmNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUubm9kZU5hbWUgPT09ICdURU1QTEFURScgPyB0aGlzLmUuY29udGVudC5jaGlsZE5vZGVzIDogdGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNfc3ZnKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBmb3IgbXVsdGlwbGUgZG9jdW1lbnRzIGJlY2F1c2UgYSBTdmVsdGUgYXBwbGljYXRpb24gY291bGQgYWxzbyBjb250YWluIGlmcmFtZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzM2MjRcbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuICAgIGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcbiAgICBtYW5hZ2VkX3N0eWxlcy5zZXQoZG9jLCBpbmZvKTtcbiAgICByZXR1cm4gaW5mbztcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuICAgIGlmICghcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiAnJ30ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG93bmVyTm9kZSB9ID0gaW5mby5zdHlsZXNoZWV0O1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gb3duZXJOb2RlIGlmIGl0IHJ1bnMgb24ganNkb20uXG4gICAgICAgICAgICBpZiAob3duZXJOb2RlKVxuICAgICAgICAgICAgICAgIGRldGFjaChvd25lck5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtYmVmb3JldXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIGEgW3NlcnZlci1zaWRlIGNvbXBvbmVudF0oL2RvY3MjcnVuLXRpbWUtc2VydmVyLXNpZGUtY29tcG9uZW50LWFwaSkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLW9ubW91bnRcbiAqL1xuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKi9cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLW9uZGVzdHJveVxuICovXG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oL2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtY3JlYXRlZXZlbnRkaXNwYXRjaGVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLXNldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0Y29udGV4dFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1nZXRhbGxjb250ZXh0c1xuICovXG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtaGFzY29udGV4dFxuICovXG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5jb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5jb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuICAgIC8vIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLiBJbnN0ZWFkLCBsZXQgdGhlIGlubmVyIGZsdXNoIGhhbmRsZSBpdC5cbiAgICAvLyBSZWVudHJhbmN5IGlzIG9rIGFmdGVyd2FyZHMgZm9yIGJpbmRpbmdzIGV0Yy5cbiAgICBpZiAoZmx1c2hpZHggIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRpcnR5IHN0YXRlIHRvIG5vdCBlbmQgdXAgaW4gYSBkZWFkbG9ja2VkIHN0YXRlIGFuZCB0aGVuIHJldGhyb3dcbiAgICAgICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VmdWwgZm9yIGV4YW1wbGUgdG8gZXhlY3V0ZSByZW1haW5pbmcgYGFmdGVyVXBkYXRlYCBjYWxsYmFja3MgYmVmb3JlIGV4ZWN1dGluZyBgZGVzdHJveWAuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoZm5zKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICBjb25zdCB0YXJnZXRzID0gW107XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKTtcbiAgICB0YXJnZXRzLmZvckVhY2goKGMpID0+IGMoKSk7XG4gICAgcmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnaW4nIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ291dCcgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IChwcm9ncmFtLmIgLSB0KTtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyBcdTIwMTQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyBcdTIwMTQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgLy8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcnVuX2FsbCh1cGRhdGVzKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbmNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSBbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2luZXJ0JyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXTtcbi8qKlxuICogTGlzdCBvZiBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcyAoZS5nLiBgPGlucHV0IGRpc2FibGVkPmApLlxuICogU291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbiAqL1xuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogcmVnZXggb2YgYWxsIGh0bWwgdm9pZCBlbGVtZW50IG5hbWVzICovXG5jb25zdCB2b2lkX2VsZW1lbnRfbmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvO1xuZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG4gICAgcmV0dXJuIHZvaWRfZWxlbWVudF9uYW1lcy50ZXN0KG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChhdHRyc190b19hZGQpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3NlcztcbiAgICAgICAgY29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG4gICAgICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZXNfdG9fYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKG1lcmdlX3Nzcl9zdHlsZXMoYXR0cmlidXRlcy5zdHlsZSwgc3R5bGVzX3RvX2FkZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICBjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGluZGl2aWR1YWxfc3R5bGUgb2Ygc3R5bGVfYXR0cmlidXRlLnNwbGl0KCc7JykpIHtcbiAgICAgICAgY29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKGNvbG9uX2luZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZV9vYmplY3Q7XG59XG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh2YWx1ZSwgaXNfYXR0ciA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICB3aGlsZSAocGF0dGVybi50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgY2ggPSBzdHJbaV07XG4gICAgICAgIGVzY2FwZWQgKz0gc3RyLnN1YnN0cmluZyhsYXN0LCBpKSArIChjaCA9PT0gJyYnID8gJyZhbXA7JyA6IChjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKSk7XG4gICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuICAgIC8vIGtlZXAgYm9vbGVhbnMsIG51bGwsIGFuZCB1bmRlZmluZWQgZm9yIHRoZSBzYWtlIG9mIGBzcHJlYWRgXG4gICAgY29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuICAgIHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlX29iamVjdChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXMuIE90aGVyd2lzZSB5b3UgbWF5IG5lZWQgdG8gZml4IGEgPCR7bmFtZX0+LmApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBhc3NpZ25tZW50ID0gKGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUpID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcbiAgICByZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5mdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuZnVuY3Rpb24gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuICAgICAgICAuZmlsdGVyKGtleSA9PiBzdHlsZV9vYmplY3Rba2V5XSlcbiAgICAgICAgLm1hcChrZXkgPT4gYCR7a2V5fTogJHtlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHN0eWxlX29iamVjdFtrZXldKX07YClcbiAgICAgICAgLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuICAgIHJldHVybiBzdHlsZXMgPyBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBpdCB3aWxsIHVwZGF0ZSB0aGUgYCQkLm9uX2Rlc3Ryb3lgIHJlZmVyZW5jZSB0byBgbnVsbGAuXG4gICAgICAgICAgICAvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcbiAgICAgICAgICAgICAgICBydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogW10sXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIHByb3BzLFxuICAgICAgICB1cGRhdGU6IG5vb3AsXG4gICAgICAgIG5vdF9lcXVhbCxcbiAgICAgICAgYm91bmQ6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICAvLyBsaWZlY3ljbGVcbiAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICBvbl9kZXN0cm95OiBbXSxcbiAgICAgICAgb25fZGlzY29ubmVjdDogW10sXG4gICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICBjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgc2tpcF9ib3VuZDogZmFsc2UsXG4gICAgICAgIHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuICAgIH07XG4gICAgYXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICQkLmN0eCA9IGluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgc3RhcnRfaHlkcmF0aW5nKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50cm8pXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvciwgb3B0aW9ucy5jdXN0b21FbGVtZW50KTtcbiAgICAgICAgZW5kX2h5ZHJhdGluZygpO1xuICAgICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5sZXQgU3ZlbHRlRWxlbWVudDtcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbl9tb3VudCB9ID0gdGhpcy4kJDtcbiAgICAgICAgICAgIHRoaXMuJCQub25fZGlzY29ubmVjdCA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJC5zbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuJCQuc2xvdHRlZFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgICRkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgZGVsZWdhdGUgdG8gYWRkRXZlbnRMaXN0ZW5lcj9cbiAgICAgICAgICAgIGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjU5LjEnIH0sIGRldGFpbCksIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbiwgaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGlmIChoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24nKTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgY29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuICAgIGVsc2VcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC5kYXRhID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG4gICAgaWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG4gICAgICAgIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBlcnJvcl9tZXNzYWdlID0gJ3RoaXM9ey4uLn0gb2YgPHN2ZWx0ZTpjb21wb25lbnQ+IHNob3VsZCBzcGVjaWZ5IGEgU3ZlbHRlIGNvbXBvbmVudC4nO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGNvbXBvbmVudChwcm9wcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2UuJCQgfHwgIWluc3RhbmNlLiRzZXQgfHwgIWluc3RhbmNlLiRvbiB8fCAhaW5zdGFuY2UuJGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBlcnI7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKCdpcyBub3QgYSBjb25zdHJ1Y3RvcicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24sIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVDb21wb25lbnRUeXBlZCwgU3ZlbHRlRWxlbWVudCwgYWN0aW9uX2Rlc3Ryb3llciwgYWRkX2F0dHJpYnV0ZSwgYWRkX2NsYXNzZXMsIGFkZF9mbHVzaF9jYWxsYmFjaywgYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIsIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3N0eWxlcywgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tbWVudCwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tbWVudCwgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudCwgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2LCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcywgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGhlYWRfc2VsZWN0b3IsIGlkZW50aXR5LCBpbml0LCBpbml0X2JpbmRpbmdfZ3JvdXAsIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljLCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCwgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94LCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94LCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCwgc2V0X2RhdGEsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSwgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldiwgc2V0X2RhdGFfZGV2LCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwbGl0X2Nzc191bml0LCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24sIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHRydXN0ZWQsIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2gsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3RfYmFzZSwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCwgeGxpbmtfYXR0ciB9O1xuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0ICogYXMgY2hyb25vIGZyb20gJ2Nocm9uby1ub2RlJztcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBSZWN1cnJlbmNlIH0gZnJvbSAnLi4vUmVjdXJyZW5jZSc7XG4gICAgaW1wb3J0IHsgZ2V0U2V0dGluZ3MsIFRBU0tfRk9STUFUUyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG4gICAgaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG4gICAgaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzJztcbiAgICBpbXBvcnQgeyBQcmlvcml0eSwgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuICAgIGltcG9ydCB7IGRvQXV0b2NvbXBsZXRlIH0gZnJvbSAnLi4vRGF0ZUFiYnJldmlhdGlvbnMnO1xuICAgIGltcG9ydCB7IFRhc2tzRGF0ZSB9IGZyb20gJy4uL1NjcmlwdGluZy9UYXNrc0RhdGUnO1xuXG4gICAgLy8gVGhlc2UgZXhwb3J0ZWQgdmFyaWFibGVzIGFyZSBwYXNzZWQgaW4gYXMgcHJvcHMgYnkgVGFza01vZGFsLm9uT3BlbigpOlxuICAgIGV4cG9ydCBsZXQgdGFzazogVGFzaztcbiAgICBleHBvcnQgbGV0IG9uU3VibWl0OiAodXBkYXRlZFRhc2tzOiBUYXNrW10pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICAgIGV4cG9ydCBsZXQgc3RhdHVzT3B0aW9uczogU3RhdHVzW107XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHByaW9yaXR5U3ltYm9scyxcbiAgICAgICAgcmVjdXJyZW5jZVN5bWJvbCxcbiAgICAgICAgc3RhcnREYXRlU3ltYm9sLFxuICAgICAgICBzY2hlZHVsZWREYXRlU3ltYm9sLFxuICAgICAgICBkdWVEYXRlU3ltYm9sLFxuICAgIH0gPSBUQVNLX0ZPUk1BVFMudGFza3NQbHVnaW5FbW9qaS50YXNrU2VyaWFsaXplci5zeW1ib2xzO1xuXG4gICAgbGV0IGRlc2NyaXB0aW9uSW5wdXQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgbGV0IGVkaXRhYmxlVGFzazoge1xuICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgICBzdGF0dXM6IFN0YXR1cztcbiAgICAgICAgcHJpb3JpdHk6ICdub25lJyB8ICdsb3dlc3QnIHwgJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdoaWdoZXN0JztcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6IHN0cmluZztcbiAgICAgICAgY3JlYXRlZERhdGU6IHN0cmluZztcbiAgICAgICAgc3RhcnREYXRlOiBzdHJpbmc7XG4gICAgICAgIHNjaGVkdWxlZERhdGU6IHN0cmluZztcbiAgICAgICAgZHVlRGF0ZTogc3RyaW5nO1xuICAgICAgICBkb25lRGF0ZTogc3RyaW5nO1xuICAgICAgICBmb3J3YXJkT25seTogYm9vbGVhbjtcbiAgICB9ID0ge1xuICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIHN0YXR1czogU3RhdHVzLlRPRE8sXG4gICAgICAgIHByaW9yaXR5OiAnbm9uZScsXG4gICAgICAgIHJlY3VycmVuY2VSdWxlOiAnJyxcbiAgICAgICAgY3JlYXRlZERhdGU6ICcnLFxuICAgICAgICBzdGFydERhdGU6ICcnLFxuICAgICAgICBzY2hlZHVsZWREYXRlOiAnJyxcbiAgICAgICAgZHVlRGF0ZTogJycsXG4gICAgICAgIGRvbmVEYXRlOiAnJyxcbiAgICAgICAgZm9yd2FyZE9ubHk6IHRydWVcbiAgICB9O1xuXG4gICAgbGV0IGlzRGVzY3JpcHRpb25WYWxpZDogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IHBhcnNlZENyZWF0ZWQ6IHN0cmluZyA9ICcnO1xuICAgIGxldCBwYXJzZWRTdGFydERhdGU6IHN0cmluZyA9ICcnO1xuICAgIGxldCBpc1N0YXJ0RGF0ZVZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBsZXQgcGFyc2VkU2NoZWR1bGVkRGF0ZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IGlzU2NoZWR1bGVkRGF0ZVZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBsZXQgcGFyc2VkRHVlRGF0ZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IGlzRHVlRGF0ZVZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBsZXQgcGFyc2VkUmVjdXJyZW5jZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IGlzUmVjdXJyZW5jZVZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBsZXQgcGFyc2VkRG9uZTogc3RyaW5nID0gJyc7XG4gICAgbGV0IGFkZEdsb2JhbEZpbHRlck9uU2F2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGxldCB3aXRoQWNjZXNzS2V5czogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IGZvcm1Jc1ZhbGlkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8vICd3ZWVrZW5kJyBhYmJyZXZpYXRpb24gb21taXR0ZWQgZHVlIHRvIGxhY2sgb2Ygc3BhY2UuXG4gICAgbGV0IGRhdGVQbGFjZWhvbGRlciA9XG4gICAgICAgIFwiVHJ5ICdNb25kYXknIG9yICd0b21vcnJvdycsIG9yIFt0ZHx0bXx5ZHx0d3xud3x3ZV0gdGhlbiBzcGFjZS5cIjtcblxuICAgIGNvbnN0IHByaW9yaXR5T3B0aW9uczoge1xuICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBlZGl0YWJsZVRhc2sucHJpb3JpdHksXG4gICAgICAgICAgICBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgc3ltYm9sOiBzdHJpbmcsXG4gICAgICAgICAgICBhY2Nlc3NLZXk6IHN0cmluZyxcbiAgICAgICAgICAgIGFjY2Vzc0tleUluZGV4OiBudW1iZXJ9W10gPVxuICAgICAgICBbe1xuICAgICAgICAgICAgdmFsdWU6ICdsb3dlc3QnLFxuICAgICAgICAgICAgbGFiZWw6ICdMb3dlc3QnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuTG93ZXN0LFxuICAgICAgICAgICAgYWNjZXNzS2V5OiAnbycsXG4gICAgICAgICAgICBhY2Nlc3NLZXlJbmRleDogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogJ2xvdycsXG4gICAgICAgICAgICBsYWJlbDogJ0xvdycsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5Mb3csXG4gICAgICAgICAgICBhY2Nlc3NLZXk6ICdsJyxcbiAgICAgICAgICAgIGFjY2Vzc0tleUluZGV4OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAnbm9uZScsXG4gICAgICAgICAgICBsYWJlbDogJ05vcm1hbCcsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5Ob25lLFxuICAgICAgICAgICAgYWNjZXNzS2V5OiAnbicsXG4gICAgICAgICAgICBhY2Nlc3NLZXlJbmRleDogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogJ21lZGl1bScsXG4gICAgICAgICAgICBsYWJlbDogJ01lZGl1bScsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5NZWRpdW0sXG4gICAgICAgICAgICBhY2Nlc3NLZXk6ICdtJyxcbiAgICAgICAgICAgIGFjY2Vzc0tleUluZGV4OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAnaGlnaCcsXG4gICAgICAgICAgICBsYWJlbDogJ0hpZ2gnLFxuICAgICAgICAgICAgc3ltYm9sOiBwcmlvcml0eVN5bWJvbHMuSGlnaCxcbiAgICAgICAgICAgIGFjY2Vzc0tleTogJ2gnLFxuICAgICAgICAgICAgYWNjZXNzS2V5SW5kZXg6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdmFsdWU6ICdoaWdoZXN0JyxcbiAgICAgICAgICAgIGxhYmVsOiAnSGlnaGVzdCcsXG4gICAgICAgICAgICBzeW1ib2w6IHByaW9yaXR5U3ltYm9scy5IaWdoZXN0LFxuICAgICAgICAgICAgYWNjZXNzS2V5OiAnaScsXG4gICAgICAgICAgICBhY2Nlc3NLZXlJbmRleDogMVxuICAgICAgICB9XVxuXG4gICAgLypcbiAgICAgICAgTUFJTlRFTkFOQ0UgTk9URSBvbiB0aGVzZSBEYXRlIGZ1bmN0aW9uczpcbiAgICAgICAgICAgIFJlcGV0aXRpb3VzIGRhdGUtcmVsYXRlZCBjb2RlIGluIHRoaXMgZmlsZSBoYXMgYmVlbiBleHRyYWN0ZWRcbiAgICAgICAgICAgIG91dCBpbiB0byBzZXZlcmFsIHBhcnNlVHlwZWREYXRlRm9yLi4uLigpIGZ1bmN0aW9ucyBvdmVyIHRpbWUuXG5cbiAgICAgICAgICAgIFRoZXJlIGlzIHNvbWUgc2ltaWxhcml0eSBiZXR3ZWVuIHRoZXNlIGZ1bmN0aW9ucywgYW5kIGFsc29cbiAgICAgICAgICAgIHNvbWUgc3VidGxlIGRpZmZlcmVuY2VzLlxuXG4gICAgICAgICAgICBGdXR1cmUgcmVmYWN0b3JpbmcgdG8gc2ltcGxpZnkgdGhlbSB3b3VsZCBiZSB3ZWxjb21lZC5cblxuICAgICAgICAgICAgV2hlbiBlZGl0aW5nIG9mIERvbmUgZGF0ZSBpcyBpbnRyb2R1Y2VkLCB0aGUgZnVuY3Rpb25zXG4gICAgICAgICAgICBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXlVc2luZ0Z1dHVyZURhdGUoKSBhbmQgcGFyc2VUeXBlZERhdGVGb3JEaXNwbGF5KClcbiAgICAgICAgICAgIG1heSBjb2xsYXBzZSBpbiB0byBhIHNpbmdsZSBjYXNlLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYW5kIHJldHVybiB0aGUgZW50ZXJlZCB2YWx1ZSBmb3IgYSBkYXRlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWVcbiAgICAgKiBAcGFyYW0gdHlwZWREYXRlIC0gd2hhdCB0aGUgdXNlciBoYXMgZW50ZXJlZCwgc3VjaCBhcyAnMjAyMy0wMS0yMycgb3IgJ3RvbW9ycm93J1xuICAgICAqIEBwYXJhbSBmb3J3YXJkRGF0ZVxuICAgICAqIEByZXR1cm5zIHRoZSBwYXJzZWQgZGF0ZSBzdHJpbmcuIEluY2x1ZGVzIFwiaW52YWxpZFwiIGlmIHtAY29kZSB0eXBlZERhdGV9IHdhcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheShcbiAgICAgICAgZmllbGROYW1lOiAnY3JlYXRlZCcgfCAnc3RhcnQnIHwgJ3NjaGVkdWxlZCcgfCAnZHVlJyB8ICdkb25lJyxcbiAgICAgICAgdHlwZWREYXRlOiBzdHJpbmcsXG4gICAgICAgIGZvcndhcmREYXRlOiBEYXRlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdHlwZWREYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxpPm5vICR7ZmllbGROYW1lfSBkYXRlPC9pPmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkID0gY2hyb25vLnBhcnNlRGF0ZSh0eXBlZERhdGUsIGZvcndhcmREYXRlLCB7XG4gICAgICAgICAgICBmb3J3YXJkRGF0ZTogZm9yd2FyZERhdGUgIT0gdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5tb21lbnQocGFyc2VkKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxpPmludmFsaWQgJHtmaWVsZE5hbWV9IGRhdGU8L2k+YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWtlIHtAbGluayBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXl9IGJ1dCBhbHNvIGFjY291bnRzIGZvciB0aGUgJ09ubHkgZnV0dXJlIGRhdGVzJyBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWVcbiAgICAgKiBAcGFyYW0gdHlwZWREYXRlIC0gd2hhdCB0aGUgdXNlciBoYXMgZW50ZXJlZCwgc3VjaCBhcyAnMjAyMy0wMS0yMycgb3IgJ3RvbW9ycm93J1xuICAgICAqIEByZXR1cm5zIHRoZSBwYXJzZWQgZGF0ZSBzdHJpbmcuIEluY2x1ZGVzIFwiaW52YWxpZFwiIGlmIHtAY29kZSB0eXBlZERhdGV9IHdhcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheVVzaW5nRnV0dXJlRGF0ZShmaWVsZE5hbWU6ICdzdGFydCcgfCAnc2NoZWR1bGVkJyB8ICdkdWUnIHwgJ2RvbmUnLCB0eXBlZERhdGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXkoXG4gICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgICB0eXBlZERhdGUsXG4gICAgICAgICAgICBlZGl0YWJsZVRhc2suZm9yd2FyZE9ubHkgPyBuZXcgRGF0ZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVudGVyZWQgdmFsdWUgZm9yIGEgZGF0ZSBmaWVsZCwgYW5kIHJldHVybiB0aGUgdmFsdWUgdG8gYmUgc2F2ZWQgaW4gdGhlIGVkaXRlZCB0YXNrLlxuICAgICAqIEBwYXJhbSB0eXBlZERhdGUgLSB3aGF0IHRoZSB1c2VyIGhhcyBlbnRlcmVkLCBzdWNoIGFzICcyMDIzLTAxLTIzJyBvciAndG9tb3Jyb3cnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcodHlwZWREYXRlOiBzdHJpbmcpOiBtb21lbnQuTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIGxldCBkYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBjaHJvbm8ucGFyc2VEYXRlKFxuICAgICAgICAgICAgdHlwZWREYXRlLFxuICAgICAgICAgICAgbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHsgZm9yd2FyZERhdGU6IGVkaXRhYmxlVGFzay5mb3J3YXJkT25seSB9LFxuICAgICAgICApO1xuICAgICAgICBpZiAocGFyc2VkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0ZSA9IHdpbmRvdy5tb21lbnQocGFyc2VkRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgJDogYWNjZXNza2V5ID0gKGtleTogc3RyaW5nKSA9PiB3aXRoQWNjZXNzS2V5cyA/IGtleSA6IG51bGw7XG4gICAgJDogZm9ybUlzVmFsaWQgPSBpc0R1ZURhdGVWYWxpZCAmJiBpc1JlY3VycmVuY2VWYWxpZCAmJiBpc1NjaGVkdWxlZERhdGVWYWxpZCAmJiBpc1N0YXJ0RGF0ZVZhbGlkICYmIGlzRGVzY3JpcHRpb25WYWxpZDtcbiAgICAkOiBpc0Rlc2NyaXB0aW9uVmFsaWQgPSBlZGl0YWJsZVRhc2suZGVzY3JpcHRpb24udHJpbSgpICE9PSAnJztcblxuICAgICQ6IHtcbiAgICAgICAgZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGVkaXRhYmxlVGFzay5zdGFydERhdGUpO1xuICAgICAgICBwYXJzZWRTdGFydERhdGUgPSBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXlVc2luZ0Z1dHVyZURhdGUoJ3N0YXJ0JywgZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSk7XG4gICAgICAgIGlzU3RhcnREYXRlVmFsaWQgPSAhcGFyc2VkU3RhcnREYXRlLmluY2x1ZGVzKCdpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBlZGl0YWJsZVRhc2suc2NoZWR1bGVkRGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGVkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlKTtcbiAgICAgICAgcGFyc2VkU2NoZWR1bGVkRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheVVzaW5nRnV0dXJlRGF0ZSgnc2NoZWR1bGVkJywgZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGUpO1xuICAgICAgICBpc1NjaGVkdWxlZERhdGVWYWxpZCA9ICFwYXJzZWRTY2hlZHVsZWREYXRlLmluY2x1ZGVzKCdpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBlZGl0YWJsZVRhc2suZHVlRGF0ZSA9IGRvQXV0b2NvbXBsZXRlKGVkaXRhYmxlVGFzay5kdWVEYXRlKTtcbiAgICAgICAgcGFyc2VkRHVlRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheVVzaW5nRnV0dXJlRGF0ZSgnZHVlJywgZWRpdGFibGVUYXNrLmR1ZURhdGUpO1xuICAgICAgICBpc0R1ZURhdGVWYWxpZCA9ICFwYXJzZWREdWVEYXRlLmluY2x1ZGVzKCdpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgJDoge1xuICAgICAgICBpc1JlY3VycmVuY2VWYWxpZCA9IHRydWU7XG4gICAgICAgIGlmICghZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlKSB7XG4gICAgICAgICAgICBwYXJzZWRSZWN1cnJlbmNlID0gJzxpPm5vdCByZWN1cnJpbmc8Lz4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVjdXJyZW5jZUZyb21UZXh0ID0gUmVjdXJyZW5jZS5mcm9tVGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlVGV4dDogZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGZvciByZXByZXNlbnRhdGlvbiBpbiB0aGUgbW9kYWwsIG5vIGRhdGVzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGR1ZURhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk/LnRvVGV4dCgpO1xuICAgICAgICAgICAgaWYgKCFyZWN1cnJlbmNlRnJvbVRleHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRSZWN1cnJlbmNlID0gJzxpPmludmFsaWQgcmVjdXJyZW5jZSBydWxlPC9pPic7XG4gICAgICAgICAgICAgICAgaXNSZWN1cnJlbmNlVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkUmVjdXJyZW5jZSA9IHJlY3VycmVuY2VGcm9tVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICQ6IHtcbiAgICAgICAgcGFyc2VkQ3JlYXRlZCA9IHBhcnNlVHlwZWREYXRlRm9yRGlzcGxheSgnY3JlYXRlZCcsIGVkaXRhYmxlVGFzay5jcmVhdGVkRGF0ZSk7XG4gICAgICAgIHBhcnNlZERvbmUgPSBwYXJzZVR5cGVkRGF0ZUZvckRpc3BsYXkoJ2RvbmUnLCBlZGl0YWJsZVRhc2suZG9uZURhdGUpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVBY2Nlc3NLZXlzIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICB3aXRoQWNjZXNzS2V5cyA9IHByb3ZpZGVBY2Nlc3NLZXlzO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnJlbW92ZUFzV29yZEZyb20odGFzay5kZXNjcmlwdGlvbik7XG4gICAgICAgIC8vIElmIHdlJ3JlIGRpc3BsYXlpbmcgdG8gdGhlIHVzZXIgdGhlIGRlc2NyaXB0aW9uIHdpdGhvdXQgdGhlIGdsb2JhbCBmaWx0ZXIgKGkuZS4gaXQgd2FzIHJlbW92ZWQgaW4gdGhlIG1ldGhvZFxuICAgICAgICAvLyBhYm92ZSksIG9yIGlmIHRoZSBkZXNjcmlwdGlvbiBkaWQgbm90IGluY2x1ZGUgYSBnbG9iYWwgZmlsdGVyIGluIHRoZSBmaXJzdCBwbGFjZSwgd2UnbGwgYWRkIHRoZSBnbG9iYWwgZmlsdGVyXG4gICAgICAgIC8vIHdoZW4gc2F2aW5nIHRoZSB0YXNrLlxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT0gdGFzay5kZXNjcmlwdGlvbiB8fCAhR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuaW5jbHVkZWRJbih0YXNrLmRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgYWRkR2xvYmFsRmlsdGVyT25TYXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpb3JpdHk6IHR5cGVvZiBlZGl0YWJsZVRhc2sucHJpb3JpdHkgPSAnbm9uZSc7XG4gICAgICAgIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5Mb3dlc3QpIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gJ2xvd2VzdCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGFzay5wcmlvcml0eSA9PT0gUHJpb3JpdHkuTG93KSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdsb3cnO1xuICAgICAgICB9IGVsc2UgaWYgKHRhc2sucHJpb3JpdHkgPT09IFByaW9yaXR5Lk1lZGl1bSkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSAnbWVkaXVtJztcbiAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5IaWdoKSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdoaWdoJztcbiAgICAgICAgfSBlbHNlIGlmICh0YXNrLnByaW9yaXR5ID09PSBQcmlvcml0eS5IaWdoZXN0KSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdoaWdoZXN0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRhYmxlVGFzayA9IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc3RhdHVzOiB0YXNrLnN0YXR1cyxcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgcmVjdXJyZW5jZVJ1bGU6IHRhc2sucmVjdXJyZW5jZSA/IHRhc2sucmVjdXJyZW5jZS50b1RleHQoKSA6ICcnLFxuICAgICAgICAgICAgY3JlYXRlZERhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5jcmVhdGVkRGF0ZSkuZm9ybWF0QXNEYXRlKCksXG4gICAgICAgICAgICBzdGFydERhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5zdGFydERhdGUpLmZvcm1hdEFzRGF0ZSgpLFxuICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZTogbmV3IFRhc2tzRGF0ZSh0YXNrLnNjaGVkdWxlZERhdGUpLmZvcm1hdEFzRGF0ZSgpLFxuICAgICAgICAgICAgZHVlRGF0ZTogbmV3IFRhc2tzRGF0ZSh0YXNrLmR1ZURhdGUpLmZvcm1hdEFzRGF0ZSgpLFxuICAgICAgICAgICAgZG9uZURhdGU6IG5ldyBUYXNrc0RhdGUodGFzay5kb25lRGF0ZSkuZm9ybWF0QXNEYXRlKCksXG4gICAgICAgICAgICBmb3J3YXJkT25seTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbklucHV0LmZvY3VzKCk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IF9vblByaW9yaXR5S2V5dXAgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eU9wdGlvbiA9IHByaW9yaXR5T3B0aW9ucy5maW5kKFxuICAgICAgICAgICAgICAgIG9wdGlvbiA9PiBvcHRpb24ubGFiZWwuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgPT0gZXZlbnQua2V5KTtcbiAgICAgICAgICAgIGlmIChwcmlvcml0eU9wdGlvbikge1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlVGFzay5wcmlvcml0eSA9IHByaW9yaXR5T3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgX29uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIG9uU3VibWl0KFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBfb25EZXNjcmlwdGlvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChmb3JtSXNWYWxpZCkgX29uU3VibWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIGNhbGxlZCwgd2hlbiB0ZXh0IGlzIHBhc3RlZCBvciBkcm9wcGVkIGludG9cbiAgICAvLyB0aGUgZGVzY3JpcHRpb24gZmllbGQsIHRvIHJlbW92ZSBhbnkgbGluZWJyZWFrc1xuICAgIGNvbnN0IF9yZW1vdmVMaW5lYnJlYWtzRnJvbURlc2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAvLyB3cmFwcGVkIGludG8gYSB0aW1lciB0byBydW4gYWZ0ZXIgdGhlIHBhc3RlL2Ryb3AgZXZlbnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGVkaXRhYmxlVGFzay5kZXNjcmlwdGlvbiA9IGVkaXRhYmxlVGFzay5kZXNjcmlwdGlvbi5yZXBsYWNlKC9bXFxyXFxuXSsvZywgJyAnKX0sIDApO1xuICAgIH1cblxuICAgIGNvbnN0IF9vblN1Ym1pdCA9ICgpID0+IHtcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9uLnRyaW0oKTtcbiAgICAgICAgaWYgKGFkZEdsb2JhbEZpbHRlck9uU2F2ZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5wcmVwZW5kVG8oZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcoZWRpdGFibGVUYXNrLnN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkRGF0ZSA9IHBhcnNlVHlwZWREYXRlRm9yU2F2aW5nKGVkaXRhYmxlVGFzay5zY2hlZHVsZWREYXRlKTtcblxuICAgICAgICBjb25zdCBkdWVEYXRlID0gcGFyc2VUeXBlZERhdGVGb3JTYXZpbmcoZWRpdGFibGVUYXNrLmR1ZURhdGUpO1xuXG4gICAgICAgIGxldCByZWN1cnJlbmNlOiBSZWN1cnJlbmNlIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChlZGl0YWJsZVRhc2sucmVjdXJyZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIHJlY3VycmVuY2UgPSBSZWN1cnJlbmNlLmZyb21UZXh0KHtcbiAgICAgICAgICAgICAgICByZWN1cnJlbmNlUnVsZVRleHQ6IGVkaXRhYmxlVGFzay5yZWN1cnJlbmNlUnVsZSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkRGF0ZSxcbiAgICAgICAgICAgICAgICBkdWVEYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyc2VkUHJpb3JpdHk6IFByaW9yaXR5O1xuICAgICAgICBzd2l0Y2ggKGVkaXRhYmxlVGFzay5wcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSAnbG93ZXN0JzpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5Lkxvd2VzdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5Mb3c7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgIHBhcnNlZFByaW9yaXR5ID0gUHJpb3JpdHkuTWVkaXVtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlnaCc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlnaGVzdCc6XG4gICAgICAgICAgICAgICAgcGFyc2VkUHJpb3JpdHkgPSBQcmlvcml0eS5IaWdoZXN0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwYXJzZWRQcmlvcml0eSA9IFByaW9yaXR5Lk5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkVGFzayA9IG5ldyBUYXNrKHtcbiAgICAgICAgICAgIC4uLnRhc2ssXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHN0YXR1czogZWRpdGFibGVUYXNrLnN0YXR1cyxcbiAgICAgICAgICAgIHByaW9yaXR5OiBwYXJzZWRQcmlvcml0eSxcbiAgICAgICAgICAgIHJlY3VycmVuY2UsXG4gICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlLFxuICAgICAgICAgICAgZHVlRGF0ZSxcbiAgICAgICAgICAgIGRvbmVEYXRlOiB3aW5kb3dcbiAgICAgICAgICAgICAgICAubW9tZW50KGVkaXRhYmxlVGFzay5kb25lRGF0ZSwgJ1lZWVktTU0tREQnKVxuICAgICAgICAgICAgICAgIC5pc1ZhbGlkKClcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5tb21lbnQoZWRpdGFibGVUYXNrLmRvbmVEYXRlLCAnWVlZWS1NTS1ERCcpXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBvblN1Ym1pdChbdXBkYXRlZFRhc2tdKTtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbFwiPlxuICAgIDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17X29uU3VibWl0fSBjbGFzczp3aXRoLWFjY2Vzc2tleXM9XCJ7d2l0aEFjY2Vzc0tleXN9XCI+XG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8IS0tICBEZXNjcmlwdGlvbiAgLS0+XG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFza3MtbW9kYWwtc2VjdGlvblwiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRlc2NyaXB0aW9uXCI+RGVzY3JpcDxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCI+dDwvc3Bhbj5pb248L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLmRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgIGJpbmQ6dGhpcz17ZGVzY3JpcHRpb25JbnB1dH1cbiAgICAgICAgICAgICAgICBpZD1cImRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhc2tzLW1vZGFsLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRha2Ugb3V0IHRoZSB0cmFzaFwiXG4gICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoXCJ0XCIpfVxuICAgICAgICAgICAgICAgIG9uOmtleWRvd249e19vbkRlc2NyaXB0aW9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICBvbjpwYXN0ZT17X3JlbW92ZUxpbmVicmVha3NGcm9tRGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgb246ZHJvcD17X3JlbW92ZUxpbmVicmVha3NGcm9tRGVzY3JpcHRpb259XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgUHJpb3JpdHkgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb24gdGFza3MtbW9kYWwtcHJpb3JpdGllc1wiIG9uOmtleXVwPXtfb25Qcmlvcml0eUtleXVwfT5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJwcmlvcml0eS17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVwiPlByaW9yaXR5PC9sYWJlbD5cbiAgICAgICAgICAgIHsjZWFjaCBwcmlvcml0eU9wdGlvbnMgYXMge3ZhbHVlLCBsYWJlbCwgc3ltYm9sLCBhY2Nlc3NLZXksIGFjY2Vzc0tleUluZGV4fX1cbiAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cInByaW9yaXR5LXt2YWx1ZX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZDpncm91cD17ZWRpdGFibGVUYXNrLnByaW9yaXR5fVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoYWNjZXNzS2V5KX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInByaW9yaXR5LXt2YWx1ZX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntsYWJlbC5zdWJzdHJpbmcoMCxhY2Nlc3NLZXlJbmRleCl9PC9zcGFuPjxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCI+e2xhYmVsLnN1YnN0cmluZyhhY2Nlc3NLZXlJbmRleCxhY2Nlc3NLZXlJbmRleCsxKX08L3NwYW4+PHNwYW4+e2xhYmVsLnN1YnN0cmluZyhhY2Nlc3NLZXlJbmRleCsxKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHN5bWJvbCAmJiBzeW1ib2wuY2hhckNvZGVBdCgwKSA+PSAweDEwMH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57c3ltYm9sfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPCEtLSAgUmVjdXJyZW5jZSBhbmQgRGF0ZXMgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb24gdGFza3MtbW9kYWwtZGF0ZXNcIj5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgUmVjdXJyZW5jZSAgLS0+XG4gICAgICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZWN1cnJlbmNlXCIgY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj5SZWN1cnM8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnJlY3VycmVuY2VSdWxlfVxuICAgICAgICAgICAgICAgIGlkPVwicmVjdXJyZW5jZVwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzOnRhc2tzLW1vZGFsLWVycm9yPXshaXNSZWN1cnJlbmNlVmFsaWR9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUcnkgJ2V2ZXJ5IDIgd2Vla3Mgb24gVGh1cnNkYXknLlwiXG4gICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoXCJyXCIpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjb2RlPntyZWN1cnJlbmNlU3ltYm9sfSB7QGh0bWwgcGFyc2VkUmVjdXJyZW5jZX08L2NvZGU+XG5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgRHVlIERhdGUgIC0tPlxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZHVlXCIgY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj5EdWU8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLmR1ZURhdGV9XG4gICAgICAgICAgICAgICAgaWQ9XCJkdWVcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzczp0YXNrcy1tb2RhbC1lcnJvcj17IWlzRHVlRGF0ZVZhbGlkfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtkYXRlUGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoXCJkXCIpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjb2RlPntkdWVEYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkRHVlRGF0ZX08L2NvZGU+XG5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgU2NoZWR1bGVkIERhdGUgIC0tPlxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwic2NoZWR1bGVkXCIgY2xhc3M9XCJhY2Nlc3NrZXktZmlyc3RcIj5TY2hlZHVsZWQ8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17ZWRpdGFibGVUYXNrLnNjaGVkdWxlZERhdGV9XG4gICAgICAgICAgICAgICAgaWQ9XCJzY2hlZHVsZWRcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzczp0YXNrcy1tb2RhbC1lcnJvcj17IWlzU2NoZWR1bGVkRGF0ZVZhbGlkfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtkYXRlUGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgYWNjZXNza2V5PXthY2Nlc3NrZXkoXCJzXCIpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjb2RlPntzY2hlZHVsZWREYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkU2NoZWR1bGVkRGF0ZX08L2NvZGU+XG5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgU3RhcnQgRGF0ZSAgLS0+XG4gICAgICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzdGFydFwiPlN0PHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXlcIj5hPC9zcGFuPnJ0PC9sYWJlbD5cbiAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWFjY2Vzc2tleSAtLT5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e2VkaXRhYmxlVGFzay5zdGFydERhdGV9XG4gICAgICAgICAgICAgICAgaWQ9XCJzdGFydFwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzOnRhc2tzLW1vZGFsLWVycm9yPXshaXNTdGFydERhdGVWYWxpZH1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17ZGF0ZVBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KFwiYVwiKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8Y29kZT57c3RhcnREYXRlU3ltYm9sfSB7QGh0bWwgcGFyc2VkU3RhcnREYXRlfTwvY29kZT5cblxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8IS0tICBPbmx5IGZ1dHVyZSBkYXRlcyAgLS0+XG4gICAgICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImZvcndhcmRPbmx5XCI+T25seVxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFjY2Vzc2tleS1maXJzdFwiPmZ1dHVyZTwvc3Bhbj4gZGF0ZXM6PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hY2Nlc3NrZXkgLS0+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6Y2hlY2tlZD17ZWRpdGFibGVUYXNrLmZvcndhcmRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBpZD1cImZvcndhcmRPbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0YXNrLWxpc3QtaXRlbS1jaGVja2JveCB0YXNrcy1tb2RhbC1jaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KFwiZlwiKX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICA8IS0tICBTdGF0dXMgIC0tPlxuICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhc2tzLW1vZGFsLXNlY3Rpb25cIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzdGF0dXNcIj5TdGF0PHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXlcIj51PC9zcGFuPnM8L2xhYmVsPlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktYWNjZXNza2V5IC0tPlxuICAgICAgICAgICAgPHNlbGVjdCBiaW5kOnZhbHVlPXtlZGl0YWJsZVRhc2suc3RhdHVzfVxuICAgICAgICAgICAgICAgICAgICBpZD1cInN0YXR1cy10eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkcm9wZG93blwiXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc2tleT17YWNjZXNza2V5KCd1Jyl9PlxuICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0dXNPcHRpb25zIGFzIHN0YXR1c31cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17c3RhdHVzfT57c3RhdHVzLm5hbWV9IFt7c3RhdHVzLnN5bWJvbH1dPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YXNrcy1tb2RhbC1zZWN0aW9uIHRhc2tzLW1vZGFsLXN0YXR1c1wiPlxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8IS0tICBDb21wbGV0ZWQgIC0tPlxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzdGF0dXNcIj5Db21wbGV0ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJzdGF0dXNcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhc2stbGlzdC1pdGVtLWNoZWNrYm94IHRhc2tzLW1vZGFsLWNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17ZWRpdGFibGVUYXNrLnN0YXR1cy5pc0NvbXBsZXRlZCgpfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLS0+XG4gICAgICAgICAgICA8IS0tICBDcmVhdGVkIG9uICAtLT5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8c3Bhbj5DcmVhdGVkIG9uOjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8Y29kZT57QGh0bWwgcGFyc2VkQ3JlYXRlZH08L2NvZGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC0tPlxuICAgICAgICAgICAgPCEtLSAgRG9uZSBvbiAgLS0+XG4gICAgICAgICAgICA8IS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAtLT5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4+RG9uZSBvbjo8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGNvZGU+e0BodG1sIHBhcnNlZERvbmV9PC9jb2RlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFza3MtbW9kYWwtc2VjdGlvbiB0YXNrcy1tb2RhbC1idXR0b25zXCI+XG4gICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkPXshZm9ybUlzVmFsaWR9IHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cIm1vZC1jdGFcIj5BcHBseVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17X29uQ2xvc2V9PkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Zvcm0+XG48L2Rpdj5cbiIsICJpbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuLi9TdGF0dXMnO1xuaW1wb3J0IHsgUHJpb3JpdHksIFRhc2ssIFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IERhdGVGYWxsYmFjayB9IGZyb20gJy4uL0RhdGVGYWxsYmFjayc7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4uL1Rhc2tMb2NhdGlvbic7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gJy4uL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdENyZWF0ZWREYXRlKCkge1xuICAgIGNvbnN0IHsgc2V0Q3JlYXRlZERhdGUgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgcmV0dXJuIHNldENyZWF0ZWREYXRlID8gd2luZG93Lm1vbWVudCgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ3JlYXRlZERhdGVGb3JUYXNrKHRhc2s6IFRhc2spIHtcbiAgICBjb25zdCB7IHNldENyZWF0ZWREYXRlIH0gPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgaWYgKCFzZXRDcmVhdGVkRGF0ZSkge1xuICAgICAgICAvLyBBdXRvLWFkZGluZyBvZiBDcmVhdGVkIERhdGUgaXMgZGlzYWJsZWQgaW4gc2V0dGluZ3MuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFzay5jcmVhdGVkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgdGFzayBhbHJlYWR5IGhhZCBhIGNyZWF0ZWQgZGF0ZSwgc28gZG9uJ3QgY2hhbmdlIGl0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRlc2NyaXB0aW9uIHdhcyBlbXB0eSwgdHJlYXQgaXQgYXMgbmV3IGFuZCBhZGQgYSBjcmVhdGlvbiBkYXRlLlxuICAgIGNvbnN0IGRlc2NyaXB0aW9uSXNFbXB0eSA9IHRhc2suZGVzY3JpcHRpb24gPT09ICcnO1xuXG4gICAgLy8gSWYgdGhlIGdsb2JhbCBmaWx0ZXIgd2lsbCBiZSBhZGRlZCB3aGVuIHRoZSB0YXNrIGlzIHNhdmVkLCB0cmVhdCBpdCBhcyBuZXcgYW5kIGFkZCBhIGNyZWF0aW9uIGRhdGUuXG4gICAgLy8gU2VlIGlzc3VlICMyMTEyLlxuICAgIGNvbnN0IGdsb2JhbEZpbHRlckVuYWJsZWQgPSAhR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHRhc2tEb2VzTm90Q29udGFpbkdsb2JhbEZpbHRlciA9ICFHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5pbmNsdWRlZEluKHRhc2suZGVzY3JpcHRpb24pO1xuICAgIGNvbnN0IG5lZWRzR2xvYmFsRmlsdGVyVG9CZUFkZGVkID0gZ2xvYmFsRmlsdGVyRW5hYmxlZCAmJiB0YXNrRG9lc05vdENvbnRhaW5HbG9iYWxGaWx0ZXI7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRpb25Jc0VtcHR5IHx8IG5lZWRzR2xvYmFsRmlsdGVyVG9CZUFkZGVkO1xufVxuXG4vKipcbiAqIFJlYWQgYW55IG1hcmtkb3duIGxpbmUgYW5kIHRyZWF0IGl0IGFzIGEgdGFzaywgZm9yIHRoZSBwdXJwb3NlcyBvZlxuICogdGhlICdDcmVhdGUgb3IgZWRpdCB0YXNrJyBtb2RhbC5cbiAqXG4gKiBVbmxpa2Uge0BsaW5rIFRhc2suZnJvbUxpbmV9LCB3aGljaCBvbmx5IHByb2Nlc3NlcyB0YXNrc1xuICogYWxyZWFkeSByZWNvZ25pc2VkIGJ5IHRoZSBUYXNrcyBwbHVnaW4sIHRoaXMgZnVuY3Rpb24gcHJvY2Vzc2VzIGFueSBsaW5lLlxuICpcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHRoYXQgY29tbWFuZCwgd2hpY2ggaGFzIGJlZW4gc2VwYXJhdGVkXG4gKiBvdXQgdG8gYSBkaWZmZXJlbnQgc291cmNlIGZpbGUgaW4gb3JkZXIgdG8gYWxsb3cgaXRzIGxvZ2ljIHRvIGJlIHRlc3RlZC5cbiAqXG4gKiBAcGFyYW0gbGluZSAtIFRoZSBsaW5lIHRoZSB1c2VyIGhhZCBjbGlja2VkIG9uIHdoZW4gcnVubmluZyAnQ3JlYXRlIG9yIGVkaXQgdGFzaycgY29tbWFuZFxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSBjb250YWluaW5nIHRoZSBsaW5lXG4gKi9cbmV4cG9ydCBjb25zdCB0YXNrRnJvbUxpbmUgPSAoeyBsaW5lLCBwYXRoIH06IHsgbGluZTogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfSk6IFRhc2sgPT4ge1xuICAgIC8vIFdlIGdldCBhbGwgc2lnbmlmaWVycyBmcm9tIHRoZSBsaW5lLCBldmVuIGlmIHRoZSBHbG9iYWwgRmlsdGVyIGlzIG1pc3NpbmcuXG4gICAgLy8gVGhpcyBoZWxwcyB1c2VycyB3aG8sIGZvciBzb21lIHJlYXNvbiwgaGF2ZSBkYXRhIGluIGEgdGFzayBsaW5lIHdpdGhvdXQgdGhlIEdsb2JhbCBGaWx0ZXIuXG4gICAgY29uc3QgdGFzayA9IFRhc2sucGFyc2VUYXNrU2lnbmlmaWVycyhcbiAgICAgICAgbGluZSxcbiAgICAgICAgVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24ocGF0aCksIC8vIFdlIGRvbid0IG5lZWQgcHJlY2lzZSBsb2NhdGlvbiB0byB0b2dnbGUgaXQgaGVyZSBpbiB0aGUgZWRpdG9yLlxuICAgICAgICBEYXRlRmFsbGJhY2suZnJvbVBhdGgocGF0aCksIC8vIHNldCB0aGUgc2NoZWR1bGVkIGRhdGUgZnJvbSB0aGUgZmlsZW5hbWUsIHNvIGl0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIGRpYWxvZ1xuICAgICk7XG5cbiAgICBjb25zdCBjcmVhdGVkRGF0ZSA9IGdldERlZmF1bHRDcmVhdGVkRGF0ZSgpO1xuXG4gICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUNyZWF0ZWREYXRlRm9yVGFzayh0YXNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXNrKHsgLi4udGFzaywgY3JlYXRlZERhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIG5vdCBvbiBhIGxpbmUgb2YgYSB0YXNrLCB3ZSB0YWtlIHdoYXQgd2UgaGF2ZS5cbiAgICBjb25zdCBub25UYXNrTWF0Y2ggPSBsaW5lLm1hdGNoKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMubm9uVGFza1JlZ2V4KTtcbiAgICBpZiAobm9uVGFza01hdGNoID09PSBudWxsKSB7XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW47IGV2ZXJ5dGhpbmcgaW4gdGhlIHJlZ2V4IGlzIG9wdGlvbmFsLlxuICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrczogQ2Fubm90IGNyZWF0ZSB0YXNrIG9uIGxpbmU6JywgbGluZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUYXNrKHtcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLlRPRE8sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBsb2NhdGlvbiBmaWVsZHMgZXhjZXB0IGZpbGUgdG8gZWRpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbi5mcm9tVW5rbm93blBvc2l0aW9uKHBhdGgpLFxuICAgICAgICAgICAgaW5kZW50YXRpb246ICcnLFxuICAgICAgICAgICAgbGlzdE1hcmtlcjogJy0nLFxuICAgICAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5Lk5vbmUsXG4gICAgICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogbnVsbCxcbiAgICAgICAgICAgIHNjaGVkdWxlZERhdGU6IG51bGwsXG4gICAgICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICAgICAgZG9uZURhdGU6IG51bGwsXG4gICAgICAgICAgICByZWN1cnJlbmNlOiBudWxsLFxuICAgICAgICAgICAgYmxvY2tMaW5rOiAnJyxcbiAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgb3JpZ2luYWxNYXJrZG93bjogJycsXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlSXNJbmZlcnJlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGVudGF0aW9uOiBzdHJpbmcgPSBub25UYXNrTWF0Y2hbMV07XG4gICAgY29uc3QgbGlzdE1hcmtlciA9IG5vblRhc2tNYXRjaFsyXSA/PyAnLSc7XG4gICAgY29uc3Qgc3RhdHVzU3RyaW5nOiBzdHJpbmcgPSBub25UYXNrTWF0Y2hbNF0gPz8gJyAnO1xuICAgIGNvbnN0IHN0YXR1cyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuYnlTeW1ib2xPckNyZWF0ZShzdGF0dXNTdHJpbmcpO1xuXG4gICAgbGV0IGRlc2NyaXB0aW9uOiBzdHJpbmcgPSBub25UYXNrTWF0Y2hbNV07XG5cbiAgICBjb25zdCBibG9ja0xpbmtNYXRjaCA9IGxpbmUubWF0Y2goVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5ibG9ja0xpbmtSZWdleCk7XG4gICAgY29uc3QgYmxvY2tMaW5rID0gYmxvY2tMaW5rTWF0Y2ggIT09IG51bGwgPyBibG9ja0xpbmtNYXRjaFswXSA6ICcnO1xuXG4gICAgaWYgKGJsb2NrTGluayAhPT0gJycpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5yZXBsYWNlKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMuYmxvY2tMaW5rUmVnZXgsICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRhc2soe1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBsb2NhdGlvbiBmaWVsZHMgZXhjZXB0IGZpbGUgdG8gZWRpdCBoZXJlIGluIHRoZSBlZGl0b3IuXG4gICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24ocGF0aCksXG4gICAgICAgIGluZGVudGF0aW9uLFxuICAgICAgICBsaXN0TWFya2VyLFxuICAgICAgICBibG9ja0xpbmssXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5Ob25lLFxuICAgICAgICBjcmVhdGVkRGF0ZSxcbiAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICBzY2hlZHVsZWREYXRlOiBudWxsLFxuICAgICAgICBkdWVEYXRlOiBudWxsLFxuICAgICAgICBkb25lRGF0ZTogbnVsbCxcbiAgICAgICAgcmVjdXJyZW5jZTogbnVsbCxcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG9yaWdpbmFsTWFya2Rvd246ICcnLFxuICAgICAgICAvLyBOb3QgbmVlZGVkIHNpbmNlIHRoZSBpbmZlcnJlZCBzdGF0dXMgaXMgYWx3YXlzIHJlLWNvbXB1dGVkIGFmdGVyIHN1Ym1pdHRpbmcuXG4gICAgICAgIHNjaGVkdWxlZERhdGVJc0luZmVycmVkOiBmYWxzZSxcbiAgICB9KTtcbn07XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCB0eXBlIEVkaXRvclBvc2l0aW9uLCB0eXBlIE1hcmtkb3duRmlsZUluZm8sIE1hcmtkb3duVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFN0YXR1c1JlZ2lzdHJ5IH0gZnJvbSAnLi4vU3RhdHVzUmVnaXN0cnknO1xuXG5pbXBvcnQgeyBUYXNrLCBUYXNrUmVndWxhckV4cHJlc3Npb25zIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBUYXNrTG9jYXRpb24gfSBmcm9tICcuLi9UYXNrTG9jYXRpb24nO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlRG9uZSA9IChjaGVja2luZzogYm9vbGVhbiwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8pID0+IHtcbiAgICBpZiAoY2hlY2tpbmcpIHtcbiAgICAgICAgaWYgKCEodmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBtYXJrZG93biB2aWV3LCB0aGUgY29tbWFuZCBzaG91bGRuJ3QgYmUgc2hvd24uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgY29tbWFuZCBzaG91bGQgYWx3YXlzIHRyaWdnZXIgaW4gYSBtYXJrZG93biB2aWV3OlxuICAgICAgICAvLyAtIENvbnZlcnQgbGluZXMgdG8gbGlzdCBpdGVtcy5cbiAgICAgICAgLy8gLSBDb252ZXJ0IGxpc3QgaXRlbXMgdG8gdGFza3MuXG4gICAgICAgIC8vIC0gVG9nZ2xlIHRhc2tzJyBzdGF0dXMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghKHZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpKSB7XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gZHVlIHRvIGNoZWNrIGFib3ZlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgYXJlIGNlcnRhaW4gd2UgYXJlIGluIHRoZSBlZGl0b3IgZHVlIHRvIHRoZSBjaGVjayBhYm92ZS5cbiAgICBjb25zdCBwYXRoID0gdmlldy5maWxlPy5wYXRoO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdDdXJzb3JQb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgY29uc3QgbGluZU51bWJlciA9IG9yaWdDdXJzb3JQb3MubGluZTtcbiAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cbiAgICBjb25zdCBpbnNlcnRpb24gPSB0b2dnbGVMaW5lKGxpbmUsIHBhdGgpO1xuICAgIGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIGluc2VydGlvbi50ZXh0KTtcblxuICAgIC8qIEN1cnNvciBwb3NpdGlvbnMgYXJlIDAtYmFzZWQgZm9yIGJvdGggXCJsaW5lXCIgYW5kIFwiY2hcIiBvZmZzZXRzLlxuICAgICAqIElmIFwiY2hcIiBvZmZzZXQgYmlnZ2VyIHRoYW4gdGhlIGxpbmUgbGVuZ3RoLCB3aWxsIGp1c3QgY29udGludWUgdG8gbmV4dCBsaW5lKHMpLlxuICAgICAqIEJ5IGRlZmF1bHQgXCJlZGl0b3Iuc2V0TGluZSgpXCIgYXBwZWFycyB0byBlaXRoZXIga2VlcCB0aGUgY3Vyc29yIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgaWYgaXQgaXMgYWxyZWFkeSB0aGVyZSxcbiAgICAgKiAuLi5vciBtb3ZlIGl0IHRvIHRoZSBiZWdpbm5pbmcgaWYgaXQgaXMgYW55d2hlcmUgZWxzZS4gTGljYXQgZXhwbGFpbmVkIHRoaXMgb24gRGlzY29yZCBhcyBcInN0aWNraW5nXCIgdG8gb25lIHNpZGUgb3IgYW5vdGhlci5cbiAgICAgKi9cbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKGdldE5ld0N1cnNvclBvc2l0aW9uKG9yaWdDdXJzb3JQb3MsIGluc2VydGlvbikpO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZWRpdG9yXG4gKlxuICogQHByb3BlcnR5IHRleHQgVGhlIHRleHQgdG8gaW5zZXJ0LiBNYXkgc3BhbiBvdmVyIG11bHRpcGxlIGxpbmVzLlxuICogQHByb3BlcnR5IFttb3ZlVG9dIEFuIHtAbGluayBFZGl0b3JQb3NpdGlvbn0gdGhhdCByZXByZXNlbnRzIGFuIGFic29sdXRlIHBvc2l0aW9uIHdpdGhpbiB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLnRleHR9IHRoYXQgaXNcbiAqICAgIHJlY29tbWVuZGVkIHRvIG1vdmUgdGhlIGN1cnNvciB0by5cbiAqXG4gKiBBbnkgY29tYmluYXRpb24gb2Ygc3ViZmllbGRzIChvciB0aGUgd2hvbGUge0BsaW5rIEVkaXRvclBvc2l0aW9ufSkgbWF5IGJlIG9taXR0ZWQuXG4gKiBNaXNzaW5nIGZpZWxkcyBzaG91bGQgcHJlc2VydmUgdGhlIGNvcnJlc3BvbmRpbmcgY3Vyc29yIHBvc2l0aW9uLiBUaGF0IGlzOlxuICogICAgICogQSB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLm1vdmVUb30gdGhhdCBpcyBgdW5kZWZpbmVkYCBkaXJlY3RzIHRoZSBjYWxsZXIgdG8ga2VlcCB0aGUgY3Vyc29yIHdoZXJlIGl0IGlzLlxuICogICAgICogQSB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLm1vdmVUb30gdGhhdCBpcyBge2xpbmU6IDF9YCBkaXJlY3RzIHRoZSBjYWxsZXIgb2YgdG8ganVtcCB0byB7QGxpbmsgRWRpdG9ySW5zZXJ0aW9uLnRleHR9J3NcbiAqICAgICAgIHNlY29uZCBsaW5lIGJ1dCBzdGF5IGluIHRoZSBzYW1lIGNvbHVtbi5cbiAqXG4gKiBAaW50ZXJmYWNlIEVkaXRvckluc2VydGlvblxuICovXG5pbnRlcmZhY2UgRWRpdG9ySW5zZXJ0aW9uIHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgbW92ZVRvPzogUGFydGlhbDxFZGl0b3JQb3NpdGlvbj47XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVMaW5lID0gKGxpbmU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogRWRpdG9ySW5zZXJ0aW9uID0+IHtcbiAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgIC8vIFdoeSBhcmUgd2UgdXNpbmcgVGFzay5mcm9tTGluZSBpbnN0ZWFkIG9mIHRoZSBDYWNoZSBoZXJlP1xuICAgICAgICBsaW5lLFxuICAgICAgICB0YXNrTG9jYXRpb246IFRhc2tMb2NhdGlvbi5mcm9tVW5rbm93blBvc2l0aW9uKHBhdGgpLCAvLyBXZSBkb24ndCBuZWVkIHByZWNpc2UgbG9jYXRpb24gdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLCAvLyBXZSBkb24ndCBuZWVkIHRoaXMgdG8gdG9nZ2xlIGl0IGhlcmUgaW4gdGhlIGVkaXRvci5cbiAgICB9KTtcbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRhc2sudG9nZ2xlV2l0aFJlY3VycmVuY2VJblVzZXJzT3JkZXIoKS5tYXAoKHQpID0+IHQudG9GaWxlTGluZVN0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZXMuam9pbignXFxuJyksIG1vdmVUbzogeyBsaW5lOiBsaW5lcy5sZW5ndGggLSAxIH0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgdGFzayBpcyBudWxsIHRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBvZjpcbiAgICAgICAgLy8gMS4gYSByZWd1bGFyIGNoZWNrbGlzdCBpdGVtXG4gICAgICAgIC8vIDIuIGEgbGlzdCBpdGVtXG4gICAgICAgIC8vIDMuIGEgc2ltcGxlIHRleHQgbGluZVxuICAgICAgICAvLyA0LiBhIHN0YW5kYXJkIHRhc2ssIGJ1dCB3aGljaCBkb2VzIG5vdCBjb250YWluIHRoZSBnbG9iYWwgZmlsdGVyLCB0byBiZSB0b2dnbGVkLCBidXQgbm8gZG9uZSBkYXRlIGFkZGVkLlxuXG4gICAgICAgIC8vIFRoZSB0YXNrIHJlZ2V4IHdpbGwgbWF0Y2ggY2hlY2tsaXN0IGl0ZW1zLlxuICAgICAgICBjb25zdCByZWdleE1hdGNoID0gbGluZS5tYXRjaChUYXNrUmVndWxhckV4cHJlc3Npb25zLnRhc2tSZWdleCk7XG4gICAgICAgIGlmIChyZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIHN0YXR1cyBvZiB0aGUgY2hlY2tsaXN0IGl0ZW0uXG4gICAgICAgICAgICBjb25zdCBzdGF0dXNTdHJpbmcgPSByZWdleE1hdGNoWzNdO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5ieVN5bWJvbChzdGF0dXNTdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzU3RyaW5nID0gc3RhdHVzLm5leHRTdGF0dXNTeW1ib2w7XG4gICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy50YXNrUmVnZXgsIGAkMS0gWyR7bmV3U3RhdHVzU3RyaW5nfV0gJDRgKSB9O1xuICAgICAgICB9IGVsc2UgaWYgKFRhc2tSZWd1bGFyRXhwcmVzc2lvbnMubGlzdEl0ZW1SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBsaXN0IGl0ZW0gdG8gYSBjaGVja2xpc3QgaXRlbS5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5saXN0SXRlbVJlZ2V4LCAnJDEkMiBbIF0nKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRleHQsIG1vdmVUbzogeyBjaDogdGV4dC5sZW5ndGggfSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbGluZSB0byBhIGxpc3QgaXRlbS5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnJlcGxhY2UoVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5pbmRlbnRhdGlvblJlZ2V4LCAnJDEtICcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGV4dCwgbW92ZVRvOiB7IGNoOiB0ZXh0Lmxlbmd0aCB9IH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBuZXcgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvciBzbyB0aGF0IGl0IGlzIHBvc2l0aW9uZWQgd2l0aGluIHRoZSBpbnNlcnRlZCB0ZXh0IGFzIHNwZWNpZmllZFxuICogYnkge0BsaW5rIGluc2VydGlvbn0ubW92ZVRvLlxuICpcbiAqIEBub3RlIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRleHQgd2FzIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUsIHdoaWNoIGlzXG4gKiAgICAgICB0aGUgY2FzZSB3aGVuIHVzZWQgdG9nZXRoZXIgd2l0aCB7QGxpbmsgRWRpdG9yLnNldExpbmV9LiBUaGlzIGlzIGEgc2ltcGxpZnlpbmcgYXNzdW1wdGlvbixcbiAqICAgICAgIGJ1dCBtYXkgcmVzdWx0IGluIGluY29ycmVjdCBiZWhhdmlvciBpZiB1c2VkIG91dHNpZGUgdGhlIGludGVuZGVkIGNvbnRleHQgKGkuZS4gbm90IGJ5IHtAbGluayB0b2dnbGVEb25lfSkuXG4gKlxuICogICAgICAgRXhhbXBsZTogQXNzdW1lIHtAbGluayBpbnNlcnRpb259PWB7dGV4dDogXCJIZWxsbyBXb3JsZFwiLCBtb3ZlVG86IHtsaW5lOiAwLCBjaDogNn19YCwgd2hlcmUge0BsaW5rIGluc2VydGlvbn0udGV4dFxuICogICAgICAgICAgICAgICAgaGFkIGJlZW4gYXBwZW5kZWQgdG8gYSBsaW5lIHdpdGggY29udGVudCBcIi0tLS0tLVwiOiAgYC0tLS0tLUhlbGxvIFdvcmxkYC5cbiAqICAgICAgICAgICAgICAgIFRoZSBjdXJzb3Igd2lsbCBiZSBvZmZzZXQgdG8gdGhlIGxlZnQgYnkgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBhbHJlYWR5IG9uIHRoZSBsaW5lLlxuICogICAgICAgICAgICAgICAgUmVzdWx0aW5nIGluIHRoZSBpbmNvcnJlY3QgcmVzdWx0IGAtLS0tLS18SGVsbG8gV29ybGRgIGluc3RlYWQgb2YgdGhlIGludGVuZGVkIGAtLS0tLS1IZWxsbyB8V29ybGRgLlxuICpcbiAqIEBwYXJhbSBzdGFydFBvcyBUaGUgc3RhcnRpbmcgY3Vyc29yIHBvc2l0aW9uXG4gKiBAcGFyYW0gaW5zZXJ0aW9uIFRoZSBpbnNlcnRlZCB0ZXh0IGFuZCBzdWdnZXN0ZWQgY3Vyc29yIHBvc2l0aW9uIHdpdGhpbiB0aGF0IHRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5ld0N1cnNvclBvc2l0aW9uID0gKHN0YXJ0UG9zOiBFZGl0b3JQb3NpdGlvbiwgaW5zZXJ0aW9uOiBFZGl0b3JJbnNlcnRpb24pOiBFZGl0b3JQb3NpdGlvbiA9PiB7XG4gICAgY29uc3QgZGVmYXVsdE1vdmVUbyA9IHsgbGluZTogMCwgY2g6IHN0YXJ0UG9zLmNoIH07XG4gICAgLy8gRmlsbCBpbiBhbnkgbWlzc2luZyBtb3ZlVG8gdmFsdWVzIHVzaW5nIHRoZSBkZWZhdWx0XG4gICAgY29uc3QgbW92ZVRvID0geyAuLi5kZWZhdWx0TW92ZVRvLCAuLi4oaW5zZXJ0aW9uLm1vdmVUbyA/PyB7fSkgfTtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgd2UncmUgbW92aW5nIHRoZSBjdXJzb3IgdG8sIHNvIHRoYXQgY3Vyc29yIGlzbid0IG1vdmVkIG91dCBvZiBib3VuZHNcbiAgICBjb25zdCBkZXN0aW5hdGlvbkxpbmVMZW5ndGggPSBpbnNlcnRpb24udGV4dC5zcGxpdCgnXFxuJylbbW92ZVRvLmxpbmVdLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHN0YXJ0UG9zLmxpbmUgKyBtb3ZlVG8ubGluZSxcbiAgICAgICAgY2g6IE1hdGgubWluKG1vdmVUby5jaCwgZGVzdGluYXRpb25MaW5lTGVuZ3RoKSxcbiAgICB9O1xufTtcbiIsICJpbXBvcnQgdHlwZSB7IEFwcCwgRWRpdG9yLCBNYXJrZG93bkZpbGVJbmZvLCBNYXJrZG93blZpZXcsIFBsdWdpbiwgVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IGNyZWF0ZU9yRWRpdCB9IGZyb20gJy4vQ3JlYXRlT3JFZGl0JztcblxuaW1wb3J0IHsgdG9nZ2xlRG9uZSB9IGZyb20gJy4vVG9nZ2xlRG9uZSc7XG5cbmV4cG9ydCBjbGFzcyBDb21tYW5kcyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IFBsdWdpbjtcblxuICAgIHByaXZhdGUgZ2V0IGFwcCgpOiBBcHAge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW4uYXBwO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHsgcGx1Z2luIH06IHsgcGx1Z2luOiBQbHVnaW4gfSkge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblxuICAgICAgICBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2VkaXQtdGFzaycsXG4gICAgICAgICAgICBuYW1lOiAnQ3JlYXRlIG9yIGVkaXQgdGFzaycsXG4gICAgICAgICAgICBpY29uOiAncGVuY2lsJyxcbiAgICAgICAgICAgIGVkaXRvckNoZWNrQ2FsbGJhY2s6IChjaGVja2luZzogYm9vbGVhbiwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlT3JFZGl0KGNoZWNraW5nLCBlZGl0b3IsIHZpZXcgYXMgVmlldywgdGhpcy5hcHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICd0b2dnbGUtZG9uZScsXG4gICAgICAgICAgICBuYW1lOiAnVG9nZ2xlIHRhc2sgZG9uZScsXG4gICAgICAgICAgICBpY29uOiAnY2hlY2staW4tY2lyY2xlJyxcbiAgICAgICAgICAgIGVkaXRvckNoZWNrQ2FsbGJhY2s6IHRvZ2dsZURvbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICIvKiFcbiAqIG11c3RhY2hlLmpzIC0gTG9naWMtbGVzcyB7e211c3RhY2hlfX0gdGVtcGxhdGVzIHdpdGggSmF2YVNjcmlwdFxuICogaHR0cDovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xuICovXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheVBvbHlmaWxsIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICogd2hpY2ggbm9ybWFsbHkgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcbiAqL1xuZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gIHJldHVybiBpc0FycmF5KG9iaikgPyAnYXJyYXknIDogdHlwZW9mIG9iajtcbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xufVxuXG4vKipcbiAqIE51bGwgc2FmZSB3YXkgb2YgY2hlY2tpbmcgd2hldGhlciBvciBub3QgYW4gb2JqZWN0LFxuICogaW5jbHVkaW5nIGl0cyBwcm90b3R5cGUsIGhhcyBhIGdpdmVuIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAocHJvcE5hbWUgaW4gb2JqKTtcbn1cblxuLyoqXG4gKiBTYWZlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHRoaW5nIGlzIGEgcHJpbWl0aXZlIGFuZFxuICogd2hldGhlciBpdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIHByaW1pdGl2ZUhhc093blByb3BlcnR5IChwcmltaXRpdmUsIHByb3BOYW1lKSB7XG4gIHJldHVybiAoXG4gICAgcHJpbWl0aXZlICE9IG51bGxcbiAgICAmJiB0eXBlb2YgcHJpbWl0aXZlICE9PSAnb2JqZWN0J1xuICAgICYmIHByaW1pdGl2ZS5oYXNPd25Qcm9wZXJ0eVxuICAgICYmIHByaW1pdGl2ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgKTtcbn1cblxuLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DT1VDSERCLTU3N1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbnZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuZnVuY3Rpb24gdGVzdFJlZ0V4cCAocmUsIHN0cmluZykge1xuICByZXR1cm4gcmVnRXhwVGVzdC5jYWxsKHJlLCBzdHJpbmcpO1xufVxuXG52YXIgbm9uU3BhY2VSZSA9IC9cXFMvO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChzdHJpbmcpIHtcbiAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG59XG5cbnZhciBlbnRpdHlNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICcvJzogJyYjeDJGOycsXG4gICdgJzogJyYjeDYwOycsXG4gICc9JzogJyYjeDNEOydcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ2A9XFwvXS9nLCBmdW5jdGlvbiBmcm9tRW50aXR5TWFwIChzKSB7XG4gICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgfSk7XG59XG5cbnZhciB3aGl0ZVJlID0gL1xccyovO1xudmFyIHNwYWNlUmUgPSAvXFxzKy87XG52YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xudmFyIGN1cmx5UmUgPSAvXFxzKlxcfS87XG52YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuLyoqXG4gKiBCcmVha3MgdXAgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgc3RyaW5nIGludG8gYSB0cmVlIG9mIHRva2Vucy4gSWYgdGhlIGB0YWdzYFxuICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gKiBjb3Vyc2UsIHRoZSBkZWZhdWx0IGlzIHRvIHVzZSBtdXN0YWNoZXMgKGkuZS4gbXVzdGFjaGUudGFncykuXG4gKlxuICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICogbXVzdGFjaGUgc3ltYm9sIHRoYXQgd2FzIHVzZWQgaW5zaWRlIHRoZSB0YWcsIGUuZy4gXCIjXCIgb3IgXCImXCIuIElmIHRoZSB0YWdcbiAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAqXG4gKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gKiB0aGlzIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAqXG4gKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gKiByZXNwZWN0aXZlbHksIG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXG4gKlxuICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gKiBhcnJheSBvZiB0b2tlbnMgaW4gdGhlIHN1YnRyZWUgYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgYXRcbiAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAqXG4gKiBUb2tlbnMgZm9yIHBhcnRpYWxzIGFsc28gY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYSBzdHJpbmcgdmFsdWUgb2ZcbiAqIGluZGVuZGF0aW9uIHByaW9yIHRvIHRoYXQgdGFnIGFuZCAyKSB0aGUgaW5kZXggb2YgdGhhdCB0YWcgb24gdGhhdCBsaW5lIC1cbiAqIGVnIGEgdmFsdWUgb2YgMiBpbmRpY2F0ZXMgdGhlIHBhcnRpYWwgaXMgdGhlIHRoaXJkIHRhZyBvbiB0aGlzIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIGlmICghdGVtcGxhdGUpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgbGluZUhhc05vblNwYWNlID0gZmFsc2U7XG4gIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gIHZhciBpbmRlbnRhdGlvbiA9ICcnOyAgLy8gVHJhY2tzIGluZGVudGF0aW9uIGZvciB0YWdzIHRoYXQgdXNlIGl0XG4gIHZhciB0YWdJbmRleCA9IDA7ICAgICAgLy8gU3RvcmVzIGEgY291bnQgb2YgbnVtYmVyIG9mIHRhZ3MgZW5jb3VudGVyZWQgb24gYSBsaW5lXG5cbiAgLy8gU3RyaXBzIGFsbCB3aGl0ZXNwYWNlIHRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbGluZVxuICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gIGZ1bmN0aW9uIHN0cmlwU3BhY2UgKCkge1xuICAgIGlmIChoYXNUYWcgJiYgIW5vblNwYWNlKSB7XG4gICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgZGVsZXRlIHRva2Vuc1tzcGFjZXMucG9wKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcGFjZXMgPSBbXTtcbiAgICB9XG5cbiAgICBoYXNUYWcgPSBmYWxzZTtcbiAgICBub25TcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9wZW5pbmdUYWdSZSwgY2xvc2luZ1RhZ1JlLCBjbG9zaW5nQ3VybHlSZTtcbiAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICBpZiAodHlwZW9mIHRhZ3NUb0NvbXBpbGUgPT09ICdzdHJpbmcnKVxuICAgICAgdGFnc1RvQ29tcGlsZSA9IHRhZ3NUb0NvbXBpbGUuc3BsaXQoc3BhY2VSZSwgMik7XG5cbiAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnczogJyArIHRhZ3NUb0NvbXBpbGUpO1xuXG4gICAgb3BlbmluZ1RhZ1JlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVswXSkgKyAnXFxcXHMqJyk7XG4gICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgY2xvc2luZ0N1cmx5UmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKCd9JyArIHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgfVxuXG4gIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgdmFyIHN0YXJ0LCB0eXBlLCB2YWx1ZSwgY2hyLCB0b2tlbiwgb3BlblNlY3Rpb247XG4gIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAvLyBNYXRjaCBhbnkgdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICBzcGFjZXMucHVzaCh0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBjaHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICBpZiAoY2hyID09PSAnXFxuJykge1xuICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgICBpbmRlbnRhdGlvbiA9ICcnO1xuICAgICAgICAgIHRhZ0luZGV4ID0gMDtcbiAgICAgICAgICBsaW5lSGFzTm9uU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgYnJlYWs7XG5cbiAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICB0eXBlID0gc2Nhbm5lci5zY2FuKHRhZ1JlKSB8fCAnbmFtZSc7XG4gICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICBzY2FubmVyLnNjYW4oY3VybHlSZSk7XG4gICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgdHlwZSA9ICcmJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgIH1cblxuICAgIC8vIE1hdGNoIHRoZSBjbG9zaW5nIHRhZy5cbiAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIGlmICh0eXBlID09ICc+Jykge1xuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MsIGluZGVudGF0aW9uLCB0YWdJbmRleCwgbGluZUhhc05vblNwYWNlIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgfVxuICAgIHRhZ0luZGV4Kys7XG4gICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgaWYgKHR5cGUgPT09ICcjJyB8fCB0eXBlID09PSAnXicpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAvLyBDaGVjayBzZWN0aW9uIG5lc3RpbmcuXG4gICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcblxuICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZScgfHwgdHlwZSA9PT0gJ3snIHx8IHR5cGUgPT09ICcmJykge1xuICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAvLyBTZXQgdGhlIHRhZ3MgZm9yIHRoZSBuZXh0IHRpbWUgYXJvdW5kLlxuICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHN0cmlwU3BhY2UoKTtcblxuICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gIGlmIChvcGVuU2VjdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICByZXR1cm4gbmVzdFRva2VucyhzcXVhc2hUb2tlbnModG9rZW5zKSk7XG59XG5cbi8qKlxuICogQ29tYmluZXMgdGhlIHZhbHVlcyBvZiBjb25zZWN1dGl2ZSB0ZXh0IHRva2VucyBpbiB0aGUgZ2l2ZW4gYHRva2Vuc2AgYXJyYXlcbiAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICovXG5mdW5jdGlvbiBzcXVhc2hUb2tlbnMgKHRva2Vucykge1xuICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW5bMF0gPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4gJiYgbGFzdFRva2VuWzBdID09PSAndGV4dCcpIHtcbiAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3F1YXNoZWRUb2tlbnM7XG59XG5cbi8qKlxuICogRm9ybXMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIGludG8gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUgd2hlcmVcbiAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gKiB0ZW1wbGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGF0IHNlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lc3RlZFRva2Vucztcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gKiB0b2tlbnMgaW4gdGVtcGxhdGUgc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gIHRoaXMucG9zID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xufTtcblxuLyoqXG4gKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICogUmV0dXJucyB0aGUgbWF0Y2hlZCB0ZXh0IGlmIGl0IGNhbiBtYXRjaCwgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gKi9cblNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgcmV0dXJuICcnO1xuXG4gIHZhciBzdHJpbmcgPSBtYXRjaFswXTtcblxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICovXG5TY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiBzY2FuVW50aWwgKHJlKSB7XG4gIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgICBtYXRjaCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgfVxuXG4gIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICogbWFpbnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gIHRoaXMudmlldyA9IHZpZXc7XG4gIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAqIGFzIHRoZSBwYXJlbnQuXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gIHJldHVybiBuZXcgQ29udGV4dCh2aWV3LCB0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIG5hbWUgaW4gdGhpcyBjb250ZXh0LCB0cmF2ZXJzaW5nXG4gKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAgKG5hbWUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICB2YXIgdmFsdWU7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLCBpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgKiBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgKiBjaGVjayBpZiB0aGUgbGFzdCBvYmplY3QgaW4gdGhlIHBhdGggYWN0dWFsbHkgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgc3BlY2lhbGx5IG5lY2Vzc2FyeSBmb3Igd2hlbiB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IHRvXG4gICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSBkb3Qgbm90YXRpb24gaXMgdXNlZCwgd2UgY29uc2lkZXIgdGhlIGxvb2t1cFxuICAgICAgICAgKiB0byBiZSBzdWNjZXNzZnVsIGV2ZW4gaWYgdGhlIGxhc3QgXCJvYmplY3RcIiBpbiB0aGUgcGF0aCBpc1xuICAgICAgICAgKiBub3QgYWN0dWFsbHkgYW4gb2JqZWN0IGJ1dCBhIHByaW1pdGl2ZSAoZS5nLiwgYSBzdHJpbmcsIG9yIGFuXG4gICAgICAgICAqIGludGVnZXIpLCBiZWNhdXNlIGl0IGlzIHNvbWV0aW1lcyB1c2VmdWwgdG8gYWNjZXNzIGEgcHJvcGVydHlcbiAgICAgICAgICogb2YgYW4gYXV0b2JveGVkIHByaW1pdGl2ZSwgc3VjaCBhcyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxuICAgICAgICAgKiovXG4gICAgICAgIHdoaWxlIChpbnRlcm1lZGlhdGVWYWx1ZSAhPSBudWxsICYmIGluZGV4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgbG9va3VwSGl0ID0gKFxuICAgICAgICAgICAgICBoYXNQcm9wZXJ0eShpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXNbaW5kZXhdKVxuICAgICAgICAgICAgICB8fCBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eShpbnRlcm1lZGlhdGVWYWx1ZSwgbmFtZXNbaW5kZXhdKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gaW50ZXJtZWRpYXRlVmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBjaGVja2luZyBhZ2FpbnN0IGBoYXNQcm9wZXJ0eWAsIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAgaWZcbiAgICAgICAgICogYGNvbnRleHQudmlld2AgaXMgbm90IGFuIG9iamVjdC4gRGVsaWJlcmF0ZWx5IG9taXR0aW5nIHRoZSBjaGVja1xuICAgICAgICAgKiBhZ2FpbnN0IGBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eWAgaWYgZG90IG5vdGF0aW9uIGlzIG5vdCB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25zaWRlciB0aGlzIGV4YW1wbGU6XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBNdXN0YWNoZS5yZW5kZXIoXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMge3sjbGVuZ3RofX17e2xlbmd0aH19e3svbGVuZ3RofX0uXCIsIHtsZW5ndGg6IFwiMTAwIHlhcmRzXCJ9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgd2Ugd2VyZSB0byBjaGVjayBhbHNvIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCwgYXMgd2UgZG9cbiAgICAgICAgICogaW4gdGhlIGRvdCBub3RhdGlvbiBjYXNlLCB0aGVuIHJlbmRlciBjYWxsIHdvdWxkIHJldHVybjpcbiAgICAgICAgICpcbiAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgOS5cIlxuICAgICAgICAgKlxuICAgICAgICAgKiByYXRoZXIgdGhhbiB0aGUgZXhwZWN0ZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIFwiVGhlIGxlbmd0aCBvZiBhIGZvb3RiYWxsIGZpZWxkIGlzIDEwMCB5YXJkcy5cIlxuICAgICAgICAgKiovXG4gICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rdXBIaXQpIHtcbiAgICAgICAgdmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICB9XG5cbiAgICBjYWNoZVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLnZpZXcpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAqIGF2b2lkIHRoZSBuZWVkIHRvIHBhcnNlIHRoZSBzYW1lIHRlbXBsYXRlIHR3aWNlLlxuICovXG5mdW5jdGlvbiBXcml0ZXIgKCkge1xuICB0aGlzLnRlbXBsYXRlQ2FjaGUgPSB7XG4gICAgX2NhY2hlOiB7fSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5fY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoaXMgd3JpdGVyLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLnRlbXBsYXRlQ2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy50ZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgdGFnc2Agb3JcbiAqIGBtdXN0YWNoZS50YWdzYCBpZiBgdGFnc2AgaXMgb21pdHRlZCwgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAqIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHBhcnNlLlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMudGVtcGxhdGVDYWNoZTtcbiAgdmFyIGNhY2hlS2V5ID0gdGVtcGxhdGUgKyAnOicgKyAodGFncyB8fCBtdXN0YWNoZS50YWdzKS5qb2luKCc6Jyk7XG4gIHZhciBpc0NhY2hlRW5hYmxlZCA9IHR5cGVvZiBjYWNoZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciB0b2tlbnMgPSBpc0NhY2hlRW5hYmxlZCA/IGNhY2hlLmdldChjYWNoZUtleSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHRva2VucyA9PSB1bmRlZmluZWQpIHtcbiAgICB0b2tlbnMgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcbiAgICBpc0NhY2hlRW5hYmxlZCAmJiBjYWNoZS5zZXQoY2FjaGVLZXksIHRva2Vucyk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbi8qKlxuICogSGlnaC1sZXZlbCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCB3aXRoXG4gKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICpcbiAqIFRoZSBvcHRpb25hbCBgcGFydGlhbHNgIGFyZ3VtZW50IG1heSBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAqIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsLlxuICpcbiAqIElmIHRoZSBvcHRpb25hbCBgY29uZmlnYCBhcmd1bWVudCBpcyBnaXZlbiBoZXJlLCB0aGVuIGl0IHNob3VsZCBiZSBhblxuICogb2JqZWN0IHdpdGggYSBgdGFnc2AgYXR0cmlidXRlIG9yIGFuIGBlc2NhcGVgIGF0dHJpYnV0ZSBvciBib3RoLlxuICogSWYgYW4gYXJyYXkgaXMgcGFzc2VkLCB0aGVuIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgdGhlIHNhbWUgd2F5IGFzXG4gKiBhIGB0YWdzYCBhdHRyaWJ1dGUgb24gYSBgY29uZmlnYCBvYmplY3QuXG4gKlxuICogVGhlIGB0YWdzYCBhdHRyaWJ1dGUgb2YgYSBgY29uZmlnYCBvYmplY3QgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3b1xuICogc3RyaW5nIHZhbHVlczogdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSAoZS5nLlxuICogWyBcIjwlXCIsIFwiJT5cIiBdKS4gVGhlIGRlZmF1bHQgaXMgdG8gbXVzdGFjaGUudGFncy5cbiAqXG4gKiBUaGUgYGVzY2FwZWAgYXR0cmlidXRlIG9mIGEgYGNvbmZpZ2Agb2JqZWN0IG11c3QgYmUgYSBmdW5jdGlvbiB3aGljaFxuICogYWNjZXB0cyBhIHN0cmluZyBhcyBpbnB1dCBhbmQgb3V0cHV0cyBhIHNhZmVseSBlc2NhcGVkIHN0cmluZy5cbiAqIElmIGFuIGBlc2NhcGVgIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBhbiBIVE1MLXNhZmUgc3RyaW5nXG4gKiBlc2NhcGluZyBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgdmFyIHRhZ3MgPSB0aGlzLmdldENvbmZpZ1RhZ3MoY29uZmlnKTtcbiAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB2YXIgY29udGV4dCA9ICh2aWV3IGluc3RhbmNlb2YgQ29udGV4dCkgPyB2aWV3IDogbmV3IENvbnRleHQodmlldywgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIHRlbXBsYXRlLCBjb25maWcpO1xufTtcblxuLyoqXG4gKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAqIHRoZSBnaXZlbiBgY29udGV4dGAgYW5kIGBwYXJ0aWFsc2AuXG4gKlxuICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gKiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY29udGFpbmVkIGluIGEgaGlnaGVyLW9yZGVyIHNlY3Rpb24uXG4gKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICogYmUgb21pdHRlZC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgc3ltYm9sID0gdG9rZW5bMF07XG5cbiAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0LCBjb25maWcpO1xuICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICBidWZmZXIgKz0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVmZmVyID0gJyc7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAvLyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGJ5IGhpZ2hlci1vcmRlciBzZWN0aW9ucy5cbiAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMsIGNvbmZpZyk7XG4gIH1cblxuICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWVbal0pLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFRlbXBsYXRlICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGNvbnRleHQudmlldywgb3JpZ2luYWxUZW1wbGF0ZS5zbGljZSh0b2tlblszXSwgdG9rZW5bNV0pLCBzdWJSZW5kZXIpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICBidWZmZXIgKz0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgY29uZmlnKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUsIGNvbmZpZykge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODZcbiAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlLCBjb25maWcpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5pbmRlbnRQYXJ0aWFsID0gZnVuY3Rpb24gaW5kZW50UGFydGlhbCAocGFydGlhbCwgaW5kZW50YXRpb24sIGxpbmVIYXNOb25TcGFjZSkge1xuICB2YXIgZmlsdGVyZWRJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uLnJlcGxhY2UoL1teIFxcdF0vZywgJycpO1xuICB2YXIgcGFydGlhbEJ5TmwgPSBwYXJ0aWFsLnNwbGl0KCdcXG4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsQnlObC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0aWFsQnlObFtpXS5sZW5ndGggJiYgKGkgPiAwIHx8ICFsaW5lSGFzTm9uU3BhY2UpKSB7XG4gICAgICBwYXJ0aWFsQnlObFtpXSA9IGZpbHRlcmVkSW5kZW50YXRpb24gKyBwYXJ0aWFsQnlObFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWxCeU5sLmpvaW4oJ1xcbicpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJQYXJ0aWFsID0gZnVuY3Rpb24gcmVuZGVyUGFydGlhbCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgaWYgKCFwYXJ0aWFscykgcmV0dXJuO1xuICB2YXIgdGFncyA9IHRoaXMuZ2V0Q29uZmlnVGFncyhjb25maWcpO1xuXG4gIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBsaW5lSGFzTm9uU3BhY2UgPSB0b2tlbls2XTtcbiAgICB2YXIgdGFnSW5kZXggPSB0b2tlbls1XTtcbiAgICB2YXIgaW5kZW50YXRpb24gPSB0b2tlbls0XTtcbiAgICB2YXIgaW5kZW50ZWRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0YWdJbmRleCA9PSAwICYmIGluZGVudGF0aW9uKSB7XG4gICAgICBpbmRlbnRlZFZhbHVlID0gdGhpcy5pbmRlbnRQYXJ0aWFsKHZhbHVlLCBpbmRlbnRhdGlvbiwgbGluZUhhc05vblNwYWNlKTtcbiAgICB9XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UoaW5kZW50ZWRWYWx1ZSwgdGFncyk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIGluZGVudGVkVmFsdWUsIGNvbmZpZyk7XG4gIH1cbn07XG5cbldyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmVzY2FwZWRWYWx1ZSA9IGZ1bmN0aW9uIGVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQsIGNvbmZpZykge1xuICB2YXIgZXNjYXBlID0gdGhpcy5nZXRDb25maWdFc2NhcGUoY29uZmlnKSB8fCBtdXN0YWNoZS5lc2NhcGU7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGVzY2FwZSA9PT0gbXVzdGFjaGUuZXNjYXBlKSA/IFN0cmluZyh2YWx1ZSkgOiBlc2NhcGUodmFsdWUpO1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV07XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLmdldENvbmZpZ1RhZ3MgPSBmdW5jdGlvbiBnZXRDb25maWdUYWdzIChjb25maWcpIHtcbiAgaWYgKGlzQXJyYXkoY29uZmlnKSkge1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgZWxzZSBpZiAoY29uZmlnICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGNvbmZpZy50YWdzO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbldyaXRlci5wcm90b3R5cGUuZ2V0Q29uZmlnRXNjYXBlID0gZnVuY3Rpb24gZ2V0Q29uZmlnRXNjYXBlIChjb25maWcpIHtcbiAgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShjb25maWcpKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5lc2NhcGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxudmFyIG11c3RhY2hlID0ge1xuICBuYW1lOiAnbXVzdGFjaGUuanMnLFxuICB2ZXJzaW9uOiAnNC4yLjAnLFxuICB0YWdzOiBbICd7eycsICd9fScgXSxcbiAgY2xlYXJDYWNoZTogdW5kZWZpbmVkLFxuICBlc2NhcGU6IHVuZGVmaW5lZCxcbiAgcGFyc2U6IHVuZGVmaW5lZCxcbiAgcmVuZGVyOiB1bmRlZmluZWQsXG4gIFNjYW5uZXI6IHVuZGVmaW5lZCxcbiAgQ29udGV4dDogdW5kZWZpbmVkLFxuICBXcml0ZXI6IHVuZGVmaW5lZCxcbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgY2FjaGluZyBzdHJhdGVneSwgYnkgcHJvdmlkaW5nIGFuXG4gICAqIG9iamVjdCB3aXRoIHNldCwgZ2V0IGFuZCBjbGVhciBtZXRob2RzLiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gZGlzYWJsZVxuICAgKiB0aGUgY2FjaGUgYnkgc2V0dGluZyBpdCB0byB0aGUgbGl0ZXJhbCBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldCB0ZW1wbGF0ZUNhY2hlIChjYWNoZSkge1xuICAgIGRlZmF1bHRXcml0ZXIudGVtcGxhdGVDYWNoZSA9IGNhY2hlO1xuICB9LFxuICAvKipcbiAgICogR2V0cyB0aGUgZGVmYXVsdCBvciBvdmVycmlkZGVuIGNhY2hpbmcgb2JqZWN0IGZyb20gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnRlbXBsYXRlQ2FjaGU7XG4gIH1cbn07XG5cbi8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbnZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gKi9cbm11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIuY2xlYXJDYWNoZSgpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gdGVtcGxhdGUgaW4gdGhlIGRlZmF1bHQgd3JpdGVyIGFuZCByZXR1cm5zIHRoZVxuICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAqL1xubXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCwgYHBhcnRpYWxzYCwgYW5kIGBjb25maWdgXG4gKiB1c2luZyB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gKi9cbm11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBjb25maWcpIHtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCBcIicgKyB0eXBlU3RyKHRlbXBsYXRlKSArICdcIiB3YXMgZ2l2ZW4gYXMgdGhlIGZpcnN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgY29uZmlnKTtcbn07XG5cbi8vIEV4cG9ydCB0aGUgZXNjYXBpbmcgZnVuY3Rpb24gc28gdGhhdCB0aGUgdXNlciBtYXkgb3ZlcnJpZGUgaXQuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxubXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuLy8gRXhwb3J0IHRoZXNlIG1haW5seSBmb3IgdGVzdGluZywgYnV0IGFsc28gZm9yIGFkdmFuY2VkIHVzYWdlLlxubXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG5tdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbm11c3RhY2hlLldyaXRlciA9IFdyaXRlcjtcblxuZXhwb3J0IGRlZmF1bHQgbXVzdGFjaGU7XG4iLCAiaW1wb3J0IE11c3RhY2hlIGZyb20gJ211c3RhY2hlJztcbmltcG9ydCBwcm94eURhdGEgZnJvbSAnbXVzdGFjaGUtdmFsaWRhdG9yJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcblxuLyoqXG4gKiBFeHBhbmQgYW55IHBsYWNlaG9sZGVyIHN0cmluZ3MgLSB7ey4uLi59fSAtIGluIHRoZSBnaXZlbiB0ZW1wbGF0ZSwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBpbXBsZW1lbnRhdGlvbiBpcyBjdXJyZW50bHkgcHJvdmlkZWQgYnk6IFttdXN0YWNoZS5qc10oaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMpLlxuICpcbiAqIEBwYXJhbSB0ZW1wbGF0ZSAtIEEgdGVtcGxhdGUgc3RyaW5nLCB0eXBpY2FsbHkgd2l0aCBwbGFjZWhvbGRlcnMgc3VjaCBhcyB7e3F1ZXJ5LnRhc2suZm9sZGVyfX1cbiAqIEBwYXJhbSB2aWV3IC0gVGhlIHByb3BlcnR5IHZhbHVlc1xuICpcbiAqIEB0aHJvd3MgRXJyb3JcbiAqXG4gKiAgICAgIEJ5IHVzaW5nIG11c3RhY2hlLXZhbGlkYXRvcidzIHByb3h5RGF0YSwgd2UgZW5zdXJlIHRoYXQgYW55IGFjY2Vzc2VzIG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgYXJlXG4gKiAgICAgIG5vdCBpbiB0aGUgdmlldywgd2UgZW5zdXJlIHRoYXQgZXJyb3JzIGFyZSBkZXRlY3RlZCBpbW1lZGlhdGVseS5cbiAqICAgICAgVGhlIGZpcnN0IHVua25vd24gcGxhY2Vob2xkZXIgaXMgaW5jbHVkZWQgaW4gRXJyb3IubWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFBsYWNlaG9sZGVycyh0ZW1wbGF0ZTogc3RyaW5nLCB2aWV3OiBhbnkpOiBzdHJpbmcge1xuICAgIC8vIFR1cm4gb2ZmIEhUTUwgZXNjYXBpbmcgb2YgdGhpbmdzIGxpa2UgJy8nIGluIGZpbGUgcGF0aHM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMjdmFyaWFibGVzXG4gICAgTXVzdGFjaGUuZXNjYXBlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBNdXN0YWNoZS5yZW5kZXIodGVtcGxhdGUsIHByb3h5RGF0YSh2aWV3KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlcmUgd2FzIGFuIGVycm9yIGV4cGFuZGluZyBvbmUgb3IgbW9yZSBwbGFjZWhvbGRlcnMuXG5cblRoZSBlcnJvciBtZXNzYWdlIHdhczpcbiAgICAke2Vycm9yLm1lc3NhZ2UucmVwbGFjZSgvID4gL2csICcuJykucmVwbGFjZSgnTWlzc2luZyBNdXN0YWNoZSBkYXRhIHByb3BlcnR5JywgJ1Vua25vd24gcHJvcGVydHknKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdVbmtub3duIGVycm9yIGV4cGFuZGluZyBwbGFjZWhvbGRlcnMuJztcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlICs9IGBcblxuVGhlIHByb2JsZW0gaXMgaW46XG4gICAgJHt0ZW1wbGF0ZX1gO1xuICAgICAgICB0aHJvdyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgVGFza3NGaWxlIH0gZnJvbSAnLi9UYXNrc0ZpbGUnO1xuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIHBhcnQgb2YgdGhlIGltcGxlbWVudGF0aW9uIG9mIHBsYWNlaG9sZGVycy5cbiAqIFVzZSB7QGxpbmsgbWFrZVF1ZXJ5Q29udGV4dH0gdG8gbWFrZSBhIFF1ZXJ5Q29udGV4dC5cbiAqXG4gKiBRdWVyeUNvbnRleHQgaXMgYSAndmlldycgdG8gcGFzcyBpbiB0byB7QGxpbmsgZXhwYW5kUGxhY2Vob2xkZXJzfS5cbiAqXG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nOlxuICogYHF1ZXJ5Q29udGV4dC5xdWVyeS5maWxlYCAtIHdoZXJlIHF1ZXJ5LmZpbGUgaXMgYSB7QGxpbmsgVGFza3NGaWxlfSBvYmplY3QuXG4gKiBTbyBpdCBzdXBwbGllcyBgcXVlcnkuZmlsZS5wYXRoYCwgYHF1ZXJ5LmZpbGUuZm9sZGVyYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUNvbnRleHQge1xuICAgIHF1ZXJ5OiB7XG4gICAgICAgIGZpbGU6IFRhc2tzRmlsZTtcbiAgICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBRdWVyeUNvbnRleHR9IHRvIHJlcHJlc2VudCBhIHF1ZXJ5IGluIG5vdGUgYXQgdGhlIGdpdmUgcGF0aC5cbiAqIEBwYXJhbSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUXVlcnlDb250ZXh0KHBhdGg6IHN0cmluZyk6IFF1ZXJ5Q29udGV4dCB7XG4gICAgY29uc3QgdGFza3NGaWxlID0gbmV3IFRhc2tzRmlsZShwYXRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgZmlsZTogdGFza3NGaWxlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4iLCAiLyoqXG4gKiBHZXQgdGhlIHRleHQgdG8gcmVwb3J0IGFmdGVyIGFuIGV4Y2VwdGlvbiBpcyBjYXVnaHQuXG4gKiBAcGFyYW0gd2hhdFdhc0hhcHBlbmluZyAtIGEgZGVzY3JpcHRpb24gb2Ygd2hhdCB3YXMgaGFwcGVuaW5nIGF0IHRoZSB0aW1lLCBwcmVmZXJhYmx5IGluY2x1ZGluZyBhbnkgdXNlciBpbnB1dHMuXG4gKiBAcGFyYW0gZXhjZXB0aW9uIC0gb2JqZWN0IHRoYXQgd2FzIGNhdWdodCBpbiBhIHRyeS9jYXRjaCBibG9jay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbih3aGF0V2FzSGFwcGVuaW5nOiBzdHJpbmcsIGV4Y2VwdGlvbjogYW55KTogc3RyaW5nIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgRXJyb3I6ICR7d2hhdFdhc0hhcHBlbmluZ30uXG5UaGUgZXJyb3IgbWVzc2FnZSB3YXM6XG4gICAgYDtcbiAgICBsZXQgZGV0YWlsOiBzdHJpbmcgPSAnJztcbiAgICBpZiAoZXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZGV0YWlsICs9IGV4Y2VwdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXRhaWwgKz0gJ1Vua25vd24gZXJyb3InO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZXJyb3JNZXNzYWdlfVwiJHtkZXRhaWx9XCJgO1xufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuXG4vKipcbiAqIEEgc29ydGluZyBmdW5jdGlvbiwgdGhhdCB0YWtlcyB0d28gVGFzayBvYmplY3RzIGFuZCByZXR1cm5zXG4gKiBhbmQgcmV0dXJucyBvbmUgb2Y6XG4gKiAtIGAtMWAgb3Igc29tZSBvdGhlciBuZWdhdGl2ZSBudW1iZXIsIGlmIGEgaXMgbGVzcyB0aGFuIGIgYnkgc29tZSBvcmRlcmluZyBjcml0ZXJpb24uXG4gKiAtIGArMWAgb3Igc29tZSBvdGhlciBwb3NpdGl2ZSBudW1iZXIsIGlmIGEgaXMgZ3JlYXRlciB0aGFuIGIgYnkgdGhlIG9yZGVyaW5nIGNyaXRlcmlvbi5cbiAqIC0gYDBgIG9yIHNvbWV0aW1lcyBgLTBgLCBpZiBhIGVxdWFscyBiIGJ5IHRoZSBvcmRlcmluZyBjcml0ZXJpb24uXG4gKlxuICogVHlwaWNhbGx5IENvbXBhcmF0b3IgZnVuY3Rpb25zIGFyZSBzdG9yZWQgaW4gYSB7QGxpbmsgU29ydGVyfSBvYmplY3QuXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBhcmF0b3IgPSAoYTogVGFzaywgYjogVGFzaykgPT4gbnVtYmVyO1xuXG4vKipcbiAqIFNvcnRlciByZXByZXNlbnRzIGEgc2luZ2xlICdzb3J0IGJ5JyBpbnN0cnVjdGlvbi5cbiAqIEl0IHN0b3JlcyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiBhcyBhIHtAbGluayBDb21wYXJhdG9yfS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvcnRlciB7XG4gICAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5OiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IGNvbXBhcmF0b3I6IENvbXBhcmF0b3I7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIHtAbGluayBDb21wYXJhdG9yfSBmdW5jdGlvbiwgZm9yIHNvcnRpbmcgaW4gdGhlIHN0YW5kYXJkIGRpcmVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIElmIGByZXZlcnNlYCBpcyB0cnVlLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY29udmVydGVkIHRvIHJldmVyc2UgdGhlIHNvcnQgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSByZXZlcnNlIC0gd2hldGhlciB0aGUgc29ydCBvcmRlciBzaG91bGQgYmUgcmV2ZXJzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcGVydHk6IHN0cmluZywgY29tcGFyYXRvcjogQ29tcGFyYXRvciwgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IFNvcnRlci5tYXliZVJldmVyc2UocmV2ZXJzZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWF5YmVSZXZlcnNlKHJldmVyc2U6IGJvb2xlYW4sIGNvbXBhcmF0b3I6IENvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2UgPyBTb3J0ZXIubWFrZVJldmVyc2VkQ29tcGFyYXRvcihjb21wYXJhdG9yKSA6IGNvbXBhcmF0b3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFrZVJldmVyc2VkQ29tcGFyYXRvcihjb21wYXJhdG9yOiBDb21wYXJhdG9yKTogQ29tcGFyYXRvciB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgY2FuIHJldHVybiAtMC5cbiAgICAgICAgcmV0dXJuIChhLCBiKSA9PiAoY29tcGFyYXRvcihhLCBiKSAqIC0xKSBhcyAtMSB8IDAgfCAxO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcblxuLyoqXG4gKiBBIGdyb3VwLW5hbWluZyBmdW5jdGlvbiwgdGhhdCB0YWtlcyBhIFRhc2sgb2JqZWN0IGFuZCByZXR1cm5zIHplcm8gb3IgbW9yZVxuICogY29ycmVzcG9uZGluZyBncm91cCBwcm9wZXJ0eSBuYW1lcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYSB7QGxpbmsgR3JvdXBlckZ1bmN0aW9ufSBpbXBsZW1lbnRlZCBncm91cGluZyBieSB0YWcsXG4gKiBwYXNzaW5nIGluIGEgdGFzayB0aGF0IGhhcyB0d28gdGFncywgI3RhZzEgYW5kICN0YWcyIHRvIHRoaXMgdGFnLWdyb3VwZXIgZnVuY3Rpb25cbiAqIHdvdWxkIHJldHVybiBbJ3RhZzEnLCAndGFnMiddXG4gKi9cbmV4cG9ydCB0eXBlIEdyb3VwZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiBzdHJpbmdbXTtcblxuLyoqXG4gKiBBIG5hbWVkIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGdyb3VwIGhlYWRpbmcgbmFtZShzKSB0byB1c2UgZm9yIGEge0BsaW5rIFRhc2t9IG9iamVjdC5cbiAqXG4gKiBUaGUgbmFtZSBpcyByZXByZXNlbnRlZCBpbiB7QGxpbmsgcHJvcGVydHl9LlxuICpcbiAqIE5vdGU6IHtAbGluayBHcm91cGVyfSBvYmplY3RzIGFyZSB0eXBpY2FsbHkgY3JlYXRlZCBieSB7QGxpbmsgRmllbGQuZ3JvdXBlcn0gdXNpbmcgdGhlIG1hbnlcbiAqIGNsYXNzZXMgZGVyaXZlZCBmcm9tIHtAbGluayBGaWVsZH0uXG4gKlxuICogQHNlZSB7QGxpbmsgVGFza0dyb3Vwc30gZm9yIGhvdyB0byB1c2Uge0BsaW5rIEdyb3VwZXJ9IG9iamVjdHMgdG8gZ3JvdXAgdGFza3MgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBncm91cGVyLCBmb3IgZXhhbXBsZSAndGFncycgb3IgJ2R1ZScuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSAnZ3JvdXAgYnkgdGFncycgbGluZSB3b3VsZCBiZSBleHBlY3RlZCB0byBnZW5lcmF0ZSBhXG4gICAgICoge0BsaW5rIEdyb3VwZXIucHJvcGVydHl9IGNhbGxlZCAndGFncycuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIEdyb3VwZXJGdW5jdGlvbn0gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ3JvdXAgdGFza3MgdG9nZXRoZXIuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGdyb3VwZXI6IEdyb3VwZXJGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGhlYWRpbmdzIGZvciB0aGlzIGdyb3VwIHNob3VsZCBiZSByZXZlcnNlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5OiBzdHJpbmcsIGdyb3VwZXI6IEdyb3VwZXJGdW5jdGlvbiwgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuZ3JvdXBlciA9IGdyb3VwZXI7XG4gICAgICAgIHRoaXMucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFNvcnRlciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0ICogYXMgUmVnRXhwVG9vbHMgZnJvbSAnLi4vLi4vbGliL1JlZ0V4cFRvb2xzJztcbmltcG9ydCB7IEdyb3VwZXIgfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogRmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZWFjaCB0eXBlIG9mIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZGVyaXZlZCBjbGFzcyBTdGFydERhdGVGaWVsZCBpbXBsZW1lbnRzIHRoZSBwYXJzaW5nXG4gKiBvZiAnc3RhcnRzJyBpbnN0cnVjdGlvbnMuXG4gKlxuICogVGhlIG5hbWUgJ0ZpZWxkJyBtYXkgc2VlbSBjb25mdXNpbmcsIGFzIGl0IG1pZ2h0IGN1cnJlbnRseSBiZVxuICogZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgd29yZCAnRmlsdGVyJyBpbiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBDdXJyZW50IHRoaW5raW5nIGlzIHRoYXQgaXQgbWF5IHdlbGwgZXZvbHZlIGxhdGVyIHRvIGFsc28gaW1wbGVtZW50XG4gKiB0aGUgcHJlc2VuY2UgYW5kIGFic2VuY2Ugc2VhcmNoZXMgYXMgd2VsbFxuICogKHN1Y2ggJ25vIHN0YXJ0IGRhdGUnIGFuZCAnaGFzIHN0YXJ0IGRhdGUnKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZpZWxkIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNsYXNzIGNhbiBwYXJzZSB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNoZWNrcyB3aGV0aGVyIHRoZSBsaW5lIG1hdGNoZXNcbiAgICAgKiB0aGlzLmZpbHRlclJlZ0V4cCgpLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSBgYGB0YXNrc2BgYCBibG9jay5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkLmxpbmVNYXRjaGVzRmlsdGVyKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIEZpbHRlciBmdW5jdGlvbiBvciBhbiBlcnJvciBzdHJpbmcsXG4gICAgICogd2hpY2ggYXJlIGJvdGggd3JhcHBlZCBpbiBhIEZpbHRlck9yRXJyb3JNZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlO1xuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgZ2l2ZW4gbGluZSBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyP1xuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBBIFJlZ0V4cCByZWd1bGFyIGV4cHJlc3Npb24sIHRoYXQgc3BlY2lmaWVzIG9uZSBxdWVyeSBpbnN0cnVjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgT3IgbnVsbCwgaWYgdGhlIGZpZWxkIGRvZXMgbm90IHN1cHBvcnQgcmVnZXhwLWJhc2VkIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgbGluZSBmcm9tIGEgdGFza3MgY29kZSBibG9jayBxdWVyeS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBsaW5lTWF0Y2hlc0ZpbHRlcihmaWx0ZXI6IFJlZ0V4cCB8IG51bGwsIGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLnRlc3QobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1hdGNoIGZvciB0aGUgZ2l2ZW4gZmlsdGVyLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IG1hdGNoXG4gICAgICogQHBhcmFtIGZpbHRlclJlZ0V4cCAtIEEgUmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhhdCBzcGVjaWZpZXMgb25lIHF1ZXJ5IGluc3RydWN0aW9uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBPciBudWxsLCBpZiB0aGUgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCByZWdleHAtYmFzZWQgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSBsaW5lIC0gQSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrIHF1ZXJ5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldE1hdGNoKGZpbHRlclJlZ0V4cDogUmVnRXhwIHwgbnVsbCwgbGluZTogc3RyaW5nKTogUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwge1xuICAgICAgICBpZiAoZmlsdGVyUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5tYXRjaChmaWx0ZXJSZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGZpbHRlcmluZyBUYXNrcyBieSBpbnNwZWN0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLlxuICAgICAqIE9yIG51bGwsIGlmIHRoaXMgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHJlZ2V4LWJhc2VkIGluc3RydWN0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhpcyBmaWVsZCwgdG8gYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBUaGlzIHVzdWFsbHkgbWF0Y2hlcyB0aGUgaW5zdHJ1Y3Rpb24gbmFtZSwgYnV0IGRvZXMgbm90IGFsd2F5c1xuICAgICAqIChzZWUgc3RhcnQgYW5kIHN0YXJ0cykuXG4gICAgICpcbiAgICAgKiBBbHNvLCBzb21lIGZpZWxkcyBoYXZlIG1vcmUgdGhhbiBvbmUgbmFtZSwgc2VwYXJhdGVkIGJ5ICcvJy5cbiAgICAgKiBTZWUge0BsaW5rIFRhZ3NGaWVsZH0sIGZvciBleGFtcGxlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBmaWVsZE5hbWUoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKlxuICAgICAqIEBzZWUgZmllbGROYW1lXG4gICAgICogQHNlZSBmaWVsZE5hbWVTaW5ndWxhckVzY2FwZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBvZiB0aGUgZmllbGQncyBuYW1lLCBlc2NhcGVkIGZvciB1c2UgaW4gcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGZvciBmaWVsZCBuYW1lcyB0aGF0IGNvbnRhaW4gYC5gIGluLCBmb3IgZXhhbXBsZS5cbiAgICAgKiBAcHVibGljXG4gICAgICpcbiAgICAgKiBAc2VlIGZpZWxkTmFtZVxuICAgICAqIEBzZWUgZmllbGROYW1lU2luZ3VsYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwVG9vbHMuZXNjYXBlUmVnRXhwKHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBjb2RlIGZvciB0aGlzIGZpZWxkIGltcGxlbWVudHMgc29ydGluZyBvZiB0YXNrcy5cbiAgICAgKlxuICAgICAqIElmIG92ZXJyaWRpbmcgdGhpcyB0byByZXR1cm4gdHJ1ZSwgaW4gb3JkZXIgdG8gZW5hYmxlIHNvcnRpbmcsXG4gICAgICogdGhlIG1ldGhvZCB7QGxpbmsgY29tcGFyYXRvcn0gbXVzdCBhbHNvIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBvciBudWxsLlxuICAgICAqXG4gICAgICogVGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdvcmtzIGZvciBhbGwgZmllbGRzIHRoYXQgc3VwcG9ydFxuICAgICAqIHRoZSBkZWZhdWx0IHNvcnRpbmcgcGF0dGVybiBvZiBgc29ydCBieSA8ZmllbGROYW1lPiAocmV2ZXJzZSk/YC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ3NvcnQgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSAtIEEgJ3NvcnQgYnknIGxpbmUgZnJvbSBhIGBgYHRhc2tzYGBgIGJsb2NrLlxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVTb3J0ZXJGcm9tTGluZShsaW5lOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzU29ydGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5zb3J0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ydGVyKHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgbWF0Y2ggYSBjb3JyZWN0bHktZm9ybWVkXG4gICAgICogaW5zdHJ1Y3Rpb24gbGluZSBmb3Igc29ydGluZyBUYXNrcyBieSB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogVGhyb3dzIGlmIHRoaXMgZmllbGQgZG9lcyBub3Qgc3VwcG9ydCBzb3J0aW5nLlxuICAgICAqXG4gICAgICogYG1hdGNoWzFdYCB3aWxsIGJlIGVpdGhlciBgcmV2ZXJzZWAgb3IgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogRmllbGRzIHRoYXQgb2ZmZXIgbW9yZSBjb21wbGljYXRlZCAnc29ydCBieScgb3B0aW9ucyBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc29ydGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1NvcnRpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYHNvcnRlclJlZ0V4cCgpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5zb3J0IGJ5ICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0oIHJldmVyc2UpP2ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdHdvIFRhc2sgb2JqZWN0cywgZm9yIHVzZSBpbiBzb3J0aW5nIGJ5IHRoaXMgZmllbGQncyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgc3VwcG9ydHNTb3J0aW5nfSBmb3Igd2hhdCB0byBkbywgdG8gZW5hYmxlIHN1cHBvcnQgb2Ygc29ydGluZyBpbiBhXG4gICAgICogcGFydGljdWxhciB7QGxpbmsgRmllbGR9IGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICB0aHJvdyBFcnJvcihgY29tcGFyYXRvcigpIHVuaW1wbGVtZW50ZWQgZm9yICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhcigpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBmb3Igc29ydGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUuXG4gICAgICogQHBhcmFtIHJldmVyc2UgLSBmYWxzZSBmb3Igbm9ybWFsIHNvcnQgb3JkZXIsIHRydWUgZm9yIHJldmVyc2Ugc29ydCBvcmRlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlU29ydGVyKHJldmVyc2U6IGJvb2xlYW4pOiBTb3J0ZXIge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlcih0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCksIHRoaXMuY29tcGFyYXRvcigpLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgU29ydGVyfSBvYmplY3QgZm9yIHNvcnRpbmcgdGFza3MgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLFxuICAgICAqIGluIHRoZSBzdGFuZGFyZC9ub3JtYWwgc29ydCBvcmRlciBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZVJldmVyc2VTb3J0ZXJ9XG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZU5vcm1hbFNvcnRlcigpOiBTb3J0ZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb3J0ZXIoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBTb3J0ZXJ9IG9iamVjdCBmb3Igc29ydGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUsXG4gICAgICogaW4gdGhlIHJldmVyc2Ugb2YgdGhlIHN0YW5kYXJkL25vcm1hbCBzb3J0IG9yZGVyIGZvciB0aGlzIGZpZWxkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlTm9ybWFsU29ydGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVSZXZlcnNlU29ydGVyKCk6IFNvcnRlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvcnRlcih0cnVlKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBjb2RlIGZvciB0aGlzIGZpZWxkIGltcGxlbWVudHMgZ3JvdXBpbmcgb2YgdGFza3MuXG4gICAgICpcbiAgICAgKiBJZiBvdmVycmlkaW5nIHRoaXMgdG8gcmV0dXJuIHRydWUsIGluIG9yZGVyIHRvIGVuYWJsZSBncm91cGluZyxcbiAgICAgKiB0aGUgbWV0aG9kIHtAbGluayBncm91cGVyfSBtdXN0IGFsc28gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBsaW5lLCBhbmQgcmV0dXJuIGVpdGhlciBhIHtAbGluayBHcm91cGVyfSBvYmplY3Qgb3IgbnVsbC5cbiAgICAgKlxuICAgICAqIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3b3JrcyBmb3IgYWxsIGZpZWxkcyB0aGF0IHN1cHBvcnRcbiAgICAgKiB0aGUgZGVmYXVsdCBncm91cGluZyBwYXR0ZXJuIG9mIGBncm91cCBieSA8ZmllbGROYW1lPiAocmV2ZXJzZSk/YC5cbiAgICAgKlxuICAgICAqIEZpZWxkcyB0aGF0IG9mZmVyIG1vcmUgY29tcGxpY2F0ZWQgJ2dyb3VwIGJ5JyBvcHRpb25zIGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmUgLSBBICdncm91cCBieScgbGluZSBmcm9tIGEgYGBgdGFza3NgYGAgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXJGcm9tTGluZShsaW5lOiBzdHJpbmcpOiBHcm91cGVyIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0dyb3VwaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBGaWVsZC5nZXRNYXRjaCh0aGlzLmdyb3VwZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlR3JvdXBlcihyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIGdyb3VwaW5nIFRhc2tzIGJ5IHRoaXMgZmllbGQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgdGhpcyBmaWVsZCBkb2VzIG5vdCBzdXBwb3J0IGdyb3VwaW5nLlxuICAgICAqXG4gICAgICogYG1hdGNoWzFdYCB3aWxsIGJlIGVpdGhlciBgcmV2ZXJzZWAgb3IgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogRmllbGRzIHRoYXQgb2ZmZXIgbW9yZSBjb21wbGljYXRlZCAnZ3JvdXAgYnknIG9wdGlvbnMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdyb3VwZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzR3JvdXBpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGdyb3VwZXJSZWdFeHAoKSB1bmltcGxlbWVudGVkIGZvciAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSAkIGF0IGVuZCBpcyByZXF1aXJlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGdyb3VwIGJ5IHN0YXR1cyBhbmQgc3RhdHVzLm5hbWVcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5ncm91cCBieSAke3RoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCl9KCByZXZlcnNlKT8kYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdG8gZ2V0IGEgbGlzdCBvZiBhIHRhc2sncyBncm91cCBuYW1lcywgZm9yIHVzZSBpbiBncm91cGluZyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIHN1cHBvcnRzR3JvdXBpbmd9IGZvciB3aGF0IHRvIGRvLCB0byBlbmFibGUgc3VwcG9ydCBvZiBncm91cGluZyBpbiBhXG4gICAgICogcGFydGljdWxhciB7QGxpbmsgRmllbGR9IGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHRocm93IEVycm9yKGBncm91cGVyKCkgdW5pbXBsZW1lbnRlZCBmb3IgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIEdyb3VwZXJ9IG9iamVjdCBmb3IgZ3JvdXBpbmcgdGFza3MgYnkgdGhpcyBmaWVsZCdzIHZhbHVlLlxuICAgICAqIEBwYXJhbSByZXZlcnNlIC0gZmFsc2UgZm9yIG5vcm1hbCBncm91cCBvcmRlciwgdHJ1ZSBmb3IgcmV2ZXJzZSBncm91cCBvcmRlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlR3JvdXBlcihyZXZlcnNlOiBib29sZWFuKTogR3JvdXBlciB7XG4gICAgICAgIHJldHVybiBuZXcgR3JvdXBlcih0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCksIHRoaXMuZ3JvdXBlcigpLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0IGZvciBncm91cGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUsXG4gICAgICogaW4gdGhlIHN0YW5kYXJkL25vcm1hbCBncm91cCBvcmRlciBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZVJldmVyc2VHcm91cGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVOb3JtYWxHcm91cGVyKCk6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVHcm91cGVyKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0IGZvciBncm91cGluZyB0YXNrcyBieSB0aGlzIGZpZWxkJ3MgdmFsdWUsXG4gICAgICogaW4gdGhlIHJldmVyc2Ugb2YgdGhlIHN0YW5kYXJkL25vcm1hbCBncm91cCBvcmRlciBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZU5vcm1hbEdyb3VwZXJ9XG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZVJldmVyc2VHcm91cGVyKCk6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVHcm91cGVyKHRydWUpO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEFuIEV4cGxhbmF0aW9uIG9iamVjdCBzdG9yZXMgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIGEgUXVlcnkgaW5zdHJ1Y3Rpb24sIG9yIGEgY29tcG9uZW50IG9mIG9uZS5cbiAqXG4gKiBJdCBzdXBwb3J0cyBCb29sZWFuIGNvbWJpbmF0aW9ucyB2aWEgdGhlIHtAbGluayBjaGlsZHJlbn0gZmllbGQuXG4gKlxuICogSW5pdGlhbGx5LCB0aGUge0BsaW5rIGRlc2NyaXB0aW9ufSB3aWxsIHNpbXBseSByZXN0YXRlIHRoZSBpbnN0cnVjdGlvbiBmaWx0ZXIuXG4gKiBMYXRlciwgbW9yZSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBsYW5hdGlvbiB7XG4gICAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgcHVibGljIHJlYWRvbmx5IHN5bWJvbDogc3RyaW5nOyAvLyBBTkQsIE9SLCBOT1QsIFhPUlxuICAgIHB1YmxpYyByZWFkb25seSBjaGlsZHJlbjogRXhwbGFuYXRpb25bXTtcblxuICAgIGNvbnN0cnVjdG9yKGRlc2NyaXB0aW9uOiBzdHJpbmcsIGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdID0gW10sIHN5bWJvbDogc3RyaW5nID0gJycpIHtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gQU5EXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuQW5kKGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJpbmVPckNyZWF0ZUV4cGxhbmF0aW9uKCdBbGwgb2YnLCBjaGlsZHJlbiwgJ0FORCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gT1JcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJvb2xlYW5PcihjaGlsZHJlbjogRXhwbGFuYXRpb25bXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lT3JDcmVhdGVFeHBsYW5hdGlvbignQXQgbGVhc3Qgb25lIG9mJywgY2hpbGRyZW4sICdPUicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gTk9UXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuTm90KGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oJ05vbmUgb2YnLCBjaGlsZHJlbiwgJ05PVCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFeHBsYW5hdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIEJvb2xlYW4gWE9SXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBib29sZWFuWG9yKGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oJ0V4YWN0bHkgb25lIG9mJywgY2hpbGRyZW4sICdYT1InKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEV4cGxhbmF0aW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGl0IHdpbGwgbm90IGhhdmUgYSBmaW5hbCBlbmQtb2YtbGluZSBjaGFyYWN0ZXIgYXQgdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJyZW50SW5kZW50YXRpb24gLSBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gVXNlcnMgY2FuIGlnbm9yZSBpdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXNTdHJpbmcoY3VycmVudEluZGVudGF0aW9uOiBzdHJpbmcgPSAnJykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRlbnRhdGlvbiArIHRoaXMuZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gY3VycmVudEluZGVudGF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgd2FzIG5vdCBzZXQsIGFkZCB0aGUgZGVzY3JpcHRpb24gYW5kIGp1c3QgaW5kZW50XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGRldGFpbGVkIGV4cGxhbmF0aW9uIHdpdGggbG9naWNcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnN5bWJvbDtcblxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBjaGlsZHJlbiwgc28gY29uY2F0ZW5hdGUgdGhlbSB0b2dldGhlclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkZXNjcmlwdGlvbnMgbGlrZSAnQWxsIG9mJywgJ05vbmUgb2YnIGFyZSBvbmUgcmVhbGx5IG1lYW5pbmdmdWxcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGZpbHRlci4gT3RoZXJ3aXNlLCB0aGV5IGFyZSBqdXN0IGNvbmZ1c2luZy5cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYCAoJHt0aGlzLmRlc2NyaXB0aW9ufSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc6JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld0luZGVudGF0aW9uID0gY3VycmVudEluZGVudGF0aW9uICsgJyAgJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFxcbiR7dGhpcy5jaGlsZHJlbltpXS5hc1N0cmluZyhuZXdJbmRlbnRhdGlvbil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNvbWJpbmVPckNyZWF0ZUV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcsIGNoaWxkcmVuOiBFeHBsYW5hdGlvbltdLCBzeW1ib2w6IHN0cmluZykge1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDAgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkMSA9IGNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgaWYgKGNoaWxkMC5zeW1ib2wgPT09IHN5bWJvbCAmJiBjaGlsZDEuc3ltYm9sID09PSAnJykge1xuICAgICAgICAgICAgICAgIGNoaWxkMC5jaGlsZHJlbi5wdXNoKGNoaWxkMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKGRlc2NyaXB0aW9uLCBjaGlsZHJlbiwgc3ltYm9sKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5cbi8qKlxuICogQSBmaWx0ZXJpbmcgZnVuY3Rpb24sIHRoYXQgdGFrZXMgYSBUYXNrIG9iamVjdCBhbmQgcmV0dXJuc1xuICogd2hldGhlciBpdCBtYXRjaGVzIGEgcGFydGljdWxhciBmaWx0ZXJpbmcgaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IGJvb2xlYW47XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwYXJzZWQgZmlsdGVyaW5nIGluc3RydWN0aW9uIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrLlxuICpcbiAqIEN1cnJlbnRseSBpdCBwcm92aWRlcyBhY2Nlc3MgdG86XG4gKlxuICogLSBUaGUgb3JpZ2luYWwge0BsaW5rIGluc3RydWN0aW9ufVxuICogLSBUaGUge0BsaW5rIGZpbHRlckZ1bmN0aW9ufSAtIGEge0BsaW5rIEZpbHRlckZ1bmN0aW9ufSB3aGljaCB0ZXN0cyB3aGV0aGVyIGEgdGFzayBtYXRjaGVzIHRoZSBmaWx0ZXJcbiAqXG4gKiBMYXRlciwgdGhlIHBsYW4gaXMgdG8gYWRkIGEgaHVtYW4tcmVhZGFibGUgZXhwbGFuYXRpb24gb2YgdGhlIGZpbHRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlciB7XG4gICAgcmVhZG9ubHkgaW5zdHJ1Y3Rpb246IHN0cmluZztcbiAgICByZWFkb25seSBleHBsYW5hdGlvbjogRXhwbGFuYXRpb247XG4gICAgcHVibGljIGZpbHRlckZ1bmN0aW9uOiBGaWx0ZXJGdW5jdGlvbjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXJGdW5jdGlvbjogRmlsdGVyRnVuY3Rpb24sIGV4cGxhbmF0aW9uOiBFeHBsYW5hdGlvbikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgICAgICAgdGhpcy5maWx0ZXJGdW5jdGlvbiA9IGZpbHRlckZ1bmN0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHBsYWluRmlsdGVySW5kZW50ZWQoaW5kZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSB0aGlzLmV4cGxhbmF0aW9uO1xuICAgICAgICBjb25zdCB1bmluZGVudGVkRXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbi5hc1N0cmluZygpO1xuICAgICAgICBpZiAodW5pbmRlbnRlZEV4cGxhbmF0aW9uID09PSB0aGlzLmluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7aW5kZW50fSR7dGhpcy5pbnN0cnVjdGlvbn1cXG5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2luZGVudH0ke3RoaXMuaW5zdHJ1Y3Rpb259ID0+XFxuJHtleHBsYW5hdGlvbi5hc1N0cmluZygnICAnKX1cXG5gO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qKlxuICogR2VuZXJpYyBjbGFzcyBmb3Igc3RvcmluZzpcbiAqIC0gYSB0ZXh0IGluc3RydWN0aW9uLlxuICogLSBhbiBvYmplY3Qgb2YgdHlwZSBRdWVyeUNvbXBvbmVudCBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbnN0cnVjdGlvbiwgaWYgdGhlIGluc3RydWN0aW9uIGlzIHZhbGlkLlxuICogLSBvdGhlcndpc2UsIGFuIGVycm9yIG1lc3NhZ2UgZXhwbGFpbmluZyBpbiB3aGF0IHdhdCB0aGUgaW5zdHJ1Y3Rpb24gaXMgaW52YWxpZC5cbiAqXG4gKiBBbiBleGFtcGxlIHR5cGUgb2YgUXVlcnlDb21wb25lbnQgaXMge0BsaW5rIEZpbHRlcn0uIFNlZSB7QGxpbmsgRmlsdGVyT3JFcnJvck1lc3NhZ2V9LlxuICovXG5leHBvcnQgY2xhc3MgUXVlcnlDb21wb25lbnRPckVycm9yPFF1ZXJ5Q29tcG9uZW50PiB7XG4gICAgcmVhZG9ubHkgaW5zdHJ1Y3Rpb246IHN0cmluZztcbiAgICBwcml2YXRlIF9xdWVyeUNvbXBvbmVudDogUXVlcnlDb21wb25lbnQgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfZXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHF1ZXJ5Q29tcG9uZW50KCk6IFF1ZXJ5Q29tcG9uZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29tcG9uZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0IHF1ZXJ5Q29tcG9uZW50KHZhbHVlOiBRdWVyeUNvbXBvbmVudCB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9xdWVyeUNvbXBvbmVudCA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZXJyb3IoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0IGVycm9yKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gT2JqZWN0T3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gUXVlcnlDb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gYSB7QGxpbmsgRmlsdGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbU9iamVjdDxRdWVyeUNvbXBvbmVudD4oXG4gICAgICAgIGluc3RydWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIG9iamVjdDogUXVlcnlDb21wb25lbnQsXG4gICAgKTogUXVlcnlDb21wb25lbnRPckVycm9yPFF1ZXJ5Q29tcG9uZW50PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWVyeUNvbXBvbmVudE9yRXJyb3I8UXVlcnlDb21wb25lbnQ+KGluc3RydWN0aW9uKTtcbiAgICAgICAgcmVzdWx0Ll9xdWVyeUNvbXBvbmVudCA9IG9iamVjdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBPYmplY3RPckVycm9yTWVzc2FnZSB3aXRoIHRoZSBnaXZlbiBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21FcnJvcjxRdWVyeUNvbXBvbmVudD4oXG4gICAgICAgIGluc3RydWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIGVycm9yTWVzc2FnZTogc3RyaW5nLFxuICAgICk6IFF1ZXJ5Q29tcG9uZW50T3JFcnJvcjxRdWVyeUNvbXBvbmVudD4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVlcnlDb21wb25lbnRPckVycm9yPFF1ZXJ5Q29tcG9uZW50PihpbnN0cnVjdGlvbik7XG4gICAgICAgIHJlc3VsdC5fZXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFF1ZXJ5Q29tcG9uZW50T3JFcnJvciB9IGZyb20gJy4uL1F1ZXJ5Q29tcG9uZW50T3JFcnJvcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlciwgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5cbi8qKlxuICogQSBjbGFzcyB3aGljaCBzdG9yZXMgb25lIG9mOlxuICogLSBUaGUgb3JpZ2luYWwgaW5zdHJ1Y3Rpb24gc3RyaW5nIC0gYSBsaW5lIGZyb20gYSB0YXNrcyBjb2RlIGJsb2NrXG4gKiAtIEFuIG9wdGlvbmFsIHtAbGluayBGaWx0ZXJ9XG4gKiAtIEFuIG9wdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAqXG4gKiBUaGlzIGlzIHJlYWxseSBjdXJyZW50bHkgYSBjb252ZW5pZW5jZSBmb3IgcmV0dXJuaW5nIGRhdGEgZnJvbVxuICoge0BsaW5rIEZpZWxkLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKCl9IGFuZCBkZXJpdmVkIGNsYXNzZXMuXG4gKlxuICogQnkgdGhlIHRpbWUgdGhlIGNvZGUgaGFzIGZpbmlzaGVkIHdpdGggcGFyc2luZyB0aGUgbGluZSwgdHlwaWNhbGx5IHRoZVxuICogY29udGFpbmVkIHtAbGluayBGaWx0ZXJ9IHdpbGwgYmUgc2F2ZWQsIGZvciBsYXRlciB1c2UgaW4gc2VhcmNoaW5nIGZvciBUYXNrc1xuICogdGhhdCBtYXRjaCB0aGUgdXNlcidzIGZpbHRlciBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICBwdWJsaWMgb2JqZWN0OiBRdWVyeUNvbXBvbmVudE9yRXJyb3I8RmlsdGVyPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3Iob2JqZWN0OiBRdWVyeUNvbXBvbmVudE9yRXJyb3I8RmlsdGVyPikge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGluc3RydWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5pbnN0cnVjdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpbHRlcigpOiBGaWx0ZXIgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QucXVlcnlDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlcnJvcigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuZXJyb3I7XG4gICAgfVxuXG4gICAgZ2V0IGZpbHRlckZ1bmN0aW9uKCk6IEZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZmlsdGVyRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgYSBtZWFuaW5nZnVsIHtAbGluayBFeHBsYW5hdGlvbn0gdG8gYmUgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gYSB7QGxpbmsgRmlsdGVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUZpbHRlcihmaWx0ZXI6IEZpbHRlcik6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJPckVycm9yTWVzc2FnZShRdWVyeUNvbXBvbmVudE9yRXJyb3IuZnJvbU9iamVjdDxGaWx0ZXI+KGZpbHRlci5pbnN0cnVjdGlvbiwgZmlsdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRmlsdGVyT3JFcnJvck1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tRXJyb3IoaW5zdHJ1Y3Rpb246IHN0cmluZywgZXJyb3JNZXNzYWdlOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyT3JFcnJvck1lc3NhZ2UoUXVlcnlDb21wb25lbnRPckVycm9yLmZyb21FcnJvcjxGaWx0ZXI+KGluc3RydWN0aW9uLCBlcnJvck1lc3NhZ2UpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyRnVuY3Rpb24gfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgc2luZ2xlIGluc3RydWN0aW9uIGZvciBmaWx0ZXJpbmcgdGFza3MsIGFuZCBpdHMgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUuXG4gKlxuICogVGhpcyBpcyByZWFsbHkgYSBoZWxwZXIgdG8gc2ltcGxpZnkgdGhlIGltcGxlbWVudGF0aW9uIG9mIGluZGl2aWR1YWwgZmlsdGVyXG4gKiBpbnN0cnVjdGlvbnMsIGhpZGluZyBhd2F5IHRoZSBkZXRhaWxzIG9mIHBhcnNpbmcgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbiBsaW5lcy5cbiAqXG4gKiBUaGlzIHdpbGwgdXN1YWxseSBiZSBhY2Nlc3NlZCB2aWEge0BsaW5rIEZpbHRlckluc3RydWN0aW9ucy5hZGR9XG4gKlxuICogQHNlZSBGaWx0ZXJJbnN0cnVjdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlckluc3RydWN0aW9uIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pbnN0cnVjdGlvbjogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpbHRlcjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvcjpcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gLSBGdWxsIHRleHQgb2YgdGhlIGluc3RydWN0aW9uIGZvciB0aGUgZmlsdGVyOiBtdXN0IGJlIG1hdGNoZWQgZXhhY3RseVxuICAgICAqIEBwYXJhbSBmaWx0ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXI6IEZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGxpbmUgPT0gdGhpcy5faW5zdHJ1Y3Rpb247XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IHRoaXMuX2luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihuZXcgRmlsdGVyKGxpbmUsIHRoaXMuX2ZpbHRlciwgbmV3IEV4cGxhbmF0aW9uKGxpbmUpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGBkbyBub3QgdW5kZXJzdGFuZCBmaWx0ZXI6ICR7bGluZX1gKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb24gfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9uJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgY29sbGVjdGlvbiBvZiBpbnN0cnVjdGlvbnMgZm9yIGZpbHRlcmluZyB0YXNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpbHRlcnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG4gKiAgICAgdGhpcy5fZmlsdGVycy5hZGQoJ2lzIHJlY3VycmluZycsICh0YXNrKSA9PiB0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpO1xuICpcbiAqIEBzZWUgRmlsdGVySW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlckluc3RydWN0aW9ucyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZmlsdGVyczogRmlsdGVySW5zdHJ1Y3Rpb25bXSA9IFtdO1xuXG4gICAgcHVibGljIGFkZChpbnN0cnVjdGlvbjogc3RyaW5nLCBmaWx0ZXI6IEZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaChuZXcgRmlsdGVySW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGZpbHRlcikpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGZpbHRlci5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgICAgIGlmICh4LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgYGRvIG5vdCB1bmRlcnN0YW5kIGZpbHRlcjogJHtsaW5lfWApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGltcGxlbWVudHMgb2Yge0BsaW5rIEZpZWxkfVxuICpcbiAqIFRoZSBuYW1lZCBvZiB0aGUgY2xhc3MgaXMgd2Vhay4gSXQgaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBmYWN0IHRoYXQgdGhlXG4gKiBjbGFzcyBpcyBlbnRpcmVseSBpbXBsZW1lbnRlZCB2aWEgdGhlIHtAbGluayBGaWx0ZXJJbnN0cnVjdGlvbnN9IGNsYXNzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2ZpbHRlcnMgPSBuZXcgRmlsdGVySW5zdHJ1Y3Rpb25zKCk7XG5cbiAgICBwdWJsaWMgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycy5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQnO1xuXG5leHBvcnQgY2xhc3MgU3RhdHVzRmllbGQgZXh0ZW5kcyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBjaGFuZ2U6IEluIFRhc2tzIDEuMjIuMCBhbmQgZWFybGllciwgYWxsIHRhc2tzXG4gICAgICAgIC8vIHdpdGggYW55IHN0YXR1cyBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlIHdlcmUgY29uc2lkZXJlZCBieSB0aGUgc3RhdHVzIGZpbHRlclxuICAgICAgICAvLyBpbnN0cnVjdGlvbnMgdG8gYmUgZG9uZS5cbiAgICAgICAgLy8gSW4gbGF0ZXIgdmVyc2lvbnM6XG4gICAgICAgIC8vICAgU3RhdHVzVHlwZS5ET05FIGNvdW50cyBhcyBkb25lXG4gICAgICAgIC8vICAgU3RhdHVzVHlwZS5DQU5DRUxMRUQgY291bnRzIGFzIGRvbmVcbiAgICAgICAgLy8gICBTdGF0dXNUeXBlLlRPRE8gY291bnRzIGFzIG5vdCBkb25lXG4gICAgICAgIC8vICAgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUyBjb3VudHMgYXMgbm90IGRvbmVcbiAgICAgICAgLy8gICBTdGF0dXNUeXBlLk5PTl9UQVNLIGNvdW50cyBhcyBkb25lXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdkb25lJywgKHRhc2s6IFRhc2spID0+IHRhc2suaXNEb25lKTtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5hZGQoJ25vdCBkb25lJywgKHRhc2s6IFRhc2spID0+ICF0YXNrLmlzRG9uZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXR1cyc7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdG8gY29tcGFyZSB0d28gVGFzayBvYmplY3RzLCBmb3IgdXNlIGluIHNvcnRpbmcgYnkgc3RhdHVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBub3RlOiBJbiBUYXNrcyAxLjIyLjAgYW5kIGVhcmxpZXIsIHRoZVxuICAgICAgICAvLyBvbmx5IGF2YWlsYWJsZSBzdGF0dXMgbmFtZXMgd2VyZSAnVG9kbycgYW5kICdEb25lJy5cbiAgICAgICAgLy8gQW5kICdUb2RvJyBzb3J0ZWQgYmVmb3JlICdEb25lJy5cbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRTdGF0dXNOYW1lQSA9IFN0YXR1c0ZpZWxkLm9sZFN0YXR1c05hbWUoYSk7XG4gICAgICAgICAgICBjb25zdCBvbGRTdGF0dXNOYW1lQiA9IFN0YXR1c0ZpZWxkLm9sZFN0YXR1c05hbWUoYik7XG4gICAgICAgICAgICBpZiAob2xkU3RhdHVzTmFtZUEgPCBvbGRTdGF0dXNOYW1lQikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRTdGF0dXNOYW1lQSA+IG9sZFN0YXR1c05hbWVCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBvbGRTdGF0dXNOYW1lKGE6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICBpZiAoYS5zdGF0dXMuc3ltYm9sID09PSAnICcpIHtcbiAgICAgICAgICAgIHJldHVybiAnVG9kbyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RvbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgbm90ZTogSW4gVGFza3MgMS4yMi4wIGFuZCBlYXJsaWVyLCB0aGUgb25seVxuICAgICAgICAgICAgLy8gbmFtZXMgdXNlZCBieSAnZ3JvdXAgYnkgc3RhdHVzJyB3ZXJlICdUb2RvJyBhbmQgJ0RvbmUnIC0gYW5kXG4gICAgICAgICAgICAvLyBhbnkgY2hhcmFjdGVyIG90aGVyIHRoYW4gYSBzcGFjZSB3YXMgY29uc2lkZXJlZCB0byBiZSAnRG9uZScuXG4gICAgICAgICAgICByZXR1cm4gW1N0YXR1c0ZpZWxkLm9sZFN0YXR1c05hbWUodGFzayldO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9EYXRlUmFuZ2UnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlUGFyc2VyIH0gZnJvbSAnLi4vRGF0ZVBhcnNlcic7XG5pbXBvcnQgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB7IGNvbXBhcmVCeURhdGUgfSBmcm9tICcuLi8uLi9saWIvRGF0ZVRvb2xzJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyLCB0eXBlIEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnMnO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcblxuZXhwb3J0IHR5cGUgRGF0ZUZpbHRlckZ1bmN0aW9uID0gKGRhdGU6IE1vbWVudCB8IG51bGwpID0+IGJvb2xlYW47XG5cbi8qKlxuICogRGF0ZUZpZWxkIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdG8gaGVscCBpbXBsZW1lbnRcbiAqIGFsbCB0aGUgZmlsdGVyIGluc3RydWN0aW9ucyB0aGF0IGFjdCBvbiBhIHNpbmdsZSB0eXBlIG9mIGRhdGVcbiAqIHZhbHVlLCBzdWNoIGFzIHRoZSBkb25lIGRhdGUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGZpbHRlckluc3RydWN0aW9uczogRmlsdGVySW5zdHJ1Y3Rpb25zO1xuXG4gICAgY29uc3RydWN0b3IoZmlsdGVySW5zdHJ1Y3Rpb25zOiBGaWx0ZXJJbnN0cnVjdGlvbnMgfCBudWxsID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoZmlsdGVySW5zdHJ1Y3Rpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucyA9IGZpbHRlckluc3RydWN0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zID0gbmV3IEZpbHRlckluc3RydWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuYWRkKGBoYXMgJHt0aGlzLmZpZWxkTmFtZSgpfSBkYXRlYCwgKHRhc2s6IFRhc2spID0+IHRoaXMuZGF0ZSh0YXNrKSAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYG5vICR7dGhpcy5maWVsZE5hbWUoKX0gZGF0ZWAsICh0YXNrOiBUYXNrKSA9PiB0aGlzLmRhdGUodGFzaykgPT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuYWRkKGAke3RoaXMuZmllbGROYW1lKCl9IGRhdGUgaXMgaW52YWxpZGAsICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZSh0YXNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZSAhPT0gbnVsbCAmJiAhZGF0ZS5pc1ZhbGlkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBmaWx0ZXJSZXN1bHQgPSB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5jcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lKTtcbiAgICAgICAgaWYgKGZpbHRlclJlc3VsdC5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlclJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZUtleXdvcmREYXRlID0gRmllbGQuZ2V0TWF0Y2godGhpcy5maWx0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChmaWVsZE5hbWVLZXl3b3JkRGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICdkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCcgKyB0aGlzLmZpZWxkTmFtZSgpICsgJyBkYXRlKScsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5d29yZEFuZERhdGVTdHJpbmcgPSBmaWVsZE5hbWVLZXl3b3JkRGF0ZVsxXTsgLy8gVGhlIHdob2xlIGxpbmUgZXhjZXB0IHRoZSBmaWVsZCBuYW1lXG4gICAgICAgIGNvbnN0IGZpZWxkS2V5d29yZCA9IGZpZWxkTmFtZUtleXdvcmREYXRlWzJdOyAvLyAnb24nLCAnaW4nLCAnYmVmb3JlJywgJ2FmdGVyJywgJ29ufGluIG9yIGJlZm9yZXxhZnRlcicgb3IgdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGZpZWxkRGF0ZVN0cmluZyA9IGZpZWxkTmFtZUtleXdvcmREYXRlWzNdOyAvLyBUaGUgcmVtYWluZGVyIG9mIHRoZSBpbnN0cnVjdGlvblxuXG4gICAgICAgIC8vIFRyeSBpbnRlcnByZXRpbmcgZXZlcnl0aGluZyBhZnRlciB0aGUga2V5d29yZCBhcyBhIGRhdGUgcmFuZ2U6XG4gICAgICAgIGxldCBmaWVsZERhdGVzID0gRGF0ZVBhcnNlci5wYXJzZURhdGVSYW5nZShmaWVsZERhdGVTdHJpbmcpO1xuXG4gICAgICAgIC8vIElmIHRoZSBkYXRlIHJhbmdlIHBhcnNpbmcgZmFpbGVkLCB0cnkgYWdhaW4gdG8gcGFyc2UgdGhlIHdob2xlIGxpbmUgZXhjZXB0IHRoZSBmaWVsZCBuYW1lXG4gICAgICAgIC8vIGFzIGEgc2luZ2xlIGRhdGUsIHVzaW5nIHRoZSBwcmUtZGF0ZS1yYW5nZXMgcGFyc2luZyBtZWNoYW5pc20uXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGtlZXAgJ2R1ZSBpbiB0d28gd2Vla3MnIHdvcmtpbmcsIGFzICd0d28gd2Vla3MnIGlzIG5vdCBhY3R1YWxseSBhIHZhbGlkIGRhdGUgcmFuZ2VcbiAgICAgICAgLy8gaWYgdGhlIGZ1dHVyZURhdGVzIHZhbHVlIHBhc3NlZCBpbiB0byBjaHJvbm8ncyBwYXJzaW5nIGZ1bmN0aW9ucyBpcyBmYWxzZS5cbiAgICAgICAgaWYgKCFmaWVsZERhdGVzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IERhdGVQYXJzZXIucGFyc2VEYXRlKGtleXdvcmRBbmREYXRlU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChkYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkRGF0ZXMgPSBuZXcgRGF0ZVJhbmdlKGRhdGUsIGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaWVsZERhdGVzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnZG8gbm90IHVuZGVyc3RhbmQgJyArIHRoaXMuZmllbGROYW1lKCkgKyAnIGRhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbHRlckZ1bmN0aW9uID0gdGhpcy5idWlsZEZpbHRlckZ1bmN0aW9uKGZpZWxkS2V5d29yZCwgZmllbGREYXRlcyk7XG5cbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBEYXRlRmllbGQuYnVpbGRFeHBsYW5hdGlvbihcbiAgICAgICAgICAgIHRoaXMuZmllbGROYW1lRm9yRXhwbGFuYXRpb24oKSxcbiAgICAgICAgICAgIGZpZWxkS2V5d29yZCxcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSxcbiAgICAgICAgICAgIGZpZWxkRGF0ZXMsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRmlsdGVyKG5ldyBGaWx0ZXIobGluZSwgZmlsdGVyRnVuY3Rpb24sIGV4cGxhbmF0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGZ1bmN0aW9uIHRoYXQgYWN0dWFsbHkgZmlsdGVycyB0aGUgdGFza3MgZGVwZW5kaW5nIG9uIHRoZSBkYXRlXG4gICAgICogQHBhcmFtIGZpZWxkS2V5d29yZCByZWxhdGlvbnNoaXAgdG8gYmUgaGVsZCB3aXRoIHRoZSBkYXRlICdiZWZvcmUnLCAnYWZ0ZXInXG4gICAgICogQHBhcmFtIGZpZWxkRGF0ZXMgdGhlIGRhdGUgcmFuZ2UgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHRoYXQgZmlsdGVycyB0aGUgdGFza3NcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYnVpbGRGaWx0ZXJGdW5jdGlvbihmaWVsZEtleXdvcmQ6IHN0cmluZywgZmllbGREYXRlczogRGF0ZVJhbmdlKTogRmlsdGVyRnVuY3Rpb24ge1xuICAgICAgICBsZXQgZGF0ZUZpbHRlcjogRGF0ZUZpbHRlckZ1bmN0aW9uO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkS2V5d29yZCkge1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgICAgICBkYXRlRmlsdGVyID0gKGRhdGUpID0+IChkYXRlID8gZGF0ZS5pc0JlZm9yZShmaWVsZERhdGVzLnN0YXJ0KSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgICAgICAgZGF0ZUZpbHRlciA9IChkYXRlKSA9PiAoZGF0ZSA/IGRhdGUuaXNBZnRlcihmaWVsZERhdGVzLmVuZCkgOiB0aGlzLmZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb24gb3IgYmVmb3JlJzpcbiAgICAgICAgICAgIGNhc2UgJ2luIG9yIGJlZm9yZSc6XG4gICAgICAgICAgICAgICAgLy8gJ29uIG9yIGJlZm9yZScvJ2luIG9yIGJlZm9yZScgYSBkYXRlIHJhbmdlIHVzZXMgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgc2VhcmNoIGxpbWl0LCBzbyB0aGF0IGl0IG1hdGNoZXMgZXZlcnkgZGF0ZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbmNsdXNpdmUgZGF0ZSByYW5nZSwgYW5kIGFsbCBkYXRlcyBiZWZvcmUgdGhlIHJhbmdlLlxuICAgICAgICAgICAgICAgIGRhdGVGaWx0ZXIgPSAoZGF0ZSkgPT4gKGRhdGUgPyBkYXRlLmlzU2FtZU9yQmVmb3JlKGZpZWxkRGF0ZXMuZW5kKSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvbiBvciBhZnRlcic6XG4gICAgICAgICAgICBjYXNlICdpbiBvciBhZnRlcic6XG4gICAgICAgICAgICAgICAgLy8gJ29uIG9yIGFmdGVyJy8naW4gb3IgYWZ0ZXInIGEgZGF0ZSByYW5nZSB1c2VzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIHNlYXJjaCBsaW1pdCwgc28gdGhhdCBpdCBtYXRjaGVzIGV2ZXJ5IGRhdGUgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVzaXZlIGRhdGUgcmFuZ2UsIGFuZCBhbGwgZGF0ZXMgYWZ0ZXIgdGhlIHJhbmdlLlxuICAgICAgICAgICAgICAgIGRhdGVGaWx0ZXIgPSAoZGF0ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA/IGRhdGUuaXNTYW1lT3JBZnRlcihmaWVsZERhdGVzLnN0YXJ0KSA6IHRoaXMuZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGF0ZUZpbHRlciA9IChkYXRlKSA9PlxuICAgICAgICAgICAgICAgICAgICBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGUuaXNTYW1lT3JBZnRlcihmaWVsZERhdGVzLnN0YXJ0KSAmJiBkYXRlLmlzU2FtZU9yQmVmb3JlKGZpZWxkRGF0ZXMuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyKGRhdGVGaWx0ZXIpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRGaWx0ZXIoZGF0ZUZpbHRlckZ1bmN0aW9uOiBEYXRlRmlsdGVyRnVuY3Rpb24pOiBGaWx0ZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXJGdW5jdGlvbih0aGlzLmRhdGUodGFzaykpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBgXiR7dGhpcy5maWVsZE5hbWVGb3JGaWx0ZXJJbnN0cnVjdGlvbigpfSAoKCg/Om9ufGluKSBvciBiZWZvcmV8YmVmb3JlfCg/Om9ufGluKSBvciBhZnRlcnxhZnRlcnxvbnxpbik/ID8oLiopKWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHN1cHBvcnQgZm9yICdzdGFydHMgLi4uJyBhcyBmaWx0ZXIgd2hlcmUgdGhlIGZpZWxkIG5hbWUgaXMgZGlmZmVyZW50ICgnc3RhcnQnKS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZmllbGROYW1lRm9yRmlsdGVySW5zdHJ1Y3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrJ3MgdmFsdWUgZm9yIHRoaXMgZGF0ZSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEBwYXJhbSB0YXNrIC0gYSBUYXNrIG9iamVjdFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gRXhwbGFuYXRpb24gZm9yIGEgZGF0ZS1iYXNlZCBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lIC0gZm9yIGV4YW1wbGUsICdkdWUnXG4gICAgICogQHBhcmFtIGZpZWxkS2V5d29yZCAtIG9uZSBvZiB0aGUga2V5d29yZHMgbGlrZSAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gICAgICogQHBhcmFtIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nIC0gd2hldGhlciB0aGUgc2VhcmNoIG1hdGNoZXMgdGFza3Mgd2l0aG91dCB0aGUgcmVxdWVzdGVkIGRhdGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gZmlsdGVyRGF0ZXMgLSB0aGUgZGF0ZSByYW5nZSB1c2VkIGluIHRoZSBmaWx0ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJ1aWxkRXhwbGFuYXRpb24oXG4gICAgICAgIGZpZWxkTmFtZTogc3RyaW5nLFxuICAgICAgICBmaWVsZEtleXdvcmQ6IHN0cmluZyxcbiAgICAgICAgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3Npbmc6IGJvb2xlYW4sXG4gICAgICAgIGZpbHRlckRhdGVzOiBEYXRlUmFuZ2UsXG4gICAgKTogRXhwbGFuYXRpb24ge1xuICAgICAgICBsZXQgcmVsYXRpb25zaGlwID0gZmllbGRLZXl3b3JkO1xuICAgICAgICAvLyBFeGFtcGxlIG9mIGZvcm1hdHRlZCBkYXRlOiAnMjAyNC0wMS0wMiAoVHVlc2RheSAybmQgSmFudWFyeSAyMDI0KSdcbiAgICAgICAgY29uc3QgZGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREIChkZGRkIERvIE1NTU0gWVlZWSknO1xuICAgICAgICBsZXQgZXhwbGFuYXRpb25EYXRlcztcbiAgICAgICAgc3dpdGNoIChmaWVsZEtleXdvcmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICBjYXNlICdvbiBvciBhZnRlcic6XG4gICAgICAgICAgICAgICAgLy8gJ2JlZm9yZSA8ZGF0ZSByYW5nZT4nIGFuZCAnb24gb3IgYWZ0ZXIgPGRhdGUgcmFuZ2U+JyByZWZlcmVuY2UgdGhlIFN0YXJ0IG9mIHRoZSByYW5nZTpcbiAgICAgICAgICAgICAgICAvLyAgLSAnYmVmb3JlIHRoaXMgd2VlaycgaXMgYmVmb3JlIHRoZSBNb25kYXlcbiAgICAgICAgICAgICAgICAvLyAgLSAnb24gb3IgYWZ0ZXIgdGhpcyB3ZWVrJyBpcyBzdGFydGluZyBmcm9tIE1vbmRheSBpbmNsdXNpdmUuXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb25EYXRlcyA9IGZpbHRlckRhdGVzLnN0YXJ0LmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ29uIG9yIGJlZm9yZSc6XG4gICAgICAgICAgICAgICAgLy8gJ2FmdGVyIDxkYXRlIHJhbmdlPicgYW5kICdvbiBvciBiZWZvcmUgPGRhdGUgcmFuZ2U+JyByZWZlcmVuY2UgdGhlIEVuZCBvZiB0aGUgcmFuZ2U6XG4gICAgICAgICAgICAgICAgLy8gIC0gJ2FmdGVyIHRoaXMgbW9udGgnIGlzIGFmdGVyIHRoZSBsYXN0IGRheSBvZiB0aGlzIG1vbnRoXG4gICAgICAgICAgICAgICAgLy8gIC0gJ29uIG9yIGJlZm9yZSB0aGlzIG1vbnRoJyBpcyBiZWZvcmUgdGhlIGxhc3QgZGF5IG9mIHRoaXMgbW9udGggaW5jbHVzaXZlLlxuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uRGF0ZXMgPSBmaWx0ZXJEYXRlcy5lbmQuZm9ybWF0KGRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW4gb3IgYmVmb3JlJzpcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAgPSAnb24gb3IgYmVmb3JlJztcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbkRhdGVzID0gZmlsdGVyRGF0ZXMuZW5kLmZvcm1hdChkYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luIG9yIGFmdGVyJzpcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAgPSAnb24gb3IgYWZ0ZXInO1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uRGF0ZXMgPSBmaWx0ZXJEYXRlcy5zdGFydC5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyRGF0ZXMuc3RhcnQuaXNTYW1lKGZpbHRlckRhdGVzLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSBhIG11bHRpLWxpbmUgZXhwbGFuYXRpb24gaGFzIHRvIGJlIGJ1aWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBvdGhlciBjYXNlcyBuZWVkIG9ubHkgb25lIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gYCR7ZmllbGROYW1lfSBkYXRlIGlzIGJldHdlZW46YDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zZWN1dGl2ZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJFeHBsYW5hdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXhwbGFuYXRpb24oYCR7ZmlsdGVyRGF0ZXMuc3RhcnQuZm9ybWF0KGRhdGVGb3JtYXQpfSBhbmRgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFeHBsYW5hdGlvbihgJHtmaWx0ZXJEYXRlcy5lbmQuZm9ybWF0KGRhdGVGb3JtYXQpfSBpbmNsdXNpdmVgKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBsaW5lIGZvciBTdGFydERhdGVGaWVsZCAoc28gZmFyKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YkV4cGxhbmF0aW9ucy5wdXNoKG5ldyBFeHBsYW5hdGlvbihgT1Igbm8gJHtmaWVsZE5hbWV9IGRhdGVgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cGxhbmF0aW9uKGZpcnN0TGluZSwgc3ViRXhwbGFuYXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAgPSAnb24nO1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uRGF0ZXMgPSBmaWx0ZXJEYXRlcy5zdGFydC5mb3JtYXQoZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb25lTGluZUV4cGxhbmF0aW9uID0gYCR7ZmllbGROYW1lfSBkYXRlIGlzICR7cmVsYXRpb25zaGlwfSAke2V4cGxhbmF0aW9uRGF0ZXN9YDtcbiAgICAgICAgaWYgKGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKSB7XG4gICAgICAgICAgICBvbmVMaW5lRXhwbGFuYXRpb24gKz0gYCBPUiBubyAke2ZpZWxkTmFtZX0gZGF0ZWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBsYW5hdGlvbihvbmVMaW5lRXhwbGFuYXRpb24pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZE5hbWVGb3JFeHBsYW5hdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB0YXNrIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgcGFydGljdWxhciBkYXRlIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBtYXRjaC4gRm9yIGV4YW1wbGUsICdzdGFydHMnIHNlYXJjaGVzIG1hdGNoIGFsbCB0YXNrc1xuICAgICAqIHRoYXQgaGF2ZSBubyBzdGFydCBkYXRlLCB3aGljaCBiZWhhdmVzIGRpZmZlcmVudGx5IGZyb20gJ2R1ZScsICdkb25lJyBhbmRcbiAgICAgKiAnc2NoZWR1bGVkJyBzZWFyY2hlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCk6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJ5RGF0ZSh0aGlzLmRhdGUoYSksIHRoaXMuZGF0ZShiKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZSh0YXNrKTtcbiAgICAgICAgICAgIGlmIChkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTm8gJyArIHRoaXMuZmllbGROYW1lKCkgKyAnIGRhdGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQgZGRkZCcpXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2R1ZScgc2VhcmNoIGluc3RydWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRHVlRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZHVlJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5kdWVEYXRlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVzdWx0SWZGaWVsZE1pc3NpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUHJpb3JpdHksIFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB7IFByaW9yaXR5VG9vbHMgfSBmcm9tICcuLi8uLi9saWIvUHJpb3JpdHlUb29scyc7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcblxuZXhwb3J0IGNsYXNzIFByaW9yaXR5RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgLy8gVGhlIHRyaWNrIGluIHRoZSBmb2xsb3dpbmcgdG8gbWFuYWdlIHdoaXRlc3BhY2Ugd2l0aCBvcHRpb25hbCB2YWx1ZXNcbiAgICAvLyBpcyB0byBjYXB0dXJlIHRoZW0gaW4gTmVzdGVkIENhcHR1cmUgR3JvdXBzLCBsaWtlIHRoaXM6XG4gICAgLy8gIChsZWFkaW5nLXdoaXRlLXNwYWNlLWluLW91dGVyLWNhcHR1cmUtZ3JvdXAodmFsdWVzLXRvLXVzZS1hcmUtaW4taW5uZXItY2FwdHVyZS1ncm91cCkpXG4gICAgLy8gVGhlIGNhcHR1cmUgZ3JvdXBzIGFyZSBudW1iZXJlZCBpbiB0aGUgb3JkZXIgb2YgdGhlaXIgb3BlbmluZyBicmFja2V0cywgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHByaW9yaXR5UmVnZXhwID1cbiAgICAgICAgL15wcmlvcml0eShcXHMraXMpPyhcXHMrKGFib3ZlfGJlbG93fG5vdCkpPyhcXHMrKGxvd2VzdHxsb3d8bm9uZXxtZWRpdW18aGlnaHxoaWdoZXN0KSkkLztcblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlNYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAocHJpb3JpdHlNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyUHJpb3JpdHlTdHJpbmcgPSBwcmlvcml0eU1hdGNoWzVdO1xuICAgICAgICAgICAgbGV0IGZpbHRlclByaW9yaXR5OiBQcmlvcml0eSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpbHRlclByaW9yaXR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG93ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5Mb3dlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuTG93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyUHJpb3JpdHkgPSBQcmlvcml0eS5Ob25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJQcmlvcml0eSA9IFByaW9yaXR5Lk1lZGl1bTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlnaCc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuSGlnaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlnaGVzdCc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclByaW9yaXR5ID0gUHJpb3JpdHkuSGlnaGVzdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXJQcmlvcml0eSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgJ2RvIG5vdCB1bmRlcnN0YW5kIHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBleHBsYW5hdGlvbiA9IGxpbmU7XG4gICAgICAgICAgICBsZXQgZmlsdGVyO1xuICAgICAgICAgICAgc3dpdGNoIChwcmlvcml0eU1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSAodGFzazogVGFzaykgPT4gdGFzay5wcmlvcml0eS5sb2NhbGVDb21wYXJlKGZpbHRlclByaW9yaXR5ISkgPCAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB0YXNrLnByaW9yaXR5LmxvY2FsZUNvbXBhcmUoZmlsdGVyUHJpb3JpdHkhKSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vdCc6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9ICh0YXNrOiBUYXNrKSA9PiB0YXNrLnByaW9yaXR5ICE9PSBmaWx0ZXJQcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gKHRhc2s6IFRhc2spID0+IHRhc2sucHJpb3JpdHkgPT09IGZpbHRlclByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9IGAke3RoaXMuZmllbGROYW1lKCl9IGlzICR7ZmlsdGVyUHJpb3JpdHlTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21GaWx0ZXIobmV3IEZpbHRlcihsaW5lLCBmaWx0ZXIsIG5ldyBFeHBsYW5hdGlvbihleHBsYW5hdGlvbikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5IGZpbHRlciAocHJpb3JpdHkpJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAncHJpb3JpdHknO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIFByaW9yaXR5RmllbGQucHJpb3JpdHlSZWdleHA7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkubG9jYWxlQ29tcGFyZShiLnByaW9yaXR5KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eU5hbWUgPSBQcmlvcml0eVRvb2xzLnByaW9yaXR5TmFtZVVzaW5nTm9ybWFsKHRhc2sucHJpb3JpdHkpO1xuICAgICAgICAgICAgLy8gVGV4dCBpbnNpZGUgdGhlICUlLi4lJSBjb21tZW50cyBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIHNvcnQgb3JkZXIuXG4gICAgICAgICAgICAvLyBUaGUgY29tbWVudHMgYXJlIGhpZGRlbiBieSBPYnNpZGlhbiB3aGVuIHRoZSBoZWFkaW5ncyBhcmUgcmVuZGVyZWQuXG4gICAgICAgICAgICByZXR1cm4gW2AlJSR7dGFzay5wcmlvcml0eX0lJSR7cHJpb3JpdHlOYW1lfSBwcmlvcml0eWBdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYSBwYXJ0aWN1bGFyIGNvbmRpdGlvbi5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gaGlkZSBhd2F5IHRoZSBkZXRhaWxzIG9mIHZhcmlvdXMgdGV4dCBzZWFyY2hlcywgc3VjaCBhcyB0aGVcbiAqIHNpbXBsZSBpbmNsdXNpb24gb2YgYSBzdWItc3RyaW5nLCBvciB0aGUgbW9yZSBjb21wbGV4IHJlZ3VsYXIgZXhwcmVzc2lvbiBzZWFyY2hlcy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIElTdHJpbmdNYXRjaGVyIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIG1hdGNoZXMgdGhpcyBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZ1RvU2VhcmNoXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IG1hdGNoZXMoc3RyaW5nVG9TZWFyY2g6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gd2hldGhlciBhbnkgb2YgdGhlIGdpdmVuIHN0cmluZ3MgbWF0Y2hlcyB0aGlzIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RyaW5nc1RvU2VhcmNoXG4gICAgICovXG4gICAgcHVibGljIG1hdGNoZXNBbnlPZihzdHJpbmdzVG9TZWFyY2g6IHN0cmluZ1tdKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzVG9TZWFyY2guc29tZSgocykgPT4gdGhpcy5tYXRjaGVzKHMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4ge0BsaW5rIEV4cGxhbmF0aW9ufSBvYmplY3QsIHdpdGggYW55IGV4dHJhIGRldGFpbFxuICAgICAqIGFib3V0IHRoZSBiZWhhdmlvdXIgb2YgdGhpcyBtYXRjaGVyLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXh0cmEgZGV0YWlsLCBqdXN0IHBhc3Mge0BsaW5rIGluc3RydWN0aW9ufSBpbiB0b1xuICAgICAqIHRoZSB7QGxpbmsgRXhwbGFuYXRpb259IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBleHBsYW5hdGlvbihpbnN0cnVjdGlvbjogc3RyaW5nKTogRXhwbGFuYXRpb247XG59XG4iLCAiaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB7IElTdHJpbmdNYXRjaGVyIH0gZnJvbSAnLi9JU3RyaW5nTWF0Y2hlcic7XG5cbi8qKlxuICogU3Vic3RyaW5nLWJhc2VkIGltcGxlbWVudGF0aW9uIG9mIElTdHJpbmdNYXRjaGVyLlxuICpcbiAqIFRoaXMgZG9lcyBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICovXG5leHBvcnQgY2xhc3MgU3Vic3RyaW5nTWF0Y2hlciBleHRlbmRzIElTdHJpbmdNYXRjaGVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0cmluZ1RvRmluZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgU3Vic3RyaW5nTWF0Y2hlciBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdUb0ZpbmQgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlYXJjaGVzIHdpbGwgYmUgY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3Ioc3RyaW5nVG9GaW5kOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdUb0ZpbmQgPSBzdHJpbmdUb0ZpbmQ7XG4gICAgfVxuXG4gICAgcHVibGljIG1hdGNoZXMoc3RyaW5nVG9TZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gU3Vic3RyaW5nTWF0Y2hlci5zdHJpbmdJbmNsdWRlc0Nhc2VJbnNlbnNpdGl2ZShzdHJpbmdUb1NlYXJjaCwgdGhpcy5zdHJpbmdUb0ZpbmQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5nSW5jbHVkZXNDYXNlSW5zZW5zaXRpdmUoaGF5c3RhY2s6IHN0cmluZywgbmVlZGxlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5jbHVkZXMobmVlZGxlLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIGV4cGxhbmF0aW9uKGluc3RydWN0aW9uOiBzdHJpbmcpOiBFeHBsYW5hdGlvbiB7XG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBoYXZlIGFueSBzcGVjaWZpYyBleHBsYW5hdGlvbiBvZiBzdWJzdHJpbmctc2VhcmNoaW5nLFxuICAgICAgICAvLyBzbyBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgaW5zdHJ1Y3Rpb24gbGluZS5cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBsYW5hdGlvbihpbnN0cnVjdGlvbik7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4vSVN0cmluZ01hdGNoZXInO1xuXG4vKipcbiAqIFJlZ3VsYXItZXhwcmVzc2lvbi1iYXNlZCBpbXBsZW1lbnRhdGlvbiBvZiBJU3RyaW5nTWF0Y2hlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2V4TWF0Y2hlciBleHRlbmRzIElTdHJpbmdNYXRjaGVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVnZXg6IFJlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFJlZ2V4TWF0Y2hlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnZXgge1JlZ0V4cH0gLSBBIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihyZWdleDogUmVnRXhwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBSZWdleE1hdGNoZXIgb2JqZWN0IGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICogYW5kIG51bGwgaWYgbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2V4SW5wdXQgLSBBIHN0cmluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBtdXN0IGJlZ2luIHdpdGggYSAvLCBhbmQgZW5kIGVpdGhlciB3aXRoIC8gYW5kIG9wdGlvbmFsbHkgYW55XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBmbGFncy5cbiAgICAgKiBAdGhyb3dzIHtTeW50YXhFcnJvcn0gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgaW4ge0BsaW5rIHJlZ2V4SW5wdXR9LlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVBbmRDb25zdHJ1Y3QocmVnZXhJbnB1dDogc3RyaW5nKTogUmVnZXhNYXRjaGVyIHwgbnVsbCB7XG4gICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBoYXMgdHdvIHBhcnRzLlxuICAgICAgICAvLyAxLiBUaGUgcmVnZXggc291cmNlOiAgTWF0Y2ggZXZlcnkgY2hhcmFjdGVyIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHRvXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBqdXN0IGJlZm9yZSB0aGUgZmluYWwgZm9yd2FyZCBzbGFzaCAoJy8nKS5cbiAgICAgICAgLy8gMi4gVGhlIGZsYWdzLCBpZiBhbnk6IE1hdGNoIGV2ZXJ5IGNoYXJhY3RlciBhZnRlciB0aGUgbGFzdCBzbGFzaCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IC9eXFwvKC4rKVxcLyhbXi9dKikkLztcbiAgICAgICAgY29uc3QgcXVlcnkgPSByZWdleElucHV0Lm1hdGNoKHJlZ2V4UGF0dGVybik7XG5cbiAgICAgICAgaWYgKHF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKHF1ZXJ5WzFdLCBxdWVyeVsyXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ2V4TWF0Y2hlcihyZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbWF0Y2hlcyhzdHJpbmdUb1NlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb1NlYXJjaC5tYXRjaCh0aGlzLnJlZ2V4KSAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGhlbHBNZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBTdHJpbmcucmF3YFNlZSBodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvUXVlcmllcy9SZWd1bGFyK0V4cHJlc3Npb25zXG5cblJlZ3VsYXIgZXhwcmVzc2lvbnMgbXVzdCBsb29rIGxpa2UgdGhpczpcbiAgICAvcGF0dGVybi9cbm9yIHRoaXM6XG4gICAgL3BhdHRlcm4vZmxhZ3NcblxuV2hlcmU6XG4tIHBhdHRlcm46IFRoZSAncmVndWxhciBleHByZXNzaW9uJyBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4tIGZsYWdzOiAgIE9wdGlvbmFsIGNoYXJhY3RlcnMgdGhhdCBtb2RpZnkgdGhlIHNlYXJjaC5cbiAgICAgICAgICAgaSA9PiBtYWtlIHRoZSBzZWFyY2ggY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgICAgICB1ID0+IGFkZCBVbmljb2RlIHN1cHBvcnRcblxuRXhhbXBsZXM6ICAvXkxvZy9cbiAgICAgICAgICAgL15Mb2cvaVxuICAgICAgICAgICAvRmlsZSBOYW1lXFwubWQvXG4gICAgICAgICAgIC93YWl0aW5nfHdhaXRzfHdhaXRlZC9pXG4gICAgICAgICAgIC9cXGRcXGQ6XFxkXFxkL1xuXG5UaGUgZm9sbG93aW5nIGNoYXJhY3RlcnMgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gdGhlIHBhdHRlcm46XG50byBmaW5kIHRoZW0gbGl0ZXJhbGx5LCB5b3UgbXVzdCBhZGQgYSBcXCBiZWZvcmUgdGhlbTpcbiAgICBbXFxeJC58PyorKClcblxuQ0FVVElPTiEgUmVndWxhciBleHByZXNzaW9uIChvciAncmVnZXgnKSBzZWFyY2hpbmcgaXMgYSBwb3dlcmZ1bFxuYnV0IGFkdmFuY2VkIGZlYXR1cmUgdGhhdCByZXF1aXJlcyB0aG9yb3VnaCBrbm93bGVkZ2UgaW4gb3JkZXIgdG9cbnVzZSBzdWNjZXNzZnVsbHksIGFuZCBub3QgbWlzcyBpbnRlbmRlZCBzZWFyY2ggcmVzdWx0cy5cbmA7XG4gICAgfVxuXG4gICAgcHVibGljIGV4cGxhbmF0aW9uKGluc3RydWN0aW9uOiBzdHJpbmcpOiBFeHBsYW5hdGlvbiB7XG4gICAgICAgIGNvbnN0IGludHJvID0gJ3VzaW5nIHJlZ2V4OiAnO1xuICAgICAgICBjb25zdCBleHBsYW5hdGlvblRleHQgPSBhbGlnblJlZ2V4V2l0aE9yaWdpbmFsSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGludHJvLCB0aGlzLnJlZ2V4QXNTdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBuZXcgRXhwbGFuYXRpb24oZXhwbGFuYXRpb25UZXh0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlZ2V4QXNTdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBgJyR7dGhpcy5yZWdleC5zb3VyY2V9JyB3aXRoIGA7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnJlZ2V4LmZsYWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbm8gZmxhZ3MnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgZmxhZyAnJHt0aGlzLnJlZ2V4LmZsYWdzfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYGZsYWdzICcke3RoaXMucmVnZXguZmxhZ3N9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbGlnbiB0aGUgcmVnZXggd2UgYXJlIGFjdHVhbGx5IHVzaW5nIHdpdGggdGhlIHJlZ2V4IGluIHRoZSBvcmlnaW5hbCBxdWVyeS5cbiAqIEZvciBleGFtcGxlLCB0aGlzIGNyZWF0ZXMgdGhlIHNlY29uZCBsaW5lIGluIHRoaXMgaW5zdHJ1Y3Rpb24vZXhwbGFuYXRpb24gcGFpcjpcbiAqXG4gKiBgYGB0ZXh0XG4gKiBkZXNjcmlwdGlvbiByZWdleCBtYXRjaGVzIC93YWl0aW5nfHdhaXRzfHdhcnRldC8gPT5cbiAqICAgdXNpbmcgcmVnZXg6ICAgICAgICAgICAgJ3dhaXRpbmd8d2FpdHN8d2FydGV0JyB3aXRoIG5vIGZsYWdzXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25cbiAqIEBwYXJhbSBpbnRyb1xuICogQHBhcmFtIHJlZ2V4QXNTdHJpbmdcbiAqL1xuZnVuY3Rpb24gYWxpZ25SZWdleFdpdGhPcmlnaW5hbEluc3RydWN0aW9uKGluc3RydWN0aW9uOiBzdHJpbmcsIGludHJvOiBzdHJpbmcsIHJlZ2V4QXNTdHJpbmc6IHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoID0gaW5zdHJ1Y3Rpb24ubWF0Y2goL1xcLy8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuICdFcnJvciBleHBsYWluaW5nIGluc3RydWN0aW9uLiBDb3VsZCBub3QgZmluZCBhIHNsYXNoIGNoYXJhY3Rlcic7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4cGxhbmF0aW9uIHdpbGwgYmUgaW5kZW50ZWQgMiBjaGFyYWN0ZXJzIGZyb20gdGhlIHBhcmVudCBpbnN0cnVjdGlvbixcbiAgICAvLyBzbyBwYWQgdGhlIGV4cGxhbmF0aW9uIHNvIHRoYXQgdGhlIHN0YXJ0IG9mIHRoZSBleHBsYWluZWQgcmVnZXhcbiAgICAvLyBhbGlnbnMgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIHJlZ2V4IGluIHRoZSBvcmlnaW5hbCBpbnN0cnVjdGlvbi5cbiAgICAvLyBUaGlzIG1ha2VzIGFueSBkaWZmZXJlbmNlcyBpbiB0aGUgcmVnZXggbXVjaCBlYXNpZXIgdG8gc3BvdC5cbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9IDI7XG4gICAgY29uc3Qgc3RhcnRPZlJlZ2V4ID0gKG1hdGNoLmluZGV4ID8/IGluZGVudGF0aW9uKSAtIGluZGVudGF0aW9uO1xuICAgIGNvbnN0IHByZWZpeFBhZGRlZCA9IGludHJvLnBhZEVuZChzdGFydE9mUmVnZXgpO1xuICAgIHJldHVybiBgJHtwcmVmaXhQYWRkZWR9JHtyZWdleEFzU3RyaW5nfWA7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBTdWJzdHJpbmdNYXRjaGVyIH0gZnJvbSAnLi4vTWF0Y2hlcnMvU3Vic3RyaW5nTWF0Y2hlcic7XG5pbXBvcnQgeyBSZWdleE1hdGNoZXIgfSBmcm9tICcuLi9NYXRjaGVycy9SZWdleE1hdGNoZXInO1xuaW1wb3J0IHR5cGUgeyBJU3RyaW5nTWF0Y2hlciB9IGZyb20gJy4uL01hdGNoZXJzL0lTdHJpbmdNYXRjaGVyJztcbmltcG9ydCB0eXBlIHsgQ29tcGFyYXRvciB9IGZyb20gJy4uL1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlRm9yRXhjZXB0aW9uIH0gZnJvbSAnLi4vLi4vbGliL0V4Y2VwdGlvblRvb2xzJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcblxuLyoqXG4gKiBUZXh0RmllbGQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0byBoZWxwIGltcGxlbWVudFxuICogYWxsIHRoZSBmaWx0ZXIgaW5zdHJ1Y3Rpb25zIHRoYXQgYWN0IG9uIGEgc2luZ2xlIHR5cGUgb2Ygc3RyaW5nXG4gKiB2YWx1ZSwgc3VjaCBhcyB0aGUgZGVzY3JpcHRpb24gb3IgZmlsZSBwYXRoLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gRmllbGQuZ2V0TWF0Y2godGhpcy5maWx0ZXJSZWdFeHAoKSwgbGluZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgRmllbGQuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZSgpIGhhcyBiZWVuIGNoZWNrZWQsIHdlIHNob3VsZCBuZXZlciBnZXRcbiAgICAgICAgICAgIC8vIGluIHRvIHRoaXMgYmxvY2suXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gSVN0cmluZ01hdGNoZXIgZm9yIHRoaXMgZmlsdGVyLCBvciByZXR1cm5cbiAgICAgICAgLy8gaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cbiAgICAgICAgY29uc3QgW18sIGZpbHRlck9wZXJhdG9yLCBmaWx0ZXJWYWx1ZV0gPSBtYXRjaDtcbiAgICAgICAgbGV0IG1hdGNoZXI6IElTdHJpbmdNYXRjaGVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChmaWx0ZXJPcGVyYXRvci5pbmNsdWRlcygnaW5jbHVkZScpKSB7XG4gICAgICAgICAgICBtYXRjaGVyID0gbmV3IFN1YnN0cmluZ01hdGNoZXIoZmlsdGVyVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlck9wZXJhdG9yLmluY2x1ZGVzKCdyZWdleCcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBSZWdleE1hdGNoZXIudmFsaWRhdGVBbmRDb25zdHJ1Y3QoZmlsdGVyVmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VGb3JFeGNlcHRpb24oJ1BhcnNpbmcgcmVndWxhciBleHByZXNzaW9uJywgZSkgKyBgXFxuXFxuJHtSZWdleE1hdGNoZXIuaGVscE1lc3NhZ2UoKX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIGluc3RydWN0aW9uOiAnJHtsaW5lfSdcXG5cXG4ke1JlZ2V4TWF0Y2hlci5oZWxwTWVzc2FnZSgpfWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGxpa2VseSB0aGlzIGNhbiBub3cgbmV2ZXIgYmUgcmVhY2hlZC5cbiAgICAgICAgICAgIC8vIFJldGFpbmVkIGZvciBzYWZldHksIGZvciBub3cuXG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsIGBkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBmaWx0ZXIgKCR7dGhpcy5maWVsZE5hbWUoKX0pYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5LCB3ZSBjYW4gY3JlYXRlIHRoZSBGaWx0ZXIsIHRoYXQgdGFrZXMgYSB0YXNrXG4gICAgICAgIC8vIGFuZCB0ZXN0cyBpZiBpdCBtYXRjaGVzIHRoZSBzdHJpbmcgZmlsdGVyaW5nIHJ1bGVcbiAgICAgICAgLy8gcmVwcmVzZW50ZWQgYnkgdGhpcyBvYmplY3QuXG4gICAgICAgIGNvbnN0IG5lZ2F0ZSA9IGZpbHRlck9wZXJhdG9yLm1hdGNoKC9ub3QvKSAhPT0gbnVsbDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbmV3IEZpbHRlcihsaW5lLCB0aGlzLmdldEZpbHRlcihtYXRjaGVyLCBuZWdhdGUpLCBtYXRjaGVyLmV4cGxhbmF0aW9uKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21GaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVnZXhwIHBhdHRlcm4gbWF0Y2hpbmcgdGhlIGZpZWxkJ3MgbmFtZSBhbmQgcG9zc2libGUgYWxpYXNlc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaWVsZFBhdHRlcm4oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZ2V4cCBwYXR0ZXJuIG1hdGNoaW5nIGFsbCBwb3NzaWJsZSBmaWx0ZXIgb3BlcmF0b3JzIGZvciB0aGlzIGZpZWxkLFxuICAgICAqIHN1Y2ggYXMgXCJpbmNsdWRlc1wiIG9yIFwiZG9lcyBub3QgaW5jbHVkZVwiLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaWx0ZXJPcGVyYXRvclBhdHRlcm4oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdpbmNsdWRlc3xkb2VzIG5vdCBpbmNsdWRlfHJlZ2V4IG1hdGNoZXN8cmVnZXggZG9lcyBub3QgbWF0Y2gnO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPzoke3RoaXMuZmllbGRQYXR0ZXJuKCl9KSAoJHt0aGlzLmZpbHRlck9wZXJhdG9yUGF0dGVybigpfSkgKC4qKWApO1xuICAgIH1cblxuICAgIHB1YmxpYyBhYnN0cmFjdCBmaWVsZE5hbWUoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmllbGQncyB2YWx1ZSwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSB2YWx1ZSBpcyBudWxsXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmc7XG5cbiAgICBwcm90ZWN0ZWQgZ2V0RmlsdGVyKG1hdGNoZXI6IElTdHJpbmdNYXRjaGVyLCBuZWdhdGU6IGJvb2xlYW4pOiBGaWx0ZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyIS5tYXRjaGVzKHRoaXMudmFsdWUodGFzaykpO1xuICAgICAgICAgICAgcmV0dXJuIG5lZ2F0ZSA/ICFtYXRjaCA6IG1hdGNoO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBzb3J0aW5nLCBmb3IgdGV4dCBmaWVsZHMgd2hlcmUgc2ltcGxlIGxvY2FsZS1hd2FyZSBzb3J0aW5nIGlzIHRoZVxuICAgICAqIGRlc2lyZWQgYmVoYXZpb3VyLlxuICAgICAqXG4gICAgICogRWFjaCBjbGFzcyB0aGF0IHdhbnRzIHRvIHVzZSB0aGlzIHdpbGwgbmVlZCB0byBvdmVycmlkZSBzdXBwb3J0c1NvcnRpbmcoKSB0byByZXR1cm4gdHJ1ZSxcbiAgICAgKiB0byB0dXJuIG9uIHNvcnRpbmcuXG4gICAgICovXG4gICAgY29tcGFyYXRvcigpOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZShhKS5sb2NhbGVDb21wYXJlKHRoaXMudmFsdWUoYiksIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBncm91cGluZywgZm9yIHRleHQgZmllbGRzIHdoZXJlIHNpbXBsZSBncm91cGluZyBieSBmaWVsZCB2YWx1ZSBpcyB0aGVcbiAgICAgKiBkZXNpcmVkIGJlaGF2aW91ci5cbiAgICAgKlxuICAgICAqIEVhY2ggY2xhc3MgdGhhdCB3YW50cyB0byB1c2UgdGhpcyB3aWxsIG5lZWQgdG8gb3ZlcnJpZGUgc3VwcG9ydHNHcm91cGluZygpIHRvIHJldHVybiB0cnVlLFxuICAgICAqIHRvIHR1cm4gb24gZ3JvdXBpbmcuXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudmFsdWUodGFzayldO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93aWxzb25tYXIuZ2l0aHViLmlvL21hcmtkb3duLXRleHQtZm9yLWdpdGh1Yi1mcm9tLWh0bWwvI3NwZWNpYWwtY2hhcmFjdGVyc1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9fL2csICdcXFxcXycpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKiBTdXBwb3J0IHRoZSAncGF0aCcgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbHNvIHNlYXJjaGVzIHRoZSBmaWxlIGV4dGVuc2lvbixcbiAqIHNvICdwYXRoIGluY2x1ZGVzIC5tZCcgd2lsbCB0eXBpY2FsbHkgbWF0Y2ggYWxsIHRhc2tzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3BhdGgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgcGF0aCBpbmNsdWRpbmcgZmlsZSBleHRlbnNpb24sIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgcGF0aCBpcyBudWxsXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHVibGljIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5wYXRoO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIG1hZGUgc3RyaWN0ZXI/XG4gICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgb2YgZ2V0dGluZyB0aGUgZmlsZSBuYW1lP1xuICAgICAgICAgICAgcmV0dXJuIFtUZXh0RmllbGQuZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKHRhc2sucGF0aC5yZXBsYWNlKCcubWQnLCAnJykpXTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyLCBHcm91cGVyRnVuY3Rpb24gfSBmcm9tICcuLi9Hcm91cGVyJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuXG4vKipcbiAqIFN1cHBvcnQgJ3VyZ2VuY3knIHNvcnRpbmcuXG4gKlxuICogTm90ZTogU2VhcmNoaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBpbXBsZW1lbnRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVyZ2VuY3lGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKF9saW5lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCAnRmlsdGVyaW5nIGJ5IHVyZ2VuY3kgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICd1cmdlbmN5JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZmlsdGVyUmVnRXhwKCk6IFJlZ0V4cCB8IG51bGwge1xuICAgICAgICB0aHJvdyBFcnJvcihgZmlsdGVyUmVnRXhwKCkgdW5pbXBsZW1lbnRlZCBmb3IgJHt0aGlzLmZpZWxkTmFtZSgpfWApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU29ydGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIEhpZ2hlciB1cmdlbmN5IHNob3VsZCBiZSBzb3J0ZWQgZWFybGllci5cbiAgICAgICAgICAgIHJldHVybiBiLnVyZ2VuY3kgLSBhLnVyZ2VuY3k7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHcm91cGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgLy8gTm90ZTogR3JvdXBzIGFyZSBzb3J0ZWQgZnJvbSBsb3cgcHJpb3JpdHkgdG8gaGlnaC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGltcHJvdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIGJ5IGFsbG93aW5nXG4gICAgICAgIC8vIHRoZSBncm91cGluZyBjb2RlIHRvIHRha2UgYWR2YW50YWdlIG9mIHRoZSBjb21wYXJhdG9yKClcbiAgICAgICAgLy8gbWV0aG9kIGFib3ZlLlxuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbYCR7dGFzay51cmdlbmN5LnRvRml4ZWQoMil9YF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBGaWVsZC5jcmVhdGVHcm91cGVyfSBjcmVhdGVzIGEgZ3JvdXBlciB0aGF0IHNvcnRzIGJ5IGluY3JlYXNpbmcgdmFsdWVzLlxuICAgICAqIEZvciB7QGxpbmsgVXJnZW5jeUZpZWxkfSB0aGUgZ3JvdXAgc29ydGluZyBzaGFsbCBiZSBkb25lIGJ5IGRlY3JlYXNpbmcgdmFsdWVzLCBzb1xuICAgICAqIHRoZSBub3JtYWwgb3JkZXIgaGVyZSBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgcmVndWxhciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSAtIGZhbHNlIGZvciBub3JtYWwgZ3JvdXAgb3JkZXIgKGZyb20gbW9zdCB1cmdlbnQgdG8gbGVzcyB1cmdlbnQpLFxuICAgICAqIHRydWUgZm9yIHJldmVyc2UgZ3JvdXAgb3JkZXIuXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXIocmV2ZXJzZTogYm9vbGVhbik6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlR3JvdXBlcighcmV2ZXJzZSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBDb21wYXJhdG9yIH0gZnJvbSAnLi9Tb3J0ZXInO1xuaW1wb3J0IHR5cGUgeyBTb3J0ZXIgfSBmcm9tICcuL1NvcnRlcic7XG5pbXBvcnQgeyBTdGF0dXNGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1N0YXR1c0ZpZWxkJztcbmltcG9ydCB7IER1ZURhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0R1ZURhdGVGaWVsZCc7XG5pbXBvcnQgeyBQcmlvcml0eUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUHJpb3JpdHlGaWVsZCc7XG5pbXBvcnQgeyBQYXRoRmllbGQgfSBmcm9tICcuL0ZpbHRlci9QYXRoRmllbGQnO1xuaW1wb3J0IHsgVXJnZW5jeUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvVXJnZW5jeUZpZWxkJztcblxuZXhwb3J0IGNsYXNzIFNvcnQge1xuICAgIHB1YmxpYyBzdGF0aWMgYnkoc29ydGVyczogU29ydGVyW10sIHRhc2tzOiBUYXNrW10pIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbXBhcmF0b3JzOiBDb21wYXJhdG9yW10gPSBbXG4gICAgICAgICAgICBuZXcgVXJnZW5jeUZpZWxkKCkuY29tcGFyYXRvcigpLFxuICAgICAgICAgICAgbmV3IFN0YXR1c0ZpZWxkKCkuY29tcGFyYXRvcigpLFxuICAgICAgICAgICAgbmV3IER1ZURhdGVGaWVsZCgpLmNvbXBhcmF0b3IoKSxcbiAgICAgICAgICAgIG5ldyBQcmlvcml0eUZpZWxkKCkuY29tcGFyYXRvcigpLFxuICAgICAgICAgICAgbmV3IFBhdGhGaWVsZCgpLmNvbXBhcmF0b3IoKSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCB1c2VyQ29tcGFyYXRvcnM6IENvbXBhcmF0b3JbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc29ydGVyIG9mIHNvcnRlcnMpIHtcbiAgICAgICAgICAgIHVzZXJDb21wYXJhdG9ycy5wdXNoKHNvcnRlci5jb21wYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXNrcy5zb3J0KFNvcnQubWFrZUNvbXBvc2l0ZUNvbXBhcmF0b3IoWy4uLnVzZXJDb21wYXJhdG9ycywgLi4uZGVmYXVsdENvbXBhcmF0b3JzXSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG1ha2VDb21wb3NpdGVDb21wYXJhdG9yKGNvbXBhcmF0b3JzOiBDb21wYXJhdG9yW10pOiBDb21wYXJhdG9yIHtcbiAgICAgICAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBhcmF0b3Igb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJhdG9yKGEsIGIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBTdG9yZSB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIG9uZSBoZWFkaW5nIGZvciBhIGdyb3VwIG9mIHRhc2tzLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBEaXNwbGF5SGVhZGluZyB7XG4gICAgLyoqXG4gICAgICogSG93IG5lc3RlZCB0aGUgaGVhZGluZyBpcy5cbiAgICAgKlxuICAgICAqIDAgaXMgdGhlIGZpcnN0IGdyb3VwLCBtZWFuaW5nIHRoaXMgaGVhZGluZyB3YXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogdGhlIGZpcnN0ICdncm91cCBieScgaW5zdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiAtIExldmVsIDAgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYW4gSDQgaGVhZGluZyAtIGFzIHRob3VnaCBpdCB3ZXJlIHR5cGVkIGluIG1hcmtkb3duIGFzICcjIyMjJy5cbiAgICAgKiAtIExldmVsIDEgd2lsbCBiZSBhbiBINVxuICAgICAqIC0gTGV2ZWwgMiBhbmQgYWJvdmUgd2lsbCBhbGwgYmUgSDZcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmVzdGluZ0xldmVsOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBncm91cCdzIGhlYWRpbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtYXkgY29udGFpbiBtYXJrZG93biBjaGFyYWN0ZXJzIGFuZCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcGVydHksIG9yIGZpZWxkIG5hbWUsIGluIHRoZSAnZ3JvdXAgYnknIGxpbmUgdGhhdCBnZW5lcmF0ZWQgdGhpcyBoZWFkaW5nLlxuICAgICAqIEZvciBleGFtcGxlLCAnc3RhcnRzJywgJ3N0YXR1cy50eXBlJywgb3IgJ3ByaW9yaXR5Jy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBHcm91cERpc3BsYXlIZWFkaW5nfSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZ0xldmVsIC0gU2VlIHtAbGluayBuZXN0aW5nTGV2ZWx9IGZvciBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpc3BsYXlOYW1lIC0gVGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIGZvciB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgbmFtZSwgdXN1YWxseSBmaWVsZCBuYW1lLCBpbiB0aGUgJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnZHVlJyBvciAncHJpb3JpdHknLiBUaGlzIG1heSBiZSB1c2VmdWwgaW4gc3R5bGluZyB0aGUgZ3JvdXAgaGVhZGluZ3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmVzdGluZ0xldmVsOiBudW1iZXIsIGRpc3BsYXlOYW1lOiBzdHJpbmcsIHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBHcm91cERpc3BsYXlIZWFkaW5nIH0gZnJvbSAnLi9Hcm91cERpc3BsYXlIZWFkaW5nJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlciB9IGZyb20gJy4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlIH0gZnJvbSAnLi9UYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSc7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvZiBHcm91cC50c1xuICovXG5cbi8qKlxuICogRXhwbGFuYXRpb24gb2YgdGhlIGFsZ29yaXRobXMgdXNlZCBoZXJlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdGV4dCBpcyB0YWtlbiBmcm9tXG4gKiBodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY4NjA1MzcwODI2MTIyODU3Ny84NDAyODYyNjQ5NjQwMjIzMDIvOTU1MjQwODEyOTczODA5Njc0XG4gKlxuICogVGhlIFByb2JsZW1cbiAqID09PT09PT09PT09XG4gKlxuICogSW1hZ2luZSB0aGF0IHRoZSB1c2VyIGhhcyBzdXBwbGllZCAzICdncm91cCBieScgaW5zdHJ1Y3Rpb25zLCBhbmQgaW4gb3JkZXJcbiAqIHRvIHByZXNlbnQgdGhlIHJlc3VsdHMsIHdlIHNpbXBseSBjb25jYXRlbmF0ZSB0aGUgZ3JvdXAgbmFtZXMgdG9nZXRoZXJcbiAqIHdpdGggJz4nLlxuICpcbiAqIFNvIHRoZSBkaXNwbGF5IG1pZ2h0IGxvb2sgc29tZXRoaW5nIGxpa2U6XG4gKiAgICAgICMjIyMgMTAuMCA+IDIwMjItMDMtMjAgPiBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIDEwLjAgPiAyMDIyLTAzLTIyID4gU29tZSBoZWFkaW5nIG5hbWVcbiAqICAgICAgLSB0YXNrIDdcbiAqICAgICAgLSB0YXNrIDlcbiAqXG4gKiBUaGUgaGVhZGluZ3MgZ2V0IHZlcnkgaGFyZCB0byByZWFkLCB2ZXJ5IHF1aWNrbHkuXG4gKlxuICogV2hhdCB3ZSB3YW50IGluc3RlYWQgaXM6XG4gKiAgICAgICMjIyMgMTAuMFxuICogICAgICAjIyMjIyAyMDIyLTAzLTIwXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgMVxuICogICAgICAtIHRhc2sgMlxuICogICAgICAjIyMjIyAyMDIyLTAzLTIyXG4gKiAgICAgICMjIyMjIyBTb21lIGhlYWRpbmcgbmFtZVxuICogICAgICAtIHRhc2sgN1xuICogICAgICAtIHRhc2sgOVxuICpcbiAqIEknbSBzdHJ1Z2dsaW5nIHRvIGdldCBteSBoZWFkIGFyb3VuZCBob3csIGluIFRTLCBJIGNhbiBzdG9yZSBzb21ldGhpbmcgbGlrZSBhIHRyZWUgc3RydWN0dXJlLFxuICogb2YgYXJiaXRyYXJ5IGRlcHRoIC0gdG8gcmVwcmVzZW50IHRoZSBncm91cGVkIHRhc2tzLlxuICpcbiAqIHBqZWJ5J3MgYW5zd2VyXG4gKiA9PT09PT09PT09PT09PVxuICpcbiAqIFVzZXIgcGplYnkgcmVwbGllZDpcbiAqIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvNjg2MDUzNzA4MjYxMjI4NTc3Lzg0MDI4NjI2NDk2NDAyMjMwMi85NTU1Nzk1NjAwMzQ5ODM5NDZcbiAqXG4gKiBJZiBhbGwgeW91J3JlIGRvaW5nIGlzIGdlbmVyYXRpbmcgaGVhZGluZ3MsIHRoZSBzaW1wbGUgYWxnb3JpdGhtIHdvdWxkIGJlIHRvIHNvcnQgZXZlcnl0aGluZyBieSBhIG11bHRpLXZhbHVlIGtleSAtXG4gKiBpLmUuLCBbbGV2ZWwgMSwgbGV2ZWwgMiwgLi4uLCBpdGVtIHNvcnQga2V5XSAtLSB0aGVuIGl0ZXJhdGUgdGhlIHdob2xlIGxpc3QgYW5kIG91dHB1dCBhIGhlYWRpbmcgZm9yIGVhY2ggbGV2ZWxcbiAqIHdoZXJlIHRoZSB2YWx1ZSBjaGFuZ2VkLlxuICpcbiAqIGkuZS4sIHlvdSBzdGFydCB3aXRoIGEgW251bGwsIG51bGwsIG51bGwsIG51bGwuLi4uXSBcImxhc3Qgc2VlblwiIGFycmF5IGFuZCBjb21wYXJlIGl0IGl0ZW0gYnkgaXRlbSB0byB0aGUgY3VycmVudFxuICogaXRlbSdzIGRhdGEsIGFuZCBvdXRwdXQgYSBoZWFkaW5nIG9mIHRoZSBjb3JyZWN0IGxldmVsIGlmIHRoZXJlJ3MgYSBjaGFuZ2UsIHVwZGF0aW5nIHRoZSBpdGVtIGluIHlvdXJcbiAqIFwibGFzdCBzZWVuXCIgYXJyYXkuXG4gKlxuICogaS5lLiBpZiB0aGUgZmlyc3QgaXRlbSBpcyBkaWZmZXJlbnQsIG91dHB1dCBhbiBIMSBmb3IgdGhlIG5ldyB2YWx1ZSBhbmQgc2V0IHRoZSByZXN0IG9mIHRoZSBhcnJheSB0byBudWxsLlxuICogSWYgdGhlIHNlY29uZCBpdGVtIGlzIGFsc28gZGlmZmVyZW50LCBvdXRwdXQgYW4gSDIsIHNhdmUgdGhlIHZhbHVlLCBzZXQgdGhlIHJlc3QgdG8gbnVsbCwgYW5kIHNvIG9uLlxuICogQWZ0ZXIgYWxsIHRoZSBsZXZlbHMgYXJlIGNoZWNrZWQsIG91dHB1dCB0aGUgYWN0dWFsIGl0ZW0uXG4gKiBJZiB0aGVyZSBhcmUgbm8gY2hhbmdlcywgdGhlbiBiYXNpY2FsbHkgeW91J2xsIGp1c3QgYmUgb3V0cHV0dGluZyB0aGUgaXRlbS5cbiAqIE5vIHRyZWVzIG9yIGdyYXBocyBvciB3aGF0bm90IG5lZWRlZC5cbiAqXG4gKiBZb3UgY291bGQgYWxzbyBqdXN0IGtlZXAgdGhlIGxhc3QgaXRlbSBhbmQgc2V0IGEgZmxhZyBhcyBzb29uIGFzIHNvbWV0aGluZyBkb2Vzbid0IG1hdGNoLCBhbmQga2VlcCBvdXRwdXR0aW5nXG4gKiBoZWFkaW5ncyBhcyBzb29uIGFzIHRoZSBmbGFnIGlzIHNldC5cbiAqXG4gKiBXaGF0IHRoZSBjb2RlIGRvZXNcbiAqID09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoZSBUYXNrR3JvdXBpbmdUcmVlIGNsYXNzIGJlbG93IGRvZXMgdGhlIGluaXRpYWwgZ3JvdXBpbmcgYW5kIHNvcnRpbmcuXG4gKlxuICogVGhlIEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3RvciBjbGFzcyBiZWxvdyBpbXBsZW1lbnRzIHBqZWJ5J3MgaGVhZGluZyBkZXRlY3Rpb24gYWxnb3JpdGhtLCBidXQgaW5zdGVhZCBvZiBkb2luZyB0aGUgcHJpbnRpbmcgZGlyZWN0bHksXG4gKiBpdCByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlYWRpbmcgbGV2ZWxzIGluIGFuIGFycmF5IG9mIEdyb3VwRGlzcGxheUhlYWRpbmcgb2JqZWN0cywgZm9yIGxhdGVyIHVzZSBpbiBRdWVyeVJlbmRlcmVyLnRzLlxuICovXG5cbi8qKlxuICogR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yIGNhbGN1bGF0ZXMgd2hpY2ggaGVhZGluZ3MgbmVlZCB0byBiZSBkaXNwbGF5ZWQsIGZvclxuICogYSBnaXZlbiBncm91cCBvZiB0YXNrcy5cbiAqXG4gKiBJdCBzZWxlY3RzIHdoaWNoIHtAbGluayBHcm91cERpc3BsYXlIZWFkaW5nfSBvYmplY3RzIHRvIGNyZWF0ZS5cbiAqXG4gKiBTZWUgdGhlIGV4cGxhbmF0aW9uIGluIEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3Rvci50cyBmb3IgaG93IGl0IHdvcmtzLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yIHtcbiAgICBwcml2YXRlIGxhc3RIZWFkaW5nQXRMZXZlbCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgcHJpdmF0ZSBncm91cGVyczogR3JvdXBlcltdO1xuXG4gICAgY29uc3RydWN0b3IodGFza0dyb3VwaW5nVHJlZVN0b3JhZ2U6IFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlLCBncm91cGVyczogR3JvdXBlcltdKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBlcnMgPSBncm91cGVycztcbiAgICAgICAgY29uc3QgZmlyc3RHcm91cCA9IHRhc2tHcm91cGluZ1RyZWVTdG9yYWdlLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IGdyb3VwQ291bnQgPSBmaXJzdEdyb3VwLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNldCBvZiBoZWFkaW5ncyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAgKiBiZWZvcmUgdGhlIHRhc2tzIHdpdGggdGhlIGdpdmVuIGdyb3VwIG5hbWVzLlxuICAgICAqXG4gICAgICogRGF0YSBmb3IgZWFjaCByZXF1aXJlZCBoZWFkaW5nIGlzIHN0b3JlZCBpbiBhIEdyb3VwRGlzcGxheUhlYWRpbmcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBncm91cE5hbWVzIDAgb3IgbW9yZSBncm91cCBuYW1lcywgb25lIHBlciAnZ3JvdXAgYnknIGxpbmVcbiAgICAgKi9cbiAgICBnZXRIZWFkaW5nc0ZvclRhc2tHcm91cChncm91cE5hbWVzOiBzdHJpbmdbXSk6IEdyb3VwRGlzcGxheUhlYWRpbmdbXSB7XG4gICAgICAgIC8vIFNlZSAncGplYnkncyBhbnN3ZXInIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgaGVhZGluZ3NGb3JHcm91cCA9IG5ldyBBcnJheTxHcm91cERpc3BsYXlIZWFkaW5nPigpO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZ3JvdXBOYW1lcy5sZW5ndGg7IGxldmVsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBOYW1lc1tsZXZlbF07XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gdGhpcy5sYXN0SGVhZGluZ0F0TGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZ3NGb3JHcm91cC5wdXNoKG5ldyBHcm91cERpc3BsYXlIZWFkaW5nKGxldmVsLCBncm91cCwgdGhpcy5ncm91cGVyc1tsZXZlbF0ucHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgdGhlIGxvd2VyIGhlYWRpbmcgbGV2ZWxzIHRvIHVuLXNlZW5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbGV2ZWw7IGogPCBncm91cE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEhlYWRpbmdBdExldmVsW2xldmVsXSA9IGdyb3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkaW5nc0Zvckdyb3VwO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEEgbm9kZSBpbiB0aGUgZ3JvdXBpbmcgdHJlZS4gVGhlIG5vZGUgY29udGFpbnMgdGhlXG4gKiBsaXN0IG9mIHZhbHVlcyBtYXRjaGluZyB0aGUgcGF0aCBmcm9tIHRoZSByb290IHNvIGZhciwgYW5kIGl0cyBjaGlsZHJlblxuICogYXJlIHRoZSBmdXJ0aGVyIGdyb3VwaW5nIG9mIHRob3NlIHZhbHVlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cGluZ1RyZWVOb2RlPFQ+IHtcbiAgICBjaGlsZHJlbjogTWFwPHN0cmluZywgR3JvdXBpbmdUcmVlTm9kZTxUPj4gPSBuZXcgTWFwKCk7XG4gICAgdmFsdWVzOiBUW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBHcm91cGluZ1RyZWVOb2RlIGlzIGNyZWF0ZWQsIHRoZSBjYWxsZXIgbXVzdCBwb3B1bGF0ZSB0aGUgdHJlZSBieSBhZGRpbmcgdmFsdWVzIHRvIHtAbGluayBjaGlsZHJlbn0uXG4gICAgICogU2VlIEdyb3VwaW5nVHJlZU5vZGUudGVzdC50cyBmb3IgYW4gZXhwbGFuYXRpb24gb2YgdGhlIGNvbnRlbnRzIG9mIHtAbGluayBjaGlsZHJlbn0uXG4gICAgICogQHBhcmFtIHZhbHVlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlczogVFtdKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSB0cmVlIHRvIGdlbmVyYXRlIGFsbCB0aGUgcGF0aHMgdG8gdGhlIGxlYXZlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBtYXAgZnJvbSBldmVyeSBsZWFmIHBhdGgsIHRvIHRoZSBsaXN0IG9mIHZhbHVlc1xuICAgICAqIG1hdGNoaW5nIHRoaXMgcGF0aC5cbiAgICAgKiBOT1RFOiBUaGUgbm9kZSBpdHNlbGYgZG9lc24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBwYXRocy5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFsbFBhdGhzKHBhdGhTb0Zhcjogc3RyaW5nW10gPSBbXSk6IE1hcDxzdHJpbmdbXSwgVFtdPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IExlYWYgbm9kZS4gUG9wdWxhdGUgdGhlIHJlc3VsdHMgbWFwIHdpdGggdGhlIHBhdGggdG9cbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSwgYW5kIHRoZSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGlzIHBhdGguXG4gICAgICAgICAgICByZXN1bHRNYXAuc2V0KFsuLi5wYXRoU29GYXJdLCB0aGlzLnZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwYXRoU29GYXIucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFJlc3VsdCA9IGNoaWxkLmdlbmVyYXRlQWxsUGF0aHMocGF0aFNvRmFyKTtcbiAgICAgICAgICAgIGNoaWxkUmVzdWx0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHJlc3VsdE1hcC5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgcGF0aFNvRmFyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNYXA7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyIH0gZnJvbSAnLi9Hcm91cGVyJztcbmltcG9ydCB7IEdyb3VwaW5nVHJlZU5vZGUgfSBmcm9tICcuL0dyb3VwaW5nVHJlZU5vZGUnO1xuaW1wb3J0IHR5cGUgeyBUYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSB9IGZyb20gJy4vVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UnO1xuXG4vKlxuICogQSB0cmVlIG9mIHRhc2tzIHdoZXJlIGV2ZXJ5IGxldmVsIGluIHRoZSB0cmVlIGNvcnJlc3BvbmRzIHRvIGEgZ3JvdXBpbmcgcHJvcGVydHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmU6XG4gKiAjIEhlYWRpbmcgMVxuICogLSBbIF0gVGFzayAxXG4gKiAjIEhlYWRpbmcgMlxuICogLSBbIF0gVGFzayAyXG4gKiAtIFtYXSBUYXNrIDNcbiAqXG4gKiBBbmQgd2UgZ3JvdXAgYnkgaGVhZGluZyB0aGVuIHN0YXR1cywgdGhlIHRyZWUgd2lsbCBsb29rIGxpa2U6XG4gKlxuICogICAgICAgICAgICAgICAgICAgUm9vdCBbVDEsIFQyLCBUM11cbiAqICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgXFxcbiAqICAgICAgICAgICAgICBIZWFkaW5nIDEgW1QxXSAgICAgSGVhZGluZyBbVDIsIFQzXVxuICogICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgIC8gICAgICAgIFxcXG4gKiAgICAgICAgICAgICAgIFRPRE8gW1QxXSAgICAgVE9ETyBbVDJdICAgIERvbmUgW1QzXVxuICpcbiAqIFRoZSBuaWNlIHByb3BlcnR5IG9mIHRoaXMgdHJlZSBpcyB0aGF0IGV2ZXJ5IHBhdGggZnJvbSB0aGUgcm9vdCB0byBhIGxlYWYsIG1hcHNcbiAqIHRvIGhvdyB0aGUgdGFza3Mgd2lsbCBiZSByZW5kZXJlZC5cbiAqXG4gKiBOT1RFOiBUaGUgc2FtZSB0YXNrIGNhbiBhcHBlYXIgaW4gbXVsdGlwbGUgbGVhZiBub2RlcywgaWYgaXQgbWF0Y2hlcyBtdWx0aXBsZSBwYXRocy5cbiAqL1xuY2xhc3MgVGFza0dyb3VwaW5nVHJlZU5vZGUgZXh0ZW5kcyBHcm91cGluZ1RyZWVOb2RlPFRhc2s+IHt9XG5cbi8qKlxuICogVGFza0dyb3VwaW5nVHJlZSBkb2VzIHRoZSBpbml0aWFsIGdyb3VwaW5nIHRvZ2V0aGVyIG9mIHRhc2tzLFxuICogaW4gYXJiaXRyYXJ5IG9yZGVyLiBDYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHNvcnRpbmcgZ3JvdXBzIGluIHRvIGRlc2lyZWQgb3JkZXIuXG4gKlxuICogSXQgaXMgZXNzZW50aWFsbHkgYSB0aGluIHdyYXBwZXIgYXJvdW5kIE1hcCAtIHNlZSB7QGxpbmsgVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2V9LlxuICpcbiAqIEl0IGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiB0aGUgdGFzay1ncm91cGluZyBjb2RlLCBhbmQgZG9lcyBub3QgbmVlZCB0b1xuICogYmUgdW5kZXJzdG9vZCBpbiBvcmRlciB0byBncm91cCB0YXNrcy5cbiAqXG4gKiBJZGVhbGx5LCB0aGlzIGNvZGUgd291bGQgYmUgc2ltcGxpZmllZCBhbmQgbW92ZWQgaW4gdG8gVGFza0dyb3Vwcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tHcm91cGluZ1RyZWUge1xuICAgIHByaXZhdGUgcm9vdDogVGFza0dyb3VwaW5nVHJlZU5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBHcm91cCBhIGxpc3Qgb2YgdGFza3MsIGFjY29yZGluZyB0byBvbmUgb3IgbW9yZSB0YXNrIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGdyb3VwZXJzIDAgb3IgbW9yZSBHcm91cGluZyB2YWx1ZXMsIG9uZSBwZXIgJ2dyb3VwIGJ5JyBsaW5lXG4gICAgICogQHBhcmFtIHRhc2tzIFRoZSB0YXNrcyB0aGF0IG1hdGNoIHRoZSB0YXNrIGJsb2NrJ3MgUXVlcnlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihncm91cGVyczogR3JvdXBlcltdLCB0YXNrczogVGFza1tdKSB7XG4gICAgICAgIC8vIFRoZSByb290IG9mIHRoZSB0cmVlIGNvbnRhaW5zIGFsbCB0aGUgdGFza3MuXG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlTm9kZSh0YXNrcyk7XG5cbiAgICAgICAgdGhpcy5idWlsZEdyb3VwaW5nVHJlZShncm91cGVycyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBidWlsZEdyb3VwaW5nVHJlZShncm91cGVyczogR3JvdXBlcltdKSB7XG4gICAgICAgIC8vIFRoZSB0cmVlIGlzIGJ1aWxkIGxheWVyIGJ5IGxheWVyLCBzdGFydGluZyBmcm9tIHRoZSByb290LlxuICAgICAgICAvLyBBdCBldmVyeSBsZXZlbCwgd2UgaXRlcmF0ZSBvbiB0aGUgbm9kZXMgb2YgdGhhdCBsZXZlbCB0byBnZW5lcmF0ZVxuICAgICAgICAvLyB0aGUgbmV4dCBvbmUgdXNpbmcgdGhlIG5leHQgZ3JvdXBpbmcuXG5cbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlTGV2ZWwgPSBbdGhpcy5yb290XTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cGVyIG9mIGdyb3VwZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJlZUxldmVsID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRUcmVlTm9kZSBvZiBjdXJyZW50VHJlZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIGN1cnJlbnRUcmVlTm9kZS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHByb3BlcnRpZXMgb2YgYSB0YXNrIGZvciB0aGUgZ3JvdXBlclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmV0dXJuZWQgc3RyaW5nIGlzIHJlbmRlcmVkLCBzbyBzcGVjaWFsIE1hcmtkb3duIGNoYXJhY3RlcnMgd2lsbCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZXMgPSBncm91cGVyLmdyb3VwZXIodGFzayk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmYWtlIGVtcHR5IGdyb3VwLW5hbWUgc28gdGhhdCB3ZSBjYW4gYWRkIHRoZXNlIHRhc2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgdHJlZS4gVGhpcyBncm91cCB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIG5vIGhlYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMsIHRoZXkgd291bGQgYmUgbG9zdCBhbmQgbm90IGRpc3BsYXllZCBhdCBhbGwgdGhlIHF1ZXJ5IHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cE5hbWVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBncm91cE5hbWUgb2YgZ3JvdXBOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLmdldChncm91cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlTm9kZShbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWVOb2RlLmNoaWxkcmVuLnNldChncm91cE5hbWUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VHJlZUxldmVsLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudmFsdWVzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VHJlZUxldmVsID0gbmV4dFRyZWVMZXZlbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBHZW5lcmF0ZXMgYW4gaW50ZXJtZWRpYXRlIHN0b3JhZ2UgZm9yIHRoZSBpbml0aWFsIGdyb3VwaW5nIHRvZ2V0aGVyIG9mIHRhc2tzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBtYXAgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgZ3JvdXBzXG4gICAgICogYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSB0YXNrcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2VuZXJhdGVUYXNrVHJlZVN0b3JhZ2UoKTogVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdlbmVyYXRlQWxsUGF0aHMoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwRGlzcGxheUhlYWRpbmcgfSBmcm9tICcuL0dyb3VwRGlzcGxheUhlYWRpbmcnO1xuXG4vKipcbiAqIFN0b3JlIGEgc2luZ2xlIGdyb3VwIG9mIHRhc2tzLCB0aGF0IGFsbCBzaGFyZSB0aGUgc2FtZSBncm91cCBuYW1lcy5cbiAqIHtAbGluayBUYXNrR3JvdXB9IG9iamVjdHMgYXJlIHN0b3JlZCBpbiBhIHtAbGluayBUYXNrR3JvdXBzfSBvYmplY3QuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSB1c2VyIHN1cHBsaWVkIHRoZXNlICdncm91cCBieScgbGluZXM6XG4gKiAgIGdyb3VwIGJ5IGZvbGRlclxuICogICBncm91cCBieSBmaWxlbmFtZVxuICogICBncm91cCBieSBoZWFkaW5nXG4gKiBUaGVuIHRoZSBuYW1lcyBvZiBvbmUge0BsaW5rIFRhc2tHcm91cH0gbWlnaHQgYmUgdGhpczpcbiAqICAgU29tZS9Gb2xkZXIvSW4vVGhlL1ZhdWx0XG4gKiAgIEEgUGFydGljdWxhciBGaWxlIE5hbWVcbiAqICAgTXkgbG92ZWx5IGhlYWRpbmdcbiAqIEFuZCB0aGUge0BsaW5rIFRhc2tHcm91cH0gd291bGQgc3RvcmUgYWxsIHRoZSB0YXNrcyBmcm9tIHRoYXQgbG9jYXRpb25cbiAqIHRoYXQgbWF0Y2ggdGhlIHRhc2sgYmxvY2sncyBmaWx0ZXJzLCBpbiB0aGUgdGFzayBibG9jaydzIHNvcnQgb3JkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tHcm91cCB7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgbGlzdCBvZiBuYW1lcyBvZiB0aGUgZ3JvdXAgcHJvcGVydGllcyBmb3IgdGhpcyBzZXQgb2YgdGFza3MsXG4gICAgICogaW4gdGhlIG9yZGVyIG9mIHRoZSAnZ3JvdXAgYnknIGxpbmVzIHRoZSB1c2VyIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIHdlcmUgbm8gJ2dyb3VwIGJ5JyBpbnN0cnVjdGlvbnMgaW4gdGhlIHRhc2tzIGNvZGUgYmxvY2ssXG4gICAgICogdGhpcyB3aWxsIGJlIGVtcHR5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBzdHJpbmdzIHJldHVybmVkIGNvbnRhaW4gbWFya2Rvd24gZm9yIHJlbmRlcmluZyxcbiAgICAgKiBpZiByZXF1aXJlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZ3JvdXBzOiBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWFkaW5ncyB0byBiZSBkaXNwbGF5ZWQgaW4gZnJvbnQgb2YgdGhpcyBzZXQgb2YgdGFza3MsXG4gICAgICogd2hlbiByZW5kZXJpbmcgdGhlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBJdCBvbmx5IGNvbnRhaW5zIHRoZSBtaW5pbWFsIHNldCBvZiBoZWFkaW5ncyByZXF1aXJlZCB0byBzZXBhcmF0ZVxuICAgICAqIHRoaXMgZ3JvdXAgb2YgdGFza3MgZnJvbSB0aGUgcHJldmlvdXMgZ3JvdXAgb2YgdGFza3MuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGdyb3VwIG9mIHRhc2tzIGhhcyB0aGUgc2FtZSBmaXJzdC1sZXZlbCBoZWFkaW5nIGFzIHRoZSBwcmV2aW91c1xuICAgICAqIGdyb3VwIG9mIHRhc2tzLCB0aGVyZSBpcyBubyBuZWVkIHRvIGRpc3BsYXkgdGhhdCBmaXJzdC1sZXZlbCBoZWFkaW5nXG4gICAgICogdG8gc2VwYXJhdGUgdGhlc2UgdGFza3MgZnJvbSB0aGUgcHJldmlvdXMgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSB3ZXJlIG5vICdncm91cCBieScgaW5zdHJ1Y3Rpb25zIGluIHRoZSB0YXNrcyBjb2RlIGJsb2NrLFxuICAgICAqIHRoaXMgd2lsbCBiZSBlbXB0eS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZ3JvdXBIZWFkaW5nczogR3JvdXBEaXNwbGF5SGVhZGluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSB0YXNrcyB0aGF0IG1hdGNoIHRoZSB1c2VyJ3MgZmlsdGVycyBhbmQgdGhhdCBoYXZlIHRoZVxuICAgICAqIGdyb3VwIG5hbWVzIGV4YWN0bHkgbWF0Y2hpbmcgZ3JvdXBzKCkuXG4gICAgICovXG4gICAgcHVibGljIHRhc2tzOiBUYXNrW107XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGdyb3VwcyAtIFNlZSB7QGxpbmsgZ3JvdXBzfSBmb3IgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB0YXNrcyB7VGFza1tdfSAtIFNlZSB7QGxpbmsgdGFza3N9IGZvciBkZXRhaWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3JvdXBzOiBzdHJpbmdbXSwgdGFza3M6IFRhc2tbXSkge1xuICAgICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcbiAgICAgICAgdGhpcy5ncm91cEhlYWRpbmdzID0gW107XG4gICAgICAgIHRoaXMudGFza3MgPSB0YXNrcztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0R3JvdXBIZWFkaW5ncyhoZWFkaW5nc0ZvclRhc2tHcm91cDogR3JvdXBEaXNwbGF5SGVhZGluZ1tdKSB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXBEaXNwbGF5SGVhZGluZyBvZiBoZWFkaW5nc0ZvclRhc2tHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRpbmdzLnB1c2goZ3JvdXBEaXNwbGF5SGVhZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW1pdHMge0BsaW5rIHRhc2tzfSBhcnJheSB0byBhIGNlcnRhaW4gbnVtYmVyLiBUYXNrcyBleGNlZWRpbmdcbiAgICAgKiB0aGUgbGltaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVuZCwgc2hhbGwgYmUgY2FsbGVkIG9uIHNvcnRlZCB0YXNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2YgdGFza3MgZm9yIHRoZSBncm91cCB0byBoYXZlLiBJZiBncmVhdGVyXG4gICAgICogdGhhbiB0aGUgdGFzayBjb3VudCwgbm8gYWN0aW9uIHdpbGwgYmUgdGFrZW4uXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgYXBwbHlUYXNrTGltaXQobGltaXQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLnRhc2tzID0gdGhpcy50YXNrcy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtYXJrZG93bi1mb3JtYXQgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSB0YXNrcyBpbiB0aGlzIGdyb3VwLlxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyB0YXNrc0FzU3RyaW5nT2ZMaW5lcygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0aGlzLnRhc2tzKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gdGFzay50b0ZpbGVMaW5lU3RyaW5nKCkgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0YXNrIGdyb3VwLCBpbmNsdWRpbmcgbmFtZXNcbiAgICAgKiBhbmQgaGVhZGluZ3MgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXMgdXNlZCBpbiBzbmFwc2hvdCB0ZXN0aW5nLCBzbyBpZiB0aGUgZm9ybWF0IGlzXG4gICAgICogY2hhbmdlZCwgdGhlIHNuYXBzaG90cyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICdcXG4nO1xuICAgICAgICBvdXRwdXQgKz0gYEdyb3VwIG5hbWVzOiBbJHt0aGlzLmdyb3Vwc31dXFxuYDtcblxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRpbmcgb2YgdGhpcy5ncm91cEhlYWRpbmdzKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBoZWFkaW5ncyBtaW1pYyB0aGUgYmVoYXZpb3VyIG9mIFF1ZXJ5UmVuZGVyZXIsXG4gICAgICAgICAgICAvLyB3aGljaCB1c2VzICdoNCcsICdoNScgYW5kICdoNicgZm9yIG5lc3RlZCBncm91cHMuXG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nUHJlZml4ID0gJyMnLnJlcGVhdCg0ICsgaGVhZGluZy5uZXN0aW5nTGV2ZWwpO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGAke2hlYWRpbmdQcmVmaXh9IFske2hlYWRpbmcucHJvcGVydHl9XSAke2hlYWRpbmcuZGlzcGxheU5hbWV9XFxuYDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCArPSB0aGlzLnRhc2tzQXNTdHJpbmdPZkxpbmVzKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyIH0gZnJvbSAnLi9Hcm91cGVyJztcbmltcG9ydCB7IEdyb3VwRGlzcGxheUhlYWRpbmdTZWxlY3RvciB9IGZyb20gJy4vR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yJztcbmltcG9ydCB7IFRhc2tHcm91cGluZ1RyZWUgfSBmcm9tICcuL1Rhc2tHcm91cGluZ1RyZWUnO1xuaW1wb3J0IHsgVGFza0dyb3VwIH0gZnJvbSAnLi9UYXNrR3JvdXAnO1xuaW1wb3J0IHR5cGUgeyBUYXNrR3JvdXBpbmdUcmVlU3RvcmFnZSB9IGZyb20gJy4vVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UnO1xuXG4vKipcbiAqIFN0b3JlIGFsbCB0aGUgZ3JvdXBzIG9mIHRhc2tzIGdlbmVyYXRlZCBieSBhbnkgJ2dyb3VwIGJ5J1xuICogaW5zdHJ1Y3Rpb25zIGluIHRoZSB0YXNrIGJsb2NrLlxuICpcbiAqIFRoZSBncm91cHMgYXJlIHN0b3JlZCBpbiBhcnJheSBvZiB7QGxpbmsgVGFza0dyb3VwfSBvYmplY3RzLlxuICogQHNlZSB7QGxpbmsgR3JvdXBlcn1cbiAqIEBzZWUge0BsaW5rIFF1ZXJ5Lmdyb3VwaW5nfVxuICovXG5leHBvcnQgY2xhc3MgVGFza0dyb3VwcyB7XG4gICAgcHJpdmF0ZSBfZ3JvdXBlcnM6IEdyb3VwZXJbXTtcbiAgICBwcml2YXRlIF9ncm91cHM6IFRhc2tHcm91cFtdID0gbmV3IEFycmF5PFRhc2tHcm91cD4oKTtcbiAgICBwcml2YXRlIF90b3RhbFRhc2tDb3VudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3Ige0BsaW5rIFRhc2tHcm91cHN9XG4gICAgICogQHBhcmFtIHtHcm91cGVyW119IGdyb3VwcyAtIDAgb3IgbW9yZSB7QGxpbmsgR3JvdXBlcn0gb2JqZWN0cyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgcGVyICdncm91cCBieScgbGluZSBpbiB0aGUgdGFzayBxdWVyeSBibG9ja1xuICAgICAqIEBwYXJhbSB7VGFza1tdfSB0YXNrcyAtIGFsbCB0aGUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBhbHJlYWR5IHNvcnRlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwczogR3JvdXBlcltdLCB0YXNrczogVGFza1tdKSB7XG4gICAgICAgIC8vIEdyb3VwaW5nIGRvZXNuJ3QgY2hhbmdlIHRoZSBudW1iZXIgb2YgdGFza3MsIGFuZCBhbGwgdGhlIHRhc2tzXG4gICAgICAgIC8vIHdpbGwgYmUgc2hvd24gaW4gYXQgbGVhc3Qgb25lIGdyb3VwLlxuICAgICAgICB0aGlzLl90b3RhbFRhc2tDb3VudCA9IHRhc2tzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fZ3JvdXBlcnMgPSBncm91cHM7XG5cbiAgICAgICAgY29uc3QgdGFza0dyb3VwaW5nVHJlZSA9IG5ldyBUYXNrR3JvdXBpbmdUcmVlKGdyb3VwcywgdGFza3MpO1xuICAgICAgICBjb25zdCBncm91cGluZ1RyZWVTdG9yYWdlID0gdGFza0dyb3VwaW5nVHJlZS5nZW5lcmF0ZVRhc2tUcmVlU3RvcmFnZSgpO1xuXG4gICAgICAgIHRoaXMuYWRkVGFza0dyb3Vwcyhncm91cGluZ1RyZWVTdG9yYWdlKTtcblxuICAgICAgICB0aGlzLnNvcnRUYXNrR3JvdXBzKCk7XG5cbiAgICAgICAgdGhpcy5zZXRHcm91cHNIZWFkaW5ncyhncm91cGluZ1RyZWVTdG9yYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHtAbGluayBHcm91cGVyfSBvYmplY3RzLCAxIHBlciAnZ3JvdXAgYnknIGxpbmUgaW4gdGhlIHRhc2tzIHF1ZXJ5IGJsb2NrLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ3JvdXBlcnMoKTogR3JvdXBlcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgdGFza3MgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBncm91cGVkIHRvZ2V0aGVyLCBhbmQgaW4gdGhlIG9yZGVyXG4gICAgICogdGhhdCB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFza3MgYXJlIHVuZ3JvdXBlZCwgYSBzaW5nbGUge0BsaW5rIFRhc2tHcm91cH0gd2lsbCBiZSByZXR1cm5lZCxcbiAgICAgKiB3aXRoIG5vIGhlYWRpbmcgbmFtZXMuXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHMoKTogVGFza0dyb3VwW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdW5pcXVlIHRhc2tzIG1hdGNoaW5nIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0YXNrcyBtYXkgYmUgZGlzcGxheWVkIG1vcmUgdGhhbiBvbmNlLiBGb3IgZXhhbXBsZSBhbnkgdGFza3Mgd2l0aCBtb3JlIHRoYW4gb25lXG4gICAgICogdGFnIHdpbGwgYmUgZGlzcGxheWVkIG11bHRpcGxlIHRpbWVzIGlmIGdyb3VwZWQgYnkgVGFnLlxuICAgICAqIFNvIHN1bW1pbmcgdGhlIG51bWJlciBvZiB0YXNrcyBpbiBhbGwgdGhlIHtAbGluayBncm91cHN9IGNhbiBnaXZlIGEgbGFyZ2VyIG51bWJlciB0aGFuXG4gICAgICogdGhpcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG90YWxUYXNrc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxUYXNrQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIHRhc2sgZ3JvdXBzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXMgdXNlZCBpbiBzbmFwc2hvdCB0ZXN0aW5nLCBzbyBpZiB0aGUgZm9ybWF0IGlzXG4gICAgICogY2hhbmdlZCwgdGhlIHNuYXBzaG90cyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBvdXRwdXQgKz0gJ0dyb3VwZXJzIChpZiBhbnkpOlxcbic7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXBlciBvZiB0aGlzLl9ncm91cGVycykge1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZVRleHQgPSBncm91cGVyLnJldmVyc2UgPyAnIHJldmVyc2UnIDogJyc7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYC0gJHtncm91cGVyLnByb3BlcnR5fSR7cmV2ZXJzZVRleHR9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhc2tHcm91cCBvZiB0aGlzLmdyb3Vwcykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IHRhc2tHcm91cC50b1N0cmluZygpO1xuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4tLS1cXG4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsVGFza3NDb3VudCA9IHRoaXMudG90YWxUYXNrc0NvdW50KCk7XG4gICAgICAgIG91dHB1dCArPSBgXFxuJHt0b3RhbFRhc2tzQ291bnR9IHRhc2tzXFxuYDtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRhc2tHcm91cHMoZ3JvdXBpbmdUcmVlU3RvcmFnZTogVGFza0dyb3VwaW5nVHJlZVN0b3JhZ2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBbZ3JvdXBzLCB0YXNrc10gb2YgZ3JvdXBpbmdUcmVlU3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3QgdGFza0dyb3VwID0gbmV3IFRhc2tHcm91cChncm91cHMsIHRhc2tzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFza0dyb3VwKHRhc2tHcm91cCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRhc2tHcm91cCh0YXNrR3JvdXA6IFRhc2tHcm91cCkge1xuICAgICAgICB0aGlzLl9ncm91cHMucHVzaCh0YXNrR3JvdXApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc29ydFRhc2tHcm91cHMoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVGbiA9IChncm91cDE6IFRhc2tHcm91cCwgZ3JvdXAyOiBUYXNrR3JvdXApID0+IHtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgdHdvIFRhc2tHcm91cCBvYmplY3RzLCBzb3J0aW5nIHRoZW0gYnkgdGhlIGdyb3VwIG5hbWVzIGF0IGVhY2ggZ3JvdXBpbmcgbGV2ZWwuXG4gICAgICAgICAgICBjb25zdCBncm91cE5hbWVzMSA9IGdyb3VwMS5ncm91cHM7XG4gICAgICAgICAgICBjb25zdCBncm91cE5hbWVzMiA9IGdyb3VwMi5ncm91cHM7XG4gICAgICAgICAgICAvLyBUaGUgY29udGFpbmVycyBhcmUgZ3VhcmFudGVlZCB0byBiZSBpZGVudGljYWwgc2l6ZXMsXG4gICAgICAgICAgICAvLyB0aGV5IGhhdmUgb25lIHZhbHVlIGZvciBlYWNoICdncm91cCBieScgbGluZSBpbiB0aGUgcXVlcnkuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTmFtZXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgd2Ugb25seSBoYXZlIG9uZSBzb3J0IG9wdGlvbjogc29ydCBieSB0aGUgbmFtZXMgb2YgdGhlIGdyb3Vwcy5cbiAgICAgICAgICAgICAgICAvLyBJbiBmdXR1cmUsIHdlIHdpbGwgYWRkIGNvbnRyb2wgb3ZlciB0aGUgc29ydGluZyBvZiBncm91cCBoZWFkaW5ncyxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGxpa2VseSBpbnZvbHZlIGFkanVzdGluZyB0aGlzIGNvZGUgdG8gc29ydCBieSBhcHBseWluZyBhIENvbXBhcmF0b3JcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgZmlyc3QgVGFzayBpbiBlYWNoIGdyb3VwLlxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwZXIgPSB0aGlzLl9ncm91cGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBncm91cE5hbWVzMVtpXS5sb2NhbGVDb21wYXJlKGdyb3VwTmFtZXMyW2ldLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cGVyLnJldmVyc2UgPyAtcmVzdWx0IDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlkZW50aWNhbCBpZiB3ZSByZWFjaCBoZXJlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZ3JvdXBzLnNvcnQoY29tcGFyZUZuKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEdyb3Vwc0hlYWRpbmdzKGdyb3VwaW5nVHJlZVN0b3JhZ2U6IFRhc2tHcm91cGluZ1RyZWVTdG9yYWdlKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlIZWFkaW5nU2VsZWN0b3IgPSBuZXcgR3JvdXBEaXNwbGF5SGVhZGluZ1NlbGVjdG9yKGdyb3VwaW5nVHJlZVN0b3JhZ2UsIHRoaXMuX2dyb3VwZXJzKTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLl9ncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3VwLnNldEdyb3VwSGVhZGluZ3MoZGlzcGxheUhlYWRpbmdTZWxlY3Rvci5nZXRIZWFkaW5nc0ZvclRhc2tHcm91cChncm91cC5ncm91cHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbWl0cyBhbGwge0BsaW5rIGdyb3Vwc30gdG8gaGF2ZSBhIGNlcnRhaW4gbnVtYmVyIG9mIHRhc2tzIGFuZFxuICAgICAqIHJlY2FsY3VsYXRlcyB0aGUge0BsaW5rIF90b3RhbFRhc2tDb3VudH0gZm9yIGNvbnNpc3RlbmN5LlxuICAgICAqXG4gICAgICogSWYgbm8gYGdyb3VwIGJ5IC4uLmAgaW5zdHJ1Y3Rpb25zIHdlcmUgcHJvdmlkZWQgdGhlIGxpbWl0IGlzIGlnbm9yZWQsXG4gICAgICogaG93ZXZlciB0aGVyZSB3aWxsIGJlIG9uZSB0YXNrIGdyb3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiB0YXNrcyBmb3IgZWFjaCBncm91cCB0byBoYXZlLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGFwcGx5VGFza0xpbWl0KGxpbWl0OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICAgICAgICBncm91cC5hcHBseVRhc2tMaW1pdChsaW1pdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVUb3RhbFRhc2tDb3VudCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc3RvcmVkIHRhc2sgY291bnQgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgb2YgdW5pcXVlIHRhc2tzXG4gICAgICogYWNyb3NzIGFsbCB0aGUgZ3JvdXBzLlxuICAgICAqXG4gICAgICogSW4gbm9ybWFsIG9wZXJhdGlvbiB0aGlzIGlzIG9ubHkgdXNlZnVsIGFmdGVyIGEgbGltaXQgdG8gZ3JvdXAgc2l6ZVxuICAgICAqIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBpdCBpcyBhbHNvIHVzZWZ1bCBmb3IgdGVzdCBjb2RlIHRvIGJlIGFibGUgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gICAgICogb2YgdGFzayBjb3VudCBhZnRlciB0aGUgb2JqZWN0IGhhcyBiZWVuIGluaXRpYWxseSBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjYWxjdWxhdGVUb3RhbFRhc2tDb3VudCgpIHtcbiAgICAgICAgbGV0IGNvbmNhdGVuYXRlZFRhc2tzOiBUYXNrW10gPSBbXTtcblxuICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgIGNvbmNhdGVuYXRlZFRhc2tzID0gWy4uLmNvbmNhdGVuYXRlZFRhc2tzLCAuLi5ncm91cC50YXNrc107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVuaXF1ZVRhc2tzID0gWy4uLm5ldyBTZXQoY29uY2F0ZW5hdGVkVGFza3MpXTtcbiAgICAgICAgdGhpcy5fdG90YWxUYXNrQ291bnQgPSB1bmlxdWVUYXNrcy5sZW5ndGg7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4uLy4uL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdkZXNjcmlwdGlvbicgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBEZXNjcmlwdGlvbkZpZWxkLnZhbHVlKCkgcmV0dXJucyB0aGUgZGVzY3JpcHRpb25cbiAqIHdpdGggdGhlIGdsb2JhbCBmaWx0ZXIgKGlmIGFueSkgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlc2NyaXB0aW9uRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdkZXNjcmlwdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrJ3MgZGVzY3JpcHRpb24sIHdpdGggYW55IGdsb2JhbCB0YWcgcmVtb3ZlZFxuICAgICAqXG4gICAgICogUHJvbW90ZWQgdG8gcHVibGljLCB0byBlbmFibGUgdGVzdGluZy5cbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIC8vIFJlbW92ZSBnbG9iYWwgZmlsdGVyIGZyb20gZGVzY3JpcHRpb24gbWF0Y2ggaWYgcHJlc2VudC5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWF0Y2ggb25seSBvbiB0aGUgY29udGVudCBvZiB0aGUgdGFzaywgbm90XG4gICAgICAgIC8vIHRoZSBnbG9iYWwgZmlsdGVyLlxuICAgICAgICByZXR1cm4gR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkucmVtb3ZlQXNTdWJzdHJpbmdGcm9tKHRhc2suZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdGhlIGRlc2NyaXB0aW9uIGJ5IGhvdyBpdCBpcyByZW5kZXJlZCBpbiBtYXJrZG93bi5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHVzZSB0aGUgTWFya2Rvd25SZW5kZXJlciwgYnV0IHRyaWVzIHRvIG1hdGNoIHJlZ2V4ZXMgaW5zdGVhZFxuICAgICAqIGluIG9yZGVyIHRvIGJlIHNpbXBsZXIsIGZhc3RlciwgYW5kIG5vdCBhc3luYy5cbiAgICAgKlxuICAgICAqIE9ubHkgc2VhcmNoZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkZXNjcmlwdGlvbi4gTWFya2Rvd24gbGF0ZXIgaW4gdGhlIHRhayBpcyB1bmNoYW5nZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIHJldHVybiAoYTogVGFzaywgYjogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25BID0gRGVzY3JpcHRpb25GaWVsZC5jbGVhbkRlc2NyaXB0aW9uKGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25CID0gRGVzY3JpcHRpb25GaWVsZC5jbGVhbkRlc2NyaXB0aW9uKGIuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uQS5sb2NhbGVDb21wYXJlKGRlc2NyaXB0aW9uQiwgdW5kZWZpbmVkLCB7IG51bWVyaWM6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBgKmAsIGA9YCwgYW5kIGBbYCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV2lsbCByZW1vdmUgdGhlbSBvbmx5IGlmIHRoZXkgYXJlIGNsb3NpbmcuXG4gICAgICogUHJvcGVybHkgcmVhZHMgbGlua3MgW1tsaWtlIHRoaXN8b25lXV0gKG5vdGUgcGlwZSkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjbGVhbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBkZXNjcmlwdGlvbiA9IEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnJlbW92ZUFzU3Vic3RyaW5nRnJvbShkZXNjcmlwdGlvbik7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRzV2l0aExpbmtSZWdleCA9IC9eXFxbXFxbPyhbXlxcXV0qKV1dPy87XG4gICAgICAgIGNvbnN0IGxpbmtSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2goc3RhcnRzV2l0aExpbmtSZWdleCk7XG4gICAgICAgIGlmIChsaW5rUmVnZXhNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXJMaW5rVGV4dCA9IGxpbmtSZWdleE1hdGNoWzFdO1xuICAgICAgICAgICAgLy8gRm9yIGEgbGluaywgd2UgaGF2ZSB0byBjaGVjayB3aGV0aGVyIGl0IGhhcyBhbm90aGVyIHZpc2libGUgbmFtZSBzZXQuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSBgW1t0aGlzIGlzIHRoZSBsaW5rfGJ1dCB0aGlzIGlzIGFjdHVhbGx5IHNob3duXV1gLlxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIGlubmVyTGlua1RleHQuc3Vic3RyaW5nKGlubmVyTGlua1RleHQuaW5kZXhPZignfCcpICsgMSkgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHN0YXJ0c1dpdGhMaW5rUmVnZXgsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCpcXCooW14qXSspXFwqXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL15cXCooW14qXSspXFwqLyk7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5yZXBsYWNlRm9ybWF0dGluZyhkZXNjcmlwdGlvbiwgL149PShbXj1dKyk9PS8pO1xuICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMucmVwbGFjZUZvcm1hdHRpbmcoZGVzY3JpcHRpb24sIC9eX18oW15fXSspX18vKTtcbiAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLnJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uLCAvXl8oW15fXSspXy8pO1xuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc29tZSBmb3JtYXR0aW5nIGZyb20gdGV4dFxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSByZWdFeHAgQSByZWd1bGFyIGV4cHJlc3Npb24gLSBhbGwgbWF0Y2hpbmcgdGV4dCBpcyBkaXNjYXJkZWQgZXhjZXB0IHRoZSBmaXJzdCBncm91cFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlcGxhY2VGb3JtYXR0aW5nKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHJlZ0V4cDogUmVnRXhwKSB7XG4gICAgICAgIGNvbnN0IGl0YWxpY0JvbGRSZWdleE1hdGNoID0gZGVzY3JpcHRpb24ubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgaWYgKGl0YWxpY0JvbGRSZWdleE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckl0YWxpY0JvbGRUZXh0ID0gaXRhbGljQm9sZFJlZ2V4TWF0Y2hbMV07XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGlubmVySXRhbGljQm9sZFRleHQgKyBkZXNjcmlwdGlvbi5yZXBsYWNlKHJlZ0V4cCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5cbi8qKlxuICogU3VwcG9ydCB0aGUgJ2NyZWF0ZWQnIHNlYXJjaCBpbnN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENyZWF0ZWREYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdjcmVhdGVkJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5jcmVhdGVkRGF0ZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdkb25lJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBEb25lRGF0ZUZpZWxkIGV4dGVuZHMgRGF0ZUZpZWxkIHtcbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZG9uZSc7XG4gICAgfVxuICAgIHB1YmxpYyBkYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suZG9uZURhdGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXJJbnN0cnVjdGlvbnNCYXNlZEZpZWxkJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzICdleGNsdWRlIHN1Yi1pdGVtcycgZmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBFeGNsdWRlU3ViSXRlbXNGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdleGNsdWRlIHN1Yi1pdGVtcycsICh0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5pbmRlbnRhdGlvbiA9PT0gJycpIHJldHVybiB0cnVlOyAvLyBubyBpbmRlbnRhdGlvbiwgbm90IGEgc3ViaXRlbVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0QmxvY2txdW90ZU1hcmsgPSB0YXNrLmluZGVudGF0aW9uLmxhc3RJbmRleE9mKCc+Jyk7XG4gICAgICAgICAgICBpZiAobGFzdEJsb2NrcXVvdGVNYXJrID09PSAtMSkgcmV0dXJuIGZhbHNlOyAvLyBpbmRlbnRhdGlvbiBwcmVzZW50LCBub3QgaW4gYSBibG9ja3F1b3RlLCBzdWJpdGVtXG5cbiAgICAgICAgICAgIC8vIFVwIHRvIG9uZSBzcGFjZSBhbGxvd2VkIGFmdGVyIGxhc3QgPiBpbiBibG9ja3F1b3RlL2NhbGxvdXQsIG90aGVyd2lzZSBzdWJpdGVtXG4gICAgICAgICAgICByZXR1cm4gL14gPyQvLnRlc3QodGFzay5pbmRlbnRhdGlvbi5zbGljZShsYXN0QmxvY2txdW90ZU1hcmsgKyAxKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdleGNsdWRlJztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQgeyBRdWVyeUNvbXBvbmVudE9yRXJyb3IgfSBmcm9tICcuLi9RdWVyeS9RdWVyeUNvbXBvbmVudE9yRXJyb3InO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlRm9yRXhjZXB0aW9uIH0gZnJvbSAnLi4vbGliL0V4Y2VwdGlvblRvb2xzJztcblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uT3JFcnJvciBleHRlbmRzIFF1ZXJ5Q29tcG9uZW50T3JFcnJvcjxGdW5jdGlvbj4ge31cblxuLyoqXG4gKiAgRnJvbTogaHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Fuc3dlcnMvcGFyYW1ldGVyLXZzLWFyZ3VtZW50XG4gKiAgICAgIEEgcGFyYW1ldGVyIGlzIGEgdmFyaWFibGUgaW4gYSBmdW5jdGlvbiBkZWZpbml0aW9uLiBJdCBpcyBhIHBsYWNlaG9sZGVyIGFuZCBoZW5jZSBkb2VzIG5vdCBoYXZlIGEgY29uY3JldGUgdmFsdWUuXG4gKiAgICAgIEFuIGFyZ3VtZW50IGlzIGEgdmFsdWUgcGFzc2VkIGR1cmluZyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuICogQHBhcmFtIHRhc2sgLSBkdXJpbmcgcGFyc2luZywgdGhpcyBjYW4gYmUgbnVsbC4gRHVyaW5nIGV2YWx1YXRpb24sIGl0IG11c3QgYmUgYSBUYXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RBcmd1bWVudHModGFzazogVGFzayB8IG51bGwpIHtcbiAgICAvLyBUT0RPIE1vdmUgdGhpcyB0byBUYXNrRXhwcmVzc2lvblxuICAgIGNvbnN0IHBhcmFtc0FyZ3M6IFtzdHJpbmcsIGFueV1bXSA9IFtcbiAgICAgICAgLy8gVE9ETyBMYXRlciwgcGFzcyBpbiB0aGUgUXVlcnkgdG9vLCBmb3IgYWNjZXNzIHRvIGZpbGUgcHJvcGVydGllc1xuICAgICAgICBbJ3Rhc2snLCB0YXNrXSxcbiAgICBdO1xuICAgIHJldHVybiBwYXJhbXNBcmdzO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLCBhbmQgcmV0dXJuIGVpdGhlciBhIEZ1bmN0aW9uIG9yIGFuIGVycm9yIG1lc3NhZ2UgaW4gYSBzdHJpbmcuXG4gKiBAcGFyYW0gcGFyYW1zQXJnc1xuICogQHBhcmFtIGFyZ1xuICpcbiAqIEBzZWUgZXZhbHVhdGVFeHByZXNzaW9uXG4gKiBAc2VlIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihwYXJhbXNBcmdzOiBbc3RyaW5nLCBhbnldW10sIGFyZzogc3RyaW5nKTogRnVuY3Rpb25PckVycm9yIHtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXJhbXNBcmdzLm1hcCgoW3BdKSA9PiBwKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGFyZy5pbmNsdWRlcygncmV0dXJuJykgPyBhcmcgOiBgcmV0dXJuICR7YXJnfWA7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb246ICcnIHwgbnVsbCB8IEZ1bmN0aW9uID0gYXJnICYmIG5ldyBGdW5jdGlvbiguLi5wYXJhbXMsIGlucHV0KTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uT3JFcnJvci5mcm9tT2JqZWN0KGFyZywgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSSBoYXZlIG5vdCBtYW5hZ2VkIHRvIHdyaXRlIGEgdGVzdCB0aGF0IHJlYWNoZXMgaGVyZTpcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uT3JFcnJvci5mcm9tRXJyb3IoYXJnLCAnRXJyb3IgcGFyc2luZyBncm91cCBmdW5jdGlvbicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uT3JFcnJvci5mcm9tRXJyb3IoYXJnLCBlcnJvck1lc3NhZ2VGb3JFeGNlcHRpb24oYEZhaWxlZCBwYXJzaW5nIGV4cHJlc3Npb24gXCIke2FyZ31cImAsIGUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYW4gYXJiaXRyYXJ5IEphdmFTY3JpcHQgZXhwcmVzc2lvbiwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIGlmIHRoZSBjYWxjdWxhdGlvbiBmYWlsZWQuXG4gKiBAcGFyYW0gZXhwcmVzc2lvblxuICogQHBhcmFtIHBhcmFtc0FyZ3NcbiAqXG4gKiBAc2VlIHBhcnNlRXhwcmVzc2lvblxuICogQHNlZSBldmFsdWF0ZUV4cHJlc3Npb25PckNhdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbjogRnVuY3Rpb24sIHBhcmFtc0FyZ3M6IFtzdHJpbmcsIGFueV1bXSkge1xuICAgIGNvbnN0IGFyZ3MgPSBwYXJhbXNBcmdzLm1hcCgoW18sIGFdKSA9PiBhKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbiguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSBhbiBhcmJpdHJhcnkgSmF2YVNjcmlwdCBleHByZXNzaW9uLCByZXR1cm5pbmcgYW4gZXJyb3IgbWVzc2FnZSBpZiB0aGUgY2FsY3VsYXRpb24gZmFpbGVkLlxuICogQHBhcmFtIGV4cHJlc3Npb25cbiAqIEBwYXJhbSBwYXJhbXNBcmdzXG4gKiBAcGFyYW0gYXJnXG4gKlxuICogQHNlZSBwYXJzZUV4cHJlc3Npb25cbiAqIEBzZWUgZXZhbHVhdGVFeHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZUV4cHJlc3Npb25PckNhdGNoKGV4cHJlc3Npb246IEZ1bmN0aW9uLCBwYXJhbXNBcmdzOiBbc3RyaW5nLCBhbnldW10sIGFyZzogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJhbXNBcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2VGb3JFeGNlcHRpb24oYEZhaWxlZCBjYWxjdWxhdGluZyBleHByZXNzaW9uIFwiJHthcmd9XCJgLCBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgYW4gYXJiaXRyYXJ5IEphdmFTY3JpcHQgZXhwcmVzc2lvbiBvbiBhIFRhc2sgb2JqZWN0XG4gKiBAcGFyYW0gdGFzayAtIGEge0BsaW5rIFRhc2t9IG9iamVjdFxuICogQHBhcmFtIGFyZyAtIGEgc3RyaW5nLCBzdWNoIGFzIGB0YXNrLnBhdGguc3RhcnRzV2l0aChcImpvdXJuYWwvXCIpID8gXCJqb3VybmFsL1wiIDogdGFzay5wYXRoYFxuICpcbiAqIEN1cnJlbnRseSBhbnkgZXJyb3JzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmcgZXJyb3IgbWVzc2FnZXMsIHN0YXJ0aW5nIHdpdGggdGhlIHdvcmQgJ0Vycm9yJy5cbiAqXG4gKiBAdG9kbyBJbXBsZW1lbnQgYSB0eXBlLXNhZmUgbWVjaGFuaXNtIHRvIHJlcG9ydCBlcnJvciBtZXNzYWdlcyBkaXN0aW5jdCBmcm9tIGV4cHJlc3Npb24gcmVzdWx0cy5cbiAqXG4gKiBTZWUgYWxzbyB7QGxpbmsgRnVuY3Rpb25GaWVsZH0gd2hpY2ggZXhwb3NlcyB0aGlzIGZhY2lsaXR5IHRvIHVzZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbmRFdmFsdWF0ZUV4cHJlc3Npb24odGFzazogVGFzaywgYXJnOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJhbXNBcmdzID0gY29uc3RydWN0QXJndW1lbnRzKHRhc2spO1xuXG4gICAgY29uc3QgZnVuY3Rpb25PckVycm9yID0gcGFyc2VFeHByZXNzaW9uKHBhcmFtc0FyZ3MsIGFyZyk7XG4gICAgaWYgKGZ1bmN0aW9uT3JFcnJvci5lcnJvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25PckVycm9yLmVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBldmFsdWF0ZUV4cHJlc3Npb25PckNhdGNoKGZ1bmN0aW9uT3JFcnJvci5xdWVyeUNvbXBvbmVudCEsIHBhcmFtc0FyZ3MsIGFyZyk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vVGFzayc7XG5pbXBvcnQge1xuICAgIEZ1bmN0aW9uT3JFcnJvcixcbiAgICBjb25zdHJ1Y3RBcmd1bWVudHMsXG4gICAgZXZhbHVhdGVFeHByZXNzaW9uLFxuICAgIGV2YWx1YXRlRXhwcmVzc2lvbk9yQ2F0Y2gsXG4gICAgcGFyc2VFeHByZXNzaW9uLFxufSBmcm9tICcuL0V4cHJlc3Npb24nO1xuXG4vKipcbiAqIEVuY2Fwc3VsYXRlIGFuIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgY2FsY3VsYXRlZCBmcm9tIGEge0BsaW5rIFRhc2t9IG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgVGFza0V4cHJlc3Npb24ge1xuICAgIHB1YmxpYyByZWFkb25seSBsaW5lOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBmdW5jdGlvbk9yRXJyb3I6IEZ1bmN0aW9uT3JFcnJvcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihsaW5lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk9yRXJyb3IgPSBwYXJzZUV4cHJlc3Npb24oY29uc3RydWN0QXJndW1lbnRzKG51bGwpLCBsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25PckVycm9yLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwYXJzZUVycm9yKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uT3JFcnJvci5lcnJvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBvbiB0aGlzIHRhc2ssIG9yIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgY2FsY3VsYXRpb24gZmFpbGVkXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKlxuICAgICAqIEBzZWUgZXZhbHVhdGVPckNhdGNoXG4gICAgICovXG4gICAgcHVibGljIGV2YWx1YXRlKHRhc2s6IFRhc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEVycm9yOiBDYW5ub3QgZXZhbHVhdGUgYW4gZXhwcmVzc2lvbiB3aGljaCBpcyBub3QgdmFsaWQ6IFwiJHt0aGlzLmxpbmV9XCIgZ2F2ZSBlcnJvcjogXCIke3RoaXMucGFyc2VFcnJvcn1cImAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsdWF0ZUV4cHJlc3Npb24odGhpcy5mdW5jdGlvbk9yRXJyb3IucXVlcnlDb21wb25lbnQhLCBjb25zdHJ1Y3RBcmd1bWVudHModGFzaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHRoZSBleHByZXNzaW9uIG9uIHRoaXMgdGFzaywgb3IgcmV0dXJuIGVycm9yIHRleHQgaWYgdGhlIGNhbGN1bGF0aW9uIGZhaWxlZFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICpcbiAgICAgKiBAc2VlIGV2YWx1YXRlXG4gICAgICovXG4gICAgcHVibGljIGV2YWx1YXRlT3JDYXRjaCh0YXNrOiBUYXNrKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3I6IENhbm5vdCBldmFsdWF0ZSBhbiBleHByZXNzaW9uIHdoaWNoIGlzIG5vdCB2YWxpZDogXCIke3RoaXMubGluZX1cIiBnYXZlIGVycm9yOiBcIiR7dGhpcy5wYXJzZUVycm9yfVwiYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZhbHVhdGVFeHByZXNzaW9uT3JDYXRjaCh0aGlzLmZ1bmN0aW9uT3JFcnJvci5xdWVyeUNvbXBvbmVudCEsIGNvbnN0cnVjdEFyZ3VtZW50cyh0YXNrKSwgdGhpcy5saW5lKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VBbmRFdmFsdWF0ZUV4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9TY3JpcHRpbmcvRXhwcmVzc2lvbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBHcm91cGVyIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBFeHBsYW5hdGlvbiB9IGZyb20gJy4uL0V4cGxhaW4vRXhwbGFuYXRpb24nO1xuaW1wb3J0IHsgVGFza0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9TY3JpcHRpbmcvVGFza0V4cHJlc3Npb24nO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IEZpbHRlciwgdHlwZSBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5cbi8qKlxuICogQSB7QGxpbmsgRmllbGR9IGltcGxlbWVudCB0aGF0IGFjY2VwdHMgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gdG8gZmlsdGVyIG9yIGdyb3VwIHRhc2tzLlxuICpcbiAqIFNlZSBhbHNvIHtAbGluayBwYXJzZUFuZEV2YWx1YXRlRXhwcmVzc2lvbn1cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgJ1VuYWJsZSB0byBwYXJzZSBsaW5lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gbWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IHRhc2tFeHByZXNzaW9uID0gbmV3IFRhc2tFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXRhc2tFeHByZXNzaW9uLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCB0YXNrRXhwcmVzc2lvbi5wYXJzZUVycm9yISk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUZpbHRlcihcbiAgICAgICAgICAgIG5ldyBGaWx0ZXIobGluZSwgY3JlYXRlRmlsdGVyRnVuY3Rpb25Gcm9tTGluZSh0YXNrRXhwcmVzc2lvbiksIG5ldyBFeHBsYW5hdGlvbihsaW5lKSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeZmlsdGVyIGJ5ICR7dGhpcy5maWVsZE5hbWVTaW5ndWxhckVzY2FwZWQoKX0gKC4qKWApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR3JvdXBpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVHcm91cGVyRnJvbUxpbmUobGluZTogc3RyaW5nKTogR3JvdXBlciB8IG51bGwge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZ3JvdXBlclJlZ0V4cCgpLCBsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXZlcnNlID0gISFtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoWzJdO1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIoJ2Z1bmN0aW9uJywgY3JlYXRlR3JvdXBlckZ1bmN0aW9uRnJvbUxpbmUoYXJncyksIHJldmVyc2UpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBncm91cGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeZ3JvdXAgYnkgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyRXNjYXBlZCgpfSggcmV2ZXJzZSk/ICguKilgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGZvciAnZ3JvdXAgYnkgZnVuY3Rpb24nIGFzIHRoZSB1c2VyJ3MgaW5zdHJ1Y3Rpb24gbGluZVxuICAgICAqIGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUge0BsaW5rIEdyb3VwZXJGdW5jdGlvbn0uXG4gICAgICpcbiAgICAgKiBTbyB0aGlzIGNsYXNzIG92ZXJyaWRlcyB7QGxpbmsgY3JlYXRlR3JvdXBlckZyb21MaW5lfSBpbnN0ZWFkLlxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICB0aHJvdyBFcnJvcignZ3JvdXBlcigpIGZ1bmN0aW9uIG5vdCB2YWxpZCBmb3IgRnVuY3Rpb25GaWVsZC4gVXNlIGNyZWF0ZUdyb3VwZXJGcm9tTGluZSgpIGluc3RlYWQuJyk7XG4gICAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRmlsdGVyaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXJGdW5jdGlvbkZyb21MaW5lKGV4cHJlc3Npb246IFRhc2tFeHByZXNzaW9uKTogRmlsdGVyRnVuY3Rpb24ge1xuICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICByZXR1cm4gZmlsdGVyQnlGdW5jdGlvbihleHByZXNzaW9uLCB0YXNrKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyQnlGdW5jdGlvbihleHByZXNzaW9uOiBUYXNrRXhwcmVzc2lvbiwgdGFzazogVGFzayk6IGJvb2xlYW4ge1xuICAgIC8vIEFsbG93IGV4Y2VwdGlvbnMgdG8gcHJvcGFnYXRlIHRvIGNhbGxlciwgc2luY2UgdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgLy8gSW4gc2VhcmNoZXMsIGl0IHdpbGwgYmUgY2F1Z2h0IGJ5IFF1ZXJ5LmFwcGx5UXVlcnlUb1Rhc2tzKCkuXG4gICAgY29uc3QgcmVzdWx0ID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSh0YXNrKTtcblxuICAgIC8vIFdlIGluc2lzdCB0aGF0ICdmaWx0ZXIgYnkgZnVuY3Rpb24nIHJldHVybnMgYm9vbGVhbnMsXG4gICAgLy8gdG8gYXZvaWQgdXNlcnMgaGF2aW5nIHRvIHVuZGVyc3RhbmQgdHJ1dGh5IGFuZCBmYWxzZXkgdmFsdWVzLlxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0aHJvdyBFcnJvcihgZmlsdGVyaW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIHRydWUgb3IgZmFsc2UuIFRoaXMgcmV0dXJuZWQgXCIke3Jlc3VsdH1cIi5gKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdyb3VwaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG50eXBlIEdyb3VwaW5nQXJnID0gc3RyaW5nO1xuXG5mdW5jdGlvbiBjcmVhdGVHcm91cGVyRnVuY3Rpb25Gcm9tTGluZShsaW5lOiBzdHJpbmcpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICByZXR1cm4gZ3JvdXBCeUZ1bmN0aW9uKHRhc2ssIGxpbmUpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5RnVuY3Rpb24odGFzazogVGFzaywgYXJnOiBHcm91cGluZ0FyZyk6IHN0cmluZ1tdIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUFuZEV2YWx1YXRlRXhwcmVzc2lvbih0YXNrLCBhcmcpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKChoKSA9PiBoLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFzayB1c2VzIG51bGwgdG8gcmVwcmVzZW50IG1pc3NpbmcgaW5mb3JtYXRpb24uXG4gICAgICAgIC8vIFNvIHdlIHRyZWF0IG51bGwgYXMgYW4gZW1wdHkgZ3JvdXAgb3IgJ25vdCBpbiBhIGhlYWRpbmcnLCBmb3Igc2ltcGxpY2l0eSBmb3IgdXNlcnMuXG4gICAgICAgIC8vIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCAnbnVsbCB8fCBcIk5vIHZhbHVlXCJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIHRoZSBleHByZXNzaW9uLCBsaWtlIGl0IHJlZmVycmVkIHRvXG4gICAgICAgIC8vIGFuIHVua25vd24gdGFzayBmaWVsZCwgcmVzdWx0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhlIGNhbGxcbiAgICAgICAgLy8gb24gdW5kZWZpbmVkLnRvU3RyaW5nKCkgd2lsbCBnaXZlIGFuIGV4Y2VwdGlvbiBhbmQgYSB1c2VmdWwgZXJyb3JcbiAgICAgICAgLy8gbWVzc2FnZSBiZWxvdy4gVGhpcyBpcyBhIGZlYXR1cmU6IGl0IGdpdmVzIHVzZXJzIGZlZWRiYWNrIG9uIHRoZSBwcm9ibGVtXG4gICAgICAgIC8vIGluc3RydWN0aW9uIGxpbmUuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbZ3JvdXBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYEVycm9yOiBGYWlsZWQgY2FsY3VsYXRpbmcgZXhwcmVzc2lvbiBcIiR7YXJnfVwiLiBUaGUgZXJyb3IgbWVzc2FnZSB3YXM6IGA7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXJyb3JNZXNzYWdlICsgZS5tZXNzYWdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZXJyb3JNZXNzYWdlICsgJ1Vua25vd24gZXJyb3InXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbi8qKiBTdXBwb3J0IHRoZSAnaGVhZGluZycgc2VhcmNoIGluc3RydWN0aW9uLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEhlYWRpbmdGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByZWNlZGluZyBoZWFkaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGhlYWRpbmcgaXMgbnVsbFxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRhc2sucHJlY2VkaW5nSGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wcmVjZWRpbmdIZWFkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLnByZWNlZGluZ0hlYWRlciA9PT0gbnVsbCB8fCB0YXNrLnByZWNlZGluZ0hlYWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoTm8gaGVhZGluZyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdGFzay5wcmVjZWRpbmdIZWFkZXJdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAnc2NoZWR1bGVkJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTY2hlZHVsZWREYXRlRmllbGQgZXh0ZW5kcyBEYXRlRmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzY2hlZHVsZWQnO1xuICAgIH1cbiAgICBwdWJsaWMgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0YXNrLnNjaGVkdWxlZERhdGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IERhdGVGaWVsZCB9IGZyb20gJy4vRGF0ZUZpZWxkJztcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSAnc3RhcnRzJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFydERhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZUZvckZpbHRlckluc3RydWN0aW9uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnc3RhcnRzJztcbiAgICB9XG4gICAgcHVibGljIGRhdGUodGFzazogVGFzayk6IE1vbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGFzay5zdGFydERhdGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZXN1bHRJZkZpZWxkTWlzc2luZygpIHtcbiAgICAgICAgLy8gcmVmZXJlbmNlOiBodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvUXVlcmllcy9GaWx0ZXJzI1N0YXJ0K0RhdGVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHR5cGUgeyBGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4vRmlsdGVyJztcbmltcG9ydCB7IEZpbHRlckluc3RydWN0aW9ucyB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zJztcbmltcG9ydCB0eXBlIHsgRGF0ZUZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuaW1wb3J0IHsgRGF0ZUZpZWxkIH0gZnJvbSAnLi9EYXRlRmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICdoYXBwZW5zJyBzZWFyY2ggaW5zdHJ1Y3Rpb24sIHdoaWNoIHNlYXJjaGVzIGFsbCBvZlxuICogc3RhcnQsIHNjaGVkdWxlZCBhbmQgZHVlIGRhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgSGFwcGVuc0RhdGVGaWVsZCBleHRlbmRzIERhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckluc3RydWN0aW9ucyA9IG5ldyBGaWx0ZXJJbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnaGFzIGhhcHBlbnMgZGF0ZScsICh0YXNrOiBUYXNrKSA9PiB0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpKTtcbiAgICAgICAgZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZCgnbm8gaGFwcGVucyBkYXRlJywgKHRhc2s6IFRhc2spID0+ICF0aGlzLmRhdGVzKHRhc2spLnNvbWUoKGRhdGUpID0+IGRhdGUgIT09IG51bGwpKTtcbiAgICAgICAgc3VwZXIoZmlsdGVySW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnaGFwcGVucyc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpZWxkTmFtZUZvckV4cGxhbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ2R1ZSwgc3RhcnQgb3Igc2NoZWR1bGVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBlYXJsaWVzdERhdGV9XG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF0ZSh0YXNrOiBUYXNrKTogTW9tZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhcmxpZXN0RGF0ZSh0YXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRhc2sncyBzdGFydCwgc2NoZWR1bGVkIGFuZCBkdWUgZGF0ZXMsIGFueSBvciBhbGwgb2Ygd2hpY2ggbWF5IGJlIG51bGwuXG4gICAgICovXG4gICAgcHVibGljIGRhdGVzKHRhc2s6IFRhc2spOiAoTW9tZW50IHwgbnVsbClbXSB7XG4gICAgICAgIHJldHVybiB0YXNrLmhhcHBlbnNEYXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVhcmxpZXN0IG9mIHRoZSBkYXRlcyB1c2VkIGJ5ICdoYXBwZW5zJyBpbiB0aGUgZ2l2ZW4gdGFzaywgb3IgbnVsbCBpZiBub25lIHNldC5cbiAgICAgKlxuICAgICAqIEdlbmVyYWxseSBzcGVha2luZywgdGhlIGVhcmxpZXN0IGRhdGUgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgaGlnaGVzdCBwcmlvcml0eSxcbiAgICAgKiBhcyBpdCBpcyB0aGUgZmlyc3QgcG9pbnQgYXQgd2hpY2ggdGhlIHVzZXIgbWlnaHQgd2lzaCB0byBhY3Qgb24gdGhlIHRhc2suXG4gICAgICogQHBhcmFtIHRhc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZWFybGllc3REYXRlKHRhc2s6IFRhc2spOiBNb21lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRhc2suaGFwcGVucy5tb21lbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlc3VsdElmRmllbGRNaXNzaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlcihkYXRlRmlsdGVyRnVuY3Rpb246IERhdGVGaWx0ZXJGdW5jdGlvbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlcyh0YXNrKS5zb21lKChkYXRlKSA9PiBkYXRlRmlsdGVyRnVuY3Rpb24oZGF0ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCB9IGZyb20gJy4vRmlsdGVySW5zdHJ1Y3Rpb25zQmFzZWRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSZWN1cnJpbmdGaWVsZCBleHRlbmRzIEZpbHRlckluc3RydWN0aW9uc0Jhc2VkRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWx0ZXJzLmFkZCgnaXMgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuYWRkKCdpcyBub3QgcmVjdXJyaW5nJywgKHRhc2spID0+IHRhc2sucmVjdXJyZW5jZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ3JlY3VycmluZyc7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTb3J0aW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbXBhcmF0b3IoKTogQ29tcGFyYXRvciB7XG4gICAgICAgIC8vIFJlY3VycmluZyB0YXNrcyBzb3J0IGJlZm9yZSBub24tcmVjdXJyaW5nIG9uZXNcbiAgICAgICAgcmV0dXJuIChhOiBUYXNrLCBiOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5yZWN1cnJlbmNlICE9PSBudWxsICYmIGIucmVjdXJyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5yZWN1cnJlbmNlID09PSBudWxsICYmIGIucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLnJlY3VycmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydSZWN1cnJpbmcnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTm90IFJlY3VycmluZyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgSVN0cmluZ01hdGNoZXIgfSBmcm9tICcuLi9NYXRjaGVycy9JU3RyaW5nTWF0Y2hlcic7XG5pbXBvcnQgeyBHcm91cGVyIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuXG4vKipcbiAqIE11bHRpVGV4dEZpZWxkIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdG8gaGVscCBpbXBsZW1lbnRcbiAqIGFsbCB0aGUgZmlsdGVyIGluc3RydWN0aW9ucyB0aGF0IGFjdCBvbiBtdWx0aXBsZSBzdHJpbmcgdmFsdWVzXG4gKiBzdWNoIGFzIHRoZSB0YWdzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTXVsdGlUZXh0RmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpbmd1bGFyIGZvcm0gb2YgdGhlIGZpZWxkJ3MgbmFtZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGZvcm0gb2YgdGhlIGZpZWxkJ3MgbmFtZS5cbiAgICAgKiBJZiBub3Qgb3ZlcnJpZGRlbiwgcmV0dXJucyB0aGUgc2luZ3VsYXIgZm9ybSBhcHBlbmRlZCB3aXRoIGFuIFwic1wiLlxuICAgICAqL1xuICAgIHB1YmxpYyBmaWVsZE5hbWVQbHVyYWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGROYW1lU2luZ3VsYXIoKSArICdzJztcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9LyR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX1gO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBmaWVsZFBhdHRlcm4oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX18JHt0aGlzLmZpZWxkTmFtZVBsdXJhbCgpfWA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlck9wZXJhdG9yUGF0dGVybigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIuZmlsdGVyT3BlcmF0b3JQYXR0ZXJuKCl9fGluY2x1ZGV8ZG8gbm90IGluY2x1ZGVgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIG5vdCBvdmVycmlkZGVuLCByZXR1cm5zIGEgY29tbWEtc2VwYXJhdGVkIGNvbmNhdGVuYXRpb24gb2YgYWxsXG4gICAgICogdGhlIHZhbHVlcyBvZiB0aGlzIGZpZWxkIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBhcmUgbm90IHZhbHVlc1xuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKHRhc2spLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgdmFsdWVzIG9mIHRoaXMgZmllbGQsIG9yIGFuIGVtcHR5IGFycmF5XG4gICAgICogaWYgdGhlIGZpZWxkIGhhcyBubyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgdmFsdWVzKHRhc2s6IFRhc2spOiBzdHJpbmdbXTtcblxuICAgIHByb3RlY3RlZCBnZXRGaWx0ZXIobWF0Y2hlcjogSVN0cmluZ01hdGNoZXIsIG5lZ2F0ZTogYm9vbGVhbik6IEZpbHRlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXIhLm1hdGNoZXNBbnlPZih0aGlzLnZhbHVlcyh0YXNrKSk7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRlID8gIW1hdGNoIDogbWF0Y2g7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvdmVybG9hZHMge0BsaW5rIEZpZWxkLmNyZWF0ZUdyb3VwZXJ9IHRvIHB1dCBhIHBsdXJhbCBmaWVsZCBuYW1lIGluIHRoZSB7QGxpbmsgR3JvdXBlci5wcm9wZXJ0eX0uXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZUdyb3VwZXIocmV2ZXJzZTogYm9vbGVhbik6IEdyb3VwZXIge1xuICAgICAgICByZXR1cm4gbmV3IEdyb3VwZXIodGhpcy5maWVsZE5hbWVQbHVyYWwoKSwgdGhpcy5ncm91cGVyKCksIHJldmVyc2UpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBncm91cGVyUmVnRXhwKCk6IFJlZ0V4cCB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0dyb3VwaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBncm91cGVyUmVnRXhwKCkgdW5pbXBsZW1lbnRlZCBmb3IgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXmdyb3VwIGJ5ICR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX0oIHJldmVyc2UpPyRgKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgU29ydGVyIH0gZnJvbSAnLi4vU29ydGVyJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXJPckVycm9yTWVzc2FnZSc7XG5pbXBvcnQgeyBGaWx0ZXJJbnN0cnVjdGlvbnMgfSBmcm9tICcuL0ZpbHRlckluc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBNdWx0aVRleHRGaWVsZCB9IGZyb20gJy4vTXVsdGlUZXh0RmllbGQnO1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlICd0YWcnIGFuZCAndGFncycgc2VhcmNoIGluc3RydWN0aW9ucy5cbiAqXG4gKiBUYWdzIGNhbiBiZSBzZWFyY2hlZCBmb3Igd2l0aCBhbmQgd2l0aG91dCB0aGUgaGFzaCB0YWcgYXQgdGhlIHN0YXJ0LlxuICovXG5leHBvcnQgY2xhc3MgVGFnc0ZpZWxkIGV4dGVuZHMgTXVsdGlUZXh0RmllbGQge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRmlsdGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbHRlckluc3RydWN0aW9uczogRmlsdGVySW5zdHJ1Y3Rpb25zO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zID0gbmV3IEZpbHRlckluc3RydWN0aW9ucygpO1xuICAgICAgICB0aGlzLmZpbHRlckluc3RydWN0aW9ucy5hZGQoYGhhcyAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX1gLCAodGFzazogVGFzaykgPT4gdGhpcy52YWx1ZXModGFzaykubGVuZ3RoID4gMCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZChgaGFzICR7dGhpcy5maWVsZE5hbWVQbHVyYWwoKX1gLCAodGFzazogVGFzaykgPT4gdGhpcy52YWx1ZXModGFzaykubGVuZ3RoID4gMCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZChgbm8gJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9YCwgKHRhc2s6IFRhc2spID0+IHRoaXMudmFsdWVzKHRhc2spLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmFkZChgbm8gJHt0aGlzLmZpZWxkTmFtZVBsdXJhbCgpfWAsICh0YXNrOiBUYXNrKSA9PiB0aGlzLnZhbHVlcyh0YXNrKS5sZW5ndGggPT09IDApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIGNvbnN0IGZpbHRlclJlc3VsdCA9IHRoaXMuZmlsdGVySW5zdHJ1Y3Rpb25zLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuICAgICAgICBpZiAoZmlsdGVyUmVzdWx0LmZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5DcmVhdGVGaWx0ZXJGb3JMaW5lKGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJJbnN0cnVjdGlvbnMuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY2FuQ3JlYXRlRmlsdGVyRm9yTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lU2luZ3VsYXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICd0YWcnO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWx1ZXModGFzazogVGFzayk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRhc2sudGFncztcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNvcnRpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHVibGljIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqIE92ZXJyaWRkZW4gdG8gYWRkIHN1cHBvcnQgZm9yIHRhZyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVTb3J0ZXJGcm9tTGluZShsaW5lOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHRoaXMuc29ydGVyUmVnRXhwKCkpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9ICEhbWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IHByb3BlcnR5SW5zdGFuY2UgPSBpc05hTigrbWF0Y2hbMl0pID8gMSA6ICttYXRjaFsyXTtcbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IFRhZ3NGaWVsZC5tYWtlQ29tcGFyZUJ5VGFnQ29tcGFyYXRvcihwcm9wZXJ0eUluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZXIodGhpcy5maWVsZE5hbWVTaW5ndWxhcigpLCBjb21wYXJhdG9yLCByZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIG1hdGNoIGEgY29ycmVjdGx5LWZvcm1lZFxuICAgICAqIGluc3RydWN0aW9uIGxpbmUgZm9yIHNvcnRpbmcgVGFza3MgYnkgdGFnLlxuICAgICAqXG4gICAgICogYG1hdGNoWzFdYCB3aWxsIGJlIGVpdGhlciBgcmV2ZXJzZWAgb3IgdW5kZWZpbmVkLlxuICAgICAqIGBtYXRjaFsyXWAgd2lsbCBiZSBlaXRoZXIgdGhlIHRhZyBudW1iZXIgb3IgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzb3J0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIC9ec29ydCBieSB0YWcoIHJldmVyc2UpP1tcXHNdKihcXGQrKT8vO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhICR7QGxpbmsgQ29tcGFyYXRvcn0gdGhhdCBzb3J0cyBieSB0aGUgZmlyc3QgdGFnLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gVGFnc0ZpZWxkLm1ha2VDb21wYXJlQnlUYWdDb21wYXJhdG9yKDEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG1ha2VDb21wYXJlQnlUYWdDb21wYXJhdG9yKHByb3BlcnR5SW5zdGFuY2U6IG51bWJlcik6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIElmIG5vIHRhZ3MgdGhlbiBhc3N1bWUgdGhleSBhcmUgZXF1YWwuXG4gICAgICAgICAgICBpZiAoYS50YWdzLmxlbmd0aCA9PT0gMCAmJiBiLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBhIGlzIGxlc3MgdGhhbiBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBiIGlzIGxlc3MgdGhhbiBhXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcnJheXMgc3RhcnQgYXQgMCBidXQgdGhlIHVzZXJzIHNwZWNpZnkgYSB0YWcgc3RhcnRpbmcgYXQgMS5cbiAgICAgICAgICAgIGNvbnN0IHRhZ0luc3RhbmNlVG9Tb3J0QnkgPSBwcm9wZXJ0eUluc3RhbmNlIC0gMTtcblxuICAgICAgICAgICAgaWYgKGEudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlICYmIGIudGFncy5sZW5ndGggPj0gcHJvcGVydHlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLnRhZ3MubGVuZ3RoIDwgcHJvcGVydHlJbnN0YW5jZSAmJiBhLnRhZ3MubGVuZ3RoID49IHByb3BlcnR5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlICYmIGIudGFncy5sZW5ndGggPCBwcm9wZXJ0eUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ0EgPSBhLnRhZ3NbdGFnSW5zdGFuY2VUb1NvcnRCeV07XG4gICAgICAgICAgICBjb25zdCB0YWdCID0gYi50YWdzW3RhZ0luc3RhbmNlVG9Tb3J0QnldO1xuICAgICAgICAgICAgcmV0dXJuIHRhZ0EubG9jYWxlQ29tcGFyZSh0YWdCLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEdyb3VwaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGlmICh0YXNrLnRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoTm8gdGFncyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXNrLnRhZ3M7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB7IHBhcnNlIGFzIGJvb25QYXJzZSB9IGZyb20gJ2Jvb24tanMnO1xuaW1wb3J0IHR5cGUgeyBQb3N0Zml4RXhwcmVzc2lvbiB9IGZyb20gJ2Jvb24tanMnO1xuXG5pbXBvcnQgeyBwYXJzZUZpbHRlciB9IGZyb20gJy4uL0ZpbHRlclBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB7IEV4cGxhbmF0aW9uIH0gZnJvbSAnLi4vRXhwbGFpbi9FeHBsYW5hdGlvbic7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4vRmllbGQnO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4vRmlsdGVyJztcblxuLyoqXG4gKiBCb29sZWFuRmllbGQgaXMgYSAnY29udGFpbmVyJyBmaWVsZCB0eXBlIHRoYXQgcGFyc2VzIGEgaGlnaC1sZXZlbCBmaWx0ZXJpbmcgcXVlcnkgb2ZcbiAqIHRoZSBmb3JtYXQgLS1cbiAqICAgIChmaWx0ZXIxKSBBTkQgKChmaWx0ZXIyKSBPUiAoZmlsdGVyMykpXG4gKiBUaGUgZmlsdGVycyBjYW4gYmUgbWl4ZWQgYW5kIG1hdGNoZWQgd2l0aCBhbnkgYm9vbGVhbiBvcGVyYXRvcnMgYXMgbG9uZyBhcyB0aGUgaW5kaXZpZHVhbCBmaWx0ZXJzIGFyZVxuICogd3JhcHBlZCBpbiBlaXRoZXIgcGFyZW50aGVzaXMgb3IgcXVvdGVzIC0tIChmaWx0ZXIxKSBvciBcImZpbHRlcjFcIi5cbiAqIFdoYXQgaGFwcGVucyBpbnRlcm5hbGx5IGlzIHRoYXQgd2hlbiB0aGUgYm9vbGVhbiBmaWVsZCBpcyBhc2tlZCB0byBjcmVhdGUgYSBmaWx0ZXIsIGl0IHBhcnNlcyB0aGUgYm9vbGVhblxuICogcXVlcnkgaW50byBhIGxvZ2ljYWwgcG9zdGZpeCBleHByZXNzaW9uIChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZXZlcnNlX1BvbGlzaF9ub3RhdGlvbiksXG4gKiB3aXRoIHRoZSBpbmRpdmlkdWFsIGZpbHRlciBjb21wb25lbnRzIGFzIFwiaWRlbnRpZmllclwiIHRva2Vucy5cbiAqIFRoZXNlIGlkZW50aWZpZXJzIGhhdmUgYW4gYXNzb2NpYXRlZCBhY3R1YWwgRmlsdGVyICh3aGljaCBpcyBjYWNoZWQgZHVyaW5nIHRoZSBxdWVyeSBwYXJzaW5nKS5cbiAqIFRoZSByZXR1cm5lZCBGaWx0ZXIgb2YgdGhlIHdob2xlIGJvb2xlYW4gcXVlcnkgaXMgZXZlbnR1YWxseSBhIGZ1bmN0aW9uIHRoYXQgZm9yIGVhY2ggVGFzayBvYmplY3QsXG4gKiBldmFsdWF0ZXMgdGhlIGNvbXBsZXRlIHBvc3RmaXggZXhwcmVzc2lvbiBieSBnb2luZyB0aHJvdWdoIHRoZSBpbmRpdmlkdWFsIGZpbHRlcnMgYW5kIHRoZW4gcmVzb2x2aW5nXG4gKiB0aGUgZXhwcmVzc2lvbiBpbnRvIGEgc2luZ2xlIGJvb2xlYW4gZW50aXR5LlxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIC8vIEZpcnN0IHBhdHRlcm4gaW4gdGhpcyBtYXRjaGVzIGNvbnZlbnRpb25hbCAoZmlsdGVyMSkgT1IgKGZpbHRlcjIpIGFuZCBzaW1pbGFyXG4gICAgLy8gU2Vjb25kIHBhdHRlcm4gbWF0Y2hlcyAoZmlsdGVyMSkgLSB0aGF0IGlzLCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgZmlsdGVyIGlzIHRyZWF0ZWQgYXMgdmFsaWRcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhc2ljQm9vbGVhblJlZ2V4cCA9IC8oLiooQU5EfE9SfFhPUnxOT1QpXFxzKlsoXCJdLip8XFwoLitcXCkpL2c7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzdXBwb3J0ZWRPcGVyYXRvcnMgPSBbJ0FORCcsICdPUicsICdYT1InLCAnTk9UJ107XG4gICAgcHJpdmF0ZSBzdWJGaWVsZHM6IFJlY29yZDxzdHJpbmcsIEZpbHRlcj4gPSB7fTtcblxuICAgIHByb3RlY3RlZCBmaWx0ZXJSZWdFeHAoKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzaWNCb29sZWFuUmVnZXhwO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVGaWx0ZXJPckVycm9yTWVzc2FnZShsaW5lOiBzdHJpbmcpOiBGaWx0ZXJPckVycm9yTWVzc2FnZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGluZShsaW5lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbiBxdWVyeSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBidWlsZHMgYSBGaWx0ZXIgZm9yIGEgY29tcGxldGUgYm9vbGVhbiBxdWVyeSBieTpcbiAgICAgKiAxLiBQcmVwcm9jZXNzaW5nIHRoZSBleHByZXNzaW9uIGludG8gc29tZXRoaW5nIG91ciBoZWxwZXIgcGFja2FnZSwgYm9vbi1qcywga25vd3MgaG93IHRvIGJ1aWxkIGFuIGV4cHJlc3Npb24gZm9yLlxuICAgICAqIDIuIENyZWF0aW5nIGEgcG9zdGZpeCBsb2dpY2FsIGV4cHJlc3Npb24gdXNpbmcgYm9vbi1qcywgd2hpY2ggaGFzIC1cbiAgICAgKiAgICBhLiBJZGVudGlmaWVycyAobGVhdmVzKSwgd2hpY2ggYXJlIHJlZ3VsYXIgRmllbGQgZmlsdGVycyByZXByZXNlbnRlZCBhcyB0aGVpciBzdHJpbmcuXG4gICAgICogICAgYi4gT3BlcmF0b3JzLCB3aGljaCBhcmUgbG9naWNhbCBvcGVyYXRvcnMgYmV0d2VlbiBpZGVudGlmaWVycyBvciBiZXR3ZWVuIHBhcmVudGhlc2lzLlxuICAgICAqIDMuIENyZWF0aW5nIHRoZSBmaWx0ZXIgZnVuY3Rpb25zIGZvciBhbGwgdGhlIElkZW50aWZpZXJzIGluIHRoZSBleHByZXNzaW9uIGFuZCBjYWNoaW5nIHRoZW0gaW4gdGhpcy5zdWJGaWVsZHMuXG4gICAgICogNC4gUmV0dXJuaW5nIGEgZmluYWwgZnVuY3Rpb24gZmlsdGVyLCB3aGljaCBmb3IgZWFjaCBUYXNrIGNhbiBydW4gdGhlIGNvbXBsZXRlIHF1ZXJ5LlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFyc2VMaW5lKGxpbmU6IHN0cmluZyk6IEZpbHRlck9yRXJyb3JNZXNzYWdlIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsICdlbXB0eSBsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcHJvY2Vzc2VkID0gdGhpcy5wcmVwcm9jZXNzRXhwcmVzc2lvbihsaW5lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIChwcmVwcm9jZXNzZWQpIGxpbmUgaW50byBhIHBvc3RmaXggbG9naWNhbCBleHByZXNzaW9uXG4gICAgICAgICAgICBjb25zdCBwb3N0Zml4RXhwcmVzc2lvbiA9IGJvb25QYXJzZShwcmVwcm9jZXNzZWQpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHN1Yi1maWVsZCBtYXAsIGkuZS4gaGF2ZSBzdWJGaWVsZHMgaW5jbHVkZSBhIGZpbHRlciBmdW5jdGlvbiBmb3IgZXZlcnlcbiAgICAgICAgICAgIC8vIGZpbmFsIHRva2VuIGluIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09ICdJREVOVElGSUVSJyAmJiB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gdG9rZW4udmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpZGVudGlmaWVyIGluIHRoaXMuc3ViRmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkRmllbGQgPSBwYXJzZUZpbHRlcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRGaWVsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBjb3VsZG4ndCBwYXJzZSBzdWItZXhwcmVzc2lvbiAnJHtpZGVudGlmaWVyfSdgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmllbGQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgY291bGRuJ3QgcGFyc2Ugc3ViLWV4cHJlc3Npb24gJyR7aWRlbnRpZmllcn0nOiAke3BhcnNlZEZpZWxkLmVycm9yfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VkRmllbGQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJGaWVsZHNbaWRlbnRpZmllcl0gPSBwYXJzZWRGaWVsZC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdPUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UncmUgYWxyZWFkeSBpdGVyYXRpbmcgb3ZlciB0aGUgZXhwcmVzc2lvbiwgYWx0aG91Z2ggd2UgZG9uJ3QgbmVlZCB0aGUgb3BlcmF0b3JzIGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc3RhZ2UgYnV0IG9ubHkgaW4gZmlsdGVyVGFza1dpdGhQYXJzZWRRdWVyeSBiZWxvdywgd2UncmUgdXNpbmcgdGhlIG9wcG9ydHVuaXR5IHRvIHZlcmlmeVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSB2YWxpZC4gSWYgd2Ugd29uJ3QsIHRoZW4gYW4gaW52YWxpZCBvcGVyYXRvciB3aWxsIG9ubHkgYmUgZGV0ZWN0ZWQgd2hlbiB0aGUgcXVlcnkgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIG9uIGEgdGFza1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsICdlbXB0eSBvcGVyYXRvciBpbiBib29sZWFuIHF1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZE9wZXJhdG9ycy5pbmNsdWRlcyh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IobGluZSwgYHVua25vd24gYm9vbGVhbiBvcGVyYXRvciAnJHt0b2tlbi52YWx1ZX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpbHRlciB3aXRoIGZpbHRlciBmdW5jdGlvbiB0aGF0IGNhbiBydW4gdGhlIGNvbXBsZXRlIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGdW5jdGlvbiA9ICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyVGFza1dpdGhQYXJzZWRRdWVyeSh0YXNrLCBwb3N0Zml4RXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSB0aGlzLmNvbnN0cnVjdEV4cGxhbmF0aW9uKHBvc3RmaXhFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRmlsdGVyKG5ldyBGaWx0ZXIobGluZSwgZmlsdGVyRnVuY3Rpb24sIGV4cGxhbmF0aW9uKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93biBlcnJvciB0eXBlJztcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJPckVycm9yTWVzc2FnZS5mcm9tRXJyb3IoXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBgbWFsZm9ybWVkIGJvb2xlYW4gcXVlcnkgLS0gJHttZXNzYWdlfSAoY2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGd1aWRlbGluZXMpYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXByb2Nlc3NFeHByZXNzaW9uKGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHF1ZXJ5IHRvIGJlIHByb2Nlc3NlZCBieSBib29uLWpzLlxuICAgICAgICAvLyBCb29uIGRvZXNuJ3QgcHJvY2VzcyBleHByZXNzaW9uIHdpdGggc3BhY2VzIHVubGVzcyB0aGV5IGFyZSBzdXJyb3VuZGVkIGJ5IHF1b3Rlcywgc28gcmVwbGFjZVxuICAgICAgICAvLyAoZHVlIHRvZGF5KSBieSAoXCJkdWUgdG9kYXlcIikuXG4gICAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoL1xcKChbXigpXSspXFwpL2csICcoXCIkMVwiKScpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhpcyBydW4gYSBUYXNrIG9iamVjdCB0aHJvdWdoIGEgY29tcGxldGUgYm9vbGVhbiBleHByZXNzaW9uLlxuICAgICAqIEl0IGJhc2ljYWxseSByZXNvbHZlcyB0aGUgcG9zdGZpeCBleHByZXNzaW9uIHVudGlsIGl0IGlzIHJlZHVjZWQgaW50byBhIHNpbmdsZSBib29sZWFuIHZhbHVlLFxuICAgICAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXBsZXRlIGV4cHJlc3Npb24uXG4gICAgICogU2VlIGhlcmUgaG93IGl0IHdvcmtzOiBodHRwOi8vd3d3LmJ0ZWNoc21hcnRjbGFzcy5jb20vZGF0YV9zdHJ1Y3R1cmVzL3Bvc3RmaXgtZXZhbHVhdGlvbi5odG1sXG4gICAgICogQW5vdGhlciByZWZlcmVuY2U6IGh0dHBzOi8vd3d3LnR1dG9yaWFsc3BvaW50LmNvbS9FdmFsdWF0ZS1Qb3N0Zml4LUV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbHRlclRhc2tXaXRoUGFyc2VkUXVlcnkodGFzazogVGFzaywgcG9zdGZpeEV4cHJlc3Npb246IFBvc3RmaXhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHRvQm9vbCA9IChzOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzID09PSAndHJ1ZSc7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvU3RyaW5nID0gKGI6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9vbGVhblN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ0lERU5USUZJRVInKSB7XG4gICAgICAgICAgICAgICAgLy8gSWRlbnRpZmllcnMgYXJlIHRoZSBzdWItZmllbGRzIG9mIHRoZSBleHByZXNzaW9uLCB0aGUgYWN0dWFsIGZpbHRlcnMsIGUuZy4gJ2Rlc2NyaXB0aW9uIGluY2x1ZGVzIGZvbycuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggaWRlbnRpZmllciB3ZSBjcmVhdGVkIGVhcmxpZXIgdGhlIGNvcnJlc3BvbmRpbmcgRmlsdGVyLCBzbyBub3cgd2UgY2FuIGp1c3QgZXZhbHVhdGUgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdGFzayBmb3IgZWFjaCBpZGVudGlmaWVyIHRoYXQgd2UgZmluZCBpbiB0aGUgcG9zdGZpeCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSBudWxsKSB0aHJvdyBFcnJvcignbnVsbCB0b2tlbiB2YWx1ZScpOyAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5zdWJGaWVsZHNbdG9rZW4udmFsdWUudHJpbSgpXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaWx0ZXIuZmlsdGVyRnVuY3Rpb24odGFzayk7XG4gICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcocmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdPUEVSQVRPUicpIHtcbiAgICAgICAgICAgICAgICAvLyBUbyBldmFsdWF0ZSBhbiBvcGVyYXRvciB3ZSBuZWVkIHRvIHBvcCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJvb2xlYW4gc3RhY2ssXG4gICAgICAgICAgICAgICAgLy8gZG8gdGhlIGxvZ2ljYWwgZXZhbHVhdGlvbiBhbmQgcHVzaCBiYWNrIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdOT1QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoIWFyZzEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuU3RhY2sucHVzaCh0b1N0cmluZyhhcmcxIHx8IGFyZzIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnQU5EJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSB0b0Jvb2woYm9vbGVhblN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhblN0YWNrLnB1c2godG9TdHJpbmcoYXJnMSAmJiBhcmcyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1hPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMSA9IHRvQm9vbChib29sZWFuU3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcyID0gdG9Cb29sKGJvb2xlYW5TdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5TdGFjay5wdXNoKHRvU3RyaW5nKChhcmcxICYmICFhcmcyKSB8fCAoIWFyZzEgJiYgYXJnMikpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcgKyB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgdG9rZW4gdHlwZTogJyArIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVudHVhbGx5IHRoZSByZXN1bHQgb2YgdGhlIGV4cHJlc3Npb24gZm9yIHRoaXMgVGFzayBpcyB0aGUgb25seSBpdGVtIGxlZnQgaW4gdGhlIGJvb2xlYW4gc3RhY2tcbiAgICAgICAgcmV0dXJuIHRvQm9vbChib29sZWFuU3RhY2tbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgRXhwbGFuYXRpb259IHJlcHJlc2VudGluZyB0aGUgY29tcGxldGUgQm9vbGVhbiBpbnN0cnVjdGlvbiBjdXJyZW50bHkgYmVpbmcgYW5hbHlzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zdGZpeEV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGNvbnN0cnVjdEV4cGxhbmF0aW9uKHBvc3RmaXhFeHByZXNzaW9uOiBQb3N0Zml4RXhwcmVzc2lvbik6IEV4cGxhbmF0aW9uIHtcbiAgICAgICAgLy8gRm9yIGFuIGV4cGxhbmF0aW9uIG9mIHRoZSBjb2RlLCBzZWUgdGhlIEpTZG9jIGFuZCBjb21tZW50cyBvZiBmaWx0ZXJUYXNrV2l0aFBhcnNlZFF1ZXJ5KClcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25TdGFjazogRXhwbGFuYXRpb25bXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvc3RmaXhFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ0lERU5USUZJRVInKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHRocm93IEVycm9yKCdudWxsIHRva2VuIHZhbHVlJyk7IC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnN1YkZpZWxkc1t0b2tlbi52YWx1ZS50cmltKCldO1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uU3RhY2sucHVzaChmaWx0ZXIuZXhwbGFuYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnT1BFUkFUT1InKSB7XG4gICAgICAgICAgICAgICAgLy8gVG8gZXZhbHVhdGUgYW4gb3BlcmF0b3Igd2UgbmVlZCB0byBwb3AgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBib29sZWFuIHN0YWNrLFxuICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBsb2dpY2FsIGV2YWx1YXRpb24gYW5kIHB1c2ggYmFjayB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnTk9UJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Ob3QoW2FyZzEhXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdPUicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IGV4cGxhbmF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleHBsYW5hdGlvblN0YWNrLnB1c2goRXhwbGFuYXRpb24uYm9vbGVhbk9yKFthcmcxISwgYXJnMiFdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ0FORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnMiA9IGV4cGxhbmF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzEgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBleHBsYW5hdGlvblN0YWNrLnB1c2goRXhwbGFuYXRpb24uYm9vbGVhbkFuZChbYXJnMSEsIGFyZzIhXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdYT1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZzIgPSBleHBsYW5hdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcxID0gZXhwbGFuYXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwbGFuYXRpb25TdGFjay5wdXNoKEV4cGxhbmF0aW9uLmJvb2xlYW5Yb3IoW2FyZzEhLCBhcmcyIV0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcgKyB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgdG9rZW4gdHlwZTogJyArIHRva2VuLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW50dWFsbHkgdGhlIEV4cGxhbmF0aW9uIGlzIHRoZSBvbmx5IGl0ZW0gbGVmdCBpbiB0aGUgYm9vbGVhbiBzdGFja1xuICAgICAgICByZXR1cm4gZXhwbGFuYXRpb25TdGFja1swXTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKiogU3VwcG9ydCB0aGUgJ2ZpbGVuYW1lJyBzZWFyY2ggaW5zdHJ1Y3Rpb24uXG4gKlxuICogTm90ZSB0aGF0IHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFsc28gc2VhcmNoZXMgdGhlIGZpbGUgZXh0ZW5zaW9uLFxuICogc28gJ2ZpbGVuYW1lIGluY2x1ZGVzIC5tZCcgd2lsbCB0eXBpY2FsbHkgbWF0Y2ggYWxsIHRhc2tzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVuYW1lRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdmaWxlbmFtZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsZSBuYW1lIGluY2x1ZGluZyBmaWxlIGV4dGVuc2lvbiwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSB0YXNrIGRvZXMgbm90IGhhdmUgYSBmaWxlbmFtZVxuICAgICAqIEBwYXJhbSB0YXNrXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1YmxpYyB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0YXNrLmZpbGVuYW1lO1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZW5hbWUgKyAnLm1kJztcbiAgICB9XG5cbiAgICBzdXBwb3J0c1NvcnRpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0c0dyb3VwaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBlcigpOiBHcm91cGVyRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGUgY3VycmVudCBsaW1pdGF0aW9uOiBUYXNrcyBmcm9tIGRpZmZlcmVudCBub3RlcyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBuYW1lIHdpbGwgYmUgZ3JvdXBlZCB0b2dldGhlciwgZXZlbiB0aG91Z2ggdGhleSBhcmUgaW5cbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBmaWxlcyBhbmQgdGhlaXIgbGlua3Mgd2lsbCBsb29rIGRpZmZlcmVudC5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGFzay5maWxlbmFtZTtcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ1Vua25vd24gTG9jYXRpb24nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ1tbJyArIGZpbGVuYW1lICsgJ11dJ107XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgVGFzayB9IGZyb20gJy4uLy4uL1Rhc2snO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG4vKipcbiAqIEEge0BsaW5rIEZpZWxkfSBpbXBsZW1lbnRhdGlvbiBmb3Igc2VhcmNoaW5nIHN0YXR1cy5uYW1lXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0dXNOYW1lRmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdzdGF0dXMubmFtZSc7XG4gICAgfVxuXG4gICAgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0YXNrLnN0YXR1cy5uYW1lO1xuICAgIH1cblxuICAgIHN1cHBvcnRzU29ydGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBTdGF0dXNUeXBlIH0gZnJvbSAnLi4vLi4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSB7IENvbXBhcmF0b3IgfSBmcm9tICcuLi9Tb3J0ZXInO1xuaW1wb3J0IHsgRXhwbGFuYXRpb24gfSBmcm9tICcuLi9FeHBsYWluL0V4cGxhbmF0aW9uJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL0ZpbHRlcic7XG5pbXBvcnQgdHlwZSB7IEZpbHRlckZ1bmN0aW9uIH0gZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyT3JFcnJvck1lc3NhZ2UgfSBmcm9tICcuL0ZpbHRlck9yRXJyb3JNZXNzYWdlJztcblxuLyoqXG4gKiBBICR7QGxpbmsgRmllbGR9IGltcGxlbWVudGF0aW9uIGZvciBzZWFyY2hpbmcgc3RhdHVzLnR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXR1c1R5cGVGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZpbHRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHVibGljIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUobGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFVzZSBhIHJlbGF4ZWQgcmVnZXhwLCBqdXN0IGNoZWNraW5nIGZpZWxkIG5hbWUgYW5kIG5vdCB0aGUgY29udGVudHMsXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHBhcnNlIHRoZSBsaW5lIGxhdGVyIGFuZCBnaXZlIG1lYW5pbmdmdWwgZXJyb3JzIGlmIHVzZXIgdXNlcyBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgY29uc3QgcmVsYXhlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoYF4oPzoke3RoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCl9KWApO1xuICAgICAgICByZXR1cm4gRmllbGQubGluZU1hdGNoZXNGaWx0ZXIocmVsYXhlZFJlZ0V4cCwgbGluZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IEZpZWxkLmdldE1hdGNoKHRoaXMuZmlsdGVyUmVnRXhwKCksIGxpbmUpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgT0sgdG8gZ2V0IGhlcmUsIGJlY2F1c2UgY2FuQ3JlYXRlRmlsdGVyRm9yTGluZSgpIHVzZXMgYSBtb3JlIHJlbGF4ZWQgcmVnZXhwLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVscE1lc3NhZ2UobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbXywgZmlsdGVyT3BlcmF0b3IsIHN0YXR1c1R5cGVBc1N0cmluZ10gPSBtYXRjaDtcblxuICAgICAgICBjb25zdCBzdGF0dXNUeXBlRWxlbWVudCA9IFN0YXR1c1R5cGVbc3RhdHVzVHlwZUFzU3RyaW5nLnRvVXBwZXJDYXNlKCkgYXMga2V5b2YgdHlwZW9mIFN0YXR1c1R5cGVdO1xuICAgICAgICBpZiAoIXN0YXR1c1R5cGVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWxwTWVzc2FnZShsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaWx0ZXJGdW5jdGlvbjogRmlsdGVyRnVuY3Rpb247XG5cbiAgICAgICAgc3dpdGNoIChmaWx0ZXJPcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAnaXMnOlxuICAgICAgICAgICAgICAgIGZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suc3RhdHVzLnR5cGUgPT09IHN0YXR1c1R5cGVFbGVtZW50O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpcyBub3QnOlxuICAgICAgICAgICAgICAgIGZpbHRlckZ1bmN0aW9uID0gKHRhc2s6IFRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suc3RhdHVzLnR5cGUgIT09IHN0YXR1c1R5cGVFbGVtZW50O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlbHBNZXNzYWdlKGxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21GaWx0ZXIobmV3IEZpbHRlcihsaW5lLCBmaWx0ZXJGdW5jdGlvbiwgbmV3IEV4cGxhbmF0aW9uKGxpbmUpKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbHRlclJlZ0V4cCgpOiBSZWdFeHAgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPzoke3RoaXMuZmllbGROYW1lU2luZ3VsYXJFc2NhcGVkKCl9KSAoaXN8aXMgbm90KSAoW14gXSspJGApO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGVscE1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBPYmplY3QudmFsdWVzKFN0YXR1c1R5cGUpXG4gICAgICAgICAgICAuZmlsdGVyKCh0KSA9PiB0ICE9PSBTdGF0dXNUeXBlLkVNUFRZKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEludmFsaWQgJHt0aGlzLmZpZWxkTmFtZVNpbmd1bGFyKCl9IGluc3RydWN0aW9uOiAnJHtsaW5lfScuXG4gICAgQWxsb3dlZCBvcHRpb25zOiAnaXMnIGFuZCAnaXMgbm90JyAod2l0aG91dCBxdW90ZXMpLlxuICAgIEFsbG93ZWQgdmFsdWVzOiAgJHthbGxvd2VkVHlwZXN9XG4gICAgICAgICAgICAgICAgICAgICBOb3RlOiB2YWx1ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzbyAnaW5fcHJvZ3Jlc3MnIHdvcmtzIHRvbywgZm9yIGV4YW1wbGUuXG4gICAgRXhhbXBsZTogICAgICAgICAke3RoaXMuZmllbGROYW1lU2luZ3VsYXIoKX0gaXMgbm90IE5PTl9UQVNLYDtcbiAgICAgICAgcmV0dXJuIEZpbHRlck9yRXJyb3JNZXNzYWdlLmZyb21FcnJvcihsaW5lLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmllbGROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnc3RhdHVzLnR5cGUnO1xuICAgIH1cblxuICAgIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5zdGF0dXMudHlwZTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNvcnRpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc3VwcG9ydHNTb3J0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wYXJhdG9yKCk6IENvbXBhcmF0b3Ige1xuICAgICAgICByZXR1cm4gKGE6IFRhc2ssIGI6IFRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleUEgPSBTdGF0dXNUeXBlRmllbGQuZ3JvdXBOYW1lKGEpO1xuICAgICAgICAgICAgY29uc3Qga2V5QiA9IFN0YXR1c1R5cGVGaWVsZC5ncm91cE5hbWUoYik7XG4gICAgICAgICAgICByZXR1cm4ga2V5QS5sb2NhbGVDb21wYXJlKGtleUIsIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR3JvdXBpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtTdGF0dXNUeXBlRmllbGQuZ3JvdXBOYW1lKHRhc2spXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBncm91cE5hbWUodGFzazogVGFzaykge1xuICAgICAgICBsZXQgcHJlZml4OiBzdHJpbmc7XG4gICAgICAgIC8vIEFkZCBhIG51bWVyaWMgcHJlZml4IHRvIHNvcnQgaW4gdG8gYSBtZWFuaW5nZnVsIG9yZGVyIGZvciB1c2Vyc1xuICAgICAgICBzd2l0Y2ggKHRhc2suc3RhdHVzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUzpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnMSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuVE9ETzpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnMic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuRE9ORTpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnMyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuQ0FOQ0VMTEVEOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICc0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdHVzVHlwZS5OT05fVEFTSzpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnNSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXR1c1R5cGUuRU1QVFk6XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJzYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRleHQgaW5zaWRlIHRoZSAlJS4uJSUgY29tbWVudHMgaXMgdXNlZCB0byBjb250cm9sIHRoZSBzb3J0aW5nIGluIGJvdGggc29ydGluZyBvZiB0YXNrcyBhbmQgbmFtaW5nIG9mIGdyb3Vwcy5cbiAgICAgICAgLy8gVGhlIGNvbW1lbnRzIGFyZSBoaWRkZW4gYnkgT2JzaWRpYW4gd2hlbiB0aGUgaGVhZGluZ3MgYXJlIHJlbmRlcmVkLlxuICAgICAgICByZXR1cm4gYCUlJHtwcmVmaXh9JSUke3Rhc2suc3RhdHVzLnR5cGV9YDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi4vLi4vVGFzayc7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXJGdW5jdGlvbiB9IGZyb20gJy4uL0dyb3VwZXInO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgUmVjdXJyZW5jZUZpZWxkIGV4dGVuZHMgVGV4dEZpZWxkIHtcbiAgICBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdyZWN1cnJlbmNlJztcbiAgICB9XG5cbiAgICB2YWx1ZSh0YXNrOiBUYXNrKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRhc2sucmVjdXJyZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucmVjdXJyZW5jZSEudG9UZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0YXNrLnJlY3VycmVuY2UhLnRvVGV4dCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTm9uZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBGb2xkZXJGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2ZvbGRlcic7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbHVlKHRhc2s6IFRhc2spOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGFzay5maWxlLmZvbGRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1RleHRGaWVsZC5lc2NhcGVNYXJrZG93bkNoYXJhY3RlcnModGhpcy52YWx1ZSh0YXNrKSldO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBUZXh0RmllbGQgfSBmcm9tICcuL1RleHRGaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSb290RmllbGQgZXh0ZW5kcyBUZXh0RmllbGQge1xuICAgIHB1YmxpYyBmaWVsZE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdyb290JztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0YXNrLmZpbGUucm9vdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHNHcm91cGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwZXIoKTogR3JvdXBlckZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuICh0YXNrOiBUYXNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1RleHRGaWVsZC5lc2NhcGVNYXJrZG93bkNoYXJhY3RlcnModGhpcy52YWx1ZSh0YXNrKSldO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi8uLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgR3JvdXBlckZ1bmN0aW9uIH0gZnJvbSAnLi4vR3JvdXBlcic7XG5pbXBvcnQgeyBGaWx0ZXJPckVycm9yTWVzc2FnZSB9IGZyb20gJy4vRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY2xhc3MgQmFja2xpbmtGaWVsZCBleHRlbmRzIFRleHRGaWVsZCB7XG4gICAgcHVibGljIGZpZWxkTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2JhY2tsaW5rJztcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWUodGFzazogVGFzayk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGxpbmtUZXh0ID0gdGFzay5nZXRMaW5rVGV4dCh7IGlzRmlsZW5hbWVVbmlxdWU6IHRydWUgfSk7XG4gICAgICAgIGlmIChsaW5rVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIExvY2F0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlua1RleHQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRmlsdGVyT3JFcnJvck1lc3NhZ2UobGluZTogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2Uge1xuICAgICAgICByZXR1cm4gRmlsdGVyT3JFcnJvck1lc3NhZ2UuZnJvbUVycm9yKGxpbmUsICdiYWNrbGluayBmaWVsZCBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcmluZycpO1xuICAgIH1cblxuICAgIGNhbkNyZWF0ZUZpbHRlckZvckxpbmUoX2xpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIHN1cHBvcnRzR3JvdXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cGVyKCk6IEdyb3VwZXJGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiAodGFzazogVGFzaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0YXNrLmZpbGVuYW1lO1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnVW5rbm93biBMb2NhdGlvbiddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0YXNrLnByZWNlZGluZ0hlYWRlcjtcbiAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydbWycgKyBmaWxlbmFtZSArICddXSddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgYXBwZW5kIHRoZSBoZWFkZXIsIHRvIGVuc3VyZSB3ZSBuYXZpZ2F0ZSB0byB0aGUgY29ycmVjdCBzZWN0aW9uIG9mIHRoZSBmaWxlOlxuICAgICAgICAgICAgcmV0dXJuIFtgW1ske2ZpbGVuYW1lfSMke2hlYWRlcn18JHtmaWxlbmFtZX0gPiAke2hlYWRlcn1dXWBdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRmllbGQnO1xuaW1wb3J0IHsgRGVzY3JpcHRpb25GaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Rlc2NyaXB0aW9uRmllbGQnO1xuaW1wb3J0IHsgQ3JlYXRlZERhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0NyZWF0ZWREYXRlRmllbGQnO1xuaW1wb3J0IHsgRG9uZURhdGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0RvbmVEYXRlRmllbGQnO1xuaW1wb3J0IHsgRHVlRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRHVlRGF0ZUZpZWxkJztcbmltcG9ydCB7IEV4Y2x1ZGVTdWJJdGVtc0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRXhjbHVkZVN1Ykl0ZW1zRmllbGQnO1xuaW1wb3J0IHsgRnVuY3Rpb25GaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Z1bmN0aW9uRmllbGQnO1xuaW1wb3J0IHsgSGVhZGluZ0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvSGVhZGluZ0ZpZWxkJztcbmltcG9ydCB7IFBhdGhGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1BhdGhGaWVsZCc7XG5pbXBvcnQgeyBQcmlvcml0eUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvUHJpb3JpdHlGaWVsZCc7XG5pbXBvcnQgeyBTY2hlZHVsZWREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TY2hlZHVsZWREYXRlRmllbGQnO1xuaW1wb3J0IHsgU3RhcnREYXRlRmllbGQgfSBmcm9tICcuL0ZpbHRlci9TdGFydERhdGVGaWVsZCc7XG5pbXBvcnQgeyBIYXBwZW5zRGF0ZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvSGFwcGVuc0RhdGVGaWVsZCc7XG5pbXBvcnQgeyBSZWN1cnJpbmdGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1JlY3VycmluZ0ZpZWxkJztcbmltcG9ydCB7IFN0YXR1c0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzRmllbGQnO1xuaW1wb3J0IHsgVGFnc0ZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvVGFnc0ZpZWxkJztcbmltcG9ydCB7IEJvb2xlYW5GaWVsZCB9IGZyb20gJy4vRmlsdGVyL0Jvb2xlYW5GaWVsZCc7XG5pbXBvcnQgeyBGaWxlbmFtZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvRmlsZW5hbWVGaWVsZCc7XG5pbXBvcnQgeyBVcmdlbmN5RmllbGQgfSBmcm9tICcuL0ZpbHRlci9VcmdlbmN5RmllbGQnO1xuaW1wb3J0IHsgU3RhdHVzTmFtZUZpZWxkIH0gZnJvbSAnLi9GaWx0ZXIvU3RhdHVzTmFtZUZpZWxkJztcbmltcG9ydCB7IFN0YXR1c1R5cGVGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1N0YXR1c1R5cGVGaWVsZCc7XG5cbmltcG9ydCB7IFJlY3VycmVuY2VGaWVsZCB9IGZyb20gJy4vRmlsdGVyL1JlY3VycmVuY2VGaWVsZCc7XG5pbXBvcnQgdHlwZSB7IEZpbHRlck9yRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9GaWx0ZXIvRmlsdGVyT3JFcnJvck1lc3NhZ2UnO1xuaW1wb3J0IHR5cGUgeyBTb3J0ZXIgfSBmcm9tICcuL1NvcnRlcic7XG5pbXBvcnQgdHlwZSB7IEdyb3VwZXIgfSBmcm9tICcuL0dyb3VwZXInO1xuaW1wb3J0IHsgRm9sZGVyRmllbGQgfSBmcm9tICcuL0ZpbHRlci9Gb2xkZXJGaWVsZCc7XG5pbXBvcnQgeyBSb290RmllbGQgfSBmcm9tICcuL0ZpbHRlci9Sb290RmllbGQnO1xuaW1wb3J0IHsgQmFja2xpbmtGaWVsZCB9IGZyb20gJy4vRmlsdGVyL0JhY2tsaW5rRmllbGQnO1xuXG4vLyBXaGVuIHBhcnNpbmcgYSBxdWVyeSB0aGUgZmllbGRzIGFyZSB0ZXN0ZWQgb25lIGJ5IG9uZSBhY2NvcmRpbmcgdG8gdGhpcyBvcmRlci5cbi8vIFNpbmNlIEJvb2xlYW5GaWVsZCBpcyBhIG1ldGEtZmllbGQsIHdoaWNoIG5lZWRzIHRvIGFnZ3JlZ2F0ZSBhIGZldyBmaWVsZHMgdG9nZXRoZXIsIGl0IGlzIGludGVuZGVkIHRvXG4vLyBiZSBrZXB0IGxhc3QuXG4vLyBXaGVuIGFkZGluZyBuZXcgZmllbGRzIGtlZXAgdGhpcyBvcmRlciBpbiBtaW5kLCBwdXR0aW5nIGZpZWxkcyB0aGF0IGFyZSBtb3JlIHNwZWNpZmljIGJlZm9yZSBmaWVsZHMgdGhhdFxuLy8gbWF5IGNvbnRhaW4gdGhlbSwgYW5kIGtlZXAgQm9vbGVhbkZpZWxkIGxhc3QuXG5leHBvcnQgY29uc3QgZmllbGRDcmVhdG9yczogRW5kc1dpdGg8Qm9vbGVhbkZpZWxkPiA9IFtcbiAgICAoKSA9PiBuZXcgU3RhdHVzTmFtZUZpZWxkKCksIC8vIHN0YXR1cy5uYW1lIGlzIGJlZm9yZSBzdGF0dXMsIHRvIGF2b2lkIGFtYmlndWl0eVxuICAgICgpID0+IG5ldyBTdGF0dXNUeXBlRmllbGQoKSwgLy8gc3RhdHVzLnR5cGUgaXMgYmVmb3JlIHN0YXR1cywgdG8gYXZvaWQgYW1iaWd1aXR5XG4gICAgKCkgPT4gbmV3IFN0YXR1c0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFJlY3VycmluZ0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFByaW9yaXR5RmllbGQoKSxcbiAgICAoKSA9PiBuZXcgSGFwcGVuc0RhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBDcmVhdGVkRGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFN0YXJ0RGF0ZUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFNjaGVkdWxlZERhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBEdWVEYXRlRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRG9uZURhdGVGaWVsZCgpLFxuICAgICgpID0+IG5ldyBQYXRoRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRm9sZGVyRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgUm9vdEZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEJhY2tsaW5rRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgRGVzY3JpcHRpb25GaWVsZCgpLFxuICAgICgpID0+IG5ldyBUYWdzRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgSGVhZGluZ0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEV4Y2x1ZGVTdWJJdGVtc0ZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEZpbGVuYW1lRmllbGQoKSxcbiAgICAoKSA9PiBuZXcgVXJnZW5jeUZpZWxkKCksXG4gICAgKCkgPT4gbmV3IFJlY3VycmVuY2VGaWVsZCgpLFxuICAgICgpID0+IG5ldyBGdW5jdGlvbkZpZWxkKCksXG4gICAgKCkgPT4gbmV3IEJvb2xlYW5GaWVsZCgpLCAvLyAtLS0gUGxlYXNlIG1ha2Ugc3VyZSB0byBrZWVwIEJvb2xlYW5GaWVsZCBsYXN0IChzZWUgY29tbWVudCBhYm92ZSkgLS0tXG5dO1xuXG4vLyBUaGlzIHR5cGUgaGVscHMgdmVyaWZ5IHRoYXQgQm9vbGVhbkZpZWxkIGlzIGtlcHQgbGFzdFxudHlwZSBFbmRzV2l0aDxFbmQsIFQgZXh0ZW5kcyBGaWVsZCA9IEZpZWxkPiA9IFsuLi5BcnJheTwoKSA9PiBUPiwgKCkgPT4gRW5kXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmlsdGVyKGZpbHRlclN0cmluZzogc3RyaW5nKTogRmlsdGVyT3JFcnJvck1lc3NhZ2UgfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IGNyZWF0b3Igb2YgZmllbGRDcmVhdG9ycykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNyZWF0b3IoKTtcbiAgICAgICAgaWYgKGZpZWxkLmNhbkNyZWF0ZUZpbHRlckZvckxpbmUoZmlsdGVyU3RyaW5nKSkgcmV0dXJuIGZpZWxkLmNyZWF0ZUZpbHRlck9yRXJyb3JNZXNzYWdlKGZpbHRlclN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTb3J0ZXIoc29ydGVyU3RyaW5nOiBzdHJpbmcpOiBTb3J0ZXIgfCBudWxsIHtcbiAgICAvLyBOZXcgc3R5bGUgcGFyc2luZywgdXNpbmcgc29ydGluZyB3aGljaCBpcyBkb25lIGJ5IHRoZSBGaWVsZCBjbGFzc2VzLlxuXG4gICAgLy8gT3B0aW1pc2F0aW9uOiBDaGVjayB3aGV0aGVyIGxpbmUgYmVnaW5zIHdpdGggJ3NvcnQgYnknXG4gICAgY29uc3Qgc29ydEJ5UmVnZXhwID0gL15zb3J0IGJ5IC87XG4gICAgaWYgKHNvcnRlclN0cmluZy5tYXRjaChzb3J0QnlSZWdleHApID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBpZiBhbnkgb2YgdGhlIGZpZWxkcyBjYW4gcGFyc2UgdGhlIGxpbmUuXG4gICAgZm9yIChjb25zdCBjcmVhdG9yIG9mIGZpZWxkQ3JlYXRvcnMpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBjcmVhdG9yKCk7XG4gICAgICAgIGNvbnN0IHNvcnRlciA9IGZpZWxkLmNyZWF0ZVNvcnRlckZyb21MaW5lKHNvcnRlclN0cmluZyk7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUdyb3VwZXIobGluZTogc3RyaW5nKTogR3JvdXBlciB8IG51bGwge1xuICAgIC8vIE5ldyBzdHlsZSBwYXJzaW5nLCB1c2luZyBncm91cGluZyB3aGljaCBpcyBkb25lIGJ5IHRoZSBGaWVsZCBjbGFzc2VzLlxuXG4gICAgLy8gT3B0aW1pc2F0aW9uOiBDaGVjayB3aGV0aGVyIGxpbmUgYmVnaW5zIHdpdGggJ2dyb3VwIGJ5J1xuICAgIGNvbnN0IGdyb3VwQnlSZWdleHAgPSAvXmdyb3VwIGJ5IC87XG4gICAgaWYgKGxpbmUubWF0Y2goZ3JvdXBCeVJlZ2V4cCkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgZmllbGRzIGNhbiBwYXJzZSB0aGUgbGluZS5cbiAgICBmb3IgKGNvbnN0IGNyZWF0b3Igb2YgZmllbGRDcmVhdG9ycykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNyZWF0b3IoKTtcbiAgICAgICAgY29uc3QgZ3JvdXBlciA9IGZpZWxkLmNyZWF0ZUdyb3VwZXJGcm9tTGluZShsaW5lKTtcbiAgICAgICAgaWYgKGdyb3VwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuIiwgImltcG9ydCB7IFRhc2tHcm91cHMgfSBmcm9tICcuL1Rhc2tHcm91cHMnO1xuaW1wb3J0IHR5cGUgeyBUYXNrR3JvdXAgfSBmcm9tICcuL1Rhc2tHcm91cCc7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVJlc3VsdCB7XG4gICAgcHVibGljIHJlYWRvbmx5IHRhc2tHcm91cHM6IFRhc2tHcm91cHM7XG4gICAgcHJpdmF0ZSBfc2VhcmNoRXJyb3JNZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihncm91cHM6IFRhc2tHcm91cHMpIHtcbiAgICAgICAgdGhpcy50YXNrR3JvdXBzID0gZ3JvdXBzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2VhcmNoRXJyb3JNZXNzYWdlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWFyY2hFcnJvck1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXQgc2VhcmNoRXJyb3JNZXNzYWdlKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc2VhcmNoRXJyb3JNZXNzYWdlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB0b3RhbFRhc2tzQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza0dyb3Vwcy50b3RhbFRhc2tzQ291bnQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGdyb3VwcygpOiBUYXNrR3JvdXBbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2tHcm91cHMuZ3JvdXBzO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tRXJyb3IobWVzc2FnZTogc3RyaW5nKTogUXVlcnlSZXN1bHQge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVlcnlSZXN1bHQobmV3IFRhc2tHcm91cHMoW10sIFtdKSk7XG4gICAgICAgIHJlc3VsdC5fc2VhcmNoRXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgdGFza3NDb3VudERpc3BsYXlUZXh0KCkge1xuICAgICAgICBjb25zdCB0YXNrc0NvdW50ID0gdGhpcy50b3RhbFRhc2tzQ291bnQ7XG4gICAgICAgIHJldHVybiBgJHt0YXNrc0NvdW50fSB0YXNrJHt0YXNrc0NvdW50ICE9PSAxID8gJ3MnIDogJyd9YDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgZXhwYW5kUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vU2NyaXB0aW5nL0V4cGFuZFBsYWNlaG9sZGVycyc7XG5pbXBvcnQgeyBtYWtlUXVlcnlDb250ZXh0IH0gZnJvbSAnLi4vU2NyaXB0aW5nL1F1ZXJ5Q29udGV4dCc7XG5pbXBvcnQgeyBMYXlvdXRPcHRpb25zIH0gZnJvbSAnLi4vVGFza0xheW91dCc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgSVF1ZXJ5IH0gZnJvbSAnLi4vSVF1ZXJ5JztcbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi4vQ29uZmlnL1NldHRpbmdzJztcbmltcG9ydCB7IGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbiB9IGZyb20gJy4uL2xpYi9FeGNlcHRpb25Ub29scyc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9Tb3J0JztcbmltcG9ydCB0eXBlIHsgU29ydGVyIH0gZnJvbSAnLi9Tb3J0ZXInO1xuaW1wb3J0IHsgVGFza0dyb3VwcyB9IGZyb20gJy4vVGFza0dyb3Vwcyc7XG5pbXBvcnQgKiBhcyBGaWx0ZXJQYXJzZXIgZnJvbSAnLi9GaWx0ZXJQYXJzZXInO1xuaW1wb3J0IHR5cGUgeyBHcm91cGVyIH0gZnJvbSAnLi9Hcm91cGVyJztcbmltcG9ydCB0eXBlIHsgRmlsdGVyIH0gZnJvbSAnLi9GaWx0ZXIvRmlsdGVyJztcbmltcG9ydCB7IFF1ZXJ5UmVzdWx0IH0gZnJvbSAnLi9RdWVyeVJlc3VsdCc7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeSBpbXBsZW1lbnRzIElRdWVyeSB7XG4gICAgLyoqIE5vdGU6IHNvdXJjZSBpcyB0aGUgcmF3IHNvdXJjZSwgYmVmb3JlIGV4cGFuZGluZyBhbnkgcGxhY2Vob2xkZXJzICovXG4gICAgcHVibGljIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nO1xuICAgIHB1YmxpYyByZWFkb25seSBmaWxlUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgcHJpdmF0ZSBfbGltaXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF90YXNrR3JvdXBMaW1pdDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX2xheW91dE9wdGlvbnM6IExheW91dE9wdGlvbnMgPSBuZXcgTGF5b3V0T3B0aW9ucygpO1xuICAgIHByaXZhdGUgX2ZpbHRlcnM6IEZpbHRlcltdID0gW107XG4gICAgcHJpdmF0ZSBfZXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9zb3J0aW5nOiBTb3J0ZXJbXSA9IFtdO1xuICAgIHByaXZhdGUgX2dyb3VwaW5nOiBHcm91cGVyW10gPSBbXTtcbiAgICBwcml2YXRlIF9pZ25vcmVHbG9iYWxRdWVyeTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBoaWRlT3B0aW9uc1JlZ2V4cCA9XG4gICAgICAgIC9eKGhpZGV8c2hvdykgKHRhc2sgY291bnR8YmFja2xpbmt8cHJpb3JpdHl8Y3JlYXRlZCBkYXRlfHN0YXJ0IGRhdGV8c2NoZWR1bGVkIGRhdGV8ZG9uZSBkYXRlfGR1ZSBkYXRlfHJlY3VycmVuY2UgcnVsZXxlZGl0IGJ1dHRvbnx1cmdlbmN5fHRhZ3MpLztcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNob3J0TW9kZVJlZ2V4cCA9IC9ec2hvcnQvO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhwbGFpblF1ZXJ5UmVnZXhwID0gL15leHBsYWluLztcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlnbm9yZUdsb2JhbFF1ZXJ5UmVnZXhwID0gL15pZ25vcmUgZ2xvYmFsIHF1ZXJ5LztcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGltaXRSZWdleHAgPSAvXmxpbWl0IChncm91cHMgKT8odG8gKT8oXFxkKykoIHRhc2tzPyk/LztcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29tbWVudFJlZ2V4cCA9IC9eIy4qLztcblxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBwYXRoO1xuXG4gICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgLm1hcCgocmF3TGluZTogc3RyaW5nKSA9PiByYXdMaW5lLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChyYXdMaW5lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5leHBhbmRQbGFjZWhvbGRlcnMocmF3TGluZSwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZXhwYW5kaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxpbmUgPT09ICcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5zaG9ydE1vZGVSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuc2hvcnRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZXhwbGFpblF1ZXJ5UmVnZXhwLnRlc3QobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmV4cGxhaW5RdWVyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmlnbm9yZUdsb2JhbFF1ZXJ5UmVnZXhwLnRlc3QobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pZ25vcmVHbG9iYWxRdWVyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmxpbWl0UmVnZXhwLnRlc3QobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGltaXQobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnBhcnNlU29ydEJ5KGxpbmUpOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5wYXJzZUdyb3VwQnkobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmhpZGVPcHRpb25zUmVnZXhwLnRlc3QobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSGlkZU9wdGlvbnMobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLmNvbW1lbnRSZWdleHAudGVzdChsaW5lKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgbGluZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMucGFyc2VGaWx0ZXIobGluZSk6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoJ2RvIG5vdCB1bmRlcnN0YW5kIHF1ZXJ5JywgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRQbGFjZWhvbGRlcnMoc291cmNlOiBzdHJpbmcsIHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc291cmNlLmluY2x1ZGVzKCd7eycpICYmIHNvdXJjZS5pbmNsdWRlcygnfX0nKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZVBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gYFRoZSBxdWVyeSBsb29rcyBsaWtlIGl0IGNvbnRhaW5zIGEgcGxhY2Vob2xkZXIsIHdpdGggXCJ7e1wiIGFuZCBcIn19XCJcbmJ1dCBubyBmaWxlIHBhdGggaGFzIGJlZW4gc3VwcGxpZWQsIHNvIGNhbm5vdCBleHBhbmQgcGxhY2Vob2xkZXIgdmFsdWVzLlxuVGhlIHF1ZXJ5IGlzOlxuJHtzb3VyY2V9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBEbyBub3QgY29tcGxhaW4gYWJvdXQgYW55IHBsYWNlaG9sZGVyIGVycm9ycyBpbiBjb21tZW50IGxpbmVzXG4gICAgICAgIC8vIFRPRE8gU2hvdyB0aGUgb3JpZ2luYWwgYW5kIGV4cGFuZGVkIHRleHQgaW4gZXhwbGFuYXRpb25zXG4gICAgICAgIC8vIFRPRE8gR2l2ZSB1c2VyIGVycm9yIGluZm8gaWYgdGhleSB0cnkgYW5kIHB1dCBhIHN0cmluZyBpbiBhIHJlZ2V4IHNlYXJjaFxuICAgICAgICBsZXQgZXhwYW5kZWRTb3VyY2U6IHN0cmluZyA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5Q29udGV4dCA9IG1ha2VRdWVyeUNvbnRleHQocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkU291cmNlID0gZXhwYW5kUGxhY2Vob2xkZXJzKHNvdXJjZSwgcXVlcnlDb250ZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gJ0ludGVybmFsIGVycm9yLiBleHBhbmRQbGFjZWhvbGRlcnMoKSB0aHJldyBzb21ldGhpbmcgb3RoZXIgdGhhbiBFcnJvci4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBhbmRlZFNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFwcGVuZHMge0BsaW5rIHEyfSB0byB0aGlzIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQG5vdGUgQXQgdGltZSBvZiB3cml0aW5nLCB0aGlzIHF1ZXJ5IGxhbmd1YWdlIGFwcGVhcnMgdG8gcGxheSBuaWNlbHkgd2l0aCBjb21iaW5pbmcgcXVlcmllcy5cbiAgICAgKlxuICAgICAqIE1vcmUgZm9ybWFsbHksIHRoZSBjb25jYXRlbmF0aW9uIG9wZXJhdGlvbiBvbiB0aGUgcXVlcnkgbGFuZ3VhZ2U6XG4gICAgICogICAgICogSXMgY2xvc2VkIChjb25jYXRlbmF0aW5nIHR3byBxdWVyaWVzIGlzIGFub3RoZXIgdmFsaWQgcXVlcnkpXG4gICAgICogICAgICogSXMgbm90IGNvbW11dGF0aXZlIChxMS5hcHBlbmQocTIpICE9PSBxMi5hcHBlbmQocTEpKVxuICAgICAqXG4gICAgICogQW5kIHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGNvbWJpbmF0aW9uIGFyZSBzdHJhaWdodCBmb3J3YXJkOlxuICAgICAqICAgICAqIENvbWJpbmluZyB0d28gcXVlcmllcyBhcHBlbmRzIHRoZWlyIGZpbHRlcnNcbiAgICAgKiAgICAgICAgICAgKGFzc3VtaW5nIHRoYXQgdGhlIGZpbHRlcnMgYXJlIHB1cmUgZnVuY3Rpb25zLCBmaWx0ZXIgY29uY2F0ZW5hdGlvbiBpcyBjb21tdXRhdGl2ZSlcbiAgICAgKiAgICAgKiBDb21iaW5pbmcgdHdvIHF1ZXJpZXMgYXBwZW5kcyB0aGVpciBzb3J0aW5nIGluc3RydWN0aW9ucy4gKHRoaXMgaXMgbm90IGNvbW11dGF0aXZlKVxuICAgICAqICAgICAqIENvbWJpbmluZyB0d28gcXVlcmllcyBhcHBlbmRzIHRoZWlyIGdyb3VwaW5nIGluc3RydWN0aW9ucy4gKHRoaXMgaXMgbm90IGNvbW11dGF0aXZlKVxuICAgICAqICAgICAqIFN1Y2Nlc3NpdmUgbGltaXQgaW5zdHJ1Y3Rpb25zIG92ZXJ3cml0ZSBwcmV2aW91cyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtRdWVyeX0gcTJcbiAgICAgKiBAcmV0dXJuIHtRdWVyeX0gVGhlIGNvbWJpbmVkIHF1ZXJ5XG4gICAgICovXG4gICAgcHVibGljIGFwcGVuZChxMjogUXVlcnkpOiBRdWVyeSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gJycpIHJldHVybiBxMjtcbiAgICAgICAgaWYgKHEyLnNvdXJjZSA9PT0gJycpIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KGAke3RoaXMuc291cmNlfVxcbiR7cTIuc291cmNlfWAsIHRoaXMuZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29udGVudHMgb2YgdGhpcyBxdWVyeS5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3Qgc2hvdyBhbnkgZ2xvYmFsIGZpbHRlciBhbmQgZ2xvYmFsIHF1ZXJ5LlxuICAgICAqIFVzZSB7QGxpbmsgZXhwbGFpblJlc3VsdHN9IGlmIHlvdSB3YW50IHRvIHNlZSBhbnkgZ2xvYmFsIHF1ZXJ5IGFuZCBnbG9iYWwgZmlsdGVyIGFzIHdlbGwuXG4gICAgICovXG4gICAgcHVibGljIGV4cGxhaW5RdWVyeSgpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdRdWVyeSBoYXMgYW4gZXJyb3I6XFxuJztcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmVycm9yICsgJ1xcbic7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbnVtYmVyT2ZGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bWJlck9mRmlsdGVycyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdObyBmaWx0ZXJzIHN1cHBsaWVkLiBBbGwgdGFza3Mgd2lsbCBtYXRjaCB0aGUgcXVlcnkuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZGaWx0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maWx0ZXJzW2ldLmV4cGxhaW5GaWx0ZXJJbmRlbnRlZCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwbGFpblF1ZXJ5TGltaXRzKCk7XG5cbiAgICAgICAgY29uc3QgeyBkZWJ1Z1NldHRpbmdzIH0gPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAoZGVidWdTZXR0aW5ncy5pZ25vcmVTb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICByZXN1bHQgKz1cbiAgICAgICAgICAgICAgICBcIlxcblxcbk5PVEU6IEFsbCBzb3J0IGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGRlZmF1bHQgc29ydCBvcmRlciwgYXJlIGRpc2FibGVkLCBkdWUgdG8gJ2lnbm9yZVNvcnRJbnN0cnVjdGlvbnMnIHNldHRpbmcuXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZXhwbGFpblF1ZXJ5TGltaXRzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGx1cmFsaXNlZFRleHQobGltaXQ6IG51bWJlcikge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBgXFxuXFxuQXQgbW9zdCAke2xpbWl0fSB0YXNrYDtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gJ3MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGdldFBsdXJhbGlzZWRUZXh0KHRoaXMuX2xpbWl0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLlxcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdGFza0dyb3VwTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGdldFBsdXJhbGlzZWRUZXh0KHRoaXMuX3Rhc2tHcm91cExpbWl0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnIHBlciBncm91cCAoaWYgYW55IFwiZ3JvdXAgYnlcIiBvcHRpb25zIGFyZSBzdXBwbGllZCkuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbGltaXQoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbGF5b3V0T3B0aW9ucygpOiBMYXlvdXRPcHRpb25zIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dE9wdGlvbnM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBmaWx0ZXJzKCk6IEZpbHRlcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzb3J0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHtAbGluayBHcm91cGVyfSBvYmplY3RzIHRoYXQgcmVwcmVzZW50IGFueSBgZ3JvdXAgYnlgIGluc3RydWN0aW9ucyBpbiB0aGUgdGFza3MgYmxvY2suXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cGluZygpOiBHcm91cGVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmc7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlcnJvcigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRFcnJvcihtZXNzYWdlOiBzdHJpbmcsIGxpbmU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9lcnJvciA9IGAke21lc3NhZ2V9XG5Qcm9ibGVtIGxpbmU6IFwiJHtsaW5lfVwiYDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlnbm9yZUdsb2JhbFF1ZXJ5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faWdub3JlR2xvYmFsUXVlcnk7XG4gICAgfVxuXG4gICAgcHVibGljIGFwcGx5UXVlcnlUb1Rhc2tzKHRhc2tzOiBUYXNrW10pOiBRdWVyeVJlc3VsdCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFza3MgPSB0YXNrcy5maWx0ZXIoZmlsdGVyLmZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlYnVnU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCB0YXNrc1NvcnRlZCA9IGRlYnVnU2V0dGluZ3MuaWdub3JlU29ydEluc3RydWN0aW9ucyA/IHRhc2tzIDogU29ydC5ieSh0aGlzLnNvcnRpbmcsIHRhc2tzKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzU29ydGVkTGltaXRlZCA9IHRhc2tzU29ydGVkLnNsaWNlKDAsIHRoaXMubGltaXQpO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrR3JvdXBzID0gbmV3IFRhc2tHcm91cHModGhpcy5ncm91cGluZywgdGFza3NTb3J0ZWRMaW1pdGVkKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rhc2tHcm91cExpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXNrR3JvdXBzLmFwcGx5VGFza0xpbWl0KHRoaXMuX3Rhc2tHcm91cExpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVJlc3VsdCh0YXNrR3JvdXBzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSAnU2VhcmNoIGZhaWxlZCc7XG4gICAgICAgICAgICByZXR1cm4gUXVlcnlSZXN1bHQuZnJvbUVycm9yKGVycm9yTWVzc2FnZUZvckV4Y2VwdGlvbihkZXNjcmlwdGlvbiwgZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUhpZGVPcHRpb25zKGxpbmU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBoaWRlT3B0aW9uc01hdGNoID0gbGluZS5tYXRjaCh0aGlzLmhpZGVPcHRpb25zUmVnZXhwKTtcbiAgICAgICAgaWYgKGhpZGVPcHRpb25zTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZGUgPSBoaWRlT3B0aW9uc01hdGNoWzFdID09PSAnaGlkZSc7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBoaWRlT3B0aW9uc01hdGNoWzJdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Rhc2sgY291bnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVUYXNrQ291bnQgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdiYWNrbGluayc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZUJhY2tsaW5rcyA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlUHJpb3JpdHkgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGVkIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVDcmVhdGVkRGF0ZSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0IGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVTdGFydERhdGUgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzY2hlZHVsZWQgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVNjaGVkdWxlZERhdGUgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkdWUgZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZUR1ZURhdGUgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb25lIGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVEb25lRGF0ZSA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3VycmVuY2UgcnVsZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVJlY3VycmVuY2VSdWxlID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdCBidXR0b24nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmhpZGVFZGl0QnV0dG9uID0gaGlkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndXJnZW5jeSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuaGlkZVVyZ2VuY3kgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0YWdzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5oaWRlVGFncyA9IGhpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoJ2RvIG5vdCB1bmRlcnN0YW5kIGhpZGUvc2hvdyBvcHRpb24nLCBsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VGaWx0ZXIobGluZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlck9yRXJyb3IgPSBGaWx0ZXJQYXJzZXIucGFyc2VGaWx0ZXIobGluZSk7XG4gICAgICAgIGlmIChmaWx0ZXJPckVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJPckVycm9yLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaChmaWx0ZXJPckVycm9yLmZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoZmlsdGVyT3JFcnJvci5lcnJvciA/PyAnVW5rbm93biBlcnJvcicsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VMaW1pdChsaW5lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbGltaXRNYXRjaCA9IGxpbmUubWF0Y2godGhpcy5saW1pdFJlZ2V4cCk7XG4gICAgICAgIGlmIChsaW1pdE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVycm9yKCdkbyBub3QgdW5kZXJzdGFuZCBxdWVyeSBsaW1pdCcsIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXRNYXRjaFszXSBpcyBwZXIgcmVnZXggYWx3YXlzIGRpZ2l0cyBhbmQgdGhlcmVmb3JlIHBhcnNhYmxlLlxuICAgICAgICBjb25zdCBsaW1pdEZyb21MaW5lID0gTnVtYmVyLnBhcnNlSW50KGxpbWl0TWF0Y2hbM10sIDEwKTtcblxuICAgICAgICBpZiAobGltaXRNYXRjaFsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl90YXNrR3JvdXBMaW1pdCA9IGxpbWl0RnJvbUxpbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0RnJvbUxpbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlU29ydEJ5KGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzb3J0aW5nTWF5YmUgPSBGaWx0ZXJQYXJzZXIucGFyc2VTb3J0ZXIobGluZSk7XG4gICAgICAgIGlmIChzb3J0aW5nTWF5YmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRpbmcucHVzaChzb3J0aW5nTWF5YmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgb2YgYGdyb3VwIGJ5YCBsaW5lcywgZm9yIGdyb3VwaW5nIHRoYXQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIHtAbGluayBGaWVsZH1cbiAgICAgKiBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgcGFyc2VHcm91cEJ5KGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBncm91cGluZ01heWJlID0gRmlsdGVyUGFyc2VyLnBhcnNlR3JvdXBlcihsaW5lKTtcbiAgICAgICAgaWYgKGdyb3VwaW5nTWF5YmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwaW5nLnB1c2goZ3JvdXBpbmdNYXliZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFF1ZXJ5IH0gZnJvbSAnLi4vUXVlcnkvUXVlcnknO1xuXG4vKipcbiAqIEdsb2JhbCBRdWVyeSBzZXQgaW4gdGhlIHtAbGluayBTZXR0aW5nc1RhYn0gYW5kIGFzc29jaWF0ZWQgc2VydmljZXMuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIG9mIHVzaW5nIHRoaXMgY2xhc3MuXG4gKiAtIEluICdwcm9kdWN0aW9uJyBjb2RlLCB0aGF0IGlzIGluIHRoZSBhY3R1YWwgcGx1Z2luIGNvZGUgdGhhdCBpcyByZWxlYXNlZCxcbiAqICAgY2FsbCB7QGxpbmsgR2xvYmFsUXVlcnkuZ2V0SW5zdGFuY2UoKX0gdG8gb2J0YWluIHRoZSBzaW5nbGUgZ2xvYmFsIGluc3RhbmNlLlxuICogLSBUZXN0cyBvZiBHbG9iYWwgUXVlcnkgY2FwYWJpbGl0aWVzIGRvIG5vdCBuZWVkIHRvIG1vZGlmeSB0aGUgZ2xvYmFsIGluc3RhbmNlOlxuICogICBUaGV5IHNob3VsZCB1c2UgYG5ldyBHbG9iYWxRdWVyeSgpYCwgd2hpY2ggbWFrZXMgc2ltcGxlciwgbW9yZSByZWFkYWJsZVxuICogICB0ZXN0cyB0aGF0IGNhbiBiZSBydW4gaW4gcGFyYWxsZWwuXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEdsb2JhbFF1ZXJ5XG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iYWxRdWVyeSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdsb2JhbFF1ZXJ5O1xuXG4gICAgc3RhdGljIGVtcHR5ID0gJyc7XG4gICAgcHJpdmF0ZSBfc291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHbG9iYWwgUXVlcnkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQ29kZSBpbiB0aGUgcGx1Z2luIHNob3VsZCB1c2Uge0BsaW5rIGdldEluc3RhbmNlfSB0byBhY2Nlc3MgdGhlIEdsb2JhbCBRdWVyeSBzZXJ2aWNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZyA9IEdsb2JhbFF1ZXJ5LmVtcHR5KSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHNpbmdsZSBnbG9iYWwgaW5zdGFuY2Ugb2YgdGhlIEdsb2JhbCBRdWVyeS5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIHRoZSBwbHVnaW4gY29kZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEdsb2JhbFF1ZXJ5IHtcbiAgICAgICAgaWYgKCFHbG9iYWxRdWVyeS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgR2xvYmFsUXVlcnkuaW5zdGFuY2UgPSBuZXcgR2xvYmFsUXVlcnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBHbG9iYWxRdWVyeS5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0KHNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBRdWVyeX0gb2JqZWN0IHdpdGggdGhlIEdsb2JhbCBRdWVyeVxuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICovXG4gICAgcHVibGljIHF1ZXJ5KHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCk6IFF1ZXJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLl9zb3VyY2UsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgR2xvYmFsIFF1ZXJ5IGNvbnRhaW5zIGNoYXJhY3RlcnMgZXhjZXB0IGxpbmUgYnJlYWtzIGFuZCBzcGFjZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzSW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLnRyaW0oKSAhPT0gR2xvYmFsUXVlcnkuZW1wdHk7XG4gICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgRXZlbnRSZWYsIEV2ZW50cyBhcyBPYnNpZGlhbkV2ZW50cyB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHR5cGUgeyBTdGF0ZSB9IGZyb20gJy4vQ2FjaGUnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcblxuZW51bSBFdmVudCB7XG4gICAgQ2FjaGVVcGRhdGUgPSAnb2JzaWRpYW4tdGFza3MtcGx1Z2luOmNhY2hlLXVwZGF0ZScsXG4gICAgUmVxdWVzdENhY2hlVXBkYXRlID0gJ29ic2lkaWFuLXRhc2tzLXBsdWdpbjpyZXF1ZXN0LWNhY2hlLXVwZGF0ZScsXG59XG5cbmludGVyZmFjZSBDYWNoZVVwZGF0ZURhdGEge1xuICAgIHRhc2tzOiBUYXNrW107XG4gICAgc3RhdGU6IFN0YXRlO1xufVxuXG5leHBvcnQgY2xhc3MgVGFza3NFdmVudHMge1xuICAgIHByaXZhdGUgb2JzaWRpYW5FdmVudHM6IE9ic2lkaWFuRXZlbnRzO1xuXG4gICAgY29uc3RydWN0b3IoeyBvYnNpZGlhbkV2ZW50cyB9OiB7IG9ic2lkaWFuRXZlbnRzOiBPYnNpZGlhbkV2ZW50cyB9KSB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMgPSBvYnNpZGlhbkV2ZW50cztcbiAgICB9XG5cbiAgICBwdWJsaWMgb25DYWNoZVVwZGF0ZShoYW5kbGVyOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2lkaWFuRXZlbnRzLm9uKEV2ZW50LkNhY2hlVXBkYXRlLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJpZ2dlckNhY2hlVXBkYXRlKGNhY2hlRGF0YTogQ2FjaGVVcGRhdGVEYXRhKTogdm9pZCB7XG4gICAgICAgIHRoaXMub2JzaWRpYW5FdmVudHMudHJpZ2dlcihFdmVudC5DYWNoZVVwZGF0ZSwgY2FjaGVEYXRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25SZXF1ZXN0Q2FjaGVVcGRhdGUoaGFuZGxlcjogKGZuOiAoY2FjaGVEYXRhOiBDYWNoZVVwZGF0ZURhdGEpID0+IHZvaWQpID0+IHZvaWQpOiBFdmVudFJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2lkaWFuRXZlbnRzLm9uKEV2ZW50LlJlcXVlc3RDYWNoZVVwZGF0ZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcHVibGljIHRyaWdnZXJSZXF1ZXN0Q2FjaGVVcGRhdGUoZm46IChjYWNoZURhdGE6IENhY2hlVXBkYXRlRGF0YSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9ic2lkaWFuRXZlbnRzLnRyaWdnZXIoRXZlbnQuUmVxdWVzdENhY2hlVXBkYXRlLCBmbik7XG4gICAgfVxuXG4gICAgcHVibGljIG9mZihldmVudFJlZjogRXZlbnRSZWYpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vYnNpZGlhbkV2ZW50cy5vZmZyZWYoZXZlbnRSZWYpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyB0eXBlIExpc3RJdGVtQ2FjaGUsIE1ldGFkYXRhQ2FjaGUsIE5vdGljZSwgVEZpbGUsIFZhdWx0LCBXb3Jrc3BhY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgdHlwZSBNb2NrTGlzdEl0ZW1DYWNoZSwgdHlwZSBNb2NrVGFzaywgc2F2ZU1vY2tEYXRhRm9yVGVzdGluZyB9IGZyb20gJy4vbGliL01vY2tEYXRhQ3JlYXRvcic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuaW1wb3J0IHsgbG9nZ2luZyB9IGZyb20gJy4vbGliL2xvZ2dpbmcnO1xuXG5sZXQgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZSB8IHVuZGVmaW5lZDtcbmxldCB2YXVsdDogVmF1bHQgfCB1bmRlZmluZWQ7XG5sZXQgd29ya3NwYWNlOiBXb3Jrc3BhY2UgfCB1bmRlZmluZWQ7XG5cbmNvbnN0IHN1cHBvcnRlZEZpbGVFeHRlbnNpb25zID0gWydtZCddO1xuXG5jb25zdCBsb2dnZXIgPSBsb2dnaW5nLmdldExvZ2dlcigndGFza3MnKTtcblxuZXhwb3J0IHR5cGUgRXJyb3JMb2dnaW5nRnVuY3Rpb24gPSAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkO1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUZpbGUgPSAoe1xuICAgIG1ldGFkYXRhQ2FjaGU6IG5ld01ldGFkYXRhQ2FjaGUsXG4gICAgdmF1bHQ6IG5ld1ZhdWx0LFxuICAgIHdvcmtzcGFjZTogbmV3V29ya3NwYWNlLFxufToge1xuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG4gICAgdmF1bHQ6IFZhdWx0O1xuICAgIHdvcmtzcGFjZTogV29ya3NwYWNlO1xufSkgPT4ge1xuICAgIG1ldGFkYXRhQ2FjaGUgPSBuZXdNZXRhZGF0YUNhY2hlO1xuICAgIHZhdWx0ID0gbmV3VmF1bHQ7XG4gICAgd29ya3NwYWNlID0gbmV3V29ya3NwYWNlO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgb3JpZ2luYWwgdGFzayB3aXRoIG9uZSBvciBtb3JlIG5ldyB0YXNrcy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBtb3JlIHRoYW4gb25lIHJlcGxhY2VtZW50IHRhc2ssIGFsbCBzdWJzZXF1ZW50IHRhc2tzIGluIHRoZSBzYW1lXG4gKiBzZWN0aW9uIG11c3QgYmUgcmUtcmVuZGVyZWQsIGFzIHRoZWlyIHNlY3Rpb24gaW5kZXhlcyBjaGFuZ2UuIEFzc3VtaW5nIHRoYXRcbiAqIHRoaXMgaXMgZG9uZSBmYXN0ZXIgdGhhbiB1c2VyIGludGVyYWN0aW9uIGluIHByYWN0aWNlLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGlzIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGJlIGNhbGxlZCB3aXRoIHJlYXNvbmFibGUgY29uZmlkZW5jZVxuICogdGhhdCB0aGUge0Bjb2RlIG9yaWdpbmFsVGFza30gaXMgdW5tb2RpZmllZCBhbmQgYXQgdGhlIGV4YWN0IHNhbWUgc2VjdGlvbiBhbmRcbiAqIHNlY3Rpb25JZHggaW4gdGhlIHNvdXJjZSBmaWxlIGl0IHdhcyBvcmlnaW5hbGx5IGZvdW5kIGluLiBJdCB3aWxsIGZhaWwgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVRhc2tXaXRoVGFza3MgPSBhc3luYyAoe1xuICAgIG9yaWdpbmFsVGFzayxcbiAgICBuZXdUYXNrcyxcbn06IHtcbiAgICBvcmlnaW5hbFRhc2s6IFRhc2s7XG4gICAgbmV3VGFza3M6IFRhc2sgfCBUYXNrW107XG59KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHZhdWx0ID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGFDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IHdvcmtzcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yQW5kTm90aWNlKCdUYXNrczogY2Fubm90IHVzZSBGaWxlIGJlZm9yZSBpbml0aWFsaXppbmcgaXQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3VGFza3MpKSB7XG4gICAgICAgIG5ld1Rhc2tzID0gW25ld1Rhc2tzXTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoYHJlcGxhY2VUYXNrV2l0aFRhc2tzIGVudGVyZWQuICR7b3JpZ2luYWxUYXNrLnBhdGh9YCk7XG5cbiAgICB0cnlSZXBldGl0aXZlKHtcbiAgICAgICAgb3JpZ2luYWxUYXNrLFxuICAgICAgICBuZXdUYXNrcyxcbiAgICAgICAgdmF1bHQsXG4gICAgICAgIG1ldGFkYXRhQ2FjaGUsXG4gICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgcHJldmlvdXNUcmllczogMCxcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yQW5kTm90aWNlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgbmV3IE5vdGljZShtZXNzYWdlLCAxNTAwMCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BbmROb3RpY2UobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIG5ldyBOb3RpY2UobWVzc2FnZSwgMTAwMDApO1xufVxuXG5mdW5jdGlvbiBkZWJ1Z0xvZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBsb2dnZXIuZGVidWcobWVzc2FnZSk7XG59XG5cbi8vIFdoZW4gdGhpcyBleGNlcHRpb24gaXMgdGhyb3duLCBpdCBpcyBtZWFudCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjYWxsZXIgc2hvdWxkIGNvbnNpZGVyIHRvIHRyeSB0aGUgb3BlcmF0aW9uXG4vLyBhZ2FpbiBzb29uXG5jbGFzcyBXYXJuaW5nV29ydGhSZXRyeWluZyBleHRlbmRzIEVycm9yIHt9XG4vLyBTYW1lIGFzIGFib3ZlLCBidXQgYmUgc2lsZW50IGFib3V0IGl0XG5jbGFzcyBSZXRyeVdpdGhvdXRXYXJuaW5nIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0byByZS10cnkgd2hlbiB0aGUgcmV0dXJuZWQgZmlsZSBjYWNoZSBpcyBgdW5kZWZpbmVkYC5cbiAqIFJldHJ5aW5nIGFmdGVyIGEgd2hpbGUgbWF5IHJldHVybiBhIHZhbGlkIGZpbGUgY2FjaGUuXG4gKiBSZXBvcnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzg3XG4gKi9cbmNvbnN0IHRyeVJlcGV0aXRpdmUgPSBhc3luYyAoe1xuICAgIG9yaWdpbmFsVGFzayxcbiAgICBuZXdUYXNrcyxcbiAgICB2YXVsdCxcbiAgICBtZXRhZGF0YUNhY2hlLFxuICAgIHdvcmtzcGFjZSxcbiAgICBwcmV2aW91c1RyaWVzLFxufToge1xuICAgIG9yaWdpbmFsVGFzazogVGFzaztcbiAgICBuZXdUYXNrczogVGFza1tdO1xuICAgIHZhdWx0OiBWYXVsdDtcbiAgICBtZXRhZGF0YUNhY2hlOiBNZXRhZGF0YUNhY2hlO1xuICAgIHdvcmtzcGFjZTogV29ya3NwYWNlO1xuICAgIHByZXZpb3VzVHJpZXM6IG51bWJlcjtcbn0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBsb2dnZXIuZGVidWcoYHRyeVJlcGV0aXRpdmUgYWZ0ZXIgJHtwcmV2aW91c1RyaWVzfSBwcmV2aW91cyB0cmllc2ApO1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXNUcmllcyA+IDEwKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFRhc2tzOiBDb3VsZCBub3QgZmluZCB0aGUgY29ycmVjdCB0YXNrIGxpbmUgdG8gdXBkYXRlLlxuXG5UaGUgdGFzayBsaW5lIG5vdCB1cGRhdGVkIGlzOlxuJHtvcmlnaW5hbFRhc2sub3JpZ2luYWxNYXJrZG93bn1cblxuSW4gdGhpcyBtYXJrZG93biBmaWxlOlxuXCIke29yaWdpbmFsVGFzay50YXNrTG9jYXRpb24ucGF0aH1cIlxuXG5Ob3RlOiBmdXJ0aGVyIGNsaWNrcyBvbiB0aGlzIGNoZWNrYm94IHdpbGwgdXN1YWxseSBub3cgYmUgaWdub3JlZCB1bnRpbCB0aGUgZmlsZSBpcyBvcGVuZWQgKG9yIGNlcnRhaW4sIHNwZWNpZmljIGVkaXRzIGFyZSBtYWRlIC0gaXQncyBjb21wbGljYXRlZCkuXG5cblJlY29tbWVuZGF0aW9uczpcblxuMS4gQ2xvc2UgYWxsIHBhbmVzIHRoYXQgaGF2ZSB0aGUgYWJvdmUgZmlsZSBvcGVuLCBhbmQgdGhlbiByZS1vcGVuIHRoZSBmaWxlLlxuXG4yLiBDaGVjayBmb3IgZXhhY3RseSBpZGVudGljYWwgY29waWVzIG9mIHRoZSB0YXNrIGxpbmUsIGluIHRoaXMgZmlsZSwgYW5kIHNlZSBpZiB5b3UgY2FuIG1ha2UgdGhlbSBkaWZmZXJlbnQuXG5gO1xuICAgICAgICAgICAgZXJyb3JBbmROb3RpY2UobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oTWF0aC5wb3coMTAsIHByZXZpb3VzVHJpZXMpLCAxMDApOyAvLyAxLCAxMCwgMTAwLCAxMDAsIDEwMCwgLi4uXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgdGltZW91dCA9ICR7dGltZW91dH1gKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0cnlSZXBldGl0aXZlKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRhc2ssXG4gICAgICAgICAgICAgICAgbmV3VGFza3MsXG4gICAgICAgICAgICAgICAgdmF1bHQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFDYWNoZSxcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2UsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmllczogcHJldmlvdXNUcmllcyArIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFt0YXNrTGluZU51bWJlciwgZmlsZSwgZmlsZUxpbmVzXSA9IGF3YWl0IGdldFRhc2tBbmRGaWxlTGluZXMob3JpZ2luYWxUYXNrLCB2YXVsdCk7XG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGNhbiBpbnNlcnQgMSBvciBtb3JlIGxpbmVzIG92ZXIgdGhlIG9yaWdpbmFsIHRhc2sgbGluZTpcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpbGVMaW5lcyA9IFtcbiAgICAgICAgICAgIC4uLmZpbGVMaW5lcy5zbGljZSgwLCB0YXNrTGluZU51bWJlciksXG4gICAgICAgICAgICAuLi5uZXdUYXNrcy5tYXAoKHRhc2s6IFRhc2spID0+IHRhc2sudG9GaWxlTGluZVN0cmluZygpKSxcbiAgICAgICAgICAgIC4uLmZpbGVMaW5lcy5zbGljZSh0YXNrTGluZU51bWJlciArIDEpLCAvLyBPbmx5IHN1cHBvcnRzIHNpbmdsZS1saW5lIHRhc2tzLlxuICAgICAgICBdO1xuXG4gICAgICAgIGF3YWl0IHZhdWx0Lm1vZGlmeShmaWxlLCB1cGRhdGVkRmlsZUxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgV2FybmluZ1dvcnRoUmV0cnlpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UpIHdhcm5BbmROb3RpY2UoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiByZXRyeSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBSZXRyeVdpdGhvdXRXYXJuaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yQW5kTm90aWNlKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgbGluZSBvbiB3aGljaCBgdGFza2AgaXMgZGVmaW5lZCwgdG9nZXRoZXIgd2l0aCB0aGUgZmlsZSBpdCBpcyBkZWZpbmVkIGluLCBhbmQgdGhlXG4gKiBsaW5lcyBvZiB0aGF0IGZpbGUsIHBvc3NpYmx5IGZvciB0aGUgcHVycG9zZSBvZiB1cGRhdGluZyB0aGUgdGFzayBpbiB0aGUgZmlsZSBvciBqdW1waW5nIHRvIGl0LlxuICogSXQgbWF5IHRocm93IGEgV2FybmluZ1dvcnRoUmV0cnlpbmcgZXhjZXB0aW9uIGluIHNldmVyYWwgY2FzZXMgdGhhdCBqdXN0aWZ5IGEgcmV0cnkgKHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBjYWxsZXIpXG4gKiBvciBhbiBFcnJvciBleGNlcHRpb24gaW4gY2FzZSBvZiBhbiB1bnJlY292ZXJhYmxlIGVycm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRUYXNrQW5kRmlsZUxpbmVzKHRhc2s6IFRhc2ssIHZhdWx0OiBWYXVsdCk6IFByb21pc2U8W251bWJlciwgVEZpbGUsIHN0cmluZ1tdXT4ge1xuICAgIGlmIChtZXRhZGF0YUNhY2hlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBXYXJuaW5nV29ydGhSZXRyeWluZygpO1xuICAgIC8vIFZhbGlkYXRlIG91ciBpbnB1dHMuXG4gICAgLy8gRm9yIHBlcm1hbmVudCBmYWlsdXJlcywgcmV0dXJuIG5vdGhpbmcuXG4gICAgLy8gRm9yIGZhaWx1cmVzIHRoYXQgbWlnaHQgYmUgZml4ZWQgaWYgd2Ugd2FpdCBmb3IgYSBsaXR0bGUgd2hpbGUsIHJldHVybiByZXRyeSgpLlxuICAgIGNvbnN0IGZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGFzay5wYXRoKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBXYXJuaW5nV29ydGhSZXRyeWluZyhgVGFza3M6IE5vIGZpbGUgZm91bmQgZm9yIHRhc2sgJHt0YXNrLmRlc2NyaXB0aW9ufS4gUmV0cnlpbmcgLi4uYCk7XG4gICAgfVxuXG4gICAgaWYgKCFzdXBwb3J0ZWRGaWxlRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlLmV4dGVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXNrczogRG9lcyBub3Qgc3VwcG9ydCBmaWxlcyB3aXRoIHRoZSAke2ZpbGUuZXh0ZW5zaW9ufSBmaWxlIGV4dGVuc2lvbi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlQ2FjaGUgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICBpZiAoZmlsZUNhY2hlID09IHVuZGVmaW5lZCB8fCBmaWxlQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhcm5pbmdXb3J0aFJldHJ5aW5nKGBUYXNrczogTm8gZmlsZSBjYWNoZSBmb3VuZCBmb3IgZmlsZSAke2ZpbGUucGF0aH0uIFJldHJ5aW5nIC4uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RJdGVtc0NhY2hlID0gZmlsZUNhY2hlLmxpc3RJdGVtcztcbiAgICBpZiAobGlzdEl0ZW1zQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBsaXN0SXRlbXNDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFdhcm5pbmdXb3J0aFJldHJ5aW5nKGBUYXNrczogTm8gbGlzdCBpdGVtcyBmb3VuZCBpbiBmaWxlIGNhY2hlIG9mICR7ZmlsZS5wYXRofS4gUmV0cnlpbmcgLi4uYCk7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIG5vdyB0cnkgYW5kIGZpbmQgd2hpY2ggbGluZSBpbiB0aGUgZmlsZSBjdXJyZW50bHkgY29udGFpbnMgb3JpZ2luYWxUYXNrLFxuICAgIC8vIHNvIHRoYXQgd2Uga25vdyB3aGljaCBsaW5lIHRvIHVwZGF0ZS5cbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHZhdWx0LnJlYWQoZmlsZSk7IC8vIFRPRE86IHJlcGxhY2Ugd2l0aCB2YXVsdC5wcm9jZXNzLlxuICAgIGNvbnN0IGZpbGVMaW5lcyA9IGZpbGVDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCB0YXNrTGluZU51bWJlciA9IGZpbmRMaW5lTnVtYmVyT2ZUYXNrVG9Ub2dnbGUodGFzaywgZmlsZUxpbmVzLCBsaXN0SXRlbXNDYWNoZSwgZGVidWdMb2cpO1xuXG4gICAgaWYgKHRhc2tMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbG9nRGF0YUZvck1vY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvZ0RhdGFGb3JNb2NraW5nKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZmluZGluZyB0aGUgY29ycmVjdCBsaW5lIHRvIHRvZ2dsZSxcbiAgICAgICAgICAgIC8vIHNvIHdyaXRlIG91dCB0byB0aGUgY29uc29sZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhIG5lZWRlZCB0byByZWNvbnN0cnVjdCB0aGUgYWJvdmVcbiAgICAgICAgICAgIC8vIGZpbmRMaW5lTnVtYmVyT2ZUYXNrVG9Ub2dnbGUoKSBjYWxsLCBzbyB0aGF0IHRoZSBjb250ZW50IGNhbiBiZSBzYXZlZFxuICAgICAgICAgICAgLy8gdG8gYSBKU09OIGZpbGUgYW5kIHRoZW4gcmUtdXNlZCBpbiBhICd1bml0JyB0ZXN0LlxuICAgICAgICAgICAgc2F2ZU1vY2tEYXRhRm9yVGVzdGluZyh0YXNrLCBmaWxlTGluZXMsIGxpc3RJdGVtc0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmV0cnlXaXRob3V0V2FybmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gW3Rhc2tMaW5lTnVtYmVyLCBmaWxlLCBmaWxlTGluZXNdO1xufVxuXG4vLyBBIHNpbXBsZXIgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGFib3ZlLCB3aGljaCBkb2Vzbid0IHJldHVybiB0aGUgbGluZXMgb2YgdGhlIGZpbGUsIGFuZCBoYW5kbGVzIGV4Y2VwdGlvbnNcbi8vIGludGVybmFsbHkgcmF0aGVyIHRoYW4gdGhyb3cgdGhlbSB0byB0aGUgb3V0c2lkZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhc2tMaW5lQW5kRmlsZSh0YXNrOiBUYXNrLCB2YXVsdDogVmF1bHQpOiBQcm9taXNlPFtudW1iZXIsIFRGaWxlXSB8IHVuZGVmaW5lZD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFt0YXNrTGluZU51bWJlciwgZmlsZSwgX10gPSBhd2FpdCBnZXRUYXNrQW5kRmlsZUxpbmVzKHRhc2ssIHZhdWx0KTtcbiAgICAgICAgcmV0dXJuIFt0YXNrTGluZU51bWJlciwgZmlsZV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFdhcm5pbmdXb3J0aFJldHJ5aW5nKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlKSB3YXJuQW5kTm90aWNlKGUubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckFuZE5vdGljZShlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRMaW5lTnVtYmVyKGxpc3RJdGVtTGluZU51bWJlcjogbnVtYmVyLCBmaWxlTGluZXM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGxpc3RJdGVtTGluZU51bWJlciA8IGZpbGVMaW5lcy5sZW5ndGg7XG59XG5cbi8qKlxuICogVHJ5IHRvIGZpbmQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2sgLSB0aGUge0BsaW5rIFRhc2t9IGxpbmUgdGhhdCB0aGUgdXNlciBjbGlja2VkIG9uXG4gKiBAcGFyYW0gZmlsZUxpbmVzIC0gdGhlIGxpbmVzIHJlYWQgZnJvbSB0aGUgZmlsZS5cbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICogQHBhcmFtIGVycm9yTG9nZ2luZ0Z1bmN0aW9uIC0gYSBmdW5jdGlvbiBvZiB0eXBlIHtAbGluayBFcnJvckxvZ2dpbmdGdW5jdGlvbn0gLSB3aGljaCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgZm91bmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgZGlmZmVycyBmcm9tIHRoZSBvcmlnaW5hbCBtYXJrZG93biBpbiB7QGxpbmsgb3JpZ2luYWxUYXNrfS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkIHRvIGFsbG93IHRlc3RzIHRvIGJlIHdyaXR0ZW4gZm9yIHRoaXMgY29kZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBkbyBub3QgZGlzcGxheSBhIHBvcHVwIHdhcm5pbmcsIGJ1dCBpbnN0ZWFkIGNhcHR1cmUgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGluZU51bWJlck9mVGFza1RvVG9nZ2xlKFxuICAgIG9yaWdpbmFsVGFzazogVGFzayB8IE1vY2tUYXNrLFxuICAgIGZpbGVMaW5lczogc3RyaW5nW10sXG4gICAgbGlzdEl0ZW1zQ2FjaGU6IExpc3RJdGVtQ2FjaGVbXSB8IE1vY2tMaXN0SXRlbUNhY2hlW10sXG4gICAgZXJyb3JMb2dnaW5nRnVuY3Rpb246IEVycm9yTG9nZ2luZ0Z1bmN0aW9uLFxuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgcmVzdWx0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB0cnlGaW5kaW5nRXhhY3RNYXRjaEF0T3JpZ2luYWxMaW5lTnVtYmVyKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnlGaW5kaW5nSWRlbnRpY2FsVW5pcXVlTWFya2Rvd25MaW5lSW5GaWxlKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ5RmluZGluZ0xpbmVOdW1iZXJGcm9tVGFza1NlY3Rpb25JbmZvKG9yaWdpbmFsVGFzaywgZmlsZUxpbmVzLCBsaXN0SXRlbXNDYWNoZSwgZXJyb3JMb2dnaW5nRnVuY3Rpb24pO1xufVxuXG4vKipcbiAqICBJZiB0aGUgbGluZSBhdCBsaW5lIG51bWJlciBpbiBvcmlnaW5hbFRhc2sgbWF0Y2hlcyBvcmlnaW5hbCBtYXJrZG93bixcbiAqICB0cmVhdCB0aGF0IGFzIHRoZSBjb3JyZWN0IGFuc3dlci5cbiAqXG4gKiAgVGhpcyBjb3VsZCBnbyB3cm9uZyBpZjpcbiAqICAgICAtIFNvbWUgbGluZXMgaGF2ZSBiZWVuIGFkZGVkIHNpbmNlIG9yaWdpbmFsVGFzayB3YXMgcmVuZGVyZWQgaW4gUmVhZGluZyB2aWV3LFxuICogICAgICAgYW5kIGFuIGlkZW50aWNhbCB0YXNrIGxpbmUgd2FzIGFkZGVkLCB0aGF0IGhhcHBlbmVkIGJ5IGNvaW5jaWRlbmNlIHRvIGJlIGluIHRoZSBzYW1lXG4gKiAgICAgICBsaW5lIG51bWJlciBhcyB0aGUgb3JpZ2luYWwgdGFzay5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxUYXNrXG4gKiBAcGFyYW0gZmlsZUxpbmVzXG4gKi9cbmZ1bmN0aW9uIHRyeUZpbmRpbmdFeGFjdE1hdGNoQXRPcmlnaW5hbExpbmVOdW1iZXIob3JpZ2luYWxUYXNrOiBUYXNrIHwgTW9ja1Rhc2ssIGZpbGVMaW5lczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBvcmlnaW5hbFRhc2tMaW5lTnVtYmVyID0gb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5saW5lTnVtYmVyO1xuICAgIGlmIChpc1ZhbGlkTGluZU51bWJlcihvcmlnaW5hbFRhc2tMaW5lTnVtYmVyLCBmaWxlTGluZXMpKSB7XG4gICAgICAgIGlmIChmaWxlTGluZXNbb3JpZ2luYWxUYXNrTGluZU51bWJlcl0gPT09IG9yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3duKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIG9yaWdpbmFsIG1hcmtkb3duIGF0IG9yaWdpbmFsIGxpbmUgbnVtYmVyICR7b3JpZ2luYWxUYXNrTGluZU51bWJlcn1gKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRhc2tMaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSWYgdGhlIGxpbmUgb25seSBhcHBlYXJzIG9uY2UgaW4gdGhlIGZpbGUsIHVzZSB0aGF0IGxpbmUgbnVtYmVyLlxuICpcbiAqIFRoaXMgY291bGQgZ28gd3JvbmcgaWY6XG4gKiAgICAtIHRoZSB1c2VyIGhhZCBjb21tZW50ZWQgb3V0IHRoZSBvcmlnaW5hbCB0YXNrIGxpbmUsIGFuZCB0aGUgc2VjdGlvbiBoYWQgbm90IHlldCBiZWVuIHJlZHJhd25cbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqL1xuZnVuY3Rpb24gdHJ5RmluZGluZ0lkZW50aWNhbFVuaXF1ZU1hcmtkb3duTGluZUluRmlsZShvcmlnaW5hbFRhc2s6IFRhc2sgfCBNb2NrVGFzaywgZmlsZUxpbmVzOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IG1hdGNoaW5nTGluZU51bWJlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZmlsZUxpbmVzW2ldID09PSBvcmlnaW5hbFRhc2sub3JpZ2luYWxNYXJrZG93bikge1xuICAgICAgICAgICAgbWF0Y2hpbmdMaW5lTnVtYmVycy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGluZ0xpbmVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGUgbGluZSBpbiB0aGUgZmlsZSwgc28gaXQgbXVzdCBiZSB0aGVcbiAgICAgICAgLy8gbGluZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0xpbmVOdW1iZXJzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEZhbGwgYmFjayBvbiB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtLCB3aGljaCB1c2VzIHRoZSBzZWN0aW9uIGluZm9ybWF0aW9uIGluc2lkZSB0aGUgdGFzaydzIHtAbGluayBUYXNrTG9jYXRpb259LlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbFRhc2tcbiAqIEBwYXJhbSBmaWxlTGluZXNcbiAqIEBwYXJhbSBsaXN0SXRlbXNDYWNoZVxuICogQHBhcmFtIGVycm9yTG9nZ2luZ0Z1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRyeUZpbmRpbmdMaW5lTnVtYmVyRnJvbVRhc2tTZWN0aW9uSW5mbyhcbiAgICBvcmlnaW5hbFRhc2s6IFRhc2sgfCBNb2NrVGFzayxcbiAgICBmaWxlTGluZXM6IHN0cmluZ1tdLFxuICAgIGxpc3RJdGVtc0NhY2hlOiBMaXN0SXRlbUNhY2hlW10gfCBNb2NrTGlzdEl0ZW1DYWNoZVtdLFxuICAgIGVycm9yTG9nZ2luZ0Z1bmN0aW9uOiBFcnJvckxvZ2dpbmdGdW5jdGlvbixcbikge1xuICAgIGxldCB0YXNrTGluZU51bWJlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGxldCBzZWN0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgbGlzdEl0ZW1DYWNoZSBvZiBsaXN0SXRlbXNDYWNoZSkge1xuICAgICAgICBjb25zdCBsaXN0SXRlbUxpbmVOdW1iZXIgPSBsaXN0SXRlbUNhY2hlLnBvc2l0aW9uLnN0YXJ0LmxpbmU7XG4gICAgICAgIGlmICghaXNWYWxpZExpbmVOdW1iZXIobGlzdEl0ZW1MaW5lTnVtYmVyLCBmaWxlTGluZXMpKSB7XG4gICAgICAgICAgICAvLyBPbmUgb3IgbW9yZSBsaW5lcyBoYXMgYmVlbiBkZWxldGVkIHNpbmNlIHRoZSBjYWNoZSB3YXMgcG9wdWxhdGVkLFxuICAgICAgICAgICAgLy8gc28gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3QgaXRlbSBpbiB0aGUgY2FjaGUgdGhhdCBpcyBiZXlvbmRcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIGFjdHVhbCBmaWxlIG9uIGRpc2suXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RJdGVtTGluZU51bWJlciA8IG9yaWdpbmFsVGFzay50YXNrTG9jYXRpb24uc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0SXRlbUNhY2hlLnRhc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5lID0gZmlsZUxpbmVzW2xpc3RJdGVtTGluZU51bWJlcl07XG4gICAgICAgIGlmIChHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5pbmNsdWRlZEluKGxpbmUpKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbkluZGV4ID09PSBvcmlnaW5hbFRhc2sudGFza0xvY2F0aW9uLnNlY3Rpb25JbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lID09PSBvcmlnaW5hbFRhc2sub3JpZ2luYWxNYXJrZG93bikge1xuICAgICAgICAgICAgICAgICAgICB0YXNrTGluZU51bWJlciA9IGxpc3RJdGVtTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckxvZ2dpbmdGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUYXNrczogVW5hYmxlIHRvIGZpbmQgdGFzayBpbiBmaWxlICR7b3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5wYXRofS5cbkV4cGVjdGVkIHRhc2s6XG4ke29yaWdpbmFsVGFzay5vcmlnaW5hbE1hcmtkb3dufVxuRm91bmQgdGFzazpcbiR7bGluZX1gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFza0xpbmVOdW1iZXI7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBMaXN0SXRlbUNhY2hlLCBQb3MgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcblxudHlwZSBNb2NrVGFza0xvY2F0aW9uID0ge1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBsaW5lTnVtYmVyOiBudW1iZXI7XG4gICAgc2VjdGlvblN0YXJ0OiBudW1iZXI7XG4gICAgc2VjdGlvbkluZGV4OiBudW1iZXI7XG4gICAgcHJlY2VkaW5nSGVhZGVyOiBzdHJpbmcgfCBudWxsO1xufTtcblxuLyoqIGEgbW9jayBmb3Ige0BsaW5rIExpc3RJdGVtQ2FjaGUudGFza30gKi9cbnR5cGUgTW9ja0xpc3RJdGVtQ2FjaGVUYXNrID0gc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4vKiogYSBtb2NrIGZvciB7QGxpbmsgUG9zfSAqL1xudHlwZSBNb2NrUG9zID0gUG9zO1xuXG4vKiogYSBtb2NrIGZvciB7QGxpbmsgTGlzdEl0ZW1DYWNoZX0gKi9cbmV4cG9ydCB0eXBlIE1vY2tMaXN0SXRlbUNhY2hlID0geyB0YXNrOiBzdHJpbmcgfCB1bmRlZmluZWQ7IHBvc2l0aW9uOiBQb3MgfTtcbnR5cGUgTW9ja0xpc3RJdGVtQ2FjaGVzID0gTW9ja0xpc3RJdGVtQ2FjaGVbXTtcblxuLyoqIGEgbW9jayBmb3Ige0BsaW5rIFRhc2t9ICovXG5leHBvcnQgdHlwZSBNb2NrVGFzayA9IHtcbiAgICBvcmlnaW5hbE1hcmtkb3duOiBzdHJpbmc7XG4gICAgdGFza0xvY2F0aW9uOiBNb2NrVGFza0xvY2F0aW9uO1xufTtcblxuLyoqIEFsbCB0aGUgZGF0YSByZXF1aXJlZCB0byBjYWxsIHtAbGluayBmaW5kTGluZU51bWJlck9mVGFza1RvVG9nZ2xlfSAqL1xuZXhwb3J0IHR5cGUgTW9ja1RvZ2dsaW5nRGF0YUZvclRlc3RpbmcgPSB7XG4gICAgY2FjaGVEYXRhOiB7IGxpc3RJdGVtc0NhY2hlOiBNb2NrTGlzdEl0ZW1DYWNoZVtdIH07XG4gICAgZmlsZURhdGE6IHsgZmlsZUxpbmVzOiBzdHJpbmdbXSB9O1xuICAgIHRhc2tEYXRhOiBNb2NrVGFzaztcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBzYXZlIGRhdGEgdGhhdCBpcyB1c2VkXG4gKiB3aGVuIGZpbmRpbmcgd2hpY2ggbGluZSB0byB0b2dnbGUgaW4gYSBmaWxlLlxuICogQHBhcmFtIG9yaWdpbmFsVGFza1xuICogQHBhcmFtIGZpbGVMaW5lc1xuICogQHBhcmFtIGxpc3RJdGVtc0NhY2hlXG4gKlxuICogQHNlZSBzYXZlTW9ja0RhdGFGb3JUZXN0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2NrRGF0YUZvclRlc3RpbmcoXG4gICAgb3JpZ2luYWxUYXNrOiBUYXNrLFxuICAgIGZpbGVMaW5lczogc3RyaW5nW10sXG4gICAgbGlzdEl0ZW1zQ2FjaGU6IExpc3RJdGVtQ2FjaGVbXSxcbik6IE1vY2tUb2dnbGluZ0RhdGFGb3JUZXN0aW5nIHtcbiAgICBjb25zdCBhbGxEYXRhRnJvbUxpc3RJdGVtQ2FjaGU6IE1vY2tMaXN0SXRlbUNhY2hlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbGlzdEl0ZW1DYWNoZSBvZiBsaXN0SXRlbXNDYWNoZSkge1xuICAgICAgICBjb25zdCBwb3M6IE1vY2tQb3MgPSBsaXN0SXRlbUNhY2hlLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0YXNrOiBNb2NrTGlzdEl0ZW1DYWNoZVRhc2sgPSBsaXN0SXRlbUNhY2hlLnRhc2s7XG4gICAgICAgIGNvbnN0IGRhdGFGcm9tTGlzdEl0ZW1DYWNoZTogTW9ja0xpc3RJdGVtQ2FjaGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgfTtcbiAgICAgICAgYWxsRGF0YUZyb21MaXN0SXRlbUNhY2hlLnB1c2goZGF0YUZyb21MaXN0SXRlbUNhY2hlKTtcbiAgICB9XG4gICAgY29uc3QgbW9ja1Rhc2tMb2NhdGlvbjogTW9ja1Rhc2tMb2NhdGlvbiA9IHtcbiAgICAgICAgcGF0aDogb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5wYXRoLFxuICAgICAgICBsaW5lTnVtYmVyOiBvcmlnaW5hbFRhc2sudGFza0xvY2F0aW9uLmxpbmVOdW1iZXIsXG4gICAgICAgIHNlY3Rpb25TdGFydDogb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5zZWN0aW9uU3RhcnQsXG4gICAgICAgIHNlY3Rpb25JbmRleDogb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5zZWN0aW9uSW5kZXgsXG4gICAgICAgIHByZWNlZGluZ0hlYWRlcjogb3JpZ2luYWxUYXNrLnRhc2tMb2NhdGlvbi5wcmVjZWRpbmdIZWFkZXIsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YXNrRGF0YToge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXJrZG93bjogb3JpZ2luYWxUYXNrLm9yaWdpbmFsTWFya2Rvd24sXG4gICAgICAgICAgICB0YXNrTG9jYXRpb246IG1vY2tUYXNrTG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlTGluZXM6IGZpbGVMaW5lcyxcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGVEYXRhOiB7XG4gICAgICAgICAgICBsaXN0SXRlbXNDYWNoZTogYWxsRGF0YUZyb21MaXN0SXRlbUNhY2hlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8qKlxuICogV3JpdGUgdGhlIHN1cHBsaWVkIGRhdGEgdG8gdGhlIGNvbnNvbGUsIHNvIGl0IGNhbiBiZSBzYXZlZCBmb3IgdXNlIGluIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIG9yaWdpbmFsVGFza1xuICogQHBhcmFtIGZpbGVMaW5lc1xuICogQHBhcmFtIGxpc3RJdGVtc0NhY2hlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlTW9ja0RhdGFGb3JUZXN0aW5nKG9yaWdpbmFsVGFzazogVGFzaywgZmlsZUxpbmVzOiBzdHJpbmdbXSwgbGlzdEl0ZW1zQ2FjaGU6IExpc3RJdGVtQ2FjaGVbXSkge1xuICAgIGNvbnN0IGV2ZXJ5dGhpbmcgPSBnZXRNb2NrRGF0YUZvclRlc3Rpbmcob3JpZ2luYWxUYXNrLCBmaWxlTGluZXMsIGxpc3RJdGVtc0NhY2hlKTtcbiAgICBjb25zb2xlLmVycm9yKGBJbmNvbnNpc3RlbnQgbGluZXM6IFNBVkUgVEhFIE9VVFBVVFxuZGF0YTpcbiR7SlNPTi5zdHJpbmdpZnkoZXZlcnl0aGluZyl9XG5gKTtcbn1cbiIsICJpbXBvcnQgeyBQbGF0Zm9ybSwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuLypcbiAqIEV2ZW50RW1pdHRlcjIgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIEV2ZW50RW1pdHRlciBtb2R1bGUgZm91bmQgaW4gTm9kZS5qcy5cbiAqIEluIGFkZGl0aW9uIHRvIGhhdmluZyBhIGJldHRlciBiZW5jaG1hcmsgcGVyZm9ybWFuY2UgdGhhbiBFdmVudEVtaXR0ZXIgYW5kIGJlaW5nXG4gKiBicm93c2VyLWNvbXBhdGlibGUsIGl0IGFsc28gZXh0ZW5kcyB0aGUgaW50ZXJmYWNlIG9mIEV2ZW50RW1pdHRlciB3aXRoIG1hbnlcbiAqIGFkZGl0aW9uYWwgbm9uLWJyZWFraW5nIGZlYXR1cmVzLlxuICpcbiAqIFRoaXMgaGFzIGJlZW4gYWRkZWQgYXMgRXZlbnRFbWl0dGVyIGluIE5vZGUuSlMgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAqIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2V2ZW50ZW1pdHRlcjJcbiAqL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyMiB9IGZyb20gJ2V2ZW50ZW1pdHRlcjInO1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBsb2cgbGV2ZWxzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUxvZ0xldmVsIHtcbiAgICAxOiAndHJhY2UnO1xuICAgIDI6ICdkZWJ1Zyc7XG4gICAgMzogJ2luZm8nO1xuICAgIDQ6ICd3YXJuJztcbiAgICA1OiAnZXJyb3InO1xufVxuXG4vKipcbiAqIExvZ2dlciBjbGFzcyB0byBoYW5kbGUgY29uc2lzdGVuY3kgb2YgbG9ncyBhY3Jvc3MgdGhlIHBsdWdpbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAaW50ZXJmYWNlIExvZ0VudHJ5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9nRW50cnkge1xuICAgIHRyYWNlSWQ/OiBzdHJpbmc7XG4gICAgbGV2ZWw6IHN0cmluZztcbiAgICBtb2R1bGU6IHN0cmluZztcbiAgICBsb2NhdGlvbj86IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgb2JqZWN0czogYW55O1xufVxuXG4vKipcbiAqIExvZ2dpbmcgb3B0aW9ucyBzdHJ1Y3R1cmUuXG4gKlxuICogQGV4cG9ydFxuICogQGludGVyZmFjZSBMb2dPcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9nT3B0aW9ucyB7XG4gICAgbWluTGV2ZWxzOiB7IFttb2R1bGU6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG4vKipcbiAqIExvZyBsZXZlbCBJRHMgKDEgLSA1KVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBUTG9nTGV2ZWxJZCA9IGtleW9mIElMb2dMZXZlbDtcblxuLyoqXG4gKiBMb2cgbGV2ZWwgbmFtZXMgKHRyYWNlIC0gZXJyb3IpXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFRMb2dMZXZlbE5hbWUgPSBJTG9nTGV2ZWxbVExvZ0xldmVsSWRdO1xuXG4vKipcbiAqIExvZ2dlciBjbGFzcyB0byBoYW5kbGUgY29uc2lzdGVuY3kgb2YgbG9ncyBhY3Jvc3MgdGhlIHBsdWdpbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgTG9nTWFuYWdlclxuICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcjJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyMiB7XG4gICAgcHJpdmF0ZSBvcHRpb25zOiBMb2dPcHRpb25zID0ge1xuICAgICAgICBtaW5MZXZlbHM6IHtcbiAgICAgICAgICAgICcnOiAnaW5mbycsXG4gICAgICAgICAgICB0YXNrczogJ2luZm8nLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IHRoZSBjb25zb2xlIGxvZ2dlciBmcm9tIGJlaW5nIGFkZGVkIHR3aWNlXG4gICAgcHJpdmF0ZSBjb25zb2xlTG9nZ2VyUmVnaXN0ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIGxvZyBsZXZlbHMgZm9yIHRoZSBtb2R1bGUgbmFtZSBvciBnbG9iYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvZ09wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHsqfSAge0xvZ01hbmFnZXJ9XG4gICAgICogQG1lbWJlcm9mIExvZ01hbmFnZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgY29uZmlndXJlKG9wdGlvbnM6IExvZ09wdGlvbnMpOiBMb2dNYW5hZ2VyIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvZ2dlciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIG1vZHVsZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZVxuICAgICAqIEByZXR1cm4geyp9ICB7TG9nZ2VyfVxuICAgICAqIEBtZW1iZXJvZiBMb2dNYW5hZ2VyXG4gICAgICovXG4gICAgcHVibGljIGdldExvZ2dlcihtb2R1bGU6IHN0cmluZyk6IExvZ2dlciB7XG4gICAgICAgIGxldCBtaW5MZXZlbCA9ICdub25lJztcbiAgICAgICAgbGV0IG1hdGNoID0gJyc7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5vcHRpb25zLm1pbkxldmVscykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5zdGFydHNXaXRoKGtleSkgJiYga2V5Lmxlbmd0aCA+PSBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtaW5MZXZlbCA9IHRoaXMub3B0aW9ucy5taW5MZXZlbHNba2V5XTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLCBtb2R1bGUsIG1pbkxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsobG9nRW50cnk6IExvZ0VudHJ5KSA9PiB2b2lkfSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4geyp9ICB7TG9nTWFuYWdlcn1cbiAgICAgKiBAbWVtYmVyb2YgTG9nTWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyBvbkxvZ0VudHJ5KGxpc3RlbmVyOiAobG9nRW50cnk6IExvZ0VudHJ5KSA9PiB2b2lkKTogTG9nTWFuYWdlciB7XG4gICAgICAgIHRoaXMub24oJ2xvZycsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcHJpdmF0ZSBwZXJpb2Q6IG51bWJlciA9IDA7XG4gICAgYXJyQXZnID0gKGFycjogbnVtYmVyW10pID0+IGFyci5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGFyci5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsb2dnZXIgdGhhdCB3cml0ZSB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9ICB7TG9nTWFuYWdlcn1cbiAgICAgKiBAbWVtYmVyb2YgTG9nTWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3RlckNvbnNvbGVMb2dnZXIoKTogTG9nTWFuYWdlciB7XG4gICAgICAgIGlmICh0aGlzLmNvbnNvbGVMb2dnZXJSZWdpc3RlcmVkKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLm9uTG9nRW50cnkoKGxvZ0VudHJ5KSA9PiB7XG4gICAgICAgICAgICBsZXQgbXNnID0gYFske3dpbmRvdy5tb21lbnQoKS5mb3JtYXQoJ1lZWVktTU0tREQtSEg6bW06c3MuU1NTJyl9XVske2xvZ0VudHJ5LmxldmVsfV1bJHtsb2dFbnRyeS5tb2R1bGV9XWA7XG5cbiAgICAgICAgICAgIGlmIChsb2dFbnRyeS50cmFjZUlkKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IGBbJHtsb2dFbnRyeS50cmFjZUlkfV1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtc2cgKz0gYCAke2xvZ0VudHJ5Lm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIGlmIChsb2dFbnRyeS5vYmplY3RzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dFbnRyeS5vYmplY3RzID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAobG9nRW50cnkubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UobXNnLCBsb2dFbnRyeS5vYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVidWcnOlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1zZywgbG9nRW50cnkub2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obXNnLCBsb2dFbnRyeS5vYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2csIGxvZ0VudHJ5Lm9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnLCBsb2dFbnRyeS5vYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHske2xvZ0VudHJ5LmxldmVsfX0gJHttc2d9YCwgbG9nRW50cnkub2JqZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29uc29sZUxvZ2dlclJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBsb2dnaW5nID0gbmV3IExvZ01hbmFnZXIoKTtcblxuLyoqXG4gKiBNYWluIGxvZ2dpbmcgbGlicmFyeSwgdG8gdmlldyB0aGUgbG9ncyBhIGxvZ2dlciBsaXN0ZW5lciBtdXN0IGJlIGFkZGVkLiBUaGVcbiAqIENvbnNvbGUgTG9nZ2VyIGlzIGFscmVhZHkgaW1wbGVtZW50ZWQgZm9yIHRoaXMgcHJvamVjdC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgTG9nZ2VyXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIHByaXZhdGUgbG9nTWFuYWdlcjogRXZlbnRFbWl0dGVyMjtcbiAgICBwcml2YXRlIG1pbkxldmVsOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBtb2R1bGU6IHN0cmluZztcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxldmVsczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgICAgICAgdHJhY2U6IDEsXG4gICAgICAgIGRlYnVnOiAyLFxuICAgICAgICBpbmZvOiAzLFxuICAgICAgICB3YXJuOiA0LFxuICAgICAgICBlcnJvcjogNSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMb2dnZXIuXG4gICAgICogQHBhcmFtIHtFdmVudEVtaXR0ZXIyfSBsb2dNYW5hZ2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW5MZXZlbFxuICAgICAqIEBtZW1iZXJvZiBMb2dnZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2dNYW5hZ2VyOiBFdmVudEVtaXR0ZXIyLCBtb2R1bGU6IHN0cmluZywgbWluTGV2ZWw6IHN0cmluZykge1xuICAgICAgICB0aGlzLmxvZ01hbmFnZXIgPSBsb2dNYW5hZ2VyO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5taW5MZXZlbCA9IHRoaXMubGV2ZWxUb0ludChtaW5MZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgbGV2ZWwgKHRyYWNlL2RlYnVnL2luZm8vd2Fybi9lcnJvcikgaW50byBhIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbkxldmVsXG4gICAgICovXG4gICAgcHJpdmF0ZSBsZXZlbFRvSW50KG1pbkxldmVsOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBpZiAobWluTGV2ZWwudG9Mb3dlckNhc2UoKSBpbiB0aGlzLmxldmVscykgcmV0dXJuIHRoaXMubGV2ZWxzW21pbkxldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBlbHNlIHJldHVybiA5OTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDZW50cmFsIGxvZ2dpbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBsb2dMZXZlbFxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICovXG4gICAgcHVibGljIGxvZyhsb2dMZXZlbDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmxldmVsVG9JbnQobG9nTGV2ZWwpO1xuICAgICAgICBpZiAobGV2ZWwgPCB0aGlzLm1pbkxldmVsKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbG9nRW50cnk6IExvZ0VudHJ5ID0ge1xuICAgICAgICAgICAgbGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgICAgbW9kdWxlOiB0aGlzLm1vZHVsZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBvYmplY3RzLFxuICAgICAgICAgICAgdHJhY2VJZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE9idGFpbiB0aGUgbGluZS9maWxlIHRocm91Z2ggYSB0aG9yb3VnaGx5IGhhY2t5IG1ldGhvZFxuICAgICAgICAvLyBUaGlzIGNyZWF0ZXMgYSBuZXcgc3RhY2sgdHJhY2UgYW5kIHB1bGxzIHRoZSBjYWxsZXIgZnJvbSBpdC4gIElmIHRoZSBjYWxsZXJcbiAgICAgICAgLy8gaWYgLnRyYWNlKClcbiAgICAgICAgLy8gY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJycpO1xuICAgICAgICAvLyBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IGNsYSA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgLy8gICAgIGxldCBpZHggPSAxO1xuICAgICAgICAvLyAgICAgd2hpbGUgKGlkeCA8IGNsYS5sZW5ndGggJiYgY2xhW2lkeF0uaW5jbHVkZXMoJ2F0IExvZ2dlci5PYmplY3QuJykpIGlkeCsrO1xuICAgICAgICAvLyAgICAgaWYgKGlkeCA8IGNsYS5sZW5ndGgpIHtcbiAgICAgICAgLy8gICAgICAgICBsb2dFbnRyeS5sb2NhdGlvbiA9IGNsYVtpZHhdLnNsaWNlKGNsYVtpZHhdLmluZGV4T2YoJ2F0ICcpICsgMywgY2xhW2lkeF0ubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHRoaXMubG9nTWFuYWdlci5lbWl0KCdsb2cnLCBsb2dFbnRyeSk7XG4gICAgfVxuXG4gICAgcHVibGljIHRyYWNlKG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZygndHJhY2UnLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZygnZGVidWcnLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcHVibGljIGluZm8obWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nKCdpbmZvJywgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyB3YXJuKG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZygnd2FybicsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cbiAgICBwdWJsaWMgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nKCdlcnJvcicsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENlbnRyYWwgbG9nZ2luZyBtZXRob2Qgd2l0aCBhIHRyYWNlIElEIHRvIHRyYWNrIGNhbGxzIGJldHdlZW4gbW9kdWxlcy9jb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSBsb2dMZXZlbFxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICovXG4gICAgcHVibGljIGxvZ1dpdGhJZChsb2dMZXZlbDogc3RyaW5nLCB0cmFjZUlkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMubGV2ZWxUb0ludChsb2dMZXZlbCk7XG4gICAgICAgIGlmIChsZXZlbCA8IHRoaXMubWluTGV2ZWwpIHJldHVybjtcblxuICAgICAgICBjb25zdCBsb2dFbnRyeTogTG9nRW50cnkgPSB7XG4gICAgICAgICAgICBsZXZlbDogbG9nTGV2ZWwsXG4gICAgICAgICAgICBtb2R1bGU6IHRoaXMubW9kdWxlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIG9iamVjdHMsXG4gICAgICAgICAgICB0cmFjZUlkLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubG9nTWFuYWdlci5lbWl0KCdsb2cnLCBsb2dFbnRyeSk7XG4gICAgfVxuXG4gICAgcHVibGljIHRyYWNlV2l0aElkKHRyYWNlSWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nV2l0aElkKCd0cmFjZScsIHRyYWNlSWQsIG1lc3NhZ2UsIG9iamVjdHMpO1xuICAgIH1cbiAgICBwdWJsaWMgZGVidWdXaXRoSWQodHJhY2VJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG9iamVjdHM/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2dXaXRoSWQoJ2RlYnVnJywgdHJhY2VJZCwgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyBpbmZvV2l0aElkKHRyYWNlSWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nV2l0aElkKCdpbmZvJywgdHJhY2VJZCwgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyB3YXJuV2l0aElkKHRyYWNlSWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBvYmplY3RzPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9nV2l0aElkKCd3YXJuJywgdHJhY2VJZCwgbWVzc2FnZSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHB1YmxpYyBlcnJvcldpdGhJZCh0cmFjZUlkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgb2JqZWN0cz86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZ1dpdGhJZCgnZXJyb3InLCB0cmFjZUlkLCBtZXNzYWdlLCBvYmplY3RzKTtcbiAgICB9XG59XG5cbnR5cGUgVGltaW5nTWFwID0ge1xuICAgIC8vIGNvdW50LCBhdmcsIG1pbiwgbWF4XG4gICAgW2lkOiBzdHJpbmddOiBudW1iZXJbXTtcbn07XG5cbmNvbnN0IHRpbWluZ01hcDogVGltaW5nTWFwID0ge307XG5cbi8qKlxuICogVGhpcyBkZWNlbGVyYXRpb24gd2lsbCBsb2cgdGhlIHRpbWUgdGFrZW4gdG8gcnVuIHRoZSBmdW5jdGlvbiBpdCBpcyBhdHRhY2hlZCB0by4gQmVcbiAqIGNhcmVmdWwgd2hlcmUgaXQgaXMgYWRkZWQgYXMgaXQgaW5jcmVhc2VzIHRoZSBvdXRwdXQuXG4gKlxuICogQGV4cG9ydFxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ0NhbGwgPSAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAvL2NvbnN0IGxvZ2dlciA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd0YXNrc3NxbC5wZXJmJyk7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShEYXRlLm5vdygpKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke3RhcmdldD8uY29uc3RydWN0b3I/Lm5hbWV9JHtwcm9wZXJ0eUtleX1gO1xuICAgICAgICBjb25zdCB0aW1lID0gZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpO1xuICAgICAgICBpZiAodGltaW5nTWFwW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWluZ01hcFtuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRpbWluZ01hcFtuYW1lXS5wdXNoKHRpbWUpO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2codGltaW5nTWFwKTtcbiAgICAgICAgLy8gaWYgKGVuZFRpbWUuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLmdldFRpbWUoKSA+IDUwKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAvLyAgICAgICAgIGBbZGVidWddW3Rhc2tzc3FsLnBlcmZdICR7U3RyaW5nKHRpbWluZ01hcFtuYW1lXS5hdmcpLnBhZEVuZCg0KX0ke1N0cmluZyhcbiAgICAgICAgLy8gICAgICAgICAgICAgZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpLFxuICAgICAgICAvLyAgICAgICAgICkucGFkRW5kKDQpfSAke3RhcmdldD8uY29uc3RydWN0b3I/Lm5hbWUucGFkRW5kKDEwKX0ke3Byb3BlcnR5S2V5LnBhZEVuZCgyMCl9YCxcbiAgICAgICAgLy8gICAgICk7XG5cbiAgICAgICAgLy8gICAgIC8vIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgLy8gICAgIC8vICAgICBgJHt0YXJnZXQ/LmNvbnN0cnVjdG9yPy5uYW1lfToke3Byb3BlcnR5S2V5fTpjYWxsZWQgd2l0aCAke2FyZ3MubGVuZ3RofSBhcmd1bWVudHMuIFRvb2s6ICR7XG4gICAgICAgIC8vICAgICAvLyAgICAgICAgIGVuZFRpbWUuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLmdldFRpbWUoKVxuICAgICAgICAvLyAgICAgLy8gICAgIH1tc2AsXG4gICAgICAgIC8vICAgICAvLyApO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0NhbGxEZXRhaWxzKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIHByb3BlcnR5S2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd0YXNrc3NxbCcpO1xuXG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKERhdGUubm93KCkpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAgYCR7dHlwZW9mIHRhcmdldH06JHtwcm9wZXJ0eUtleX0gY2FsbGVkIHdpdGggJHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgICB9IGFyZ3VtZW50cy4gVG9vazogJHtlbGFwc2VkfW1zICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgc2ltcGxlIGxvZyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvZyBtZXNzYWdlcyBhZ2FpbnN0IGRlZmF1bHQgbW9kdWxlLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7VExvZ0xldmVsTmFtZX0gbG9nTGV2ZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2cobG9nTGV2ZWw6IFRMb2dMZXZlbE5hbWUsIG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnN0IGxvZ2dlciA9IGxvZ2dpbmcuZ2V0TG9nZ2VyKCd0YXNrc3NxbCcpO1xuXG4gICAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgICAgICBjYXNlICd0cmFjZSc6XG4gICAgICAgICAgICBsb2dnZXIudHJhY2UobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVidWcnOlxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgbG9nZ2VyLmluZm8obWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICBsb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGFsbG93cyB0aGUgcGx1Z2luIHRvIGJlIGRlYnVnZ2VkIGluIGEgbW9iaWxlIGFwcGxpY2F0aW9uXG4gKiBhZGQgaXQgd2hlbiBkZWJ1Z2dpbmcgb24gYSBkZXZpY2UuIE5vdCBtZWFudCB0byBiZSB1c2VkIGJ5XG4gKiBlbmQgdXNlcnMuIEFkZCBpdCBpbnRvIG1haW4udHMgYW5kIHJlbW92ZSBiZWZvcmUgeW91IGNvbW1pdC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9ua2V5UGF0Y2hDb25zb2xlKHBsdWdpbjogUGx1Z2luKSB7XG4gICAgaWYgKCFQbGF0Zm9ybS5pc01vYmlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbG9nRmlsZSA9IGAke3BsdWdpbi5tYW5pZmVzdC5kaXJ9L3Rhc2tzLXNxbC1sb2dzLnR4dGA7XG4gICAgY29uc3QgbG9nczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBsb2dNZXNzYWdlcyA9XG4gICAgICAgIChwcmVmaXg6IHN0cmluZykgPT5cbiAgICAgICAgKC4uLm1lc3NhZ2VzOiB1bmtub3duW10pID0+IHtcbiAgICAgICAgICAgIGxvZ3MucHVzaChgXFxuWyR7cHJlZml4fV1gKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGxvZ3MucHVzaChTdHJpbmcobWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKGxvZ0ZpbGUsIGxvZ3Muam9pbignICcpKTtcbiAgICAgICAgfTtcblxuICAgIGNvbnNvbGUuZGVidWcgPSBsb2dNZXNzYWdlcygnZGVidWcnKTtcbiAgICBjb25zb2xlLmVycm9yID0gbG9nTWVzc2FnZXMoJ2Vycm9yJyk7XG4gICAgY29uc29sZS5pbmZvID0gbG9nTWVzc2FnZXMoJ2luZm8nKTtcbiAgICBjb25zb2xlLmxvZyA9IGxvZ01lc3NhZ2VzKCdsb2cnKTtcbiAgICBjb25zb2xlLndhcm4gPSBsb2dNZXNzYWdlcygnd2FybicpO1xufVxuIiwgImltcG9ydCB0eXBlIHsgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTWFya2Rvd25SZW5kZXJDaGlsZCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEdsb2JhbEZpbHRlciB9IGZyb20gJy4vQ29uZmlnL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB7IHRhc2tUb0xpIH0gZnJvbSAnLi9UYXNrTGluZVJlbmRlcmVyJztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4vVGFza0xvY2F0aW9uJztcblxuZXhwb3J0IGNsYXNzIElubGluZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiB9OiB7IHBsdWdpbjogUGx1Z2luIH0pIHtcbiAgICAgICAgcGx1Z2luLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKHRoaXMuX21hcmtkb3duUG9zdFByb2Nlc3Nvci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFya2Rvd25Qb3N0UHJvY2Vzc29yID0gdGhpcy5fbWFya2Rvd25Qb3N0UHJvY2Vzc29yLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlbmRlcnMgYSBmaWxlJ3MgdGFzayBsaXN0IHdoZW4gcmVuZGVyZWQgaW4gUmVhZGluZyBWaWV3LCB1c2luZyByb3VnaGx5IHRoZSBzYW1lIHBpcGVsaW5lXG4gICAgICogb2YgUXVlcnlSZW5kZXJlciAoZS5nLiBpdCByZW1vdmVzIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBoYW5kbGVzIG90aGVyIGZvcm1hdHRpbmcpLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX21hcmtkb3duUG9zdFByb2Nlc3NvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGV4dDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBBcyBvZiBPYnNpZGlhbiAxLjMuMCwgaXQgaXMgcmVxdWlyZWQgYnkgT2JzaWRpYW4gdG8gY3JlYXRlIGFuZC9vciBwYXNzIGEgQ29tcG9uZW50IG9iamVjdFxuICAgICAgICAvLyB3aGVuIHVzaW5nIGl0cyBNYXJrZG93biByZW5kZXJpbmcgbWV0aG9kc1xuICAgICAgICBjb25zdCBjaGlsZENvbXBvbmVudCA9IG5ldyBNYXJrZG93blJlbmRlckNoaWxkKGVsZW1lbnQpO1xuICAgICAgICBjb250ZXh0LmFkZENoaWxkKGNoaWxkQ29tcG9uZW50KTtcblxuICAgICAgICBjb25zdCByZW5kZXJlZEVsZW1lbnRzID0gZWxlbWVudC5maW5kQWxsKCcudGFzay1saXN0LWl0ZW0nKS5maWx0ZXIoKHRhc2tJdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lc1RleHQgPSB0YXNrSXRlbS50ZXh0Q29udGVudD8uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBsaW5lLiBDYW4gYmUgbXVsdGlwbGUgbGluZXMgaWYgYW4gTEkgZWxlbWVudCBjb250YWlucyBhbiBVTC5cbiAgICAgICAgICAgIC8vIFdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBsZXZlbCBMSSBpbmRlcGVuZGVudGx5IGZyb20gaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgZmFsc2UgcG9zaXRpdmUsIHdoZW4gdGhlIExJIHdhc24ndCBhIHRhc2sgaXRzZWxmLCBidXQgY29udGFpbmVkIHRoZVxuICAgICAgICAgICAgLy8gZ2xvYmFsIGZpbHRlciBpbiBjaGlsZCBMSXMuXG4gICAgICAgICAgICBsZXQgZmlyc3RMaW5lVGV4dDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBsaW5lIGlzIHRoZSBmaXJzdCBsaW5lIHRoYXQgaXMgbm90IGVtcHR5LiBFbXB0eSBsaW5lcyBjYW4gZXhpc3Qgd2hlblxuICAgICAgICAgICAgLy8gdGhlIGNoZWNrbGlzdCBpbiBtYXJrZG93biBpbmNsdWRlcyBibGFuayBsaW5lcyAoc2VlICMzMTMpLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc1RleHQubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZXNUZXh0W2ldICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmVUZXh0ID0gbGluZXNUZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdExpbmVUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsRmlsdGVyLmdldEluc3RhbmNlKCkuaW5jbHVkZWRJbihmaXJzdExpbmVUZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gdGFza3MgbWVhbnMgbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhdGggPSBjb250ZXh0LnNvdXJjZVBhdGg7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBjb250ZXh0LmdldFNlY3Rpb25JbmZvKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW5ub3QgcHJvY2VzcyB0aGUgcmVuZGVyIHdpdGhvdXQgdGhlIHNlY3Rpb24gaW5mby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVMaW5lcyA9IHNlY3Rpb24udGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgbGV0IHNlY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGZpbGVUYXNrczogVGFza1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBzZWN0aW9uLmxpbmVTdGFydDsgbGluZU51bWJlciA8PSBzZWN0aW9uLmxpbmVFbmQ7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGZpbGVMaW5lc1tsaW5lTnVtYmVyXTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlbmQgdXAgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgdGhlIGZpbGUsXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHByb2Nlc3MgdGhpcyB0YXNrLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcmVjZWRpbmdIZWFkZXIgPSBudWxsOyAvLyBXZSBkb24ndCBuZWVkIHRoZSBwcmVjZWRpbmcgaGVhZGVyIGZvciBpbi1saW5lIHJlbmRlcmluZy5cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBUYXNrLmZyb21MaW5lKHtcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogbmV3IFRhc2tMb2NhdGlvbihwYXRoLCBsaW5lTnVtYmVyLCBzZWN0aW9uLmxpbmVTdGFydCwgc2VjdGlvbkluZGV4LCBwcmVjZWRpbmdIZWFkZXIpLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrRGF0ZTogbnVsbCwgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgZmFsbGJhY2sgZGF0ZSBmb3IgaW4tbGluZSByZW5kZXJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWxlVGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzZWN0aW9uIGluZGV4IGlzIHRoZSBudGggdGFzayB3aXRoaW4gdGhpcyBzZWN0aW9uLlxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uSW5kZXggPSAwOyBzZWN0aW9uSW5kZXggPCByZW5kZXJlZEVsZW1lbnRzLmxlbmd0aDsgc2VjdGlvbkluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBmaWxlVGFza3Nbc2VjdGlvbkluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkRWxlbWVudCA9IHJlbmRlcmVkRWxlbWVudHNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgICAgICAgaWYgKHRhc2sgPT09IHVuZGVmaW5lZCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIG1hdGNoIG9mIHRhc2tzIGluIGZpbGUgYW5kIHJlbmRlciBwcmV2aWV3LlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbWlzLW1hdGNoIGluIHRoZSBudW1iZXJzLCB3ZSBzdGlsbCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gd2hhdCB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFMaW5lOiBzdHJpbmcgPSByZW5kZXJlZEVsZW1lbnQuZ2V0QXR0cignZGF0YS1saW5lJykgPz8gJzAnO1xuICAgICAgICAgICAgY29uc3QgbGlzdEluZGV4OiBudW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoZGF0YUxpbmUsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tFbGVtZW50ID0gYXdhaXQgdGFza1RvTGkodGFzaywge1xuICAgICAgICAgICAgICAgIHBhcmVudFVsRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgb2JzaWRpYW5Db21wb25lbnQ6IGNoaWxkQ29tcG9uZW50LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGEgc3ViLWxpc3Qgb3Igc3ViLWRpdiAoZS5nLiB0aGVcbiAgICAgICAgICAgIC8vIGZvbGRpbmcgYXJyb3cpLCB3ZSBuZWVkIHRvIGtlZXAgaXQuXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkcmVuID0gcmVuZGVyZWRFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrRWxlbWVudC5wcmVwZW5kKHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVuZGVyZWRDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tFbGVtZW50LmFwcGVuZChyZW5kZXJlZENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLXNldCB0aGUgb3JpZ2luYWwgZm9vdG5vdGVzLlxuICAgICAgICAgICAgLy8gVGhlIG5ld2x5IHJlbmRlcmVkIEhUTUwgd29uJ3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleGVzIGFuZCBsaW5rc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvb3Rub3RlcyA9IHJlbmRlcmVkRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mb290bm90ZS1pZF0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Zvb3Rub3RlcyA9IHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvb3Rub3RlLWlkXScpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRm9vdG5vdGVzLmxlbmd0aCA9PT0gbmV3Rm9vdG5vdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxGb290bm90ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Rm9vdG5vdGVzW2ldLnJlcGxhY2VXaXRoKG9yaWdpbmFsRm9vdG5vdGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5yZXBsYWNlV2l0aCh0YXNrRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHR5cGUgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCAqIGFzIHRhc2tNb2R1bGUgZnJvbSAnLi9UYXNrJztcbmltcG9ydCB0eXBlIHsgTGF5b3V0T3B0aW9ucywgVGFza0xheW91dENvbXBvbmVudCB9IGZyb20gJy4vVGFza0xheW91dCc7XG5pbXBvcnQgeyBUYXNrTGF5b3V0IH0gZnJvbSAnLi9UYXNrTGF5b3V0JztcbmltcG9ydCB7IHJlcGxhY2VUYXNrV2l0aFRhc2tzIH0gZnJvbSAnLi9GaWxlJztcbmltcG9ydCB7IFRBU0tfRk9STUFUUywgZ2V0U2V0dGluZ3MgfSBmcm9tICcuL0NvbmZpZy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuL0NvbmZpZy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IHsgUHJpb3JpdHlUb29scyB9IGZyb20gJy4vbGliL1ByaW9yaXR5VG9vbHMnO1xuXG5leHBvcnQgdHlwZSBUYXNrTGluZVJlbmRlckRldGFpbHMgPSB7XG4gICAgcGFyZW50VWxFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICAvKiogVGhlIG50aCBpdGVtIGluIHRoaXMgbGlzdCAoaW5jbHVkaW5nIG5vbi10YXNrcykuICovXG4gICAgbGlzdEluZGV4OiBudW1iZXI7XG4gICAgb2JzaWRpYW5Db21wb25lbnQ6IENvbXBvbmVudCB8IG51bGw7XG4gICAgbGF5b3V0T3B0aW9ucz86IExheW91dE9wdGlvbnM7XG4gICAgaXNGaWxlbmFtZVVuaXF1ZT86IGJvb2xlYW47XG4gICAgdGFza0xheW91dD86IFRhc2tMYXlvdXQ7XG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0Q2xhc3NlczogeyBbYyBpbiBUYXNrTGF5b3V0Q29tcG9uZW50XTogc3RyaW5nIH0gPSB7XG4gICAgZGVzY3JpcHRpb246ICd0YXNrLWRlc2NyaXB0aW9uJyxcbiAgICBwcmlvcml0eTogJ3Rhc2stcHJpb3JpdHknLFxuICAgIGR1ZURhdGU6ICd0YXNrLWR1ZScsXG4gICAgc3RhcnREYXRlOiAndGFzay1zdGFydCcsXG4gICAgY3JlYXRlZERhdGU6ICd0YXNrLWNyZWF0ZWQnLFxuICAgIHNjaGVkdWxlZERhdGU6ICd0YXNrLXNjaGVkdWxlZCcsXG4gICAgZG9uZURhdGU6ICd0YXNrLWRvbmUnLFxuICAgIHJlY3VycmVuY2VSdWxlOiAndGFzay1yZWN1cnJpbmcnLFxuICAgIGJsb2NrTGluazogJycsXG59O1xuXG5jb25zdCBNQVhfREFZX1ZBTFVFX1JBTkdFID0gNztcbmNvbnN0IERBWV9WQUxVRV9PVkVSX1JBTkdFX1BPU1RGSVggPSAnZmFyJztcblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gdXNlZCB0byByZW5kZXIgYSBNYXJrZG93biB0YXNrIGxpbmUgaW50byBhbiBleGlzdGluZyBIVE1MIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCB0eXBlIFRleHRSZW5kZXJlciA9IChcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgZWxlbWVudDogSFRNTFNwYW5FbGVtZW50LFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvYnNpZGlhbkNvbXBvbmVudDogQ29tcG9uZW50IHwgbnVsbCwgLy8gbnVsbCBpcyBhbGxvd2VkIGhlcmUgb25seSBmb3IgdGVzdHNcbikgPT4gUHJvbWlzZTx2b2lkPjtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZ2l2ZW4gVGFzayBvYmplY3QgaW50byBhbiBIVE1MIExpc3QgSXRlbSAoTEkpIGVsZW1lbnQsIHVzaW5nIHRoZSBnaXZlbiByZW5kZXJEZXRhaWxzXG4gKiBjb25maWd1cmF0aW9uIGFuZCBhIHN1cHBsaWVkIFRleHRSZW5kZXJlciAodHlwaWNhbGx5IHRoZSBPYnNpZGlhbiBNYXJrZG93biByZW5kZXJlciwgYnV0IGZvciB0ZXN0aW5nXG4gKiBwdXJwb3NlcyBpdCBjYW4gYmUgYSBzaW1wbGVyIG9uZSkuXG4gKiBUaGUgZWxlbWVudCBpbmNsdWRlcyB0aGUgdGFzayBhbmQgaXRzIHZhcmlvdXMgY29tcG9uZW50cyAoZGVzY3JpcHRpb24sIHByaW9yaXR5LCBibG9jayBsaW5rIGV0YyksIHRoZVxuICogY2hlY2tib3ggb24gdGhlIGxlZnQgd2l0aCBpdHMgZXZlbnQgaGFuZGxpbmcgb2YgY29tcGxldGluZyB0aGUgdGFzaywgYW5kIHRoZSBidXR0b24gZm9yIGVkaXRpbmcgdGhlIHRhc2suXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5kZXJUYXNrTGluZShcbiAgICB0YXNrOiBUYXNrLFxuICAgIHJlbmRlckRldGFpbHM6IFRhc2tMaW5lUmVuZGVyRGV0YWlscyxcbiAgICB0ZXh0UmVuZGVyZXI6IFRleHRSZW5kZXJlcixcbik6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgIGNvbnN0IGxpOiBIVE1MTElFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICByZW5kZXJEZXRhaWxzLnBhcmVudFVsRWxlbWVudC5hcHBlbmRDaGlsZChsaSk7XG5cbiAgICBsaS5jbGFzc0xpc3QuYWRkKCd0YXNrLWxpc3QtaXRlbScsICdwbHVnaW4tdGFza3MtbGlzdC1pdGVtJyk7XG5cbiAgICAvLyBNYWludGVuYW5jZSBub3RlOlxuICAgIC8vICBXZSBkb24ndCB1c2UgdGhlIE9ic2lkaWFuIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGxpLmNyZWF0ZUVsKCkgaGVyZSwgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGl0IGF2YWlsYWJsZVxuICAgIC8vICB3aGVuIHJ1bm5pbmcgdGVzdHMsIGFuZCB3ZSB3YW50IHRoZSB0ZXN0cyB0byBiZSBhYmxlIHRvIGNyZWF0ZSB0aGUgZnVsbCBkaXYgYW5kIHNwYW4gc3RydWN0dXJlLFxuICAgIC8vICBzbyBoYWQgdG8gY29udmVydCBhbGwgb2YgdGhlc2UgdG8gdGhlIGVxdWl2YWxlbnQgYnV0IG1vcmUgZWxhYm9yYXRlIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKSBhbmRcbiAgICAvLyAgYXBwZW5kQ2hpbGQoKSBjYWxscy5cbiAgICBjb25zdCB0ZXh0U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBsaS5hcHBlbmRDaGlsZCh0ZXh0U3Bhbik7XG4gICAgdGV4dFNwYW4uY2xhc3NMaXN0LmFkZCgndGFza3MtbGlzdC10ZXh0Jyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGF3YWl0IHRhc2tUb0h0bWwodGFzaywgcmVuZGVyRGV0YWlscywgdGV4dFNwYW4sIHRleHRSZW5kZXJlcik7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykgbGkuZGF0YXNldFtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXG4gICAgLy8gTk9URTogdGhpcyBhcmVhIGlzIG1lbnRpb25lZCBpbiBgQ09OVFJJQlVUSU5HLm1kYCB1bmRlciBcIkhvdyBkb2VzIFRhc2tzIGhhbmRsZSBzdGF0dXMgY2hhbmdlc1wiLiBXaGVuXG4gICAgLy8gbW92aW5nIHRoZSBjb2RlLCByZW1lbWJlciB0byB1cGRhdGUgdGhhdCByZWZlcmVuY2UgdG9vLlxuICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBsaS5hcHBlbmRDaGlsZChjaGVja2JveCk7XG4gICAgY2hlY2tib3guY2xhc3NMaXN0LmFkZCgndGFzay1saXN0LWl0ZW0tY2hlY2tib3gnKTtcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICBpZiAodGFzay5zdGF0dXMuc3ltYm9sICE9PSAnICcpIHtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2lzLWNoZWNrZWQnKTtcbiAgICB9XG5cbiAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBJdCBpcyByZXF1aXJlZCB0byBzdG9wIHByb3BhZ2F0aW9uIHNvIHRoYXQgb2JzaWRpYW4gd29uJ3Qgd3JpdGUgdGhlIGZpbGUgd2l0aCB0aGVcbiAgICAgICAgLy8gY2hlY2tib3ggKHVuKWNoZWNrZWQuIE9ic2lkaWFuIHdvdWxkIHdyaXRlIGFmdGVyIHVzIGFuZCBvdmVyd3JpdGUgb3VyIGNoYW5nZS5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIHJlLXJlbmRlcmVkIGFzIGVuYWJsZWQgYWZ0ZXIgdXBkYXRlIGluIGZpbGUuXG4gICAgICAgIGNoZWNrYm94LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9nZ2xlZFRhc2tzID0gdGFzay50b2dnbGVXaXRoUmVjdXJyZW5jZUluVXNlcnNPcmRlcigpO1xuICAgICAgICByZXBsYWNlVGFza1dpdGhUYXNrcyh7XG4gICAgICAgICAgICBvcmlnaW5hbFRhc2s6IHRhc2ssXG4gICAgICAgICAgICBuZXdUYXNrczogdG9nZ2xlZFRhc2tzLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGxpLnByZXBlbmQoY2hlY2tib3gpO1xuXG4gICAgLy8gU2V0IHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBzdG9jayBvYnNpZGlhbiBsaXN0czpcbiAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGFzaycsIHRhc2suc3RhdHVzLnN5bWJvbC50cmltKCkpOyAvLyBUcmltIHRvIGVuc3VyZSBlbXB0eSBhdHRyaWJ1dGUgZm9yIHNwYWNlLiBTYW1lIHdheSBhcyBvYnNpZGlhbi5cbiAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZScsIHJlbmRlckRldGFpbHMubGlzdEluZGV4LnRvU3RyaW5nKCkpO1xuICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS10YXNrLXN0YXR1cy1uYW1lJywgdGFzay5zdGF0dXMubmFtZSk7XG4gICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhLXRhc2stc3RhdHVzLXR5cGUnLCB0YXNrLnN0YXR1cy50eXBlKTtcbiAgICBjaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGluZScsIHJlbmRlckRldGFpbHMubGlzdEluZGV4LnRvU3RyaW5nKCkpO1xuXG4gICAgaWYgKHJlbmRlckRldGFpbHMubGF5b3V0T3B0aW9ucz8uc2hvcnRNb2RlKSB7XG4gICAgICAgIGFkZFRvb2x0aXAoeyB0YXNrLCBlbGVtZW50OiB0ZXh0U3BhbiwgaXNGaWxlbmFtZVVuaXF1ZTogcmVuZGVyRGV0YWlscy5pc0ZpbGVuYW1lVW5pcXVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaTtcbn1cblxuZXhwb3J0IHR5cGUgQXR0cmlidXRlc0RpY3Rpb25hcnkgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG5hc3luYyBmdW5jdGlvbiB0YXNrVG9IdG1sKFxuICAgIHRhc2s6IFRhc2ssXG4gICAgcmVuZGVyRGV0YWlsczogVGFza0xpbmVSZW5kZXJEZXRhaWxzLFxuICAgIHBhcmVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgIHRleHRSZW5kZXJlcjogVGV4dFJlbmRlcmVyLFxuKTogUHJvbWlzZTxBdHRyaWJ1dGVzRGljdGlvbmFyeT4ge1xuICAgIGxldCBhbGxBdHRyaWJ1dGVzOiBBdHRyaWJ1dGVzRGljdGlvbmFyeSA9IHt9O1xuICAgIGNvbnN0IHRhc2tMYXlvdXQgPSBuZXcgVGFza0xheW91dChyZW5kZXJEZXRhaWxzLmxheW91dE9wdGlvbnMpO1xuICAgIGNvbnN0IGVtb2ppU2VyaWFsaXplciA9IFRBU0tfRk9STUFUUy50YXNrc1BsdWdpbkVtb2ppLnRhc2tTZXJpYWxpemVyO1xuICAgIC8vIFJlbmRlciBhbmQgYnVpbGQgY2xhc3NlcyBmb3IgYWxsIHRoZSB0YXNrJ3MgdmlzaWJsZSBjb21wb25lbnRzXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgdGFza0xheW91dC5zaG93blRhc2tMYXlvdXRDb21wb25lbnRzKSB7XG4gICAgICAgIGxldCBjb21wb25lbnRTdHJpbmcgPSBlbW9qaVNlcmlhbGl6ZXIuY29tcG9uZW50VG9TdHJpbmcodGFzaywgdGFza0xheW91dCwgY29tcG9uZW50KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2Rlc2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0cmluZyA9IEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLnJlbW92ZUFzV29yZEZyb21EZXBlbmRpbmdPblNldHRpbmdzKGNvbXBvbmVudFN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgc3BhbiB0aGF0IHdpbGwgaG9sZCB0aGUgcmVuZGVyZWQgY29tcG9uZW50XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zaWRlIHRoYXQgdGV4dCBzcGFuLCB3ZSBhcmUgY3JlYXRpbmcgYW5vdGhlciBpbnRlcm5hbCBzcGFuLCB0aGF0IHdpbGwgaG9sZCB0aGUgdGV4dCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgc2VlbSByZWR1bmRhbnQsIGFuZCBieSBkZWZhdWx0IGl0IGluZGVlZCBkb2VzIG5vdGhpbmcsIGJ1dCB3ZSBkbyBpdCB0byBhbGxvdyB0aGUgQ1NTXG4gICAgICAgICAgICAgICAgLy8gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBjb250YWluZXIgb2YgdGhlIHRleHQgYW5kIHRoZSB0ZXh0IGl0c2VsZiwgc28gaXQgd2lsbCBiZSBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIC8vIHRvIGRvIHRoaW5ncyBsaWtlIHN1cnJvdWRpbmcgb25seSB0aGUgdGV4dCAocmF0aGVyIHRoYW4gaXRzIHdob2xlIHBsYWNlaG9sZGVyKSB3aXRoIGEgaGlnaGxpZ2h0XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoaW50ZXJuYWxTcGFuKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW5kZXJDb21wb25lbnRUZXh0KFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFNwYW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UmVuZGVyZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckRldGFpbHMub2JzaWRpYW5Db21wb25lbnQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhZGRJbnRlcm5hbENsYXNzZXMoY29tcG9uZW50LCBpbnRlcm5hbFNwYW4pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb21wb25lbnQncyBDU1MgY2xhc3MgZGVzY3JpYmluZyB3aGF0IHRoaXMgY29tcG9uZW50IGlzIChwcmlvcml0eSwgZHVlIGRhdGUgZXRjLilcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRDbGFzcyA9IGdldFRhc2tDb21wb25lbnRDbGFzcyhjb21wb25lbnQsIHRhc2spO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCguLi5jb21wb25lbnRDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbXBvbmVudCdzIGF0dHJpYnV0ZSAoJ3ByaW9yaXR5LW1lZGl1bScsICdkdWUtcGFzdC0xZCcgZXRjLilcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnREYXRhQXR0cmlidXRlID0gZ2V0Q29tcG9uZW50RGF0YUF0dHJpYnV0ZShjb21wb25lbnQsIHRhc2spO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXBvbmVudERhdGFBdHRyaWJ1dGUpIHNwYW4uZGF0YXNldFtrZXldID0gY29tcG9uZW50RGF0YUF0dHJpYnV0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGFsbEF0dHJpYnV0ZXMgPSB7IC4uLmFsbEF0dHJpYnV0ZXMsIC4uLmNvbXBvbmVudERhdGFBdHRyaWJ1dGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdyBidWlsZCBjbGFzc2VzIGZvciB0aGUgaGlkZGVuIHRhc2sgY29tcG9uZW50cyB3aXRob3V0IHJlbmRlcmluZyB0aGVtXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgdGFza0xheW91dC5oaWRkZW5UYXNrTGF5b3V0Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBoaWRkZW5Db21wb25lbnREYXRhQXR0cmlidXRlID0gZ2V0Q29tcG9uZW50RGF0YUF0dHJpYnV0ZShjb21wb25lbnQsIHRhc2spO1xuICAgICAgICBhbGxBdHRyaWJ1dGVzID0geyAuLi5hbGxBdHRyaWJ1dGVzLCAuLi5oaWRkZW5Db21wb25lbnREYXRhQXR0cmlidXRlIH07XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0YXNrIGhhcyBubyBwcmlvcml0eSBmaWVsZCBzZXQsIGl0cyBwcmlvcml0eSB3aWxsIG5vdCBiZSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBsb29wIGFib3ZlIGFuZFxuICAgIC8vIGl0IHdpbGwgbm90IGJlIHNldCBhIHByaW9yaXR5IGRhdGEgYXR0cmlidXRlLlxuICAgIC8vIEluIHN1Y2ggYSBjYXNlIHdlIHdhbnQgdGhlIHVwcGVyIHRhc2sgTEkgZWxlbWVudCB0byBtYXJrIHRoZSB0YXNrIGhhcyBhICdub3JtYWwnIHByaW9yaXR5LlxuICAgIC8vIFNvIGlmIHRoZSBwcmlvcml0eSB3YXMgbm90IHJlbmRlcmVkLCBmb3JjZSBpdCB0aHJvdWdoIHRoZSBwaXBlIG9mIGdldHRpbmcgdGhlIGNvbXBvbmVudCBkYXRhIGZvciB0aGVcbiAgICAvLyBwcmlvcml0eSBmaWVsZC5cbiAgICBpZiAoYWxsQXR0cmlidXRlcy50YXNrUHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwcmlvcml0eURhdGFBdHRyaWJ1dGUgPSBnZXRDb21wb25lbnREYXRhQXR0cmlidXRlKCdwcmlvcml0eScsIHRhc2spO1xuICAgICAgICBhbGxBdHRyaWJ1dGVzID0geyAuLi5hbGxBdHRyaWJ1dGVzLCAuLi5wcmlvcml0eURhdGFBdHRyaWJ1dGUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsQXR0cmlidXRlcztcbn1cblxuLypcbiAqIFJlbmRlcnMgdGhlIGdpdmVuIGNvbXBvbmVudCBpbnRvIHRoZSBnaXZlbiBIVE1MIHNwYW4gZWxlbWVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50VGV4dChcbiAgICBzcGFuOiBIVE1MU3BhbkVsZW1lbnQsXG4gICAgY29tcG9uZW50U3RyaW5nOiBzdHJpbmcsXG4gICAgY29tcG9uZW50OiBUYXNrTGF5b3V0Q29tcG9uZW50LFxuICAgIHRhc2s6IFRhc2ssXG4gICAgdGV4dFJlbmRlcmVyOiBUZXh0UmVuZGVyZXIsXG4gICAgb2JzaWRpYW5Db21wb25lbnQ6IENvbXBvbmVudCB8IG51bGwsXG4pIHtcbiAgICBpZiAoY29tcG9uZW50ID09PSAnZGVzY3JpcHRpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgZGVidWdTZXR0aW5ncyB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKGRlYnVnU2V0dGluZ3Muc2hvd1Rhc2tIaWRkZW5EYXRhKSB7XG4gICAgICAgICAgICAvLyBBZGQgc29tZSBkZWJ1ZyBvdXRwdXQgdG8gZW5hYmxlIGhpZGRlbiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFzayB0byBiZSBpbnNwZWN0ZWQuXG4gICAgICAgICAgICBjb21wb25lbnRTdHJpbmcgKz0gYDxicj5cdUQ4M0RcdURDMUIgPGI+JHt0YXNrLmxpbmVOdW1iZXJ9PC9iPiAuICR7dGFzay5zZWN0aW9uU3RhcnR9IC4gJHt0YXNrLnNlY3Rpb25JbmRleH0gLiAnPGNvZGU+JHt0YXNrLm9yaWdpbmFsTWFya2Rvd259PC9jb2RlPic8YnI+Jzxjb2RlPiR7dGFzay5wYXRofTwvY29kZT4nID4gJzxjb2RlPiR7dGFzay5wcmVjZWRpbmdIZWFkZXJ9PC9jb2RlPic8YnI+YDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0ZXh0UmVuZGVyZXIoY29tcG9uZW50U3RyaW5nLCBzcGFuLCB0YXNrLnBhdGgsIG9ic2lkaWFuQ29tcG9uZW50KTtcblxuICAgICAgICAvLyBJZiB0aGUgdGFzayBpcyBhIGJsb2NrIHF1b3RlLCB0aGUgYmxvY2sgcXVvdGUgd3JhcHMgdGhlIHAtdGFnIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB1bndyYXAgdGhlIHAtdGFnICppbnNpZGUqIHRoZSBzdXJyb3VuZGluZyBibG9jayBxdW90ZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB1bndyYXAgdGhlIHAtdGFnIGFzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIHNwYW4uXG4gICAgICAgIGNvbnN0IGJsb2NrUXVvdGUgPSBzcGFuLnF1ZXJ5U2VsZWN0b3IoJ2Jsb2NrcXVvdGUnKTtcbiAgICAgICAgY29uc3QgZGlyZWN0UGFyZW50T2ZQVGFnID0gYmxvY2tRdW90ZSA/PyBzcGFuO1xuXG4gICAgICAgIC8vIFVud3JhcCB0aGUgcC10YWcgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgTWFya2Rvd25SZW5kZXJlcjpcbiAgICAgICAgY29uc3QgcEVsZW1lbnQgPSBkaXJlY3RQYXJlbnRPZlBUYWcucXVlcnlTZWxlY3RvcigncCcpO1xuICAgICAgICBpZiAocEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlIChwRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0UGFyZW50T2ZQVGFnLmluc2VydEJlZm9yZShwRWxlbWVudC5maXJzdENoaWxkLCBwRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbiBlbXB0eSB0cmFpbGluZyBwLXRhZyB0aGF0IHRoZSBNYXJrZG93blJlbmRlcmVyIGFwcGVuZHMgd2hlbiB0aGVyZSBpcyBhIGJsb2NrIGxpbms6XG4gICAgICAgIHNwYW4ucXVlcnlTZWxlY3RvckFsbCgncCcpLmZvckVhY2goKHBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBFbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIHBFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZvb3Rub3RlIHRoYXQgdGhlIE1hcmtkb3duUmVuZGVyZXIgYXBwZW5kcyB3aGVuIHRoZXJlIGlzIGEgZm9vdG5vdGUgaW4gdGhlIHRhc2s6XG4gICAgICAgIHNwYW4ucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rub3RlcycpLmZvckVhY2goKGZvb3Rub3RlRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZm9vdG5vdGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvbXBvbmVudFN0cmluZztcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IGRlc2NyaWJlcyB3aGF0IHRoZSBjb21wb25lbnQgaXMsIGUuZy4gYSBkdWUgZGF0ZSBvciBhIHByaW9yaXR5LCBhbmQgaXMgYSB2YWx1ZSBmcm9tIExheW91dENsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFRhc2tDb21wb25lbnRDbGFzcyhjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQsIHRhc2s6IFRhc2spIHtcbiAgICBjb25zdCBjb21wb25lbnRDbGFzc0NvbnRhaW5lcjogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0IGNvbXBvbmVudENsYXNzID0gTGF5b3V0Q2xhc3Nlc1tjb21wb25lbnRdO1xuICAgIHN3aXRjaCAoY29tcG9uZW50KSB7XG4gICAgICAgIGNhc2UgJ2Jsb2NrTGluayc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICBjYXNlICdwcmlvcml0eSc6XG4gICAgICAgIGNhc2UgJ3JlY3VycmVuY2VSdWxlJzpcbiAgICAgICAgICAgIGNvbXBvbmVudENsYXNzQ29udGFpbmVyLnB1c2goY29tcG9uZW50Q2xhc3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NyZWF0ZWREYXRlJzpcbiAgICAgICAgY2FzZSAnZHVlRGF0ZSc6XG4gICAgICAgIGNhc2UgJ3N0YXJ0RGF0ZSc6XG4gICAgICAgIGNhc2UgJ3NjaGVkdWxlZERhdGUnOlxuICAgICAgICBjYXNlICdkb25lRGF0ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0YXNrW2NvbXBvbmVudF07XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENsYXNzQ29udGFpbmVyLnB1c2goY29tcG9uZW50Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudENsYXNzQ29udGFpbmVyO1xufVxuXG4vKipcbiAqIFRoZSBkYXRhIGF0dHJpYnV0ZSBkZXNjcmliZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudCwgZS5nLiBgZGF0YS10YXNrLXByaW9yaXR5PVwibWVkaXVtXCJgLCBgZGF0YS10YXNrLWR1ZT1cInBhc3QtMWRcImAgZXRjLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnREYXRhQXR0cmlidXRlKGNvbXBvbmVudDogVGFza0xheW91dENvbXBvbmVudCwgdGFzazogVGFzaykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGU6IEF0dHJpYnV0ZXNEaWN0aW9uYXJ5ID0ge307XG5cbiAgICAvLyBJZiBhIFRhc2tMYXlvdXRDb21wb25lbnQgbmVlZHMgYSBkYXRhIGF0dHJpYnV0ZSBpbiB0aGUgdGFzaydzIDxzcGFuPiwgYWRkIHRoZSBkYXRhIGF0dHJpYnV0ZSBuYW1lXG4gICAgLy8gdG8gdGhpcyBkaWN0aW9uYXJ5OiBrZXkgaXMgdGhlIGNvbXBvbmVudCwgdmFsdWUgaXMgdGhlIGRhdGEgYXR0cmlidXRlIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IGxlYXZlIGFuIGVtcHR5IHN0cmluZyAoJycpIGFzIHRoZSB2YWx1ZS5cbiAgICAvLyBBbHNvIGFkZCB0aGUgbmV3IGNvbXBvbmVudCB0byB0aGUgc3dpdGNoLWNhc2UgYmVsb3cgaW4gdGhpcyBmdW5jdGlvbi4gVGhpcyBpcyB3aGVyZVxuICAgIC8vIHRoZSBkYXRhIGF0dHJpYnV0ZSB2YWx1ZSBzaGFsbCBiZSBjYWxjdWxhdGVkIGFuZCBzZXQgaW4gdGhlIHJldHVybmVkIGRpY3Rpb25hcnkuXG4gICAgY29uc3QgRGF0YUF0dHJpYnV0ZU5hbWVzOiB7IFtjIGluIFRhc2tMYXlvdXRDb21wb25lbnRdOiBzdHJpbmcgfSA9IHtcbiAgICAgICAgY3JlYXRlZERhdGU6ICd0YXNrQ3JlYXRlZCcsXG4gICAgICAgIGR1ZURhdGU6ICd0YXNrRHVlJyxcbiAgICAgICAgc3RhcnREYXRlOiAndGFza1N0YXJ0JyxcbiAgICAgICAgc2NoZWR1bGVkRGF0ZTogJ3Rhc2tTY2hlZHVsZWQnLFxuICAgICAgICBkb25lRGF0ZTogJ3Rhc2tEb25lJyxcbiAgICAgICAgcHJpb3JpdHk6ICd0YXNrUHJpb3JpdHknLFxuICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIHJlY3VycmVuY2VSdWxlOiAnJyxcbiAgICAgICAgYmxvY2tMaW5rOiAnJyxcbiAgICB9O1xuXG4gICAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgICBjYXNlICdyZWN1cnJlbmNlUnVsZSc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrTGluayc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHJpb3JpdHknOiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gRGF0YUF0dHJpYnV0ZU5hbWVzW2NvbXBvbmVudF07XG4gICAgICAgICAgICBkYXRhQXR0cmlidXRlW2F0dHJpYnV0ZU5hbWVdID0gUHJpb3JpdHlUb29scy5wcmlvcml0eU5hbWVVc2luZ05vcm1hbCh0YXNrLnByaW9yaXR5KS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY3JlYXRlZERhdGUnOlxuICAgICAgICBjYXNlICdkdWVEYXRlJzpcbiAgICAgICAgY2FzZSAnc3RhcnREYXRlJzpcbiAgICAgICAgY2FzZSAnc2NoZWR1bGVkRGF0ZSc6XG4gICAgICAgIGNhc2UgJ2RvbmVEYXRlJzoge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRhc2tbY29tcG9uZW50XTtcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBkYXRlVG9BdHRyaWJ1dGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBEYXRhQXR0cmlidXRlTmFtZXNbY29tcG9uZW50XTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZVthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhQXR0cmlidXRlO1xufVxuXG4vKlxuICogQWRkcyBpbnRlcm5hbCBjbGFzc2VzIGZvciB2YXJpb3VzIGNvbXBvbmVudHMgKHJpZ2h0IG5vdyBqdXN0IHRhZ3MgYWN0dWFsbHkpLCBtZWFuaW5nIHRoYXQgd2UgbW9kaWZ5IHRoZSBleGlzdGluZ1xuICogcmVuZGVyZWQgZWxlbWVudCB0byBhZGQgY2xhc3NlcyBpbnNpZGUgaXQuXG4gKiBJbiB0aGUgY2FzZSBvZiB0YWdzLCBPYnNpZGlhbiByZW5kZXJzIGEgTWFya2Rvd24gZGVzY3JpcHRpb24gd2l0aCA8YSBjbGFzcz1cInRhZ1wiPiBlbGVtZW50cyBmb3IgdGFncy4gV2Ugd2FudCB0b1xuICogZW5hYmxlIHVzZXJzIHRvIHN0eWxlIHRoZXNlLCBzbyB3ZSBtb2RpZnkgdGhlIHJlbmRlcmVkIE1hcmtkb3duIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWMgdGFnIGNsYXNzZXMgZm9yIHRoZXNlIDxhPlxuICogZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGFkZEludGVybmFsQ2xhc3Nlcyhjb21wb25lbnQ6IFRhc2tMYXlvdXRDb21wb25lbnQsIHJlbmRlcmVkQ29tcG9uZW50OiBIVE1MU3BhbkVsZW1lbnQpIHtcbiAgICBpZiAoY29tcG9uZW50ID09PSAnZGVzY3JpcHRpb24nKSB7XG4gICAgICAgIGNvbnN0IHRhZ3MgPSByZW5kZXJlZENvbXBvbmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0YWcnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFnc1tpXS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGFnVG9BdHRyaWJ1dGVWYWx1ZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFnc1tpXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSBlbGVtZW50LmRhdGFzZXQudGFnTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSByZWxhdGl2ZSBkYXRlIHRvIGEgQ1NTIGNsYXNzOiAndG9kYXknLCAnZnV0dXJlLTFkJyAoZm9yIHRvbW9ycm93KSwgJ3Bhc3QtMWQnIChmb3IgeWVzdGVyZGF5KVxuICogZXRjLlxuICogQSBjdXRvZmYgKGluIGRheXMpIGlzIGRlZmluZWQgaW4gTUFYX0RBWV9WQUxVRV9SQU5HRSwgZnJvbSBiZXlvbmQgdGhhdCBhIGdlbmVyaWMgJ2ZhcicgcG9zdGZpeCB3aWxsIGJlIGFkZGVkLlxuICogKHRoZSBjdXRvZmYgZXhpc3RzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBmbG9vZCB0aGUgRE9NIHdpdGggcG90ZW50aWFsbHkgaHVuZHJlZHMgb2YgdW5pcXVlIGNsYXNzZXMuKVxuICovXG5mdW5jdGlvbiBkYXRlVG9BdHRyaWJ1dGUoZGF0ZTogTW9tZW50KSB7XG4gICAgY29uc3QgdG9kYXkgPSB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5Jyk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IGRpZmZEYXlzID0gdG9kYXkuZGlmZihkYXRlLCAnZGF5cycpO1xuICAgIGlmIChpc05hTihkaWZmRGF5cykpIHJldHVybiBudWxsO1xuICAgIGlmIChkaWZmRGF5cyA9PT0gMCkgcmV0dXJuICd0b2RheSc7XG4gICAgZWxzZSBpZiAoZGlmZkRheXMgPiAwKSByZXN1bHQgKz0gJ3Bhc3QtJztcbiAgICBlbHNlIGlmIChkaWZmRGF5cyA8IDApIHJlc3VsdCArPSAnZnV0dXJlLSc7XG4gICAgaWYgKE1hdGguYWJzKGRpZmZEYXlzKSA8PSBNQVhfREFZX1ZBTFVFX1JBTkdFKSB7XG4gICAgICAgIHJlc3VsdCArPSBNYXRoLmFicyhkaWZmRGF5cykudG9TdHJpbmcoKSArICdkJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gREFZX1ZBTFVFX09WRVJfUkFOR0VfUE9TVEZJWDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFNhbml0aXplIHRhZyBuYW1lcyBzbyB0aGV5IHdpbGwgYmUgdmFsaWQgYXR0cmlidXRlIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIEhUTUwgc3BlYzpcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNhdHRyaWJ1dGUtdmFsdWUtKGRvdWJsZS1xdW90ZWQpLXN0YXRlXG4gKi9cbmZ1bmN0aW9uIHRhZ1RvQXR0cmlidXRlVmFsdWUodGFnOiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIGNvbnN0IGlsbGVnYWxDaGFycyA9IC9bXCImXFx4MDBcXHJcXG5dL2c7XG4gICAgbGV0IHNhbml0aXplZFRhZyA9IHRhZy5yZXBsYWNlKGlsbGVnYWxDaGFycywgJy0nKTtcbiAgICAvLyBBbmQgaWYgYWZ0ZXIgc2FuaXRhemF0aW9uIHRoZSBuYW1lIHN0YXJ0cyB3aXRoIGRhc2hlcyBvciB1bmRlcnNjb3JlcywgcmVtb3ZlIHRoZW0uXG4gICAgc2FuaXRpemVkVGFnID0gc2FuaXRpemVkVGFnLnJlcGxhY2UoL15bLV9dKy8sICcnKTtcbiAgICBpZiAoc2FuaXRpemVkVGFnLmxlbmd0aCA+IDApIHJldHVybiBzYW5pdGl6ZWRUYWc7XG4gICAgZWxzZSByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkVG9vbHRpcCh7XG4gICAgdGFzayxcbiAgICBlbGVtZW50LFxuICAgIGlzRmlsZW5hbWVVbmlxdWUsXG59OiB7XG4gICAgdGFzazogVGFzaztcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBpc0ZpbGVuYW1lVW5pcXVlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xufSk6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVjdXJyZW5jZVN5bWJvbCwgc3RhcnREYXRlU3ltYm9sLCBjcmVhdGVkRGF0ZVN5bWJvbCwgc2NoZWR1bGVkRGF0ZVN5bWJvbCwgZHVlRGF0ZVN5bWJvbCwgZG9uZURhdGVTeW1ib2wgfSA9XG4gICAgICAgIFRBU0tfRk9STUFUUy50YXNrc1BsdWdpbkVtb2ppLnRhc2tTZXJpYWxpemVyLnN5bWJvbHM7XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBlbGVtZW50LmNyZWF0ZURpdigpO1xuICAgICAgICB0b29sdGlwLmFkZENsYXNzZXMoWyd0b29sdGlwJywgJ3BvcC11cCddKTtcblxuICAgICAgICBpZiAodGFzay5yZWN1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCByZWN1cnJlbmNlRGl2ID0gdG9vbHRpcC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgIHJlY3VycmVuY2VEaXYuc2V0VGV4dChgJHtyZWN1cnJlbmNlU3ltYm9sfSAke3Rhc2sucmVjdXJyZW5jZS50b1RleHQoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZERhdGVUb1Rvb2x0aXAodG9vbHRpcCwgdGFzay5jcmVhdGVkRGF0ZSwgY3JlYXRlZERhdGVTeW1ib2wpO1xuICAgICAgICBhZGREYXRlVG9Ub29sdGlwKHRvb2x0aXAsIHRhc2suc3RhcnREYXRlLCBzdGFydERhdGVTeW1ib2wpO1xuICAgICAgICBhZGREYXRlVG9Ub29sdGlwKHRvb2x0aXAsIHRhc2suc2NoZWR1bGVkRGF0ZSwgc2NoZWR1bGVkRGF0ZVN5bWJvbCk7XG4gICAgICAgIGFkZERhdGVUb1Rvb2x0aXAodG9vbHRpcCwgdGFzay5kdWVEYXRlLCBkdWVEYXRlU3ltYm9sKTtcbiAgICAgICAgYWRkRGF0ZVRvVG9vbHRpcCh0b29sdGlwLCB0YXNrLmRvbmVEYXRlLCBkb25lRGF0ZVN5bWJvbCk7XG5cbiAgICAgICAgY29uc3QgbGlua1RleHQgPSB0YXNrLmdldExpbmtUZXh0KHsgaXNGaWxlbmFtZVVuaXF1ZSB9KTtcbiAgICAgICAgaWYgKGxpbmtUZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrbGlua0RpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICBiYWNrbGlua0Rpdi5zZXRUZXh0KGBcdUQ4M0RcdUREMTcgJHtsaW5rVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREYXRlVG9Ub29sdGlwKHRvb2x0aXA6IEhUTUxEaXZFbGVtZW50LCBkYXRlOiBtb21lbnQuTW9tZW50IHwgbnVsbCwgc2lnbmlmaWVyOiBzdHJpbmcpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgICBjb25zdCBjcmVhdGVkRGF0ZURpdiA9IHRvb2x0aXAuY3JlYXRlRGl2KCk7XG4gICAgICAgIGNyZWF0ZWREYXRlRGl2LnNldFRleHQoXG4gICAgICAgICAgICB0b1Rvb2x0aXBEYXRlKHtcbiAgICAgICAgICAgICAgICBzaWduaWZpZXI6IHNpZ25pZmllcixcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b1Rvb2x0aXBEYXRlKHsgc2lnbmlmaWVyLCBkYXRlIH06IHsgc2lnbmlmaWVyOiBzdHJpbmc7IGRhdGU6IE1vbWVudCB9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7c2lnbmlmaWVyfSAke2RhdGUuZm9ybWF0KHRhc2tNb2R1bGUuVGFza1JlZ3VsYXJFeHByZXNzaW9ucy5kYXRlRm9ybWF0KX0gKCR7ZGF0ZS5mcm9tKFxuICAgICAgICB3aW5kb3cubW9tZW50KCkuc3RhcnRPZignZGF5JyksXG4gICAgKX0pYDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCByZW5kZXJlZCBMaXN0IEl0ZW0gZWxlbWVudCAoTEkpIGZvciBhIHRhc2suXG4gKiBAbm90ZSBPdXRwdXQgaXMgYmFzZWQgb24gdGhlIHtAbGluayBEZWZhdWx0VGFza1NlcmlhbGl6ZXJ9J3MgZm9ybWF0LCB3aXRoIGRlZmF1bHQgKGVtb2ppKSBzeW1ib2xzXG4gKiBAcGFyYW0gdGFza1xuICogQHBhcmFtIHJlbmRlckRldGFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhc2tUb0xpKHRhc2s6IFRhc2ssIHJlbmRlckRldGFpbHM6IFRhc2tMaW5lUmVuZGVyRGV0YWlscyk6IFByb21pc2U8SFRNTExJRWxlbWVudD4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIG9ic2lkaWFuTWFya2Rvd25SZW5kZXJlcihcbiAgICAgICAgdGV4dDogc3RyaW5nLFxuICAgICAgICBlbGVtZW50OiBIVE1MU3BhbkVsZW1lbnQsXG4gICAgICAgIHBhdGg6IHN0cmluZyxcbiAgICAgICAgb2JzaWRpYW5Db21wb25lbnQ6IENvbXBvbmVudCB8IG51bGwsXG4gICAgKSB7XG4gICAgICAgIGlmICghb2JzaWRpYW5Db21wb25lbnQpIHRocm93IG5ldyBFcnJvcignTXVzdCBjYWxsIHRoZSBPYnNpZGlhbiByZW5kZXJlciB3aXRoIGFuIE9ic2lkaWFuIENvbXBvbmVudCBvYmplY3QnKTtcbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXJNYXJrZG93bih0ZXh0LCBlbGVtZW50LCBwYXRoLCBvYnNpZGlhbkNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlclRhc2tMaW5lKHRhc2ssIHJlbmRlckRldGFpbHMsIG9ic2lkaWFuTWFya2Rvd25SZW5kZXJlcik7XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yVmlldywgVmlld1BsdWdpbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHR5cGUgeyBQbHVnaW5WYWx1ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcbmltcG9ydCB7IFRhc2tMb2NhdGlvbiB9IGZyb20gJy4vVGFza0xvY2F0aW9uJztcblxuZXhwb3J0IGNvbnN0IG5ld0xpdmVQcmV2aWV3RXh0ZW5zaW9uID0gKCkgPT4ge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhMaXZlUHJldmlld0V4dGVuc2lvbik7XG59O1xuXG5jbGFzcyBMaXZlUHJldmlld0V4dGVuc2lvbiBpbXBsZW1lbnRzIFBsdWdpblZhbHVlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXc6IEVkaXRvclZpZXc7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVDbGlja0V2ZW50ID0gdGhpcy5oYW5kbGVDbGlja0V2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNsaWNrRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50O1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94IGNsaWNrcy5cbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB8fCB0YXJnZXQudHlwZSAhPT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmlnaHQgbm93IE9ic2lkaWFuIEFQSSBkb2VzIG5vdCBnaXZlIHVzIGEgd2F5IHRvIGhhbmRsZSBjaGVja2JveCBjbGlja3MgaW5zaWRlIHJlbmRlcmVkLXdpZGdldHMtaW4tTFAgc3VjaCBhc1xuICAgICAgICAgKiBjYWxsb3V0cywgdGFibGVzLCBhbmQgdHJhbnNjbHVzaW9ucyBiZWNhdXNlIGB0aGlzLnZpZXcucG9zQXRET01gIHdpbGwgcmV0dXJuIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHdpZGdldFxuICAgICAgICAgKiBhcyB0aGUgcG9zaXRpb24gZm9yIGFueSBjbGljayBpbnNpZGUgdGhlIHdpZGdldC5cbiAgICAgICAgICogRm9yIGNhbGxvdXRzLCB0aGlzIG1lYW5zIHRoYXQgdGhlIHRhc2sgd2lsbCBuZXZlciBiZSBmb3VuZCwgc2luY2UgdGhlIGBsaW5lQXRgIHdpbGwgYmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgY2FsbG91dC5cbiAgICAgICAgICogVGhlcmVmb3JlLCBwcm9kdWNlIGFuIGVycm9yIG1lc3NhZ2UgcG9wLXVwIHVzaW5nIE9ic2lkaWFuJ3MgXCJOb3RpY2VcIiBmZWF0dXJlLCBsb2cgYSBjb25zb2xlIHdhcm5pbmcsIHRoZW4gcmV0dXJuLlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBUYXNrcyBmcm9tIFwidGFza1wiIHF1ZXJ5IGNvZGVibG9ja3MgaGFuZGxlIHRoZW1zZWx2ZXMgdGhhbmtzIHRvIGB0b0xpYCwgc28gYmUgc3BlY2lmaWMgYWJvdXQgZXJyb3IgbWVzc2FnaW5nLCBidXQgc3RpbGwgcmV0dXJuLlxuICAgICAgICBjb25zdCBhbmNlc3RvciA9IHRhcmdldC5jbG9zZXN0KCd1bC5wbHVnaW4tdGFza3MtcXVlcnktcmVzdWx0LCBkaXYuY2FsbG91dC1jb250ZW50Jyk7XG4gICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLm1hdGNoZXMoJ2Rpdi5jYWxsb3V0LWNvbnRlbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICAgICAgICAgICAnb2JzaWRpYW4tdGFza3MtcGx1Z2luIHdhcm5pbmc6IFRhc2tzIGNhbm5vdCBhZGQgb3IgcmVtb3ZlIGNvbXBsZXRpb24gZGF0ZXMgb3IgbWFrZSB0aGUgbmV4dCBjb3B5IG9mIGEgcmVjdXJyaW5nIHRhc2sgZm9yIHRhc2tzIHdyaXR0ZW4gaW5zaWRlIGEgY2FsbG91dCB3aGVuIHlvdSBjbGljayB0aGVpciBjaGVja2JveGVzIGluIExpdmUgUHJldmlldy4gXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdJZiB5b3Ugd2FudGVkIFRhc2tzIHRvIGRvIHRoZXNlIHRoaW5ncywgcGxlYXNlIHVuZG8geW91ciBjaGFuZ2UsIHRoZW4gZWl0aGVyIGNsaWNrIHRoZSBsaW5lIG9mIHRoZSB0YXNrIGFuZCB1c2UgdGhlIFwiVG9nZ2xlIFRhc2sgRG9uZVwiIGNvbW1hbmQsIG9yIHN3aXRjaCB0byBSZWFkaW5nIFZpZXcgdG8gY2xpY2sgdGhlIGNoZWNrYm94Lic7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShtc2csIDQ1MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMudmlldztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnZpZXcucG9zQXRET00odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0YXNrID0gVGFzay5mcm9tTGluZSh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLnRleHQsXG4gICAgICAgICAgICAvLyBOb25lIG9mIHRoaXMgZGF0YSBpcyByZWxldmFudCBoZXJlLlxuICAgICAgICAgICAgLy8gVGhlIHRhc2sgaXMgY3JlYXRlZCwgdG9nZ2xlZCwgYW5kIHdyaXR0ZW4gYmFjayB0byB0aGUgQ002IGRvY3VtZW50LFxuICAgICAgICAgICAgLy8gcmVwbGFjaW5nIHRoZSBvbGQgdGFzayBpbi1wbGFjZS5cbiAgICAgICAgICAgIHRhc2tMb2NhdGlvbjogVGFza0xvY2F0aW9uLmZyb21Vbmtub3duUG9zaXRpb24oJycpLFxuICAgICAgICAgICAgZmFsbGJhY2tEYXRlOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUZW1wb3JhcnkgZWRpdCAtIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb2JzaWRpYW4tdGFza3MtZ3JvdXAvb2JzaWRpYW4tdGFza3MvaXNzdWVzLzIxNjBcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgTGl2ZSBQcmV2aWV3IEV4dGVuc2lvbjogdG9nZ2xlIGNhbGxlZC4gUG9zaXRpb246ICR7cG9zaXRpb259IExpbmU6ICR7bGluZS50ZXh0fWApO1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGNoZWNrYm94ZXMgb2YgdGFza3MuXG4gICAgICAgIGlmICh0YXNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXZlbnQgZGVmYXVsdCBzbyB0aGF0IHRoZSBjaGVja2JveCBpcyBvbmx5IGhhbmRsZWQgYnkgdXMgYW5kIG5vdCBvYnNpZGlhbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBDbGlja2VkIG9uIGEgdGFzaydzIGNoZWNrYm94LiBUb2dnbGUgdGhlIHRhc2sgYW5kIHNldCBpdC5cbiAgICAgICAgY29uc3QgdG9nZ2xlZCA9IHRhc2sudG9nZ2xlV2l0aFJlY3VycmVuY2VJblVzZXJzT3JkZXIoKTtcbiAgICAgICAgY29uc3QgdG9nZ2xlZFN0cmluZyA9IHRvZ2dsZWQubWFwKCh0KSA9PiB0LnRvRmlsZUxpbmVTdHJpbmcoKSkuam9pbihzdGF0ZS5saW5lQnJlYWspO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBDb2RlTWlycm9yIHRyYW5zYWN0aW9uIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGxpbmUudG8sXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiB0b2dnbGVkU3RyaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG5cbiAgICAgICAgLy8gRGlydHkgd29ya2Fyb3VuZC5cbiAgICAgICAgLy8gV2hpbGUgdGhlIGNvZGUgaW4gdGhpcyBtZXRob2QgcHJvcGVybHkgdXBkYXRlcyB0aGUgYGNoZWNrZWRgIHN0YXRlXG4gICAgICAgIC8vIG9mIHRoZSB0YXJnZXQgY2hlY2tib3gsIHNvbWUgT2JzaWRpYW4gaW50ZXJuYWxzIHJldmVydCB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgY2hlY2tib3ggd291bGQgcmVtYWluIGluIGl0cyBvcmlnaW5hbCBgY2hlY2tlZGBcbiAgICAgICAgLy8gc3RhdGUgKGB0cnVlYCBvciBgZmFsc2VgKSwgZXZlbiB0aG91Z2ggdGhlIHVuZGVybHlpbmcgZG9jdW1lbnRcbiAgICAgICAgLy8gdXBkYXRlcyBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEFzIGEgXCJmaXhcIiwgd2Ugc2V0IHRoZSBjaGVja2JveCdzIGBjaGVja2VkYCBzdGF0ZSAqYWdhaW4qIGFmdGVyIGFcbiAgICAgICAgLy8gdGltZW91dCB0byByZXZlcnQgT2JzaWRpYW4ncyB3cm9uZ2Z1bCByZXZlcnNhbC5cbiAgICAgICAgY29uc3QgZGVzaXJlZENoZWNrZWRTdGF0dXMgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQuY2hlY2tlZCA9IGRlc2lyZWRDaGVja2VkU3RhdHVzO1xuICAgICAgICB9LCAxKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBLZXltYXAsIE1hcmtkb3duUmVuZGVyQ2hpbGQsIE1hcmtkb3duUmVuZGVyZXIsIFBsdWdpbiwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEV2ZW50UmVmLCBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgR2xvYmFsRmlsdGVyIH0gZnJvbSAnLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB7IEdsb2JhbFF1ZXJ5IH0gZnJvbSAnLi9Db25maWcvR2xvYmFsUXVlcnknO1xuXG5pbXBvcnQgdHlwZSB7IElRdWVyeSB9IGZyb20gJy4vSVF1ZXJ5JztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9DYWNoZSc7XG5pbXBvcnQgeyBnZXRUYXNrTGluZUFuZEZpbGUsIHJlcGxhY2VUYXNrV2l0aFRhc2tzIH0gZnJvbSAnLi9GaWxlJztcbmltcG9ydCB0eXBlIHsgR3JvdXBEaXNwbGF5SGVhZGluZyB9IGZyb20gJy4vUXVlcnkvR3JvdXBEaXNwbGF5SGVhZGluZyc7XG5pbXBvcnQgeyB0YXNrVG9MaSB9IGZyb20gJy4vVGFza0xpbmVSZW5kZXJlcic7XG5pbXBvcnQgeyBUYXNrTW9kYWwgfSBmcm9tICcuL1Rhc2tNb2RhbCc7XG5pbXBvcnQgdHlwZSB7IFRhc2tzRXZlbnRzIH0gZnJvbSAnLi9UYXNrc0V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuL1Rhc2snO1xuaW1wb3J0IHsgRGF0ZUZhbGxiYWNrIH0gZnJvbSAnLi9EYXRlRmFsbGJhY2snO1xuaW1wb3J0IHsgVGFza0xheW91dCB9IGZyb20gJy4vVGFza0xheW91dCc7XG5pbXBvcnQgeyBleHBsYWluUmVzdWx0cywgZ2V0UXVlcnlGb3JRdWVyeVJlbmRlcmVyIH0gZnJvbSAnLi9saWIvUXVlcnlSZW5kZXJlckhlbHBlcic7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5UmVzdWx0IH0gZnJvbSAnLi9RdWVyeS9RdWVyeVJlc3VsdCc7XG5pbXBvcnQgdHlwZSB7IFRhc2tHcm91cHMgfSBmcm9tICcuL1F1ZXJ5L1Rhc2tHcm91cHMnO1xuXG5leHBvcnQgY2xhc3MgUXVlcnlSZW5kZXJlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBhcHA6IEFwcDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogVGFza3NFdmVudHM7XG5cbiAgICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiwgZXZlbnRzIH06IHsgcGx1Z2luOiBQbHVnaW47IGV2ZW50czogVGFza3NFdmVudHMgfSkge1xuICAgICAgICB0aGlzLmFwcCA9IHBsdWdpbi5hcHA7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuXG4gICAgICAgIHBsdWdpbi5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKCd0YXNrcycsIHRoaXMuX2FkZFF1ZXJ5UmVuZGVyQ2hpbGQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFF1ZXJ5UmVuZGVyQ2hpbGQgPSB0aGlzLl9hZGRRdWVyeVJlbmRlckNoaWxkLmJpbmQodGhpcyk7XG5cbiAgICBwcml2YXRlIGFzeW5jIF9hZGRRdWVyeVJlbmRlckNoaWxkKHNvdXJjZTogc3RyaW5nLCBlbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGV4dDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmFkZENoaWxkKFxuICAgICAgICAgICAgbmV3IFF1ZXJ5UmVuZGVyQ2hpbGQoe1xuICAgICAgICAgICAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBjb250ZXh0LnNvdXJjZVBhdGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNsYXNzIFF1ZXJ5UmVuZGVyQ2hpbGQgZXh0ZW5kcyBNYXJrZG93blJlbmRlckNoaWxkIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRzOiBUYXNrc0V2ZW50cztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZSB0ZXh0IGluIHRoZSBpbnN0cnVjdGlvbiBibG9jaywgc3VjaCBhczpcbiAgICAgKiBgYGBcbiAgICAgKiAgIG5vdCBkb25lXG4gICAgICogICBzaG9ydCBtb2RlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgbm90IGNvbnRhaW4gdGhlIEdsb2JhbCBRdWVyeSBmcm9tIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAgICogVXNlIHtAbGluayBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXJ9IHRvIGdldCB0aGlzIHZhbHVlIHByZWZpeGVkIHdpdGggdGhlIEdsb2JhbCBRdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nO1xuXG4gICAgLy8vIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIGluc3RydWN0aW9uIGJsb2NrLlxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmlsZVBhdGg6IHN0cmluZztcblxuICAgIHByaXZhdGUgcXVlcnk6IElRdWVyeTtcbiAgICBwcml2YXRlIHF1ZXJ5VHlwZTogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSByZW5kZXJFdmVudFJlZjogRXZlbnRSZWYgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBxdWVyeVJlbG9hZFRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBhcHAsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGZpbGVQYXRoLFxuICAgIH06IHtcbiAgICAgICAgYXBwOiBBcHA7XG4gICAgICAgIGV2ZW50czogVGFza3NFdmVudHM7XG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgICAgIHNvdXJjZTogc3RyaW5nO1xuICAgICAgICBmaWxlUGF0aDogc3RyaW5nO1xuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG5cbiAgICAgICAgLy8gVGhlIGVuZ2luZSBpcyBjaG9zZW4gb24gdGhlIGJhc2lzIG9mIHRoZSBjb2RlIGJsb2NrIGxhbmd1YWdlLiBDdXJyZW50bHlcbiAgICAgICAgLy8gdGhlcmUgaXMgb25seSB0aGUgbWFpbiBlbmdpbmUgZm9yIHRoZSBwbHVnaW4sIHRoaXMgYWxsb3dzIG90aGVycyB0byBiZVxuICAgICAgICAvLyBhZGRlZCBsYXRlci5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRhaW5lckVsLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbGFuZ3VhZ2UtdGFza3MnOlxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXIodGhpcy5zb3VyY2UsIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCksIHRoaXMuZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ3Rhc2tzJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gZ2V0UXVlcnlGb3JRdWVyeVJlbmRlcmVyKHRoaXMuc291cmNlLCBHbG9iYWxRdWVyeS5nZXRJbnN0YW5jZSgpLCB0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICd0YXNrcyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbmxvYWQoKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGN1cnJlbnQgY2FjaGUgc3RhdGU6XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJSZXF1ZXN0Q2FjaGVVcGRhdGUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIExpc3RlbiB0byBmdXR1cmUgY2FjaGUgY2hhbmdlczpcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudFJlZiA9IHRoaXMuZXZlbnRzLm9uQ2FjaGVVcGRhdGUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5yZWxvYWRRdWVyeUF0TWlkbmlnaHQoKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRXZlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMub2ZmKHRoaXMucmVuZGVyRXZlbnRSZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucXVlcnlSZWxvYWRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnF1ZXJ5UmVsb2FkVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBxdWVyeSBhZnRlciBtaWRuaWdodCB0byB1cGRhdGUgcmVzdWx0cyBmcm9tIHJlbGF0aXZlIGRhdGUgcXVlcmllcy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0aGUgcXVlcnkgYGR1ZSB0b2RheWAgY2hhbmdlcyBldmVyeSBkYXkuIFRoaXMgbWFrZXMgc3VyZSB0aGF0IGFsbCBxdWVyeSByZXN1bHRzXG4gICAgICogYXJlIHJlLXJlbmRlcmVkIGFmdGVyIG1pZG5pZ2h0IGV2ZXJ5IGRheSB0byBlbnN1cmUgdXAtdG8tZGF0ZSByZXN1bHRzIHdpdGhvdXQgaGF2aW5nIHRvXG4gICAgICogcmVsb2FkIG9ic2lkaWFuLiBDcmVhdGluZyBhIG5ldyBxdWVyeSBvYmplY3QgZnJvbSB0aGUgc291cmNlIHJlLWFwcGxpZXMgdGhlIHJlbGF0aXZlIGRhdGVzXG4gICAgICogdG8gXCJub3dcIi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlbG9hZFF1ZXJ5QXRNaWRuaWdodCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWlkbmlnaHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBtaWRuaWdodC5zZXRIb3VycygyNCwgMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzVG9NaWRuaWdodCA9IG1pZG5pZ2h0LmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy5xdWVyeVJlbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXIodGhpcy5zb3VyY2UsIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlKCksIHRoaXMuZmlsZVBhdGgpO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgY3VycmVudCBjYWNoZSBzdGF0ZTpcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJSZXF1ZXN0Q2FjaGVVcGRhdGUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFF1ZXJ5QXRNaWRuaWdodCgpO1xuICAgICAgICB9LCBtaWxsaXNlY29uZHNUb01pZG5pZ2h0ICsgMTAwMCk7IC8vIEFkZCBidWZmZXIgdG8gYmUgc3VyZSB0byBydW4gYWZ0ZXIgbWlkbmlnaHQuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZW5kZXIoeyB0YXNrcywgc3RhdGUgfTogeyB0YXNrczogVGFza1tdOyBzdGF0ZTogU3RhdGUgfSkge1xuICAgICAgICAvLyBEb24ndCBsb2cgYW55dGhpbmcgaGVyZSwgZm9yIGFueSBzdGF0ZSwgYXMgaXQgZ2VuZXJhdGVzIGh1Z2UgYW1vdW50cyBvZlxuICAgICAgICAvLyBjb25zb2xlIG1lc3NhZ2VzIGluIGxhcmdlIHZhdWx0cywgaWYgT2JzaWRpYW4gd2FzIG9wZW5lZCB3aXRoIGFueVxuICAgICAgICAvLyBub3RlcyB3aXRoIHRhc2tzIGNvZGUgYmxvY2tzIGluIFJlYWRpbmcgb3IgTGl2ZSBQcmV2aWV3IG1vZGUuXG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicpO1xuICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLldhcm0gJiYgdGhpcy5xdWVyeS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclF1ZXJ5U2VhcmNoUmVzdWx0cyh0YXNrcywgc3RhdGUsIGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVlcnkuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvck1lc3NhZ2UoY29udGVudCwgdGhpcy5xdWVyeS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckxvYWRpbmdNZXNzYWdlKGNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5maXJzdENoaWxkPy5yZXBsYWNlV2l0aChjb250ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlclF1ZXJ5U2VhcmNoUmVzdWx0cyh0YXNrczogVGFza1tdLCBzdGF0ZTogU3RhdGUuV2FybSwgY29udGVudDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbi10YXNrcy1ncm91cC9vYnNpZGlhbi10YXNrcy9pc3N1ZXMvMjE2MFxuICAgICAgICBjb25zdCBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgYFJlbmRlciAke3RoaXMucXVlcnlUeXBlfSBjYWxsZWQgZm9yIGEgYmxvY2sgaW4gYWN0aXZlIGZpbGUgXCIke3RoaXMuZmlsZVBhdGh9XCIsIHRvIHNlbGVjdCBmcm9tICR7dGFza3MubGVuZ3RofSB0YXNrczogcGx1Z2luIHN0YXRlOiAke3N0YXRlfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucXVlcnkubGF5b3V0T3B0aW9ucy5leHBsYWluUXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRXhwbGFuYXRpb24oY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHRoaXMucXVlcnkuYXBwbHlRdWVyeVRvVGFza3ModGFza3MpO1xuICAgICAgICBpZiAocXVlcnlSZXN1bHQuc2VhcmNoRXJyb3JNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBpbiB0aGUgc2VhcmNoLCBmb3IgZXhhbXBsZSBkdWUgdG8gYSBwcm9ibGVtIGN1c3RvbSBmdW5jdGlvbi5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXJyb3JNZXNzYWdlKGNvbnRlbnQsIHF1ZXJ5UmVzdWx0LnNlYXJjaEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLmFkZEFsbFRhc2tHcm91cHMocXVlcnlSZXN1bHQudGFza0dyb3VwcywgY29udGVudCk7XG5cbiAgICAgICAgY29uc3QgdG90YWxUYXNrc0NvdW50ID0gcXVlcnlSZXN1bHQudG90YWxUYXNrc0NvdW50O1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYCR7dG90YWxUYXNrc0NvdW50fSBvZiAke3Rhc2tzLmxlbmd0aH0gdGFza3MgZGlzcGxheWVkIGluIGEgYmxvY2sgaW4gXCIke3RoaXMuZmlsZVBhdGh9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRhc2tDb3VudChjb250ZW50LCBxdWVyeVJlc3VsdCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJFcnJvck1lc3NhZ2UoY29udGVudDogSFRNTERpdkVsZW1lbnQsIGVycm9yTWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnRlbnQuY3JlYXRlRGl2KCkuaW5uZXJIVE1MID0gJzxwcmU+JyArIGBUYXNrcyBxdWVyeTogJHtlcnJvck1lc3NhZ2UucmVwbGFjZSgvXFxuL2csICc8YnI+Jyl9YCArICc8L3ByZT4nO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyTG9hZGluZ01lc3NhZ2UoY29udGVudDogSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgY29udGVudC5zZXRUZXh0KCdMb2FkaW5nIFRhc2tzIC4uLicpO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgJ2V4cGxhaW4nIGluc3RydWN0aW9uIHRvIGVuYWJsZSB0aGlzXG4gICAgcHJpdmF0ZSBjcmVhdGVFeHBsYW5hdGlvbihjb250ZW50OiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgICBjb25zdCBleHBsYW5hdGlvbkFzU3RyaW5nID0gZXhwbGFpblJlc3VsdHMoXG4gICAgICAgICAgICB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLFxuICAgICAgICAgICAgR2xvYmFsUXVlcnkuZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb25zQmxvY2sgPSBjb250ZW50LmNyZWF0ZUVsKCdwcmUnKTtcbiAgICAgICAgZXhwbGFuYXRpb25zQmxvY2suYWRkQ2xhc3NlcyhbJ3BsdWdpbi10YXNrcy1xdWVyeS1leHBsYW5hdGlvbiddKTtcbiAgICAgICAgZXhwbGFuYXRpb25zQmxvY2suc2V0VGV4dChleHBsYW5hdGlvbkFzU3RyaW5nKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChleHBsYW5hdGlvbnNCbG9jayk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUYXNrTGlzdCh0YXNrczogVGFza1tdLCBjb250ZW50OiBIVE1MRGl2RWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBuZXcgVGFza0xheW91dCh0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0YXNrTGlzdCA9IGNvbnRlbnQuY3JlYXRlRWwoJ3VsJyk7XG4gICAgICAgIHRhc2tMaXN0LmFkZENsYXNzZXMoWydjb250YWlucy10YXNrLWxpc3QnLCAncGx1Z2luLXRhc2tzLXF1ZXJ5LXJlc3VsdCddKTtcbiAgICAgICAgdGFza0xpc3QuYWRkQ2xhc3NlcyhsYXlvdXQudGFza0xpc3RIaWRkZW5DbGFzc2VzKTtcbiAgICAgICAgY29uc3QgZ3JvdXBpbmdBdHRyaWJ1dGUgPSB0aGlzLmdldEdyb3VwaW5nQXR0cmlidXRlKCk7XG4gICAgICAgIGlmIChncm91cGluZ0F0dHJpYnV0ZSAmJiBncm91cGluZ0F0dHJpYnV0ZS5sZW5ndGggPiAwKSB0YXNrTGlzdC5kYXRhc2V0LnRhc2tHcm91cEJ5ID0gZ3JvdXBpbmdBdHRyaWJ1dGU7XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHRhc2tdIG9mIHRhc2tzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgaXNGaWxlbmFtZVVuaXF1ZSA9IHRoaXMuaXNGaWxlbmFtZVVuaXF1ZSh7IHRhc2sgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gYXdhaXQgdGFza1RvTGkodGFzaywge1xuICAgICAgICAgICAgICAgIHBhcmVudFVsRWxlbWVudDogdGFza0xpc3QsXG4gICAgICAgICAgICAgICAgbGlzdEluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbnM6IHRoaXMucXVlcnkubGF5b3V0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpc0ZpbGVuYW1lVW5pcXVlLFxuICAgICAgICAgICAgICAgIHRhc2tMYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICBvYnNpZGlhbkNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZvb3Rub3Rlcy4gVGhleSBkb24ndCByZS1hcHBlYXIgaW4gYW5vdGhlciBkb2N1bWVudC5cbiAgICAgICAgICAgIGNvbnN0IGZvb3Rub3RlcyA9IGxpc3RJdGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvb3Rub3RlLWlkXScpO1xuICAgICAgICAgICAgZm9vdG5vdGVzLmZvckVhY2goKGZvb3Rub3RlKSA9PiBmb290bm90ZS5yZW1vdmUoKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhc1NwYW4gPSBsaXN0SXRlbS5jcmVhdGVTcGFuKCd0YXNrLWV4dHJhcycpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucXVlcnkubGF5b3V0T3B0aW9ucy5oaWRlVXJnZW5jeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVXJnZW5jeShleHRyYXNTcGFuLCB0YXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMuaGlkZUJhY2tsaW5rcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3J0TW9kZSA9IHRoaXMucXVlcnkubGF5b3V0T3B0aW9ucy5zaG9ydE1vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCYWNrbGlua3MoZXh0cmFzU3BhbiwgdGFzaywgc2hvcnRNb2RlLCBpc0ZpbGVuYW1lVW5pcXVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LmxheW91dE9wdGlvbnMuaGlkZUVkaXRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVkaXRCdXR0b24oZXh0cmFzU3BhbiwgdGFzayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhc2tMaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGFza0xpc3QpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkRWRpdEJ1dHRvbihsaXN0SXRlbTogSFRNTEVsZW1lbnQsIHRhc2s6IFRhc2spIHtcbiAgICAgICAgY29uc3QgZWRpdFRhc2tQZW5jaWwgPSBsaXN0SXRlbS5jcmVhdGVFbCgnYScsIHtcbiAgICAgICAgICAgIGNsczogJ3Rhc2tzLWVkaXQnLFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdFRhc2tQZW5jaWwub25DbGlja0V2ZW50KChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgY29uc3Qgb25TdWJtaXQgPSAodXBkYXRlZFRhc2tzOiBUYXNrW10pOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICByZXBsYWNlVGFza1dpdGhUYXNrcyh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFzazogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFza3M6IERhdGVGYWxsYmFjay5yZW1vdmVJbmZlcnJlZFN0YXR1c0lmTmVlZGVkKHRhc2ssIHVwZGF0ZWRUYXNrcyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBldmVyeSB0aW1lLCBhcyBjdXJzb3IvdGFzayBjYW4gY2hhbmdlLlxuICAgICAgICAgICAgY29uc3QgdGFza01vZGFsID0gbmV3IFRhc2tNb2RhbCh7XG4gICAgICAgICAgICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIG9uU3VibWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YXNrTW9kYWwub3BlbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFVyZ2VuY3kobGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5mb3JtYXQodGFzay51cmdlbmN5KTtcbiAgICAgICAgbGlzdEl0ZW0uY3JlYXRlU3Bhbih7IHRleHQsIGNsczogJ3Rhc2tzLXVyZ2VuY3knIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgYWRkQWxsVGFza0dyb3Vwcyh0YXNrc1NvcnRlZExpbWl0ZWRHcm91cGVkOiBUYXNrR3JvdXBzLCBjb250ZW50OiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRhc2tzU29ydGVkTGltaXRlZEdyb3VwZWQuZ3JvdXBzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSB3ZXJlIG5vICdncm91cCBieScgaW5zdHJ1Y3Rpb25zLCBncm91cC5ncm91cEhlYWRpbmdzXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGVtcHR5LCBhbmQgbm8gaGVhZGluZ3Mgd2lsbCBiZSBhZGRlZC5cbiAgICAgICAgICAgIHRoaXMuYWRkR3JvdXBIZWFkaW5ncyhjb250ZW50LCBncm91cC5ncm91cEhlYWRpbmdzKTtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVUYXNrTGlzdChncm91cC50YXNrcywgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGhlYWRpbmdzIGZvciBhIGdyb3VwIG9mIHRhc2tzLlxuICAgICAqIEBwYXJhbSBjb250ZW50XG4gICAgICogQHBhcmFtIGdyb3VwSGVhZGluZ3MgLSBUaGUgaGVhZGluZ3MgdG8gZGlzcGxheS4gVGhpcyBjYW4gYmUgYW4gZW1wdHkgYXJyYXksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBpbiB3aGljaCBjYXNlIG5vIGhlYWRpbmdzIHdpbGwgYmUgYWRkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGFkZEdyb3VwSGVhZGluZ3MoY29udGVudDogSFRNTERpdkVsZW1lbnQsIGdyb3VwSGVhZGluZ3M6IEdyb3VwRGlzcGxheUhlYWRpbmdbXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRpbmcgb2YgZ3JvdXBIZWFkaW5ncykge1xuICAgICAgICAgICAgdGhpcy5hZGRHcm91cEhlYWRpbmcoY29udGVudCwgaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGFkZEdyb3VwSGVhZGluZyhjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgZ3JvdXA6IEdyb3VwRGlzcGxheUhlYWRpbmcpIHtcbiAgICAgICAgLy8gSGVhZGluZ3MgbmVzdGVkIHRvIDIgb3IgbW9yZSBsZXZlbHMgYXJlIGFsbCBkaXNwbGF5ZWQgd2l0aCAnaDY6XG4gICAgICAgIGxldCBoZWFkZXI6IGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcCA9ICdoNic7XG4gICAgICAgIGlmIChncm91cC5uZXN0aW5nTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGhlYWRlciA9ICdoNCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubmVzdGluZ0xldmVsID09PSAxKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSAnaDUnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGVhZGVyRWwgPSBjb250ZW50LmNyZWF0ZUVsKGhlYWRlciwge1xuICAgICAgICAgICAgY2xzOiAndGFza3MtZ3JvdXAtaGVhZGluZycsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBNYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKGdyb3VwLmRpc3BsYXlOYW1lLCBoZWFkZXJFbCwgdGhpcy5maWxlUGF0aCwgdGhpcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRCYWNrbGlua3MobGlzdEl0ZW06IEhUTUxFbGVtZW50LCB0YXNrOiBUYXNrLCBzaG9ydE1vZGU6IGJvb2xlYW4sIGlzRmlsZW5hbWVVbmlxdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYmFja0xpbmsgPSBsaXN0SXRlbS5jcmVhdGVTcGFuKHsgY2xzOiAndGFza3MtYmFja2xpbmsnIH0pO1xuXG4gICAgICAgIGlmICghc2hvcnRNb2RlKSB7XG4gICAgICAgICAgICBiYWNrTGluay5hcHBlbmQoJyAoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaW5rID0gYmFja0xpbmsuY3JlYXRlRWwoJ2EnKTtcblxuICAgICAgICBsaW5rLnJlbCA9ICdub29wZW5lcic7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIGxpbmsuYWRkQ2xhc3MoJ2ludGVybmFsLWxpbmsnKTtcbiAgICAgICAgaWYgKHNob3J0TW9kZSkge1xuICAgICAgICAgICAgbGluay5hZGRDbGFzcygnaW50ZXJuYWwtbGluay1zaG9ydC1tb2RlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGlua1RleHQ6IHN0cmluZztcbiAgICAgICAgaWYgKHNob3J0TW9kZSkge1xuICAgICAgICAgICAgbGlua1RleHQgPSAnIFx1RDgzRFx1REQxNyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5rVGV4dCA9IHRhc2suZ2V0TGlua1RleHQoeyBpc0ZpbGVuYW1lVW5pcXVlIH0pID8/ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluay5zZXRUZXh0KGxpbmtUZXh0KTtcblxuICAgICAgICAvLyBHbyB0byB0aGUgbGluZSB0aGUgdGFzayBpcyBkZWZpbmVkIGF0XG4gICAgICAgIGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXY6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFRhc2tMaW5lQW5kRmlsZSh0YXNrLCB2YXVsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xpbmUsIGZpbGVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZihLZXltYXAuaXNNb2RFdmVudChldikpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb3BlbnMgdGhlIGZpbGUgd2l0aCB0aGUgcmVxdWlyZWQgbGluZSBoaWdobGlnaHRlZC5cbiAgICAgICAgICAgICAgICAvLyBJdCB3b3JrcyBmb3IgRWRpdCBhbmQgUmVhZGluZyBtb2RlLCBob3dldmVyLCBmb3Igc29tZSByZWFzb24gKG1heWJlIGFuIE9ic2lkaWFuIGJ1ZyksXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1c2VkIGluIFJlYWRpbmcgbW9kZSwgc3dpdGNoaW5nIHRoZSByZXN1bHQgdG8gRWRpdCBkb2VzIG5vdCBzeW5jIHRoZSBzY3JvbGwuXG4gICAgICAgICAgICAgICAgLy8gQSBwYXRjaCBzdWdnZXN0ZWQgb3ZlciBEaXNjb3JkIHRvIHVzZSBsZWFmLnNldEVwaGVtZXJhbFN0YXRlKHtzY3JvbGw6IGxpbmV9KSBkb2VzIG5vdCBzZWVtXG4gICAgICAgICAgICAgICAgLy8gdG8gbWFrZSBhIGRpZmZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGlzc3VlIGlzIHRyYWNrZWQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFuLXRhc2tzLWdyb3VwL29ic2lkaWFuLXRhc2tzL2lzc3Vlcy8xODc5XG4gICAgICAgICAgICAgICAgYXdhaXQgbGVhZi5vcGVuRmlsZShmaWxlLCB7IGVTdGF0ZTogeyBsaW5lOiBsaW5lIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgYXN5bmMgKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBPcGVuIGluIGEgbmV3IHRhYiBvbiBtaWRkbGUtY2xpY2suXG4gICAgICAgICAgICAvLyBUaGlzIGRpc3RpbmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlICdjbGljaycgZXZlbnQsIHNvIHdlIGhhbmRsZSB0aGUgJ21vdXNlZG93bicgZXZlbnRcbiAgICAgICAgICAgIC8vIHNvbGVseSBmb3IgdGhpcy5cbiAgICAgICAgICAgIC8vIChmb3IgcmVndWxhciBsZWZ0LWNsaWNrIHdlIHByZWZlciB0aGUgJ2NsaWNrJyBldmVudCwgYW5kIG5vdCB0byBqdXN0IGRvIGV2ZXJ5dGhpbmcgaGVyZSwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhlICdjbGljaycgZXZlbnQgaXMgbW9yZSBnZW5lcmljIGZvciB0b3VjaCBkZXZpY2VzIGV0Yy4pXG4gICAgICAgICAgICBpZiAoZXYuYnV0dG9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VGFza0xpbmVBbmRGaWxlKHRhc2ssIHZhdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtsaW5lLCBmaWxlXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCd0YWInKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbGVhZi5vcGVuRmlsZShmaWxlLCB7IGVTdGF0ZTogeyBsaW5lOiBsaW5lIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXNob3J0TW9kZSkge1xuICAgICAgICAgICAgYmFja0xpbmsuYXBwZW5kKCcpJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFRhc2tDb3VudChjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgcXVlcnlSZXN1bHQ6IFF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5sYXlvdXRPcHRpb25zLmhpZGVUYXNrQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzQ291bnRMYWJlbCA9IHF1ZXJ5UmVzdWx0LnRhc2tzQ291bnREaXNwbGF5VGV4dCgpO1xuICAgICAgICAgICAgY29udGVudC5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRhc2tzQ291bnRMYWJlbCxcbiAgICAgICAgICAgICAgICBjbHM6ICd0YXNrcy1jb3VudCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNGaWxlbmFtZVVuaXF1ZSh7IHRhc2sgfTogeyB0YXNrOiBUYXNrIH0pOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgLy8gV2lsbCBtYXRjaCB0aGUgZmlsZW5hbWUgd2l0aG91dCBleHRlbnNpb24gKHRoZSBmaWxlJ3MgXCJiYXNlbmFtZVwiKS5cbiAgICAgICAgY29uc3QgZmlsZW5hbWVNYXRjaCA9IHRhc2sucGF0aC5tYXRjaCgvKFteL10qKVxcLi4rJC9pKTtcbiAgICAgICAgaWYgKGZpbGVuYW1lTWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGVuYW1lTWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IGFsbEZpbGVzV2l0aFNhbWVOYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcigoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlLmJhc2VuYW1lID09PSBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWUgKGl0IG1pZ2h0IGFjdHVhbGx5IGJlIHRoZSBzYW1lIGZpbGUsIGJ1dCB3ZSdsbCB0YWtlIHRoYXQgaW50byBhY2NvdW50IGxhdGVyLilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFsbEZpbGVzV2l0aFNhbWVOYW1lLmxlbmd0aCA8IDI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRHcm91cGluZ0F0dHJpYnV0ZSgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBpbmdSdWxlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLnF1ZXJ5Lmdyb3VwaW5nKSB7XG4gICAgICAgICAgICBncm91cGluZ1J1bGVzLnB1c2goZ3JvdXAucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cGluZ1J1bGVzLmpvaW4oJywnKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsRmlsdGVyJztcbmltcG9ydCB0eXBlIHsgR2xvYmFsUXVlcnkgfSBmcm9tICcuLi9Db25maWcvR2xvYmFsUXVlcnknO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuLi9RdWVyeS9RdWVyeSc7XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgdXNlZCBieSB7QGxpbmsgUXVlcnlSZW5kZXJlcn0gdGhhdCBzaG91bGQgYWN0dWFsbHlcbiAqIGJlIGluIHRoYXQgZmlsZS4gQnV0IHRoZSBmaWxlIHtAbGluayBRdWVyeVJlbmRlcmVyfSBpcyBpbiBkZXBlbmRzIG9uIGRlcGVuZGVuY2llc1xuICogdGhhdCBhcmVuJ3QgYXZhaWxhYmxlIGR1cmluZyBhdXRvbWF0ZWQgdGVzdGluZywgYW5kIHdvdWxkIG1ha2UgaXQgaW1wb3NzaWJsZSB0byBydW5cbiAqIHRob3NlIHRlc3RzIG9uIHRoZSBjb2RlIHRoYXQgaXMgaW5zdGVhZCBob3VzZWQgaGVyZS5cbiAqL1xuXG4vKipcbiAqIEV4cGxhaW5zIGEgcXVlcnkgcmVuZGVyZWQgYnkge0BsaW5rIFF1ZXJ5UmVuZGVyZXJ9XG4gKlxuICogU3BlY2lmaWNhbGx5LCByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZzpcbiAqICAgICAqIEV4cGxhaW5zIHdoZXRoZXIgYSBnbG9iYWwgZmlsdGVyIGlzIGluIHVzZVxuICogICAgICogRXhwbGFpbnMgd2hldGhlciB0aGUgZ2xvYmFsIHF1ZXJ5IGlmIGl0J3MgaW4gdXNlXG4gKiAgICAgKiBFeHBsYWlucyB0aGUgcXVlcnkgZGVzY3JpYmVkIGJ5IHtAbGluayBzb3VyY2V9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIG9mIHRoZSB0YXNrIGJsb2NrIHRvIGV4cGxhaW5cbiAqIEBwYXJhbSB7R2xvYmFsRmlsdGVyfSBnbG9iYWxGaWx0ZXIgVGhlIGdsb2JhbCBmaWx0ZXIuIEluIGBzcmMvYCwgZ2VuZXJhbGx5IHBhc3MgaW4ge0BsaW5rIEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZX1cbiAqIEBwYXJhbSB7R2xvYmFsUXVlcnl9IGdsb2JhbFF1ZXJ5IFRoZSBnbG9iYWwgcXVlcnkuIEluIGBzcmMvYCwgZ2VuZXJhbGx5IHBhc3MgaW4ge0BsaW5rIEdsb2JhbFF1ZXJ5LmdldEluc3RhbmNlfVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSB0YXNrIGJsb2NrLCBpZiBrbm93blxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5SZXN1bHRzKFxuICAgIHNvdXJjZTogc3RyaW5nLFxuICAgIGdsb2JhbEZpbHRlcjogR2xvYmFsRmlsdGVyLFxuICAgIGdsb2JhbFF1ZXJ5OiBHbG9iYWxRdWVyeSxcbiAgICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIGlmICghZ2xvYmFsRmlsdGVyLmlzRW1wdHkoKSkge1xuICAgICAgICByZXN1bHQgKz0gYE9ubHkgdGFza3MgY29udGFpbmluZyB0aGUgZ2xvYmFsIGZpbHRlciAnJHtnbG9iYWxGaWx0ZXIuZ2V0KCl9Jy5cXG5cXG5gO1xuICAgIH1cblxuICAgIGNvbnN0IHRhc2tzQmxvY2tRdWVyeSA9IG5ldyBRdWVyeShzb3VyY2UsIHBhdGgpO1xuXG4gICAgaWYgKCF0YXNrc0Jsb2NrUXVlcnkuaWdub3JlR2xvYmFsUXVlcnkpIHtcbiAgICAgICAgaWYgKGdsb2JhbFF1ZXJ5Lmhhc0luc3RydWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYEV4cGxhbmF0aW9uIG9mIHRoZSBnbG9iYWwgcXVlcnk6XFxuXFxuJHtnbG9iYWxRdWVyeS5xdWVyeShwYXRoKS5leHBsYWluUXVlcnkoKX1cXG5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGBFeHBsYW5hdGlvbiBvZiB0aGlzIFRhc2tzIGNvZGUgYmxvY2sgcXVlcnk6XFxuXFxuJHt0YXNrc0Jsb2NrUXVlcnkuZXhwbGFpblF1ZXJ5KCl9YDtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgYWN0dWFsIHF1ZXJ5IHRoYXQge0BsaW5rIFF1ZXJ5UmVuZGVyQ2hpbGR9IHdpbGwgYWN0dWFsbHkgZXhlY3V0ZSBhZ2FpbnN0IHRoZSB0YXNrIGxpc3QuXG4gKlxuICogVGhpcyBxdWVyeSBpcyB0aGUgcmVzdWx0IG9mIGpvaW5pbmcgdGhlIGdsb2JhbCBxdWVyeSB3aXRoIHRoZSBxdWVyeSBpbiB0aGUgdGFzayBibG9ja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHF1ZXJ5IHNvdXJjZSBmcm9tIHRoZSB0YXNrIGJsb2NrXG4gKiBAcGFyYW0gZ2xvYmFsUXVlcnlcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5LCBpZiBhdmFpbGFibGUuXG4gKiBAcmV0dXJucyB7UXVlcnl9IFRoZSBxdWVyeSB0byBleGVjdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeUZvclF1ZXJ5UmVuZGVyZXIoc291cmNlOiBzdHJpbmcsIGdsb2JhbFF1ZXJ5OiBHbG9iYWxRdWVyeSwgcGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkKTogUXVlcnkge1xuICAgIGNvbnN0IHRhc2tzQmxvY2tRdWVyeSA9IG5ldyBRdWVyeShzb3VyY2UsIHBhdGgpO1xuXG4gICAgaWYgKHRhc2tzQmxvY2tRdWVyeS5pZ25vcmVHbG9iYWxRdWVyeSkge1xuICAgICAgICByZXR1cm4gdGFza3NCbG9ja1F1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxRdWVyeS5xdWVyeShwYXRoKS5hcHBlbmQodGFza3NCbG9ja1F1ZXJ5KTtcbn1cbiIsICJpbXBvcnQgeyBOb3RpY2UsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIGRlYm91bmNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3RhdHVzQ29uZmlndXJhdGlvbiwgU3RhdHVzVHlwZSB9IGZyb20gJy4uL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHR5cGUgVGFza3NQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4uL1N0YXR1c1JlZ2lzdHJ5JztcbmltcG9ydCB7IFN0YXR1cyB9IGZyb20gJy4uL1N0YXR1cyc7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi9TdGF0dXNDb2xsZWN0aW9uJztcbmltcG9ydCAqIGFzIFRoZW1lcyBmcm9tICcuL1RoZW1lcyc7XG5pbXBvcnQgeyB0eXBlIEhlYWRpbmdTdGF0ZSwgVEFTS19GT1JNQVRTIH0gZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgeyBnZXRTZXR0aW5ncywgaXNGZWF0dXJlRW5hYmxlZCwgdXBkYXRlR2VuZXJhbFNldHRpbmcsIHVwZGF0ZVNldHRpbmdzIH0gZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgeyBHbG9iYWxGaWx0ZXIgfSBmcm9tICcuL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgeyBTdGF0dXNTZXR0aW5ncyB9IGZyb20gJy4vU3RhdHVzU2V0dGluZ3MnO1xuaW1wb3J0IHNldHRpbmdzSnNvbiBmcm9tICcuL3NldHRpbmdzQ29uZmlndXJhdGlvbi5qc29uJztcblxuaW1wb3J0IHsgQ3VzdG9tU3RhdHVzTW9kYWwgfSBmcm9tICcuL0N1c3RvbVN0YXR1c01vZGFsJztcbmltcG9ydCB7IEdsb2JhbFF1ZXJ5IH0gZnJvbSAnLi9HbG9iYWxRdWVyeSc7XG5cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIC8vIElmIHRoZSBVSSBuZWVkcyBhIG1vcmUgY29tcGxleCBzZXR0aW5nIHlvdSBjYW4gY3JlYXRlIGFcbiAgICAvLyBjdXN0b20gZnVuY3Rpb24gYW5kIHNwZWNpZnkgaXQgZnJvbSB0aGUganNvbiBmaWxlLiBJdCB3aWxsXG4gICAgLy8gdGhlbiBiZSByZW5kZXJlZCBpbnN0ZWFkIG9mIGEgbm9ybWFsIGNoZWNrYm94IG9yIHRleHQgYm94LlxuICAgIGN1c3RvbUZ1bmN0aW9uczogeyBbSzogc3RyaW5nXTogRnVuY3Rpb24gfSA9IHtcbiAgICAgICAgaW5zZXJ0VGFza0NvcmVTdGF0dXNTZXR0aW5nczogdGhpcy5pbnNlcnRUYXNrQ29yZVN0YXR1c1NldHRpbmdzLmJpbmQodGhpcyksXG4gICAgICAgIGluc2VydEN1c3RvbVRhc2tTdGF0dXNTZXR0aW5nczogdGhpcy5pbnNlcnRDdXN0b21UYXNrU3RhdHVzU2V0dGluZ3MuYmluZCh0aGlzKSxcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IFRhc2tzUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoeyBwbHVnaW4gfTogeyBwbHVnaW46IFRhc2tzUGx1Z2luIH0pIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCwgcGx1Z2luKTtcblxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVGcmFnbWVudFdpdGhIVE1MID0gKGh0bWw6IHN0cmluZykgPT5cbiAgICAgICAgY3JlYXRlRnJhZ21lbnQoKGRvY3VtZW50RnJhZ21lbnQpID0+IChkb2N1bWVudEZyYWdtZW50LmNyZWF0ZURpdigpLmlubmVySFRNTCA9IGh0bWwpKTtcblxuICAgIHB1YmxpYyBhc3luYyBzYXZlU2V0dGluZ3ModXBkYXRlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYWRkQ2xhc3MoJ3Rhc2tzLXNldHRpbmdzJyk7XG5cbiAgICAgICAgLy8gRm9yIHJlYXNvbnMgSSBkb24ndCB1bmRlcnN0YW5kLCAnaDInIGlzIHRpbnkgaW4gU2V0dGluZ3MsXG4gICAgICAgIC8vIHNvIEkgaGF2ZSB1c2VkICdoMycgYXMgdGhlIGxhcmdlc3QgaGVhZGluZy5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnVGFza3MgU2V0dGluZ3MnIH0pO1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHtcbiAgICAgICAgICAgIGNsczogJ3Rhc2tzLXNldHRpbmctaW1wb3J0YW50JyxcbiAgICAgICAgICAgIHRleHQ6ICdDaGFuZ2luZyBhbnkgc2V0dGluZ3MgcmVxdWlyZXMgYSByZXN0YXJ0IG9mIG9ic2lkaWFuLicsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdUYXNrIEZvcm1hdCBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgRm9ybWF0JylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICc8cD5UaGUgZm9ybWF0IHRoYXQgVGFza3MgdXNlcyB0byByZWFkIGFuZCB3cml0ZSB0YXNrcy48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+PGI+SW1wb3J0YW50OjwvYj4gVGFza3MgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgb25lIGZvcm1hdCBhdCBhIHRpbWUuIFNlbGVjdGluZyBEYXRhdmlldyB3aWxsIGN1cnJlbnRseSA8Yj5zdG9wIFRhc2tzIHJlYWRpbmcgaXRzIG93biBlbW9qaSBzaWduaWZpZXJzPC9iPi48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL1JlZmVyZW5jZS9UYXNrK0Zvcm1hdHMvQWJvdXQrVGFzaytGb3JtYXRzXCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhUQVNLX0ZPUk1BVFMpIGFzIChrZXlvZiBUQVNLX0ZPUk1BVFMpW10pIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKGtleSwgVEFTS19GT1JNQVRTW2tleV0uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKGdldFNldHRpbmdzKCkudGFza0Zvcm1hdCkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgdGFza0Zvcm1hdDogdmFsdWUgYXMga2V5b2YgVEFTS19GT1JNQVRTIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdHbG9iYWwgZmlsdGVyIFNldHRpbmdzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnR2xvYmFsIHRhc2sgZmlsdGVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICc8cD48Yj5SZWNvbW1lbmRlZDogTGVhdmUgZW1wdHkgaWYgeW91IHdhbnQgYWxsIGNoZWNrbGlzdCBpdGVtcyBpbiB5b3VyIHZhdWx0IHRvIGJlIHRhc2tzIG1hbmFnZWQgYnkgdGhpcyBwbHVnaW4uPC9iPjwvcD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5Vc2UgYSBnbG9iYWwgZmlsdGVyIGlmIHlvdSB3YW50IFRhc2tzIHRvIG9ubHkgYWN0IG9uIGEgc3Vic2V0IG9mIHlvdXIgXCI8Y29kZT4tIFsgXTwvY29kZT5cIiBjaGVja2xpc3QgaXRlbXMsIHNvIHRoYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYSBjaGVja2xpc3QgaXRlbSBtdXN0IGluY2x1ZGUgdGhlIHNwZWNpZmllZCBzdHJpbmcgaW4gaXRzIGRlc2NyaXB0aW9uIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXNrLjxwPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPkZvciBleGFtcGxlLCBpZiB5b3Ugc2V0IHRoZSBnbG9iYWwgZmlsdGVyIHRvIDxjb2RlPiN0YXNrPC9jb2RlPiwgdGhlIFRhc2tzIHBsdWdpbiB3aWxsIG9ubHkgaGFuZGxlIGNoZWNrbGlzdCBpdGVtcyB0YWdnZWQgd2l0aCA8Y29kZT4jdGFzazwvY29kZT4uPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPdGhlciBjaGVja2xpc3QgaXRlbXMgd2lsbCByZW1haW4gbm9ybWFsIGNoZWNrbGlzdCBpdGVtcyBhbmQgbm90IGFwcGVhciBpbiBxdWVyaWVzIG9yIGdldCBhIGRvbmUgZGF0ZSBzZXQuPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvR2xvYmFsK0ZpbHRlclwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEkgd2FudGVkIHRvIG1ha2UgdGhpcyBzYXkgJ2ZvciBleGFtcGxlLCAjdGFzayBvciBUT0RPJ1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB3YXNuJ3QgYWJsZSB0byBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIHRoZSB0ZXh0IGJveFxuICAgICAgICAgICAgICAgIC8vIHdpZGUgZW5vdWdoIGZvciB0aGUgd2hvbGUgc3RyaW5nIHRvIGJlIHZpc2libGUuXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignZS5nLiAjdGFzayBvciBUT0RPJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKEdsb2JhbEZpbHRlci5nZXRJbnN0YW5jZSgpLmdldCgpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGdsb2JhbEZpbHRlcjogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVtb3ZlIGdsb2JhbCBmaWx0ZXIgZnJvbSBkZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnRW5hYmxpbmcgdGhpcyByZW1vdmVzIHRoZSBzdHJpbmcgdGhhdCB5b3Ugc2V0IGFzIGdsb2JhbCBmaWx0ZXIgZnJvbSB0aGUgdGFzayBkZXNjcmlwdGlvbiB3aGVuIGRpc3BsYXlpbmcgYSB0YXNrLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3MucmVtb3ZlR2xvYmFsRmlsdGVyKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyByZW1vdmVHbG9iYWxGaWx0ZXI6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBHbG9iYWxGaWx0ZXIuZ2V0SW5zdGFuY2UoKS5zZXRSZW1vdmVHbG9iYWxGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdHbG9iYWwgUXVlcnknIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBtYWtlTXVsdGlsaW5lVGV4dFNldHRpbmcoXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5BIHF1ZXJ5IHRoYXQgaXMgYXV0b21hdGljYWxseSBpbmNsdWRlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgVGFza3MgYmxvY2sgaW4gdGhlIHZhdWx0LicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgVXNlZnVsIGZvciBhZGRpbmcgZGVmYXVsdCBmaWx0ZXJzLCBvciBsYXlvdXQgb3B0aW9ucy48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9RdWVyaWVzL0dsb2JhbCtRdWVyeVwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAuYWRkVGV4dEFyZWEoKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignIyBGb3IgZXhhbXBsZS4uLlxcbnBhdGggZG9lcyBub3QgaW5jbHVkZSBfdGVtcGxhdGVzL1xcbmxpbWl0IDMwMFxcbnNob3cgdXJnZW5jeScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuZ2xvYmFsUXVlcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBnbG9iYWxRdWVyeTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR2xvYmFsUXVlcnkuZ2V0SW5zdGFuY2UoKS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ1Rhc2sgU3RhdHVzZXMnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCB7IGhlYWRpbmdPcGVuZWQgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgc2V0dGluZ3NKc29uLmZvckVhY2goKGhlYWRpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT25lU2V0dGluZ3NCbG9jayhjb250YWluZXJFbCwgaGVhZGluZywgaGVhZGluZ09wZW5lZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdEYXRlIFNldHRpbmdzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU2V0IGNyZWF0ZWQgZGF0ZSBvbiBldmVyeSBhZGRlZCB0YXNrJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgIFwiRW5hYmxpbmcgdGhpcyB3aWxsIGFkZCBhIHRpbWVzdGFtcCBcdTI3OTUgWVlZWS1NTS1ERCBiZWZvcmUgb3RoZXIgZGF0ZSB2YWx1ZXMsIHdoZW4gYSB0YXNrIGlzIGNyZWF0ZWQgd2l0aCAnQ3JlYXRlIG9yIGVkaXQgdGFzaycsIG9yIGJ5IGNvbXBsZXRpbmcgYSByZWN1cnJpbmcgdGFzay48L2JyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL0RhdGVzI0NyZWF0ZWQrZGF0ZVwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnNldENyZWF0ZWREYXRlKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBzZXRDcmVhdGVkRGF0ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU2V0IGRvbmUgZGF0ZSBvbiBldmVyeSBjb21wbGV0ZWQgdGFzaycpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnRW5hYmxpbmcgdGhpcyB3aWxsIGFkZCBhIHRpbWVzdGFtcCBcdTI3MDUgWVlZWS1NTS1ERCBhdCB0aGUgZW5kIHdoZW4gYSB0YXNrIGlzIHRvZ2dsZWQgdG8gZG9uZS48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvRGF0ZXMjRG9uZStkYXRlXCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3Muc2V0RG9uZURhdGUpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IHNldERvbmVEYXRlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdVc2UgZmlsZW5hbWUgYXMgU2NoZWR1bGVkIGRhdGUgZm9yIHVuZGF0ZWQgdGFza3MnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUgdGltZSBlbnRlcmluZyBTY2hlZHVsZWQgKFx1MjNGMykgZGF0ZXMuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdJZiB0aGlzIG9wdGlvbiBpcyBlbmFibGVkLCBhbnkgdW5kYXRlZCB0YXNrcyB3aWxsIGJlIGdpdmVuIGEgZGVmYXVsdCBTY2hlZHVsZWQgZGF0ZSBleHRyYWN0ZWQgZnJvbSB0aGVpciBmaWxlIG5hbWUuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgZGF0ZSBpbiB0aGUgZmlsZSBuYW1lIG11c3QgYmUgaW4gb25lIG9mIDxjb2RlPllZWVktTU0tREQ8L2NvZGU+IG9yIDxjb2RlPllZWVlNTUREPC9jb2RlPiBmb3JtYXRzLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVW5kYXRlZCB0YXNrcyBoYXZlIG5vbmUgb2YgRHVlIChcdUQ4M0RcdURDQzUgKSwgU2NoZWR1bGVkIChcdTIzRjMpIGFuZCBTdGFydCAoXHVEODNEXHVERUVCKSBkYXRlcy48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvVXNlK0ZpbGVuYW1lK2FzK0RlZmF1bHQrRGF0ZVwiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnVzZUZpbGVuYW1lQXNTY2hlZHVsZWREYXRlKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyB1c2VGaWxlbmFtZUFzU2NoZWR1bGVkRGF0ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRm9sZGVycyB3aXRoIGRlZmF1bHQgU2NoZWR1bGVkIGRhdGVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdMZWF2ZSBlbXB0eSBpZiB5b3Ugd2FudCB0byB1c2UgZGVmYXVsdCBTY2hlZHVsZWQgZGF0ZXMgZXZlcnl3aGVyZSwgb3IgZW50ZXIgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmb2xkZXJzLicsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dChhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKFNldHRpbmdzVGFiLnJlbmRlckZvbGRlckFycmF5KHNldHRpbmdzLmZpbGVuYW1lQXNEYXRlRm9sZGVycykpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlcnMgPSBTZXR0aW5nc1RhYi5wYXJzZUNvbW1hU2VwYXJhdGVkRm9sZGVycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGZpbGVuYW1lQXNEYXRlRm9sZGVyczogZm9sZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdSZWN1cnJpbmcgdGFzayBTZXR0aW5ncycgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ05leHQgcmVjdXJyZW5jZSBhcHBlYXJzIG9uIHRoZSBsaW5lIGJlbG93JylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFNldHRpbmdzVGFiLmNyZWF0ZUZyYWdtZW50V2l0aEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICdFbmFibGluZyB0aGlzIHdpbGwgbWFrZSB0aGUgbmV4dCByZWN1cnJlbmNlIG9mIGEgdGFzayBhcHBlYXIgb24gdGhlIGxpbmUgYmVsb3cgdGhlIGNvbXBsZXRlZCB0YXNrLiBPdGhlcndpc2UgdGhlIG5leHQgcmVjdXJyZW5jZSB3aWxsIGFwcGVhciBiZWZvcmUgdGhlIGNvbXBsZXRlZCBvbmUuPC9icj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8cD5TZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvdGFza3MvR2V0dGluZytTdGFydGVkL1JlY3VycmluZytUYXNrc1wiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3VycmVuY2VPbk5leHRMaW5lOiByZWN1cnJlbmNlT25OZXh0TGluZSB9ID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUocmVjdXJyZW5jZU9uTmV4dExpbmUpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IHJlY3VycmVuY2VPbk5leHRMaW5lOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnQXV0by1zdWdnZXN0IFNldHRpbmdzJyB9KTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQXV0by1zdWdnZXN0IHRhc2sgY29udGVudCcpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBTZXR0aW5nc1RhYi5jcmVhdGVGcmFnbWVudFdpdGhIVE1MKFxuICAgICAgICAgICAgICAgICAgICAnRW5hYmxpbmcgdGhpcyB3aWxsIG9wZW4gYW4gaW50ZWxsaWdlbnQgc3VnZ2VzdCBtZW51IHdoaWxlIHR5cGluZyBpbnNpZGUgYSByZWNvZ25pemVkIHRhc2sgbGluZS48L2JyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxwPlNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC90YXNrcy9HZXR0aW5nK1N0YXJ0ZWQvQXV0by1TdWdnZXN0XCI+ZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUoc2V0dGluZ3MuYXV0b1N1Z2dlc3RJbkVkaXRvcikub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgYXV0b1N1Z2dlc3RJbkVkaXRvcjogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWluaW11bSBtYXRjaCBsZW5ndGggZm9yIGF1dG8tc3VnZ2VzdCcpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAnSWYgaGlnaGVyIHRoYW4gMCwgYXV0by1zdWdnZXN0IHdpbGwgYmUgdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgYmVnaW5uaW5nIG9mIGFueSBzdXBwb3J0ZWQga2V5d29yZHMgaXMgcmVjb2duaXplZC4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDAsIDMsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5hdXRvU3VnZ2VzdE1pbk1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTZXR0aW5ncyh7IGF1dG9TdWdnZXN0TWluTWF0Y2g6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWF4aW11bSBudW1iZXIgb2YgYXV0by1zdWdnZXN0aW9ucyB0byBzaG93JylcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgICdIb3cgbWFueSBzdWdnZXN0aW9ucyBzaG91bGQgYmUgc2hvd24gd2hlbiBhbiBhdXRvLXN1Z2dlc3QgbWVudSBwb3BzIHVwIChpbmNsdWRpbmcgdGhlIFwiXHUyM0NFXCIgb3B0aW9uKS4nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFNsaWRlcigoc2xpZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDMsIDEyLCAxKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuYXV0b1N1Z2dlc3RNYXhJdGVtcylcbiAgICAgICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBhdXRvU3VnZ2VzdE1heEl0ZW1zOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdEaWFsb2cgU2V0dGluZ3MnIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm92aWRlIGFjY2VzcyBrZXlzIGluIGRpYWxvZ3MnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NUYWIuY3JlYXRlRnJhZ21lbnRXaXRoSFRNTChcbiAgICAgICAgICAgICAgICAgICAgJ0lmIHRoZSBhY2Nlc3Mga2V5cyAoa2V5Ym9hcmQgc2hvcnRjdXRzKSBmb3IgdmFyaW91cyBjb250cm9scycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBpbiBkaWFsb2cgYm94ZXMgY29uZmxpY3Qgd2l0aCBzeXN0ZW0ga2V5Ym9hcmQgc2hvcnRjdXRzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIG9yIGFzc2lzdGl2ZSB0ZWNobm9sb2d5IGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBpbXBvcnRhbnQgZm9yIHlvdSwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgeW91IG1heSB3YW50IHRvIGRlYWN0aXZhdGUgdGhlbSBoZXJlLjwvYnI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHA+U2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3Rhc2tzL0dldHRpbmcrU3RhcnRlZC9DcmVhdGUrb3IrZWRpdCtUYXNrI0tleWJvYXJkK3Nob3J0Y3V0c1wiPmRvY3VtZW50YXRpb248L2E+LjwvcD4nLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnByb3ZpZGVBY2Nlc3NLZXlzKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2V0dGluZ3MoeyBwcm92aWRlQWNjZXNzS2V5czogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRPbmVTZXR0aW5nc0Jsb2NrKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgaGVhZGluZzogYW55LCBoZWFkaW5nT3BlbmVkOiBIZWFkaW5nU3RhdGUpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsc0NvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkZXRhaWxzJywge1xuICAgICAgICAgICAgY2xzOiAndGFza3MtbmVzdGVkLXNldHRpbmdzJyxcbiAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICAuLi4oaGVhZGluZy5vcGVuIHx8IGhlYWRpbmdPcGVuZWRbaGVhZGluZy50ZXh0XSA/IHsgb3BlbjogdHJ1ZSB9IDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRldGFpbHNDb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgZGV0YWlsc0NvbnRhaW5lci5vbnRvZ2dsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGhlYWRpbmdPcGVuZWRbaGVhZGluZy50ZXh0XSA9IGRldGFpbHNDb250YWluZXIub3BlbjtcbiAgICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKHsgaGVhZGluZ09wZW5lZDogaGVhZGluZ09wZW5lZCB9KTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdW1tYXJ5ID0gZGV0YWlsc0NvbnRhaW5lci5jcmVhdGVFbCgnc3VtbWFyeScpO1xuICAgICAgICBuZXcgU2V0dGluZyhzdW1tYXJ5KS5zZXRIZWFkaW5nKCkuc2V0TmFtZShoZWFkaW5nLnRleHQpO1xuICAgICAgICBzdW1tYXJ5LmNyZWF0ZURpdignY29sbGFwc2VyJykuY3JlYXRlRGl2KCdoYW5kbGUnKTtcblxuICAgICAgICAvLyBkZXRhaWxzQ29udGFpbmVyLmNyZWF0ZUVsKGhlYWRpbmcubGV2ZWwgYXMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwLCB7IHRleHQ6IGhlYWRpbmcudGV4dCB9KTtcblxuICAgICAgICBpZiAoaGVhZGluZy5ub3RpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGljZSA9IGRldGFpbHNDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbHM6IGhlYWRpbmcubm90aWNlLmNsYXNzLFxuICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRpbmcubm90aWNlLnRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoZWFkaW5nLm5vdGljZS5odG1sICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm90aWNlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaGVhZGluZy5ub3RpY2UuaHRtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgdGhlIHNldHRpbmdzIGZyb20gc2V0dGluZ3NDb25maWd1cmF0aW9uLmpzb24gYW5kIHJlbmRlclxuICAgICAgICAvLyB0aGVtIG91dCByZWR1Y2luZyB0aGUgZHVwbGljYXRpb24gb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlLiBUaGlzIHdpbGwgYmVjb21lXG4gICAgICAgIC8vIG1vcmUgaW1wb3J0YW50IGFzIGZlYXR1cmVzIGFyZSBiZWluZyBhZGRlZCBvdmVyIHRpbWUuXG4gICAgICAgIGhlYWRpbmcuc2V0dGluZ3MuZm9yRWFjaCgoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy5mZWF0dXJlRmxhZyAhPT0gJycgJiYgIWlzRmVhdHVyZUVuYWJsZWQoc2V0dGluZy5mZWF0dXJlRmxhZykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgY29uZmlndXJhdGlvbiBoYXMgYSBmZWF0dXJlRmxhZyBzZXQgYW5kIHRoZSB1c2VyIGhhcyBub3RcbiAgICAgICAgICAgICAgICAvLyBlbmFibGVkIGl0LiBTa2lwIGFkZGluZyB0aGUgc2V0dGluZ3Mgb3B0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5nLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhkZXRhaWxzQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZShzZXR0aW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKHNldHRpbmcuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCBzZXR0aW5nLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoPGJvb2xlYW4+c2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR2VuZXJhbFNldHRpbmcoc2V0dGluZy5zZXR0aW5nTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZGV0YWlsc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoc2V0dGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYyhzZXR0aW5nLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCBzZXR0aW5nLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHZW5lcmFsU2V0dGluZyhzZXR0aW5nLnNldHRpbmdOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKHNldHRpbmcucGxhY2Vob2xkZXIudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuZ2VuZXJhbFNldHRpbmdzW3NldHRpbmcuc2V0dGluZ05hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGRlYm91bmNlKG9uQ2hhbmdlLCA1MDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcudHlwZSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGRldGFpbHNDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKHNldHRpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2Moc2V0dGluZy5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmdlbmVyYWxTZXR0aW5nc1tzZXR0aW5nLnNldHRpbmdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdlbmVyYWxTZXR0aW5nKHNldHRpbmcuc2V0dGluZ05hbWUsIHNldHRpbmcuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUdlbmVyYWxTZXR0aW5nKHNldHRpbmcuc2V0dGluZ05hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoc2V0dGluZy5wbGFjZWhvbGRlci50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5nZW5lcmFsU2V0dGluZ3Nbc2V0dGluZy5zZXR0aW5nTmFtZV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoZGVib3VuY2Uob25DaGFuZ2UsIDUwMCwgdHJ1ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwucm93cyA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuY29scyA9IDQwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZy50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21GdW5jdGlvbnNbc2V0dGluZy5zZXR0aW5nTmFtZV0oZGV0YWlsc0NvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nLm5vdGljZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGljZSA9IGRldGFpbHNDb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogc2V0dGluZy5ub3RpY2UuY2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNldHRpbmcubm90aWNlLnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcubm90aWNlLmh0bWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgc2V0dGluZy5ub3RpY2UuaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZUNvbW1hU2VwYXJhdGVkRm9sZGVycyhpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyBhIGxpbWl0YXRpb24gaXMgdGhhdCBmb2xkZXIgbmFtZXMgbWF5IG5vdCBjb250YWluIGNvbW1hc1xuICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgLm1hcCgoZm9sZGVyKSA9PiBmb2xkZXIudHJpbSgpKVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoZm9sZGVyKSA9PiBmb2xkZXIucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmb2xkZXIpID0+IGZvbGRlciAhPT0gJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVuZGVyRm9sZGVyQXJyYXkoZm9sZGVyczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZm9sZGVycy5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGluZ3MgZm9yIENvcmUgVGFzayBTdGF0dXNcbiAgICAgKiBUaGVzZSBhcmUgYnVpbHQtaW4gc3RhdHVzZXMgdGhhdCBjYW4gaGF2ZSBtaW5pbWFsIGVkaXRzIG1hZGUsXG4gICAgICogYnV0IGFyZSBub3QgYWxsb3dlZCB0byBiZSBkZWxldGVkIG9yIGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyRWxcbiAgICAgKiBAcGFyYW0ge1NldHRpbmdzVGFifSBzZXR0aW5nc1xuICAgICAqIEBtZW1iZXJvZiBTZXR0aW5nc1RhYlxuICAgICAqL1xuICAgIGluc2VydFRhc2tDb3JlU3RhdHVzU2V0dGluZ3MoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzZXR0aW5nczogU2V0dGluZ3NUYWIpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXNTZXR0aW5ncyB9ID0gZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBPbmUgcm93IHBlciBjb3JlIHN0YXR1cyBpbiB0aGUgc2V0dGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY29yZVN0YXR1c2VzLmZvckVhY2goKHN0YXR1c190eXBlKSA9PiB7XG4gICAgICAgICAgICBjcmVhdGVSb3dGb3JUYXNrU3RhdHVzKFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLFxuICAgICAgICAgICAgICAgIHN0YXR1c190eXBlLFxuICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLmNvcmVTdGF0dXNlcyxcbiAgICAgICAgICAgICAgICBzdGF0dXNTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW4sXG4gICAgICAgICAgICAgICAgdHJ1ZSwgLy8gaXNDb3JlU3RhdHVzXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5ncyBmb3IgQ3VzdG9tIFRhc2sgU3RhdHVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJFbFxuICAgICAqIEBwYXJhbSB7U2V0dGluZ3NUYWJ9IHNldHRpbmdzXG4gICAgICogQG1lbWJlcm9mIFNldHRpbmdzVGFiXG4gICAgICovXG4gICAgaW5zZXJ0Q3VzdG9tVGFza1N0YXR1c1NldHRpbmdzKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc2V0dGluZ3M6IFNldHRpbmdzVGFiKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzU2V0dGluZ3MgfSA9IGdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gT25lIHJvdyBwZXIgY3VzdG9tIHN0YXR1cyBpbiB0aGUgc2V0dGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzX3R5cGUpID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZVJvd0ZvclRhc2tTdGF0dXMoXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwsXG4gICAgICAgICAgICAgICAgc3RhdHVzX3R5cGUsXG4gICAgICAgICAgICAgICAgc3RhdHVzU2V0dGluZ3MuY3VzdG9tU3RhdHVzZXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luLFxuICAgICAgICAgICAgICAgIGZhbHNlLCAvLyBpc0NvcmVTdGF0dXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnKTtcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAnQWRkIE5ldyBUYXNrIFN0YXR1cycgYnV0dG9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgTmV3IFRhc2sgU3RhdHVzJylcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLmFkZFN0YXR1cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1NldHRpbmdzLmN1c3RvbVN0YXR1c2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YXR1c0NvbmZpZ3VyYXRpb24oJycsICcnLCAnJywgZmFsc2UsIFN0YXR1c1R5cGUuVE9ETyksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0dGluZy5pbmZvRWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gQWRkIGFsbCBTdGF0dXMgdHlwZXMgc3VwcG9ydGVkIGJ5IC4uLiBidXR0b25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIHR5cGUgTmFtZWRUaGVtZSA9IFtzdHJpbmcsIFN0YXR1c0NvbGxlY3Rpb25dO1xuICAgICAgICBjb25zdCB0aGVtZXM6IE5hbWVkVGhlbWVbXSA9IFtcbiAgICAgICAgICAgIC8vIExpZ2h0IGFuZCBEYXJrIHRoZW1lcyAtIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICAgICAgWydBbnVQcHVjY2luIFRoZW1lJywgVGhlbWVzLmFudXBwdWNjaW5TdXBwb3J0ZWRTdGF0dXNlcygpXSxcbiAgICAgICAgICAgIFsnQXVyYSBUaGVtZScsIFRoZW1lcy5hdXJhU3VwcG9ydGVkU3RhdHVzZXMoKV0sXG4gICAgICAgICAgICBbJ0VidWxsaWVudHdvcmtzIFRoZW1lJywgVGhlbWVzLmVidWxsaWVudHdvcmtzU3VwcG9ydGVkU3RhdHVzZXMoKV0sXG4gICAgICAgICAgICBbJ0lUUyBUaGVtZSAmIFNsUnZiIENoZWNrYm94ZXMnLCBUaGVtZXMuaXRzU3VwcG9ydGVkU3RhdHVzZXMoKV0sXG4gICAgICAgICAgICBbJ01pbmltYWwgVGhlbWUnLCBUaGVtZXMubWluaW1hbFN1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICAgICAgWydUaGluZ3MgVGhlbWUnLCBUaGVtZXMudGhpbmdzU3VwcG9ydGVkU3RhdHVzZXMoKV0sXG4gICAgICAgICAgICAvLyBEYXJrIG9ubHkgdGhlbWVzIC0gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICAgICAgICBbJ0xZVCBNb2RlIFRoZW1lIChEYXJrIG1vZGUgb25seSknLCBUaGVtZXMubHl0TW9kZVN1cHBvcnRlZFN0YXR1c2VzKCldLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb2xsZWN0aW9uXSBvZiB0aGVtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZFN0YXR1c2VzU3VwcG9ydGVkQnlUaGlzVGhlbWUgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGAke25hbWV9OiBBZGQgJHtjb2xsZWN0aW9uLmxlbmd0aH0gc3VwcG9ydGVkIFN0YXR1c2VzYDtcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChsYWJlbCkub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkZEN1c3RvbVN0YXRlc1RvU2V0dGluZ3MoY29sbGVjdGlvbiwgc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkU3RhdHVzZXNTdXBwb3J0ZWRCeVRoaXNUaGVtZS5pbmZvRWwucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAnQWRkIEFsbCBVbmtub3duIFN0YXR1cyBUeXBlcycgYnV0dG9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IGFkZEFsbFVua25vd25TdGF0dXNlcyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBBbGwgVW5rbm93biBTdGF0dXMgVHlwZXMnKVxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza3MgPSB0aGlzLnBsdWdpbi5nZXRUYXNrcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxTdGF0dXNlcyA9IHRhc2tzIS5tYXAoKHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25TdGF0dXNlcyA9IFN0YXR1c1JlZ2lzdHJ5LmdldEluc3RhbmNlKCkuZmluZFVua25vd25TdGF0dXNlcyhhbGxTdGF0dXNlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmtub3duU3RhdHVzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5rbm93blN0YXR1c2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0YXR1c1NldHRpbmdzLmFkZFN0YXR1cyhzdGF0dXNTZXR0aW5ncy5jdXN0b21TdGF0dXNlcywgcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZEFsbFVua25vd25TdGF0dXNlcy5pbmZvRWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gJ1Jlc2V0IEN1c3RvbSBTdGF0dXMgVHlwZXMgdG8gRGVmYXVsdHMnIGJ1dHRvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICBjb25zdCBjbGVhckN1c3RvbVN0YXR1c2VzID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnUmVzZXQgQ3VzdG9tIFN0YXR1cyBUeXBlcyB0byBEZWZhdWx0cycpXG4gICAgICAgICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzU2V0dGluZ3MucmVzZXRBbGxDdXN0b21TdGF0dXNlcyhzdGF0dXNTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJDdXN0b21TdGF0dXNlcy5pbmZvRWwucmVtb3ZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcm93IHRvIHNlZSBhbmQgbW9kaWZ5IHNldHRpbmdzIGZvciBhIHNpbmdsZSB0YXNrIHN0YXR1cyB0eXBlLlxuICogQHBhcmFtIGNvbnRhaW5lckVsXG4gKiBAcGFyYW0gc3RhdHVzVHlwZSAtIFRoZSBzdGF0dXMgdHlwZSB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gc3RhdHVzZXMgLSBUaGUgbGlzdCBvZiBzdGF0dXNlcyB0aGF0IHN0YXR1c1R5cGUgaXMgc3RvcmVkIGluLlxuICogQHBhcmFtIHN0YXR1c1NldHRpbmdzIC0gQWxsIHRoZSBzdGF0dXMgdHlwZXMgYWxyZWFkeSBpbiB0aGUgdXNlcidzIHNldHRpbmdzLCBFWENFUFQgdGhlIHN0YW5kYXJkIG9uZXMuXG4gKiBAcGFyYW0gc2V0dGluZ3NcbiAqIEBwYXJhbSBwbHVnaW5cbiAqIEBwYXJhbSBpc0NvcmVTdGF0dXMgLSB3aGV0aGVyIHRoZSBzdGF0dXMgaXMgYSBjb3JlIHN0YXR1c1xuICovXG5mdW5jdGlvbiBjcmVhdGVSb3dGb3JUYXNrU3RhdHVzKFxuICAgIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcbiAgICBzdGF0dXNUeXBlOiBTdGF0dXNDb25maWd1cmF0aW9uLFxuICAgIHN0YXR1c2VzOiBTdGF0dXNDb25maWd1cmF0aW9uW10sXG4gICAgc3RhdHVzU2V0dGluZ3M6IFN0YXR1c1NldHRpbmdzLFxuICAgIHNldHRpbmdzOiBTZXR0aW5nc1RhYixcbiAgICBwbHVnaW46IFRhc2tzUGx1Z2luLFxuICAgIGlzQ29yZVN0YXR1czogYm9vbGVhbixcbikge1xuICAgIC8vY29uc3QgdGFza1N0YXR1c0RpdiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnKTtcblxuICAgIGNvbnN0IHRhc2tTdGF0dXNQcmV2aWV3ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3ByZScpO1xuICAgIHRhc2tTdGF0dXNQcmV2aWV3LmFkZENsYXNzKCdyb3ctZm9yLXN0YXR1cycpO1xuICAgIHRhc2tTdGF0dXNQcmV2aWV3LnRleHRDb250ZW50ID0gbmV3IFN0YXR1cyhzdGF0dXNUeXBlKS5wcmV2aWV3VGV4dCgpO1xuXG4gICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKTtcblxuICAgIHNldHRpbmcuaW5mb0VsLnJlcGxhY2VXaXRoKHRhc2tTdGF0dXNQcmV2aWV3KTtcblxuICAgIGlmICghaXNDb3JlU3RhdHVzKSB7XG4gICAgICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oKGV4dHJhKSA9PiB7XG4gICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdjcm9zcycpXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0RlbGV0ZScpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU3RhdHVzU2V0dGluZ3MuZGVsZXRlU3RhdHVzKHN0YXR1c2VzLCBzdGF0dXNUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQW5kU2F2ZVN0YXR1c1NldHRpbmdzKHN0YXR1c1NldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbigoZXh0cmEpID0+IHtcbiAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIC5zZXRJY29uKCdwZW5jaWwnKVxuICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0VkaXQnKVxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEN1c3RvbVN0YXR1c01vZGFsKHBsdWdpbiwgc3RhdHVzVHlwZSwgaXNDb3JlU3RhdHVzKTtcblxuICAgICAgICAgICAgICAgIG1vZGFsLm9uQ2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RhbC5zYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFN0YXR1c1NldHRpbmdzLnJlcGxhY2VTdGF0dXMoc3RhdHVzZXMsIHN0YXR1c1R5cGUsIG1vZGFsLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2RhbC5vcGVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNldHRpbmcuaW5mb0VsLnJlbW92ZSgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRDdXN0b21TdGF0ZXNUb1NldHRpbmdzKFxuICAgIHN1cHBvcnRlZFN0YXR1c2VzOiBTdGF0dXNDb2xsZWN0aW9uLFxuICAgIHN0YXR1c1NldHRpbmdzOiBTdGF0dXNTZXR0aW5ncyxcbiAgICBzZXR0aW5nczogU2V0dGluZ3NUYWIsXG4pIHtcbiAgICBjb25zdCBub3RpY2VzID0gU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb24oc3RhdHVzU2V0dGluZ3MsIHN1cHBvcnRlZFN0YXR1c2VzKTtcblxuICAgIG5vdGljZXMuZm9yRWFjaCgobm90aWNlKSA9PiB7XG4gICAgICAgIG5ldyBOb3RpY2Uobm90aWNlKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IHVwZGF0ZUFuZFNhdmVTdGF0dXNTZXR0aW5ncyhzdGF0dXNTZXR0aW5ncywgc2V0dGluZ3MpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVBbmRTYXZlU3RhdHVzU2V0dGluZ3Moc3RhdHVzVHlwZXM6IFN0YXR1c1NldHRpbmdzLCBzZXR0aW5nczogU2V0dGluZ3NUYWIpIHtcbiAgICB1cGRhdGVTZXR0aW5ncyh7XG4gICAgICAgIHN0YXR1c1NldHRpbmdzOiBzdGF0dXNUeXBlcyxcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIHN0YXR1c2VzLlxuICAgIC8vIFRoaXMgc2F2ZXMgdGhlIHVzZXIgZnJvbSBoYXZpbmcgdG8gcmVzdGFydCBPYnNpZGlhbiBpbiBvcmRlciB0byBhcHBseSB0aGUgY2hhbmdlZCBzdGF0dXMoZXMpLlxuICAgIFN0YXR1c1NldHRpbmdzLmFwcGx5VG9TdGF0dXNSZWdpc3RyeShzdGF0dXNUeXBlcywgU3RhdHVzUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKSk7XG5cbiAgICBhd2FpdCBzZXR0aW5ncy5zYXZlU2V0dGluZ3ModHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VNdWx0aWxpbmVUZXh0U2V0dGluZyhzZXR0aW5nOiBTZXR0aW5nKSB7XG4gICAgY29uc3QgeyBzZXR0aW5nRWwsIGluZm9FbCwgY29udHJvbEVsIH0gPSBzZXR0aW5nO1xuICAgIGNvbnN0IHRleHRFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gY29udHJvbEVsLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG5cbiAgICAvLyBOb3QgYSBzZXR0aW5nIHdpdGggYSB0ZXh0IGZpZWxkXG4gICAgaWYgKHRleHRFbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0dGluZ0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGluZm9FbC5zdHlsZS5tYXJnaW5SaWdodCA9ICcwcHgnO1xuICAgIHRleHRFbC5zdHlsZS5taW5XaWR0aCA9ICctd2Via2l0LWZpbGwtYXZhaWxhYmxlJztcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBBbnVQcHVjY2luIHRoZW1lLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0FudWJpc05la2hldC9BbnVQcHVjY2lufVxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVwcHVjY2luU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICBbJyAnLCAnVW5jaGVja2VkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3gnLCAnQ2hlY2tlZCcsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWyc+JywgJ1Jlc2NoZWR1bGVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJzwnLCAnU2NoZWR1bGVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyEnLCAnSW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJy0nLCAnQ2FuY2VsbGVkJywgJyAnLCAnQ0FOQ0VMTEVEJ10sXG4gICAgICAgIFsnLycsICdJbiBQcm9ncmVzcycsICd4JywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICAgIFsnPycsICdRdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycqJywgJ1N0YXInLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnbicsICdOb3RlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2wnLCAnTG9jYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnaScsICdJbmZvcm1hdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydJJywgJ0lkZWEnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUycsICdBbW91bnQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsncCcsICdQcm8nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYycsICdDb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYicsICdCb29rbWFyaycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydcIicsICdRdW90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycwJywgJ1NwZWVjaCBidWJibGUgMCcsICcwJywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnMScsICdTcGVlY2ggYnViYmxlIDEnLCAnMScsICdOT05fVEFTSyddLFxuICAgICAgICBbJzInLCAnU3BlZWNoIGJ1YmJsZSAyJywgJzInLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWyczJywgJ1NwZWVjaCBidWJibGUgMycsICczJywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnNCcsICdTcGVlY2ggYnViYmxlIDQnLCAnNCcsICdOT05fVEFTSyddLFxuICAgICAgICBbJzUnLCAnU3BlZWNoIGJ1YmJsZSA1JywgJzUnLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWyc2JywgJ1NwZWVjaCBidWJibGUgNicsICc2JywgJ05PTl9UQVNLJ10sXG4gICAgICAgIFsnNycsICdTcGVlY2ggYnViYmxlIDcnLCAnNycsICdOT05fVEFTSyddLFxuICAgICAgICBbJzgnLCAnU3BlZWNoIGJ1YmJsZSA4JywgJzgnLCAnTk9OX1RBU0snXSxcbiAgICAgICAgWyc5JywgJ1NwZWVjaCBidWJibGUgOScsICc5JywgJ05PTl9UQVNLJ10sXG4gICAgXTtcbiAgICByZXR1cm4genp6O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU3RhdHVzQ29sbGVjdGlvbiB9IGZyb20gJy4uLy4uL1N0YXR1c0NvbGxlY3Rpb24nO1xuXG4vKipcbiAqIFN0YXR1cyBzdXBwb3J0ZWQgYnkgdGhlIEF1cmEgdGhlbWUuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXNod2luamFkaGF2ODE4L29ic2lkaWFuLWF1cmF9XG4gKiBAc2VlIHtAbGluayBTdGF0dXNTZXR0aW5ncy5idWxrQWRkU3RhdHVzQ29sbGVjdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1cmFTdXBwb3J0ZWRTdGF0dXNlcygpIHtcbiAgICBjb25zdCB6eno6IFN0YXR1c0NvbGxlY3Rpb24gPSBbXG4gICAgICAgIFsnICcsICdpbmNvbXBsZXRlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3gnLCAnY29tcGxldGUgLyBkb25lJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJy0nLCAnY2FuY2VsbGVkJywgJyAnLCAnQ0FOQ0VMTEVEJ10sXG4gICAgICAgIFsnPicsICdkZWZlcnJlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycvJywgJ2luIHByb2dyZXNzLCBvciBoYWxmLWRvbmUnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJyEnLCAnSW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJz8nLCAncXVlc3Rpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUicsICdyZXZpZXcnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnKycsICdJbmJveCAvIHRhc2sgdGhhdCBzaG91bGQgYmUgcHJvY2Vzc2VkIGxhdGVyJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnYm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnQicsICdicmFpbnN0b3JtJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0QnLCAnZGVmZXJyZWQgb3Igc2NoZWR1bGVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0knLCAnSW5mbycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydpJywgJ2lkZWEnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnTicsICdub3RlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1EnLCAncXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnVycsICd3aW4gLyBzdWNjZXNzIC8gcmV3YXJkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1AnLCAncHJvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0MnLCAnY29uJywgJ3gnLCAnVE9ETyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBFYnVsbGllbnR3b3JrcyB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lYnVsbGllbnQvb2JzaWRpYW4tdGhlbWUtZWJ1bGxpZW50d29ya3N9XG4gKiBAc2VlIHtAbGluayBTdGF0dXNTZXR0aW5ncy5idWxrQWRkU3RhdHVzQ29sbGVjdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVidWxsaWVudHdvcmtzU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICBbJyAnLCAnVW5jaGVja2VkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3gnLCAnQ2hlY2tlZCcsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWyctJywgJ0NhbmNlbGxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJy8nLCAnSW4gUHJvZ3Jlc3MnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJz4nLCAnRGVmZXJyZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnIScsICdJbXBvcnRhbnQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPycsICdRdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydyJywgJ1JldmlldycsICd4JywgJ1RPRE8nXSxcbiAgICBdO1xuICAgIHJldHVybiB6eno7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGF0dXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vLi4vU3RhdHVzQ29sbGVjdGlvbic7XG5cbi8qKlxuICogU3RhdHVzIHN1cHBvcnRlZCBieSB0aGUgSVRTIHRoZW1lLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1NsUnZiL09ic2lkaWFuLS1JVFMtVGhlbWV9XG4gKiBWYWx1ZXMgcmVjb2duaXNlZCBieSBUYXNrcyBhcmUgZXhjbHVkZWQuXG4gKiBAc2VlIHtAbGluayBTdGF0dXNTZXR0aW5ncy5idWxrQWRkU3RhdHVzQ29sbGVjdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGl0c1N1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ1VuY2hlY2tlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd4JywgJ1JlZ3VsYXInLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnWCcsICdDaGVja2VkJywgJyAnLCAnRE9ORSddLFxuICAgICAgICBbJy0nLCAnRHJvcHBlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJz4nLCAnRm9yd2FyZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydEJywgJ0RhdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPycsICdRdWVzdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycvJywgJ0hhbGYgRG9uZScsICd4JywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICAgIFsnKycsICdBZGQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnUicsICdSZXNlYXJjaCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ0ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydpJywgJ0lkZWEnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnQicsICdCcmFpbnN0b3JtJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1AnLCAnUHJvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0MnLCAnQ29uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1EnLCAnUXVvdGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnTicsICdOb3RlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnQm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSScsICdJbmZvcm1hdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydwJywgJ1BhcmFwaHJhc2UnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnTCcsICdMb2NhdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydFJywgJ0V4YW1wbGUnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnQScsICdBbnN3ZXInLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsncicsICdSZXdhcmQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnYycsICdDaG9pY2UnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZCcsICdEb2luZycsICd4JywgJ0lOX1BST0dSRVNTJ10sXG4gICAgICAgIFsnVCcsICdUaW1lJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0AnLCAnQ2hhcmFjdGVyIC8gUGVyc29uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3QnLCAnVGFsaycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydPJywgJ091dGxpbmUgLyBQbG90JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ34nLCAnQ29uZmxpY3QnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnVycsICdXb3JsZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydmJywgJ0NsdWUgLyBGaW5kJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ0YnLCAnRm9yZXNoYWRvdycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydIJywgJ0Zhdm9yaXRlIC8gSGVhbHRoJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyYnLCAnU3ltYm9saXNtJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3MnLCAnU2VjcmV0JywgJ3gnLCAnVE9ETyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBMWVQgTW9kZSB0aGVtZS4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWNrbWlsby9MWVQtTW9kZX1cbiAqIEBzZWUge0BsaW5rIFN0YXR1c1NldHRpbmdzLmJ1bGtBZGRTdGF0dXNDb2xsZWN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbHl0TW9kZVN1cHBvcnRlZFN0YXR1c2VzKCkge1xuICAgIGNvbnN0IHp6ejogU3RhdHVzQ29sbGVjdGlvbiA9IFtcbiAgICAgICAgWycgJywgJ1VuY2hlY2tlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyd4JywgJ0NoZWNrZWQnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnPicsICdSZXNjaGVkdWxlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc8JywgJ1NjaGVkdWxlZCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWychJywgJ0ltcG9ydGFudCcsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyctJywgJ0NhbmNlbGxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJy8nLCAnSW4gUHJvZ3Jlc3MnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJz8nLCAnUXVlc3Rpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnKicsICdTdGFyJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ24nLCAnTm90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydsJywgJ0xvY2F0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2knLCAnSW5mb3JtYXRpb24nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSScsICdJZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ1MnLCAnQW1vdW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3AnLCAnUHJvJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2MnLCAnQ29uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnQm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZicsICdGaXJlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2snLCAnS2V5JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3cnLCAnV2luJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3UnLCAnVXAnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZCcsICdEb3duJywgJ3gnLCAnVE9ETyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBNaW5pbWFsIHRoZW1lLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tlcGFuby9vYnNpZGlhbi1taW5pbWFsfVxuICogVmFsdWVzIHJlY29nbmlzZWQgYnkgVGFza3MgYXJlIGV4Y2x1ZGVkLlxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW5pbWFsU3VwcG9ydGVkU3RhdHVzZXMoKSB7XG4gICAgY29uc3Qgenp6OiBTdGF0dXNDb2xsZWN0aW9uID0gW1xuICAgICAgICBbJyAnLCAndG8tZG8nLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnLycsICdpbmNvbXBsZXRlJywgJ3gnLCAnSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgWyd4JywgJ2RvbmUnLCAnICcsICdET05FJ10sXG4gICAgICAgIFsnLScsICdjYW5jZWxlZCcsICcgJywgJ0NBTkNFTExFRCddLFxuICAgICAgICBbJz4nLCAnZm9yd2FyZGVkJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJzwnLCAnc2NoZWR1bGluZycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWyc/JywgJ3F1ZXN0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyEnLCAnaW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyonLCAnc3RhcicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydcIicsICdxdW90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydsJywgJ2xvY2F0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnYm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnaScsICdpbmZvcm1hdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydTJywgJ3NhdmluZ3MnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSScsICdpZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3AnLCAncHJvcycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydjJywgJ2NvbnMnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZicsICdmaXJlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2snLCAna2V5JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3cnLCAnd2luJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3UnLCAndXAnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZCcsICdkb3duJywgJ3gnLCAnVE9ETyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi9TdGF0dXNDb2xsZWN0aW9uJztcblxuLyoqXG4gKiBTdGF0dXMgc3VwcG9ydGVkIGJ5IHRoZSBUaGluZ3MgdGhlbWUuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY29saW5lY2tlcnQvb2JzaWRpYW4tdGhpbmdzfVxuICogQHNlZSB7QGxpbmsgU3RhdHVzU2V0dGluZ3MuYnVsa0FkZFN0YXR1c0NvbGxlY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aGluZ3NTdXBwb3J0ZWRTdGF0dXNlcygpIHtcbiAgICBjb25zdCB6eno6IFN0YXR1c0NvbGxlY3Rpb24gPSBbXG4gICAgICAgIC8vIEJhc2ljXG4gICAgICAgIFsnICcsICd0by1kbycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWycvJywgJ2luY29tcGxldGUnLCAneCcsICdJTl9QUk9HUkVTUyddLFxuICAgICAgICBbJ3gnLCAnZG9uZScsICcgJywgJ0RPTkUnXSxcbiAgICAgICAgWyctJywgJ2NhbmNlbGVkJywgJyAnLCAnQ0FOQ0VMTEVEJ10sXG4gICAgICAgIFsnPicsICdmb3J3YXJkZWQnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnPCcsICdzY2hlZHVsaW5nJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICAvLyBFeHRyYXNcbiAgICAgICAgWyc/JywgJ3F1ZXN0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyEnLCAnaW1wb3J0YW50JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJyonLCAnc3RhcicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydcIicsICdxdW90ZScsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydsJywgJ2xvY2F0aW9uJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2InLCAnYm9va21hcmsnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnaScsICdpbmZvcm1hdGlvbicsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydTJywgJ3NhdmluZ3MnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnSScsICdpZGVhJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3AnLCAncHJvcycsICd4JywgJ1RPRE8nXSxcbiAgICAgICAgWydjJywgJ2NvbnMnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZicsICdmaXJlJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ2snLCAna2V5JywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3cnLCAnd2luJywgJ3gnLCAnVE9ETyddLFxuICAgICAgICBbJ3UnLCAndXAnLCAneCcsICdUT0RPJ10sXG4gICAgICAgIFsnZCcsICdkb3duJywgJ3gnLCAnVE9ETyddLFxuICAgIF07XG4gICAgcmV0dXJuIHp6ejtcbn1cbiIsICJpbXBvcnQgeyBNb2RhbCwgTm90aWNlLCBTZXR0aW5nLCBUZXh0Q29tcG9uZW50IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdGF0dXNDb25maWd1cmF0aW9uLCBTdGF0dXNUeXBlIH0gZnJvbSAnLi4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBTdGF0dXNWYWxpZGF0b3IgfSBmcm9tICcuLi9TdGF0dXNWYWxpZGF0b3InO1xuaW1wb3J0IHsgU3RhdHVzIH0gZnJvbSAnLi4vU3RhdHVzJztcblxuY29uc3QgdmFsaWRhdG9yID0gbmV3IFN0YXR1c1ZhbGlkYXRvcigpO1xuXG5leHBvcnQgY2xhc3MgQ3VzdG9tU3RhdHVzTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgc3RhdHVzU3ltYm9sOiBzdHJpbmc7XG4gICAgc3RhdHVzTmFtZTogc3RyaW5nO1xuICAgIHN0YXR1c05leHRTeW1ib2w6IHN0cmluZztcbiAgICBzdGF0dXNBdmFpbGFibGVBc0NvbW1hbmQ6IGJvb2xlYW47XG4gICAgdHlwZTogU3RhdHVzVHlwZTtcblxuICAgIHNhdmVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgZXJyb3I6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGlzQ29yZVN0YXR1czogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcGx1Z2luOiBQbHVnaW4sIHN0YXR1c1R5cGU6IFN0YXR1c0NvbmZpZ3VyYXRpb24sIGlzQ29yZVN0YXR1czogYm9vbGVhbikge1xuICAgICAgICBzdXBlcihwbHVnaW4uYXBwKTtcbiAgICAgICAgdGhpcy5zdGF0dXNTeW1ib2wgPSBzdGF0dXNUeXBlLnN5bWJvbDtcbiAgICAgICAgdGhpcy5zdGF0dXNOYW1lID0gc3RhdHVzVHlwZS5uYW1lO1xuICAgICAgICB0aGlzLnN0YXR1c05leHRTeW1ib2wgPSBzdGF0dXNUeXBlLm5leHRTdGF0dXNTeW1ib2w7XG4gICAgICAgIHRoaXMuc3RhdHVzQXZhaWxhYmxlQXNDb21tYW5kID0gc3RhdHVzVHlwZS5hdmFpbGFibGVBc0NvbW1hbmQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHN0YXR1c1R5cGUudHlwZTtcbiAgICAgICAgdGhpcy5pc0NvcmVTdGF0dXMgPSBpc0NvcmVTdGF0dXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEge0BsaW5rIFN0YXR1c0NvbmZpZ3VyYXRpb259IGZyb20gdGhlIG1vZGFsJ3MgY29udGVudHNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdHVzQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0dXNDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNTeW1ib2wsXG4gICAgICAgICAgICB0aGlzLnN0YXR1c05hbWUsXG4gICAgICAgICAgICB0aGlzLnN0YXR1c05leHRTeW1ib2wsXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0F2YWlsYWJsZUFzQ29tbWFuZCxcbiAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcblxuICAgICAgICBjb25zdCBzZXR0aW5nRGl2ID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xuICAgICAgICAvL2NvbnN0IHRpdGxlID0gdGhpcy50aXRsZSA/PyAnLi4uJztcblxuICAgICAgICBsZXQgc3RhdHVzU3ltYm9sVGV4dDogVGV4dENvbXBvbmVudDtcbiAgICAgICAgbmV3IFNldHRpbmcoc2V0dGluZ0RpdilcbiAgICAgICAgICAgIC5zZXROYW1lKCdUYXNrIFN0YXR1cyBTeW1ib2wnKVxuICAgICAgICAgICAgLnNldERlc2MoXG4gICAgICAgICAgICAgICAgJ1RoaXMgaXMgdGhlIGNoYXJhY3RlciBiZXR3ZWVuIHRoZSBzcXVhcmUgYnJhY2VzLiAoSXQgY2FuIG9ubHkgYmUgZWRpdGVkIGZvciBDdXN0b20gc3RhdHVzZXMsIGFuZCBub3QgQ29yZSBzdGF0dXNlcy4pJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3ltYm9sVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLnN0YXR1c1N5bWJvbCkub25DaGFuZ2UoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNTeW1ib2wgPSB2O1xuICAgICAgICAgICAgICAgICAgICBDdXN0b21TdGF0dXNNb2RhbC5zZXRWYWxpZCh0ZXh0LCB2YWxpZGF0b3IudmFsaWRhdGVTeW1ib2wodGhpcy5zdGF0dXNDb25maWd1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc2V0RGlzYWJsZWQodGhpcy5pc0NvcmVTdGF0dXMpXG4gICAgICAgICAgICAudGhlbigoX3NldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTaG93IGFueSBlcnJvciBpZiB0aGUgaW5pdGlhbCB2YWx1ZSBsb2FkZWQgaXMgaW5jb3JyZWN0LlxuICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHN0YXR1c1N5bWJvbFRleHQsIHZhbGlkYXRvci52YWxpZGF0ZVN5bWJvbCh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHN0YXR1c05hbWVUZXh0OiBUZXh0Q29tcG9uZW50O1xuICAgICAgICBuZXcgU2V0dGluZyhzZXR0aW5nRGl2KVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rhc2sgU3RhdHVzIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoaXMgaXMgdGhlIGZyaWVuZGx5IG5hbWUgb2YgdGhlIHRhc2sgc3RhdHVzLicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c05hbWVUZXh0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMuc3RhdHVzTmFtZSkub25DaGFuZ2UoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNOYW1lID0gdjtcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tU3RhdHVzTW9kYWwuc2V0VmFsaWQodGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlTmFtZSh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChfc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKHN0YXR1c05hbWVUZXh0LCB2YWxpZGF0b3IudmFsaWRhdGVOYW1lKHRoaXMuc3RhdHVzQ29uZmlndXJhdGlvbigpKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgc3RhdHVzTmV4dFN5bWJvbFRleHQ6IFRleHRDb21wb25lbnQ7XG4gICAgICAgIG5ldyBTZXR0aW5nKHNldHRpbmdEaXYpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVGFzayBOZXh0IFN0YXR1cyBTeW1ib2wnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1doZW4gY2xpY2tlZCBvbiB0aGlzIGlzIHRoZSBzeW1ib2wgdGhhdCBzaG91bGQgYmUgdXNlZCBuZXh0LicpXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c05leHRTeW1ib2xUZXh0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMuc3RhdHVzTmV4dFN5bWJvbCkub25DaGFuZ2UoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNOZXh0U3ltYm9sID0gdjtcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tU3RhdHVzTW9kYWwuc2V0VmFsaWQodGV4dCwgdmFsaWRhdG9yLnZhbGlkYXRlTmV4dFN5bWJvbCh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChfc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkKFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNOZXh0U3ltYm9sVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLnZhbGlkYXRlTmV4dFN5bWJvbCh0aGlzLnN0YXR1c0NvbmZpZ3VyYXRpb24oKSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKHNldHRpbmdEaXYpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVGFzayBTdGF0dXMgVHlwZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnQ29udHJvbCBob3cgdGhlIHN0YXR1cyBiZWhhdmVzIGZvciBzZWFyY2hpbmcgYW5kIHRvZ2dsaW5nLicpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c1R5cGUuVE9ETyxcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzVHlwZS5JTl9QUk9HUkVTUyxcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzVHlwZS5ET05FLFxuICAgICAgICAgICAgICAgICAgICBTdGF0dXNUeXBlLkNBTkNFTExFRCxcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzVHlwZS5OT05fVEFTSyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHR5cGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKHMsIHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKHRoaXMudHlwZSkub25DaGFuZ2UoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gU3RhdHVzLmdldFR5cGVGcm9tU3RhdHVzVHlwZVN0cmluZyh2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChTdGF0dXMudGFza3NQbHVnaW5DYW5DcmVhdGVDb21tYW5kc0ZvclN0YXR1c2VzKCkpIHtcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHNldHRpbmdEaXYpXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ0F2YWlsYWJsZSBhcyBjb21tYW5kJylcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICAgICAgJ0lmIGVuYWJsZWQgdGhpcyBzdGF0dXMgd2lsbCBiZSBhdmFpbGFibGUgYXMgYSBjb21tYW5kIHNvIHlvdSBjYW4gYXNzaWduIGEgaG90a2V5IGFuZCB0b2dnbGUgdGhlIHN0YXR1cyB1c2luZyBpdC4nLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc3RhdHVzQXZhaWxhYmxlQXNDb21tYW5kKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQXZhaWxhYmxlQXNDb21tYW5kID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9vdGVyRWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XG4gICAgICAgIGNvbnN0IGZvb3RlckJ1dHRvbnMgPSBuZXcgU2V0dGluZyhmb290ZXJFbCk7XG4gICAgICAgIGZvb3RlckJ1dHRvbnMuYWRkQnV0dG9uKChiKSA9PiB7XG4gICAgICAgICAgICBiLnNldFRvb2x0aXAoJ1NhdmUnKVxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdjaGVja21hcmsnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdG9yLnZhbGlkYXRlKHRoaXMuc3RhdHVzQ29uZmlndXJhdGlvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JzLmpvaW4oJ1xcbicpICsgJ1xcblxcbicgKyAnRml4IGVycm9ycyBiZWZvcmUgc2F2aW5nLic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0pO1xuICAgICAgICBmb290ZXJCdXR0b25zLmFkZEV4dHJhQnV0dG9uKChiKSA9PiB7XG4gICAgICAgICAgICBiLnNldEljb24oJ2Nyb3NzJylcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnQ2FuY2VsJylcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZVRpdGxlKGFkbW9uaXRpb25QcmV2aWV3OiBIVE1MRWxlbWVudCwgdGl0bGU6IHN0cmluZykge1xuICAgIC8vICAgICBsZXQgdGl0bGVTcGFuID0gYWRtb25pdGlvblByZXZpZXcucXVlcnlTZWxlY3RvcignLmFkbW9uaXRpb24tdGl0bGUtY29udGVudCcpO1xuICAgIC8vICAgICBsZXQgaWNvbkVsID0gYWRtb25pdGlvblByZXZpZXcucXVlcnlTZWxlY3RvcignLmFkbW9uaXRpb24tdGl0bGUtaWNvbicpO1xuICAgIC8vICAgICB0aXRsZVNwYW4udGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICAvLyAgICAgdGl0bGVTcGFuLnByZXBlbmQoaWNvbkVsKTtcbiAgICAvLyB9XG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0VmFsaWRhdGlvbkVycm9yKHRleHRJbnB1dDogVGV4dENvbXBvbmVudCkge1xuICAgICAgICB0ZXh0SW5wdXQuaW5wdXRFbC5hZGRDbGFzcygndGFza3Mtc2V0dGluZ3MtaXMtaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVWYWxpZGF0aW9uRXJyb3IodGV4dElucHV0OiBUZXh0Q29tcG9uZW50KSB7XG4gICAgICAgIHRleHRJbnB1dC5pbnB1dEVsLnJlbW92ZUNsYXNzKCd0YXNrcy1zZXR0aW5ncy1pcy1pbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0VmFsaWQodGV4dDogVGV4dENvbXBvbmVudCwgbWVzc2FnZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gbWVzc2FnZXMubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnJlbW92ZVZhbGlkYXRpb25FcnJvcih0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEN1c3RvbVN0YXR1c01vZGFsLnNldFZhbGlkYXRpb25FcnJvcih0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFN0YXR1c0NvbmZpZ3VyYXRpb24gfSBmcm9tICcuL1N0YXR1c0NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgU3RhdHVzVHlwZSB9IGZyb20gJy4vU3RhdHVzQ29uZmlndXJhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c0NvbGxlY3Rpb25FbnRyeSB9IGZyb20gJy4vU3RhdHVzQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tICcuL1N0YXR1cyc7XG5pbXBvcnQgeyBTdGF0dXNSZWdpc3RyeSB9IGZyb20gJy4vU3RhdHVzUmVnaXN0cnknO1xuXG5leHBvcnQgY2xhc3MgU3RhdHVzVmFsaWRhdG9yIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZGF0ZSBpbiB0aGlzIG9iamVjdCBpcyB2YWxpZCwgYW5kIHJldHVybiBlcnJvciBtZXNzYWdlKHMpIGZvciBkaXNwbGF5IGlmIG5vdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsaWRhdGUoc3RhdHVzQ29uZmlndXJhdGlvbjogU3RhdHVzQ29uZmlndXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIE1lc3NhZ2VzIGFyZSBhZGRlZCBpbiB0aGUgb3JkZXIgZmllbGRzIGFyZSBzaG93biB3aGVuIGVkaXRpbmcgc3RhdHVzZXMuXG4gICAgICAgIGVycm9ycy5wdXNoKC4uLnRoaXMudmFsaWRhdGVTeW1ib2woc3RhdHVzQ29uZmlndXJhdGlvbikpO1xuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlTmFtZShzdGF0dXNDb25maWd1cmF0aW9uKSk7XG4gICAgICAgIGVycm9ycy5wdXNoKC4uLnRoaXMudmFsaWRhdGVOZXh0U3ltYm9sKHN0YXR1c0NvbmZpZ3VyYXRpb24pKTtcblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGRhdGEgaW4gU3RhdHVzQ29sbGVjdGlvbiBsaXN0cy4gVGhlc2UgYXJlIHRoZSBkZXNjcmlwdGlvbnMgb2Ygc3RhdHVzZXMgaW4gdmFyaW91cyB0aGVtZXMsXG4gICAgICogdGhhdCBhcmUgaW1wb3J0ZWQgdmlhIG9uZS1jbGljayBidXR0b25zIGluIHRoZSBDdXN0b20gU3RhdHVzIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogVGhpcyBkb2VzIGEgZmV3IGNoZWNrcyB0byBndWFyZCBhZ2FpbnN0IGh1bWFuIGVycm9yIHdoZW4gY3JlYXRpbmcgdGhlIGxpc3RzLCBhbmQgdGhlblxuICAgICAqIGFsc28gY2FsbHMge0BsaW5rIHZhbGlkYXRlfSB0b28uXG4gICAgICogQHBhcmFtIGVudHJ5XG4gICAgICovXG4gICAgcHVibGljIHZhbGlkYXRlU3RhdHVzQ29sbGVjdGlvbkVudHJ5KGVudHJ5OiBTdGF0dXNDb2xsZWN0aW9uRW50cnkpIHtcbiAgICAgICAgY29uc3QgW3N5bWJvbCwgX25hbWUsIG5leHRTdGF0dXNTeW1ib2wsIHR5cGVBc1N0cmluZ10gPSBlbnRyeTtcblxuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgY2FuIG9ubHkgYmUgZG9uZSBvbiB0aGUgcmF3IGRhdGEuXG4gICAgICAgIC8vIFN0YXR1cy5jcmVhdGVGcm9tSW1wb3J0ZWRWYWx1ZSgpIGZhbGxzIGJhY2sgdG8gU3RhdHVzVHlwZS5UT0RPIGlmIHRoZVxuICAgICAgICAvLyB0eXBlIHN0cmluZyBpcyBub3QgcmVjb2duaXNlZCwgc28gd2UgaGF2ZSB0byB0ZXN0IHRoYXQgZmlyc3QuXG4gICAgICAgIGVycm9ycy5wdXNoKC4uLnRoaXMudmFsaWRhdGVUeXBlKHR5cGVBc1N0cmluZykpO1xuXG4gICAgICAgIC8vIEZvciB1c2VycywgaXQgaXMgdmFsaWQgdG8gaGF2ZSBhIHN0YXR1cyB0aGF0IHRvZ2dsZXMgdG8gaXRzZWxmLlxuICAgICAgICAvLyBGb3IgaW1wb3J0ZWQgZGF0YSBmb3IgdGhlbWVzLCBpdCBzZWVtcyB3b3J0aCBwcmV2ZW50aW5nIHRoYXQgc2l0dWF0aW9uLFxuICAgICAgICAvLyB0byBndWFyZCBhZ2FpbnN0IGh1bWFuIGVycm9yIHdoZW4gc2V0dGluZyB1cCB0aGUgc3RhdHVzIGNvbGxlY3Rpb25zLlxuICAgICAgICAvLyBCdXQgbWFrZSBhbiBleGNlcHRpb24gZm9yIGFueSBub24tdGFza3MgaW4gaW1wb3J0ZWQgZGF0YS5cbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gbmV4dFN0YXR1c1N5bWJvbCAmJiB0eXBlQXNTdHJpbmcgIT09ICdOT05fVEFTSycpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGBTdGF0dXMgc3ltYm9sICcke3N5bWJvbH0nIHRvZ2dsZXMgdG8gaXRzZWxmYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcmF3IGRhdGEgd2FzIG5vdCB2YWxpZCwgcmV0dXJuIG5vdywgdG8gYXZvaWQgcG90ZW50aWFsbHkgbWlzbGVhZGluZ1xuICAgICAgICAvLyBlcnJvcnMgZnJvbSBsYXRlciBjaGVja3MuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBTdGF0dXMuY3JlYXRlRnJvbUltcG9ydGVkVmFsdWUoZW50cnkpLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGVycm9ycy5wdXNoKC4uLnRoaXMudmFsaWRhdGVTeW1ib2xUeXBlQ29udmVudGlvbnMoY29uZmlndXJhdGlvbikpO1xuICAgICAgICBlcnJvcnMucHVzaCguLi50aGlzLnZhbGlkYXRlKGNvbmZpZ3VyYXRpb24pKTtcblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZVN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gU3RhdHVzVmFsaWRhdG9yLnZhbGlkYXRlT25lU3ltYm9sKHN0YXR1c0NvbmZpZ3VyYXRpb24uc3ltYm9sLCAnVGFzayBTdGF0dXMgU3ltYm9sJyk7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbGlkYXRlTmV4dFN5bWJvbChzdGF0dXNDb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gU3RhdHVzVmFsaWRhdG9yLnZhbGlkYXRlT25lU3ltYm9sKHN0YXR1c0NvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbCwgJ1Rhc2sgTmV4dCBTdGF0dXMgU3ltYm9sJyk7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbGlkYXRlTmFtZShzdGF0dXNDb25maWd1cmF0aW9uOiBTdGF0dXNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKHN0YXR1c0NvbmZpZ3VyYXRpb24ubmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdUYXNrIFN0YXR1cyBOYW1lIGNhbm5vdCBiZSBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIHB1YmxpYyB2YWxpZGF0ZVR5cGUoc3ltYm9sTmFtZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBzdGF0dXNUeXBlRWxlbWVudCA9IFN0YXR1c1R5cGVbc3ltYm9sTmFtZSBhcyBrZXlvZiB0eXBlb2YgU3RhdHVzVHlwZV07XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKCFzdGF0dXNUeXBlRWxlbWVudCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYFN0YXR1cyBUeXBlIFwiJHtzeW1ib2xOYW1lfVwiIGlzIG5vdCBhIHZhbGlkIHR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzVHlwZUVsZW1lbnQgPT0gU3RhdHVzVHlwZS5FTVBUWSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goJ1N0YXR1cyBUeXBlIFwiRU1QVFlcIiBpcyBub3QgcGVybWl0dGVkIGluIHVzZXIgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG4gICAgcHVibGljIHZhbGlkYXRlU3ltYm9sVHlwZUNvbnZlbnRpb25zKGNvbmZpZ3VyYXRpb246IFN0YXR1c0NvbmZpZ3VyYXRpb24pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBjb25zdCBzeW1ib2wgPSBjb25maWd1cmF0aW9uLnN5bWJvbDtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBuZXcgU3RhdHVzUmVnaXN0cnkoKTtcbiAgICAgICAgY29uc3Qgc3ltYm9sVG9TZWFyY2hGb3IgPSBzeW1ib2wgPT09ICdYJyA/ICd4JyA6IHN5bWJvbDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0YXR1c0Zyb21SZWdpc3RyeSA9IHJlZ2lzdHJ5LmJ5U3ltYm9sKHN5bWJvbFRvU2VhcmNoRm9yKTtcbiAgICAgICAgaWYgKGRlZmF1bHRTdGF0dXNGcm9tUmVnaXN0cnkudHlwZSAhPT0gU3RhdHVzVHlwZS5FTVBUWSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24ubmV4dFN0YXR1c1N5bWJvbCAhPT0gZGVmYXVsdFN0YXR1c0Zyb21SZWdpc3RyeS5uZXh0U3RhdHVzU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGBOZXh0IFN0YXR1cyBTeW1ib2wgZm9yIHN5bWJvbCAnJHtzeW1ib2x9JzogJyR7Y29uZmlndXJhdGlvbi5uZXh0U3RhdHVzU3ltYm9sfScgaXMgaW5jb25zaXN0ZW50IHdpdGggY29udmVudGlvbiAnJHtkZWZhdWx0U3RhdHVzRnJvbVJlZ2lzdHJ5Lm5leHRTdGF0dXNTeW1ib2x9J2AsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnR5cGUgIT09IGRlZmF1bHRTdGF0dXNGcm9tUmVnaXN0cnkudHlwZSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBgU3RhdHVzIFR5cGUgZm9yIHN5bWJvbCAnJHtzeW1ib2x9JzogJyR7Y29uZmlndXJhdGlvbi50eXBlfScgaXMgaW5jb25zaXN0ZW50IHdpdGggY29udmVudGlvbiAnJHtkZWZhdWx0U3RhdHVzRnJvbVJlZ2lzdHJ5LnR5cGV9J2AsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGVPbmVTeW1ib2woc3ltYm9sOiBzdHJpbmcsIHN5bWJvbE5hbWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAoc3ltYm9sLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYCR7c3ltYm9sTmFtZX0gY2Fubm90IGJlIGVtcHR5LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN5bWJvbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgJHtzeW1ib2xOYW1lfSAoXCIke3N5bWJvbH1cIikgbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEVkaXRvclN1Z2dlc3QsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JQb3NpdGlvbiwgRWRpdG9yU3VnZ2VzdENvbnRleHQsIEVkaXRvclN1Z2dlc3RUcmlnZ2VySW5mbyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IHR5cGUgU2V0dGluZ3MsIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQgfSBmcm9tICcuLi9Db25maWcvU2V0dGluZ3MnO1xuaW1wb3J0IHsgY2FuU3VnZ2VzdEZvckxpbmUgfSBmcm9tICcuL1N1Z2dlc3Rvcic7XG5pbXBvcnQgdHlwZSB7IFN1Z2dlc3RJbmZvIH0gZnJvbSAnLic7XG5cbmV4cG9ydCB0eXBlIFN1Z2dlc3RJbmZvV2l0aENvbnRleHQgPSBTdWdnZXN0SW5mbyAmIHtcbiAgICBjb250ZXh0OiBFZGl0b3JTdWdnZXN0Q29udGV4dDtcbn07XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JTdWdnZXN0b3IgZXh0ZW5kcyBFZGl0b3JTdWdnZXN0PFN1Z2dlc3RJbmZvV2l0aENvbnRleHQ+IHtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBTZXR0aW5ncztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogU2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cblxuICAgIG9uVHJpZ2dlcihjdXJzb3I6IEVkaXRvclBvc2l0aW9uLCBlZGl0b3I6IEVkaXRvciwgX2ZpbGU6IFRGaWxlKTogRWRpdG9yU3VnZ2VzdFRyaWdnZXJJbmZvIHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hdXRvU3VnZ2VzdEluRWRpdG9yKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICAgICAgaWYgKGNhblN1Z2dlc3RGb3JMaW5lKGxpbmUsIGN1cnNvci5jaCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogY3Vyc29yLmxpbmUsIGNoOiAwIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGN1cnNvci5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjaDogbGluZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyeTogbGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoY29udGV4dDogRWRpdG9yU3VnZ2VzdENvbnRleHQpOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0W10ge1xuICAgICAgICBjb25zdCBsaW5lID0gY29udGV4dC5xdWVyeTtcbiAgICAgICAgY29uc3QgY3VycmVudEN1cnNvciA9IGNvbnRleHQuZWRpdG9yLmdldEN1cnNvcigpO1xuXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBTdWdnZXN0SW5mb1tdID1cbiAgICAgICAgICAgIGdldFVzZXJTZWxlY3RlZFRhc2tGb3JtYXQoKS5idWlsZFN1Z2dlc3Rpb25zPy4obGluZSwgY3VycmVudEN1cnNvci5jaCwgdGhpcy5zZXR0aW5ncykgPz8gW107XG5cbiAgICAgICAgLy8gQWRkIHRoZSBlZGl0b3IgY29udGV4dCB0byBhbGwgdGhlIHN1Z2dlc3Rpb25zXG4gICAgICAgIHJldHVybiBzdWdnZXN0aW9ucy5tYXAoKHMpID0+ICh7IC4uLnMsIGNvbnRleHQgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlclN1Z2dlc3Rpb24odmFsdWU6IFN1Z2dlc3RJbmZvV2l0aENvbnRleHQsIGVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBlbC5zZXRUZXh0KHZhbHVlLmRpc3BsYXlUZXh0KTtcbiAgICB9XG5cbiAgICBzZWxlY3RTdWdnZXN0aW9uKHZhbHVlOiBTdWdnZXN0SW5mb1dpdGhDb250ZXh0LCBfZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB2YWx1ZS5jb250ZXh0LmVkaXRvcjtcbiAgICAgICAgaWYgKHZhbHVlLnN1Z2dlc3Rpb25UeXBlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgc3VnZ2VzdGlvbiBkaWFsb2cgYW5kIHNpbXVsYXRlIGFuIEVudGVyIHByZXNzIHRvIHRoZSBlZGl0b3JcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2xvbmUgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnRW50ZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ0VudGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKGVkaXRvciBhcyBhbnkpPy5jbT8uY29udGVudERPTT8uZGlzcGF0Y2hFdmVudChldmVudENsb25lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Q3Vyc29yID0gdmFsdWUuY29udGV4dC5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VGcm9tID0ge1xuICAgICAgICAgICAgbGluZTogY3VycmVudEN1cnNvci5saW5lLFxuICAgICAgICAgICAgY2g6IHZhbHVlLmluc2VydEF0ID8/IGN1cnJlbnRDdXJzb3IuY2gsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcGxhY2VUbyA9IHZhbHVlLmluc2VydFNraXBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgbGluZTogY3VycmVudEN1cnNvci5saW5lLFxuICAgICAgICAgICAgICAgICAgY2g6IHJlcGxhY2VGcm9tLmNoICsgdmFsdWUuaW5zZXJ0U2tpcCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhbHVlLmNvbnRleHQuZWRpdG9yLnJlcGxhY2VSYW5nZSh2YWx1ZS5hcHBlbmRUZXh0LCByZXBsYWNlRnJvbSwgcmVwbGFjZVRvKTtcbiAgICAgICAgdmFsdWUuY29udGV4dC5lZGl0b3Iuc2V0Q3Vyc29yKHtcbiAgICAgICAgICAgIGxpbmU6IGN1cnJlbnRDdXJzb3IubGluZSxcbiAgICAgICAgICAgIGNoOiByZXBsYWNlRnJvbS5jaCArIHZhbHVlLmFwcGVuZFRleHQubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgdG8gcmVtb3ZlIGFsbCByZWZlcmVuY2VzIHRvIHtUYXNrTW9kYWx9IGluIHRoaXMgZmlsZS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIG1ha2Uge2NyZWF0ZVRhc2tMaW5lTW9kYWx9IHRlc3RhYmxlLlxuICogT25jZSBKZXN0IGlzIGNvbmZpZ3VyZWQgdG8gd29yayB3aXRoIFN2ZWx0ZSwgdGhpcyBjYW4gYmUgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJVGFza01vZGFsIHtcbiAgICBvcGVuKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogU2lnbmF0dXJlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZCBmb3Ige0BsaW5rIFRhc2tNb2RhbH0uXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYWtlIHtAbGluayBjcmVhdGVUYXNrTGluZU1vZGFsfSB0ZXN0YWJsZS5cbiAqIE9uY2UgSmVzdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgd2l0aCBTdmVsdGUsIHRoaXMgY2FuIGJlIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIHRhc2tNb2RhbEZhY3RvcnkgPSB7XG4gICAgKGFwcDogQXBwLCBvblN1Ym1pdDogKHVwZGF0ZWRUYXNrczogVGFza1tdKSA9PiB2b2lkKTogSVRhc2tNb2RhbDtcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIFRhc2tzIFVJIGFuZCByZXR1cm5zIHRoZSBNYXJrZG93biBzdHJpbmcgZm9yIHRoZSB0YXNrIGVudGVyZWQuXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHBcbiAqIEBwYXJhbSB0YXNrTW9kYWxGYWN0b3J5IC0gRmFjdG9yeSBtZXRob2QgdG8gaW5zdGFudGlhdGUge0BsaW5rIFRhc2tNb2RhbH0uIERlZmF1bHQgdmFsdWUgaXMge0BsaW5rIGRlZmF1bHRUYXNrTW9kYWxGYWN0b3J5fS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgVXNlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBNYXJrZG93biBzdHJpbmcgZm9yIHRoZSB0YXNrIGVudGVyZWQgb3JcbiAqIGFuIGVtcHR5IHN0cmluZywgaWYgZGF0YSBlbnRyeSB3YXMgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGFza0xpbmVNb2RhbCA9IChhcHA6IEFwcCwgdGFza01vZGFsRmFjdG9yeTogdGFza01vZGFsRmFjdG9yeSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlOiAoaW5wdXQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICBjb25zdCB3YWl0Rm9yQ2xvc2UgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfKSA9PiB7XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uU3VibWl0ID0gKHVwZGF0ZWRUYXNrczogVGFza1tdKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB1cGRhdGVkVGFza3MubWFwKCh0YXNrOiBUYXNrKSA9PiB0YXNrLnRvRmlsZUxpbmVTdHJpbmcoKSkuam9pbignXFxuJyk7XG4gICAgICAgIHJlc29sdmVQcm9taXNlKGxpbmUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0YXNrTW9kYWwgPSB0YXNrTW9kYWxGYWN0b3J5KGFwcCwgb25TdWJtaXQpO1xuICAgIHRhc2tNb2RhbC5vcGVuKCk7XG4gICAgcmV0dXJuIHdhaXRGb3JDbG9zZTtcbn07XG4iLCAiaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IFRhc2sgfSBmcm9tICcuLi9UYXNrJztcbmltcG9ydCB7IHRhc2tGcm9tTGluZSB9IGZyb20gJy4uL0NvbW1hbmRzL0NyZWF0ZU9yRWRpdFRhc2tQYXJzZXInO1xuaW1wb3J0IHsgVGFza01vZGFsIH0gZnJvbSAnLi4vVGFza01vZGFsJztcbmltcG9ydCB0eXBlIHsgSVRhc2tNb2RhbCwgdGFza01vZGFsRmFjdG9yeSB9IGZyb20gJy4vY3JlYXRlVGFza0xpbmVNb2RhbCc7XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IHtAbGluayBUYXNrTW9kYWx9LlxuICpcbiAqIFRoZSBjdXJyZW50IHNldHVwIG9mIEplc3QgZG9lcyBub3Qgd29yayB3aXRoIFN2ZWx0ZSwgdGhlcmVmb3JlIGl0IGlzIG5lY2Vzc2FyeSB0byByZW1vdmVcbiAqIGFsbCBjb2RlIHJlZmVyZW5jaW5nIHtAbGluayBFZGl0VGFza30gZnJvbSB0aGUgZmlsZSB7QGxpbmsgY3JlYXRlVGFza0xpbmVNb2RhbH0gbGl2ZXMgaW4sIHRvIG1ha2UgaXQgdGVzdGFibGUuXG4gKiBPbmNlIEplc3QgaXMgY29uZmlndXJlZCB0byB3b3JrIHdpdGggU3ZlbHRlLCB0aGlzIGNhbiBiZSBtb3ZlZCBpbiB0aGUgc2FtZSBmaWxlIGFzIHtAbGluayBjcmVhdGVUYXNrTGluZU1vZGFsfS5cbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcFxuICogQHBhcmFtIG9uU3VibWl0IC0gQ2FsbGJhY2sgdG8gYmUgcnVuIHdoZW4gdGhlIHtAbGluayBFZGl0VGFza30gZm9ybSBpcyBzdWJtaXR0ZWQgdG8gcmV0cmlldmUgdGhlIGVkaXRlZCB0YXNrLlxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFRhc2tNb2RhbEZhY3Rvcnk6IHRhc2tNb2RhbEZhY3RvcnkgPSAoXG4gICAgYXBwOiBBcHAsXG4gICAgb25TdWJtaXQ6ICh1cGRhdGVkVGFza3M6IFRhc2tbXSkgPT4gdm9pZCxcbik6IElUYXNrTW9kYWwgPT4ge1xuICAgIGNvbnN0IHRhc2sgPSB0YXNrRnJvbUxpbmUoeyBsaW5lOiAnJywgcGF0aDogJycgfSk7XG4gICAgcmV0dXJuIG5ldyBUYXNrTW9kYWwoeyBhcHAsIHRhc2ssIG9uU3VibWl0IH0pIGFzIElUYXNrTW9kYWw7XG59O1xuIiwgImltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgY3JlYXRlVGFza0xpbmVNb2RhbCB9IGZyb20gJy4vY3JlYXRlVGFza0xpbmVNb2RhbCc7XG5pbXBvcnQgdHlwZSB7IFRhc2tzQXBpVjEgfSBmcm9tICcuL1Rhc2tzQXBpVjEnO1xuaW1wb3J0IHsgZGVmYXVsdFRhc2tNb2RhbEZhY3RvcnkgfSBmcm9tICcuL2NyZWF0ZVRhc2tMaW5lTW9kYWxIZWxwZXInO1xuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIGZvciBBUEkgdjFcbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcFxuICovXG5leHBvcnQgY29uc3QgdGFza3NBcGlWMSA9IChhcHA6IEFwcCk6IFRhc2tzQXBpVjEgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZVRhc2tMaW5lTW9kYWw6ICgpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRhc2tMaW5lTW9kYWwoYXBwLCBkZWZhdWx0VGFza01vZGFsRmFjdG9yeSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxhQUFnQix3QkFBd0IsUUFBZ0IsdUJBQTZCO0FBQ2pGLFlBQU0saUNBQWlDLHNCQUFzQixRQUFRLGFBQWEsS0FBSztBQUN2RixhQUFPLEdBQUcsU0FBUyxzREFBc0Q7SUFDN0U7QUFIQSxZQUFBLDBCQUFBO0FBS0EsYUFBZ0IsYUFBYSxZQUEwQjtBQUNuRCxVQUFJO0FBQ0osVUFBSSxzQkFBc0IsT0FBTztBQUM3QixlQUFPLENBQUMsR0FBRyxVQUFVO2lCQUNkLHNCQUFzQixLQUFLO0FBQ2xDLGVBQU8sTUFBTSxLQUFNLFdBQW9DLEtBQUksQ0FBRTthQUMxRDtBQUNILGVBQU8sT0FBTyxLQUFLLFVBQVU7O0FBR2pDLGFBQU87SUFDWDtBQVhBLFlBQUEsZUFBQTtBQWFBLGFBQWdCLGdCQUFnQixZQUEwQjtBQUd0RCxZQUFNLGNBQWMsYUFBYSxVQUFVLEVBQ3RDLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUNsQyxLQUFLLEdBQUcsRUFDUixRQUFRLE9BQU8sS0FBSztBQUV6QixhQUFPLE1BQU07SUFDakI7QUFUQSxZQUFBLGtCQUFBOzs7OztBQ3BCQTtBQUFBLDZDQUFBQSxTQUFBO0FBQUEsS0FBQyxTQUFTLEdBQUUsR0FBRTtBQUFDLGtCQUFVLE9BQU8sV0FBUyxlQUFhLE9BQU9BLFVBQU9BLFFBQU8sVUFBUSxFQUFFLElBQUUsY0FBWSxPQUFPLFVBQVEsT0FBTyxNQUFJLE9BQU8sQ0FBQyxLQUFHLElBQUUsZUFBYSxPQUFPLGFBQVcsYUFBVyxLQUFHLE1BQU0sUUFBTSxFQUFFO0FBQUEsSUFBQyxFQUFFLFNBQU0sV0FBVTtBQUFDO0FBQWEsVUFBSSxJQUFFLEtBQUksSUFBRSxLQUFJLElBQUUsTUFBSyxJQUFFLGVBQWMsSUFBRSxVQUFTLElBQUUsVUFBUyxJQUFFLFFBQU8sSUFBRSxPQUFNLElBQUUsUUFBTyxJQUFFLFNBQVEsSUFBRSxXQUFVLElBQUUsUUFBTyxJQUFFLFFBQU8sSUFBRSxnQkFBZSxJQUFFLDhGQUE2RixJQUFFLHVGQUFzRixJQUFFLEVBQUMsTUFBSyxNQUFLLFVBQVMsMkRBQTJELE1BQU0sR0FBRyxHQUFFLFFBQU8sd0ZBQXdGLE1BQU0sR0FBRyxFQUFDLEdBQUUsSUFBRSxTQUFTQyxJQUFFQyxJQUFFQyxJQUFFO0FBQUMsWUFBSUMsS0FBRSxPQUFPSCxFQUFDO0FBQUUsZUFBTSxDQUFDRyxNQUFHQSxHQUFFLFVBQVFGLEtBQUVELEtBQUUsS0FBRyxNQUFNQyxLQUFFLElBQUVFLEdBQUUsTUFBTSxFQUFFLEtBQUtELEVBQUMsSUFBRUY7QUFBQSxNQUFDLEdBQUUsSUFBRSxFQUFDLEdBQUUsR0FBRSxHQUFFLFNBQVNBLElBQUU7QUFBQyxZQUFJQyxLQUFFLENBQUNELEdBQUUsVUFBVSxHQUFFRSxLQUFFLEtBQUssSUFBSUQsRUFBQyxHQUFFRSxLQUFFLEtBQUssTUFBTUQsS0FBRSxFQUFFLEdBQUVFLEtBQUVGLEtBQUU7QUFBRyxnQkFBT0QsTUFBRyxJQUFFLE1BQUksT0FBSyxFQUFFRSxJQUFFLEdBQUUsR0FBRyxJQUFFLE1BQUksRUFBRUMsSUFBRSxHQUFFLEdBQUc7QUFBQSxNQUFDLEdBQUUsR0FBRSxTQUFTSixHQUFFQyxJQUFFQyxJQUFFO0FBQUMsWUFBR0QsR0FBRSxLQUFLLElBQUVDLEdBQUUsS0FBSztBQUFFLGlCQUFNLENBQUNGLEdBQUVFLElBQUVELEVBQUM7QUFBRSxZQUFJRSxLQUFFLE1BQUlELEdBQUUsS0FBSyxJQUFFRCxHQUFFLEtBQUssTUFBSUMsR0FBRSxNQUFNLElBQUVELEdBQUUsTUFBTSxJQUFHRyxLQUFFSCxHQUFFLE1BQU0sRUFBRSxJQUFJRSxJQUFFLENBQUMsR0FBRUUsS0FBRUgsS0FBRUUsS0FBRSxHQUFFRSxLQUFFTCxHQUFFLE1BQU0sRUFBRSxJQUFJRSxNQUFHRSxLQUFFLEtBQUcsSUFBRyxDQUFDO0FBQUUsZUFBTSxFQUFFLEVBQUVGLE1BQUdELEtBQUVFLE9BQUlDLEtBQUVELEtBQUVFLEtBQUVBLEtBQUVGLFFBQUs7QUFBQSxNQUFFLEdBQUUsR0FBRSxTQUFTSixJQUFFO0FBQUMsZUFBT0EsS0FBRSxJQUFFLEtBQUssS0FBS0EsRUFBQyxLQUFHLElBQUUsS0FBSyxNQUFNQSxFQUFDO0FBQUEsTUFBQyxHQUFFLEdBQUUsU0FBU0EsSUFBRTtBQUFDLGVBQU0sRUFBQyxHQUFFLEdB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O0FBTEEsWUFBQSxtQkFBQTs7Ozs7Ozs7OztBQzVCYSxZQUFBLG9CQUFvQjtNQUM3QixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsT0FBTztNQUNQLE9BQU87TUFDUCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsSUFBSTtNQUNKLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxJQUFJO01BQ0osS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04s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Q04sT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLElBQUk7TUFDSixNQUFNO01BQ04sS0FBSztNQUNMLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsTUFBTTtNQUNOLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE1BQU07TUFDTixPQUFPO01BQ1AsTUFBTTtNQUNOLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01BQ1AsTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE1BQU07TUFDTixNQUFNO01BQ04sT0FBTztNQUNQLE1BQU07TUFDTixNQUFNO01BQ04sTUFBTTtNQUNOLEtBQUs7TUFDTCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxLQUFLO01BQ0wsT0FBTztNQUNQLE1BQU07TUFDTixLQUFLO01BQ0wsS0FBSztNQUNMLEtBQUs7TUFDTCxNQUFNO01BQ04sTUFBTTtNQUNOLE9BQU87TUFDUCxNQUFNO01BQ04sS0FBSztNQUNMLEtBQUs7TUFDTCxPQUFPO01B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QUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3ZCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLEVBQzdCO0FBQ0EsU0FBTztBQUNYOzs7QUN6Qk8sU0FBUywyQkFBMkI7QUFDdkMsUUFBTSxNQUF3QjtBQUFBLElBQzFCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxjQUFjLEtBQUssYUFBYTtBQUFBLElBQ3RDLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxZQUFZLEtBQUssV0FBVztBQUFBLElBQ2xDLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxjQUFjLEtBQUssTUFBTTtBQUFBLElBQy9CLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxlQUFlLEtBQUssTUFBTTtBQUFBLElBQ2hDLENBQUMsS0FBSyxXQUFXLEtBQUssTUFBTTtBQUFBLElBQzVCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ3hCLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLElBQ3ZCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLEVBQzdCO0FBQ0EsU0FBTztBQUNYOzs7QUMzQk8sU0FBUywwQkFBMEI7QUFDdEMsUUFBTSxNQUF3QjtBQUFBLElBRTFCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxjQUFjLEtBQUssYUFBYTtBQUFBLElBQ3RDLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxZQUFZLEtBQUssV0FBVztBQUFBLElBQ2xDLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxjQUFjLEtBQUssTUFBTTtBQUFBLElBRS9CLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUFBLElBQzlCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzFCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxZQUFZLEtBQUssTUFBTTtBQUFBLElBQzdCLENBQUMsS0FBSyxlQUFlLEtBQUssTUFBTTtBQUFBLElBQ2hDLENBQUMsS0FBSyxXQUFXLEtBQUssTUFBTTtBQUFBLElBQzVCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxRQUFRLEtBQUssTUFBTTtBQUFBLElBQ3pCLENBQUMsS0FBSyxPQUFPLEtBQUss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QUFtRlEsWUFBTyxVQUFLLFVBQUwsbUJBQVk7QUFBQSxFQUN2QjtBQUNKOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAidCIsICJlIiwgIm4iLCAiciIsICJpIiwgInMiLCAidSIsICJNIiwgIm0iLCAiaCIsICIkIiwgImwiLCAieSIsICJnIiwgIkQiLCAidiIsICJvIiwgImQiLCAiYSIsICJmIiwgImMiLCAibW9kdWxlIiwgInQiLCAiZSIsICJpIiwgInIiLCAicyIsICJ0ZXh0IiwgInRleHQiLCAiRmlsdGVyIiwgIl9hIiwgInRleHQiLCAidGV4dCIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJ0ZXh0IiwgInRleHQiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAicGFyc2UiLCAidGV4dCIsICJwYXJzZURhdGUiLCAidGV4dCIsICJwYXJzZSIsICJ0ZXh0IiwgInBhcnNlRGF0ZSIsICJ0ZXh0IiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgIk1lcmlkaWVtIiwgInBhcnNlIiwgInRleHQiLCAicGFyc2VEYXRlIiwgInJlcXVpcmVfZGlzdCIsICJPcGVyYXRvcnMiLCAiU3RydWN0dXJhbENoYXJhY3RlcnMiLCAiVG9rZW5zIiwgInJlcXVpcmVfY29uc3QiLCAiX19hc3NpZ24iLCAicmVxdWlyZV91dGlscyIsICJfX3NwcmVhZEFycmF5IiwgIl9fc3ByZWFkQXJyYXkiLCAicGFyc2UiLCAicmVxdWlyZV91dGlscyIsICJyZXF1aXJlX2NvbnN0IiwgIl9fc3ByZWFkQXJyYXkiLCAibW9kdWxlIiwgInVuZGVmaW5lZCIsICJpc0FycmF5IiwgImluaXQiLCAidG9BcnJheSIsICJQcm9taXNlIiwgInJlamVjdCIsICJldmVudCIsICJsaXN0ZW4iLCAiZXZlbnRzIiwgInNlbGYiLCAiaW1wb3J0X29ic2lkaWFuIiwgInJhbmdlIiwgInJhbmdlIiwgIldlZWtkYXkiLCAidHpPZmZzZXQiLCAiSXRlclJlc3VsdCIsICJkIiwgImIiLCAiX19hc3NpZ24iLCAiQ2FsbGJhY2tJdGVyUmVzdWx0IiwgIlRvVGV4dCIsICJQYXJzZXIiLCAidGV4dCIsICJGcmVxdWVuY3kiLCAidGV4dCIsICJUaW1lIiwgIkRhdGVUaW1lIiwgImF0dHIiLCAiRGF0ZVdpdGhab25lIiwgImRlZmF1bHRLZXlzIiwgImtleSIsICJ2YWx1ZSIsICJDYWNoZSIsICJpdGVtIiwgImkiLCAiSXRlcmluZm8iLCAiUlJ1bGUiLCAidGV4dCIsICJ6b25lZERhdGUiLCAiREVGQVVMVF9PUFRJT05TIiwgInZhbCIsICJpbml0aWFsaXplT3B0aW9ucyIsICJkZWZhdWx0S2V5cyIsICJSUnVsZVNldCIsICJ0ZXh0IiwgInNldHRpbmdzIiwgImxpbmUiLCAiZWxlbWVudCIsICJTdGF0dXNUeXBlIiwgImRlZmF1bHRTZXR0aW5ncyIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJDYWNoZSIsICJtZXRhZGF0YUNhY2hlIiwgInZhdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZWxlbWVudCIsICJfYSIsICJlbGVtZW50IiwgInRleHQiLCAiZWxlbWVudCIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiYXR0ciIsICJjdHgiLCAiYXBwIiwgImFwcCIsICJ0YXNrIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImlzQXJyYXkiLCAiZXNjYXBlUmVnRXhwIiwgInBhcnNlIiwgInNlbGYiLCAiY2xlYXJDYWNoZSIsICJyZW5kZXIiLCAidGV4dCIsICJwcm94eURhdGEiLCAiY2hpbGRyZW4iLCAiYm9vblBhcnNlIiwgInRleHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJtb2R1bGUiLCAidmF1bHQiLCAibWV0YWRhdGFDYWNoZSIsICJ3b3Jrc3BhY2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwRWxlbWVudCIsICJlbGVtZW50IiwgInRleHQiLCAiZWxlbWVudCIsICJfYSIsICJzZWN0aW9uSW5kZXgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJlbGVtZW50IiwgImFwcCIsICJ0ZXh0IiwgInZhdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAidGV4dCIsICJ1cGRhdGUiLCAidGV4dCIsICJzZXR0aW5ncyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgInNldHRpbmdzIiwgImFwcCIsICJhcHAiLCAiYXBwIiwgIkNhY2hlIl0KfQo=
