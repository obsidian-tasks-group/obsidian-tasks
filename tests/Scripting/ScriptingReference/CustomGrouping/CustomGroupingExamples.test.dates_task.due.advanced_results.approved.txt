Results of custom groupers



group by function task.due.format("dddd")
Group by day of the week (Monday, Tuesday, etc).
The day names are sorted alphabetically.
=>
Invalid date
Thursday
Tuesday
Wednesday
====================================================================================


group by function task.due.format("[%%]d[%%]dddd")
Group by day of the week (Sunday, Monday, Tuesday, etc).
The day names are sorted in date order, starting with Sunday.
=>
%%2%%Tuesday
%%3%%Wednesday
%%4%%Thursday
Invalid date
====================================================================================


group by function const date = task.due; return date.moment ? ( date.moment.day() === 0 ? date.format("[%%][8][%%]dddd") : date.format("[%%]d[%%]dddd") ) : "Undated"
Group by day of the week (Monday, Tuesday, etc).
The day names are sorted in date order, starting with Monday.
Tasks without due dates are displayed at the end, under a heading "Undated".
This is best understood by pasting it in to a Tasks block in Obsidian and then deleting parts of the expression.
The key technique is to say that if the day is Sunday (`0`), then force it to be displayed as date number `8`, so it comes after the other days of the week.
Note that because we use variables to avoid repetition of values, we need to add `return`
=>
%%2%%Tuesday
%%3%%Wednesday
%%4%%Thursday
Invalid date
Undated
====================================================================================


group by function const date = task.due.moment; return (!date) ? '%%4%% Undated' : date.isBefore(moment(), 'day') ? '%%1%% Overdue' : date.isSame(moment(), 'day') ? '%%2%% Today' : '%%3%% Future'
This gives exactly the same output as `group by function task.due.category.groupText`, and is shown here in case you want to customise the behaviour in some way.
Group task due dates in to 4 broad categories: `Overdue`, `Today`, `Future` and `Undated`, displayed in that order.
Try this on a line before `group by due` if there are a lot of due date headings, and you would like them to be broken down in to some kind of structure.
A limitation of Tasks expressions is that they each need to fit on a single line, so this uses nested ternary operators, making it powerful but very hard to read.
In fact, for ease of development and testing, it was written in a full-fledged development environment as a series of if/else blocks, and then automatically refactored in these nested ternary operators.
=>
%%1%% Overdue
%%2%% Today
%%3%% Future
%%4%% Undated
====================================================================================


group by function const date = task.due.moment; return (!date) ? '%%4%% ==Undated==' : date.isBefore(moment(), 'day') ? '%%1%% ==Overdue==' : date.isSame(moment(), 'day') ? '%%2%% ==Today==' : '%%3%% ==Future=='
As above, but the headings `Overdue`, `Today`, `Future` and `Undated` are highlighted.
See the sample screenshot below.
=>
%%1%% ==Overdue==
%%2%% ==Today==
%%3%% ==Future==
%%4%% ==Undated==
====================================================================================


group by function const date = task.due.moment; const now = moment(); const label = (order, name) => `%%${order}%% ==${name}==`; if (!date) return label(4, 'Undated'); if (date.isBefore(now, 'day')) return label(1, 'Overdue'); if (date.isSame(now, 'day')) return label(2, 'Today'); return label(3, 'Future');
As above, but using a local function, and `if` statements.
=>
%%1%% ==Overdue==
%%2%% ==Today==
%%3%% ==Future==
%%4%% ==Undated==
====================================================================================

